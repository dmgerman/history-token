multiline_comment|/*&n; *  arch/mips/pmc-sierra/yosemite/i2c-yosemite.c&n; *&n; *  Copyright (C) 2003 PMC-Sierra Inc.&n; *  Author: Manish Lachwani (lachwani@pmc-sierra.com)&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * Detailed Description:&n; *&n; * This block implements the I2C interface to the slave devices like the Atmel 24C32&n; * EEPROM and the MAX 1619 Sensors device. The I2C Master interface can be controlled&n; * by the SCMB block. And the SCMB block kicks in only when using the Ethernet Mode of&n; * operation and __not__ the SysAD mode&n; *&n; * The SCMB controls the two modes: MDIO and the I2C. The MDIO mode is used to communicate&n; * with the Quad-PHY from Marvel. The I2C is used to communicate with the I2C slave devices.&n; * It seems that the driver does not explicitly deal with the control of SDA and SCL serial&n; * lines. So, the driver will set the slave address, drive the command and then the data. &n; * The SCMB will then control the two serial lines as required. &n; *&n; * It seems the documents are very unclear abt this. Hence, I took some time out to write&n; * the desciption to have an idea of how the I2C can actually work. Currently, this Linux &n; * driver wont be integrated into the generic Linux I2C framework. And finally, the I2C &n; * interface is also known as the 2BI interface. 2BI means 2-bit interface referring to&n; * SDA and SCL serial lines respectively.&n; *&n; * - Manish Lachwani (12/09/2003)&n; */
macro_line|#include &quot;i2c-yosemite.h&quot;
multiline_comment|/*&n; * Poll the I2C interface for the BUSY bit. &n; */
DECL|function|titan_i2c_poll
r_static
r_int
id|titan_i2c_poll
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TITAN_I2C_MAX_POLL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|TITAN_I2C_READ
c_func
(paren
id|TITAN_I2C_COMMAND
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
l_int|0x8000
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|TITAN_I2C_ERR_TIMEOUT
suffix:semicolon
)brace
multiline_comment|/*&n; * Execute the I2C command&n; */
DECL|function|titan_i2c_xfer
r_int
id|titan_i2c_xfer
c_func
(paren
r_int
r_int
id|slave_addr
comma
id|titan_i2c_command
op_star
id|cmd
comma
r_int
id|size
comma
r_int
r_int
op_star
id|addr
)paren
(brace
r_int
id|loop
op_assign
l_int|0
comma
id|bytes
comma
id|i
suffix:semicolon
r_int
r_int
op_star
id|write_data
comma
id|data
comma
op_star
id|read_data
suffix:semicolon
r_int
r_int
id|reg_val
comma
id|val
suffix:semicolon
id|write_data
op_assign
id|cmd-&gt;data
suffix:semicolon
id|read_data
op_assign
id|addr
suffix:semicolon
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_SLAVE_ADDRESS
comma
id|slave_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;type
op_eq
id|TITAN_I2C_CMD_WRITE
)paren
id|loop
op_assign
id|cmd-&gt;write_size
suffix:semicolon
r_else
id|loop
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
id|loop
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|cmd-&gt;type
op_eq
id|TITAN_I2C_CMD_WRITE
)paren
op_logical_or
(paren
id|cmd-&gt;type
op_eq
id|TITAN_I2C_CMD_READ_WRITE
)paren
)paren
(brace
id|reg_val
op_assign
id|TITAN_I2C_DATA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TITAN_I2C_MAX_WORDS_PER_RW
suffix:semicolon
op_increment
id|i
comma
id|write_data
op_add_assign
l_int|2
comma
id|reg_val
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|bytes
OL
id|cmd-&gt;write_size
)paren
(brace
id|data
op_assign
id|write_data
(braket
l_int|0
)braket
suffix:semicolon
op_increment
id|data
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bytes
OL
id|cmd-&gt;write_size
)paren
(brace
id|data
op_assign
id|write_data
(braket
l_int|1
)braket
suffix:semicolon
op_increment
id|data
suffix:semicolon
)brace
id|TITAN_I2C_WRITE
c_func
(paren
id|reg_val
comma
id|data
)paren
suffix:semicolon
)brace
)brace
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_COMMAND
comma
(paren
r_int
r_int
)paren
(paren
id|cmd-&gt;type
op_lshift
l_int|13
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|titan_i2c_poll
c_func
(paren
)paren
op_ne
id|TITAN_I2C_ERR_OK
)paren
r_return
id|TITAN_I2C_ERR_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;type
op_eq
id|TITAN_I2C_CMD_READ
)paren
op_logical_or
(paren
id|cmd-&gt;type
op_eq
id|TITAN_I2C_CMD_READ_WRITE
)paren
)paren
(brace
id|reg_val
op_assign
id|TITAN_I2C_DATA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TITAN_I2C_MAX_WORDS_PER_RW
suffix:semicolon
op_increment
id|i
comma
id|read_data
op_add_assign
l_int|2
comma
id|reg_val
op_add_assign
l_int|4
)paren
(brace
id|data
op_assign
id|TITAN_I2C_READ
c_func
(paren
id|reg_val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OL
id|size
)paren
(brace
id|read_data
(braket
l_int|0
)braket
op_assign
id|data
op_amp
l_int|0xff
suffix:semicolon
op_increment
id|bytes
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bytes
OL
id|size
)paren
(brace
id|read_data
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
op_increment
id|bytes
suffix:semicolon
)brace
)brace
)brace
id|loop
op_sub_assign
(paren
id|TITAN_I2C_MAX_WORDS_PER_RW
op_star
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the Interrupt status and then return the appropriate error code &n;&t; */
id|val
op_assign
id|TITAN_I2C_READ
c_func
(paren
id|TITAN_I2C_INTERRUPTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x0020
)paren
r_return
id|TITAN_I2C_ERR_ARB_LOST
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x0040
)paren
r_return
id|TITAN_I2C_ERR_NO_RESP
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x0080
)paren
r_return
id|TITAN_I2C_ERR_DATA_COLLISION
suffix:semicolon
r_return
id|TITAN_I2C_ERR_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * Init the I2C subsystem of the PMC-Sierra Yosemite board&n; */
DECL|function|titan_i2c_init
r_int
id|titan_i2c_init
c_func
(paren
id|titan_i2c_config
op_star
id|config
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the SCMB and program into the I2C mode&n;&t; */
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_SCMB_CONTROL
comma
l_int|0xA000
)paren
suffix:semicolon
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_SCMB_CONTROL
comma
l_int|0x2000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Configure the filtera and clka values&n;&t; */
id|val
op_assign
id|TITAN_I2C_READ
c_func
(paren
id|TITAN_I2C_SCMB_CLOCK_A
)paren
suffix:semicolon
id|val
op_or_assign
(paren
(paren
id|val
op_amp
op_complement
(paren
l_int|0xF000
)paren
)paren
op_or
(paren
(paren
id|config-&gt;filtera
op_lshift
l_int|12
)paren
op_amp
l_int|0xF000
)paren
)paren
suffix:semicolon
id|val
op_or_assign
(paren
(paren
id|val
op_amp
op_complement
(paren
l_int|0x03FF
)paren
)paren
op_or
(paren
id|config-&gt;clka
op_amp
l_int|0x03FF
)paren
)paren
suffix:semicolon
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_SCMB_CLOCK_A
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Configure the filterb and clkb values&n;&t; */
id|val
op_assign
id|TITAN_I2C_READ
c_func
(paren
id|TITAN_I2C_SCMB_CLOCK_B
)paren
suffix:semicolon
id|val
op_or_assign
(paren
(paren
id|val
op_amp
op_complement
(paren
l_int|0xF000
)paren
)paren
op_or
(paren
(paren
id|config-&gt;filterb
op_lshift
l_int|12
)paren
op_amp
l_int|0xF000
)paren
)paren
suffix:semicolon
id|val
op_or_assign
(paren
(paren
id|val
op_amp
op_complement
(paren
l_int|0x03FF
)paren
)paren
op_or
(paren
id|config-&gt;clkb
op_amp
l_int|0x03FF
)paren
)paren
suffix:semicolon
id|TITAN_I2C_WRITE
c_func
(paren
id|TITAN_I2C_SCMB_CLOCK_B
comma
id|val
)paren
suffix:semicolon
r_return
id|TITAN_I2C_ERR_OK
suffix:semicolon
)brace
eof
