multiline_comment|/* i2o.c - Drivers for the I2O */
multiline_comment|/* Copyright - Galileo technology. */
multiline_comment|/*includes*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#ifdef __linux__
macro_line|#include &lt;asm/galileo-boards/evb64120A/core.h&gt;
macro_line|#include &lt;asm/galileo-boards/evb64120A/i2o.h&gt;
macro_line|#else
macro_line|#include &quot;Core.h&quot;
macro_line|#include &quot;i2o.h&quot;
macro_line|#endif
multiline_comment|/********************************************************************&n;* getInBoundMessage - When the GT is configured for I2O support&n;*                     it can receive a message from an agent on the pci bus.&n;*                     This message is a 32 bit wide and can be read by&n;*                     the CPU.&n;*                     The messaging unit contains two sets of registers&n;*                     so, actually it can receive a 64 bit message.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: Data received from the remote agent.&n;*********************************************************************/
DECL|function|getInBoundMessage
r_int
r_int
id|getInBoundMessage
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_int
r_int
id|regValue
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_MESSAGE_REGISTER0_CPU_SIDE
op_plus
l_int|4
op_star
id|messageRegNum
comma
op_amp
id|regValue
)paren
suffix:semicolon
r_return
(paren
id|regValue
)paren
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* checkInboundIntAndClear - When a message is received an interrupt is&n;*                           generated, to enable polling instead the use of&n;*                           an interrupt handler the user can use this fuction.&n;*                           You will need to mask the incomming interrupt for&n;*                           proper use.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true if the corresponding bit in the cause register is set otherwise&n;*          false.&n;*********************************************************************/
DECL|function|checkInBoundIntAndClear
r_bool
id|checkInBoundIntAndClear
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_int
r_int
id|regValue
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
op_amp
id|regValue
)paren
suffix:semicolon
multiline_comment|/* clears bit 0 for message register 0 or bit 1 for message register 1 */
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
id|BIT1
op_star
id|messageRegNum
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
r_if
c_cond
(paren
id|regValue
op_amp
id|BIT0
)paren
r_return
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
r_if
c_cond
(paren
id|regValue
op_amp
id|BIT1
)paren
r_return
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* sendOutBoundMessage - When the GT is configured for I2O support&n;*                     it can send a message to an agent on the pci bus.&n;*                     This message is a 32 bit wide and can be read by&n;*                     the PCI agent.&n;*                     The messaging unit contains two sets of registers&n;*                     so, actually it can send a 64 bit message.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;*         unsigned int message - Message to be sent.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|sendOutBoundMessage
r_bool
id|sendOutBoundMessage
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
comma
r_int
r_int
id|message
)paren
(brace
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_MESSAGE_REGISTER0_CPU_SIDE
op_plus
l_int|4
op_star
id|messageRegNum
comma
id|message
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* checkOutboundInt - When the CPU sends a message to the Outbound&n;*                    register it generates an interrupt which is refelcted on&n;*                    the Outbound Interrupt cause register, the interrupt can&n;*                    be cleard only by the PCI agent which read the message.&n;*                    After sending the message you can acknowledge it by&n;*                    monitoring the corresponding bit in the cause register.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true if the corresponding bit in the cause register is set otherwise&n;*          false.&n;*********************************************************************/
DECL|function|outBoundMessageAcknowledge
r_bool
id|outBoundMessageAcknowledge
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_int
r_int
id|regValue
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
op_amp
id|regValue
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
r_if
c_cond
(paren
id|regValue
op_amp
id|BIT0
)paren
r_return
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
r_if
c_cond
(paren
id|regValue
op_amp
id|BIT1
)paren
r_return
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* maskInBoundMessageInterrupt - Mask the inbound interrupt, when masking&n;*                               the interrupt you can work in polling mode&n;*                               using the checkInboundIntAndClear function.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|maskInBoundMessageInterrupt
r_bool
id|maskInBoundMessageInterrupt
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
id|SET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
id|SET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* enableInBoundMessageInterrupt - unMask the inbound interrupt.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|enableInBoundMessageInterrupt
r_bool
id|enableInBoundMessageInterrupt
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
id|RESET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
id|RESET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* maskOutboundMessageInterrupt - Mask the out bound interrupt, when doing so&n;*                           the PCI agent needs to poll on the interrupt&n;*                           cause register to monitor an incoming message.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|maskOutBoundMessageInterrupt
r_bool
id|maskOutBoundMessageInterrupt
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
id|SET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
id|SET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* enableOutboundMessageInterrupt - Mask the out bound interrupt, when doing so&n;*                           the PCI agent needs to poll on the interrupt&n;*                           cause register to monitor an incoming message.&n;*&n;* INPUTS: I2O_MESSAGE_REG messageRegNum - Selected set (0 or 1) register.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|enableOutBoundMessageInterrupt
r_bool
id|enableOutBoundMessageInterrupt
c_func
(paren
id|I2O_MESSAGE_REG
id|messageRegNum
)paren
(brace
r_switch
c_cond
(paren
id|messageRegNum
)paren
(brace
r_case
id|MESSAGE_REG_0
suffix:colon
id|RESET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REG_1
suffix:colon
id|RESET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* initiateOutBoundDoorBellInt - Setting a bit in this register to &squot;1&squot; by the&n;*                       CPU generates a PCI interrupt (if it is not masked by&n;*                       the Outbound interrupt Mask register)&n;*                       Only the PCI agent which recieved the interrupt can&n;*                       clear it, only after clearing all the bits the&n;*                       interrupt will be de-asserted.&n;*&n;* INPUTS: unsigned int data - Requested interrupt bits.&n;* OUTPUT: N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|initiateOutBoundDoorBellInt
r_bool
id|initiateOutBoundDoorBellInt
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_DOORBELL_REGISTER_CPU_SIDE
comma
id|data
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* readInBoundDoorBellInt - Read the in bound door bell interrupt cause&n;*                          register.&n;*&n;* OUTPUT:  N/A.&n;* RETURNS: The 32 bit interrupt cause register.&n;*********************************************************************/
DECL|function|readInBoundDoorBellInt
r_int
r_int
id|readInBoundDoorBellInt
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_DOORBELL_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
r_return
id|regData
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* clearInBoundDoorBellInt - An interrupt generated by a PCI agent through&n;*                           the in bound door bell mechanisem can be cleared&n;*                           only by the CPU. The interrupt will be de-asserted&n;*                           only if all the bits which where set by the PCI&n;*                           agent are cleared.&n;*&n;* INPUTS:  unsigned int data - Bits to be cleared.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|clearInBoundDoorBellInt
r_bool
id|clearInBoundDoorBellInt
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_DOORBELL_REGISTER_CPU_SIDE
comma
id|data
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* isInBoundDoorBellInterruptSet - Check if Inbound Doorbell Interrupt is set,&n;*                                 can be used for polling mode.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true if the corresponding bit in the cause register is set otherwise&n;*          false.&n;*********************************************************************/
DECL|function|isInBoundDoorBellInterruptSet
r_bool
id|isInBoundDoorBellInterruptSet
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
r_return
(paren
id|regData
op_amp
id|BIT2
)paren
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* isOutBoundDoorBellInterruptSet - Check if out bound Doorbell Interrupt is&n;*                                  set, can be used for acknowledging interrupt&n;*                                  handling by the agent who recieived the&n;*                                  interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true if the corresponding bit in the cause register is set otherwise&n;*          false.&n;*********************************************************************/
DECL|function|isOutBoundDoorBellInterruptSet
r_bool
id|isOutBoundDoorBellInterruptSet
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
r_return
(paren
id|regData
op_amp
id|BIT2
)paren
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* maskInboundDoorBellInterrupt - Mask the Inbound Doorbell Interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|maskInBoundDoorBellInterrupt
r_bool
id|maskInBoundDoorBellInterrupt
c_func
(paren
)paren
(brace
id|SET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT2
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* enableInboundDoorBellInterrupt - unMask the Inbound Doorbell Interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|enableInBoundDoorBellInterrupt
r_bool
id|enableInBoundDoorBellInterrupt
c_func
(paren
)paren
(brace
id|RESET_REG_BITS
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT2
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* maskOutboundDoorBellInterrupt - Mask the Outbound Doorbell Interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|maskOutBoundDoorBellInterrupt
r_bool
id|maskOutBoundDoorBellInterrupt
c_func
(paren
)paren
(brace
id|SET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT2
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* enableOutboundDoorBellInterrupt - unMask the Outbound Doorbell Interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|enableOutBoundDoorBellInterrupt
r_bool
id|enableOutBoundDoorBellInterrupt
c_func
(paren
)paren
(brace
id|RESET_REG_BITS
c_func
(paren
id|OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|BIT2
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* circularQueueEnable - Initialize the I2O messaging mechanism.&n;*&n;* INPUTS:   CIRCULE_QUEUE_SIZE cirQueSize - Bits 5:1 in the:&n;*           Queue Control Register, Offset 0x50 (0x1c50).&n;*           Defines the queues size (refer to the data sheet&n;*           for more information)&n;*          unsigned int queueBaseAddr - The base address for the first queue.&n;*           The other queues base Address will be determined as follows:&n;*           Inbound Free = queueBaseAddr&n;*           Inbound Post = queueBaseAddr + cirQueSize&n;*           Outbound Post = queueBaseAddr + cirQueSize&n;*&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*&n;*  The Circular Queue Starting Addresses as written in the spec:&n;*  ----------------------------------------&n;*  |    Queue       |  Starting Address   |&n;*  |----------------|---------------------|&n;*  | Inbound Free   |       QBAR          |&n;*  | Inbound Post   | QBAR + Queue Size   |&n;*  | Outbound Post  | QBAR + 2*Queue Size |&n;*  | Outbound Free  | QBAR + 3*Queue Size |&n;*  ----------------------------------------&n;*********************************************************************/
DECL|function|circularQueueEnable
r_bool
id|circularQueueEnable
c_func
(paren
id|CIRCULAR_QUEUE_SIZE
id|cirQueSize
comma
r_int
r_int
id|queueBaseAddr
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|regData
op_assign
id|BIT0
op_or
(paren
id|cirQueSize
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Enable Queue Operation */
id|GT_REG_WRITE
c_func
(paren
id|QUEUE_CONTROL_REGISTER_CPU_SIDE
comma
id|regData
)paren
suffix:semicolon
multiline_comment|/* Writing The base Address for the 4 Queues */
id|GT_REG_WRITE
c_func
(paren
id|QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE
comma
id|queueBaseAddr
)paren
suffix:semicolon
multiline_comment|/* Update The Inbound Free Queue Base Address, offset=0 */
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
l_int|0
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Update The Inbound Post Queue Base Address, offset=_16K*cirQueSize */
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE
comma
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE
comma
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
multiline_comment|/* Update The Outbound Post Queue Base Address, offset=2*_16K*cirQueSize */
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE
comma
l_int|2
op_star
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE
comma
l_int|2
op_star
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
multiline_comment|/* Update The Outbound Free Queue Base Address, offset=3*_16K*cirQueSize */
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
l_int|3
op_star
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
l_int|3
op_star
id|_16K
op_star
id|cirQueSize
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* inBoundPostQueuePop - Two actions are being taken upon pop:&n;*           1) Getting out the data from the Queue`s head.&n;*           2) Increment the tail pointer in a cyclic way (The HEAD is&n;*              incremented automaticaly by the GT)&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: Data pointed by tail.&n;*********************************************************************/
DECL|function|inBoundPostQueuePop
r_int
r_int
id|inBoundPostQueuePop
c_func
(paren
)paren
(brace
r_int
r_int
id|tailAddrPointer
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
r_int
r_int
id|cirQueSize
suffix:semicolon
r_int
r_int
id|qBar
suffix:semicolon
r_int
r_int
id|inBoundPostQbase
suffix:semicolon
multiline_comment|/* Gets the Inbound Post TAIL pointer */
id|GT_REG_READ
c_func
(paren
id|INBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|tailAddrPointer
)paren
suffix:semicolon
multiline_comment|/* Gets the Data From the pointer Address */
id|READ_WORD
c_func
(paren
id|tailAddrPointer
comma
op_amp
id|data
)paren
suffix:semicolon
multiline_comment|/* incrementing head process: */
multiline_comment|/* Gets the fifo&squot;s base Address */
id|GT_REG_READ
c_func
(paren
id|QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE
comma
op_amp
id|qBar
)paren
suffix:semicolon
id|qBar
op_assign
id|qBar
op_amp
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* Gets the fifo&squot;s size */
id|GT_REG_READ
c_func
(paren
id|QUEUE_CONTROL_REGISTER_CPU_SIDE
comma
op_amp
id|cirQueSize
)paren
suffix:semicolon
id|cirQueSize
op_assign
l_int|0x1f
op_logical_and
(paren
id|cirQueSize
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculating The Inbound Post Queue Base Address */
id|inBoundPostQbase
op_assign
id|qBar
op_plus
l_int|1
op_star
id|cirQueSize
op_star
id|_16K
suffix:semicolon
multiline_comment|/* incrementing Inbound Post queue TAIL in a cyclic loop */
id|tailAddrPointer
op_assign
id|inBoundPostQbase
op_plus
(paren
(paren
id|tailAddrPointer
op_plus
l_int|4
)paren
op_mod
(paren
id|_16K
op_star
id|cirQueSize
)paren
)paren
suffix:semicolon
multiline_comment|/* updating the pointer back to INBOUND_POST_TAIL_POINTER_REGISTER */
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE
comma
id|tailAddrPointer
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* isInBoundPostQueueInterruptSet - Check if in bound interrupt is set.&n;*                                  can be used for polling mode.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true if the corresponding bit in the cause register is set otherwise&n;*          false.&n;*********************************************************************/
DECL|function|isInBoundPostQueueInterruptSet
r_bool
id|isInBoundPostQueueInterruptSet
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
r_return
(paren
id|regData
op_amp
id|BIT4
)paren
suffix:semicolon
multiline_comment|/* if set return &squot;1&squot; (true), else &squot;0&squot; (false) */
)brace
multiline_comment|/********************************************************************&n;* clearInBoundPostQueueInterrupt - Clears the Post queue interrupt.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|clearInBoundPostQueueInterrupt
r_bool
id|clearInBoundPostQueueInterrupt
c_func
(paren
)paren
(brace
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE
comma
id|BIT4
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* maskInBoundPostQueueInterrupt - Mask the inbound interrupt, when masking&n;*                                 the interrupt you can work in polling mode.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS:&n;*********************************************************************/
DECL|function|maskInBoundPostQueueInterrupt
r_void
id|maskInBoundPostQueueInterrupt
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|regData
op_or
id|BIT4
)paren
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* enableInBoundPostQueueInterrupt - Enable interrupt when ever there is a new&n;*                                   message from the PCI agent.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS:&n;*********************************************************************/
DECL|function|enableInBoundPostQueueInterrupt
r_void
id|enableInBoundPostQueueInterrupt
c_func
(paren
)paren
(brace
r_int
r_int
id|regData
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
op_amp
id|regData
)paren
suffix:semicolon
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE
comma
id|regData
op_amp
l_int|0xfffffffb
)paren
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* inBoundFreeQueuePush - Two actions are being taken upon push:&n;*           1) Place the user`s data on the Queue`s head.&n;*           2) Increment the haed pointer in a cyclic way (The tail is&n;*              decremented automaticaly by the GT)&n;*&n;* INPUTS:  unsigned int data - Data to be placed in the queue.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|inBoundFreeQueuePush
r_bool
id|inBoundFreeQueuePush
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|headPointer
suffix:semicolon
r_int
r_int
id|cirQueSize
suffix:semicolon
r_int
r_int
id|qBar
suffix:semicolon
r_int
r_int
id|inBoundFreeQbase
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|headPointer
)paren
suffix:semicolon
multiline_comment|/* placing the data in the queue */
id|WRITE_WORD
c_func
(paren
id|headPointer
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* incrementing head process: */
multiline_comment|/* Gets the fifo&squot;s base Address */
id|GT_REG_READ
c_func
(paren
id|QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE
comma
op_amp
id|qBar
)paren
suffix:semicolon
id|qBar
op_assign
id|qBar
op_amp
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* Gets the fifo&squot;s size */
id|GT_REG_READ
c_func
(paren
id|QUEUE_CONTROL_REGISTER_CPU_SIDE
comma
op_amp
id|cirQueSize
)paren
suffix:semicolon
id|cirQueSize
op_assign
l_int|0x1f
op_logical_and
(paren
id|cirQueSize
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculating The Inbound Free Queue Base Address */
id|inBoundFreeQbase
op_assign
id|qBar
suffix:semicolon
multiline_comment|/* incrementing Inbound Free queue HEAD in a cyclic loop */
id|headPointer
op_assign
id|inBoundFreeQbase
op_plus
(paren
(paren
id|headPointer
op_plus
l_int|4
)paren
op_mod
(paren
id|_16K
op_star
id|cirQueSize
)paren
)paren
suffix:semicolon
multiline_comment|/* updating the pointer back to OUTBOUND_POST_HEAD_POINTER_REGISTER */
id|GT_REG_WRITE
c_func
(paren
id|INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
id|headPointer
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* isInBoundFreeQueueEmpty - Check if Inbound Free Queue Empty.&n;*                           Can be used for acknowledging the messages&n;*                           being sent by us to the PCI agent.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true if the queue is empty , otherwise false.&n;*********************************************************************/
DECL|function|isInBoundFreeQueueEmpty
r_bool
id|isInBoundFreeQueueEmpty
c_func
(paren
)paren
(brace
r_int
r_int
id|inBoundFreeQueHead
suffix:semicolon
r_int
r_int
id|inBoundFreeQueTail
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|inBoundFreeQueHead
)paren
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|inBoundFreeQueTail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inBoundFreeQueHead
op_eq
id|inBoundFreeQueTail
)paren
(brace
r_return
l_bool|true
suffix:semicolon
)brace
r_else
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* outBoundPostQueuePush  - Two actions are being taken upon push:&n;*           1) Place the user`s data on the Queue`s head.&n;*           2) Increment the haed pointer in a cyclic way (The tail is&n;*              decremented automaticaly by the GT when the Agent on the&n;*              PCI have read data from the Outbound Port).&n;*&n;* INPUTS:  unsigned int data - Data to be placed in the queue`s head.&n;* OUTPUT:  N/A.&n;* RETURNS: true.&n;*********************************************************************/
DECL|function|outBoundPostQueuePush
r_bool
id|outBoundPostQueuePush
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|headPointer
suffix:semicolon
r_int
r_int
id|cirQueSize
suffix:semicolon
r_int
r_int
id|qBar
suffix:semicolon
r_int
r_int
id|outBoundPostQbase
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|headPointer
)paren
suffix:semicolon
multiline_comment|/* placing the data in the queue (where the head point to..) */
id|WRITE_WORD
c_func
(paren
id|headPointer
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* incrementing head process: */
multiline_comment|/* Gets the fifo&squot;s base Address */
id|GT_REG_READ
c_func
(paren
id|QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE
comma
op_amp
id|qBar
)paren
suffix:semicolon
id|qBar
op_assign
id|qBar
op_amp
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* Gets the fifo&squot;s size */
id|GT_REG_READ
c_func
(paren
id|QUEUE_CONTROL_REGISTER_CPU_SIDE
comma
op_amp
id|cirQueSize
)paren
suffix:semicolon
id|cirQueSize
op_assign
l_int|0x1f
op_logical_and
(paren
id|cirQueSize
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculating The Outbound Post Queue Base Address */
id|outBoundPostQbase
op_assign
id|qBar
op_plus
l_int|2
op_star
id|cirQueSize
op_star
id|_16K
suffix:semicolon
multiline_comment|/* incrementing Outbound Post queue in a cyclic loop */
id|headPointer
op_assign
id|outBoundPostQbase
op_plus
(paren
(paren
id|headPointer
op_plus
l_int|4
)paren
op_mod
(paren
id|_16K
op_star
id|cirQueSize
)paren
)paren
suffix:semicolon
multiline_comment|/* updating the pointer back to OUTBOUND_POST_HEAD_POINTER_REGISTER */
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE
comma
id|headPointer
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* isOutBoundPostQueueEmpty - Check if Outbound Post Queue Empty.&n;*                            Can be used for acknowledging the messages&n;*                            being sent by us to the PCI agent.&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: true if the queue is empty , otherwise false.&n;*********************************************************************/
DECL|function|isOutBoundPostQueueEmpty
r_bool
id|isOutBoundPostQueueEmpty
c_func
(paren
)paren
(brace
r_int
r_int
id|outBoundPostQueHead
suffix:semicolon
r_int
r_int
id|outBoundPostQueTail
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|outBoundPostQueHead
)paren
suffix:semicolon
id|GT_REG_READ
c_func
(paren
id|INBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|outBoundPostQueTail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outBoundPostQueHead
op_eq
id|outBoundPostQueTail
)paren
(brace
r_return
l_bool|true
suffix:semicolon
)brace
r_else
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;* outBoundFreeQueuePop - Two actions are being taken upon pop:&n;*           1) Getting out the data from the Queue`s head.&n;*           2) Increment the tail pointer in a cyclic way (The HEAD is&n;*              incremented automaticaly by the GT)&n;*&n;* INPUTS:  N/A.&n;* OUTPUT:  N/A.&n;* RETURNS: Data pointed by tail.&n;*********************************************************************/
DECL|function|outBoundFreeQueuePop
r_int
r_int
id|outBoundFreeQueuePop
c_func
(paren
)paren
(brace
r_int
r_int
id|tailAddrPointer
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
r_int
r_int
id|cirQueSize
suffix:semicolon
r_int
r_int
id|qBar
suffix:semicolon
r_int
r_int
id|outBoundFreeQbase
suffix:semicolon
multiline_comment|/* Gets the Inbound Post TAIL pointer */
id|GT_REG_READ
c_func
(paren
id|OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
op_amp
id|tailAddrPointer
)paren
suffix:semicolon
multiline_comment|/* Gets the Data From the pointer Address */
id|READ_WORD
c_func
(paren
id|tailAddrPointer
comma
op_amp
id|data
)paren
suffix:semicolon
multiline_comment|/* incrementing head process: */
multiline_comment|/* Gets the fifo&squot;s base Address */
id|GT_REG_READ
c_func
(paren
id|QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE
comma
op_amp
id|qBar
)paren
suffix:semicolon
id|qBar
op_assign
id|qBar
op_amp
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* Gets the fifo&squot;s size */
id|GT_REG_READ
c_func
(paren
id|QUEUE_CONTROL_REGISTER_CPU_SIDE
comma
op_amp
id|cirQueSize
)paren
suffix:semicolon
id|cirQueSize
op_assign
l_int|0x1f
op_logical_and
(paren
id|cirQueSize
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculating The Inbound Post Queue Base Address */
id|outBoundFreeQbase
op_assign
id|qBar
op_plus
l_int|3
op_star
id|cirQueSize
op_star
id|_16K
suffix:semicolon
multiline_comment|/* incrementing Outbound Free queue TAlL in a cyclic loop */
id|tailAddrPointer
op_assign
id|outBoundFreeQbase
op_plus
(paren
(paren
id|tailAddrPointer
op_plus
l_int|4
)paren
op_mod
(paren
id|_16K
op_star
id|cirQueSize
)paren
)paren
suffix:semicolon
multiline_comment|/* updating the pointer back to OUTBOUND_FREE_TAIL_POINTER_REGISTER */
id|GT_REG_WRITE
c_func
(paren
id|OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE
comma
id|tailAddrPointer
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|variable|isInBoundDoorBellInterruptSet
id|EXPORT_SYMBOL
c_func
(paren
id|isInBoundDoorBellInterruptSet
)paren
suffix:semicolon
DECL|variable|initiateOutBoundDoorBellInt
id|EXPORT_SYMBOL
c_func
(paren
id|initiateOutBoundDoorBellInt
)paren
suffix:semicolon
DECL|variable|clearInBoundDoorBellInt
id|EXPORT_SYMBOL
c_func
(paren
id|clearInBoundDoorBellInt
)paren
suffix:semicolon
eof
