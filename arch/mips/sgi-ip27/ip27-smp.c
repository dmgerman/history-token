multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General&n; * Public License.  See the file &quot;COPYING&quot; in the main directory of this&n; * archive for more details.&n; *&n; * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)&n; * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/gda.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/launch.h&gt;
macro_line|#include &lt;asm/sn/mapped_kernel.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/sn0/hubpi.h&gt;
macro_line|#include &lt;asm/sn/sn0/hubio.h&gt;
macro_line|#include &lt;asm/sn/sn0/ip27.h&gt;
multiline_comment|/*&n; * Takes as first input the PROM assigned cpu id, and the kernel&n; * assigned cpu id as the second.&n; */
DECL|function|alloc_cpupda
r_static
r_void
id|alloc_cpupda
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|cpunum
)paren
(brace
id|cnodeid_t
id|node
op_assign
id|get_cpu_cnode
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|node
)paren
suffix:semicolon
id|cputonasid
c_func
(paren
id|cpunum
)paren
op_assign
id|nasid
suffix:semicolon
id|cpu_data
(braket
id|cpunum
)braket
dot
id|p_nodeid
op_assign
id|node
suffix:semicolon
id|cputoslice
c_func
(paren
id|cpunum
)paren
op_assign
id|get_cpu_slice
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
DECL|function|get_actual_nasid
r_static
id|nasid_t
id|get_actual_nasid
c_func
(paren
id|lboard_t
op_star
id|brd
)paren
(brace
id|klhub_t
op_star
id|hub
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
id|INVALID_NASID
suffix:semicolon
multiline_comment|/* find out if we are a completely disabled brd. */
id|hub
op_assign
(paren
id|klhub_t
op_star
)paren
id|find_first_component
c_func
(paren
id|brd
comma
id|KLSTRUCT_HUB
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub
)paren
r_return
id|INVALID_NASID
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub-&gt;hub_info.flags
op_amp
id|KLINFO_ENABLE
)paren
)paren
multiline_comment|/* disabled node brd */
r_return
id|hub-&gt;hub_info.physid
suffix:semicolon
r_else
r_return
id|brd-&gt;brd_nasid
suffix:semicolon
)brace
DECL|function|do_cpumask
r_static
r_int
id|do_cpumask
c_func
(paren
id|cnodeid_t
id|cnode
comma
id|nasid_t
id|nasid
comma
r_int
id|highest
)paren
(brace
r_static
r_int
id|tot_cpus_found
op_assign
l_int|0
suffix:semicolon
id|lboard_t
op_star
id|brd
suffix:semicolon
id|klcpu_t
op_star
id|acpu
suffix:semicolon
r_int
id|cpus_found
op_assign
l_int|0
suffix:semicolon
id|cpuid_t
id|cpuid
suffix:semicolon
id|brd
op_assign
id|find_lboard
c_func
(paren
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
comma
id|KLTYPE_IP27
)paren
suffix:semicolon
r_do
(brace
id|acpu
op_assign
(paren
id|klcpu_t
op_star
)paren
id|find_first_component
c_func
(paren
id|brd
comma
id|KLSTRUCT_CPU
)paren
suffix:semicolon
r_while
c_loop
(paren
id|acpu
)paren
(brace
id|cpuid
op_assign
id|acpu-&gt;cpu_info.virtid
suffix:semicolon
multiline_comment|/* cnode is not valid for completely disabled brds */
r_if
c_cond
(paren
id|get_actual_nasid
c_func
(paren
id|brd
)paren
op_eq
id|brd-&gt;brd_nasid
)paren
id|cpuid_to_compact_node
(braket
id|cpuid
)braket
op_assign
id|cnode
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
OG
id|highest
)paren
id|highest
op_assign
id|cpuid
suffix:semicolon
multiline_comment|/* Only let it join in if it&squot;s marked enabled */
r_if
c_cond
(paren
(paren
id|acpu-&gt;cpu_info.flags
op_amp
id|KLINFO_ENABLE
)paren
op_logical_and
(paren
id|tot_cpus_found
op_ne
id|NR_CPUS
)paren
)paren
(brace
id|cpu_set
c_func
(paren
id|cpuid
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
id|alloc_cpupda
c_func
(paren
id|cpuid
comma
id|tot_cpus_found
)paren
suffix:semicolon
id|cpus_found
op_increment
suffix:semicolon
id|tot_cpus_found
op_increment
suffix:semicolon
)brace
id|acpu
op_assign
(paren
id|klcpu_t
op_star
)paren
id|find_component
c_func
(paren
id|brd
comma
(paren
id|klinfo_t
op_star
)paren
id|acpu
comma
id|KLSTRUCT_CPU
)paren
suffix:semicolon
)brace
id|brd
op_assign
id|KLCF_NEXT
c_func
(paren
id|brd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_break
suffix:semicolon
id|brd
op_assign
id|find_lboard
c_func
(paren
id|brd
comma
id|KLTYPE_IP27
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|brd
)paren
suffix:semicolon
r_return
id|highest
suffix:semicolon
)brace
DECL|function|cpu_node_probe
r_void
id|cpu_node_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|highest
op_assign
l_int|0
suffix:semicolon
id|gda_t
op_star
id|gdap
op_assign
id|GDA
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the arrays to invalid nodeid (-1)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_COMPACT_NODES
suffix:semicolon
id|i
op_increment
)paren
id|compact_to_nasid_node
(braket
id|i
)braket
op_assign
id|INVALID_NASID
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NASIDS
suffix:semicolon
id|i
op_increment
)paren
id|nasid_to_compact_node
(braket
id|i
)braket
op_assign
id|INVALID_CNODEID
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXCPUS
suffix:semicolon
id|i
op_increment
)paren
id|cpuid_to_compact_node
(braket
id|i
)braket
op_assign
id|INVALID_CNODEID
suffix:semicolon
id|numnodes
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_COMPACT_NODES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|gdap-&gt;g_nasidtable
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|INVALID_NASID
)paren
r_break
suffix:semicolon
id|compact_to_nasid_node
(braket
id|i
)braket
op_assign
id|nasid
suffix:semicolon
id|nasid_to_compact_node
(braket
id|nasid
)braket
op_assign
id|i
suffix:semicolon
id|numnodes
op_increment
suffix:semicolon
id|highest
op_assign
id|do_cpumask
c_func
(paren
id|i
comma
id|nasid
comma
id|highest
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Discovered %d cpus on %d nodes&bslash;n&quot;
comma
id|highest
op_plus
l_int|1
comma
id|numnodes
)paren
suffix:semicolon
)brace
DECL|function|intr_clear_bits
r_static
r_void
id|intr_clear_bits
c_func
(paren
id|nasid_t
id|nasid
comma
r_volatile
id|hubreg_t
op_star
id|pend
comma
r_int
id|base_level
)paren
(brace
r_volatile
id|hubreg_t
id|bits
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check pending interrupts */
r_if
c_cond
(paren
(paren
id|bits
op_assign
id|HUB_L
c_func
(paren
id|pend
)paren
)paren
op_ne
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND_BITS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bits
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|base_level
op_plus
id|i
)paren
suffix:semicolon
)brace
DECL|function|intr_clear_all
r_static
r_void
id|intr_clear_all
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_B
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_B
comma
l_int|0
)paren
suffix:semicolon
id|intr_clear_bits
c_func
(paren
id|nasid
comma
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_PEND0
)paren
comma
id|INT_PEND0_BASELVL
)paren
suffix:semicolon
id|intr_clear_bits
c_func
(paren
id|nasid
comma
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_PEND1
)paren
comma
id|INT_PEND1_BASELVL
)paren
suffix:semicolon
)brace
DECL|function|prom_prepare_cpus
r_void
id|__init
id|prom_prepare_cpus
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
id|intr_clear_all
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
)paren
suffix:semicolon
id|replicate_kernel_text
c_func
(paren
id|numnodes
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Assumption to be fixed: we&squot;re always booted on logical / physical&n;&t; * processor 0.  While we&squot;re always running on logical processor 0&n;&t; * this still means this is physical processor zero; it might for&n;&t; * example be disabled in the firwware.&n;&t; */
id|alloc_cpupda
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Launch a slave into smp_bootstrap().  It doesn&squot;t take an argument, and we&n; * set sp to the kernel stack of the newly created idle process, gp to the proc&n; * struct so that current_thread_info() will work.&n; */
DECL|function|prom_boot_secondary
r_void
id|__init
id|prom_boot_secondary
c_func
(paren
r_int
id|cpu
comma
r_struct
id|task_struct
op_star
id|idle
)paren
(brace
r_int
r_int
id|gp
op_assign
(paren
r_int
r_int
)paren
id|idle-&gt;thread_info
suffix:semicolon
r_int
r_int
id|sp
op_assign
id|gp
op_plus
id|THREAD_SIZE
op_minus
l_int|32
suffix:semicolon
id|LAUNCH_SLAVE
c_func
(paren
id|cputonasid
c_func
(paren
id|cpu
)paren
comma
id|cputoslice
c_func
(paren
id|cpu
)paren
comma
(paren
id|launch_proc_t
)paren
id|MAPPED_KERN_RW_TO_K0
c_func
(paren
id|smp_bootstrap
)paren
comma
l_int|0
comma
(paren
r_void
op_star
)paren
id|sp
comma
(paren
r_void
op_star
)paren
id|gp
)paren
suffix:semicolon
)brace
DECL|function|prom_init_secondary
r_void
id|prom_init_secondary
c_func
(paren
r_void
)paren
(brace
id|per_cpu_init
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|prom_cpus_done
r_void
id|__init
id|prom_cpus_done
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|prom_smp_finish
r_void
id|prom_smp_finish
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|core_send_ipi
r_void
id|core_send_ipi
c_func
(paren
r_int
id|destid
comma
r_int
r_int
id|action
)paren
(brace
r_int
id|irq
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SMP_RESCHEDULE_YOURSELF
suffix:colon
id|irq
op_assign
id|CPU_RESCHED_A_IRQ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SMP_CALL_FUNCTION
suffix:colon
id|irq
op_assign
id|CPU_CALL_A_IRQ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;sendintr&quot;
)paren
suffix:semicolon
)brace
id|irq
op_add_assign
id|cputoslice
c_func
(paren
id|destid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the compact hub number to the NASID to get the correct&n;&t; * part of the address space.  Then set the interrupt bit associated&n;&t; * with the CPU we want to send the interrupt to.&n;&t; */
id|REMOTE_HUB_SEND_INTR
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cpu_to_node
c_func
(paren
id|destid
)paren
)paren
comma
id|irq
)paren
suffix:semicolon
)brace
eof
