macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/nmi.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/sn0/hub.h&gt;
macro_line|#if 0
mdefine_line|#define NODE_NUM_CPUS(n)&t;CNODE_NUM_CPUS(n)
macro_line|#else
DECL|macro|NODE_NUM_CPUS
mdefine_line|#define NODE_NUM_CPUS(n)&t;CPUS_PER_NODE
macro_line|#endif
DECL|macro|CNODEID_NONE
mdefine_line|#define CNODEID_NONE (cnodeid_t)-1
DECL|macro|enter_panic_mode
mdefine_line|#define enter_panic_mode()&t;spin_lock(&amp;nmi_lock)
DECL|typedef|machreg_t
r_typedef
r_int
r_int
id|machreg_t
suffix:semicolon
DECL|variable|nmi_lock
id|spinlock_t
id|nmi_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Lets see what else we need to do here. Set up sp, gp?&n; */
DECL|function|nmi_dump
r_void
id|nmi_dump
c_func
(paren
r_void
)paren
(brace
r_void
id|cont_nmi_dump
c_func
(paren
r_void
)paren
suffix:semicolon
id|cont_nmi_dump
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|install_cpu_nmi_handler
r_void
id|install_cpu_nmi_handler
c_func
(paren
r_int
id|slice
)paren
(brace
id|nmi_t
op_star
id|nmi_addr
suffix:semicolon
id|nmi_addr
op_assign
(paren
id|nmi_t
op_star
)paren
id|NMI_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
id|slice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmi_addr-&gt;call_addr
)paren
r_return
suffix:semicolon
id|nmi_addr-&gt;magic
op_assign
id|NMI_MAGIC
suffix:semicolon
id|nmi_addr-&gt;call_addr
op_assign
(paren
r_void
op_star
)paren
id|nmi_dump
suffix:semicolon
id|nmi_addr-&gt;call_addr_c
op_assign
(paren
r_void
op_star
)paren
(paren
op_complement
(paren
(paren
r_int
r_int
)paren
(paren
id|nmi_addr-&gt;call_addr
)paren
)paren
)paren
suffix:semicolon
id|nmi_addr-&gt;call_parm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the cpu registers which have been saved in the IP27prom format&n; * into the eframe format for the node under consideration.&n; */
DECL|function|nmi_cpu_eframe_save
r_void
id|nmi_cpu_eframe_save
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|slice
)paren
(brace
r_struct
id|reg_struct
op_star
id|nr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Get the pointer to the current cpu&squot;s register set. */
id|nr
op_assign
(paren
r_struct
id|reg_struct
op_star
)paren
(paren
id|TO_UNCAC
c_func
(paren
id|TO_NODE
c_func
(paren
id|nasid
comma
id|IP27_NMI_KREGS_OFFSET
)paren
)paren
op_plus
id|slice
op_star
id|IP27_NMI_KREGS_CPU_SIZE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI nasid %d: slice %d&bslash;n&quot;
comma
id|nasid
comma
id|slice
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved main processor registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;$%2d   :&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %016lx&quot;
comma
id|nr-&gt;gpr
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Hi    : (value lost)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Lo    : (value lost)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved cp0 registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;epc   : %016lx &quot;
comma
id|nr-&gt;epc
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s &quot;
comma
id|nr-&gt;epc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|print_tainted
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ErrEPC: %016lx &quot;
comma
id|nr-&gt;error_epc
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|nr-&gt;error_epc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ra    : %016lx &quot;
comma
id|nr-&gt;gpr
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|nr-&gt;gpr
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Status: %08lx         &quot;
comma
id|nr-&gt;sr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_KX
)paren
id|printk
c_func
(paren
l_string|&quot;KX &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_SX
)paren
id|printk
c_func
(paren
l_string|&quot;SX &t;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_UX
)paren
id|printk
c_func
(paren
l_string|&quot;UX &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_KSU
)paren
(brace
r_case
id|KSU_USER
suffix:colon
id|printk
c_func
(paren
l_string|&quot;USER &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KSU_SUPERVISOR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUPERVISOR &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KSU_KERNEL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;KERNEL &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BAD_MODE &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_ERL
)paren
id|printk
c_func
(paren
l_string|&quot;ERL &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_EXL
)paren
id|printk
c_func
(paren
l_string|&quot;EXL &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr-&gt;sr
op_amp
id|ST0_IE
)paren
id|printk
c_func
(paren
l_string|&quot;IE &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cause : %08lx&bslash;n&quot;
comma
id|nr-&gt;cause
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PrId  : %08x&bslash;n&quot;
comma
id|read_c0_prid
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BadVA : %016lx&bslash;n&quot;
comma
id|nr-&gt;badva
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CErr  : %016lx&bslash;n&quot;
comma
id|nr-&gt;cache_err
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI_SR: %016lx&bslash;n&quot;
comma
id|nr-&gt;nmi_sr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|nmi_dump_hub_irq
r_void
id|nmi_dump_hub_irq
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|slice
)paren
(brace
id|hubreg_t
id|mask0
comma
id|mask1
comma
id|pend0
comma
id|pend1
suffix:semicolon
r_if
c_cond
(paren
id|slice
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Slice A */
id|mask0
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
)paren
suffix:semicolon
id|mask1
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Slice B */
id|mask0
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_B
)paren
suffix:semicolon
id|mask1
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_B
)paren
suffix:semicolon
)brace
id|pend0
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_PEND0
)paren
suffix:semicolon
id|pend1
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_INT_PEND1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_MASK0: %16lx PI_INT_MASK1: %16lx&bslash;n&quot;
comma
id|mask0
comma
id|mask1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_PEND0: %16lx PI_INT_PEND1: %16lx&bslash;n&quot;
comma
id|pend0
comma
id|pend1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the cpu registers which have been saved in the IP27prom format&n; * into the eframe format for the node under consideration.&n; */
DECL|function|nmi_node_eframe_save
r_void
id|nmi_node_eframe_save
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|slice
suffix:semicolon
multiline_comment|/* Make sure that we have a valid node */
r_if
c_cond
(paren
id|cnode
op_eq
id|CNODEID_NONE
)paren
r_return
suffix:semicolon
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|INVALID_NASID
)paren
r_return
suffix:semicolon
multiline_comment|/* Save the registers into eframe for each cpu */
r_for
c_loop
(paren
id|slice
op_assign
l_int|0
suffix:semicolon
id|slice
OL
id|NODE_NUM_CPUS
c_func
(paren
id|slice
)paren
suffix:semicolon
id|slice
op_increment
)paren
(brace
id|nmi_cpu_eframe_save
c_func
(paren
id|nasid
comma
id|slice
)paren
suffix:semicolon
id|nmi_dump_hub_irq
c_func
(paren
id|nasid
comma
id|slice
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Save the nmi cpu registers for all cpus in the system.&n; */
r_void
DECL|function|nmi_eframes_save
id|nmi_eframes_save
c_func
(paren
r_void
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|nmi_node_eframe_save
c_func
(paren
id|cnode
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|cont_nmi_dump
id|cont_nmi_dump
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef REAL_NMI_SIGNAL
r_static
id|atomic_t
id|nmied_cpus
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nmied_cpus
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Use enter_panic_mode to allow only 1 cpu to proceed&n;&t; */
id|enter_panic_mode
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_NMI_SIGNAL
multiline_comment|/*&n;&t; * Wait up to 15 seconds for the other cpus to respond to the NMI.&n;&t; * If a cpu has not responded after 10 sec, send it 1 additional NMI.&n;&t; * This is for 2 reasons:&n;&t; *&t;- sometimes a MMSC fail to NMI all cpus.&n;&t; *&t;- on 512p SN0 system, the MMSC will only send NMIs to&n;&t; *&t;  half the cpus. Unfortunately, we don&squot;t know which cpus may be&n;&t; *&t;  NMIed - it depends on how the site chooses to configure.&n;&t; *&n;&t; * Note: it has been measure that it takes the MMSC up to 2.3 secs to&n;&t; * send NMIs to all cpus on a 256p system.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1500
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|dump_count
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|numnodes
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|dump_count
op_eq
l_int|0
)paren
(brace
id|cpu
op_assign
id|node_to_first_cpu
c_func
(paren
id|node
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|CNODE_NUM_CPUS
c_func
(paren
id|node
)paren
suffix:semicolon
id|cpu
op_increment
comma
id|n
op_increment
)paren
(brace
id|CPUMASK_SETB
c_func
(paren
id|nmied_cpus
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * cputonasid, cputoslice&n;&t;&t;&t;&t;&t;&t; * needs kernel cpuid&n;&t;&t;&t;&t;&t;&t; */
id|SEND_NMI
c_func
(paren
(paren
id|cputonasid
c_func
(paren
id|cpu
)paren
)paren
comma
(paren
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|udelay
c_func
(paren
l_int|10000
)paren
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|nmied_cpus
)paren
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Save the nmi cpu registers for all cpu in the eframe format.&n;&t; */
id|nmi_eframes_save
c_func
(paren
)paren
suffix:semicolon
id|LOCAL_HUB_S
c_func
(paren
id|NI_PORT_RESET
comma
id|NPR_PORTRESET
op_or
id|NPR_LOCALRESET
)paren
suffix:semicolon
)brace
eof
