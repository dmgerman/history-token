multiline_comment|/*&n; * ip27-irq.c: Highlevel interrupt handling for IP27 architecture.&n; *&n; * Copyright (C) 1999, 2000 Ralf Baechle (ralf@gnu.org)&n; * Copyright (C) 1999, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 1999 - 2001 Kanoj Sarcar&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/sn0/hub.h&gt;
macro_line|#include &lt;asm/sn/sn0/ip27.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/intr_public.h&gt;
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
macro_line|#ifdef DEBUG_IRQ
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
multiline_comment|/* These should die */
DECL|variable|bus_to_wid
r_int
r_char
id|bus_to_wid
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* widget id for linux pci bus */
DECL|variable|bus_to_nid
r_int
r_char
id|bus_to_nid
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* nasid for linux pci bus */
DECL|variable|num_bridges
r_int
r_char
id|num_bridges
suffix:semicolon
multiline_comment|/* number of bridges in the system */
multiline_comment|/*&n; * Linux has a controller-independent x86 interrupt architecture.&n; * every controller has a &squot;controller-template&squot;, that is used&n; * by the main code to do the right thing. Each driver-visible&n; * interrupt source is transparently wired to the apropriate&n; * controller. Thus drivers need not be aware of the&n; * interrupt-controller.&n; *&n; * Various interrupt controllers we handle: 8259 PIC, SMP IO-APIC,&n; * PIIX4&squot;s internal 8259 PIC and SGI&squot;s Visual Workstation Cobalt (IO-)APIC.&n; * (IO-APICs assumed to be messaging to Pentium local-APICs)&n; *&n; * the code is designed to be easily extended with new/different&n; * interrupt controllers, without having to do assembly magic.&n; */
r_extern
id|asmlinkage
r_void
id|ip27_irq
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|irq_to_bus
(braket
)braket
comma
id|irq_to_slot
(braket
)braket
comma
id|bus_to_cpu
(braket
)braket
suffix:semicolon
r_int
id|intr_connect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
suffix:semicolon
r_int
id|intr_disconnect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
suffix:semicolon
multiline_comment|/*&n; * There is a single intpend register per node, and we want to have&n; * distinct levels for intercpu intrs for both cpus A and B on a node.&n; */
DECL|variable|node_level_to_irq
r_int
id|node_level_to_irq
(braket
id|MAX_COMPACT_NODES
)braket
(braket
id|PERNODE_LEVELS
)braket
suffix:semicolon
multiline_comment|/*&n; * use these macros to get the encoded nasid and widget id&n; * from the irq value&n; */
DECL|macro|IRQ_TO_BUS
mdefine_line|#define IRQ_TO_BUS(i)&t;&t;&t;irq_to_bus[(i)]
DECL|macro|IRQ_TO_CPU
mdefine_line|#define IRQ_TO_CPU(i)&t;&t;&t;bus_to_cpu[IRQ_TO_BUS(i)]
DECL|macro|NASID_FROM_PCI_IRQ
mdefine_line|#define NASID_FROM_PCI_IRQ(i)&t;&t;bus_to_nid[IRQ_TO_BUS(i)]
DECL|macro|WID_FROM_PCI_IRQ
mdefine_line|#define WID_FROM_PCI_IRQ(i)&t;&t;bus_to_wid[IRQ_TO_BUS(i)]
DECL|macro|SLOT_FROM_PCI_IRQ
mdefine_line|#define&t;SLOT_FROM_PCI_IRQ(i)&t;&t;irq_to_slot[i]
DECL|function|alloc_level
r_static
r_inline
r_int
id|alloc_level
c_func
(paren
id|cpuid_t
id|cpunum
comma
r_int
id|irq
)paren
(brace
id|cnodeid_t
id|nodenum
op_assign
id|CPUID_TO_COMPACT_NODEID
c_func
(paren
id|cpunum
)paren
suffix:semicolon
r_int
id|j
op_assign
id|LEAST_LEVEL
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* resched &amp; crosscall entries taken */
r_while
c_loop
(paren
op_increment
id|j
OL
id|PERNODE_LEVELS
)paren
(brace
r_if
c_cond
(paren
id|node_level_to_irq
(braket
id|nodenum
)braket
(braket
id|j
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|node_level_to_irq
(braket
id|nodenum
)braket
(braket
id|j
)braket
op_assign
id|irq
suffix:semicolon
r_return
id|j
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Cpu %ld flooded with devices&bslash;n&quot;
comma
id|cpunum
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_level
r_static
r_inline
r_int
id|find_level
c_func
(paren
id|cpuid_t
op_star
id|cpunum
comma
r_int
id|irq
)paren
(brace
r_int
id|j
suffix:semicolon
id|cnodeid_t
id|nodenum
op_assign
id|INVALID_CNODEID
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|nodenum
OL
id|MAX_COMPACT_NODES
)paren
(brace
id|j
op_assign
id|LEAST_LEVEL
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* resched &amp; crosscall entries taken */
r_while
c_loop
(paren
op_increment
id|j
OL
id|PERNODE_LEVELS
)paren
r_if
c_cond
(paren
id|node_level_to_irq
(braket
id|nodenum
)braket
(braket
id|j
)braket
op_eq
id|irq
)paren
(brace
op_star
id|cpunum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX Fixme */
r_return
id|j
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Could not identify cpu/level for irq %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Find first bit set&n; */
DECL|function|ms1bit
r_static
r_int
id|ms1bit
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|b
op_assign
l_int|0
comma
id|s
suffix:semicolon
id|s
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|16
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|8
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|4
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|2
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|1
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; * This code is unnecessarily complex, because we do SA_INTERRUPT&n; * intr enabling. Basically, once we grab the set of intrs we need&n; * to service, we must mask _all_ these interrupts; firstly, to make&n; * sure the same intr does not intr again, causing recursion that&n; * can lead to stack overflow. Secondly, we can not just mask the&n; * one intr we are do_IRQing, because the non-masked intrs in the&n; * first set might intr again, causing multiple servicings of the&n; * same intr. This effect is mostly seen for intercpu intrs.&n; * Kanoj 05.13.00&n; */
DECL|function|ip27_do_irq
r_void
id|ip27_do_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
comma
id|swlevel
suffix:semicolon
id|hubreg_t
id|pend0
comma
id|mask0
suffix:semicolon
id|cpuid_t
id|thiscpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|pi_int_mask0
op_assign
(paren
(paren
id|cputoslice
c_func
(paren
id|thiscpu
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|PI_INT_MASK0_A
suffix:colon
id|PI_INT_MASK0_B
)paren
suffix:semicolon
multiline_comment|/* copied from Irix intpend0() */
r_while
c_loop
(paren
(paren
(paren
id|pend0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
)paren
op_amp
(paren
id|mask0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|pi_int_mask0
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|pend0
op_and_assign
id|mask0
suffix:semicolon
multiline_comment|/* Pick intrs we should look at */
r_if
c_cond
(paren
id|pend0
)paren
(brace
multiline_comment|/* Prevent any of the picked intrs from recursing */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
op_amp
op_complement
(paren
id|pend0
)paren
)paren
suffix:semicolon
r_do
(brace
id|swlevel
op_assign
id|ms1bit
c_func
(paren
id|pend0
)paren
suffix:semicolon
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|swlevel
)paren
suffix:semicolon
multiline_comment|/* &quot;map&quot; swlevel to irq */
id|irq
op_assign
id|LEVEL_TO_IRQ
c_func
(paren
id|thiscpu
comma
id|swlevel
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* clear bit in pend0 */
id|pend0
op_xor_assign
l_int|1ULL
op_lshift
id|swlevel
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pend0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Now allow the set of serviced intrs again */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
)paren
suffix:semicolon
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Startup one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|startup_bridge_irq
r_static
r_int
r_int
id|startup_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|bridgereg_t
id|device
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|cpuid_t
id|cpu
suffix:semicolon
id|nasid_t
id|master
op_assign
id|NASID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
id|BASE_PCI_IRQ
)paren
r_return
l_int|0
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|master
comma
id|WID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|cpu
op_assign
id|IRQ_TO_CPU
c_func
(paren
id|irq
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_startup(): irq= 0x%x  pin=%d&bslash;n&quot;
comma
id|irq
comma
id|pin
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;map&quot; irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|alloc_level
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|swlevel
)paren
suffix:semicolon
id|bridge-&gt;b_int_addr
(braket
id|pin
)braket
dot
id|addr
op_assign
(paren
l_int|0x20000
op_or
id|swlevel
op_or
(paren
id|master
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_enable
op_or_assign
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
multiline_comment|/* more stuff in int_enable reg */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|0x7ffffe00
suffix:semicolon
multiline_comment|/*&n;&t; * XXX This only works if b_int_device is initialized to 0!&n;&t; * We program the bridge to have a 1:1 mapping between devices&n;&t; * (slots) and intr pins.&n;&t; */
id|device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|device
op_or_assign
(paren
id|pin
op_lshift
(paren
id|pin
op_star
l_int|3
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|device
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never anything pending.  */
)brace
multiline_comment|/* Shutdown one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|shutdown_bridge_irq
r_static
r_int
r_int
id|shutdown_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|cpuid_t
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
id|BASE_PCI_IRQ
)paren
r_return
l_int|0
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|NASID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
comma
id|WID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_shutdown: irq 0x%x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * map irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|find_level
c_func
(paren
op_amp
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_disconnect_level
c_func
(paren
id|cpu
comma
id|swlevel
)paren
suffix:semicolon
id|LEVEL_TO_IRQ
c_func
(paren
id|cpu
comma
id|swlevel
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|bridge-&gt;b_int_enable
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never anything pending.  */
)brace
DECL|function|enable_bridge_irq
r_static
r_inline
r_void
id|enable_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|disable_bridge_irq
r_static
r_void
id|disable_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|mask_and_ack_bridge_irq
r_static
r_void
id|mask_and_ack_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|end_bridge_irq
r_static
r_void
id|end_bridge_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
id|enable_bridge_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|bridge_irq_type
r_static
r_struct
id|hw_interrupt_type
id|bridge_irq_type
op_assign
(brace
l_string|&quot;bridge&quot;
comma
id|startup_bridge_irq
comma
id|shutdown_bridge_irq
comma
id|enable_bridge_irq
comma
id|disable_bridge_irq
comma
id|mask_and_ack_bridge_irq
comma
id|end_bridge_irq
)brace
suffix:semicolon
DECL|function|irq_debug
r_void
id|irq_debug
c_func
(paren
r_void
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
l_int|0x9200000008000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bridge-&gt;b_int_status = 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_int_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bridge-&gt;b_int_enable = 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_int_enable
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_PEND0   = 0x%lx&bslash;n&quot;
comma
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_MASK0_A = 0x%lx&bslash;n&quot;
comma
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_MASK0_A
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|0
comma
id|ip27_irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Right now the bridge irq is our kitchen sink interrupt type&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|IRQ_DISABLED
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|action
op_assign
l_int|0
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|depth
op_assign
l_int|1
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|bridge_irq_type
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Get values that vary depending on which CPU and bit we&squot;re operating on.&n; */
DECL|function|intr_get_ptrs
r_static
id|hub_intmasks_t
op_star
id|intr_get_ptrs
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
op_star
id|new_bit
comma
id|hubreg_t
op_star
op_star
id|intpend_masks
comma
r_int
op_star
id|ip
)paren
(brace
id|hub_intmasks_t
op_star
id|hub_intmasks
suffix:semicolon
id|hub_intmasks
op_assign
op_amp
id|cpu_data
(braket
id|cpu
)braket
dot
id|p_intmasks
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
id|N_INTPEND_BITS
)paren
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend0_masks
suffix:semicolon
op_star
id|ip
op_assign
l_int|0
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
suffix:semicolon
)brace
r_else
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend1_masks
suffix:semicolon
op_star
id|ip
op_assign
l_int|1
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
op_minus
id|N_INTPEND_BITS
suffix:semicolon
)brace
r_return
id|hub_intmasks
suffix:semicolon
)brace
DECL|function|intr_connect_level
r_int
id|intr_connect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
r_int
id|ip
suffix:semicolon
r_int
id|slice
op_assign
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|ip
)paren
suffix:semicolon
multiline_comment|/* Make sure it&squot;s not already pending when we connect it. */
id|REMOTE_HUB_CLR_INTR
c_func
(paren
id|nasid
comma
id|bit
op_plus
id|ip
op_star
id|N_INTPEND_BITS
)paren
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_or_assign
(paren
l_int|1ULL
op_lshift
(paren
id|u64
)paren
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intr_disconnect_level
r_int
id|intr_disconnect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
r_int
id|ip
suffix:semicolon
r_int
id|slice
op_assign
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|ip
)paren
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
l_int|1ULL
op_lshift
(paren
id|u64
)paren
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_resched_intr
id|irqreturn_t
id|handle_resched_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Nothing, the return from intr will work for us */
r_return
id|IRQ_NONE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|core_send_ipi
r_void
id|core_send_ipi
c_func
(paren
r_int
id|destid
comma
r_int
r_int
id|action
)paren
(brace
r_int
id|irq
suffix:semicolon
macro_line|#if (CPUS_PER_NODE == 2)
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SMP_RESCHEDULE_YOURSELF
suffix:colon
id|irq
op_assign
id|CPU_RESCHED_A_IRQ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SMP_CALL_FUNCTION
suffix:colon
id|irq
op_assign
id|CPU_CALL_A_IRQ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;sendintr&quot;
)paren
suffix:semicolon
)brace
id|irq
op_add_assign
id|cputoslice
c_func
(paren
id|destid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the compact hub number to the NASID to get the correct&n;&t; * part of the address space.  Then set the interrupt bit associated&n;&t; * with the CPU we want to send the interrupt to.&n;&t; */
id|REMOTE_HUB_SEND_INTR
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|destid
)paren
)paren
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
macro_line|#else
op_lshift
id|Bomb
op_logical_neg
id|Must
id|redefine
id|this
r_for
c_loop
id|more
id|than
l_int|2
id|CPUS
dot
op_rshift
macro_line|#endif
)brace
macro_line|#endif
r_extern
id|irqreturn_t
id|smp_call_function_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|install_cpuintr
r_void
id|install_cpuintr
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#ifdef CONFIG_SMP
macro_line|#if (CPUS_PER_NODE == 2)
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is a hack till we have a pernode irqlist. Currently,&n;&t; * just have the master cpu set up the handlers for the per&n;&t; * cpu irqs.&n;&t; */
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|CPU_RESCHED_A_IRQ
comma
id|handle_resched_intr
comma
l_int|0
comma
l_string|&quot;resched&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|CPU_RESCHED_B_IRQ
comma
id|handle_resched_intr
comma
l_int|0
comma
l_string|&quot;resched&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|CPU_CALL_A_IRQ
comma
id|smp_call_function_interrupt
comma
l_int|0
comma
l_string|&quot;callfunc&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|CPU_CALL_B_IRQ
comma
id|smp_call_function_interrupt
comma
l_int|0
comma
l_string|&quot;callfunc&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PERNODE_LEVELS
suffix:semicolon
id|j
op_increment
)paren
id|LEVEL_TO_IRQ
c_func
(paren
l_int|0
comma
id|j
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|LEVEL_TO_IRQ
c_func
(paren
l_int|0
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_RESCHED_A_IRQ
)paren
)paren
op_assign
id|CPU_RESCHED_A_IRQ
suffix:semicolon
id|LEVEL_TO_IRQ
c_func
(paren
l_int|0
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_RESCHED_B_IRQ
)paren
)paren
op_assign
id|CPU_RESCHED_B_IRQ
suffix:semicolon
id|LEVEL_TO_IRQ
c_func
(paren
l_int|0
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_CALL_A_IRQ
)paren
)paren
op_assign
id|CPU_CALL_A_IRQ
suffix:semicolon
id|LEVEL_TO_IRQ
c_func
(paren
l_int|0
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_CALL_B_IRQ
)paren
)paren
op_assign
id|CPU_CALL_B_IRQ
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|MAX_COMPACT_NODES
suffix:semicolon
id|j
op_increment
)paren
id|memcpy
c_func
(paren
op_amp
id|node_level_to_irq
(braket
id|j
)braket
(braket
l_int|0
)braket
comma
op_amp
id|node_level_to_irq
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|node_level_to_irq
(braket
l_int|0
)braket
(braket
l_int|0
)braket
)paren
op_star
id|PERNODE_LEVELS
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_RESCHED_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|FAST_IRQ_TO_LEVEL
c_func
(paren
id|CPU_CALL_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
)paren
suffix:semicolon
macro_line|#else /* CPUS_PER_NODE */
macro_line|#error Must redefine this for more than 2 CPUS.
macro_line|#endif /* CPUS_PER_NODE */
macro_line|#endif /* CONFIG_SMP */
)brace
DECL|function|install_tlbintr
r_void
id|install_tlbintr
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#if 0
r_int
id|intr_bit
op_assign
id|N_INTPEND_BITS
op_plus
id|TLB_INTR_A
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
