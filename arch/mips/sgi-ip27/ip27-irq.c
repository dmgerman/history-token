multiline_comment|/*&n; * ip27-irq.c: Highlevel interrupt handling for IP27 architecture.&n; *&n; * Copyright (C) 1999, 2000 Ralf Baechle (ralf@gnu.org)&n; * Copyright (C) 1999, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 1999 - 2001 Kanoj Sarcar&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/hub.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
macro_line|#ifdef DEBUG_IRQ
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
multiline_comment|/*&n; * Linux has a controller-independent x86 interrupt architecture.&n; * every controller has a &squot;controller-template&squot;, that is used&n; * by the main code to do the right thing. Each driver-visible&n; * interrupt source is transparently wired to the apropriate&n; * controller. Thus drivers need not be aware of the&n; * interrupt-controller.&n; *&n; * Various interrupt controllers we handle: 8259 PIC, SMP IO-APIC,&n; * PIIX4&squot;s internal 8259 PIC and SGI&squot;s Visual Workstation Cobalt (IO-)APIC.&n; * (IO-APICs assumed to be messaging to Pentium local-APICs)&n; *&n; * the code is designed to be easily extended with new/different&n; * interrupt controllers, without having to do assembly magic.&n; */
r_extern
id|asmlinkage
r_void
id|ip27_irq
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|bridge_controller
op_star
id|irq_to_bridge
(braket
)braket
suffix:semicolon
r_extern
r_int
id|irq_to_slot
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; * use these macros to get the encoded nasid and widget id&n; * from the irq value&n; */
DECL|macro|IRQ_TO_BRIDGE
mdefine_line|#define IRQ_TO_BRIDGE(i)&t;&t;irq_to_bridge[(i)]
DECL|macro|SLOT_FROM_PCI_IRQ
mdefine_line|#define&t;SLOT_FROM_PCI_IRQ(i)&t;&t;irq_to_slot[i]
DECL|function|alloc_level
r_static
r_inline
r_int
id|alloc_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
r_int
id|level
suffix:semicolon
multiline_comment|/* pre-allocated entries */
id|level
op_assign
id|find_first_zero_bit
c_func
(paren
id|si-&gt;irq_alloc_mask
comma
id|LEVELS_PER_SLICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ge
id|LEVELS_PER_SLICE
)paren
id|panic
c_func
(paren
l_string|&quot;Cpu %d flooded with devices&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|__set_bit
c_func
(paren
id|level
comma
id|si-&gt;irq_alloc_mask
)paren
suffix:semicolon
id|si-&gt;level_to_irq
(braket
id|level
)braket
op_assign
id|irq
suffix:semicolon
r_return
id|level
suffix:semicolon
)brace
DECL|function|find_level
r_static
r_inline
r_int
id|find_level
c_func
(paren
id|cpuid_t
op_star
id|cpunum
comma
r_int
id|irq
)paren
(brace
r_int
id|cpu
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
op_le
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|BASE_PCI_IRQ
suffix:semicolon
id|i
OL
id|LEVELS_PER_SLICE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|si-&gt;level_to_irq
(braket
id|i
)braket
op_eq
id|irq
)paren
(brace
op_star
id|cpunum
op_assign
id|cpu
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;Could not identify cpu/level for irq %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find first bit set&n; */
DECL|function|ms1bit
r_static
r_int
id|ms1bit
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|b
op_assign
l_int|0
comma
id|s
suffix:semicolon
id|s
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|16
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|8
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|4
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|2
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
id|x
op_rshift_assign
id|s
suffix:semicolon
id|s
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|1
op_eq
l_int|0
)paren
id|s
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
id|s
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; * This code is unnecessarily complex, because we do SA_INTERRUPT&n; * intr enabling. Basically, once we grab the set of intrs we need&n; * to service, we must mask _all_ these interrupts; firstly, to make&n; * sure the same intr does not intr again, causing recursion that&n; * can lead to stack overflow. Secondly, we can not just mask the&n; * one intr we are do_IRQing, because the non-masked intrs in the&n; * first set might intr again, causing multiple servicings of the&n; * same intr. This effect is mostly seen for intercpu intrs.&n; * Kanoj 05.13.00&n; */
DECL|function|ip27_do_irq_mask0
r_void
id|ip27_do_irq_mask0
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
comma
id|swlevel
suffix:semicolon
id|hubreg_t
id|pend0
comma
id|mask0
suffix:semicolon
id|cpuid_t
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|pi_int_mask0
op_assign
(paren
id|cputoslice
c_func
(paren
id|cpu
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|PI_INT_MASK0_A
suffix:colon
id|PI_INT_MASK0_B
suffix:semicolon
multiline_comment|/* copied from Irix intpend0() */
id|pend0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
suffix:semicolon
id|mask0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|pi_int_mask0
)paren
suffix:semicolon
id|pend0
op_and_assign
id|mask0
suffix:semicolon
multiline_comment|/* Pick intrs we should look at */
r_if
c_cond
(paren
op_logical_neg
id|pend0
)paren
r_return
suffix:semicolon
multiline_comment|/* Prevent any of the picked intrs from recursing */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
op_amp
op_complement
id|pend0
)paren
suffix:semicolon
id|swlevel
op_assign
id|ms1bit
c_func
(paren
id|pend0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|pend0
op_amp
(paren
l_int|1UL
op_lshift
id|CPU_RESCHED_A_IRQ
)paren
)paren
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_RESCHED_A_IRQ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pend0
op_amp
(paren
l_int|1UL
op_lshift
id|CPU_RESCHED_B_IRQ
)paren
)paren
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_RESCHED_B_IRQ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pend0
op_amp
(paren
l_int|1UL
op_lshift
id|CPU_CALL_A_IRQ
)paren
)paren
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_CALL_A_IRQ
)paren
suffix:semicolon
id|smp_call_function_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pend0
op_amp
(paren
l_int|1UL
op_lshift
id|CPU_CALL_B_IRQ
)paren
)paren
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_CALL_B_IRQ
)paren
suffix:semicolon
id|smp_call_function_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* &quot;map&quot; swlevel to irq */
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
id|irq
op_assign
id|si-&gt;level_to_irq
(braket
id|swlevel
)braket
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* clear bit in pend0 */
id|pend0
op_xor_assign
l_int|1UL
op_lshift
id|swlevel
suffix:semicolon
multiline_comment|/* Now allow the set of serviced intrs again */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
)paren
suffix:semicolon
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
suffix:semicolon
)brace
DECL|function|ip27_do_irq_mask1
r_void
id|ip27_do_irq_mask1
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
comma
id|swlevel
suffix:semicolon
id|hubreg_t
id|pend1
comma
id|mask1
suffix:semicolon
id|cpuid_t
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|pi_int_mask1
op_assign
(paren
id|cputoslice
c_func
(paren
id|cpu
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|PI_INT_MASK1_A
suffix:colon
id|PI_INT_MASK1_B
suffix:semicolon
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
multiline_comment|/* copied from Irix intpend0() */
id|pend1
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND1
)paren
suffix:semicolon
id|mask1
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|pi_int_mask1
)paren
suffix:semicolon
id|pend1
op_and_assign
id|mask1
suffix:semicolon
multiline_comment|/* Pick intrs we should look at */
r_if
c_cond
(paren
op_logical_neg
id|pend1
)paren
r_return
suffix:semicolon
multiline_comment|/* Prevent any of the picked intrs from recursing */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask1
comma
id|mask1
op_amp
op_complement
id|pend1
)paren
suffix:semicolon
id|swlevel
op_assign
id|ms1bit
c_func
(paren
id|pend1
)paren
suffix:semicolon
multiline_comment|/* &quot;map&quot; swlevel to irq */
id|irq
op_assign
id|si-&gt;level_to_irq
(braket
id|swlevel
)braket
suffix:semicolon
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|swlevel
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* clear bit in pend1 */
id|pend1
op_xor_assign
l_int|1UL
op_lshift
id|swlevel
suffix:semicolon
multiline_comment|/* Now allow the set of serviced intrs again */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask1
comma
id|mask1
)paren
suffix:semicolon
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND1
)paren
suffix:semicolon
)brace
DECL|function|ip27_prof_timer
r_void
id|ip27_prof_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU %d got a profiling interrupt&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|ip27_hub_error
r_void
id|ip27_hub_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU %d got a hub error interrupt&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|intr_connect_level
r_static
r_int
id|intr_connect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cpu_to_node
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
id|__set_bit
c_func
(paren
id|bit
comma
id|si-&gt;irq_enable_mask
)paren
suffix:semicolon
multiline_comment|/* Make sure it&squot;s not already pending when we connect it. */
id|REMOTE_HUB_CLR_INTR
c_func
(paren
id|nasid
comma
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
comma
id|si-&gt;irq_enable_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
comma
id|si-&gt;irq_enable_mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_B
comma
id|si-&gt;irq_enable_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_B
comma
id|si-&gt;irq_enable_mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intr_disconnect_level
r_static
r_int
id|intr_disconnect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cpu_to_node
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
id|__clear_bit
c_func
(paren
id|bit
comma
id|si-&gt;irq_enable_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
comma
id|si-&gt;irq_enable_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
comma
id|si-&gt;irq_enable_mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_B
comma
id|si-&gt;irq_enable_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_B
comma
id|si-&gt;irq_enable_mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Startup one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|startup_bridge_irq
r_static
r_int
r_int
id|startup_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|bridge_controller
op_star
id|bc
suffix:semicolon
id|bridgereg_t
id|device
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|bc
op_assign
id|IRQ_TO_BRIDGE
c_func
(paren
id|irq
)paren
suffix:semicolon
id|bridge
op_assign
id|bc-&gt;base
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_startup(): irq= 0x%x  pin=%d&bslash;n&quot;
comma
id|irq
comma
id|pin
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;map&quot; irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|alloc_level
c_func
(paren
id|bc-&gt;irq_cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|bc-&gt;irq_cpu
comma
id|swlevel
)paren
suffix:semicolon
id|bridge-&gt;b_int_addr
(braket
id|pin
)braket
dot
id|addr
op_assign
(paren
l_int|0x20000
op_or
id|swlevel
op_or
(paren
id|bc-&gt;nasid
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_enable
op_or_assign
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
multiline_comment|/* more stuff in int_enable reg */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|0x7ffffe00
suffix:semicolon
multiline_comment|/*&n;&t; * Enable sending of an interrupt clear packt to the hub on a high to&n;&t; * low transition of the interrupt pin.&n;&t; *&n;&t; * IRIX sets additional bits in the address which are documented as&n;&t; * reserved in the bridge docs.&n;&t; */
id|bridge-&gt;b_int_mode
op_or_assign
(paren
l_int|1UL
op_lshift
id|pin
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We assume the bridge to have a 1:1 mapping between devices&n;&t; * (slots) and intr pins.&n;&t; */
id|device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|device
op_and_assign
op_complement
(paren
l_int|7
op_lshift
(paren
id|pin
op_star
l_int|3
)paren
)paren
suffix:semicolon
id|device
op_or_assign
(paren
id|pin
op_lshift
(paren
id|pin
op_star
l_int|3
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|device
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never anything pending.  */
)brace
multiline_comment|/* Shutdown one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|shutdown_bridge_irq
r_static
r_void
id|shutdown_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|bridge_controller
op_star
id|bc
op_assign
id|IRQ_TO_BRIDGE
c_func
(paren
id|irq
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|bc-&gt;base
suffix:semicolon
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|bc-&gt;irq_cpu
)braket
dot
id|data
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|cpuid_t
id|cpu
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_shutdown: irq 0x%x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * map irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|find_level
c_func
(paren
op_amp
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_disconnect_level
c_func
(paren
id|cpu
comma
id|swlevel
)paren
suffix:semicolon
id|__clear_bit
c_func
(paren
id|swlevel
comma
id|si-&gt;irq_alloc_mask
)paren
suffix:semicolon
id|si-&gt;level_to_irq
(braket
id|swlevel
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|bridge-&gt;b_int_enable
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
)brace
DECL|function|enable_bridge_irq
r_static
r_inline
r_void
id|enable_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|disable_bridge_irq
r_static
r_void
id|disable_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|mask_and_ack_bridge_irq
r_static
r_void
id|mask_and_ack_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* All the braindamage happens magically for us in ip27_do_irq */
)brace
DECL|function|end_bridge_irq
r_static
r_void
id|end_bridge_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|variable|bridge_irq_type
r_static
r_struct
id|hw_interrupt_type
id|bridge_irq_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;bridge&quot;
comma
dot
id|startup
op_assign
id|startup_bridge_irq
comma
dot
id|shutdown
op_assign
id|shutdown_bridge_irq
comma
dot
id|enable
op_assign
id|enable_bridge_irq
comma
dot
id|disable
op_assign
id|disable_bridge_irq
comma
dot
id|ack
op_assign
id|mask_and_ack_bridge_irq
comma
dot
id|end
op_assign
id|end_bridge_irq
comma
)brace
suffix:semicolon
DECL|variable|irq_map
r_static
r_int
r_int
id|irq_map
(braket
id|NR_IRQS
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|function|allocate_irqno
r_int
r_int
id|allocate_irqno
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
suffix:semicolon
id|again
suffix:colon
id|irq
op_assign
id|find_first_zero_bit
c_func
(paren
id|irq_map
comma
id|LEVELS_PER_SLICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|irq
comma
id|irq_map
)paren
)paren
r_goto
id|again
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|free_irqno
r_void
id|free_irqno
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|clear_bit
c_func
(paren
id|irq
comma
id|irq_map
)paren
suffix:semicolon
)brace
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|0
comma
id|ip27_irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Right now the bridge irq is our kitchen sink interrupt type&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|IRQ_DISABLED
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|action
op_assign
l_int|0
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|depth
op_assign
l_int|1
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|bridge_irq_type
suffix:semicolon
)brace
)brace
DECL|function|install_ipi
r_void
id|install_ipi
c_func
(paren
r_void
)paren
(brace
r_int
id|slice
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_CPU_NUM
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|slice_data
op_star
id|si
op_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|data
suffix:semicolon
id|hubreg_t
id|mask
comma
id|set
suffix:semicolon
r_if
c_cond
(paren
id|slice
op_eq
l_int|0
)paren
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_RESCHED_A_IRQ
)paren
suffix:semicolon
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_CALL_A_IRQ
)paren
suffix:semicolon
id|mask
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_MASK0_A
)paren
suffix:semicolon
multiline_comment|/* Slice A */
id|set
op_assign
(paren
l_int|1UL
op_lshift
id|CPU_RESCHED_A_IRQ
)paren
op_or
(paren
l_int|1UL
op_lshift
id|CPU_CALL_A_IRQ
)paren
suffix:semicolon
id|mask
op_or_assign
id|set
suffix:semicolon
id|si-&gt;irq_enable_mask
(braket
l_int|0
)braket
op_or_assign
id|set
suffix:semicolon
id|si-&gt;irq_alloc_mask
(braket
l_int|0
)braket
op_or_assign
id|set
suffix:semicolon
id|LOCAL_HUB_S
c_func
(paren
id|PI_INT_MASK0_A
comma
id|mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_RESCHED_B_IRQ
)paren
suffix:semicolon
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_CALL_B_IRQ
)paren
suffix:semicolon
id|mask
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_MASK0_B
)paren
suffix:semicolon
multiline_comment|/* Slice B */
id|set
op_assign
(paren
l_int|1UL
op_lshift
id|CPU_RESCHED_B_IRQ
)paren
op_or
(paren
l_int|1UL
op_lshift
id|CPU_CALL_B_IRQ
)paren
suffix:semicolon
id|mask
op_or_assign
id|set
suffix:semicolon
id|si-&gt;irq_enable_mask
(braket
l_int|1
)braket
op_or_assign
id|set
suffix:semicolon
id|si-&gt;irq_alloc_mask
(braket
l_int|1
)braket
op_or_assign
id|set
suffix:semicolon
id|LOCAL_HUB_S
c_func
(paren
id|PI_INT_MASK0_B
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
eof
