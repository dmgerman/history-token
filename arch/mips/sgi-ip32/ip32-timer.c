multiline_comment|/*&n; * IP32 timer calibration&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001 Keith M Wesolowski&n; */
macro_line|#include &lt;linux/bcd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/ip32/crime.h&gt;
macro_line|#include &lt;asm/ip32/ip32_ints.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/cpu.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
r_extern
r_volatile
r_int
r_int
id|wall_jiffies
suffix:semicolon
DECL|variable|cc_interval
id|u32
id|cc_interval
suffix:semicolon
multiline_comment|/* Cycle counter value at the previous timer interrupt.. */
DECL|variable|timerhi
DECL|variable|timerlo
r_static
r_int
r_int
id|timerhi
comma
id|timerlo
suffix:semicolon
multiline_comment|/* An arbitrary time; this can be decreased if reliability looks good */
DECL|macro|WAIT_MS
mdefine_line|#define WAIT_MS 10
DECL|macro|PER_MHZ
mdefine_line|#define PER_MHZ (1000000 / 2 / HZ)
multiline_comment|/*&n; * Change this if you have some constant time drift&n; */
DECL|macro|USECS_PER_JIFFY
mdefine_line|#define USECS_PER_JIFFY (1000000/HZ)
r_static
id|irqreturn_t
id|cc_timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|ip32_timer_setup
r_void
id|__init
id|ip32_timer_setup
(paren
r_struct
id|irqaction
op_star
id|irq
)paren
(brace
id|u64
id|crime_time
suffix:semicolon
id|u32
id|cc_tick
suffix:semicolon
id|write_c0_count
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|irq-&gt;handler
op_assign
id|cc_timer_interrupt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Calibrating system timer... &quot;
)paren
suffix:semicolon
id|crime_time
op_assign
id|crime_read_64
c_func
(paren
id|CRIME_TIME
)paren
op_amp
id|CRIME_TIME_MASK
suffix:semicolon
id|cc_tick
op_assign
id|read_c0_count
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|crime_read_64
(paren
id|CRIME_TIME
)paren
op_amp
id|CRIME_TIME_MASK
)paren
op_minus
id|crime_time
OL
id|WAIT_MS
op_star
l_int|1000000
op_div
id|CRIME_NS_PER_TICK
)paren
suffix:semicolon
id|cc_tick
op_assign
id|read_c0_count
c_func
(paren
)paren
op_minus
id|cc_tick
suffix:semicolon
id|cc_interval
op_assign
id|cc_tick
op_div
id|HZ
op_star
(paren
l_int|1000
op_div
id|WAIT_MS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The round-off seems unnecessary; in testing, the error of the&n;&t; * above procedure is &lt; 100 ticks, which means it gets filtered&n;&t; * out by the HZ adjustment.&n;&t; */
id|cc_interval
op_assign
(paren
id|cc_interval
op_div
id|PER_MHZ
)paren
op_star
id|PER_MHZ
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d MHz CPU detected&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|cc_interval
op_div
id|PER_MHZ
)paren
)paren
suffix:semicolon
id|setup_irq
(paren
id|CLOCK_IRQ
comma
id|irq
)paren
suffix:semicolon
DECL|macro|ALLINTS
mdefine_line|#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
multiline_comment|/* Set ourselves up for future interrupts */
id|write_c0_compare
c_func
(paren
id|read_c0_count
c_func
(paren
)paren
op_plus
id|cc_interval
)paren
suffix:semicolon
id|change_c0_status
c_func
(paren
id|ST0_IM
comma
id|ALLINTS
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cc_timer_interrupt
r_static
id|irqreturn_t
id|cc_timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * The cycle counter is only 32 bit which is good for about&n;&t; * a minute at current count rates of upto 150MHz or so.&n;&t; */
id|count
op_assign
id|read_c0_count
c_func
(paren
)paren
suffix:semicolon
id|timerhi
op_add_assign
(paren
id|count
OL
id|timerlo
)paren
suffix:semicolon
multiline_comment|/* Wrap around */
id|timerlo
op_assign
id|count
suffix:semicolon
id|write_c0_compare
c_func
(paren
(paren
id|u32
)paren
(paren
id|count
op_plus
id|cc_interval
)paren
)paren
suffix:semicolon
id|kstat_this_cpu.irqs
(braket
id|irq
)braket
op_increment
suffix:semicolon
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jiffies
)paren
(brace
multiline_comment|/*&n;&t;&t; * If jiffies has overflowed in this timer_interrupt we must&n;&t;&t; * update the timer[hi]/[lo] to make do_fast_gettimeoffset()&n;&t;&t; * quotient calc still valid. -arca&n;&t;&t; */
id|timerhi
op_assign
id|timerlo
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|ip32_time_init
r_void
id|__init
id|ip32_time_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|epoch
op_assign
l_int|0
comma
id|year
comma
id|mon
comma
id|day
comma
id|hour
comma
id|min
comma
id|sec
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* The Linux interpretation of the CMOS clock register contents:&n;&t; * When the Update-In-Progress (UIP) flag goes from 1 to 0, the&n;&t; * RTC registers show the second which has precisely just started.&n;&t; * Let&squot;s hope other operating systems interpret the RTC the same way.&n;&t; */
multiline_comment|/* read RTC exactly on falling edge of update flag */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000000
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* may take up to 1 second... */
r_if
c_cond
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000000
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* must try at least 2.228 ms */
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
)paren
r_break
suffix:semicolon
r_do
(brace
multiline_comment|/* Isn&squot;t this overkill ? UIP above should guarantee consistency */
id|sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
id|min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
id|hour
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
id|day
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|mon
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|year
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sec
op_ne
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|sec
op_assign
id|BCD2BIN
c_func
(paren
id|sec
)paren
suffix:semicolon
id|min
op_assign
id|BCD2BIN
c_func
(paren
id|min
)paren
suffix:semicolon
id|hour
op_assign
id|BCD2BIN
c_func
(paren
id|hour
)paren
suffix:semicolon
id|day
op_assign
id|BCD2BIN
c_func
(paren
id|day
)paren
suffix:semicolon
id|mon
op_assign
id|BCD2BIN
c_func
(paren
id|mon
)paren
suffix:semicolon
id|year
op_assign
id|BCD2BIN
c_func
(paren
id|year
)paren
suffix:semicolon
)brace
multiline_comment|/* Attempt to guess the epoch.  This is the same heuristic as in&n;&t; * rtc.c so no stupid things will happen to timekeeping.  Who knows,&n;&t; * maybe Ultrix also uses 1952 as epoch ...&n;&t; */
r_if
c_cond
(paren
id|year
OG
l_int|10
op_logical_and
id|year
OL
l_int|44
)paren
id|epoch
op_assign
l_int|1980
suffix:semicolon
r_else
r_if
c_cond
(paren
id|year
OL
l_int|96
)paren
id|epoch
op_assign
l_int|1952
suffix:semicolon
id|year
op_add_assign
id|epoch
suffix:semicolon
id|write_seqlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|xtime.tv_sec
op_assign
id|mktime
c_func
(paren
id|year
comma
id|mon
comma
id|day
comma
id|hour
comma
id|min
comma
id|sec
)paren
suffix:semicolon
id|xtime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|write_sequnlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
)brace
eof
