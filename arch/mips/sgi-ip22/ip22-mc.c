multiline_comment|/*&n; * ip22-mc.c: Routines for manipulating SGI Memory Controller.&n; *&n; * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)&n; * Copyright (C) 1999 Andrew R. Baker (andrewb@uab.edu) - Indigo2 changes&n; * Copyright (C) 2003 Ladislav Michl  (ladis@linux-mips.org)&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/addrspace.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/sgialib.h&gt;
macro_line|#include &lt;asm/sgi/mc.h&gt;
macro_line|#include &lt;asm/sgi/hpc3.h&gt;
macro_line|#include &lt;asm/sgi/ip22.h&gt;
DECL|variable|sgimc
r_struct
id|sgimc_regs
op_star
id|sgimc
suffix:semicolon
DECL|function|get_bank_addr
r_static
r_inline
r_int
r_int
id|get_bank_addr
c_func
(paren
r_int
r_int
id|memconfig
)paren
(brace
r_return
(paren
(paren
id|memconfig
op_amp
id|SGIMC_MCONFIG_BASEADDR
)paren
op_lshift
(paren
(paren
id|sgimc-&gt;systemid
op_amp
id|SGIMC_SYSID_MASKREV
)paren
op_ge
l_int|5
ques
c_cond
l_int|24
suffix:colon
l_int|22
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_bank_size
r_static
r_inline
r_int
r_int
id|get_bank_size
c_func
(paren
r_int
r_int
id|memconfig
)paren
(brace
r_return
(paren
(paren
id|memconfig
op_amp
id|SGIMC_MCONFIG_RMASK
)paren
op_plus
l_int|0x0100
)paren
op_lshift
(paren
(paren
id|sgimc-&gt;systemid
op_amp
id|SGIMC_SYSID_MASKREV
)paren
op_ge
l_int|5
ques
c_cond
l_int|16
suffix:colon
l_int|14
)paren
suffix:semicolon
)brace
DECL|function|get_bank_config
r_static
r_inline
r_int
r_int
id|get_bank_config
c_func
(paren
r_int
id|bank
)paren
(brace
r_int
r_int
id|res
op_assign
id|bank
OG
l_int|1
ques
c_cond
id|sgimc-&gt;mconfig1
suffix:colon
id|sgimc-&gt;mconfig0
suffix:semicolon
r_return
id|bank
op_mod
l_int|2
ques
c_cond
id|res
op_amp
l_int|0xffff
suffix:colon
id|res
op_rshift
l_int|16
suffix:semicolon
)brace
DECL|struct|mem
r_struct
id|mem
(brace
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Detect installed memory, do some sanity checks and notify kernel about it&n; */
DECL|function|probe_memory
r_static
r_void
id|probe_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|found
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|mem
id|bank
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|mem
id|space
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|SGIMC_SEG0_BADDR
comma
l_int|0
)brace
comma
(brace
id|SGIMC_SEG1_BADDR
comma
l_int|0
)brace
)brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MC: Probing memory configuration:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|bank
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|tmp
op_assign
id|get_bank_config
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
id|SGIMC_MCONFIG_BVALID
)paren
)paren
r_continue
suffix:semicolon
id|bank
(braket
id|cnt
)braket
dot
id|size
op_assign
id|get_bank_size
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|bank
(braket
id|cnt
)braket
dot
id|addr
op_assign
id|get_bank_addr
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; bank%d: %3ldM @ %08lx&bslash;n&quot;
comma
id|i
comma
id|bank
(braket
id|cnt
)braket
dot
id|size
op_div
l_int|1024
op_div
l_int|1024
comma
id|bank
(braket
id|cnt
)braket
dot
id|addr
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* And you thought bubble sort is dead algorithm... */
r_do
(brace
r_int
r_int
id|addr
comma
id|size
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bank
(braket
id|i
op_minus
l_int|1
)braket
dot
id|addr
OG
id|bank
(braket
id|i
)braket
dot
id|addr
)paren
(brace
id|addr
op_assign
id|bank
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|size
op_assign
id|bank
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|bank
(braket
id|i
)braket
dot
id|addr
op_assign
id|bank
(braket
id|i
op_minus
l_int|1
)braket
dot
id|addr
suffix:semicolon
id|bank
(braket
id|i
)braket
dot
id|size
op_assign
id|bank
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
suffix:semicolon
id|bank
(braket
id|i
op_minus
l_int|1
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|bank
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|found
)paren
suffix:semicolon
multiline_comment|/* Figure out how are memory banks mapped into spaces */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ARRAY_SIZE
c_func
(paren
id|space
)paren
op_logical_and
op_logical_neg
id|found
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|space
(braket
id|j
)braket
dot
id|addr
op_plus
id|space
(braket
id|j
)braket
dot
id|size
op_eq
id|bank
(braket
id|i
)braket
dot
id|addr
)paren
(brace
id|space
(braket
id|j
)braket
dot
id|size
op_add_assign
id|bank
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* There is either hole or overlapping memory */
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;MC: Memory configuration mismatch &quot;
l_string|&quot;(%08lx), expect Bus Error soon&bslash;n&quot;
comma
id|bank
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|space
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|space
(braket
id|i
)braket
dot
id|size
)paren
id|add_memory_region
c_func
(paren
id|space
(braket
id|i
)braket
dot
id|addr
comma
id|space
(braket
id|i
)braket
dot
id|size
comma
id|BOOT_MEM_RAM
)paren
suffix:semicolon
)brace
DECL|function|sgimc_init
r_void
id|__init
id|sgimc_init
c_func
(paren
r_void
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|sgimc
op_assign
(paren
r_struct
id|sgimc_regs
op_star
)paren
(paren
id|KSEG1
op_plus
id|SGIMC_BASE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MC: SGI memory controller Revision %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|sgimc-&gt;systemid
op_amp
id|SGIMC_SYSID_MASKREV
)paren
suffix:semicolon
multiline_comment|/* Place the MC into a known state.  This must be done before&n;&t; * interrupts are first enabled etc.&n;&t; */
multiline_comment|/* Step 0: Make sure we turn off the watchdog in case it&squot;s&n;&t; *         still running (which might be the case after a&n;&t; *         soft reboot).&n;&t; */
id|tmp
op_assign
id|sgimc-&gt;cpuctrl0
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|SGIMC_CCTRL0_WDOG
suffix:semicolon
id|sgimc-&gt;cpuctrl0
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Step 1: The CPU/GIO error status registers will not latch&n;&t; *         up a new error status until the register has been&n;&t; *         cleared by the cpu.  These status registers are&n;&t; *         cleared by writing any value to them.&n;&t; */
id|sgimc-&gt;cstat
op_assign
id|sgimc-&gt;gstat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Step 2: Enable all parity checking in cpu control register&n;&t; *         zero.&n;&t; */
id|tmp
op_assign
id|sgimc-&gt;cpuctrl0
suffix:semicolon
id|tmp
op_or_assign
(paren
id|SGIMC_CCTRL0_EPERRGIO
op_or
id|SGIMC_CCTRL0_EPERRMEM
op_or
id|SGIMC_CCTRL0_R4KNOCHKPARR
)paren
suffix:semicolon
id|sgimc-&gt;cpuctrl0
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Step 3: Setup the MC write buffer depth, this is controlled&n;&t; *         in cpu control register 1 in the lower 4 bits.&n;&t; */
id|tmp
op_assign
id|sgimc-&gt;cpuctrl1
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0xf
suffix:semicolon
id|tmp
op_or_assign
l_int|0xd
suffix:semicolon
id|sgimc-&gt;cpuctrl1
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Step 4: Initialize the RPSS divider register to run as fast&n;&t; *         as it can correctly operate.  The register is laid&n;&t; *         out as follows:&n;&t; *&n;&t; *         ----------------------------------------&n;&t; *         |  RESERVED  |   INCREMENT   | DIVIDER |&n;&t; *         ----------------------------------------&n;&t; *          31        16 15            8 7       0&n;&t; *&n;&t; *         DIVIDER determines how often a &squot;tick&squot; happens,&n;&t; *         INCREMENT determines by how the RPSS increment&n;&t; *         registers value increases at each &squot;tick&squot;. Thus,&n;&t; *         for IP22 we get INCREMENT=1, DIVIDER=1 == 0x101&n;&t; */
id|sgimc-&gt;divider
op_assign
l_int|0x101
suffix:semicolon
multiline_comment|/* Step 5: Initialize GIO64 arbitrator configuration register.&n;&t; *&n;&t; * NOTE: HPC init code in sgihpc_init() must run before us because&n;&t; *       we need to know Guiness vs. FullHouse and the board&n;&t; *       revision on this machine. You have been warned.&n;&t; */
multiline_comment|/* First the basic invariants across all GIO64 implementations. */
id|tmp
op_assign
id|SGIMC_GIOPAR_HPC64
suffix:semicolon
multiline_comment|/* All 1st HPC&squot;s interface at 64bits */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_ONEBUS
suffix:semicolon
multiline_comment|/* Only one physical GIO bus exists */
r_if
c_cond
(paren
id|ip22_is_fullhouse
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Fullhouse specific settings. */
r_if
c_cond
(paren
id|SGIOC_SYSID_BOARDREV
c_func
(paren
id|sgioc-&gt;sysid
)paren
OL
l_int|2
)paren
(brace
id|tmp
op_or_assign
id|SGIMC_GIOPAR_HPC264
suffix:semicolon
multiline_comment|/* 2nd HPC at 64bits */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_PLINEEXP0
suffix:semicolon
multiline_comment|/* exp0 pipelines */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_MASTEREXP1
suffix:semicolon
multiline_comment|/* exp1 masters */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_RTIMEEXP0
suffix:semicolon
multiline_comment|/* exp0 is realtime */
)brace
r_else
(brace
id|tmp
op_or_assign
id|SGIMC_GIOPAR_HPC264
suffix:semicolon
multiline_comment|/* 2nd HPC 64bits */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_PLINEEXP0
suffix:semicolon
multiline_comment|/* exp[01] pipelined */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_PLINEEXP1
suffix:semicolon
id|tmp
op_or_assign
id|SGIMC_GIOPAR_MASTEREISA
suffix:semicolon
multiline_comment|/* EISA masters */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_GFX64
suffix:semicolon
multiline_comment|/* GFX at 64 bits */
)brace
)brace
r_else
(brace
multiline_comment|/* Guiness specific settings. */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_EISA64
suffix:semicolon
multiline_comment|/* MC talks to EISA at 64bits */
id|tmp
op_or_assign
id|SGIMC_GIOPAR_MASTEREISA
suffix:semicolon
multiline_comment|/* EISA bus can act as master */
)brace
id|sgimc-&gt;giopar
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* poof */
id|probe_memory
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|prom_meminit
r_void
id|__init
id|prom_meminit
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|prom_free_prom_memory
r_void
id|__init
id|prom_free_prom_memory
(paren
r_void
)paren
(brace
)brace
eof
