multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; * Galileo Evaluation Boards PCI support.&n; *&n; * The general-purpose functions to read/write and configure the GT64120A&squot;s&n; * PCI registers (function names start with pci0 or pci1) are either direct&n; * copies of functions written by Galileo Technology, or are modifications&n; * of their functions to work with Linux 2.4 vs Linux 2.2.  These functions&n; * are Copyright - Galileo Technology.&n; *&n; * Other functions are derived from other MIPS PCI implementations, or were&n; * written by RidgeRun, Inc,  Copyright (C) 2000 RidgeRun, Inc.&n; *   glonnon@ridgerun.com, skranz@ridgerun.com, stevej@ridgerun.com&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/galileo-boards/ev64120.h&gt;
macro_line|#include &lt;asm/gt64120.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|PCI_DEBUG
macro_line|#undef PCI_DEBUG
macro_line|#ifdef PCI_DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
DECL|macro|SELF
mdefine_line|#define SELF 0
multiline_comment|/*&n; * These functions and structures provide the BIOS scan and mapping of the PCI&n; * devices.&n; */
DECL|macro|MAX_PCI_DEVS
mdefine_line|#define MAX_PCI_DEVS 10
DECL|struct|pci_device
r_struct
id|pci_device
(brace
DECL|member|slot
id|u32
id|slot
suffix:semicolon
DECL|member|BARtype
id|u32
id|BARtype
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|BARsize
id|u32
id|BARsize
(braket
l_int|6
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|__init
id|scan_and_initialize_pci
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|u32
id|__init
id|scan_pci_bus
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
suffix:semicolon
r_static
r_void
id|__init
id|allocate_pci_space
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
suffix:semicolon
r_static
r_void
id|__devinit
id|galileo_pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
suffix:semicolon
multiline_comment|/*&n; * The functions that actually read and write to the controller.&n; * Copied from or modified from Galileo Technology code.&n; */
r_static
r_int
r_int
id|pci0ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|pci0WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|pci1WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|pci0MapIOspace
c_func
(paren
r_int
r_int
id|pci0IoBase
comma
r_int
r_int
id|pci0IoLength
)paren
suffix:semicolon
r_static
r_void
id|pci1MapIOspace
c_func
(paren
r_int
r_int
id|pci1IoBase
comma
r_int
r_int
id|pci1IoLength
)paren
suffix:semicolon
r_static
r_void
id|pci0MapMemory0space
c_func
(paren
r_int
r_int
id|pci0Mem0Base
comma
r_int
r_int
id|pci0Mem0Length
)paren
suffix:semicolon
r_static
r_void
id|pci1MapMemory0space
c_func
(paren
r_int
r_int
id|pci1Mem0Base
comma
r_int
r_int
id|pci1Mem0Length
)paren
suffix:semicolon
r_static
r_void
id|pci0MapMemory1space
c_func
(paren
r_int
r_int
id|pci0Mem1Base
comma
r_int
r_int
id|pci0Mem1Length
)paren
suffix:semicolon
r_static
r_void
id|pci1MapMemory1space
c_func
(paren
r_int
r_int
id|pci1Mem1Base
comma
r_int
r_int
id|pci1Mem1Length
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetIOspaceBase
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetIOspaceSize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory0Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory0Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory1Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory1Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetIOspaceBase
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetIOspaceSize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory0Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory0Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory1Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory1Size
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*  Functions to implement &quot;pci ops&quot;  */
r_static
r_int
id|galileo_pcibios_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u16
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u8
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u32
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u8
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u16
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u32
id|val
)paren
suffix:semicolon
r_static
r_void
id|galileo_pcibios_set_master
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * General-purpose PCI functions.&n; */
multiline_comment|/*&n; * pci0MapIOspace - Maps PCI0 IO space for the master.&n; * Inputs: base and length of pci0Io&n; */
DECL|function|pci0MapIOspace
r_static
r_void
id|pci0MapIOspace
c_func
(paren
r_int
r_int
id|pci0IoBase
comma
r_int
r_int
id|pci0IoLength
)paren
(brace
r_int
r_int
id|pci0IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0IoBase
op_plus
id|pci0IoLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci0IoLength
op_eq
l_int|0
)paren
id|pci0IoTop
op_increment
suffix:semicolon
id|pci0IoBase
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0IoBase
op_rshift
l_int|21
)paren
suffix:semicolon
id|pci0IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|pci0IoTop
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
id|pci0IoBase
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0IOHD_OFS
comma
id|pci0IoTop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapIOspace - Maps PCI1 IO space for the master.&n; * Inputs: base and length of pci1Io&n; */
DECL|function|pci1MapIOspace
r_static
r_void
id|pci1MapIOspace
c_func
(paren
r_int
r_int
id|pci1IoBase
comma
r_int
r_int
id|pci1IoLength
)paren
(brace
r_int
r_int
id|pci1IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci1IoBase
op_plus
id|pci1IoLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci1IoLength
op_eq
l_int|0
)paren
id|pci1IoTop
op_increment
suffix:semicolon
id|pci1IoBase
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci1IoBase
op_rshift
l_int|21
)paren
suffix:semicolon
id|pci1IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|pci1IoTop
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
id|pci1IoBase
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1IOHD_OFS
comma
id|pci1IoTop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0MapMemory0space - Maps PCI0 memory0 space for the master.&n; * Inputs: base and length of pci0Mem0&n; */
DECL|function|pci0MapMemory0space
r_static
r_void
id|pci0MapMemory0space
c_func
(paren
r_int
r_int
id|pci0Mem0Base
comma
r_int
r_int
id|pci0Mem0Length
)paren
(brace
r_int
r_int
id|pci0Mem0Top
op_assign
id|pci0Mem0Base
op_plus
id|pci0Mem0Length
suffix:semicolon
r_if
c_cond
(paren
id|pci0Mem0Length
op_eq
l_int|0
)paren
id|pci0Mem0Top
op_increment
suffix:semicolon
id|pci0Mem0Base
op_assign
id|pci0Mem0Base
op_rshift
l_int|21
suffix:semicolon
id|pci0Mem0Top
op_assign
(paren
(paren
id|pci0Mem0Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
id|pci0Mem0Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M0HD_OFS
comma
id|pci0Mem0Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapMemory0space - Maps PCI1 memory0 space for the master.&n; * Inputs: base and length of pci1Mem0&n; */
DECL|function|pci1MapMemory0space
r_static
r_void
id|pci1MapMemory0space
c_func
(paren
r_int
r_int
id|pci1Mem0Base
comma
r_int
r_int
id|pci1Mem0Length
)paren
(brace
r_int
r_int
id|pci1Mem0Top
op_assign
id|pci1Mem0Base
op_plus
id|pci1Mem0Length
suffix:semicolon
r_if
c_cond
(paren
id|pci1Mem0Length
op_eq
l_int|0
)paren
id|pci1Mem0Top
op_increment
suffix:semicolon
id|pci1Mem0Base
op_assign
id|pci1Mem0Base
op_rshift
l_int|21
suffix:semicolon
id|pci1Mem0Top
op_assign
(paren
(paren
id|pci1Mem0Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M0LD_OFS
comma
id|pci1Mem0Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M0HD_OFS
comma
id|pci1Mem0Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0MapMemory1space - Maps PCI0 memory1 space for the master.&n; * Inputs: base and length of pci0Mem1&n; */
DECL|function|pci0MapMemory1space
r_static
r_void
id|pci0MapMemory1space
c_func
(paren
r_int
r_int
id|pci0Mem1Base
comma
r_int
r_int
id|pci0Mem1Length
)paren
(brace
r_int
r_int
id|pci0Mem1Top
op_assign
id|pci0Mem1Base
op_plus
id|pci0Mem1Length
suffix:semicolon
r_if
c_cond
(paren
id|pci0Mem1Length
op_eq
l_int|0
)paren
id|pci0Mem1Top
op_increment
suffix:semicolon
id|pci0Mem1Base
op_assign
id|pci0Mem1Base
op_rshift
l_int|21
suffix:semicolon
id|pci0Mem1Top
op_assign
(paren
(paren
id|pci0Mem1Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
id|pci0Mem1Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M1HD_OFS
comma
id|pci0Mem1Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapMemory1space - Maps PCI1 memory1 space for the master.&n; * Inputs: base and length of pci1Mem1&n; */
DECL|function|pci1MapMemory1space
r_static
r_void
id|pci1MapMemory1space
c_func
(paren
r_int
r_int
id|pci1Mem1Base
comma
r_int
r_int
id|pci1Mem1Length
)paren
(brace
r_int
r_int
id|pci1Mem1Top
op_assign
id|pci1Mem1Base
op_plus
id|pci1Mem1Length
suffix:semicolon
r_if
c_cond
(paren
id|pci1Mem1Length
op_eq
l_int|0
)paren
id|pci1Mem1Top
op_increment
suffix:semicolon
id|pci1Mem1Base
op_assign
id|pci1Mem1Base
op_rshift
l_int|21
suffix:semicolon
id|pci1Mem1Top
op_assign
(paren
(paren
id|pci1Mem1Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
id|pci1Mem1Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
id|pci1Mem1Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetIOspaceBase - Return PCI0 IO Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 IO Base Address.&n; */
DECL|function|pci0GetIOspaceBase
r_static
r_int
r_int
id|pci0GetIOspaceBase
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetIOspaceSize - Return PCI0 IO Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 IO Bar Size.&n; */
DECL|function|pci0GetIOspaceSize
r_static
r_int
r_int
id|pci0GetIOspaceSize
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOHD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory0Base - Return PCI0 Memory 0 Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 0 Base Address.&n; */
DECL|function|pci0GetMemory0Base
r_static
r_int
r_int
id|pci0GetMemory0Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory0Size - Return PCI0 Memory 0 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 0 Bar Size.&n; */
DECL|function|pci0GetMemory0Size
r_static
r_int
r_int
id|pci0GetMemory0Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory1Base - Return PCI0 Memory 1 Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 1 Base Address.&n; */
DECL|function|pci0GetMemory1Base
r_static
r_int
r_int
id|pci0GetMemory1Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory1Size - Return PCI0 Memory 1 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 1 Bar Size.&n; */
DECL|function|pci0GetMemory1Size
r_static
r_int
r_int
id|pci0GetMemory1Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetIOspaceBase - Return PCI1 IO Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 IO Base Address.&n; */
DECL|function|pci1GetIOspaceBase
r_static
r_int
r_int
id|pci1GetIOspaceBase
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetIOspaceSize - Return PCI1 IO Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 IO Bar Size.&n; */
DECL|function|pci1GetIOspaceSize
r_static
r_int
r_int
id|pci1GetIOspaceSize
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOHD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory0Base - Return PCI1 Memory 0 Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 0 Base Address.&n; */
DECL|function|pci1GetMemory0Base
r_static
r_int
r_int
id|pci1GetMemory0Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory0Size - Return PCI1 Memory 0 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 0 Bar Size.&n; */
DECL|function|pci1GetMemory0Size
r_static
r_int
r_int
id|pci1GetMemory0Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory1Base - Return PCI1 Memory 1 Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 1 Base Address.&n; */
DECL|function|pci1GetMemory1Base
r_static
r_int
r_int
id|pci1GetMemory1Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory1Size - Return PCI1 Memory 1 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 1 Bar Size.&n; */
DECL|function|pci1GetMemory1Size
r_static
r_int
r_int
id|pci1GetMemory1Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_range_ck -&n; *&n; * Check if the pci device that are trying to access does really exists&n; * on the evaluation board.&n; *&n; * Inputs :&n; * bus - bus number (0 for PCI 0 ; 1 for PCI 1)&n; * dev - number of device on the specific pci bus&n; *&n; * Outpus :&n; * 0 - if OK , 1 - if failure&n; */
DECL|function|pci_range_ck
r_static
id|__inline__
r_int
id|pci_range_ck
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev
)paren
(brace
singleline_comment|//DBG(KERN_INFO &quot;p_r_c %d %d&bslash;n&quot;,bus,dev);
r_if
c_cond
(paren
(paren
(paren
id|bus
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bus
op_eq
l_int|1
)paren
)paren
op_logical_and
(paren
id|dev
op_ge
l_int|6
)paren
op_logical_and
(paren
id|dev
op_le
l_int|8
)paren
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// Bus/Device Number OK
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Bus/Device Number not OK
)brace
multiline_comment|/*&n; * pciXReadConfigReg  - Read from a PCI configuration register&n; *                    - Make sure the GT is configured as a master before&n; *                      reading from another device on the PCI.&n; *                   - The function takes care of Big/Little endian conversion.&n; * INPUTS:   regOffset: The register offset as it apears in the GT spec (or PCI&n; *                        spec)&n; *           pciDevNum: The device number needs to be addressed.&n; * RETURNS: data , if the data == 0xffffffff check the master abort bit in the&n; *                 cause register to make sure the data is valid&n; *&n; *  Configuration Address 0xCF8:&n; *&n; *       31 30    24 23  16 15  11 10     8 7      2  0     &lt;=bit Number&n; *  |congif|Reserved|  Bus |Device|Function|Register|00|&n; *  |Enable|        |Number|Number| Number | Number |  |    &lt;=field Name&n; *&n; */
DECL|function|pci0ReadConfigReg
r_static
r_int
r_int
id|pci0ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
multiline_comment|/*  The casual observer might wonder why the READ is duplicated here,&n;&t;   rather than immediately following the WRITE, and just have the&n;&t;   swap in the &quot;if&quot;.  That&squot;s because there is a latency problem&n;&t;   with trying to read immediately after setting up the address&n;&t;   register.  The &quot;if&quot; check gives enough time for the address&n;&t;   to stabilize, so the READ can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|cpu_to_le32
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
DECL|function|pci1ReadConfigReg
r_static
r_int
r_int
id|pci1ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
multiline_comment|/*  The casual observer might wonder why the READ is duplicated here,&n;&t;   rather than immediately following the WRITE, and just have the&n;&t;   swap in the &quot;if&quot;.  That&squot;s because there is a latency problem&n;&t;   with trying to read immediately after setting up the address&n;&t;   register.  The &quot;if&quot; check gives enough time for the address&n;&t;   to stabilize, so the READ can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
multiline_comment|/* when configurating our own PCI 1 L-unit the access is through&n;&t;&t;   the PCI 0 interface with reg number = reg number + 0x80 */
id|DataForRegCf8
op_or_assign
l_int|0x80
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_else
(brace
id|GT_READ
c_func
(paren
id|GT_PCI1_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|cpu_to_le32
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pciXWriteConfigReg - Write to a PCI configuration register&n; *                    - Make sure the GT is configured as a master before&n; *                      writingto another device on the PCI.&n; *                    - The function takes care of Big/Little endian conversion.&n; * Inputs:   unsigned int regOffset: The register offset as it apears in the&n; *           GT spec&n; *                   (or any other PCI device spec)&n; *           pciDevNum: The device number needs to be addressed.&n; *&n; *  Configuration Address 0xCF8:&n; *&n; *       31 30    24 23  16 15  11 10     8 7      2  0     &lt;=bit Number&n; *  |congif|Reserved|  Bus |Device|Function|Register|00|&n; *  |Enable|        |Number|Number| Number | Number |  |    &lt;=field Name&n; *&n; */
DECL|function|pci0WriteConfigReg
r_static
r_void
id|pci0WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|le32_to_cpu
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|pci1WriteConfigReg
r_static
r_void
id|pci1WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
multiline_comment|/*  There is a latency problem&n;&t;   with trying to read immediately after setting up the address&n;&t;   register.  The &quot;if&quot; check gives enough time for the address&n;&t;   to stabilize, so the WRITE can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
multiline_comment|/* when configurating our own PCI 1 L-unit the access is through&n;&t;&t;   the PCI 0 interface with reg number = reg number + 0x80 */
id|DataForRegCf8
op_or_assign
l_int|0x80
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|le32_to_cpu
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * galileo_pcibios_(read/write)_config_(dword/word/byte) -&n; *&n; * reads/write a dword/word/byte register from the configuration space&n; * of a device.&n; *&n; * Inputs :&n; * bus - bus number&n; * dev - device number&n; * offset - register offset in the configuration space&n; * val - value to be written / read&n; *&n; * Outputs :&n; * PCIBIOS_SUCCESSFUL when operation was succesfull&n; * PCIBIOS_DEVICE_NOT_FOUND when the bus or dev is errorneous&n; * PCIBIOS_BAD_REGISTER_NUMBER when accessing non aligned&n; */
DECL|function|galileo_pcibios_read_config_dword
r_static
r_int
id|galileo_pcibios_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u32
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
singleline_comment|//DBG(KERN_INFO &quot;rcd entry &bslash;n&quot;,offset,val);
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffffffff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) *val = pci1ReadConfigReg (offset,device);
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: rcd dev %d offset %x %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
op_star
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is so that the upper PCI layer will get the correct return&n;&t; * value if we&squot;re not attached to anything.&n;&t; */
r_if
c_cond
(paren
(paren
id|offset
op_eq
l_int|0
)paren
op_logical_and
(paren
op_star
id|val
op_eq
l_int|0xffffffff
)paren
)paren
(brace
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_read_config_word
r_static
r_int
id|galileo_pcibios_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u16
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
op_rshift
(paren
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
op_star
l_int|8
)paren
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) *val = (unsigned short) (pci1ReadConfigReg(offset,device) &gt;&gt; ((offset &amp; ~0x3) * 8));
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: rcw dev %d offset %x %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
op_star
id|val
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_read_config_byte
r_static
r_int
id|galileo_pcibios_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u8
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
(paren
r_int
r_char
)paren
(paren
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
op_rshift
(paren
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
op_star
l_int|8
)paren
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) *val = (unsigned char) (pci1ReadConfigReg(offset,device) &gt;&gt; ((offset &amp; ~0x3) * 8));
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: rcb dev %d offset %x %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
op_star
id|val
)paren
suffix:semicolon
multiline_comment|/*  This is so that the upper PCI layer will get the correct return value if&n;&t;   we&squot;re not attached to anything.  */
r_if
c_cond
(paren
(paren
id|offset
op_eq
l_int|0xe
)paren
op_logical_and
(paren
op_star
id|val
op_eq
l_int|0xff
)paren
)paren
(brace
id|u32
id|MasterAbort
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
op_amp
id|MasterAbort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MasterAbort
op_amp
l_int|0x40000
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;PCI Master Abort, ICR %x&bslash;n&quot;
comma
id|MasterAbort
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
(paren
id|MasterAbort
op_amp
l_int|0xfffbffff
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_dword
r_static
r_int
id|galileo_pcibios_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u32
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|val
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,val);
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: wcd dev %d, offset %x, val %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
id|val
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_word
r_static
r_int
id|galileo_pcibios_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u16
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) tmp = pci1ReadConfigReg (offset,device);
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffff0000
)paren
op_or
(paren
id|val
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|2
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0x0000ffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xffff
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|tmp
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,tmp);
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: wcw dev %d, offset %x, val %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
id|val
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_byte
r_static
r_int
id|galileo_pcibios_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u8
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) tmp = pci1ReadConfigReg (offset,device);
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffffff00
)paren
op_or
(paren
id|val
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|1
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffff00ff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|2
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xff00ffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|3
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0x00ffffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|tmp
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,tmp);
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: wcb dev %d, offset %x, val %x&bslash;n&quot;
comma
id|dev
comma
id|offset
comma
id|val
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_set_master
r_static
r_void
id|galileo_pcibios_set_master
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: galileo_pcibios_set_master&bslash;n&quot;
)paren
suffix:semicolon
id|galileo_pcibios_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|galileo_pcibios_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;PCI: Enabling device %s (%04x)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*  Externally-expected functions.  Do not change function names  */
DECL|function|pcibios_enable_resources
r_int
id|pcibios_enable_resources
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
comma
id|old_cmd
suffix:semicolon
id|u16
id|tmp
suffix:semicolon
id|u8
id|tmp1
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_enable_resources&bslash;n&quot;
)paren
suffix:semicolon
id|galileo_pcibios_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|old_cmd
op_assign
id|cmd
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|r
op_assign
op_amp
id|dev-&gt;resource
(braket
id|idx
)braket
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: BAR %d, start %lx, end %lx, flags %lx&bslash;n&quot;
comma
id|idx
comma
id|r-&gt;start
comma
id|r-&gt;end
comma
id|r-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;start
op_logical_and
id|r-&gt;end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: Device %s not available because of resource collisions&bslash;n&quot;
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_ne
id|old_cmd
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;PCI: Enabling device %s (%04x -&gt; %04x)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|old_cmd
comma
id|cmd
)paren
suffix:semicolon
id|galileo_pcibios_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Let&squot;s fix up the latency timer and cache line size here.  Cache line size =&n;&t;   32 bytes / sizeof dword (4) = 8.&n;&t;   Latency timer must be &gt; 8.  32 is random but appears to work.&n;&t; */
id|galileo_pcibios_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_ne
l_int|8
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: PCI setting cache line size to 8 from %d&bslash;n&quot;
comma
id|tmp1
)paren
suffix:semicolon
id|galileo_pcibios_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_CACHE_LINE_SIZE
comma
l_int|8
)paren
suffix:semicolon
)brace
id|galileo_pcibios_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
OL
l_int|32
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: PCI setting latency timer to 32 from %d&bslash;n&quot;
comma
id|tmp1
)paren
suffix:semicolon
id|galileo_pcibios_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
l_int|32
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pcibios_enable_device
r_int
id|pcibios_enable_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|mask
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_enable_device&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|pcibios_enable_resources
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|pcibios_align_resource
r_void
id|pcibios_align_resource
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
r_int
r_int
id|start
op_assign
id|res-&gt;start
suffix:semicolon
multiline_comment|/* We need to avoid collisions with `mirrored&squot; VGA ports&n;&t;&t;   and other strange ISA hardware, so we always want the&n;&t;&t;   addresses kilobyte aligned.  */
r_if
c_cond
(paren
id|size
OG
l_int|0x100
)paren
(brace
id|DBG
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: I/O Region %s/%d too large&quot;
l_string|&quot; (%ld bytes)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|dev-&gt;resource
op_minus
id|res
comma
id|size
)paren
suffix:semicolon
)brace
id|start
op_assign
(paren
id|start
op_plus
l_int|1024
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
id|res-&gt;start
op_assign
id|start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * structure galileo_pci_ops&n; *&n; * This structure holds the pointers for the PCI configuration space&n; * access, and the fixup for the interrupts.&n; * This structure is registered to the operating system in boot time&n; */
DECL|variable|galileo_pci_ops
r_struct
id|pci_ops
id|galileo_pci_ops
op_assign
(brace
id|galileo_pcibios_read_config_byte
comma
id|galileo_pcibios_read_config_word
comma
id|galileo_pcibios_read_config_dword
comma
id|galileo_pcibios_write_config_byte
comma
id|galileo_pcibios_write_config_word
comma
id|galileo_pcibios_write_config_dword
)brace
suffix:semicolon
multiline_comment|/*&n; * galileo_pcibios_fixup_bus -&n; *&n; * After detecting all agents over the PCI , this function is called&n; * in order to give an interrupt number for each PCI device starting&n; * from IRQ 20. It does also enables master for each device.&n; *&n; * Inputs :&n; * mem_start , mem_end are not relevant in MIPS architecture.&n; *&n; * Outpus :&n; * return always mem_start&n; */
DECL|function|galileo_pcibios_fixup_bus
r_static
r_void
id|__devinit
id|galileo_pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_int
r_int
id|Current_IRQ
op_assign
l_int|20
suffix:semicolon
r_struct
id|pci_bus
op_star
id|current_bus
op_assign
id|bus
suffix:semicolon
r_struct
id|pci_dev
op_star
id|devices
suffix:semicolon
r_struct
id|list_head
op_star
id|devices_link
suffix:semicolon
id|list_for_each
c_func
(paren
id|devices_link
comma
op_amp
(paren
id|current_bus-&gt;devices
)paren
)paren
(brace
id|devices
op_assign
id|pci_dev_b
c_func
(paren
id|devices_link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devices
op_ne
l_int|NULL
)paren
(brace
id|devices-&gt;irq
op_assign
id|Current_IRQ
op_increment
suffix:semicolon
multiline_comment|/* Assign an interrupt number for the device */
id|galileo_pcibios_write_config_byte
c_func
(paren
id|devices
comma
id|PCI_INTERRUPT_LINE
comma
id|Current_IRQ
)paren
suffix:semicolon
id|galileo_pcibios_set_master
c_func
(paren
id|devices
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|pcibios_fixups
r_struct
id|pci_fixup
id|pcibios_fixups
(braket
)braket
op_assign
(brace
singleline_comment|//    { PCI_FIXUP_HEADER, 0x4620, 0x11ab, galileo_pcibios_fixup },
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|pcibios_fixup_bus
r_void
id|__devinit
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|c
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_fixup_bus&bslash;n&quot;
)paren
suffix:semicolon
id|galileo_pcibios_fixup_bus
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This code was derived from Galileo Technology&squot;s example&n; * and significantly reworked.&n; *&n; * This is very simple.  It does not scan multiple function devices.  It does&n; * not scan behind bridges.  Those would be simple to implement, but we don&squot;t&n; * currently need this.&n; */
DECL|function|scan_and_initialize_pci
r_static
r_void
id|__init
id|scan_and_initialize_pci
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_device
id|pci_devices
(braket
id|MAX_PCI_DEVS
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scan_pci_bus
c_func
(paren
id|pci_devices
)paren
)paren
(brace
id|allocate_pci_space
c_func
(paren
id|pci_devices
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is your basic PCI scan.  It goes through each slot and checks to&n; * see if there&squot;s something that responds.  If so, then get the size and&n; * type of each of the responding BARs.  Save them for later.&n; */
DECL|function|scan_pci_bus
r_static
id|u32
id|__init
id|scan_pci_bus
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
(brace
id|u32
id|arrayCounter
op_assign
l_int|0
suffix:semicolon
id|u32
id|memType
suffix:semicolon
id|u32
id|memSize
suffix:semicolon
id|u32
id|pci_slot
comma
id|bar
suffix:semicolon
id|u32
id|id
suffix:semicolon
id|u32
id|c18RegValue
suffix:semicolon
r_struct
id|pci_dev
id|device
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: scan_pci_bus&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   According to PCI REV 2.1 MAX agents on the bus are 21.&n;&t;   We don&squot;t bother scanning ourselves (slot 0).&n;&t; */
r_for
c_loop
(paren
id|pci_slot
op_assign
l_int|1
suffix:semicolon
id|pci_slot
OL
l_int|22
suffix:semicolon
id|pci_slot
op_increment
)paren
(brace
id|device.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|pci_slot
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_VENDOR_ID
comma
op_amp
id|device
)paren
suffix:semicolon
multiline_comment|/*  Check for a PCI Master Abort (nothing responds in the slot) */
id|GT_READ
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
op_amp
id|c18RegValue
)paren
suffix:semicolon
multiline_comment|/* Clearing bit 18 of in the Cause Register 0xc18 by writting 0. */
id|GT_WRITE
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
(paren
id|c18RegValue
op_amp
l_int|0xfffbffff
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_ne
l_int|0xffffffff
)paren
op_logical_and
op_logical_neg
(paren
id|c18RegValue
op_amp
l_int|0x40000
)paren
)paren
(brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: found device %x, slot %d&bslash;n&quot;
comma
id|id
comma
id|pci_slot
)paren
suffix:semicolon
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|slot
op_assign
id|pci_slot
suffix:semicolon
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
l_int|6
suffix:semicolon
id|bar
op_increment
)paren
(brace
id|memType
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
)paren
suffix:semicolon
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARtype
(braket
id|bar
)braket
op_assign
id|memType
op_amp
l_int|1
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|memSize
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memType
op_amp
l_int|1
)paren
(brace
multiline_comment|/*  IO space  */
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARsize
(braket
id|bar
)braket
op_assign
op_complement
(paren
id|memSize
op_amp
l_int|0xfffffffc
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  memory space */
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARsize
(braket
id|bar
)braket
op_assign
op_complement
(paren
id|memSize
op_amp
l_int|0xfffffff0
)paren
op_plus
l_int|1
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: BAR %d, type %d, size %x&bslash;n&quot;
comma
id|bar
comma
(paren
id|memType
op_amp
l_int|1
)paren
comma
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARsize
(braket
id|bar
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*  BAR counter  */
id|arrayCounter
op_increment
suffix:semicolon
)brace
multiline_comment|/*  found a device  */
)brace
multiline_comment|/*  slot counter  */
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: found %d devices&bslash;n&quot;
comma
id|arrayCounter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arrayCounter
OL
id|MAX_PCI_DEVS
)paren
(brace
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|slot
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|arrayCounter
)paren
suffix:semicolon
)brace
DECL|macro|ALIGN
mdefine_line|#define ALIGN(val,align)        (((val) + ((align) - 1)) &amp; ~((align) - 1))
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2) ((val1) &gt; (val2) ? (val1) : (val2))
multiline_comment|/*&n; * This function goes through the list of devices and allocates the BARs in&n; * either IO or MEM space.  It does it in order of size, which will limit the&n; * amount of fragmentation we have in the IO and MEM spaces.&n; */
DECL|function|allocate_pci_space
r_static
r_void
id|__init
id|allocate_pci_space
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
(brace
id|u32
id|count
comma
id|maxcount
comma
id|bar
suffix:semicolon
id|u32
id|maxSize
comma
id|maxDevice
comma
id|maxBAR
suffix:semicolon
id|u32
id|alignto
suffix:semicolon
id|u32
id|base
suffix:semicolon
id|u32
id|pci0_mem_base
op_assign
id|pci0GetMemory0Base
c_func
(paren
)paren
suffix:semicolon
id|u32
id|pci0_io_base
op_assign
id|pci0GetIOspaceBase
c_func
(paren
)paren
suffix:semicolon
r_struct
id|pci_dev
id|device
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: allocate_pci_space&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;pci0_io_base %x&bslash;n&quot;
comma
id|pci0_io_base
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;pci0_mem_base %x&bslash;n&quot;
comma
id|pci0_mem_base
)paren
suffix:semicolon
multiline_comment|/*  How many PCI devices do we have?  */
id|maxcount
op_assign
id|MAX_PCI_DEVS
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_PCI_DEVS
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_devices
(braket
id|count
)braket
dot
id|slot
op_eq
op_minus
l_int|1
)paren
(brace
id|maxcount
op_assign
id|count
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
singleline_comment|//    DBG(KERN_INFO &quot;Found %d devices&bslash;n&quot;, maxcount);
r_do
(brace
multiline_comment|/*  Find the largest size BAR we need to allocate  */
id|maxSize
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|maxcount
suffix:semicolon
id|count
op_increment
)paren
(brace
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
l_int|6
suffix:semicolon
id|bar
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_devices
(braket
id|count
)braket
dot
id|BARsize
(braket
id|bar
)braket
OG
id|maxSize
)paren
(brace
id|maxSize
op_assign
id|pci_devices
(braket
id|count
)braket
dot
id|BARsize
(braket
id|bar
)braket
suffix:semicolon
id|maxDevice
op_assign
id|count
suffix:semicolon
id|maxBAR
op_assign
id|bar
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;   We&squot;ve found the largest BAR.  Allocate it into IO or&n;&t;&t;   mem space.  We don&squot;t idiot check the bases to make&n;&t;&t;   sure they haven&squot;t overflowed the current size for that aperture.&n;&n;&t;&t;   Don&squot;t bother to enable the device&squot;s IO or MEM space here.  That will&n;&t;&t;   be done in pci_enable_resources if the device is activated by a driver.&n;&t;&t; */
r_if
c_cond
(paren
id|maxSize
)paren
(brace
id|device.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|slot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|BARtype
(braket
id|maxBAR
)braket
op_eq
l_int|1
)paren
(brace
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|maxSize
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|pci0_io_base
comma
id|alignto
)paren
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|maxBAR
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
id|base
op_or
l_int|0x1
)paren
suffix:semicolon
id|pci0_io_base
op_assign
id|base
op_plus
id|alignto
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;Device %d BAR %d address %x&bslash;n&quot;
comma
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|slot
comma
id|maxBAR
comma
id|base
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;New IO base %x&bslash;n&quot;
comma
id|pci0_io_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|maxSize
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|pci0_mem_base
comma
id|alignto
)paren
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|maxBAR
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
id|base
)paren
suffix:semicolon
id|pci0_mem_base
op_assign
id|base
op_plus
id|alignto
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;Device %d BAR %d address %x&bslash;n&quot;
comma
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|slot
comma
id|maxBAR
comma
id|base
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;New mem base %x&bslash;n&quot;
comma
id|pci0_mem_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;   This entry is finished.  Remove it from the list we&squot;ll scan.&n;&t;&t;&t; */
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|BARsize
(braket
id|maxBAR
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|maxSize
)paren
suffix:semicolon
)brace
DECL|function|pcibios_assign_all_busses
r_int
id|__init
r_int
id|pcibios_assign_all_busses
c_func
(paren
r_void
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pcibios_init
r_static
r_int
id|__init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_struct
id|pci_dev
id|controller
suffix:semicolon
id|controller.devfn
op_assign
id|SELF
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_init&bslash;n&quot;
)paren
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0_CMD_OFS
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: PCI0 command - %x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0_BARE_OFS
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: BAR0 - %x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * You have to enable bus mastering to configure any other&n;&t; * card on the bus.&n;&t; */
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_COMMAND
comma
op_amp
id|controller
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: command/status - %x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_or_assign
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_SERR
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: new command/status - %x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_COMMAND
comma
op_amp
id|controller
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*  This scans the PCI bus and sets up initial values.  */
id|scan_and_initialize_pci
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset PCI I/O and PCI MEM values to ones supported by EVM.&n;&t; */
id|ioport_resource.start
op_assign
l_int|0x10000000
suffix:semicolon
id|ioport_resource.end
op_assign
l_int|0x11ffffff
suffix:semicolon
multiline_comment|/*  32 MB */
id|iomem_resource.start
op_assign
l_int|0x12000000
suffix:semicolon
id|iomem_resource.end
op_assign
l_int|0x13ffffff
suffix:semicolon
multiline_comment|/* 32 MB */
id|pci_scan_bus
c_func
(paren
l_int|0
comma
op_amp
id|galileo_pci_ops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pcibios_init
id|subsys_initcall
c_func
(paren
id|pcibios_init
)paren
suffix:semicolon
DECL|function|pcibios_setup
r_char
op_star
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_setup&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Nothing to do for now.  */
r_return
id|str
suffix:semicolon
)brace
eof
