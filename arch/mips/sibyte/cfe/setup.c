multiline_comment|/*&n; * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/reboot.h&gt;
macro_line|#include &lt;asm/sibyte/board.h&gt;
macro_line|#include &quot;cfe_api.h&quot;
macro_line|#include &quot;cfe_error.h&quot;
multiline_comment|/* Max ram addressable in 32-bit segments */
macro_line|#ifdef CONFIG_MIPS64
DECL|macro|MAX_RAM_SIZE
mdefine_line|#define MAX_RAM_SIZE (~0ULL)
macro_line|#else
macro_line|#ifdef CONFIG_HIGHMEM
macro_line|#ifdef CONFIG_64BIT_PHYS_ADDR
DECL|macro|MAX_RAM_SIZE
mdefine_line|#define MAX_RAM_SIZE (~0ULL)
macro_line|#else
DECL|macro|MAX_RAM_SIZE
mdefine_line|#define MAX_RAM_SIZE (0xffffffffULL)
macro_line|#endif
macro_line|#else
DECL|macro|MAX_RAM_SIZE
mdefine_line|#define MAX_RAM_SIZE (0x1fffffffULL)
macro_line|#endif
macro_line|#endif
DECL|macro|SIBYTE_MAX_MEM_REGIONS
mdefine_line|#define SIBYTE_MAX_MEM_REGIONS 8
DECL|variable|board_mem_region_addrs
id|phys_t
id|board_mem_region_addrs
(braket
id|SIBYTE_MAX_MEM_REGIONS
)braket
suffix:semicolon
DECL|variable|board_mem_region_sizes
id|phys_t
id|board_mem_region_sizes
(braket
id|SIBYTE_MAX_MEM_REGIONS
)braket
suffix:semicolon
DECL|variable|board_mem_region_count
r_int
r_int
id|board_mem_region_count
suffix:semicolon
DECL|variable|cfe_cons_handle
r_int
id|cfe_cons_handle
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_extern
r_int
r_int
id|initrd_start
comma
id|initrd_end
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_KGDB
r_extern
r_int
id|kgdb_port
suffix:semicolon
macro_line|#endif
DECL|function|cfe_linux_exit
r_static
r_void
id|ATTRIB_NORET
id|cfe_linux_exit
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_int
id|warm
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
r_static
r_int
id|reboot_smp
suffix:semicolon
multiline_comment|/* Don&squot;t repeat the process from another CPU */
r_if
c_cond
(paren
op_logical_neg
id|reboot_smp
)paren
(brace
multiline_comment|/* Get CPU 0 to do the cfe_exit */
id|reboot_smp
op_assign
l_int|1
suffix:semicolon
id|smp_call_function
c_func
(paren
id|cfe_linux_exit
comma
id|arg
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Passing control back to CFE...&bslash;n&quot;
)paren
suffix:semicolon
id|cfe_exit
c_func
(paren
id|warm
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cfe_exit returned??&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|cfe_linux_restart
r_static
r_void
id|ATTRIB_NORET
id|cfe_linux_restart
c_func
(paren
r_char
op_star
id|command
)paren
(brace
r_static
r_const
r_int
id|zero
suffix:semicolon
id|cfe_linux_exit
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|zero
)paren
suffix:semicolon
)brace
DECL|function|cfe_linux_halt
r_static
r_void
id|ATTRIB_NORET
id|cfe_linux_halt
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_int
id|one
op_assign
l_int|1
suffix:semicolon
id|cfe_linux_exit
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|one
)paren
suffix:semicolon
)brace
DECL|function|prom_meminit
r_static
id|__init
r_void
id|prom_meminit
c_func
(paren
r_void
)paren
(brace
id|u64
id|addr
comma
id|size
comma
id|type
suffix:semicolon
multiline_comment|/* regardless of 64BIT_PHYS_ADDR */
r_int
id|mem_flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_int
id|rd_flag
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_int
r_int
id|initrd_pstart
suffix:semicolon
r_int
r_int
id|initrd_pend
suffix:semicolon
id|initrd_pstart
op_assign
id|CPHYSADDR
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
id|initrd_pend
op_assign
id|CPHYSADDR
c_func
(paren
id|initrd_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initrd_start
op_logical_and
(paren
(paren
id|initrd_pstart
OG
id|MAX_RAM_SIZE
)paren
op_logical_or
(paren
id|initrd_pend
OG
id|MAX_RAM_SIZE
)paren
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;initrd out of addressable memory&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* INITRD */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|cfe_enummem
c_func
(paren
id|idx
comma
id|mem_flags
comma
op_amp
id|addr
comma
op_amp
id|size
comma
op_amp
id|type
)paren
op_ne
id|CFE_ERR_NOMORE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|rd_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CFE_MI_AVAILABLE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * See if this block contains (any portion of) the&n;&t;&t;&t; * ramdisk&n;&t;&t;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
r_if
c_cond
(paren
(paren
id|initrd_pstart
OG
id|addr
)paren
op_logical_and
(paren
id|initrd_pstart
OL
(paren
id|addr
op_plus
id|size
)paren
)paren
)paren
(brace
id|add_memory_region
c_func
(paren
id|addr
comma
id|initrd_pstart
op_minus
id|addr
comma
id|BOOT_MEM_RAM
)paren
suffix:semicolon
id|rd_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|initrd_pend
OG
id|addr
)paren
op_logical_and
(paren
id|initrd_pend
OL
(paren
id|addr
op_plus
id|size
)paren
)paren
)paren
(brace
id|add_memory_region
c_func
(paren
id|initrd_pend
comma
(paren
id|addr
op_plus
id|size
)paren
op_minus
id|initrd_pend
comma
id|BOOT_MEM_RAM
)paren
suffix:semicolon
id|rd_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|rd_flag
)paren
(brace
r_if
c_cond
(paren
id|addr
OG
id|MAX_RAM_SIZE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_plus
id|size
OG
id|MAX_RAM_SIZE
)paren
id|size
op_assign
id|MAX_RAM_SIZE
op_minus
(paren
id|addr
op_plus
id|size
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * memcpy/__copy_user prefetch, which&n;&t;&t;&t;&t; * will cause a bus error for&n;&t;&t;&t;&t; * KSEG/KUSEG addrs not backed by RAM.&n;&t;&t;&t;&t; * Hence, reserve some padding for the&n;&t;&t;&t;&t; * prefetch distance.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|size
OG
l_int|512
)paren
id|size
op_sub_assign
l_int|512
suffix:semicolon
id|add_memory_region
c_func
(paren
id|addr
comma
id|size
comma
id|BOOT_MEM_RAM
)paren
suffix:semicolon
)brace
id|board_mem_region_addrs
(braket
id|board_mem_region_count
)braket
op_assign
id|addr
suffix:semicolon
id|board_mem_region_sizes
(braket
id|board_mem_region_count
)braket
op_assign
id|size
suffix:semicolon
id|board_mem_region_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|board_mem_region_count
op_eq
id|SIBYTE_MAX_MEM_REGIONS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Too many regions.  Need to configure more&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
id|add_memory_region
c_func
(paren
id|initrd_pstart
comma
id|initrd_pend
op_minus
id|initrd_pstart
comma
id|BOOT_MEM_RESERVED
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|initrd_setup
r_static
r_int
id|__init
id|initrd_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_char
id|rdarg
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_char
op_star
id|tmp
comma
op_star
id|endptr
suffix:semicolon
r_int
r_int
id|initrd_size
suffix:semicolon
multiline_comment|/* Make a copy of the initrd argument so we can smash it up here */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
r_sizeof
(paren
id|rdarg
)paren
op_minus
l_int|1
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|str
(braket
id|idx
)braket
op_logical_or
(paren
id|str
(braket
id|idx
)braket
op_eq
l_char|&squot; &squot;
)paren
)paren
r_break
suffix:semicolon
id|rdarg
(braket
id|idx
)braket
op_assign
id|str
(braket
id|idx
)braket
suffix:semicolon
)brace
id|rdarg
(braket
id|idx
)braket
op_assign
l_int|0
suffix:semicolon
id|str
op_assign
id|rdarg
suffix:semicolon
multiline_comment|/*&n;&t; *Initrd location comes in the form &quot;&lt;hex size of ramdisk in bytes&gt;@&lt;location in memory&gt;&quot;&n;&t; *  e.g. initrd=3abfd@80010000.  This is set up by the loader.&n;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
id|str
suffix:semicolon
op_star
id|tmp
op_ne
l_char|&squot;@&squot;
suffix:semicolon
id|tmp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|tmp
)paren
(brace
r_goto
id|fail
suffix:semicolon
)brace
)brace
op_star
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|tmp
)paren
(brace
r_goto
id|fail
suffix:semicolon
)brace
id|initrd_size
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
op_amp
id|endptr
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|endptr
)paren
(brace
op_star
(paren
id|tmp
op_minus
l_int|1
)paren
op_assign
l_char|&squot;@&squot;
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
op_star
(paren
id|tmp
op_minus
l_int|1
)paren
op_assign
l_char|&squot;@&squot;
suffix:semicolon
id|initrd_start
op_assign
id|simple_strtoul
c_func
(paren
id|tmp
comma
op_amp
id|endptr
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|endptr
)paren
(brace
r_goto
id|fail
suffix:semicolon
)brace
id|initrd_end
op_assign
id|initrd_start
op_plus
id|initrd_size
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Found initrd of %lx@%lx&bslash;n&quot;
comma
id|initrd_size
comma
id|initrd_start
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|fail
suffix:colon
id|prom_printf
c_func
(paren
l_string|&quot;Bad initrd argument.  Disabling initrd&bslash;n&quot;
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
id|initrd_end
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * prom_init is called just after the cpu type is determined, from setup_arch()&n; */
DECL|function|prom_init
r_void
id|__init
id|prom_init
c_func
(paren
r_void
)paren
(brace
r_uint64
id|cfe_ept
comma
id|cfe_handle
suffix:semicolon
r_int
r_int
id|cfe_eptseal
suffix:semicolon
r_int
id|argc
op_assign
id|fw_arg0
suffix:semicolon
r_char
op_star
op_star
id|envp
op_assign
(paren
r_char
op_star
op_star
)paren
id|fw_arg2
suffix:semicolon
r_int
op_star
id|prom_vec
op_assign
(paren
r_int
op_star
)paren
id|fw_arg3
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB
r_char
op_star
id|arg
suffix:semicolon
macro_line|#endif
id|_machine_restart
op_assign
id|cfe_linux_restart
suffix:semicolon
id|_machine_halt
op_assign
id|cfe_linux_halt
suffix:semicolon
id|_machine_power_off
op_assign
id|cfe_linux_halt
suffix:semicolon
multiline_comment|/*&n;&t; * Check if a loader was used; if NOT, the 4 arguments are&n;&t; * what CFE gives us (handle, 0, EPT and EPTSEAL)&n;&t; */
r_if
c_cond
(paren
id|argc
OL
l_int|0
)paren
(brace
id|cfe_handle
op_assign
(paren
r_uint64
)paren
(paren
r_int
)paren
id|argc
suffix:semicolon
id|cfe_ept
op_assign
(paren
r_int
)paren
id|envp
suffix:semicolon
id|cfe_eptseal
op_assign
(paren
r_uint32
)paren
(paren
r_int
r_int
)paren
id|prom_vec
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int32
)paren
(paren
r_int
)paren
id|prom_vec
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Old loader; all it gives us is the handle,&n;&t;&t;&t; * so use the &quot;known&quot; entrypoint and assume&n;&t;&t;&t; * the seal.&n;&t;&t;&t; */
id|cfe_handle
op_assign
(paren
r_uint64
)paren
(paren
r_int
)paren
id|prom_vec
suffix:semicolon
id|cfe_ept
op_assign
(paren
r_uint64
)paren
(paren
(paren
r_int32
)paren
l_int|0x9fc00500
)paren
suffix:semicolon
id|cfe_eptseal
op_assign
id|CFE_EPTSEAL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Newer loaders bundle the handle/ept/eptseal&n;&t;&t;&t; * Note: prom_vec is in the loader&squot;s useg&n;&t;&t;&t; * which is still alive in the TLB.&n;&t;&t;&t; */
id|cfe_handle
op_assign
(paren
r_uint64
)paren
(paren
(paren
r_int32
op_star
)paren
id|prom_vec
)paren
(braket
l_int|0
)braket
suffix:semicolon
id|cfe_ept
op_assign
(paren
r_uint64
)paren
(paren
(paren
r_int32
op_star
)paren
id|prom_vec
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|cfe_eptseal
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
r_uint32
op_star
)paren
id|prom_vec
)paren
(braket
l_int|3
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cfe_eptseal
op_ne
id|CFE_EPTSEAL
)paren
(brace
multiline_comment|/* too early for panic to do any good */
id|prom_printf
c_func
(paren
l_string|&quot;CFE&squot;s entrypoint seal doesn&squot;t match. Spinning.&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|cfe_init
c_func
(paren
id|cfe_handle
comma
id|cfe_ept
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Get the handle for (at least) prom_putchar, possibly for&n;&t; * boot console&n;&t; */
id|cfe_cons_handle
op_assign
id|cfe_getstdhandle
c_func
(paren
id|CFE_STDHANDLE_CONSOLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfe_getenv
c_func
(paren
l_string|&quot;LINUX_CMDLINE&quot;
comma
id|arcs_cmdline
comma
id|CL_SIZE
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|argc
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It&squot;s OK for direct boot to not provide a&n;&t;&t;&t; *  command line&n;&t;&t;&t; */
id|strcpy
c_func
(paren
id|arcs_cmdline
comma
l_string|&quot;root=/dev/ram0 &quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SIBYTE_PTSWARM
id|strcat
c_func
(paren
id|arcs_cmdline
comma
l_string|&quot;console=ttyS0,115200 &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* The loader should have set the command line */
multiline_comment|/* too early for panic to do any good */
id|prom_printf
c_func
(paren
l_string|&quot;LINUX_CMDLINE not defined in cfe.&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_KGDB
r_if
c_cond
(paren
(paren
id|arg
op_assign
id|strstr
c_func
(paren
id|arcs_cmdline
comma
l_string|&quot;kgdb=duart&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
id|kgdb_port
op_assign
(paren
id|arg
(braket
l_int|10
)braket
op_eq
l_char|&squot;0&squot;
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_else
id|kgdb_port
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
(brace
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* Need to find out early whether we&squot;ve got an initrd.  So scan&n;&t;&t;   the list looking now */
r_for
c_loop
(paren
id|ptr
op_assign
id|arcs_cmdline
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_while
c_loop
(paren
op_star
id|ptr
op_eq
l_char|&squot; &squot;
)paren
(brace
id|ptr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ptr
comma
l_string|&quot;initrd=&quot;
comma
l_int|7
)paren
)paren
(brace
id|initrd_setup
c_func
(paren
id|ptr
op_plus
l_int|7
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_star
id|ptr
op_logical_and
(paren
op_star
id|ptr
op_ne
l_char|&squot; &squot;
)paren
)paren
(brace
id|ptr
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
multiline_comment|/* Not sure this is needed, but it&squot;s the safe way. */
id|arcs_cmdline
(braket
id|CL_SIZE
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|mips_machgroup
op_assign
id|MACH_GROUP_SIBYTE
suffix:semicolon
id|prom_meminit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|prom_free_prom_memory
r_int
r_int
id|__init
id|prom_free_prom_memory
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Not sure what I&squot;m supposed to do here.  Nothing, I think */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prom_putchar
r_void
id|prom_putchar
c_func
(paren
r_char
id|c
)paren
(brace
r_int
id|ret
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|cfe_write
c_func
(paren
id|cfe_cons_handle
comma
op_amp
id|c
comma
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
eof
