multiline_comment|/*&n; * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_regs.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_int.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_uart.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_scd.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250.h&gt;
multiline_comment|/*&n; * These are the routines that handle all the low level interrupt stuff.&n; * Actions handled here are: initialization of the interrupt map, requesting of&n; * interrupt lines by handlers, dispatching if interrupts to handlers, probing&n; * for interrupt lines&n; */
DECL|macro|shutdown_sb1250_irq
mdefine_line|#define shutdown_sb1250_irq&t;disable_sb1250_irq
r_static
r_void
id|end_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|enable_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|disable_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
r_int
id|startup_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|ack_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|sb1250_set_affinity
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|mask
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SIBYTE_HAS_LDT
r_extern
r_int
r_int
id|ldt_eoi_space
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_KGDB
DECL|variable|kgdb_irq
r_static
r_int
id|kgdb_irq
suffix:semicolon
multiline_comment|/* Default to UART1 */
DECL|variable|kgdb_port
r_int
id|kgdb_port
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_SIBYTE_SB1250_DUART
r_extern
r_char
id|sb1250_duart_present
(braket
)braket
suffix:semicolon
macro_line|#endif
macro_line|#endif
DECL|variable|sb1250_irq_type
r_static
r_struct
id|hw_interrupt_type
id|sb1250_irq_type
op_assign
(brace
l_string|&quot;SB1250-IMR&quot;
comma
id|startup_sb1250_irq
comma
id|shutdown_sb1250_irq
comma
id|enable_sb1250_irq
comma
id|disable_sb1250_irq
comma
id|ack_sb1250_irq
comma
id|end_sb1250_irq
comma
macro_line|#ifdef CONFIG_SMP
id|sb1250_set_affinity
macro_line|#else
l_int|NULL
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Store the CPU id (not the logical number) */
DECL|variable|sb1250_irq_owner
r_int
id|sb1250_irq_owner
(braket
id|SB1250_NR_IRQS
)braket
suffix:semicolon
DECL|variable|sb1250_imr_lock
id|spinlock_t
id|sb1250_imr_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|sb1250_mask_irq
r_void
id|sb1250_mask_irq
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|cur_ints
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sb1250_imr_lock
comma
id|flags
)paren
suffix:semicolon
id|cur_ints
op_assign
id|____raw_readq
c_func
(paren
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|cur_ints
op_or_assign
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|irq
)paren
suffix:semicolon
id|____raw_writeq
c_func
(paren
id|cur_ints
comma
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sb1250_imr_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sb1250_unmask_irq
r_void
id|sb1250_unmask_irq
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|cur_ints
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sb1250_imr_lock
comma
id|flags
)paren
suffix:semicolon
id|cur_ints
op_assign
id|____raw_readq
c_func
(paren
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|cur_ints
op_and_assign
op_complement
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|irq
)paren
suffix:semicolon
id|____raw_writeq
c_func
(paren
id|cur_ints
comma
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sb1250_imr_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|sb1250_set_affinity
r_static
r_void
id|sb1250_set_affinity
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|old_cpu
comma
id|cpu
comma
id|int_on
suffix:semicolon
id|u64
id|cur_ints
suffix:semicolon
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_desc
op_plus
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|1
)paren
(brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;attempted to set irq affinity for irq %d to multiple CPUs&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Convert logical CPU to physical CPU */
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Protect against other affinity changers and IMR manipulation */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sb1250_imr_lock
)paren
suffix:semicolon
multiline_comment|/* Swizzle each CPU&squot;s IMR (but leave the IP selection alone) */
id|old_cpu
op_assign
id|sb1250_irq_owner
(braket
id|irq
)braket
suffix:semicolon
id|cur_ints
op_assign
id|____raw_readq
c_func
(paren
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|old_cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|int_on
op_assign
op_logical_neg
(paren
id|cur_ints
op_amp
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_on
)paren
(brace
multiline_comment|/* If it was on, mask it */
id|cur_ints
op_or_assign
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|irq
)paren
suffix:semicolon
id|____raw_writeq
c_func
(paren
id|cur_ints
comma
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|old_cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
)brace
id|sb1250_irq_owner
(braket
id|irq
)braket
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|int_on
)paren
(brace
multiline_comment|/* unmask for the new CPU */
id|cur_ints
op_assign
id|____raw_readq
c_func
(paren
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
id|cur_ints
op_and_assign
op_complement
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|irq
)paren
suffix:semicolon
id|____raw_writeq
c_func
(paren
id|cur_ints
comma
id|IOADDR
c_func
(paren
id|A_IMR_MAPPER
c_func
(paren
id|cpu
)paren
op_plus
id|R_IMR_INTERRUPT_MASK
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sb1250_imr_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Defined in arch/mips/sibyte/sb1250/irq_handler.S */
r_extern
r_void
id|sb1250_irq_handler
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
DECL|function|startup_sb1250_irq
r_static
r_int
r_int
id|startup_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|sb1250_unmask_irq
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* never anything pending */
)brace
DECL|function|disable_sb1250_irq
r_static
r_void
id|disable_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|sb1250_mask_irq
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|function|enable_sb1250_irq
r_static
r_void
id|enable_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|sb1250_unmask_irq
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|function|ack_sb1250_irq
r_static
r_void
id|ack_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
macro_line|#ifdef CONFIG_SIBYTE_HAS_LDT
id|u64
id|pending
suffix:semicolon
multiline_comment|/*&n;&t; * If the interrupt was an HT interrupt, now is the time to&n;&t; * clear it.  NOTE: we assume the HT bridge was set up to&n;&t; * deliver the interrupts to all CPUs (which makes affinity&n;&t; * changing easier for us)&n;&t; */
id|pending
op_assign
id|__raw_readq
c_func
(paren
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|R_IMR_LDT_INTERRUPT
)paren
)paren
)paren
suffix:semicolon
id|pending
op_and_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
(paren
id|irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pending
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cpu
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
macro_line|#else
id|cpu
op_assign
id|i
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Clear for all CPUs so an affinity switch&n;&t;&t;&t; * doesn&squot;t find an old status&n;&t;&t;&t; */
id|__raw_writeq
c_func
(paren
id|pending
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
id|cpu
comma
id|R_IMR_LDT_INTERRUPT_CLR
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Generate EOI.  For Pass 1 parts, EOI is a nop.  For&n;&t;&t; * Pass 2, the LDT world may be edge-triggered, but&n;&t;&t; * this EOI shouldn&squot;t hurt.  If they are&n;&t;&t; * level-sensitive, the EOI is required.&n;&t;&t; */
op_star
(paren
r_uint32
op_star
)paren
(paren
id|ldt_eoi_space
op_plus
(paren
id|irq
op_lshift
l_int|16
)paren
op_plus
(paren
l_int|7
op_lshift
l_int|2
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|sb1250_mask_irq
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|function|end_sb1250_irq
r_static
r_void
id|end_sb1250_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
(brace
id|sb1250_unmask_irq
c_func
(paren
id|sb1250_irq_owner
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_sb1250_irqs
r_void
id|__init
id|init_sb1250_irqs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|IRQ_DISABLED
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|action
op_assign
l_int|0
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|depth
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|SB1250_NR_IRQS
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|sb1250_irq_type
suffix:semicolon
id|sb1250_irq_owner
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|no_irq_type
suffix:semicolon
)brace
)brace
)brace
DECL|function|sb1250_dummy_handler
r_static
id|irqreturn_t
id|sb1250_dummy_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|IRQ_NONE
suffix:semicolon
)brace
DECL|variable|sb1250_dummy_action
r_static
r_struct
id|irqaction
id|sb1250_dummy_action
op_assign
(brace
dot
id|handler
op_assign
id|sb1250_dummy_handler
comma
dot
id|flags
op_assign
l_int|0
comma
dot
id|mask
op_assign
id|CPU_MASK_NONE
comma
dot
id|name
op_assign
l_string|&quot;sb1250-private&quot;
comma
dot
id|next
op_assign
l_int|NULL
comma
dot
id|dev_id
op_assign
l_int|0
)brace
suffix:semicolon
DECL|function|sb1250_steal_irq
r_int
id|sb1250_steal_irq
c_func
(paren
r_int
id|irq
)paren
(brace
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_desc
op_plus
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|SB1250_NR_IRQS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t allow sharing at all for these */
r_if
c_cond
(paren
id|desc-&gt;action
op_ne
l_int|NULL
)paren
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
id|desc-&gt;action
op_assign
op_amp
id|sb1250_dummy_action
suffix:semicolon
id|desc-&gt;depth
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  arch_init_irq is called early in the boot sequence from init/main.c via&n; *  init_IRQ.  It is responsible for setting up the interrupt mapper and&n; *  installing the handler that will be responsible for dispatching interrupts&n; *  to the &quot;right&quot; place.&n; */
multiline_comment|/*&n; * For now, map all interrupts to IP[2].  We could save&n; * some cycles by parceling out system interrupts to different&n; * IP lines, but keep it simple for bringup.  We&squot;ll also direct&n; * all interrupts to a single CPU; we should probably route&n; * PCI and LDT to one cpu and everything else to the other&n; * to balance the load a bit.&n; *&n; * On the second cpu, everything is set to IP5, which is&n; * ignored, EXCEPT the mailbox interrupt.  That one is&n; * set to IP[2] so it is handled.  This is needed so we&n; * can do cross-cpu function calls, as requred by SMP&n; */
DECL|macro|IMR_IP2_VAL
mdefine_line|#define IMR_IP2_VAL&t;K_INT_MAP_I0
DECL|macro|IMR_IP3_VAL
mdefine_line|#define IMR_IP3_VAL&t;K_INT_MAP_I1
DECL|macro|IMR_IP4_VAL
mdefine_line|#define IMR_IP4_VAL&t;K_INT_MAP_I2
DECL|macro|IMR_IP5_VAL
mdefine_line|#define IMR_IP5_VAL&t;K_INT_MAP_I3
DECL|macro|IMR_IP6_VAL
mdefine_line|#define IMR_IP6_VAL&t;K_INT_MAP_I4
DECL|function|arch_init_irq
r_void
id|__init
id|arch_init_irq
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|u64
id|tmp
suffix:semicolon
r_int
r_int
id|imask
op_assign
id|STATUSF_IP4
op_or
id|STATUSF_IP3
op_or
id|STATUSF_IP2
op_or
id|STATUSF_IP1
op_or
id|STATUSF_IP0
suffix:semicolon
multiline_comment|/* Default everything to IP2 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB1250_NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* was I0 */
id|__raw_writeq
c_func
(paren
id|IMR_IP2_VAL
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|i
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|IMR_IP2_VAL
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|1
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|i
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
)brace
id|init_sb1250_irqs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Map the high 16 bits of the mailbox registers to IP[3], for&n;&t; * inter-cpu messages&n;&t; */
multiline_comment|/* Was I1 */
id|__raw_writeq
c_func
(paren
id|IMR_IP3_VAL
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|K_INT_MBOX_0
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|IMR_IP3_VAL
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|1
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|K_INT_MBOX_0
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear the mailboxes.  The firmware may leave them dirty */
id|__raw_writeq
c_func
(paren
l_int|0xffffffffffffffff
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_MAILBOX_CLR_CPU
)paren
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0xffffffffffffffff
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|1
comma
id|R_IMR_MAILBOX_CLR_CPU
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Mask everything except the mailbox registers for both cpus */
id|tmp
op_assign
op_complement
(paren
(paren
id|u64
)paren
l_int|0
)paren
op_xor
(paren
(paren
(paren
id|u64
)paren
l_int|1
)paren
op_lshift
id|K_INT_MBOX_0
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|tmp
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_MASK
)paren
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|tmp
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|1
comma
id|R_IMR_INTERRUPT_MASK
)paren
)paren
)paren
suffix:semicolon
id|sb1250_steal_irq
c_func
(paren
id|K_INT_MBOX_0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that the timer interrupts are also mapped, but this is&n;&t; * done in sb1250_time_init().  Also, the profiling driver &n;&t; * does its own management of IP7.&n;&t; */
macro_line|#ifdef CONFIG_KGDB
id|imask
op_or_assign
id|STATUSF_IP6
suffix:semicolon
macro_line|#endif
multiline_comment|/* Enable necessary IPs, disable the rest */
id|change_c0_status
c_func
(paren
id|ST0_IM
comma
id|imask
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|0
comma
id|sb1250_irq_handler
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB
r_if
c_cond
(paren
id|kgdb_flag
)paren
(brace
id|kgdb_irq
op_assign
id|K_INT_UART_0
op_plus
id|kgdb_port
suffix:semicolon
macro_line|#ifdef CONFIG_SIBYTE_SB1250_DUART&t;
id|sb1250_duart_present
(braket
id|kgdb_port
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Setup uart 1 settings, mapper */
id|__raw_writeq
c_func
(paren
id|M_DUART_IMR_BRK
comma
id|IOADDR
c_func
(paren
id|A_DUART_IMRREG
c_func
(paren
id|kgdb_port
)paren
)paren
)paren
suffix:semicolon
id|sb1250_steal_irq
c_func
(paren
id|kgdb_irq
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|IMR_IP6_VAL
comma
id|IOADDR
c_func
(paren
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|kgdb_irq
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
id|sb1250_unmask_irq
c_func
(paren
l_int|0
comma
id|kgdb_irq
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_KGDB
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|duart_out
mdefine_line|#define duart_out(reg, val)     csr_out32(val, IOADDR(A_DUART_CHANREG(kgdb_port,reg)))
DECL|macro|duart_in
mdefine_line|#define duart_in(reg)           csr_in32(IOADDR(A_DUART_CHANREG(kgdb_port,reg)))
DECL|function|sb1250_kgdb_interrupt
r_void
id|sb1250_kgdb_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Clear break-change status (allow some time for the remote&n;&t; * host to stop the break, since we would see another&n;&t; * interrupt on the end-of-break too)&n;&t; */
id|kstat_this_cpu.irqs
(braket
id|kgdb_irq
)braket
op_increment
suffix:semicolon
id|mdelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|duart_out
c_func
(paren
id|R_DUART_CMD
comma
id|V_DUART_MISC_CMD_RESET_BREAK_INT
op_or
id|M_DUART_RX_EN
op_or
id|M_DUART_TX_EN
)paren
suffix:semicolon
id|set_async_breakpoint
c_func
(paren
op_amp
id|regs-&gt;cp0_epc
)paren
suffix:semicolon
)brace
macro_line|#endif &t;/* CONFIG_KGDB */
eof
