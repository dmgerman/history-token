multiline_comment|/*&n; * Copyright (C) 2001, 2002, 2003 Broadcom Corporation&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; */
DECL|macro|SBPROF_TB_DEBUG
mdefine_line|#define SBPROF_TB_DEBUG 0
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/smplock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_regs.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_scd.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_int.h&gt;
macro_line|#include &lt;asm/sibyte/trace_prof.h&gt;
DECL|macro|DEVNAME
mdefine_line|#define DEVNAME &quot;bcm1250_tbprof&quot;
DECL|variable|sbp
r_static
r_struct
id|sbprof_tb
id|sbp
suffix:semicolon
DECL|macro|TB_FULL
mdefine_line|#define TB_FULL (sbp.next_tb_sample == MAX_TB_SAMPLES)
multiline_comment|/************************************************************************&n; * Support for ZBbus sampling using the trace buffer&n; *&n; * We use the SCD performance counter interrupt, caused by a Zclk counter&n; * overflow, to trigger the start of tracing.&n; *&n; * We set the trace buffer to sample everything and freeze on&n; * overflow.&n; *&n; * We map the interrupt for trace_buffer_freeze to handle it on CPU 0.&n; *&n; ************************************************************************/
DECL|variable|tb_period
r_static
id|u_int64_t
id|tb_period
suffix:semicolon
DECL|function|arm_tb
r_static
r_void
id|arm_tb
c_func
(paren
r_void
)paren
(brace
id|u_int64_t
id|scdperfcnt
suffix:semicolon
id|u_int64_t
id|next
op_assign
(paren
l_int|1ULL
op_lshift
l_int|40
)paren
op_minus
id|tb_period
suffix:semicolon
id|u_int64_t
id|tb_options
op_assign
id|M_SCD_TRACE_CFG_FREEZE_FULL
suffix:semicolon
multiline_comment|/* Generate an SCD_PERFCNT interrupt in TB_PERIOD Zclks to&n;&t;   trigger start of trace.  XXX vary sampling period */
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_1
)paren
suffix:semicolon
id|scdperfcnt
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_CFG
)paren
suffix:semicolon
multiline_comment|/* Unfortunately, in Pass 2 we must clear all counters to knock down&n;&t;   a previous interrupt request.  This means that bus profiling&n;&t;   requires ALL of the SCD perf counters. */
id|__raw_writeq
c_func
(paren
(paren
id|scdperfcnt
op_amp
op_complement
id|M_SPC_CFG_SRC1
)paren
op_or
singleline_comment|// keep counters 0,2,3 as is
id|M_SPC_CFG_ENABLE
op_or
singleline_comment|// enable counting
id|M_SPC_CFG_CLEAR
op_or
singleline_comment|// clear all counters
id|V_SPC_CFG_SRC1
c_func
(paren
l_int|1
)paren
comma
singleline_comment|// counter 1 counts cycles
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_CFG
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|next
comma
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_1
)paren
suffix:semicolon
multiline_comment|/* Reset the trace buffer */
id|__raw_writeq
c_func
(paren
id|M_SCD_TRACE_CFG_RESET
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_CFG
)paren
suffix:semicolon
macro_line|#if 0 &amp;&amp; defined(M_SCD_TRACE_CFG_FORCECNT)
multiline_comment|/* XXXKW may want to expose control to the data-collector */
id|tb_options
op_or_assign
id|M_SCD_TRACE_CFG_FORCECNT
suffix:semicolon
macro_line|#endif
id|__raw_writeq
c_func
(paren
id|tb_options
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_CFG
)paren
suffix:semicolon
id|sbp.tb_armed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sbprof_tb_intr
r_static
id|irqreturn_t
id|sbprof_tb_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: tb_intr&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp.next_tb_sample
OL
id|MAX_TB_SAMPLES
)paren
(brace
multiline_comment|/* XXX should use XKPHYS to make writes bypass L2 */
id|u_int64_t
op_star
id|p
op_assign
id|sbp.sbprof_tbbuf
(braket
id|sbp.next_tb_sample
op_increment
)braket
suffix:semicolon
multiline_comment|/* Read out trace */
id|__raw_writeq
c_func
(paren
id|M_SCD_TRACE_CFG_START_READ
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_CFG
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* Loop runs backwards because bundles are read out in reverse order */
r_for
c_loop
(paren
id|i
op_assign
l_int|256
op_star
l_int|6
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_sub_assign
l_int|6
)paren
(brace
singleline_comment|// Subscripts decrease to put bundle in the order
singleline_comment|//   t0 lo, t0 hi, t1 lo, t1 hi, t2 lo, t2 hi
id|p
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t2 hi
id|p
(braket
id|i
op_minus
l_int|2
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t2 lo
id|p
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t1 hi
id|p
(braket
id|i
op_minus
l_int|4
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t1 lo
id|p
(braket
id|i
op_minus
l_int|5
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t0 hi
id|p
(braket
id|i
op_minus
l_int|6
)braket
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_TRACE_READ
)paren
suffix:semicolon
singleline_comment|// read t0 lo
)brace
r_if
c_cond
(paren
op_logical_neg
id|sbp.tb_enable
)paren
(brace
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: tb_intr shutdown&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SCD_TRACE_CFG_RESET
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_CFG
)paren
suffix:semicolon
id|sbp.tb_armed
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sbp.tb_sync
)paren
suffix:semicolon
)brace
r_else
(brace
id|arm_tb
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// knock down current interrupt and get another one later
)brace
)brace
r_else
(brace
multiline_comment|/* No more trace buffer samples */
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: tb_intr full&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SCD_TRACE_CFG_RESET
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_CFG
)paren
suffix:semicolon
id|sbp.tb_armed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbp.tb_enable
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|sbp.tb_sync
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|sbp.tb_read
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|sbprof_pc_intr
r_static
id|irqreturn_t
id|sbprof_pc_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: unexpected pc_intr&quot;
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
DECL|function|sbprof_zbprof_start
r_static
r_int
id|sbprof_zbprof_start
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
id|u_int64_t
id|scdperfcnt
suffix:semicolon
r_if
c_cond
(paren
id|sbp.tb_enable
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sbp.tb_enable
op_assign
l_int|1
suffix:semicolon
id|sbp.next_tb_sample
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|K_INT_TRACE_FREEZE
comma
id|sbprof_tb_intr
comma
l_int|0
comma
id|DEVNAME
l_string|&quot; trace freeze&quot;
comma
op_amp
id|sbp
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Make sure there isn&squot;t a perf-cnt interrupt waiting */
id|scdperfcnt
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_CFG
)paren
suffix:semicolon
multiline_comment|/* Disable and clear counters, override SRC_1 */
id|__raw_writeq
c_func
(paren
(paren
id|scdperfcnt
op_amp
op_complement
(paren
id|M_SPC_CFG_SRC1
op_or
id|M_SPC_CFG_ENABLE
)paren
)paren
op_or
id|M_SPC_CFG_ENABLE
op_or
id|M_SPC_CFG_CLEAR
op_or
id|V_SPC_CFG_SRC1
c_func
(paren
l_int|1
)paren
comma
id|KSEG1
op_plus
id|A_SCD_PERF_CNT_CFG
)paren
suffix:semicolon
multiline_comment|/* We grab this interrupt to prevent others from trying to use&n;           it, even though we don&squot;t want to service the interrupts&n;           (they only feed into the trace-on-interrupt mechanism) */
r_if
c_cond
(paren
id|request_irq
(paren
id|K_INT_PERF_CNT
comma
id|sbprof_pc_intr
comma
l_int|0
comma
id|DEVNAME
l_string|&quot; scd perfcnt&quot;
comma
op_amp
id|sbp
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|K_INT_TRACE_FREEZE
comma
op_amp
id|sbp
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* I need the core to mask these, but the interrupt mapper to&n;&t;   pass them through.  I am exploiting my knowledge that&n;&t;   cp0_status masks out IP[5]. krw */
id|__raw_writeq
c_func
(paren
id|K_INT_MAP_I3
comma
id|KSEG1
op_plus
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_MAP_BASE
)paren
op_plus
(paren
id|K_INT_PERF_CNT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize address traps */
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_UP_0
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_UP_1
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_UP_2
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_UP_3
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_DOWN_0
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_DOWN_1
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_DOWN_2
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_DOWN_3
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_CFG_0
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_CFG_1
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_CFG_2
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_ADDR_TRAP_CFG_3
)paren
suffix:semicolon
multiline_comment|/* Initialize Trace Event 0-7 */
singleline_comment|//&t;&t;&t;&t;when interrupt
id|__raw_writeq
c_func
(paren
id|M_SCD_TREVT_INTERRUPT
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_0
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_1
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_2
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_3
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_4
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_5
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_6
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_EVENT_7
)paren
suffix:semicolon
multiline_comment|/* Initialize Trace Sequence 0-7 */
singleline_comment|//&t;&t;&t;&t;     Start on event 0 (interrupt)
id|__raw_writeq
c_func
(paren
id|V_SCD_TRSEQ_FUNC_START
op_or
l_int|0x0fff
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_0
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;  dsamp when d used | asamp when a used
id|__raw_writeq
c_func
(paren
id|M_SCD_TRSEQ_ASAMPLE
op_or
id|M_SCD_TRSEQ_DSAMPLE
op_or
id|K_SCD_TRSEQ_TRIGGER_ALL
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_1
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_2
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_3
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_4
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_5
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_6
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|0
comma
id|KSEG1
op_plus
id|A_SCD_TRACE_SEQUENCE_7
)paren
suffix:semicolon
multiline_comment|/* Now indicate the PERF_CNT interrupt as a trace-relevant interrupt */
id|__raw_writeq
c_func
(paren
(paren
l_int|1ULL
op_lshift
id|K_INT_PERF_CNT
)paren
comma
id|KSEG1
op_plus
id|A_IMR_REGISTER
c_func
(paren
l_int|0
comma
id|R_IMR_INTERRUPT_TRACE
)paren
)paren
suffix:semicolon
id|arm_tb
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: done starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbprof_zbprof_stop
r_static
r_int
id|sbprof_zbprof_stop
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: stopping&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp.tb_enable
)paren
(brace
id|sbp.tb_enable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXXKW there is a window here where the intr handler&n;&t;&t;   may run, see the disable, and do the wake_up before&n;&t;&t;   this sleep happens. */
r_if
c_cond
(paren
id|sbp.tb_armed
)paren
(brace
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: wait for disarm&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sbp.tb_sync
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: disarm complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|K_INT_TRACE_FREEZE
comma
op_amp
id|sbp
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|K_INT_PERF_CNT
comma
op_amp
id|sbp
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: done stopping&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbprof_tb_open
r_static
r_int
id|sbprof_tb_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|minor
suffix:semicolon
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbp.open
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|sbp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbprof_tb
)paren
)paren
suffix:semicolon
id|sbp.sbprof_tbbuf
op_assign
id|vmalloc
c_func
(paren
id|MAX_TBSAMPLE_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbp.sbprof_tbbuf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|sbp.sbprof_tbbuf
comma
l_int|0
comma
id|MAX_TBSAMPLE_BYTES
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sbp.tb_sync
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sbp.tb_read
)paren
suffix:semicolon
id|sbp.open
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbprof_tb_release
r_static
r_int
id|sbprof_tb_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|minor
suffix:semicolon
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ne
l_int|0
op_logical_or
op_logical_neg
id|sbp.open
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbp.tb_armed
op_logical_or
id|sbp.tb_enable
)paren
(brace
id|sbprof_zbprof_stop
c_func
(paren
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|sbp.sbprof_tbbuf
)paren
suffix:semicolon
id|sbp.open
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbprof_tb_read
r_static
id|ssize_t
id|sbprof_tb_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|offp
)paren
(brace
r_int
id|cur_sample
comma
id|sample_off
comma
id|cur_count
comma
id|sample_left
suffix:semicolon
r_char
op_star
id|src
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|dest
op_assign
id|buf
suffix:semicolon
r_int
id|cur_off
op_assign
op_star
id|offp
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|cur_sample
op_assign
id|cur_off
op_div
id|TB_SAMPLE_SIZE
suffix:semicolon
id|sample_off
op_assign
id|cur_off
op_mod
id|TB_SAMPLE_SIZE
suffix:semicolon
id|sample_left
op_assign
id|TB_SAMPLE_SIZE
op_minus
id|sample_off
suffix:semicolon
r_while
c_loop
(paren
id|size
op_logical_and
(paren
id|cur_sample
OL
id|sbp.next_tb_sample
)paren
)paren
(brace
id|cur_count
op_assign
id|size
OL
id|sample_left
ques
c_cond
id|size
suffix:colon
id|sample_left
suffix:semicolon
id|src
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
r_int
)paren
id|sbp.sbprof_tbbuf
(braket
id|cur_sample
)braket
)paren
op_plus
id|sample_off
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|dest
comma
id|src
comma
id|cur_count
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|DEVNAME
l_string|&quot;: read from sample %d, %d bytes&bslash;n&quot;
comma
id|cur_sample
comma
id|cur_count
)paren
)paren
suffix:semicolon
id|size
op_sub_assign
id|cur_count
suffix:semicolon
id|sample_left
op_sub_assign
id|cur_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sample_left
)paren
(brace
id|cur_sample
op_increment
suffix:semicolon
id|sample_off
op_assign
l_int|0
suffix:semicolon
id|sample_left
op_assign
id|TB_SAMPLE_SIZE
suffix:semicolon
)brace
r_else
(brace
id|sample_off
op_add_assign
id|cur_count
suffix:semicolon
)brace
id|cur_off
op_add_assign
id|cur_count
suffix:semicolon
id|dest
op_add_assign
id|cur_count
suffix:semicolon
id|count
op_add_assign
id|cur_count
suffix:semicolon
)brace
op_star
id|offp
op_assign
id|cur_off
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|sbprof_tb_ioctl
r_static
r_int
id|sbprof_tb_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|command
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|SBPROF_ZBSTART
suffix:colon
id|error
op_assign
id|sbprof_zbprof_start
c_func
(paren
id|filp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBPROF_ZBSTOP
suffix:colon
id|error
op_assign
id|sbprof_zbprof_stop
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBPROF_ZBWAITFULL
suffix:colon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sbp.tb_read
)paren
suffix:semicolon
multiline_comment|/* XXXKW check if interrupted? */
r_return
id|put_user
c_func
(paren
id|TB_FULL
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|variable|sbprof_tb_fops
r_static
r_struct
id|file_operations
id|sbprof_tb_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|sbprof_tb_open
comma
dot
id|release
op_assign
id|sbprof_tb_release
comma
dot
id|read
op_assign
id|sbprof_tb_read
comma
dot
id|ioctl
op_assign
id|sbprof_tb_ioctl
comma
dot
id|mmap
op_assign
l_int|NULL
comma
)brace
suffix:semicolon
DECL|function|sbprof_tb_init
r_static
r_int
id|__init
id|sbprof_tb_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|SBPROF_TB_MAJOR
comma
id|DEVNAME
comma
op_amp
id|sbprof_tb_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DEVNAME
l_string|&quot;: initialization failed (dev %d)&bslash;n&quot;
comma
id|SBPROF_TB_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sbp.open
op_assign
l_int|0
suffix:semicolon
id|tb_period
op_assign
id|zbbus_mhz
op_star
l_int|10000LL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DEVNAME
l_string|&quot;: initialized - tb_period = %lld&bslash;n&quot;
comma
id|tb_period
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbprof_tb_cleanup
r_static
r_void
id|__exit
id|sbprof_tb_cleanup
c_func
(paren
r_void
)paren
(brace
id|unregister_chrdev
c_func
(paren
id|SBPROF_TB_MAJOR
comma
id|DEVNAME
)paren
suffix:semicolon
)brace
DECL|variable|sbprof_tb_init
id|module_init
c_func
(paren
id|sbprof_tb_init
)paren
suffix:semicolon
DECL|variable|sbprof_tb_cleanup
id|module_exit
c_func
(paren
id|sbprof_tb_cleanup
)paren
suffix:semicolon
eof
