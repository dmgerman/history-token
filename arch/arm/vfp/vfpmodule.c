multiline_comment|/*&n; *  linux/arch/arm/vfp/vfpmodule.c&n; *&n; *  Copyright (C) 2004 ARM Limited.&n; *  Written by Deep Blue Solutions Limited.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/vfp.h&gt;
macro_line|#include &quot;vfpinstr.h&quot;
macro_line|#include &quot;vfp.h&quot;
multiline_comment|/*&n; * Our undef handlers (in entry.S)&n; */
r_void
id|vfp_testing_entry
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|vfp_support_entry
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|vfp_vector
r_void
(paren
op_star
id|vfp_vector
)paren
(paren
r_void
)paren
op_assign
id|vfp_testing_entry
suffix:semicolon
DECL|variable|last_VFP_context
r_union
id|vfp_state
op_star
id|last_VFP_context
suffix:semicolon
multiline_comment|/*&n; * Dual-use variable.&n; * Used in startup: set to non-zero if VFP checks fail&n; * After startup, holds VFP architecture&n; */
DECL|variable|VFP_arch
r_int
r_int
id|VFP_arch
suffix:semicolon
multiline_comment|/*&n; * Per-thread VFP initialisation.&n; */
DECL|function|vfp_flush_thread
r_void
id|vfp_flush_thread
c_func
(paren
r_union
id|vfp_state
op_star
id|vfp
)paren
(brace
id|memset
c_func
(paren
id|vfp
comma
l_int|0
comma
r_sizeof
(paren
r_union
id|vfp_state
)paren
)paren
suffix:semicolon
id|vfp-&gt;hard.fpexc
op_assign
id|FPEXC_ENABLE
suffix:semicolon
id|vfp-&gt;hard.fpscr
op_assign
id|FPSCR_ROUND_NEAREST
suffix:semicolon
multiline_comment|/*&n;&t; * Disable VFP to ensure we initialise it first.&n;&t; */
id|fmxr
c_func
(paren
id|FPEXC
comma
id|fmrx
c_func
(paren
id|FPEXC
)paren
op_amp
op_complement
id|FPEXC_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure we don&squot;t try to overwrite our newly initialised&n;&t; * state information on the first fault.&n;&t; */
r_if
c_cond
(paren
id|last_VFP_context
op_eq
id|vfp
)paren
id|last_VFP_context
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Per-thread VFP cleanup.&n; */
DECL|function|vfp_release_thread
r_void
id|vfp_release_thread
c_func
(paren
r_union
id|vfp_state
op_star
id|vfp
)paren
(brace
r_if
c_cond
(paren
id|last_VFP_context
op_eq
id|vfp
)paren
id|last_VFP_context
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Raise a SIGFPE for the current process.&n; * sicode describes the signal being raised.&n; */
DECL|function|vfp_raise_sigfpe
r_void
id|vfp_raise_sigfpe
c_func
(paren
r_int
r_int
id|sicode
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_code
op_assign
id|sicode
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|instruction_pointer
c_func
(paren
id|regs
)paren
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is the same as NWFPE, because it&squot;s not clear what&n;&t; * this is used for&n;&t; */
id|current-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
l_int|6
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|vfp_panic
r_static
r_void
id|vfp_panic
c_func
(paren
r_char
op_star
id|reason
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFP: Error: %s&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFP: EXC 0x%08x SCR 0x%08x INST 0x%08x&bslash;n&quot;
comma
id|fmrx
c_func
(paren
id|FPEXC
)paren
comma
id|fmrx
c_func
(paren
id|FPSCR
)paren
comma
id|fmrx
c_func
(paren
id|FPINST
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFP: s%2u: 0x%08x s%2u: 0x%08x&bslash;n&quot;
comma
id|i
comma
id|vfp_get_float
c_func
(paren
id|i
)paren
comma
id|i
op_plus
l_int|1
comma
id|vfp_get_float
c_func
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process bitmask of exception conditions.&n; */
DECL|function|vfp_raise_exceptions
r_static
r_void
id|vfp_raise_exceptions
c_func
(paren
id|u32
id|exceptions
comma
id|u32
id|inst
comma
id|u32
id|fpscr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|si_code
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: raising exceptions %08x&bslash;n&quot;
comma
id|exceptions
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exceptions
op_eq
(paren
id|u32
)paren
op_minus
l_int|1
)paren
(brace
id|vfp_panic
c_func
(paren
l_string|&quot;unhandled bounce&quot;
)paren
suffix:semicolon
id|vfp_raise_sigfpe
c_func
(paren
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If any of the status flags are set, update the FPSCR.&n;&t; * Comparison instructions always return at least one of&n;&t; * these flags set.&n;&t; */
r_if
c_cond
(paren
id|exceptions
op_amp
(paren
id|FPSCR_N
op_or
id|FPSCR_Z
op_or
id|FPSCR_C
op_or
id|FPSCR_V
)paren
)paren
id|fpscr
op_and_assign
op_complement
(paren
id|FPSCR_N
op_or
id|FPSCR_Z
op_or
id|FPSCR_C
op_or
id|FPSCR_V
)paren
suffix:semicolon
id|fpscr
op_or_assign
id|exceptions
suffix:semicolon
id|fmxr
c_func
(paren
id|FPSCR
comma
id|fpscr
)paren
suffix:semicolon
DECL|macro|RAISE
mdefine_line|#define RAISE(stat,en,sig)&t;&t;&t;&t;&bslash;&n;&t;if (exceptions &amp; stat &amp;&amp; fpscr &amp; en)&t;&t;&bslash;&n;&t;&t;si_code = sig;
multiline_comment|/*&n;&t; * These are arranged in priority order, least to highest.&n;&t; */
id|RAISE
c_func
(paren
id|FPSCR_IXC
comma
id|FPSCR_IXE
comma
id|FPE_FLTRES
)paren
suffix:semicolon
id|RAISE
c_func
(paren
id|FPSCR_UFC
comma
id|FPSCR_UFE
comma
id|FPE_FLTUND
)paren
suffix:semicolon
id|RAISE
c_func
(paren
id|FPSCR_OFC
comma
id|FPSCR_OFE
comma
id|FPE_FLTOVF
)paren
suffix:semicolon
id|RAISE
c_func
(paren
id|FPSCR_IOC
comma
id|FPSCR_IOE
comma
id|FPE_FLTINV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si_code
)paren
id|vfp_raise_sigfpe
c_func
(paren
id|si_code
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Emulate a VFP instruction.&n; */
DECL|function|vfp_emulate_instruction
r_static
id|u32
id|vfp_emulate_instruction
c_func
(paren
id|u32
id|inst
comma
id|u32
id|fpscr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|exceptions
op_assign
(paren
id|u32
)paren
op_minus
l_int|1
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: emulate: INST=0x%08x SCR=0x%08x&bslash;n&quot;
comma
id|inst
comma
id|fpscr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INST_CPRTDO
c_func
(paren
id|inst
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|INST_CPRT
c_func
(paren
id|inst
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * CPDO&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vfp_single
c_func
(paren
id|inst
)paren
)paren
(brace
id|exceptions
op_assign
id|vfp_single_cpdo
c_func
(paren
id|inst
comma
id|fpscr
)paren
suffix:semicolon
)brace
r_else
(brace
id|exceptions
op_assign
id|vfp_double_cpdo
c_func
(paren
id|inst
comma
id|fpscr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * A CPRT instruction can not appear in FPINST2, nor&n;&t;&t;&t; * can it cause an exception.  Therefore, we do not&n;&t;&t;&t; * have to emulate it.&n;&t;&t;&t; */
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * A CPDT instruction can not appear in FPINST2, nor can&n;&t;&t; * it cause an exception.  Therefore, we do not have to&n;&t;&t; * emulate it.&n;&t;&t; */
)brace
r_return
id|exceptions
suffix:semicolon
)brace
multiline_comment|/*&n; * Package up a bounce condition.&n; */
DECL|function|VFP9_bounce
r_void
id|VFP9_bounce
c_func
(paren
id|u32
id|trigger
comma
id|u32
id|fpexc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|fpscr
comma
id|orig_fpscr
comma
id|exceptions
comma
id|inst
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: bounce: trigger %08x fpexc %08x&bslash;n&quot;
comma
id|trigger
comma
id|fpexc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable access to the VFP so we can handle the bounce.&n;&t; */
id|fmxr
c_func
(paren
id|FPEXC
comma
id|fpexc
op_amp
op_complement
(paren
id|FPEXC_EXCEPTION
op_or
id|FPEXC_INV
op_or
id|FPEXC_UFC
op_or
id|FPEXC_IOC
)paren
)paren
suffix:semicolon
id|orig_fpscr
op_assign
id|fpscr
op_assign
id|fmrx
c_func
(paren
id|FPSCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are running with inexact exceptions enabled, we need to&n;&t; * emulate the trigger instruction.  Note that as we&squot;re emulating&n;&t; * the trigger instruction, we need to increment PC.&n;&t; */
r_if
c_cond
(paren
id|fpscr
op_amp
id|FPSCR_IXE
)paren
(brace
id|regs-&gt;ARM_pc
op_add_assign
l_int|4
suffix:semicolon
r_goto
id|emulate
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Modify fpscr to indicate the number of iterations remaining&n;&t; */
r_if
c_cond
(paren
id|fpexc
op_amp
id|FPEXC_EXCEPTION
)paren
(brace
id|u32
id|len
suffix:semicolon
id|len
op_assign
id|fpexc
op_plus
(paren
l_int|1
op_lshift
id|FPEXC_LENGTH_BIT
)paren
suffix:semicolon
id|fpscr
op_and_assign
op_complement
id|FPSCR_LENGTH_MASK
suffix:semicolon
id|fpscr
op_or_assign
(paren
id|len
op_amp
id|FPEXC_LENGTH_MASK
)paren
op_lshift
(paren
id|FPSCR_LENGTH_BIT
op_minus
id|FPEXC_LENGTH_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle the first FP instruction.  We used to take note of the&n;&t; * FPEXC bounce reason, but this appears to be unreliable.&n;&t; * Emulate the bounced instruction instead.&n;&t; */
id|inst
op_assign
id|fmrx
c_func
(paren
id|FPINST
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_emulate_instruction
c_func
(paren
id|inst
comma
id|fpscr
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exceptions
)paren
id|vfp_raise_exceptions
c_func
(paren
id|exceptions
comma
id|inst
comma
id|orig_fpscr
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there isn&squot;t a second FP instruction, exit now.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|fpexc
op_amp
id|FPEXC_FPV2
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * The barrier() here prevents fpinst2 being read&n;&t; * before the condition above.&n;&t; */
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|trigger
op_assign
id|fmrx
c_func
(paren
id|FPINST2
)paren
suffix:semicolon
id|fpscr
op_assign
id|fmrx
c_func
(paren
id|FPSCR
)paren
suffix:semicolon
id|emulate
suffix:colon
id|exceptions
op_assign
id|vfp_emulate_instruction
c_func
(paren
id|trigger
comma
id|fpscr
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exceptions
)paren
id|vfp_raise_exceptions
c_func
(paren
id|exceptions
comma
id|trigger
comma
id|orig_fpscr
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * VFP support code initialisation.&n; */
DECL|function|vfp_init
r_static
r_int
id|__init
id|vfp_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|vfpsid
suffix:semicolon
multiline_comment|/*&n;&t; * First check that there is a VFP that we can use.&n;&t; * The handler is already setup to just log calls, so&n;&t; * we just need to read the VFPSID register.&n;&t; */
id|vfpsid
op_assign
id|fmrx
c_func
(paren
id|FPSID
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;VFP support v0.3: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|VFP_arch
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vfpsid
op_amp
id|FPSID_NODOUBLE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no double precision support&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|VFP_arch
op_assign
(paren
id|vfpsid
op_amp
id|FPSID_ARCH_MASK
)paren
op_rshift
id|FPSID_ARCH_BIT
suffix:semicolon
multiline_comment|/* Extract the architecture version */
id|printk
c_func
(paren
l_string|&quot;implementor %02x architecture %d part %02x variant %x rev %x&bslash;n&quot;
comma
(paren
id|vfpsid
op_amp
id|FPSID_IMPLEMENTER_MASK
)paren
op_rshift
id|FPSID_IMPLEMENTER_BIT
comma
(paren
id|vfpsid
op_amp
id|FPSID_ARCH_MASK
)paren
op_rshift
id|FPSID_ARCH_BIT
comma
(paren
id|vfpsid
op_amp
id|FPSID_PART_MASK
)paren
op_rshift
id|FPSID_PART_BIT
comma
(paren
id|vfpsid
op_amp
id|FPSID_VARIANT_MASK
)paren
op_rshift
id|FPSID_VARIANT_BIT
comma
(paren
id|vfpsid
op_amp
id|FPSID_REV_MASK
)paren
op_rshift
id|FPSID_REV_BIT
)paren
suffix:semicolon
id|vfp_vector
op_assign
id|vfp_support_entry
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vfp_init
id|late_initcall
c_func
(paren
id|vfp_init
)paren
suffix:semicolon
eof
