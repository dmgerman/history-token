multiline_comment|/*&n; *  linux/arch/arm/vfp/vfpdouble.c&n; *&n; * This code is derived in part from John R. Housers softfloat library, which&n; * carries the following notice:&n; *&n; * ===========================================================================&n; * This C source file is part of the SoftFloat IEC/IEEE Floating-point&n; * Arithmetic Package, Release 2.&n; *&n; * Written by John R. Hauser.  This work was made possible in part by the&n; * International Computer Science Institute, located at Suite 600, 1947 Center&n; * Street, Berkeley, California 94704.  Funding was partially provided by the&n; * National Science Foundation under grant MIP-9311980.  The original version&n; * of this code was written as part of a project to build a fixed-point vector&n; * processor in collaboration with the University of California at Berkeley,&n; * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information&n; * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/&n; * arithmetic/softfloat.html&squot;.&n; *&n; * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort&n; * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT&n; * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO&n; * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY&n; * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.&n; *&n; * Derivative works are acceptable, even for commercial purposes, so long as&n; * (1) they include prominent notice that the work is derivative, and (2) they&n; * include prominent notice akin to these three paragraphs for those parts of&n; * this code that are retained.&n; * ===========================================================================&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/vfp.h&gt;
macro_line|#include &quot;vfpinstr.h&quot;
macro_line|#include &quot;vfp.h&quot;
DECL|variable|vfp_double_default_qnan
r_static
r_struct
id|vfp_double
id|vfp_double_default_qnan
op_assign
(brace
dot
id|exponent
op_assign
l_int|2047
comma
dot
id|sign
op_assign
l_int|0
comma
dot
id|significand
op_assign
id|VFP_DOUBLE_SIGNIFICAND_QNAN
comma
)brace
suffix:semicolon
DECL|function|vfp_double_dump
r_static
r_void
id|vfp_double_dump
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|vfp_double
op_star
id|d
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: %s: sign=%d exponent=%d significand=%016llx&bslash;n&quot;
comma
id|str
comma
id|d-&gt;sign
op_ne
l_int|0
comma
id|d-&gt;exponent
comma
id|d-&gt;significand
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_normalise_denormal
r_static
r_void
id|vfp_double_normalise_denormal
c_func
(paren
r_struct
id|vfp_double
op_star
id|vd
)paren
(brace
r_int
id|bits
op_assign
l_int|31
op_minus
id|fls
c_func
(paren
id|vd-&gt;significand
op_rshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_eq
l_int|31
)paren
id|bits
op_assign
l_int|62
op_minus
id|fls
c_func
(paren
id|vd-&gt;significand
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;normalise_denormal: in&quot;
comma
id|vd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
)paren
(brace
id|vd-&gt;exponent
op_sub_assign
id|bits
op_minus
l_int|1
suffix:semicolon
id|vd-&gt;significand
op_lshift_assign
id|bits
suffix:semicolon
)brace
id|vfp_double_dump
c_func
(paren
l_string|&quot;normalise_denormal: out&quot;
comma
id|vd
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_normaliseround
id|u32
id|vfp_double_normaliseround
c_func
(paren
r_int
id|dd
comma
r_struct
id|vfp_double
op_star
id|vd
comma
id|u32
id|fpscr
comma
id|u32
id|exceptions
comma
r_const
r_char
op_star
id|func
)paren
(brace
id|u64
id|significand
comma
id|incr
suffix:semicolon
r_int
id|exponent
comma
id|shift
comma
id|underflow
suffix:semicolon
id|u32
id|rmode
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;pack: in&quot;
comma
id|vd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Infinities and NaNs are a special case.&n;&t; */
r_if
c_cond
(paren
id|vd-&gt;exponent
op_eq
l_int|2047
op_logical_and
(paren
id|vd-&gt;significand
op_eq
l_int|0
op_logical_or
id|exceptions
)paren
)paren
r_goto
id|pack
suffix:semicolon
multiline_comment|/*&n;&t; * Special-case zero.&n;&t; */
r_if
c_cond
(paren
id|vd-&gt;significand
op_eq
l_int|0
)paren
(brace
id|vd-&gt;exponent
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
)brace
id|exponent
op_assign
id|vd-&gt;exponent
suffix:semicolon
id|significand
op_assign
id|vd-&gt;significand
suffix:semicolon
id|shift
op_assign
l_int|32
op_minus
id|fls
c_func
(paren
id|significand
op_rshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
op_eq
l_int|32
)paren
id|shift
op_assign
l_int|64
op_minus
id|fls
c_func
(paren
id|significand
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
)paren
(brace
id|exponent
op_sub_assign
id|shift
suffix:semicolon
id|significand
op_lshift_assign
id|shift
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|vd-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vd-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;pack: normalised&quot;
comma
id|vd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Tiny number?&n;&t; */
id|underflow
op_assign
id|exponent
OL
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|underflow
)paren
(brace
id|significand
op_assign
id|vfp_shiftright64jamming
c_func
(paren
id|significand
comma
op_minus
id|exponent
)paren
suffix:semicolon
id|exponent
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|vd-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vd-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;pack: tiny number&quot;
comma
id|vd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|significand
op_amp
(paren
(paren
l_int|1ULL
op_lshift
(paren
id|VFP_DOUBLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
)paren
)paren
id|underflow
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Select rounding increment.&n;&t; */
id|incr
op_assign
l_int|0
suffix:semicolon
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|1ULL
op_lshift
id|VFP_DOUBLE_LOW_BITS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|significand
op_amp
(paren
l_int|1ULL
op_lshift
(paren
id|VFP_DOUBLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vd-&gt;sign
op_ne
l_int|0
)paren
)paren
id|incr
op_assign
(paren
l_int|1ULL
op_lshift
(paren
id|VFP_DOUBLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: rounding increment = 0x%08llx&bslash;n&quot;
comma
id|incr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is our rounding going to overflow?&n;&t; */
r_if
c_cond
(paren
(paren
id|significand
op_plus
id|incr
)paren
OL
id|significand
)paren
(brace
id|exponent
op_add_assign
l_int|1
suffix:semicolon
id|significand
op_assign
(paren
id|significand
op_rshift
l_int|1
)paren
op_or
(paren
id|significand
op_amp
l_int|1
)paren
suffix:semicolon
id|incr
op_rshift_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|vd-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vd-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;pack: overflow&quot;
comma
id|vd
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * If any of the low bits (which will be shifted out of the&n;&t; * number) are non-zero, the result is inexact.&n;&t; */
r_if
c_cond
(paren
id|significand
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
id|VFP_DOUBLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
multiline_comment|/*&n;&t; * Do our rounding.&n;&t; */
id|significand
op_add_assign
id|incr
suffix:semicolon
multiline_comment|/*&n;&t; * Infinity?&n;&t; */
r_if
c_cond
(paren
id|exponent
op_ge
l_int|2046
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_OFC
op_or
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|incr
op_eq
l_int|0
)paren
(brace
id|vd-&gt;exponent
op_assign
l_int|2045
suffix:semicolon
id|vd-&gt;significand
op_assign
l_int|0x7fffffffffffffffULL
suffix:semicolon
)brace
r_else
(brace
id|vd-&gt;exponent
op_assign
l_int|2047
suffix:semicolon
multiline_comment|/* infinity */
id|vd-&gt;significand
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|significand
op_rshift
(paren
id|VFP_DOUBLE_LOW_BITS
op_plus
l_int|1
)paren
op_eq
l_int|0
)paren
id|exponent
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_logical_or
id|significand
OG
l_int|0x8000000000000000ULL
)paren
id|underflow
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|underflow
)paren
id|exceptions
op_or_assign
id|FPSCR_UFC
suffix:semicolon
id|vd-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vd-&gt;significand
op_assign
id|significand
op_rshift
l_int|1
suffix:semicolon
)brace
id|pack
suffix:colon
id|vfp_double_dump
c_func
(paren
l_string|&quot;pack: final&quot;
comma
id|vd
)paren
suffix:semicolon
(brace
id|s64
id|d
op_assign
id|vfp_double_pack
c_func
(paren
id|vd
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: %s: d(d%d)=%016llx exceptions=%08x&bslash;n&quot;
comma
id|func
comma
id|dd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_double
c_func
(paren
id|dd
comma
id|d
)paren
suffix:semicolon
)brace
r_return
id|exceptions
suffix:semicolon
)brace
multiline_comment|/*&n; * Propagate the NaN, setting exceptions if it is signalling.&n; * &squot;n&squot; is always a NaN.  &squot;m&squot; may be a number, NaN or infinity.&n; */
r_static
id|u32
DECL|function|vfp_propagate_nan
id|vfp_propagate_nan
c_func
(paren
r_struct
id|vfp_double
op_star
id|vdd
comma
r_struct
id|vfp_double
op_star
id|vdn
comma
r_struct
id|vfp_double
op_star
id|vdm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
op_star
id|nan
suffix:semicolon
r_int
id|tn
comma
id|tm
op_assign
l_int|0
suffix:semicolon
id|tn
op_assign
id|vfp_double_type
c_func
(paren
id|vdn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm
)paren
id|tm
op_assign
id|vfp_double_type
c_func
(paren
id|vdm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fpscr
op_amp
id|FPSCR_DEFAULT_NAN
)paren
multiline_comment|/*&n;&t;&t; * Default NaN mode - always returns a quiet NaN&n;&t;&t; */
id|nan
op_assign
op_amp
id|vfp_double_default_qnan
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * Contemporary mode - select the first signalling&n;&t;&t; * NAN, or if neither are signalling, the first&n;&t;&t; * quiet NAN.&n;&t;&t; */
r_if
c_cond
(paren
id|tn
op_eq
id|VFP_SNAN
op_logical_or
(paren
id|tm
op_ne
id|VFP_SNAN
op_logical_and
id|tn
op_eq
id|VFP_QNAN
)paren
)paren
id|nan
op_assign
id|vdn
suffix:semicolon
r_else
id|nan
op_assign
id|vdm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make the NaN quiet.&n;&t;&t; */
id|nan-&gt;significand
op_or_assign
id|VFP_DOUBLE_SIGNIFICAND_QNAN
suffix:semicolon
)brace
op_star
id|vdd
op_assign
op_star
id|nan
suffix:semicolon
multiline_comment|/*&n;&t; * If one was a signalling NAN, raise invalid operation.&n;&t; */
r_return
id|tn
op_eq
id|VFP_SNAN
op_logical_or
id|tm
op_eq
id|VFP_SNAN
ques
c_cond
id|FPSCR_IOC
suffix:colon
l_int|0x100
suffix:semicolon
)brace
multiline_comment|/*&n; * Extended operations&n; */
DECL|function|vfp_double_fabs
r_static
id|u32
id|vfp_double_fabs
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_packed_abs
c_func
(paren
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfp_double_fcpy
r_static
id|u32
id|vfp_double_fcpy
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfp_double_fneg
r_static
id|u32
id|vfp_double_fneg
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_packed_negate
c_func
(paren
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfp_double_fsqrt
r_static
id|u32
id|vfp_double_fsqrt
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
comma
id|vdd
suffix:semicolon
r_int
id|ret
comma
id|tm
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_double_type
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
(paren
id|VFP_NAN
op_or
id|VFP_INFINITY
)paren
)paren
(brace
r_struct
id|vfp_double
op_star
id|vdp
op_assign
op_amp
id|vdd
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|ret
op_assign
id|vfp_propagate_nan
c_func
(paren
id|vdp
comma
op_amp
id|vdm
comma
l_int|NULL
comma
id|fpscr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|vdm.sign
op_eq
l_int|0
)paren
(brace
id|sqrt_copy
suffix:colon
id|vdp
op_assign
op_amp
id|vdm
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sqrt_invalid
suffix:colon
id|vdp
op_assign
op_amp
id|vfp_double_default_qnan
suffix:semicolon
id|ret
op_assign
id|FPSCR_IOC
suffix:semicolon
)brace
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_pack
c_func
(paren
id|vdp
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sqrt(+/- 0) == +/- 0&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
r_goto
id|sqrt_copy
suffix:semicolon
multiline_comment|/*&n;&t; * Normalise a denormalised number&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * sqrt(&lt;0) = invalid&n;&t; */
r_if
c_cond
(paren
id|vdm.sign
)paren
r_goto
id|sqrt_invalid
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;sqrt&quot;
comma
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Estimate the square root.&n;&t; */
id|vdd.sign
op_assign
l_int|0
suffix:semicolon
id|vdd.exponent
op_assign
(paren
(paren
id|vdm.exponent
op_minus
l_int|1023
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|1023
suffix:semicolon
id|vdd.significand
op_assign
(paren
id|u64
)paren
id|vfp_estimate_sqrt_significand
c_func
(paren
id|vdm.exponent
comma
id|vdm.significand
op_rshift
l_int|32
)paren
op_lshift
l_int|31
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;sqrt estimate1&quot;
comma
op_amp
id|vdd
)paren
suffix:semicolon
id|vdm.significand
op_rshift_assign
l_int|1
op_plus
(paren
id|vdm.exponent
op_amp
l_int|1
)paren
suffix:semicolon
id|vdd.significand
op_add_assign
l_int|2
op_plus
id|vfp_estimate_div128to64
c_func
(paren
id|vdm.significand
comma
l_int|0
comma
id|vdd.significand
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;sqrt estimate2&quot;
comma
op_amp
id|vdd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And now adjust.&n;&t; */
r_if
c_cond
(paren
(paren
id|vdd.significand
op_amp
id|VFP_DOUBLE_LOW_BITS_MASK
)paren
op_le
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|vdd.significand
OL
l_int|2
)paren
(brace
id|vdd.significand
op_assign
op_complement
l_int|0ULL
suffix:semicolon
)brace
r_else
(brace
id|u64
id|termh
comma
id|terml
comma
id|remh
comma
id|reml
suffix:semicolon
id|vdm.significand
op_lshift_assign
l_int|2
suffix:semicolon
id|mul64to128
c_func
(paren
op_amp
id|termh
comma
op_amp
id|terml
comma
id|vdd.significand
comma
id|vdd.significand
)paren
suffix:semicolon
id|sub128
c_func
(paren
op_amp
id|remh
comma
op_amp
id|reml
comma
id|vdm.significand
comma
l_int|0
comma
id|termh
comma
id|terml
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|s64
)paren
id|remh
OL
l_int|0
)paren
(brace
id|vdd.significand
op_sub_assign
l_int|1
suffix:semicolon
id|shift64left
c_func
(paren
op_amp
id|termh
comma
op_amp
id|terml
comma
id|vdd.significand
)paren
suffix:semicolon
id|terml
op_or_assign
l_int|1
suffix:semicolon
id|add128
c_func
(paren
op_amp
id|remh
comma
op_amp
id|reml
comma
id|remh
comma
id|reml
comma
id|termh
comma
id|terml
)paren
suffix:semicolon
)brace
id|vdd.significand
op_or_assign
(paren
id|remh
op_or
id|reml
)paren
op_ne
l_int|0
suffix:semicolon
)brace
)brace
id|vdd.significand
op_assign
id|vfp_shiftright64jamming
c_func
(paren
id|vdd.significand
comma
l_int|1
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fsqrt&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Equal&t;:= ZC&n; * Less than&t;:= N&n; * Greater than&t;:= C&n; * Unordered&t;:= CV&n; */
DECL|function|vfp_compare
r_static
id|u32
id|vfp_compare
c_func
(paren
r_int
id|dd
comma
r_int
id|signal_on_qnan
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
id|s64
id|d
comma
id|m
suffix:semicolon
id|u32
id|ret
op_assign
l_int|0
suffix:semicolon
id|m
op_assign
id|vfp_get_double
c_func
(paren
id|dm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfp_double_packed_exponent
c_func
(paren
id|m
)paren
op_eq
l_int|2047
op_logical_and
id|vfp_double_packed_mantissa
c_func
(paren
id|m
)paren
)paren
(brace
id|ret
op_or_assign
id|FPSCR_C
op_or
id|FPSCR_V
suffix:semicolon
r_if
c_cond
(paren
id|signal_on_qnan
op_logical_or
op_logical_neg
(paren
id|vfp_double_packed_mantissa
c_func
(paren
id|m
)paren
op_amp
(paren
l_int|1ULL
op_lshift
(paren
id|VFP_DOUBLE_MANTISSA_BITS
op_minus
l_int|1
)paren
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Signalling NaN, or signalling on quiet NaN&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
id|d
op_assign
id|vfp_get_double
c_func
(paren
id|dd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfp_double_packed_exponent
c_func
(paren
id|d
)paren
op_eq
l_int|2047
op_logical_and
id|vfp_double_packed_mantissa
c_func
(paren
id|d
)paren
)paren
(brace
id|ret
op_or_assign
id|FPSCR_C
op_or
id|FPSCR_V
suffix:semicolon
r_if
c_cond
(paren
id|signal_on_qnan
op_logical_or
op_logical_neg
(paren
id|vfp_double_packed_mantissa
c_func
(paren
id|d
)paren
op_amp
(paren
l_int|1ULL
op_lshift
(paren
id|VFP_DOUBLE_MANTISSA_BITS
op_minus
l_int|1
)paren
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Signalling NaN, or signalling on quiet NaN&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|m
op_logical_or
id|vfp_double_packed_abs
c_func
(paren
id|d
op_or
id|m
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * equal&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_Z
op_or
id|FPSCR_C
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vfp_double_packed_sign
c_func
(paren
id|d
op_xor
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * different signs&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vfp_double_packed_sign
c_func
(paren
id|d
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * d is negative, so d &lt; m&n;&t;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_N
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t;&t; * d is positive, so d &gt; m&n;&t;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_C
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|vfp_double_packed_sign
c_func
(paren
id|d
)paren
op_ne
l_int|0
)paren
op_xor
(paren
id|d
OL
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * d &lt; m&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_N
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|vfp_double_packed_sign
c_func
(paren
id|d
)paren
op_ne
l_int|0
)paren
op_xor
(paren
id|d
OG
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * d &gt; m&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_C
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|vfp_double_fcmp
r_static
id|u32
id|vfp_double_fcmp
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|dd
comma
l_int|0
comma
id|dm
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_fcmpe
r_static
id|u32
id|vfp_double_fcmpe
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|dd
comma
l_int|1
comma
id|dm
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_fcmpz
r_static
id|u32
id|vfp_double_fcmpz
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|dd
comma
l_int|0
comma
id|VFP_REG_ZERO
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_fcmpez
r_static
id|u32
id|vfp_double_fcmpez
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|dd
comma
l_int|1
comma
id|VFP_REG_ZERO
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_fcvts
r_static
id|u32
id|vfp_double_fcvts
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
suffix:semicolon
r_struct
id|vfp_single
id|vsd
suffix:semicolon
r_int
id|tm
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_double_type
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a signalling NaN, signal invalid operation.&n;&t; */
r_if
c_cond
(paren
id|tm
op_eq
id|VFP_SNAN
)paren
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
id|vsd.sign
op_assign
id|vdm.sign
suffix:semicolon
id|vsd.significand
op_assign
id|vfp_hi64to32jamming
c_func
(paren
id|vdm.significand
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have an infinity or a NaN, the exponent must be 255&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
(paren
id|VFP_INFINITY
op_or
id|VFP_NAN
)paren
)paren
(brace
id|vsd.exponent
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|vsd.significand
op_or_assign
id|VFP_SINGLE_SIGNIFICAND_QNAN
suffix:semicolon
r_goto
id|pack_nan
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
id|vsd.exponent
op_assign
l_int|0
suffix:semicolon
r_else
id|vsd.exponent
op_assign
id|vdm.exponent
op_minus
(paren
l_int|1023
op_minus
l_int|127
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fcvts&quot;
)paren
suffix:semicolon
id|pack_nan
suffix:colon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_pack
c_func
(paren
op_amp
id|vsd
)paren
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_double_fuito
r_static
id|u32
id|vfp_double_fuito
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
suffix:semicolon
id|u32
id|m
op_assign
id|vfp_get_float
c_func
(paren
id|dm
)paren
suffix:semicolon
id|vdm.sign
op_assign
l_int|0
suffix:semicolon
id|vdm.exponent
op_assign
l_int|1023
op_plus
l_int|63
op_minus
l_int|1
suffix:semicolon
id|vdm.significand
op_assign
(paren
id|u64
)paren
id|m
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdm
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fuito&quot;
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_fsito
r_static
id|u32
id|vfp_double_fsito
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
suffix:semicolon
id|u32
id|m
op_assign
id|vfp_get_float
c_func
(paren
id|dm
)paren
suffix:semicolon
id|vdm.sign
op_assign
(paren
id|m
op_amp
l_int|0x80000000
)paren
op_rshift
l_int|16
suffix:semicolon
id|vdm.exponent
op_assign
l_int|1023
op_plus
l_int|63
op_minus
l_int|1
suffix:semicolon
id|vdm.significand
op_assign
id|vdm.sign
ques
c_cond
op_minus
id|m
suffix:colon
id|m
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdm
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fsito&quot;
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_ftoui
r_static
id|u32
id|vfp_double_ftoui
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
suffix:semicolon
id|u32
id|d
comma
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
r_int
id|tm
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have a denormalised number?&n;&t; */
id|tm
op_assign
id|vfp_double_type
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|exceptions
op_or_assign
id|FPSCR_IDC
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|vdm.sign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_ge
l_int|1023
op_plus
l_int|32
)paren
(brace
id|d
op_assign
id|vdm.sign
ques
c_cond
l_int|0
suffix:colon
l_int|0xffffffff
suffix:semicolon
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vdm.exponent
op_ge
l_int|1023
op_minus
l_int|1
)paren
(brace
r_int
id|shift
op_assign
l_int|1023
op_plus
l_int|63
op_minus
id|vdm.exponent
suffix:semicolon
id|u64
id|rem
comma
id|incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * 2^0 &lt;= m &lt; 2^32-2^8&n;&t;&t; */
id|d
op_assign
(paren
id|vdm.significand
op_lshift
l_int|1
)paren
op_rshift
id|shift
suffix:semicolon
id|rem
op_assign
id|vdm.significand
op_lshift
(paren
l_int|65
op_minus
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|0x8000000000000000ULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vdm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|incr
op_assign
op_complement
l_int|0ULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rem
op_plus
id|incr
)paren
OL
id|rem
)paren
(brace
r_if
c_cond
(paren
id|d
OL
l_int|0xffffffff
)paren
id|d
op_add_assign
l_int|1
suffix:semicolon
r_else
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d
op_logical_and
id|vdm.sign
)paren
(brace
id|d
op_assign
l_int|0
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rem
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_or
id|vdm.significand
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
op_logical_and
id|vdm.sign
op_eq
l_int|0
)paren
id|d
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_MINUSINF
op_logical_and
id|vdm.sign
)paren
(brace
id|d
op_assign
l_int|0
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
)brace
)brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: ftoui: d(s%d)=%08x exceptions=%08x&bslash;n&quot;
comma
id|sd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|d
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_double_ftouiz
r_static
id|u32
id|vfp_double_ftouiz
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_ftoui
c_func
(paren
id|sd
comma
id|unused
comma
id|dm
comma
id|FPSCR_ROUND_TOZERO
)paren
suffix:semicolon
)brace
DECL|function|vfp_double_ftosi
r_static
id|u32
id|vfp_double_ftosi
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdm
suffix:semicolon
id|u32
id|d
comma
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDM&quot;
comma
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have denormalised number?&n;&t; */
r_if
c_cond
(paren
id|vfp_double_type
c_func
(paren
op_amp
id|vdm
)paren
op_amp
id|VFP_DENORMAL
)paren
id|exceptions
op_or_assign
id|FPSCR_IDC
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_ge
l_int|1023
op_plus
l_int|32
)paren
(brace
id|d
op_assign
l_int|0x7fffffff
suffix:semicolon
r_if
c_cond
(paren
id|vdm.sign
)paren
id|d
op_assign
op_complement
id|d
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vdm.exponent
op_ge
l_int|1023
op_minus
l_int|1
)paren
(brace
r_int
id|shift
op_assign
l_int|1023
op_plus
l_int|63
op_minus
id|vdm.exponent
suffix:semicolon
multiline_comment|/* 58 */
id|u64
id|rem
comma
id|incr
op_assign
l_int|0
suffix:semicolon
id|d
op_assign
(paren
id|vdm.significand
op_lshift
l_int|1
)paren
op_rshift
id|shift
suffix:semicolon
id|rem
op_assign
id|vdm.significand
op_lshift
(paren
l_int|65
op_minus
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|0x8000000000000000ULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vdm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|incr
op_assign
op_complement
l_int|0ULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rem
op_plus
id|incr
)paren
OL
id|rem
op_logical_and
id|d
OL
l_int|0xffffffff
)paren
id|d
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|d
OG
l_int|0x7fffffff
op_plus
(paren
id|vdm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|d
op_assign
l_int|0x7fffffff
op_plus
(paren
id|vdm.sign
op_ne
l_int|0
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rem
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|vdm.sign
)paren
id|d
op_assign
op_minus
id|d
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_or
id|vdm.significand
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
op_logical_and
id|vdm.sign
op_eq
l_int|0
)paren
id|d
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_MINUSINF
op_logical_and
id|vdm.sign
)paren
id|d
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: ftosi: d(s%d)=%08x exceptions=%08x&bslash;n&quot;
comma
id|sd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_float
c_func
(paren
id|sd
comma
(paren
id|s32
)paren
id|d
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_double_ftosiz
r_static
id|u32
id|vfp_double_ftosiz
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_ftosi
c_func
(paren
id|dd
comma
id|unused
comma
id|dm
comma
id|FPSCR_ROUND_TOZERO
)paren
suffix:semicolon
)brace
DECL|variable|fop_extfns
r_static
id|u32
(paren
op_star
r_const
id|fop_extfns
(braket
l_int|32
)braket
)paren
(paren
r_int
id|dd
comma
r_int
id|unused
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
op_assign
(brace
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCPY
)paren
)braket
op_assign
id|vfp_double_fcpy
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FABS
)paren
)braket
op_assign
id|vfp_double_fabs
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FNEG
)paren
)braket
op_assign
id|vfp_double_fneg
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FSQRT
)paren
)braket
op_assign
id|vfp_double_fsqrt
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMP
)paren
)braket
op_assign
id|vfp_double_fcmp
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPE
)paren
)braket
op_assign
id|vfp_double_fcmpe
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPZ
)paren
)braket
op_assign
id|vfp_double_fcmpz
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPEZ
)paren
)braket
op_assign
id|vfp_double_fcmpez
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCVT
)paren
)braket
op_assign
id|vfp_double_fcvts
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FUITO
)paren
)braket
op_assign
id|vfp_double_fuito
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FSITO
)paren
)braket
op_assign
id|vfp_double_fsito
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOUI
)paren
)braket
op_assign
id|vfp_double_ftoui
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOUIZ
)paren
)braket
op_assign
id|vfp_double_ftouiz
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOSI
)paren
)braket
op_assign
id|vfp_double_ftosi
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOSIZ
)paren
)braket
op_assign
id|vfp_double_ftosiz
comma
)brace
suffix:semicolon
r_static
id|u32
DECL|function|vfp_double_fadd_nonnumber
id|vfp_double_fadd_nonnumber
c_func
(paren
r_struct
id|vfp_double
op_star
id|vdd
comma
r_struct
id|vfp_double
op_star
id|vdn
comma
r_struct
id|vfp_double
op_star
id|vdm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
op_star
id|vdp
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|tn
comma
id|tm
suffix:semicolon
id|tn
op_assign
id|vfp_double_type
c_func
(paren
id|vdn
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_double_type
c_func
(paren
id|vdm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tn
op_amp
id|tm
op_amp
id|VFP_INFINITY
)paren
(brace
multiline_comment|/*&n;&t;&t; * Two infinities.  Are they different signs?&n;&t;&t; */
r_if
c_cond
(paren
id|vdn-&gt;sign
op_xor
id|vdm-&gt;sign
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * different signs -&gt; invalid&n;&t;&t;&t; */
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
id|vdp
op_assign
op_amp
id|vfp_double_default_qnan
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * same signs -&gt; valid&n;&t;&t;&t; */
id|vdp
op_assign
id|vdn
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_INFINITY
op_logical_and
id|tm
op_amp
id|VFP_NUMBER
)paren
(brace
multiline_comment|/*&n;&t;&t; * One infinity and one number -&gt; infinity&n;&t;&t; */
id|vdp
op_assign
id|vdn
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * &squot;n&squot; is a NaN of some type&n;&t;&t; */
r_return
id|vfp_propagate_nan
c_func
(paren
id|vdd
comma
id|vdn
comma
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
)brace
op_star
id|vdd
op_assign
op_star
id|vdp
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
r_static
id|u32
DECL|function|vfp_double_add
id|vfp_double_add
c_func
(paren
r_struct
id|vfp_double
op_star
id|vdd
comma
r_struct
id|vfp_double
op_star
id|vdn
comma
r_struct
id|vfp_double
op_star
id|vdm
comma
id|u32
id|fpscr
)paren
(brace
id|u32
id|exp_diff
suffix:semicolon
id|u64
id|m_sig
suffix:semicolon
r_if
c_cond
(paren
id|vdn-&gt;significand
op_amp
(paren
l_int|1ULL
op_lshift
l_int|63
)paren
op_logical_or
id|vdm-&gt;significand
op_amp
(paren
l_int|1ULL
op_lshift
l_int|63
)paren
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;VFP: bad FP values in %s&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDN&quot;
comma
id|vdn
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDM&quot;
comma
id|vdm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure that &squot;n&squot; is the largest magnitude number.  Note that&n;&t; * if &squot;n&squot; and &squot;m&squot; have equal exponents, we do not swap them.&n;&t; * This ensures that NaN propagation works correctly.&n;&t; */
r_if
c_cond
(paren
id|vdn-&gt;exponent
OL
id|vdm-&gt;exponent
)paren
(brace
r_struct
id|vfp_double
op_star
id|t
op_assign
id|vdn
suffix:semicolon
id|vdn
op_assign
id|vdm
suffix:semicolon
id|vdm
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is &squot;n&squot; an infinity or a NaN?  Note that &squot;m&squot; may be a number,&n;&t; * infinity or a NaN here.&n;&t; */
r_if
c_cond
(paren
id|vdn-&gt;exponent
op_eq
l_int|2047
)paren
r_return
id|vfp_double_fadd_nonnumber
c_func
(paren
id|vdd
comma
id|vdn
comma
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have two proper numbers, where &squot;vdn&squot; is the larger magnitude.&n;&t; *&n;&t; * Copy &squot;n&squot; to &squot;d&squot; before doing the arithmetic.&n;&t; */
op_star
id|vdd
op_assign
op_star
id|vdn
suffix:semicolon
multiline_comment|/*&n;&t; * Align &squot;m&squot; with the result.&n;&t; */
id|exp_diff
op_assign
id|vdn-&gt;exponent
op_minus
id|vdm-&gt;exponent
suffix:semicolon
id|m_sig
op_assign
id|vfp_shiftright64jamming
c_func
(paren
id|vdm-&gt;significand
comma
id|exp_diff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the signs are different, we are really subtracting.&n;&t; */
r_if
c_cond
(paren
id|vdn-&gt;sign
op_xor
id|vdm-&gt;sign
)paren
(brace
id|m_sig
op_assign
id|vdn-&gt;significand
op_minus
id|m_sig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s64
)paren
id|m_sig
OL
l_int|0
)paren
(brace
id|vdd-&gt;sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vdd-&gt;sign
)paren
suffix:semicolon
id|m_sig
op_assign
op_minus
id|m_sig
suffix:semicolon
)brace
)brace
r_else
(brace
id|m_sig
op_add_assign
id|vdn-&gt;significand
suffix:semicolon
)brace
id|vdd-&gt;significand
op_assign
id|m_sig
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|u32
DECL|function|vfp_double_multiply
id|vfp_double_multiply
c_func
(paren
r_struct
id|vfp_double
op_star
id|vdd
comma
r_struct
id|vfp_double
op_star
id|vdn
comma
r_struct
id|vfp_double
op_star
id|vdm
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDN&quot;
comma
id|vdn
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDM&quot;
comma
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that &squot;n&squot; is the largest magnitude number.  Note that&n;&t; * if &squot;n&squot; and &squot;m&squot; have equal exponents, we do not swap them.&n;&t; * This ensures that NaN propagation works correctly.&n;&t; */
r_if
c_cond
(paren
id|vdn-&gt;exponent
OL
id|vdm-&gt;exponent
)paren
(brace
r_struct
id|vfp_double
op_star
id|t
op_assign
id|vdn
suffix:semicolon
id|vdn
op_assign
id|vdm
suffix:semicolon
id|vdm
op_assign
id|t
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: swapping M &lt;-&gt; N&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|vdd-&gt;sign
op_assign
id|vdn-&gt;sign
op_xor
id|vdm-&gt;sign
suffix:semicolon
multiline_comment|/*&n;&t; * If &squot;n&squot; is an infinity or NaN, handle it.  &squot;m&squot; may be anything.&n;&t; */
r_if
c_cond
(paren
id|vdn-&gt;exponent
op_eq
l_int|2047
)paren
(brace
r_if
c_cond
(paren
id|vdn-&gt;significand
op_logical_or
(paren
id|vdm-&gt;exponent
op_eq
l_int|2047
op_logical_and
id|vdm-&gt;significand
)paren
)paren
r_return
id|vfp_propagate_nan
c_func
(paren
id|vdd
comma
id|vdn
comma
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vdm-&gt;exponent
op_or
id|vdm-&gt;significand
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|vdd
op_assign
id|vfp_double_default_qnan
suffix:semicolon
r_return
id|FPSCR_IOC
suffix:semicolon
)brace
id|vdd-&gt;exponent
op_assign
id|vdn-&gt;exponent
suffix:semicolon
id|vdd-&gt;significand
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If &squot;m&squot; is zero, the result is always zero.  In this case,&n;&t; * &squot;n&squot; may be zero or a number, but it doesn&squot;t matter which.&n;&t; */
r_if
c_cond
(paren
(paren
id|vdm-&gt;exponent
op_or
id|vdm-&gt;significand
)paren
op_eq
l_int|0
)paren
(brace
id|vdd-&gt;exponent
op_assign
l_int|0
suffix:semicolon
id|vdd-&gt;significand
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We add 2 to the destination exponent for the same reason&n;&t; * as the addition case - though this time we have +1 from&n;&t; * each input operand.&n;&t; */
id|vdd-&gt;exponent
op_assign
id|vdn-&gt;exponent
op_plus
id|vdm-&gt;exponent
op_minus
l_int|1023
op_plus
l_int|2
suffix:semicolon
id|vdd-&gt;significand
op_assign
id|vfp_hi64multiply64
c_func
(paren
id|vdn-&gt;significand
comma
id|vdm-&gt;significand
)paren
suffix:semicolon
id|vfp_double_dump
c_func
(paren
l_string|&quot;VDD&quot;
comma
id|vdd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|NEG_MULTIPLY
mdefine_line|#define NEG_MULTIPLY&t;(1 &lt;&lt; 0)
DECL|macro|NEG_SUBTRACT
mdefine_line|#define NEG_SUBTRACT&t;(1 &lt;&lt; 1)
r_static
id|u32
DECL|function|vfp_double_multiply_accumulate
id|vfp_double_multiply_accumulate
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
comma
id|u32
id|negate
comma
r_char
op_star
id|func
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdp
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdn.exponent
op_eq
l_int|0
op_logical_and
id|vdn.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_eq
l_int|0
op_logical_and
id|vdm.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_double_multiply
c_func
(paren
op_amp
id|vdp
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|negate
op_amp
id|NEG_MULTIPLY
)paren
id|vdp.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vdp.sign
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|negate
op_amp
id|NEG_SUBTRACT
)paren
id|vdn.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vdn.sign
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|vfp_double_add
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdp
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Standard operations&n; */
multiline_comment|/*&n; * sd = sd + (sn * sm)&n; */
DECL|function|vfp_double_fmac
r_static
id|u32
id|vfp_double_fmac
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_multiply_accumulate
c_func
(paren
id|dd
comma
id|dn
comma
id|dm
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fmac&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sd - (sn * sm)&n; */
DECL|function|vfp_double_fnmac
r_static
id|u32
id|vfp_double_fnmac
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_multiply_accumulate
c_func
(paren
id|dd
comma
id|dn
comma
id|dm
comma
id|fpscr
comma
id|NEG_MULTIPLY
comma
l_string|&quot;fnmac&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -sd + (sn * sm)&n; */
DECL|function|vfp_double_fmsc
r_static
id|u32
id|vfp_double_fmsc
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_multiply_accumulate
c_func
(paren
id|dd
comma
id|dn
comma
id|dm
comma
id|fpscr
comma
id|NEG_SUBTRACT
comma
l_string|&quot;fmsc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -sd - (sn * sm)&n; */
DECL|function|vfp_double_fnmsc
r_static
id|u32
id|vfp_double_fnmsc
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_double_multiply_accumulate
c_func
(paren
id|dd
comma
id|dn
comma
id|dm
comma
id|fpscr
comma
id|NEG_SUBTRACT
op_or
id|NEG_MULTIPLY
comma
l_string|&quot;fnmsc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn * sm&n; */
DECL|function|vfp_double_fmul
r_static
id|u32
id|vfp_double_fmul
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdn.exponent
op_eq
l_int|0
op_logical_and
id|vdn.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_eq
l_int|0
op_logical_and
id|vdm.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_double_multiply
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fmul&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -(sn * sm)&n; */
DECL|function|vfp_double_fnmul
r_static
id|u32
id|vfp_double_fnmul
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdn.exponent
op_eq
l_int|0
op_logical_and
id|vdn.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_eq
l_int|0
op_logical_and
id|vdm.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_double_multiply
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
id|vdd.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vdd.sign
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fnmul&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn + sm&n; */
DECL|function|vfp_double_fadd
r_static
id|u32
id|vfp_double_fadd
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdn.exponent
op_eq
l_int|0
op_logical_and
id|vdn.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_eq
l_int|0
op_logical_and
id|vdm.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_double_add
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fadd&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn - sm&n; */
DECL|function|vfp_double_fsub
r_static
id|u32
id|vfp_double_fsub
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdn.exponent
op_eq
l_int|0
op_logical_and
id|vdn.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdm.exponent
op_eq
l_int|0
op_logical_and
id|vdm.significand
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Subtraction is like addition, but with a negated operand.&n;&t; */
id|vdm.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vdm.sign
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_double_add
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fsub&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn / sm&n; */
DECL|function|vfp_double_fdiv
r_static
id|u32
id|vfp_double_fdiv
c_func
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_double
id|vdd
comma
id|vdn
comma
id|vdm
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|tm
comma
id|tn
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdn
comma
id|vfp_get_double
c_func
(paren
id|dn
)paren
)paren
suffix:semicolon
id|vfp_double_unpack
c_func
(paren
op_amp
id|vdm
comma
id|vfp_get_double
c_func
(paren
id|dm
)paren
)paren
suffix:semicolon
id|vdd.sign
op_assign
id|vdn.sign
op_xor
id|vdm.sign
suffix:semicolon
id|tn
op_assign
id|vfp_double_type
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_double_type
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is n a NAN?&n;&t; */
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_NAN
)paren
r_goto
id|vdn_nan
suffix:semicolon
multiline_comment|/*&n;&t; * Is m a NAN?&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
r_goto
id|vdm_nan
suffix:semicolon
multiline_comment|/*&n;&t; * If n and m are infinity, the result is invalid&n;&t; * If n and m are zero, the result is invalid&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|tn
op_amp
(paren
id|VFP_INFINITY
op_or
id|VFP_ZERO
)paren
)paren
r_goto
id|invalid
suffix:semicolon
multiline_comment|/*&n;&t; * If n is infinity, the result is infinity&n;&t; */
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_INFINITY
)paren
r_goto
id|infinity
suffix:semicolon
multiline_comment|/*&n;&t; * If m is zero, raise div0 exceptions&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
r_goto
id|divzero
suffix:semicolon
multiline_comment|/*&n;&t; * If m is infinity, or n is zero, the result is zero&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_INFINITY
op_logical_or
id|tn
op_amp
id|VFP_ZERO
)paren
r_goto
id|zero
suffix:semicolon
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_DENORMAL
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_double_normalise_denormal
c_func
(paren
op_amp
id|vdm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we have two numbers, we can perform division.&n;&t; */
id|vdd.exponent
op_assign
id|vdn.exponent
op_minus
id|vdm.exponent
op_plus
l_int|1023
op_minus
l_int|1
suffix:semicolon
id|vdm.significand
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vdm.significand
op_le
(paren
l_int|2
op_star
id|vdn.significand
)paren
)paren
(brace
id|vdn.significand
op_rshift_assign
l_int|1
suffix:semicolon
id|vdd.exponent
op_increment
suffix:semicolon
)brace
id|vdd.significand
op_assign
id|vfp_estimate_div128to64
c_func
(paren
id|vdn.significand
comma
l_int|0
comma
id|vdm.significand
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vdd.significand
op_amp
l_int|0x1ff
)paren
op_le
l_int|2
)paren
(brace
id|u64
id|termh
comma
id|terml
comma
id|remh
comma
id|reml
suffix:semicolon
id|mul64to128
c_func
(paren
op_amp
id|termh
comma
op_amp
id|terml
comma
id|vdm.significand
comma
id|vdd.significand
)paren
suffix:semicolon
id|sub128
c_func
(paren
op_amp
id|remh
comma
op_amp
id|reml
comma
id|vdn.significand
comma
l_int|0
comma
id|termh
comma
id|terml
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|s64
)paren
id|remh
OL
l_int|0
)paren
(brace
id|vdd.significand
op_sub_assign
l_int|1
suffix:semicolon
id|add128
c_func
(paren
op_amp
id|remh
comma
op_amp
id|reml
comma
id|remh
comma
id|reml
comma
l_int|0
comma
id|vdm.significand
)paren
suffix:semicolon
)brace
id|vdd.significand
op_or_assign
(paren
id|reml
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fdiv&quot;
)paren
suffix:semicolon
id|vdn_nan
suffix:colon
id|exceptions
op_assign
id|vfp_propagate_nan
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdn
comma
op_amp
id|vdm
comma
id|fpscr
)paren
suffix:semicolon
id|pack
suffix:colon
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_pack
c_func
(paren
op_amp
id|vdd
)paren
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
id|vdm_nan
suffix:colon
id|exceptions
op_assign
id|vfp_propagate_nan
c_func
(paren
op_amp
id|vdd
comma
op_amp
id|vdm
comma
op_amp
id|vdn
comma
id|fpscr
)paren
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|zero
suffix:colon
id|vdd.exponent
op_assign
l_int|0
suffix:semicolon
id|vdd.significand
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|divzero
suffix:colon
id|exceptions
op_assign
id|FPSCR_DZC
suffix:semicolon
id|infinity
suffix:colon
id|vdd.exponent
op_assign
l_int|2047
suffix:semicolon
id|vdd.significand
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|invalid
suffix:colon
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_pack
c_func
(paren
op_amp
id|vfp_double_default_qnan
)paren
)paren
suffix:semicolon
r_return
id|FPSCR_IOC
suffix:semicolon
)brace
DECL|variable|fop_fns
r_static
id|u32
(paren
op_star
r_const
id|fop_fns
(braket
l_int|16
)braket
)paren
(paren
r_int
id|dd
comma
r_int
id|dn
comma
r_int
id|dm
comma
id|u32
id|fpscr
)paren
op_assign
(brace
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMAC
)paren
)braket
op_assign
id|vfp_double_fmac
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMAC
)paren
)braket
op_assign
id|vfp_double_fnmac
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMSC
)paren
)braket
op_assign
id|vfp_double_fmsc
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMSC
)paren
)braket
op_assign
id|vfp_double_fnmsc
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMUL
)paren
)braket
op_assign
id|vfp_double_fmul
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMUL
)paren
)braket
op_assign
id|vfp_double_fnmul
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FADD
)paren
)braket
op_assign
id|vfp_double_fadd
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FSUB
)paren
)braket
op_assign
id|vfp_double_fsub
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FDIV
)paren
)braket
op_assign
id|vfp_double_fdiv
comma
)brace
suffix:semicolon
DECL|macro|FREG_BANK
mdefine_line|#define FREG_BANK(x)&t;((x) &amp; 0x0c)
DECL|macro|FREG_IDX
mdefine_line|#define FREG_IDX(x)&t;((x) &amp; 3)
DECL|function|vfp_double_cpdo
id|u32
id|vfp_double_cpdo
c_func
(paren
id|u32
id|inst
comma
id|u32
id|fpscr
)paren
(brace
id|u32
id|op
op_assign
id|inst
op_amp
id|FOP_MASK
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|dd
op_assign
id|vfp_get_sd
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|dn
op_assign
id|vfp_get_sn
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|dm
op_assign
id|vfp_get_sm
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|vecitr
comma
id|veclen
comma
id|vecstride
suffix:semicolon
id|u32
(paren
op_star
id|fop
)paren
(paren
r_int
comma
r_int
comma
id|s32
comma
id|u32
)paren
suffix:semicolon
id|veclen
op_assign
id|fpscr
op_amp
id|FPSCR_LENGTH_MASK
suffix:semicolon
id|vecstride
op_assign
(paren
l_int|1
op_plus
(paren
(paren
id|fpscr
op_amp
id|FPSCR_STRIDE_MASK
)paren
op_eq
id|FPSCR_STRIDE_MASK
)paren
)paren
op_star
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * If destination bank is zero, vector length is always &squot;1&squot;.&n;&t; * ARM DDI0100F C5.1.3, C5.3.2.&n;&t; */
r_if
c_cond
(paren
id|FREG_BANK
c_func
(paren
id|dd
)paren
op_eq
l_int|0
)paren
id|veclen
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: vecstride=%u veclen=%u&bslash;n&quot;
comma
id|vecstride
comma
(paren
id|veclen
op_rshift
id|FPSCR_LENGTH_BIT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|fop
op_assign
(paren
id|op
op_eq
id|FOP_EXT
)paren
ques
c_cond
id|fop_extfns
(braket
id|dn
)braket
suffix:colon
id|fop_fns
(braket
id|FOP_TO_IDX
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fop
)paren
r_goto
id|invalid
suffix:semicolon
r_for
c_loop
(paren
id|vecitr
op_assign
l_int|0
suffix:semicolon
id|vecitr
op_le
id|veclen
suffix:semicolon
id|vecitr
op_add_assign
l_int|1
op_lshift
id|FPSCR_LENGTH_BIT
)paren
(brace
id|u32
id|except
suffix:semicolon
r_if
c_cond
(paren
id|op
op_eq
id|FOP_EXT
)paren
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d (d%u.%u) = op[%u] (d%u.%u)&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|dd
op_rshift
l_int|1
comma
id|dd
op_amp
l_int|1
comma
id|dn
comma
id|dm
op_rshift
l_int|1
comma
id|dm
op_amp
l_int|1
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d (d%u.%u) = (d%u.%u) op[%u] (d%u.%u)&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|dd
op_rshift
l_int|1
comma
id|dd
op_amp
l_int|1
comma
id|dn
op_rshift
l_int|1
comma
id|dn
op_amp
l_int|1
comma
id|FOP_TO_IDX
c_func
(paren
id|op
)paren
comma
id|dm
op_rshift
l_int|1
comma
id|dm
op_amp
l_int|1
)paren
suffix:semicolon
id|except
op_assign
id|fop
c_func
(paren
id|dd
comma
id|dn
comma
id|dm
comma
id|fpscr
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d: exceptions=%08x&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|except
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|except
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This ensures that comparisons only operate on scalars;&n;&t;&t; * comparisons always return with one FPSCR status bit set.&n;&t;&t; */
r_if
c_cond
(paren
id|except
op_amp
(paren
id|FPSCR_N
op_or
id|FPSCR_Z
op_or
id|FPSCR_C
op_or
id|FPSCR_V
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * CHECK: It appears to be undefined whether we stop when&n;&t;&t; * we encounter an exception.  We continue.&n;&t;&t; */
id|dd
op_assign
id|FREG_BANK
c_func
(paren
id|dd
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|dd
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|6
)paren
suffix:semicolon
id|dn
op_assign
id|FREG_BANK
c_func
(paren
id|dn
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|dn
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FREG_BANK
c_func
(paren
id|dm
)paren
op_ne
l_int|0
)paren
id|dm
op_assign
id|FREG_BANK
c_func
(paren
id|dm
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|dm
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|6
)paren
suffix:semicolon
)brace
r_return
id|exceptions
suffix:semicolon
id|invalid
suffix:colon
r_return
op_complement
l_int|0
suffix:semicolon
)brace
eof
