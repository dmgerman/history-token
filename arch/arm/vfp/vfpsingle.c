multiline_comment|/*&n; *  linux/arch/arm/vfp/vfpsingle.c&n; *&n; * This code is derived in part from John R. Housers softfloat library, which&n; * carries the following notice:&n; *&n; * ===========================================================================&n; * This C source file is part of the SoftFloat IEC/IEEE Floating-point&n; * Arithmetic Package, Release 2.&n; *&n; * Written by John R. Hauser.  This work was made possible in part by the&n; * International Computer Science Institute, located at Suite 600, 1947 Center&n; * Street, Berkeley, California 94704.  Funding was partially provided by the&n; * National Science Foundation under grant MIP-9311980.  The original version&n; * of this code was written as part of a project to build a fixed-point vector&n; * processor in collaboration with the University of California at Berkeley,&n; * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information&n; * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/&n; * arithmetic/softfloat.html&squot;.&n; *&n; * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort&n; * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT&n; * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO&n; * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY&n; * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.&n; *&n; * Derivative works are acceptable, even for commercial purposes, so long as&n; * (1) they include prominent notice that the work is derivative, and (2) they&n; * include prominent notice akin to these three paragraphs for those parts of&n; * this code that are retained.&n; * ===========================================================================&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/vfp.h&gt;
macro_line|#include &quot;vfpinstr.h&quot;
macro_line|#include &quot;vfp.h&quot;
DECL|variable|vfp_single_default_qnan
r_static
r_struct
id|vfp_single
id|vfp_single_default_qnan
op_assign
(brace
dot
id|exponent
op_assign
l_int|255
comma
dot
id|sign
op_assign
l_int|0
comma
dot
id|significand
op_assign
id|VFP_SINGLE_SIGNIFICAND_QNAN
comma
)brace
suffix:semicolon
DECL|function|vfp_single_dump
r_static
r_void
id|vfp_single_dump
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|vfp_single
op_star
id|s
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: %s: sign=%d exponent=%d significand=%08x&bslash;n&quot;
comma
id|str
comma
id|s-&gt;sign
op_ne
l_int|0
comma
id|s-&gt;exponent
comma
id|s-&gt;significand
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_normalise_denormal
r_static
r_void
id|vfp_single_normalise_denormal
c_func
(paren
r_struct
id|vfp_single
op_star
id|vs
)paren
(brace
r_int
id|bits
op_assign
l_int|31
op_minus
id|fls
c_func
(paren
id|vs-&gt;significand
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;normalise_denormal: in&quot;
comma
id|vs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
)paren
(brace
id|vs-&gt;exponent
op_sub_assign
id|bits
op_minus
l_int|1
suffix:semicolon
id|vs-&gt;significand
op_lshift_assign
id|bits
suffix:semicolon
)brace
id|vfp_single_dump
c_func
(paren
l_string|&quot;normalise_denormal: out&quot;
comma
id|vs
)paren
suffix:semicolon
)brace
macro_line|#ifndef DEBUG
DECL|macro|vfp_single_normaliseround
mdefine_line|#define vfp_single_normaliseround(sd,vsd,fpscr,except,func) __vfp_single_normaliseround(sd,vsd,fpscr,except)
DECL|function|__vfp_single_normaliseround
id|u32
id|__vfp_single_normaliseround
c_func
(paren
r_int
id|sd
comma
r_struct
id|vfp_single
op_star
id|vs
comma
id|u32
id|fpscr
comma
id|u32
id|exceptions
)paren
macro_line|#else
id|u32
id|vfp_single_normaliseround
c_func
(paren
r_int
id|sd
comma
r_struct
id|vfp_single
op_star
id|vs
comma
id|u32
id|fpscr
comma
id|u32
id|exceptions
comma
r_const
r_char
op_star
id|func
)paren
macro_line|#endif
(brace
id|u32
id|significand
comma
id|incr
comma
id|rmode
suffix:semicolon
r_int
id|exponent
comma
id|shift
comma
id|underflow
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;pack: in&quot;
comma
id|vs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Infinities and NaNs are a special case.&n;&t; */
r_if
c_cond
(paren
id|vs-&gt;exponent
op_eq
l_int|255
op_logical_and
(paren
id|vs-&gt;significand
op_eq
l_int|0
op_logical_or
id|exceptions
)paren
)paren
r_goto
id|pack
suffix:semicolon
multiline_comment|/*&n;&t; * Special-case zero.&n;&t; */
r_if
c_cond
(paren
id|vs-&gt;significand
op_eq
l_int|0
)paren
(brace
id|vs-&gt;exponent
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
)brace
id|exponent
op_assign
id|vs-&gt;exponent
suffix:semicolon
id|significand
op_assign
id|vs-&gt;significand
suffix:semicolon
multiline_comment|/*&n;&t; * Normalise first.  Note that we shift the significand up to&n;&t; * bit 31, so we have VFP_SINGLE_LOW_BITS + 1 below the least&n;&t; * significant bit.&n;&t; */
id|shift
op_assign
l_int|32
op_minus
id|fls
c_func
(paren
id|significand
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
OL
l_int|32
op_logical_and
id|shift
)paren
(brace
id|exponent
op_sub_assign
id|shift
suffix:semicolon
id|significand
op_lshift_assign
id|shift
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|vs-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vs-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;pack: normalised&quot;
comma
id|vs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Tiny number?&n;&t; */
id|underflow
op_assign
id|exponent
OL
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|underflow
)paren
(brace
id|significand
op_assign
id|vfp_shiftright32jamming
c_func
(paren
id|significand
comma
op_minus
id|exponent
)paren
suffix:semicolon
id|exponent
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|vs-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vs-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;pack: tiny number&quot;
comma
id|vs
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|significand
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
)paren
)paren
id|underflow
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Select rounding increment.&n;&t; */
id|incr
op_assign
l_int|0
suffix:semicolon
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|1
op_lshift
id|VFP_SINGLE_LOW_BITS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|significand
op_amp
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vs-&gt;sign
op_ne
l_int|0
)paren
)paren
id|incr
op_assign
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: rounding increment = 0x%08x&bslash;n&quot;
comma
id|incr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is our rounding going to overflow?&n;&t; */
r_if
c_cond
(paren
(paren
id|significand
op_plus
id|incr
)paren
OL
id|significand
)paren
(brace
id|exponent
op_add_assign
l_int|1
suffix:semicolon
id|significand
op_assign
(paren
id|significand
op_rshift
l_int|1
)paren
op_or
(paren
id|significand
op_amp
l_int|1
)paren
suffix:semicolon
id|incr
op_rshift_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|vs-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vs-&gt;significand
op_assign
id|significand
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;pack: overflow&quot;
comma
id|vs
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * If any of the low bits (which will be shifted out of the&n;&t; * number) are non-zero, the result is inexact.&n;&t; */
r_if
c_cond
(paren
id|significand
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_LOW_BITS
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
multiline_comment|/*&n;&t; * Do our rounding.&n;&t; */
id|significand
op_add_assign
id|incr
suffix:semicolon
multiline_comment|/*&n;&t; * Infinity?&n;&t; */
r_if
c_cond
(paren
id|exponent
op_ge
l_int|254
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_OFC
op_or
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|incr
op_eq
l_int|0
)paren
(brace
id|vs-&gt;exponent
op_assign
l_int|253
suffix:semicolon
id|vs-&gt;significand
op_assign
l_int|0x7fffffff
suffix:semicolon
)brace
r_else
(brace
id|vs-&gt;exponent
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* infinity */
id|vs-&gt;significand
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|significand
op_rshift
(paren
id|VFP_SINGLE_LOW_BITS
op_plus
l_int|1
)paren
op_eq
l_int|0
)paren
id|exponent
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_logical_or
id|significand
OG
l_int|0x80000000
)paren
id|underflow
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|underflow
)paren
id|exceptions
op_or_assign
id|FPSCR_UFC
suffix:semicolon
id|vs-&gt;exponent
op_assign
id|exponent
suffix:semicolon
id|vs-&gt;significand
op_assign
id|significand
op_rshift
l_int|1
suffix:semicolon
)brace
id|pack
suffix:colon
id|vfp_single_dump
c_func
(paren
l_string|&quot;pack: final&quot;
comma
id|vs
)paren
suffix:semicolon
(brace
id|s32
id|d
op_assign
id|vfp_single_pack
c_func
(paren
id|vs
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: %s: d(s%d)=%08x exceptions=%08x&bslash;n&quot;
comma
id|func
comma
id|sd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|d
)paren
suffix:semicolon
)brace
r_return
id|exceptions
op_amp
op_complement
id|VFP_NAN_FLAG
suffix:semicolon
)brace
multiline_comment|/*&n; * Propagate the NaN, setting exceptions if it is signalling.&n; * &squot;n&squot; is always a NaN.  &squot;m&squot; may be a number, NaN or infinity.&n; */
r_static
id|u32
DECL|function|vfp_propagate_nan
id|vfp_propagate_nan
c_func
(paren
r_struct
id|vfp_single
op_star
id|vsd
comma
r_struct
id|vfp_single
op_star
id|vsn
comma
r_struct
id|vfp_single
op_star
id|vsm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
op_star
id|nan
suffix:semicolon
r_int
id|tn
comma
id|tm
op_assign
l_int|0
suffix:semicolon
id|tn
op_assign
id|vfp_single_type
c_func
(paren
id|vsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsm
)paren
id|tm
op_assign
id|vfp_single_type
c_func
(paren
id|vsm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fpscr
op_amp
id|FPSCR_DEFAULT_NAN
)paren
multiline_comment|/*&n;&t;&t; * Default NaN mode - always returns a quiet NaN&n;&t;&t; */
id|nan
op_assign
op_amp
id|vfp_single_default_qnan
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * Contemporary mode - select the first signalling&n;&t;&t; * NAN, or if neither are signalling, the first&n;&t;&t; * quiet NAN.&n;&t;&t; */
r_if
c_cond
(paren
id|tn
op_eq
id|VFP_SNAN
op_logical_or
(paren
id|tm
op_ne
id|VFP_SNAN
op_logical_and
id|tn
op_eq
id|VFP_QNAN
)paren
)paren
id|nan
op_assign
id|vsn
suffix:semicolon
r_else
id|nan
op_assign
id|vsm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make the NaN quiet.&n;&t;&t; */
id|nan-&gt;significand
op_or_assign
id|VFP_SINGLE_SIGNIFICAND_QNAN
suffix:semicolon
)brace
op_star
id|vsd
op_assign
op_star
id|nan
suffix:semicolon
multiline_comment|/*&n;&t; * If one was a signalling NAN, raise invalid operation.&n;&t; */
r_return
id|tn
op_eq
id|VFP_SNAN
op_logical_or
id|tm
op_eq
id|VFP_SNAN
ques
c_cond
id|FPSCR_IOC
suffix:colon
id|VFP_NAN_FLAG
suffix:semicolon
)brace
multiline_comment|/*&n; * Extended operations&n; */
DECL|function|vfp_single_fabs
r_static
id|u32
id|vfp_single_fabs
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_packed_abs
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfp_single_fcpy
r_static
id|u32
id|vfp_single_fcpy
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_float
c_func
(paren
id|sd
comma
id|m
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfp_single_fneg
r_static
id|u32
id|vfp_single_fneg
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_packed_negate
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sqrt_oddadjust
r_static
r_const
id|u16
id|sqrt_oddadjust
(braket
)braket
op_assign
(brace
l_int|0x0004
comma
l_int|0x0022
comma
l_int|0x005d
comma
l_int|0x00b1
comma
l_int|0x011d
comma
l_int|0x019f
comma
l_int|0x0236
comma
l_int|0x02e0
comma
l_int|0x039c
comma
l_int|0x0468
comma
l_int|0x0545
comma
l_int|0x0631
comma
l_int|0x072b
comma
l_int|0x0832
comma
l_int|0x0946
comma
l_int|0x0a67
)brace
suffix:semicolon
DECL|variable|sqrt_evenadjust
r_static
r_const
id|u16
id|sqrt_evenadjust
(braket
)braket
op_assign
(brace
l_int|0x0a2d
comma
l_int|0x08af
comma
l_int|0x075a
comma
l_int|0x0629
comma
l_int|0x051a
comma
l_int|0x0429
comma
l_int|0x0356
comma
l_int|0x029e
comma
l_int|0x0200
comma
l_int|0x0179
comma
l_int|0x0109
comma
l_int|0x00af
comma
l_int|0x0068
comma
l_int|0x0034
comma
l_int|0x0012
comma
l_int|0x0002
)brace
suffix:semicolon
DECL|function|vfp_estimate_sqrt_significand
id|u32
id|vfp_estimate_sqrt_significand
c_func
(paren
id|u32
id|exponent
comma
id|u32
id|significand
)paren
(brace
r_int
id|index
suffix:semicolon
id|u32
id|z
comma
id|a
suffix:semicolon
r_if
c_cond
(paren
(paren
id|significand
op_amp
l_int|0xc0000000
)paren
op_ne
l_int|0x40000000
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFP: estimate_sqrt: invalid significand&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|a
op_assign
id|significand
op_lshift
l_int|1
suffix:semicolon
id|index
op_assign
(paren
id|a
op_rshift
l_int|27
)paren
op_amp
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_amp
l_int|1
)paren
(brace
id|z
op_assign
l_int|0x4000
op_plus
(paren
id|a
op_rshift
l_int|17
)paren
op_minus
id|sqrt_oddadjust
(braket
id|index
)braket
suffix:semicolon
id|z
op_assign
(paren
(paren
id|a
op_div
id|z
)paren
op_lshift
l_int|14
)paren
op_plus
(paren
id|z
op_lshift
l_int|15
)paren
suffix:semicolon
id|a
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|z
op_assign
l_int|0x8000
op_plus
(paren
id|a
op_rshift
l_int|17
)paren
op_minus
id|sqrt_evenadjust
(braket
id|index
)braket
suffix:semicolon
id|z
op_assign
id|a
op_div
id|z
op_plus
id|z
suffix:semicolon
id|z
op_assign
(paren
id|z
op_ge
l_int|0x20000
)paren
ques
c_cond
l_int|0xffff8000
suffix:colon
(paren
id|z
op_lshift
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|z
op_le
id|a
)paren
r_return
(paren
id|s32
)paren
id|a
op_rshift
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|u32
)paren
(paren
(paren
(paren
id|u64
)paren
id|a
op_lshift
l_int|31
)paren
op_div
id|z
)paren
op_plus
(paren
id|z
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fsqrt
r_static
id|u32
id|vfp_single_fsqrt
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsm
comma
id|vsd
suffix:semicolon
r_int
id|ret
comma
id|tm
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_single_type
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
(paren
id|VFP_NAN
op_or
id|VFP_INFINITY
)paren
)paren
(brace
r_struct
id|vfp_single
op_star
id|vsp
op_assign
op_amp
id|vsd
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|ret
op_assign
id|vfp_propagate_nan
c_func
(paren
id|vsp
comma
op_amp
id|vsm
comma
l_int|NULL
comma
id|fpscr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|vsm.sign
op_eq
l_int|0
)paren
(brace
id|sqrt_copy
suffix:colon
id|vsp
op_assign
op_amp
id|vsm
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sqrt_invalid
suffix:colon
id|vsp
op_assign
op_amp
id|vfp_single_default_qnan
suffix:semicolon
id|ret
op_assign
id|FPSCR_IOC
suffix:semicolon
)brace
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_pack
c_func
(paren
id|vsp
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sqrt(+/- 0) == +/- 0&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
r_goto
id|sqrt_copy
suffix:semicolon
multiline_comment|/*&n;&t; * Normalise a denormalised number&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * sqrt(&lt;0) = invalid&n;&t; */
r_if
c_cond
(paren
id|vsm.sign
)paren
r_goto
id|sqrt_invalid
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;sqrt&quot;
comma
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Estimate the square root.&n;&t; */
id|vsd.sign
op_assign
l_int|0
suffix:semicolon
id|vsd.exponent
op_assign
(paren
(paren
id|vsm.exponent
op_minus
l_int|127
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|127
suffix:semicolon
id|vsd.significand
op_assign
id|vfp_estimate_sqrt_significand
c_func
(paren
id|vsm.exponent
comma
id|vsm.significand
)paren
op_plus
l_int|2
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;sqrt estimate&quot;
comma
op_amp
id|vsd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And now adjust.&n;&t; */
r_if
c_cond
(paren
(paren
id|vsd.significand
op_amp
id|VFP_SINGLE_LOW_BITS_MASK
)paren
op_le
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|vsd.significand
OL
l_int|2
)paren
(brace
id|vsd.significand
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_else
(brace
id|u64
id|term
suffix:semicolon
id|s64
id|rem
suffix:semicolon
id|vsm.significand
op_lshift_assign
op_logical_neg
(paren
id|vsm.exponent
op_amp
l_int|1
)paren
suffix:semicolon
id|term
op_assign
(paren
id|u64
)paren
id|vsd.significand
op_star
id|vsd.significand
suffix:semicolon
id|rem
op_assign
(paren
(paren
id|u64
)paren
id|vsm.significand
op_lshift
l_int|32
)paren
op_minus
id|term
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: term=%016llx rem=%016llx&bslash;n&quot;
comma
id|term
comma
id|rem
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rem
OL
l_int|0
)paren
(brace
id|vsd.significand
op_sub_assign
l_int|1
suffix:semicolon
id|rem
op_add_assign
(paren
(paren
id|u64
)paren
id|vsd.significand
op_lshift
l_int|1
)paren
op_or
l_int|1
suffix:semicolon
)brace
id|vsd.significand
op_or_assign
id|rem
op_ne
l_int|0
suffix:semicolon
)brace
)brace
id|vsd.significand
op_assign
id|vfp_shiftright32jamming
c_func
(paren
id|vsd.significand
comma
l_int|1
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fsqrt&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Equal&t;:= ZC&n; * Less than&t;:= N&n; * Greater than&t;:= C&n; * Unordered&t;:= CV&n; */
DECL|function|vfp_compare
r_static
id|u32
id|vfp_compare
c_func
(paren
r_int
id|sd
comma
r_int
id|signal_on_qnan
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
id|s32
id|d
suffix:semicolon
id|u32
id|ret
op_assign
l_int|0
suffix:semicolon
id|d
op_assign
id|vfp_get_float
c_func
(paren
id|sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfp_single_packed_exponent
c_func
(paren
id|m
)paren
op_eq
l_int|255
op_logical_and
id|vfp_single_packed_mantissa
c_func
(paren
id|m
)paren
)paren
(brace
id|ret
op_or_assign
id|FPSCR_C
op_or
id|FPSCR_V
suffix:semicolon
r_if
c_cond
(paren
id|signal_on_qnan
op_logical_or
op_logical_neg
(paren
id|vfp_single_packed_mantissa
c_func
(paren
id|m
)paren
op_amp
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_MANTISSA_BITS
op_minus
l_int|1
)paren
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Signalling NaN, or signalling on quiet NaN&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vfp_single_packed_exponent
c_func
(paren
id|d
)paren
op_eq
l_int|255
op_logical_and
id|vfp_single_packed_mantissa
c_func
(paren
id|d
)paren
)paren
(brace
id|ret
op_or_assign
id|FPSCR_C
op_or
id|FPSCR_V
suffix:semicolon
r_if
c_cond
(paren
id|signal_on_qnan
op_logical_or
op_logical_neg
(paren
id|vfp_single_packed_mantissa
c_func
(paren
id|d
)paren
op_amp
(paren
l_int|1
op_lshift
(paren
id|VFP_SINGLE_MANTISSA_BITS
op_minus
l_int|1
)paren
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Signalling NaN, or signalling on quiet NaN&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|m
op_logical_or
id|vfp_single_packed_abs
c_func
(paren
id|d
op_or
id|m
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * equal&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_Z
op_or
id|FPSCR_C
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vfp_single_packed_sign
c_func
(paren
id|d
op_xor
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * different signs&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vfp_single_packed_sign
c_func
(paren
id|d
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * d is negative, so d &lt; m&n;&t;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_N
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t;&t; * d is positive, so d &gt; m&n;&t;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_C
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|vfp_single_packed_sign
c_func
(paren
id|d
)paren
op_ne
l_int|0
)paren
op_xor
(paren
id|d
OL
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * d &lt; m&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_N
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|vfp_single_packed_sign
c_func
(paren
id|d
)paren
op_ne
l_int|0
)paren
op_xor
(paren
id|d
OG
id|m
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * d &gt; m&n;&t;&t;&t; */
id|ret
op_or_assign
id|FPSCR_C
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|vfp_single_fcmp
r_static
id|u32
id|vfp_single_fcmp
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|sd
comma
l_int|0
comma
id|m
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fcmpe
r_static
id|u32
id|vfp_single_fcmpe
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|sd
comma
l_int|1
comma
id|m
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fcmpz
r_static
id|u32
id|vfp_single_fcmpz
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|sd
comma
l_int|0
comma
l_int|0
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fcmpez
r_static
id|u32
id|vfp_single_fcmpez
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_compare
c_func
(paren
id|sd
comma
l_int|1
comma
l_int|0
comma
id|fpscr
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fcvtd
r_static
id|u32
id|vfp_single_fcvtd
c_func
(paren
r_int
id|dd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsm
suffix:semicolon
r_struct
id|vfp_double
id|vdd
suffix:semicolon
r_int
id|tm
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_single_type
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a signalling NaN, signal invalid operation.&n;&t; */
r_if
c_cond
(paren
id|tm
op_eq
id|VFP_SNAN
)paren
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
id|vdd.sign
op_assign
id|vsm.sign
suffix:semicolon
id|vdd.significand
op_assign
(paren
id|u64
)paren
id|vsm.significand
op_lshift
l_int|32
suffix:semicolon
multiline_comment|/*&n;&t; * If we have an infinity or NaN, the exponent must be 2047.&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
(paren
id|VFP_INFINITY
op_or
id|VFP_NAN
)paren
)paren
(brace
id|vdd.exponent
op_assign
l_int|2047
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|vdd.significand
op_or_assign
id|VFP_DOUBLE_SIGNIFICAND_QNAN
suffix:semicolon
r_goto
id|pack_nan
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
id|vdd.exponent
op_assign
l_int|0
suffix:semicolon
r_else
id|vdd.exponent
op_assign
id|vsm.exponent
op_plus
(paren
l_int|1023
op_minus
l_int|127
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Technically, if bit 0 of dd is set, this is an invalid&n;&t; * instruction.  However, we ignore this for efficiency.&n;&t; */
r_return
id|vfp_double_normaliseround
c_func
(paren
id|dd
comma
op_amp
id|vdd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fcvtd&quot;
)paren
suffix:semicolon
id|pack_nan
suffix:colon
id|vfp_put_double
c_func
(paren
id|dd
comma
id|vfp_double_pack
c_func
(paren
op_amp
id|vdd
)paren
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_single_fuito
r_static
id|u32
id|vfp_single_fuito
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vs
suffix:semicolon
id|vs.sign
op_assign
l_int|0
suffix:semicolon
id|vs.exponent
op_assign
l_int|127
op_plus
l_int|31
op_minus
l_int|1
suffix:semicolon
id|vs.significand
op_assign
(paren
id|u32
)paren
id|m
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vs
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fuito&quot;
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_fsito
r_static
id|u32
id|vfp_single_fsito
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vs
suffix:semicolon
id|vs.sign
op_assign
(paren
id|m
op_amp
l_int|0x80000000
)paren
op_rshift
l_int|16
suffix:semicolon
id|vs.exponent
op_assign
l_int|127
op_plus
l_int|31
op_minus
l_int|1
suffix:semicolon
id|vs.significand
op_assign
id|vs.sign
ques
c_cond
op_minus
id|m
suffix:colon
id|m
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vs
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fsito&quot;
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_ftoui
r_static
id|u32
id|vfp_single_ftoui
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsm
suffix:semicolon
id|u32
id|d
comma
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
r_int
id|tm
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSM&quot;
comma
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have a denormalised number?&n;&t; */
id|tm
op_assign
id|vfp_single_type
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|exceptions
op_or_assign
id|FPSCR_IDC
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
id|vsm.sign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_ge
l_int|127
op_plus
l_int|32
)paren
(brace
id|d
op_assign
id|vsm.sign
ques
c_cond
l_int|0
suffix:colon
l_int|0xffffffff
suffix:semicolon
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vsm.exponent
op_ge
l_int|127
op_minus
l_int|1
)paren
(brace
r_int
id|shift
op_assign
l_int|127
op_plus
l_int|31
op_minus
id|vsm.exponent
suffix:semicolon
id|u32
id|rem
comma
id|incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * 2^0 &lt;= m &lt; 2^32-2^8&n;&t;&t; */
id|d
op_assign
(paren
id|vsm.significand
op_lshift
l_int|1
)paren
op_rshift
id|shift
suffix:semicolon
id|rem
op_assign
id|vsm.significand
op_lshift
(paren
l_int|33
op_minus
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|0x80000000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vsm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|incr
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rem
op_plus
id|incr
)paren
OL
id|rem
)paren
(brace
r_if
c_cond
(paren
id|d
OL
l_int|0xffffffff
)paren
id|d
op_add_assign
l_int|1
suffix:semicolon
r_else
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d
op_logical_and
id|vsm.sign
)paren
(brace
id|d
op_assign
l_int|0
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rem
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_or
id|vsm.significand
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
op_logical_and
id|vsm.sign
op_eq
l_int|0
)paren
id|d
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_MINUSINF
op_logical_and
id|vsm.sign
)paren
(brace
id|d
op_assign
l_int|0
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
)brace
)brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: ftoui: d(s%d)=%08x exceptions=%08x&bslash;n&quot;
comma
id|sd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|d
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_single_ftouiz
r_static
id|u32
id|vfp_single_ftouiz
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_ftoui
c_func
(paren
id|sd
comma
id|unused
comma
id|m
comma
id|FPSCR_ROUND_TOZERO
)paren
suffix:semicolon
)brace
DECL|function|vfp_single_ftosi
r_static
id|u32
id|vfp_single_ftosi
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsm
suffix:semicolon
id|u32
id|d
comma
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|rmode
op_assign
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSM&quot;
comma
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have a denormalised number?&n;&t; */
r_if
c_cond
(paren
id|vfp_single_type
c_func
(paren
op_amp
id|vsm
)paren
op_amp
id|VFP_DENORMAL
)paren
id|exceptions
op_or_assign
id|FPSCR_IDC
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_ge
l_int|127
op_plus
l_int|32
)paren
(brace
multiline_comment|/*&n;&t;&t; * m &gt;= 2^31-2^7: invalid&n;&t;&t; */
id|d
op_assign
l_int|0x7fffffff
suffix:semicolon
r_if
c_cond
(paren
id|vsm.sign
)paren
id|d
op_assign
op_complement
id|d
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vsm.exponent
op_ge
l_int|127
op_minus
l_int|1
)paren
(brace
r_int
id|shift
op_assign
l_int|127
op_plus
l_int|31
op_minus
id|vsm.exponent
suffix:semicolon
id|u32
id|rem
comma
id|incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 2^0 &lt;= m &lt;= 2^31-2^7 */
id|d
op_assign
(paren
id|vsm.significand
op_lshift
l_int|1
)paren
op_rshift
id|shift
suffix:semicolon
id|rem
op_assign
id|vsm.significand
op_lshift
(paren
l_int|33
op_minus
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_NEAREST
)paren
(brace
id|incr
op_assign
l_int|0x80000000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|incr
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_TOZERO
)paren
(brace
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
)paren
op_xor
(paren
id|vsm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|incr
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rem
op_plus
id|incr
)paren
OL
id|rem
op_logical_and
id|d
OL
l_int|0xffffffff
)paren
id|d
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|d
OG
l_int|0x7fffffff
op_plus
(paren
id|vsm.sign
op_ne
l_int|0
)paren
)paren
(brace
id|d
op_assign
l_int|0x7fffffff
op_plus
(paren
id|vsm.sign
op_ne
l_int|0
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|FPSCR_IOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rem
)paren
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|vsm.sign
)paren
id|d
op_assign
op_minus
id|d
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_or
id|vsm.significand
)paren
(brace
id|exceptions
op_or_assign
id|FPSCR_IXC
suffix:semicolon
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_PLUSINF
op_logical_and
id|vsm.sign
op_eq
l_int|0
)paren
id|d
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rmode
op_eq
id|FPSCR_ROUND_MINUSINF
op_logical_and
id|vsm.sign
)paren
id|d
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|pr_debug
c_func
(paren
l_string|&quot;VFP: ftosi: d(s%d)=%08x exceptions=%08x&bslash;n&quot;
comma
id|sd
comma
id|d
comma
id|exceptions
)paren
suffix:semicolon
id|vfp_put_float
c_func
(paren
id|sd
comma
(paren
id|s32
)paren
id|d
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
DECL|function|vfp_single_ftosiz
r_static
id|u32
id|vfp_single_ftosiz
c_func
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_ftosi
c_func
(paren
id|sd
comma
id|unused
comma
id|m
comma
id|FPSCR_ROUND_TOZERO
)paren
suffix:semicolon
)brace
DECL|variable|fop_extfns
r_static
id|u32
(paren
op_star
r_const
id|fop_extfns
(braket
l_int|32
)braket
)paren
(paren
r_int
id|sd
comma
r_int
id|unused
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
op_assign
(brace
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCPY
)paren
)braket
op_assign
id|vfp_single_fcpy
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FABS
)paren
)braket
op_assign
id|vfp_single_fabs
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FNEG
)paren
)braket
op_assign
id|vfp_single_fneg
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FSQRT
)paren
)braket
op_assign
id|vfp_single_fsqrt
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMP
)paren
)braket
op_assign
id|vfp_single_fcmp
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPE
)paren
)braket
op_assign
id|vfp_single_fcmpe
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPZ
)paren
)braket
op_assign
id|vfp_single_fcmpz
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCMPEZ
)paren
)braket
op_assign
id|vfp_single_fcmpez
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FCVT
)paren
)braket
op_assign
id|vfp_single_fcvtd
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FUITO
)paren
)braket
op_assign
id|vfp_single_fuito
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FSITO
)paren
)braket
op_assign
id|vfp_single_fsito
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOUI
)paren
)braket
op_assign
id|vfp_single_ftoui
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOUIZ
)paren
)braket
op_assign
id|vfp_single_ftouiz
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOSI
)paren
)braket
op_assign
id|vfp_single_ftosi
comma
(braket
id|FEXT_TO_IDX
c_func
(paren
id|FEXT_FTOSIZ
)paren
)braket
op_assign
id|vfp_single_ftosiz
comma
)brace
suffix:semicolon
r_static
id|u32
DECL|function|vfp_single_fadd_nonnumber
id|vfp_single_fadd_nonnumber
c_func
(paren
r_struct
id|vfp_single
op_star
id|vsd
comma
r_struct
id|vfp_single
op_star
id|vsn
comma
r_struct
id|vfp_single
op_star
id|vsm
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
op_star
id|vsp
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
id|tn
comma
id|tm
suffix:semicolon
id|tn
op_assign
id|vfp_single_type
c_func
(paren
id|vsn
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_single_type
c_func
(paren
id|vsm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tn
op_amp
id|tm
op_amp
id|VFP_INFINITY
)paren
(brace
multiline_comment|/*&n;&t;&t; * Two infinities.  Are they different signs?&n;&t;&t; */
r_if
c_cond
(paren
id|vsn-&gt;sign
op_xor
id|vsm-&gt;sign
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * different signs -&gt; invalid&n;&t;&t;&t; */
id|exceptions
op_assign
id|FPSCR_IOC
suffix:semicolon
id|vsp
op_assign
op_amp
id|vfp_single_default_qnan
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * same signs -&gt; valid&n;&t;&t;&t; */
id|vsp
op_assign
id|vsn
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_INFINITY
op_logical_and
id|tm
op_amp
id|VFP_NUMBER
)paren
(brace
multiline_comment|/*&n;&t;&t; * One infinity and one number -&gt; infinity&n;&t;&t; */
id|vsp
op_assign
id|vsn
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * &squot;n&squot; is a NaN of some type&n;&t;&t; */
r_return
id|vfp_propagate_nan
c_func
(paren
id|vsd
comma
id|vsn
comma
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
)brace
op_star
id|vsd
op_assign
op_star
id|vsp
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
)brace
r_static
id|u32
DECL|function|vfp_single_add
id|vfp_single_add
c_func
(paren
r_struct
id|vfp_single
op_star
id|vsd
comma
r_struct
id|vfp_single
op_star
id|vsn
comma
r_struct
id|vfp_single
op_star
id|vsm
comma
id|u32
id|fpscr
)paren
(brace
id|u32
id|exp_diff
comma
id|m_sig
suffix:semicolon
r_if
c_cond
(paren
id|vsn-&gt;significand
op_amp
l_int|0x80000000
op_logical_or
id|vsm-&gt;significand
op_amp
l_int|0x80000000
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;VFP: bad FP values in %s&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSN&quot;
comma
id|vsn
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSM&quot;
comma
id|vsm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure that &squot;n&squot; is the largest magnitude number.  Note that&n;&t; * if &squot;n&squot; and &squot;m&squot; have equal exponents, we do not swap them.&n;&t; * This ensures that NaN propagation works correctly.&n;&t; */
r_if
c_cond
(paren
id|vsn-&gt;exponent
OL
id|vsm-&gt;exponent
)paren
(brace
r_struct
id|vfp_single
op_star
id|t
op_assign
id|vsn
suffix:semicolon
id|vsn
op_assign
id|vsm
suffix:semicolon
id|vsm
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is &squot;n&squot; an infinity or a NaN?  Note that &squot;m&squot; may be a number,&n;&t; * infinity or a NaN here.&n;&t; */
r_if
c_cond
(paren
id|vsn-&gt;exponent
op_eq
l_int|255
)paren
r_return
id|vfp_single_fadd_nonnumber
c_func
(paren
id|vsd
comma
id|vsn
comma
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have two proper numbers, where &squot;vsn&squot; is the larger magnitude.&n;&t; *&n;&t; * Copy &squot;n&squot; to &squot;d&squot; before doing the arithmetic.&n;&t; */
op_star
id|vsd
op_assign
op_star
id|vsn
suffix:semicolon
multiline_comment|/*&n;&t; * Align both numbers.&n;&t; */
id|exp_diff
op_assign
id|vsn-&gt;exponent
op_minus
id|vsm-&gt;exponent
suffix:semicolon
id|m_sig
op_assign
id|vfp_shiftright32jamming
c_func
(paren
id|vsm-&gt;significand
comma
id|exp_diff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the signs are different, we are really subtracting.&n;&t; */
r_if
c_cond
(paren
id|vsn-&gt;sign
op_xor
id|vsm-&gt;sign
)paren
(brace
id|m_sig
op_assign
id|vsn-&gt;significand
op_minus
id|m_sig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s32
)paren
id|m_sig
OL
l_int|0
)paren
(brace
id|vsd-&gt;sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vsd-&gt;sign
)paren
suffix:semicolon
id|m_sig
op_assign
op_minus
id|m_sig
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m_sig
op_eq
l_int|0
)paren
(brace
id|vsd-&gt;sign
op_assign
(paren
id|fpscr
op_amp
id|FPSCR_RMODE_MASK
)paren
op_eq
id|FPSCR_ROUND_MINUSINF
ques
c_cond
l_int|0x8000
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|m_sig
op_assign
id|vsn-&gt;significand
op_plus
id|m_sig
suffix:semicolon
)brace
id|vsd-&gt;significand
op_assign
id|m_sig
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|u32
DECL|function|vfp_single_multiply
id|vfp_single_multiply
c_func
(paren
r_struct
id|vfp_single
op_star
id|vsd
comma
r_struct
id|vfp_single
op_star
id|vsn
comma
r_struct
id|vfp_single
op_star
id|vsm
comma
id|u32
id|fpscr
)paren
(brace
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSN&quot;
comma
id|vsn
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSM&quot;
comma
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that &squot;n&squot; is the largest magnitude number.  Note that&n;&t; * if &squot;n&squot; and &squot;m&squot; have equal exponents, we do not swap them.&n;&t; * This ensures that NaN propagation works correctly.&n;&t; */
r_if
c_cond
(paren
id|vsn-&gt;exponent
OL
id|vsm-&gt;exponent
)paren
(brace
r_struct
id|vfp_single
op_star
id|t
op_assign
id|vsn
suffix:semicolon
id|vsn
op_assign
id|vsm
suffix:semicolon
id|vsm
op_assign
id|t
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: swapping M &lt;-&gt; N&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|vsd-&gt;sign
op_assign
id|vsn-&gt;sign
op_xor
id|vsm-&gt;sign
suffix:semicolon
multiline_comment|/*&n;&t; * If &squot;n&squot; is an infinity or NaN, handle it.  &squot;m&squot; may be anything.&n;&t; */
r_if
c_cond
(paren
id|vsn-&gt;exponent
op_eq
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|vsn-&gt;significand
op_logical_or
(paren
id|vsm-&gt;exponent
op_eq
l_int|255
op_logical_and
id|vsm-&gt;significand
)paren
)paren
r_return
id|vfp_propagate_nan
c_func
(paren
id|vsd
comma
id|vsn
comma
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vsm-&gt;exponent
op_or
id|vsm-&gt;significand
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|vsd
op_assign
id|vfp_single_default_qnan
suffix:semicolon
r_return
id|FPSCR_IOC
suffix:semicolon
)brace
id|vsd-&gt;exponent
op_assign
id|vsn-&gt;exponent
suffix:semicolon
id|vsd-&gt;significand
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If &squot;m&squot; is zero, the result is always zero.  In this case,&n;&t; * &squot;n&squot; may be zero or a number, but it doesn&squot;t matter which.&n;&t; */
r_if
c_cond
(paren
(paren
id|vsm-&gt;exponent
op_or
id|vsm-&gt;significand
)paren
op_eq
l_int|0
)paren
(brace
id|vsd-&gt;exponent
op_assign
l_int|0
suffix:semicolon
id|vsd-&gt;significand
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We add 2 to the destination exponent for the same reason as&n;&t; * the addition case - though this time we have +1 from each&n;&t; * input operand.&n;&t; */
id|vsd-&gt;exponent
op_assign
id|vsn-&gt;exponent
op_plus
id|vsm-&gt;exponent
op_minus
l_int|127
op_plus
l_int|2
suffix:semicolon
id|vsd-&gt;significand
op_assign
id|vfp_hi64to32jamming
c_func
(paren
(paren
id|u64
)paren
id|vsn-&gt;significand
op_star
id|vsm-&gt;significand
)paren
suffix:semicolon
id|vfp_single_dump
c_func
(paren
l_string|&quot;VSD&quot;
comma
id|vsd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|NEG_MULTIPLY
mdefine_line|#define NEG_MULTIPLY&t;(1 &lt;&lt; 0)
DECL|macro|NEG_SUBTRACT
mdefine_line|#define NEG_SUBTRACT&t;(1 &lt;&lt; 1)
r_static
id|u32
DECL|function|vfp_single_multiply_accumulate
id|vfp_single_multiply_accumulate
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
comma
id|u32
id|negate
comma
r_char
op_star
id|func
)paren
(brace
r_struct
id|vfp_single
id|vsd
comma
id|vsp
comma
id|vsn
comma
id|vsm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|s32
id|v
suffix:semicolon
id|v
op_assign
id|vfp_get_float
c_func
(paren
id|sn
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sn
comma
id|v
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsn.exponent
op_eq
l_int|0
op_logical_and
id|vsn.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_eq
l_int|0
op_logical_and
id|vsm.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_single_multiply
c_func
(paren
op_amp
id|vsp
comma
op_amp
id|vsn
comma
op_amp
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|negate
op_amp
id|NEG_MULTIPLY
)paren
id|vsp.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vsp.sign
)paren
suffix:semicolon
id|v
op_assign
id|vfp_get_float
c_func
(paren
id|sd
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sd
comma
id|v
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|negate
op_amp
id|NEG_SUBTRACT
)paren
id|vsn.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vsn.sign
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|vfp_single_add
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsn
comma
op_amp
id|vsp
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
id|exceptions
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Standard operations&n; */
multiline_comment|/*&n; * sd = sd + (sn * sm)&n; */
DECL|function|vfp_single_fmac
r_static
id|u32
id|vfp_single_fmac
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_multiply_accumulate
c_func
(paren
id|sd
comma
id|sn
comma
id|m
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fmac&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sd - (sn * sm)&n; */
DECL|function|vfp_single_fnmac
r_static
id|u32
id|vfp_single_fnmac
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_multiply_accumulate
c_func
(paren
id|sd
comma
id|sn
comma
id|m
comma
id|fpscr
comma
id|NEG_MULTIPLY
comma
l_string|&quot;fnmac&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -sd + (sn * sm)&n; */
DECL|function|vfp_single_fmsc
r_static
id|u32
id|vfp_single_fmsc
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_multiply_accumulate
c_func
(paren
id|sd
comma
id|sn
comma
id|m
comma
id|fpscr
comma
id|NEG_SUBTRACT
comma
l_string|&quot;fmsc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -sd - (sn * sm)&n; */
DECL|function|vfp_single_fnmsc
r_static
id|u32
id|vfp_single_fnmsc
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_return
id|vfp_single_multiply_accumulate
c_func
(paren
id|sd
comma
id|sn
comma
id|m
comma
id|fpscr
comma
id|NEG_SUBTRACT
op_or
id|NEG_MULTIPLY
comma
l_string|&quot;fnmsc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn * sm&n; */
DECL|function|vfp_single_fmul
r_static
id|u32
id|vfp_single_fmul
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsd
comma
id|vsn
comma
id|vsm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|s32
id|n
op_assign
id|vfp_get_float
c_func
(paren
id|sn
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sn
comma
id|n
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsn.exponent
op_eq
l_int|0
op_logical_and
id|vsn.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_eq
l_int|0
op_logical_and
id|vsm.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_single_multiply
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsn
comma
op_amp
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fmul&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = -(sn * sm)&n; */
DECL|function|vfp_single_fnmul
r_static
id|u32
id|vfp_single_fnmul
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsd
comma
id|vsn
comma
id|vsm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|s32
id|n
op_assign
id|vfp_get_float
c_func
(paren
id|sn
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sn
comma
id|n
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsn.exponent
op_eq
l_int|0
op_logical_and
id|vsn.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_eq
l_int|0
op_logical_and
id|vsm.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_single_multiply
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsn
comma
op_amp
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
id|vsd.sign
op_assign
id|vfp_sign_negate
c_func
(paren
id|vsd.sign
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fnmul&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn + sm&n; */
DECL|function|vfp_single_fadd
r_static
id|u32
id|vfp_single_fadd
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsd
comma
id|vsn
comma
id|vsm
suffix:semicolon
id|u32
id|exceptions
suffix:semicolon
id|s32
id|n
op_assign
id|vfp_get_float
c_func
(paren
id|sn
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sn
comma
id|n
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unpack and normalise denormals.&n;&t; */
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsn.exponent
op_eq
l_int|0
op_logical_and
id|vsn.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vsm.exponent
op_eq
l_int|0
op_logical_and
id|vsm.significand
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
id|exceptions
op_assign
id|vfp_single_add
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsn
comma
op_amp
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
id|exceptions
comma
l_string|&quot;fadd&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn - sm&n; */
DECL|function|vfp_single_fsub
r_static
id|u32
id|vfp_single_fsub
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
multiline_comment|/*&n;&t; * Subtraction is addition with one sign inverted.&n;&t; */
r_return
id|vfp_single_fadd
c_func
(paren
id|sd
comma
id|sn
comma
id|vfp_single_packed_negate
c_func
(paren
id|m
)paren
comma
id|fpscr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sd = sn / sm&n; */
DECL|function|vfp_single_fdiv
r_static
id|u32
id|vfp_single_fdiv
c_func
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
(brace
r_struct
id|vfp_single
id|vsd
comma
id|vsn
comma
id|vsm
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
id|s32
id|n
op_assign
id|vfp_get_float
c_func
(paren
id|sn
)paren
suffix:semicolon
r_int
id|tm
comma
id|tn
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: s%u = %08x&bslash;n&quot;
comma
id|sn
comma
id|n
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsn
comma
id|n
)paren
suffix:semicolon
id|vfp_single_unpack
c_func
(paren
op_amp
id|vsm
comma
id|m
)paren
suffix:semicolon
id|vsd.sign
op_assign
id|vsn.sign
op_xor
id|vsm.sign
suffix:semicolon
id|tn
op_assign
id|vfp_single_type
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
id|tm
op_assign
id|vfp_single_type
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is n a NAN?&n;&t; */
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_NAN
)paren
r_goto
id|vsn_nan
suffix:semicolon
multiline_comment|/*&n;&t; * Is m a NAN?&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_NAN
)paren
r_goto
id|vsm_nan
suffix:semicolon
multiline_comment|/*&n;&t; * If n and m are infinity, the result is invalid&n;&t; * If n and m are zero, the result is invalid&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|tn
op_amp
(paren
id|VFP_INFINITY
op_or
id|VFP_ZERO
)paren
)paren
r_goto
id|invalid
suffix:semicolon
multiline_comment|/*&n;&t; * If n is infinity, the result is infinity&n;&t; */
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_INFINITY
)paren
r_goto
id|infinity
suffix:semicolon
multiline_comment|/*&n;&t; * If m is zero, raise div0 exception&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_ZERO
)paren
r_goto
id|divzero
suffix:semicolon
multiline_comment|/*&n;&t; * If m is infinity, or n is zero, the result is zero&n;&t; */
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_INFINITY
op_logical_or
id|tn
op_amp
id|VFP_ZERO
)paren
r_goto
id|zero
suffix:semicolon
r_if
c_cond
(paren
id|tn
op_amp
id|VFP_DENORMAL
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm
op_amp
id|VFP_DENORMAL
)paren
id|vfp_single_normalise_denormal
c_func
(paren
op_amp
id|vsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we have two numbers, we can perform division.&n;&t; */
id|vsd.exponent
op_assign
id|vsn.exponent
op_minus
id|vsm.exponent
op_plus
l_int|127
op_minus
l_int|1
suffix:semicolon
id|vsm.significand
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vsm.significand
op_le
(paren
l_int|2
op_star
id|vsn.significand
)paren
)paren
(brace
id|vsn.significand
op_rshift_assign
l_int|1
suffix:semicolon
id|vsd.exponent
op_increment
suffix:semicolon
)brace
id|vsd.significand
op_assign
(paren
(paren
id|u64
)paren
id|vsn.significand
op_lshift
l_int|32
)paren
op_div
id|vsm.significand
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vsd.significand
op_amp
l_int|0x3f
)paren
op_eq
l_int|0
)paren
id|vsd.significand
op_or_assign
(paren
(paren
id|u64
)paren
id|vsm.significand
op_star
id|vsd.significand
op_ne
(paren
id|u64
)paren
id|vsn.significand
op_lshift
l_int|32
)paren
suffix:semicolon
r_return
id|vfp_single_normaliseround
c_func
(paren
id|sd
comma
op_amp
id|vsd
comma
id|fpscr
comma
l_int|0
comma
l_string|&quot;fdiv&quot;
)paren
suffix:semicolon
id|vsn_nan
suffix:colon
id|exceptions
op_assign
id|vfp_propagate_nan
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsn
comma
op_amp
id|vsm
comma
id|fpscr
)paren
suffix:semicolon
id|pack
suffix:colon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_pack
c_func
(paren
op_amp
id|vsd
)paren
)paren
suffix:semicolon
r_return
id|exceptions
suffix:semicolon
id|vsm_nan
suffix:colon
id|exceptions
op_assign
id|vfp_propagate_nan
c_func
(paren
op_amp
id|vsd
comma
op_amp
id|vsm
comma
op_amp
id|vsn
comma
id|fpscr
)paren
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|zero
suffix:colon
id|vsd.exponent
op_assign
l_int|0
suffix:semicolon
id|vsd.significand
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|divzero
suffix:colon
id|exceptions
op_assign
id|FPSCR_DZC
suffix:semicolon
id|infinity
suffix:colon
id|vsd.exponent
op_assign
l_int|255
suffix:semicolon
id|vsd.significand
op_assign
l_int|0
suffix:semicolon
r_goto
id|pack
suffix:semicolon
id|invalid
suffix:colon
id|vfp_put_float
c_func
(paren
id|sd
comma
id|vfp_single_pack
c_func
(paren
op_amp
id|vfp_single_default_qnan
)paren
)paren
suffix:semicolon
r_return
id|FPSCR_IOC
suffix:semicolon
)brace
DECL|variable|fop_fns
r_static
id|u32
(paren
op_star
r_const
id|fop_fns
(braket
l_int|16
)braket
)paren
(paren
r_int
id|sd
comma
r_int
id|sn
comma
id|s32
id|m
comma
id|u32
id|fpscr
)paren
op_assign
(brace
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMAC
)paren
)braket
op_assign
id|vfp_single_fmac
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMAC
)paren
)braket
op_assign
id|vfp_single_fnmac
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMSC
)paren
)braket
op_assign
id|vfp_single_fmsc
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMSC
)paren
)braket
op_assign
id|vfp_single_fnmsc
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FMUL
)paren
)braket
op_assign
id|vfp_single_fmul
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FNMUL
)paren
)braket
op_assign
id|vfp_single_fnmul
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FADD
)paren
)braket
op_assign
id|vfp_single_fadd
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FSUB
)paren
)braket
op_assign
id|vfp_single_fsub
comma
(braket
id|FOP_TO_IDX
c_func
(paren
id|FOP_FDIV
)paren
)braket
op_assign
id|vfp_single_fdiv
comma
)brace
suffix:semicolon
DECL|macro|FREG_BANK
mdefine_line|#define FREG_BANK(x)&t;((x) &amp; 0x18)
DECL|macro|FREG_IDX
mdefine_line|#define FREG_IDX(x)&t;((x) &amp; 7)
DECL|function|vfp_single_cpdo
id|u32
id|vfp_single_cpdo
c_func
(paren
id|u32
id|inst
comma
id|u32
id|fpscr
)paren
(brace
id|u32
id|op
op_assign
id|inst
op_amp
id|FOP_MASK
suffix:semicolon
id|u32
id|exceptions
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|sd
op_assign
id|vfp_get_sd
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|sn
op_assign
id|vfp_get_sn
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|sm
op_assign
id|vfp_get_sm
c_func
(paren
id|inst
)paren
suffix:semicolon
r_int
r_int
id|vecitr
comma
id|veclen
comma
id|vecstride
suffix:semicolon
id|u32
(paren
op_star
id|fop
)paren
(paren
r_int
comma
r_int
comma
id|s32
comma
id|u32
)paren
suffix:semicolon
id|veclen
op_assign
id|fpscr
op_amp
id|FPSCR_LENGTH_MASK
suffix:semicolon
id|vecstride
op_assign
l_int|1
op_plus
(paren
(paren
id|fpscr
op_amp
id|FPSCR_STRIDE_MASK
)paren
op_eq
id|FPSCR_STRIDE_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If destination bank is zero, vector length is always &squot;1&squot;.&n;&t; * ARM DDI0100F C5.1.3, C5.3.2.&n;&t; */
r_if
c_cond
(paren
id|FREG_BANK
c_func
(paren
id|sd
)paren
op_eq
l_int|0
)paren
id|veclen
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: vecstride=%u veclen=%u&bslash;n&quot;
comma
id|vecstride
comma
(paren
id|veclen
op_rshift
id|FPSCR_LENGTH_BIT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|fop
op_assign
(paren
id|op
op_eq
id|FOP_EXT
)paren
ques
c_cond
id|fop_extfns
(braket
id|sn
)braket
suffix:colon
id|fop_fns
(braket
id|FOP_TO_IDX
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fop
)paren
r_goto
id|invalid
suffix:semicolon
r_for
c_loop
(paren
id|vecitr
op_assign
l_int|0
suffix:semicolon
id|vecitr
op_le
id|veclen
suffix:semicolon
id|vecitr
op_add_assign
l_int|1
op_lshift
id|FPSCR_LENGTH_BIT
)paren
(brace
id|s32
id|m
op_assign
id|vfp_get_float
c_func
(paren
id|sm
)paren
suffix:semicolon
id|u32
id|except
suffix:semicolon
r_if
c_cond
(paren
id|op
op_eq
id|FOP_EXT
)paren
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d (s%u) = op[%u] (s%u=%08x)&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|sd
comma
id|sn
comma
id|sm
comma
id|m
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d (s%u) = (s%u) op[%u] (s%u=%08x)&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|sd
comma
id|sn
comma
id|FOP_TO_IDX
c_func
(paren
id|op
)paren
comma
id|sm
comma
id|m
)paren
suffix:semicolon
id|except
op_assign
id|fop
c_func
(paren
id|sd
comma
id|sn
comma
id|m
comma
id|fpscr
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;VFP: itr%d: exceptions=%08x&bslash;n&quot;
comma
id|vecitr
op_rshift
id|FPSCR_LENGTH_BIT
comma
id|except
)paren
suffix:semicolon
id|exceptions
op_or_assign
id|except
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This ensures that comparisons only operate on scalars;&n;&t;&t; * comparisons always return with one FPSCR status bit set.&n;&t;&t; */
r_if
c_cond
(paren
id|except
op_amp
(paren
id|FPSCR_N
op_or
id|FPSCR_Z
op_or
id|FPSCR_C
op_or
id|FPSCR_V
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * CHECK: It appears to be undefined whether we stop when&n;&t;&t; * we encounter an exception.  We continue.&n;&t;&t; */
id|sd
op_assign
id|FREG_BANK
c_func
(paren
id|sd
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|sd
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|sn
op_assign
id|FREG_BANK
c_func
(paren
id|sn
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|sn
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FREG_BANK
c_func
(paren
id|sm
)paren
op_ne
l_int|0
)paren
id|sm
op_assign
id|FREG_BANK
c_func
(paren
id|sm
)paren
op_plus
(paren
(paren
id|FREG_IDX
c_func
(paren
id|sm
)paren
op_plus
id|vecstride
)paren
op_amp
l_int|7
)paren
suffix:semicolon
)brace
r_return
id|exceptions
suffix:semicolon
id|invalid
suffix:colon
r_return
(paren
id|u32
)paren
op_minus
l_int|1
suffix:semicolon
)brace
eof
