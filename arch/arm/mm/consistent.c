multiline_comment|/*&n; *  linux/arch/arm/mm/consistent.c&n; *&n; *  Copyright (C) 2000-2004 Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  DMA uncached mapping support.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
DECL|macro|CONSISTENT_BASE
mdefine_line|#define CONSISTENT_BASE&t;(0xffc00000)
DECL|macro|CONSISTENT_END
mdefine_line|#define CONSISTENT_END&t;(0xffe00000)
DECL|macro|CONSISTENT_OFFSET
mdefine_line|#define CONSISTENT_OFFSET(x)&t;(((unsigned long)(x) - CONSISTENT_BASE) &gt;&gt; PAGE_SHIFT)
multiline_comment|/*&n; * This is the page table (2MB) covering uncached, DMA consistent allocations&n; */
DECL|variable|consistent_pte
r_static
id|pte_t
op_star
id|consistent_pte
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|consistent_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * VM region handling support.&n; *&n; * This should become something generic, handling VM region allocations for&n; * vmalloc and similar (ioremap, module space, etc).&n; *&n; * I envisage vmalloc()&squot;s supporting vm_struct becoming:&n; *&n; *  struct vm_struct {&n; *    struct vm_region&t;region;&n; *    unsigned long&t;flags;&n; *    struct page&t;**pages;&n; *    unsigned int&t;nr_pages;&n; *    unsigned long&t;phys_addr;&n; *  };&n; *&n; * get_vm_area() would then call vm_region_alloc with an appropriate&n; * struct vm_region head (eg):&n; *&n; *  struct vm_region vmalloc_head = {&n; *&t;.vm_list&t;= LIST_HEAD_INIT(vmalloc_head.vm_list),&n; *&t;.vm_start&t;= VMALLOC_START,&n; *&t;.vm_end&t;&t;= VMALLOC_END,&n; *  };&n; *&n; * However, vmalloc_head.vm_start is variable (typically, it is dependent on&n; * the amount of RAM found at boot time.)  I would imagine that get_vm_area()&n; * would have to initialise this each time prior to calling vm_region_alloc().&n; */
DECL|struct|vm_region
r_struct
id|vm_region
(brace
DECL|member|vm_list
r_struct
id|list_head
id|vm_list
suffix:semicolon
DECL|member|vm_start
r_int
r_int
id|vm_start
suffix:semicolon
DECL|member|vm_end
r_int
r_int
id|vm_end
suffix:semicolon
DECL|member|vm_pages
r_struct
id|page
op_star
id|vm_pages
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|consistent_head
r_static
r_struct
id|vm_region
id|consistent_head
op_assign
(brace
dot
id|vm_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|consistent_head.vm_list
)paren
comma
dot
id|vm_start
op_assign
id|CONSISTENT_BASE
comma
dot
id|vm_end
op_assign
id|CONSISTENT_END
comma
)brace
suffix:semicolon
r_static
r_struct
id|vm_region
op_star
DECL|function|vm_region_alloc
id|vm_region_alloc
c_func
(paren
r_struct
id|vm_region
op_star
id|head
comma
r_int
id|size
comma
r_int
id|gfp
)paren
(brace
r_int
r_int
id|addr
op_assign
id|head-&gt;vm_start
comma
id|end
op_assign
id|head-&gt;vm_end
op_minus
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|vm_region
op_star
id|c
comma
op_star
r_new
suffix:semicolon
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_region
)paren
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|c
comma
op_amp
id|head-&gt;vm_list
comma
id|vm_list
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
OL
id|addr
)paren
r_goto
id|nospc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_le
id|c-&gt;vm_start
)paren
r_goto
id|found
suffix:semicolon
id|addr
op_assign
id|c-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|end
)paren
r_goto
id|nospc
suffix:semicolon
)brace
id|found
suffix:colon
multiline_comment|/*&n;&t; * Insert this entry _before_ the one we found.&n;&t; */
id|list_add_tail
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|vm_list
comma
op_amp
id|c-&gt;vm_list
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|vm_start
op_assign
id|addr
suffix:semicolon
r_new
op_member_access_from_pointer
id|vm_end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
id|nospc
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|vm_region_find
r_static
r_struct
id|vm_region
op_star
id|vm_region_find
c_func
(paren
r_struct
id|vm_region
op_star
id|head
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_region
op_star
id|c
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|c
comma
op_amp
id|head-&gt;vm_list
comma
id|vm_list
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;vm_start
op_eq
id|addr
)paren
r_goto
id|out
suffix:semicolon
)brace
id|c
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
id|c
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HUGETLB_PAGE
macro_line|#error ARM Coherent DMA allocator does not (yet) support huge TLB
macro_line|#endif
r_static
r_void
op_star
DECL|function|__dma_alloc
id|__dma_alloc
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|handle
comma
r_int
id|gfp
comma
id|pgprot_t
id|prot
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|vm_region
op_star
id|c
suffix:semicolon
r_int
r_int
id|order
suffix:semicolon
id|u64
id|mask
op_assign
id|ISA_DMA_THRESHOLD
comma
id|limit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|consistent_pte
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: not initialised&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
)paren
(brace
id|mask
op_assign
id|dev-&gt;coherent_dma_mask
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Sanity check the DMA mask - it must be non-zero, and&n;&t;&t; * must be able to be satisfied by a DMA allocation.&n;&t;&t; */
r_if
c_cond
(paren
id|mask
op_eq
l_int|0
)paren
(brace
id|dev_warn
c_func
(paren
id|dev
comma
l_string|&quot;coherent DMA mask is unset&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|no_page
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_complement
id|mask
)paren
op_amp
id|ISA_DMA_THRESHOLD
)paren
(brace
id|dev_warn
c_func
(paren
id|dev
comma
l_string|&quot;coherent DMA mask %#llx is smaller &quot;
l_string|&quot;than system GFP_DMA mask %#llx&bslash;n&quot;
comma
id|mask
comma
(paren
r_int
r_int
r_int
)paren
id|ISA_DMA_THRESHOLD
)paren
suffix:semicolon
r_goto
id|no_page
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Sanity check the allocation size.&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|limit
op_assign
(paren
id|mask
op_plus
l_int|1
)paren
op_amp
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|limit
op_logical_and
id|size
op_ge
id|limit
)paren
op_logical_or
id|size
op_ge
(paren
id|CONSISTENT_END
op_minus
id|CONSISTENT_BASE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;coherent allocation too big &quot;
l_string|&quot;(requested %#x mask %#llx)&bslash;n&quot;
comma
id|size
comma
id|mask
)paren
suffix:semicolon
r_goto
id|no_page
suffix:semicolon
)brace
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_ne
l_int|0xffffffff
)paren
id|gfp
op_or_assign
id|GFP_DMA
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_page
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate any data that might be lurking in the&n;&t; * kernel direct-mapped region for device DMA.&n;&t; */
(brace
r_int
r_int
id|kaddr
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|dmac_flush_range
c_func
(paren
id|kaddr
comma
id|kaddr
op_plus
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a virtual address in the consistent mapping region.&n;&t; */
id|c
op_assign
id|vm_region_alloc
c_func
(paren
op_amp
id|consistent_head
comma
id|size
comma
id|gfp
op_amp
op_complement
(paren
id|__GFP_DMA
op_or
id|__GFP_HIGHMEM
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|pte_t
op_star
id|pte
op_assign
id|consistent_pte
op_plus
id|CONSISTENT_OFFSET
c_func
(paren
id|c-&gt;vm_start
)paren
suffix:semicolon
r_struct
id|page
op_star
id|end
op_assign
id|page
op_plus
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|c-&gt;vm_pages
op_assign
id|page
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the &quot;dma handle&quot;&n;&t;&t; */
op_star
id|handle
op_assign
id|page_to_dma
c_func
(paren
id|dev
comma
id|page
)paren
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|pte_none
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * x86 does not mark the pages reserved...&n;&t;&t;&t; */
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pte
comma
id|mk_pte
c_func
(paren
id|page
comma
id|prot
)paren
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
op_sub_assign
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the otherwise unused pages.&n;&t;&t; */
r_while
c_loop
(paren
id|page
OL
id|end
)paren
(brace
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|c-&gt;vm_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
)paren
id|__free_pages
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
id|no_page
suffix:colon
op_star
id|handle
op_assign
op_complement
l_int|0
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate DMA-coherent memory space and return both the kernel remapped&n; * virtual and bus address for that space.&n; */
r_void
op_star
DECL|function|dma_alloc_coherent
id|dma_alloc_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|handle
comma
r_int
id|gfp
)paren
(brace
r_return
id|__dma_alloc
c_func
(paren
id|dev
comma
id|size
comma
id|handle
comma
id|gfp
comma
id|pgprot_noncached
c_func
(paren
id|pgprot_kernel
)paren
)paren
suffix:semicolon
)brace
DECL|variable|dma_alloc_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|dma_alloc_coherent
)paren
suffix:semicolon
multiline_comment|/*&n; * Allocate a writecombining region, in much the same way as&n; * dma_alloc_coherent above.&n; */
r_void
op_star
DECL|function|dma_alloc_writecombine
id|dma_alloc_writecombine
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|handle
comma
r_int
id|gfp
)paren
(brace
r_return
id|__dma_alloc
c_func
(paren
id|dev
comma
id|size
comma
id|handle
comma
id|gfp
comma
id|pgprot_writecombine
c_func
(paren
id|pgprot_kernel
)paren
)paren
suffix:semicolon
)brace
DECL|variable|dma_alloc_writecombine
id|EXPORT_SYMBOL
c_func
(paren
id|dma_alloc_writecombine
)paren
suffix:semicolon
DECL|function|dma_mmap
r_static
r_int
id|dma_mmap
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|flags
comma
id|user_size
comma
id|kern_size
suffix:semicolon
r_struct
id|vm_region
op_star
id|c
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|user_size
op_assign
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|vm_region_find
c_func
(paren
op_amp
id|consistent_head
comma
(paren
r_int
r_int
)paren
id|cpu_addr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_int
r_int
id|off
op_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|kern_size
op_assign
(paren
id|c-&gt;vm_end
op_minus
id|c-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|off
OL
id|kern_size
op_logical_and
id|user_size
op_le
(paren
id|kern_size
op_minus
id|off
)paren
)paren
(brace
id|vma-&gt;vm_flags
op_or_assign
id|VM_RESERVED
suffix:semicolon
id|ret
op_assign
id|remap_pfn_range
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|page_to_pfn
c_func
(paren
id|c-&gt;vm_pages
)paren
op_plus
id|off
comma
id|user_size
op_lshift
id|PAGE_SHIFT
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dma_mmap_coherent
r_int
id|dma_mmap_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
)paren
(brace
id|vma-&gt;vm_page_prot
op_assign
id|pgprot_noncached
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_return
id|dma_mmap
c_func
(paren
id|dev
comma
id|vma
comma
id|cpu_addr
comma
id|dma_addr
comma
id|size
)paren
suffix:semicolon
)brace
DECL|variable|dma_mmap_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|dma_mmap_coherent
)paren
suffix:semicolon
DECL|function|dma_mmap_writecombine
r_int
id|dma_mmap_writecombine
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
)paren
(brace
id|vma-&gt;vm_page_prot
op_assign
id|pgprot_writecombine
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_return
id|dma_mmap
c_func
(paren
id|dev
comma
id|vma
comma
id|cpu_addr
comma
id|dma_addr
comma
id|size
)paren
suffix:semicolon
)brace
DECL|variable|dma_mmap_writecombine
id|EXPORT_SYMBOL
c_func
(paren
id|dma_mmap_writecombine
)paren
suffix:semicolon
multiline_comment|/*&n; * free a page as defined by the above mapping.&n; */
DECL|function|dma_free_coherent
r_void
id|dma_free_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|handle
)paren
(brace
r_struct
id|vm_region
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
comma
id|addr
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|vm_region_find
c_func
(paren
op_amp
id|consistent_head
comma
(paren
r_int
r_int
)paren
id|cpu_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_goto
id|no_area
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c-&gt;vm_end
op_minus
id|c-&gt;vm_start
)paren
op_ne
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: freeing wrong coherent size (%ld != %d)&bslash;n&quot;
comma
id|__func__
comma
id|c-&gt;vm_end
op_minus
id|c-&gt;vm_start
comma
id|size
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
id|size
op_assign
id|c-&gt;vm_end
op_minus
id|c-&gt;vm_start
suffix:semicolon
)brace
id|ptep
op_assign
id|consistent_pte
op_plus
id|CONSISTENT_OFFSET
c_func
(paren
id|c-&gt;vm_start
)paren
suffix:semicolon
id|addr
op_assign
id|c-&gt;vm_start
suffix:semicolon
r_do
(brace
id|pte_t
id|pte
op_assign
id|ptep_get_and_clear
c_func
(paren
op_amp
id|init_mm
comma
id|addr
comma
id|ptep
)paren
suffix:semicolon
r_int
r_int
id|pfn
suffix:semicolon
id|ptep
op_increment
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_none
c_func
(paren
id|pte
)paren
op_logical_and
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|pfn
op_assign
id|pte_pfn
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * x86 does not mark the pages reserved...&n;&t;&t;&t;&t; */
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: bad page in kernel page table&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
op_sub_assign
id|PAGE_SIZE
)paren
suffix:semicolon
id|flush_tlb_kernel_range
c_func
(paren
id|c-&gt;vm_start
comma
id|c-&gt;vm_end
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|c-&gt;vm_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
suffix:semicolon
id|no_area
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|consistent_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: trying to free invalid coherent area: %p&bslash;n&quot;
comma
id|__func__
comma
id|cpu_addr
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|dma_free_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|dma_free_coherent
)paren
suffix:semicolon
multiline_comment|/*&n; * Initialise the consistent memory allocation.&n; */
DECL|function|consistent_init
r_static
r_int
id|__init
id|consistent_init
c_func
(paren
r_void
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|init_mm.page_table_lock
)paren
suffix:semicolon
r_do
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
op_amp
id|init_mm
comma
id|CONSISTENT_BASE
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_alloc
c_func
(paren
op_amp
id|init_mm
comma
id|pgd
comma
id|CONSISTENT_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no pmd tables&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|WARN_ON
c_func
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pte
op_assign
id|pte_alloc_kernel
c_func
(paren
op_amp
id|init_mm
comma
id|pmd
comma
id|CONSISTENT_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no pte tables&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|consistent_pte
op_assign
id|pte
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|init_mm.page_table_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|consistent_init
id|core_initcall
c_func
(paren
id|consistent_init
)paren
suffix:semicolon
multiline_comment|/*&n; * Make an area consistent for devices.&n; */
DECL|function|consistent_sync
r_void
id|consistent_sync
c_func
(paren
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|vaddr
suffix:semicolon
r_int
r_int
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|direction
)paren
(brace
r_case
id|DMA_FROM_DEVICE
suffix:colon
multiline_comment|/* invalidate only */
id|dmac_inv_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_TO_DEVICE
suffix:colon
multiline_comment|/* writeback only */
id|dmac_clean_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_BIDIRECTIONAL
suffix:colon
multiline_comment|/* writeback and invalidate */
id|dmac_flush_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|consistent_sync
id|EXPORT_SYMBOL
c_func
(paren
id|consistent_sync
)paren
suffix:semicolon
eof
