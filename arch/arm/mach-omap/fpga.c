multiline_comment|/*&n; * linux/arch/arm/mach-omap/fpga.c&n; *&n; * Interrupt handler for OMAP-1510 FPGA&n; *&n; * Copyright (C) 2001 RidgeRun, Inc.&n; * Author: Greg Lonnon &lt;glonnon@ridgerun.com&gt;&n; *&n; * Copyright (C) 2002 MontaVista Software, Inc.&n; *&n; * Separated FPGA interrupts from innovator1510.c and cleaned up for 2.6&n; * Copyright (C) 2004 Nokia Corporation by Tony Lindrgen &lt;tony@atomide.com&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/arch/fpga.h&gt;
macro_line|#include &lt;asm/arch/gpio.h&gt;
DECL|function|fpga_read
r_int
r_char
id|fpga_read
c_func
(paren
r_int
id|reg
)paren
(brace
r_return
id|__raw_readb
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
DECL|function|fpga_write
r_void
id|fpga_write
c_func
(paren
r_int
r_char
id|val
comma
r_int
id|reg
)paren
(brace
id|__raw_writeb
c_func
(paren
id|val
comma
id|reg
)paren
suffix:semicolon
)brace
DECL|function|fpga_mask_irq
r_static
r_void
id|fpga_mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|irq
op_sub_assign
id|IH_FPGA_BASE
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|8
)paren
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_LO
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|irq
)paren
)paren
comma
id|OMAP1510P1_FPGA_IMR_LO
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_HI
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
id|irq
op_minus
l_int|8
)paren
)paren
)paren
comma
id|OMAP1510P1_FPGA_IMR_HI
)paren
suffix:semicolon
r_else
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|INNOVATOR_FPGA_IMR2
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
id|irq
op_minus
l_int|16
)paren
)paren
)paren
comma
id|INNOVATOR_FPGA_IMR2
)paren
suffix:semicolon
)brace
DECL|function|get_fpga_unmasked_irqs
r_static
r_inline
id|u32
id|get_fpga_unmasked_irqs
c_func
(paren
r_void
)paren
(brace
r_return
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_ISR_LO
)paren
op_amp
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_LO
)paren
)paren
)paren
op_or
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_ISR_HI
)paren
op_amp
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_HI
)paren
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|__raw_readb
c_func
(paren
id|INNOVATOR_FPGA_ISR2
)paren
op_amp
id|__raw_readb
c_func
(paren
id|INNOVATOR_FPGA_IMR2
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|function|fpga_ack_irq
r_static
r_void
id|fpga_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* Don&squot;t need to explicitly ACK FPGA interrupts */
)brace
DECL|function|fpga_unmask_irq
r_static
r_void
id|fpga_unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|irq
op_sub_assign
id|IH_FPGA_BASE
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|8
)paren
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_LO
)paren
op_or
(paren
l_int|1
op_lshift
id|irq
)paren
)paren
comma
id|OMAP1510P1_FPGA_IMR_LO
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|OMAP1510P1_FPGA_IMR_HI
)paren
op_or
(paren
l_int|1
op_lshift
(paren
id|irq
op_minus
l_int|8
)paren
)paren
)paren
comma
id|OMAP1510P1_FPGA_IMR_HI
)paren
suffix:semicolon
r_else
id|__raw_writeb
c_func
(paren
(paren
id|__raw_readb
c_func
(paren
id|INNOVATOR_FPGA_IMR2
)paren
op_or
(paren
l_int|1
op_lshift
(paren
id|irq
op_minus
l_int|16
)paren
)paren
)paren
comma
id|INNOVATOR_FPGA_IMR2
)paren
suffix:semicolon
)brace
DECL|function|fpga_mask_ack_irq
r_static
r_void
id|fpga_mask_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|fpga_mask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|fpga_ack_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|innovator_fpga_IRQ_demux
r_void
id|innovator_fpga_IRQ_demux
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqdesc
op_star
id|desc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqdesc
op_star
id|d
suffix:semicolon
id|u32
id|stat
suffix:semicolon
r_int
id|fpga_irq
suffix:semicolon
multiline_comment|/*&n;&t; * Acknowledge the parent IRQ.&n;&t; */
id|desc-&gt;chip
op_member_access_from_pointer
id|ack
c_func
(paren
id|irq
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|stat
op_assign
id|get_fpga_unmasked_irqs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
(brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|fpga_irq
op_assign
id|IH_FPGA_BASE
suffix:semicolon
(paren
id|fpga_irq
OL
(paren
id|IH_FPGA_BASE
op_plus
id|NR_FPGA_IRQS
)paren
)paren
op_logical_and
id|stat
suffix:semicolon
id|fpga_irq
op_increment
comma
id|stat
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
l_int|1
)paren
(brace
id|d
op_assign
id|irq_desc
op_plus
id|fpga_irq
suffix:semicolon
id|d
op_member_access_from_pointer
id|handle
c_func
(paren
id|fpga_irq
comma
id|d
comma
id|regs
)paren
suffix:semicolon
id|desc-&gt;chip
op_member_access_from_pointer
id|unmask
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|variable|omap_fpga_irq_ack
r_static
r_struct
id|irqchip
id|omap_fpga_irq_ack
op_assign
(brace
dot
id|ack
op_assign
id|fpga_mask_ack_irq
comma
dot
id|mask
op_assign
id|fpga_mask_irq
comma
dot
id|unmask
op_assign
id|fpga_unmask_irq
comma
)brace
suffix:semicolon
DECL|variable|omap_fpga_irq
r_static
r_struct
id|irqchip
id|omap_fpga_irq
op_assign
(brace
dot
id|ack
op_assign
id|fpga_ack_irq
comma
dot
id|mask
op_assign
id|fpga_mask_irq
comma
dot
id|unmask
op_assign
id|fpga_unmask_irq
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * All of the FPGA interrupt request inputs except for the touchscreen are&n; * edge-sensitive; the touchscreen is level-sensitive.  The edge-sensitive&n; * interrupts are acknowledged as a side-effect of reading the interrupt&n; * status register from the FPGA.  The edge-sensitive interrupt inputs&n; * cause a problem with level interrupt requests, such as Ethernet.  The&n; * problem occurs when a level interrupt request is asserted while its&n; * interrupt input is masked in the FPGA, which results in a missed&n; * interrupt.&n; *&n; * In an attempt to workaround the problem with missed interrupts, the&n; * mask_ack routine for all of the FPGA interrupts has been changed from&n; * fpga_mask_ack_irq() to fpga_ack_irq() so that the specific FPGA interrupt&n; * being serviced is left unmasked.  We can do this because the FPGA cascade&n; * interrupt is installed with the SA_INTERRUPT flag, which leaves all&n; * interrupts masked at the CPU while an FPGA interrupt handler executes.&n; *&n; * Limited testing indicates that this workaround appears to be effective&n; * for the smc9194 Ethernet driver used on the Innovator.  It should work&n; * on other FPGA interrupts as well, but any drivers that explicitly mask&n; * interrupts at the interrupt controller via disable_irq/enable_irq&n; * could pose a problem.&n; */
DECL|function|fpga_init_irq
r_void
id|fpga_init_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|__raw_writeb
c_func
(paren
l_int|0
comma
id|OMAP1510P1_FPGA_IMR_LO
)paren
suffix:semicolon
id|__raw_writeb
c_func
(paren
l_int|0
comma
id|OMAP1510P1_FPGA_IMR_HI
)paren
suffix:semicolon
id|__raw_writeb
c_func
(paren
l_int|0
comma
id|INNOVATOR_FPGA_IMR2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|IH_FPGA_BASE
suffix:semicolon
id|i
OL
(paren
id|IH_FPGA_BASE
op_plus
id|NR_FPGA_IRQS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_FPGA_TS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The touchscreen interrupt is level-sensitive, so&n;&t;&t;&t; * we&squot;ll use the regular mask_ack routine for it.&n;&t;&t;&t; */
id|set_irq_chip
c_func
(paren
id|i
comma
op_amp
id|omap_fpga_irq_ack
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * All FPGA interrupts except the touchscreen are&n;&t;&t;&t; * edge-sensitive, so we won&squot;t mask them.&n;&t;&t;&t; */
id|set_irq_chip
c_func
(paren
id|i
comma
op_amp
id|omap_fpga_irq
)paren
suffix:semicolon
)brace
id|set_irq_handler
c_func
(paren
id|i
comma
id|do_level_IRQ
)paren
suffix:semicolon
id|set_irq_flags
c_func
(paren
id|i
comma
id|IRQF_VALID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The FPGA interrupt line is connected to GPIO13. Claim this pin for&n;&t; * the ARM.&n;&t; *&n;&t; * NOTE: For general GPIO/MPUIO access and interrupts, please see&n;&t; * gpio.[ch]&n;&t; */
id|omap_request_gpio
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|omap_set_gpio_direction
c_func
(paren
l_int|13
comma
l_int|1
)paren
suffix:semicolon
id|omap_set_gpio_edge_ctrl
c_func
(paren
l_int|13
comma
id|OMAP_GPIO_RISING_EDGE
)paren
suffix:semicolon
id|set_irq_chained_handler
c_func
(paren
id|INT_FPGA
comma
id|innovator_fpga_IRQ_demux
)paren
suffix:semicolon
)brace
DECL|variable|fpga_init_irq
id|EXPORT_SYMBOL
c_func
(paren
id|fpga_init_irq
)paren
suffix:semicolon
DECL|variable|fpga_read
id|EXPORT_SYMBOL
c_func
(paren
id|fpga_read
)paren
suffix:semicolon
DECL|variable|fpga_write
id|EXPORT_SYMBOL
c_func
(paren
id|fpga_write
)paren
suffix:semicolon
eof
