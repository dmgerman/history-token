multiline_comment|/*&n; * linux/arch/arm/mach-omap/time.c&n; *&n; * OMAP Timers&n; *&n; * Copyright (C) 2004 Nokia Corporation&n; * Partial timer rewrite and additional VST timer support by&n; * Tony Lindgen &lt;tony@atomide.com&gt; and&n; * Tuukka Tikkanen &lt;tuukka.tikkanen@elektrobit.com&gt;&n; *&n; * MPU timer code based on the older MPU timer code for OMAP&n; * Copyright (C) 2000 RidgeRun, Inc.&n; * Author: Greg Lonnon &lt;glonnon@ridgerun.com&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN&n; * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&n; * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; * You should have received a copy of the  GNU General Public License along&n; * with this program; if not, write  to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/leds.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/mach/time.h&gt;
DECL|variable|omap_timer
r_struct
id|sys_timer
id|omap_timer
suffix:semicolon
macro_line|#ifdef CONFIG_OMAP_MPU_TIMER
multiline_comment|/*&n; * ---------------------------------------------------------------------------&n; * MPU timer&n; * ---------------------------------------------------------------------------&n; */
DECL|macro|OMAP_MPU_TIMER1_BASE
mdefine_line|#define OMAP_MPU_TIMER1_BASE&t;&t;(0xfffec500)
DECL|macro|OMAP_MPU_TIMER2_BASE
mdefine_line|#define OMAP_MPU_TIMER2_BASE&t;&t;(0xfffec600)
DECL|macro|OMAP_MPU_TIMER3_BASE
mdefine_line|#define OMAP_MPU_TIMER3_BASE&t;&t;(0xfffec700)
DECL|macro|OMAP_MPU_TIMER_BASE
mdefine_line|#define OMAP_MPU_TIMER_BASE&t;&t;OMAP_MPU_TIMER1_BASE
DECL|macro|OMAP_MPU_TIMER_OFFSET
mdefine_line|#define OMAP_MPU_TIMER_OFFSET&t;&t;0x100
DECL|macro|MPU_TIMER_FREE
mdefine_line|#define MPU_TIMER_FREE&t;&t;&t;(1 &lt;&lt; 6)
DECL|macro|MPU_TIMER_CLOCK_ENABLE
mdefine_line|#define MPU_TIMER_CLOCK_ENABLE&t;&t;(1 &lt;&lt; 5)
DECL|macro|MPU_TIMER_AR
mdefine_line|#define MPU_TIMER_AR&t;&t;&t;(1 &lt;&lt; 1)
DECL|macro|MPU_TIMER_ST
mdefine_line|#define MPU_TIMER_ST&t;&t;&t;(1 &lt;&lt; 0)
multiline_comment|/* cycles to nsec conversions taken from arch/i386/kernel/timers/timer_tsc.c,&n; * converted to use kHz by Kevin Hilman */
multiline_comment|/* convert from cycles(64bits) =&gt; nanoseconds (64bits)&n; *  basic equation:&n; *&t;&t;ns = cycles / (freq / ns_per_sec)&n; *&t;&t;ns = cycles * (ns_per_sec / freq)&n; *&t;&t;ns = cycles * (10^9 / (cpu_khz * 10^3))&n; *&t;&t;ns = cycles * (10^6 / cpu_khz)&n; *&n; *&t;Then we use scaling math (suggested by george at mvista.com) to get:&n; *&t;&t;ns = cycles * (10^6 * SC / cpu_khz / SC&n; *&t;&t;ns = cycles * cyc2ns_scale / SC&n; *&n; *&t;And since SC is a constant power of two, we can convert the div&n; *  into a shift.&n; *&t;&t;&t;-johnstul at us.ibm.com &quot;math is hard, lets go shopping!&quot;&n; */
DECL|variable|cyc2ns_scale
r_static
r_int
r_int
id|cyc2ns_scale
suffix:semicolon
DECL|macro|CYC2NS_SCALE_FACTOR
mdefine_line|#define CYC2NS_SCALE_FACTOR 10 /* 2^10, carefully chosen */
DECL|function|set_cyc2ns_scale
r_static
r_inline
r_void
id|set_cyc2ns_scale
c_func
(paren
r_int
r_int
id|cpu_khz
)paren
(brace
id|cyc2ns_scale
op_assign
(paren
l_int|1000000
op_lshift
id|CYC2NS_SCALE_FACTOR
)paren
op_div
id|cpu_khz
suffix:semicolon
)brace
DECL|function|cycles_2_ns
r_static
r_inline
r_int
r_int
r_int
id|cycles_2_ns
c_func
(paren
r_int
r_int
r_int
id|cyc
)paren
(brace
r_return
(paren
id|cyc
op_star
id|cyc2ns_scale
)paren
op_rshift
id|CYC2NS_SCALE_FACTOR
suffix:semicolon
)brace
multiline_comment|/*&n; * MPU_TICKS_PER_SEC must be an even number, otherwise machinecycles_to_usecs&n; * will break. On P2, the timer count rate is 6.5 MHz after programming PTV&n; * with 0. This divides the 13MHz input by 2, and is undocumented.&n; */
macro_line|#ifdef CONFIG_MACH_OMAP_PERSEUS2
multiline_comment|/* REVISIT: This ifdef construct should be replaced by a query to clock&n; * framework to see if timer base frequency is 12.0, 13.0 or 19.2 MHz.&n; */
DECL|macro|MPU_TICKS_PER_SEC
mdefine_line|#define MPU_TICKS_PER_SEC&t;&t;(13000000 / 2)
macro_line|#else
DECL|macro|MPU_TICKS_PER_SEC
mdefine_line|#define MPU_TICKS_PER_SEC&t;&t;(12000000 / 2)
macro_line|#endif
DECL|macro|MPU_TIMER_TICK_PERIOD
mdefine_line|#define MPU_TIMER_TICK_PERIOD&t;&t;((MPU_TICKS_PER_SEC / HZ) - 1)
r_typedef
r_struct
(brace
DECL|member|cntl
id|u32
id|cntl
suffix:semicolon
multiline_comment|/* CNTL_TIMER, R/W */
DECL|member|load_tim
id|u32
id|load_tim
suffix:semicolon
multiline_comment|/* LOAD_TIM,   W */
DECL|member|read_tim
id|u32
id|read_tim
suffix:semicolon
multiline_comment|/* READ_TIM,   R */
DECL|typedef|omap_mpu_timer_regs_t
)brace
id|omap_mpu_timer_regs_t
suffix:semicolon
DECL|macro|omap_mpu_timer_base
mdefine_line|#define omap_mpu_timer_base(n)&t;&t;&t;&t;&t;&t;&bslash;&n;((volatile omap_mpu_timer_regs_t*)IO_ADDRESS(OMAP_MPU_TIMER_BASE +&t;&bslash;&n;&t;&t;&t;&t; (n)*OMAP_MPU_TIMER_OFFSET))
DECL|function|omap_mpu_timer_read
r_static
r_inline
r_int
r_int
id|omap_mpu_timer_read
c_func
(paren
r_int
id|nr
)paren
(brace
r_volatile
id|omap_mpu_timer_regs_t
op_star
id|timer
op_assign
id|omap_mpu_timer_base
c_func
(paren
id|nr
)paren
suffix:semicolon
r_return
id|timer-&gt;read_tim
suffix:semicolon
)brace
DECL|function|omap_mpu_timer_start
r_static
r_inline
r_void
id|omap_mpu_timer_start
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|load_val
)paren
(brace
r_volatile
id|omap_mpu_timer_regs_t
op_star
id|timer
op_assign
id|omap_mpu_timer_base
c_func
(paren
id|nr
)paren
suffix:semicolon
id|timer-&gt;cntl
op_assign
id|MPU_TIMER_CLOCK_ENABLE
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|timer-&gt;load_tim
op_assign
id|load_val
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|timer-&gt;cntl
op_assign
(paren
id|MPU_TIMER_CLOCK_ENABLE
op_or
id|MPU_TIMER_AR
op_or
id|MPU_TIMER_ST
)paren
suffix:semicolon
)brace
DECL|function|omap_mpu_timer_ticks_to_usecs
r_int
r_int
id|omap_mpu_timer_ticks_to_usecs
c_func
(paren
r_int
r_int
id|nr_ticks
)paren
(brace
r_int
r_int
r_int
id|nsec
suffix:semicolon
id|nsec
op_assign
id|cycles_2_ns
c_func
(paren
(paren
r_int
r_int
r_int
)paren
id|nr_ticks
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|nsec
op_div
l_int|1000
suffix:semicolon
)brace
multiline_comment|/*&n; * Last processed system timer interrupt&n; */
DECL|variable|omap_mpu_timer_last
r_static
r_int
r_int
id|omap_mpu_timer_last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Returns elapsed usecs since last system timer interrupt&n; */
DECL|function|omap_mpu_timer_gettimeoffset
r_static
r_int
r_int
id|omap_mpu_timer_gettimeoffset
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|now
op_assign
l_int|0
op_minus
id|omap_mpu_timer_read
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|elapsed
op_assign
id|now
op_minus
id|omap_mpu_timer_last
suffix:semicolon
r_return
id|omap_mpu_timer_ticks_to_usecs
c_func
(paren
id|elapsed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Elapsed time between interrupts is calculated using timer0.&n; * Latency during the interrupt is calculated using timer1.&n; * Both timer0 and timer1 are counting at 6MHz (P2 6.5MHz).&n; */
DECL|function|omap_mpu_timer_interrupt
r_static
id|irqreturn_t
id|omap_mpu_timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|now
comma
id|latency
suffix:semicolon
id|write_seqlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|now
op_assign
l_int|0
op_minus
id|omap_mpu_timer_read
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|latency
op_assign
id|MPU_TICKS_PER_SEC
op_div
id|HZ
op_minus
id|omap_mpu_timer_read
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|omap_mpu_timer_last
op_assign
id|now
op_minus
id|latency
suffix:semicolon
id|timer_tick
c_func
(paren
id|regs
)paren
suffix:semicolon
id|write_sequnlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|omap_mpu_timer_irq
r_static
r_struct
id|irqaction
id|omap_mpu_timer_irq
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;mpu timer&quot;
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|handler
op_assign
id|omap_mpu_timer_interrupt
)brace
suffix:semicolon
DECL|variable|omap_mpu_timer1_overflows
r_static
r_int
r_int
id|omap_mpu_timer1_overflows
suffix:semicolon
DECL|function|omap_mpu_timer1_interrupt
r_static
id|irqreturn_t
id|omap_mpu_timer1_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|omap_mpu_timer1_overflows
op_increment
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|omap_mpu_timer1_irq
r_static
r_struct
id|irqaction
id|omap_mpu_timer1_irq
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;mpu timer1 overflow&quot;
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|handler
op_assign
id|omap_mpu_timer1_interrupt
)brace
suffix:semicolon
DECL|function|omap_init_mpu_timer
r_static
id|__init
r_void
id|omap_init_mpu_timer
c_func
(paren
r_void
)paren
(brace
id|set_cyc2ns_scale
c_func
(paren
id|MPU_TICKS_PER_SEC
op_div
l_int|1000
)paren
suffix:semicolon
id|omap_timer.offset
op_assign
id|omap_mpu_timer_gettimeoffset
suffix:semicolon
id|setup_irq
c_func
(paren
id|INT_TIMER1
comma
op_amp
id|omap_mpu_timer1_irq
)paren
suffix:semicolon
id|setup_irq
c_func
(paren
id|INT_TIMER2
comma
op_amp
id|omap_mpu_timer_irq
)paren
suffix:semicolon
id|omap_mpu_timer_start
c_func
(paren
l_int|0
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|omap_mpu_timer_start
c_func
(paren
l_int|1
comma
id|MPU_TIMER_TICK_PERIOD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Scheduler clock - returns current time in nanosec units.&n; */
DECL|function|sched_clock
r_int
r_int
r_int
id|sched_clock
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
op_assign
l_int|0
op_minus
id|omap_mpu_timer_read
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
r_int
r_int
id|ticks64
suffix:semicolon
id|ticks64
op_assign
id|omap_mpu_timer1_overflows
suffix:semicolon
id|ticks64
op_lshift_assign
l_int|32
suffix:semicolon
id|ticks64
op_or_assign
id|ticks
suffix:semicolon
r_return
id|cycles_2_ns
c_func
(paren
id|ticks64
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_OMAP_MPU_TIMER */
macro_line|#ifdef CONFIG_OMAP_32K_TIMER
macro_line|#ifdef CONFIG_ARCH_OMAP1510
macro_line|#error OMAP 32KHz timer does not currently work on 1510!
macro_line|#endif
multiline_comment|/*&n; * ---------------------------------------------------------------------------&n; * 32KHz OS timer&n; *&n; * This currently works only on 16xx, as 1510 does not have the continuous&n; * 32KHz synchronous timer. The 32KHz synchronous timer is used to keep track&n; * of time in addition to the 32KHz OS timer. Using only the 32KHz OS timer&n; * on 1510 would be possible, but the timer would not be as accurate as&n; * with the 32KHz synchronized timer.&n; * ---------------------------------------------------------------------------&n; */
DECL|macro|OMAP_32K_TIMER_BASE
mdefine_line|#define OMAP_32K_TIMER_BASE&t;&t;0xfffb9000
DECL|macro|OMAP_32K_TIMER_CR
mdefine_line|#define OMAP_32K_TIMER_CR&t;&t;0x08
DECL|macro|OMAP_32K_TIMER_TVR
mdefine_line|#define OMAP_32K_TIMER_TVR&t;&t;0x00
DECL|macro|OMAP_32K_TIMER_TCR
mdefine_line|#define OMAP_32K_TIMER_TCR&t;&t;0x04
DECL|macro|OMAP_32K_TICKS_PER_HZ
mdefine_line|#define OMAP_32K_TICKS_PER_HZ&t;&t;(32768 / HZ)
multiline_comment|/*&n; * TRM says 1 / HZ = ( TVR + 1) / 32768, so TRV = (32768 / HZ) - 1&n; * so with HZ = 100, TVR = 327.68.&n; */
DECL|macro|OMAP_32K_TIMER_TICK_PERIOD
mdefine_line|#define OMAP_32K_TIMER_TICK_PERIOD&t;((32768 / HZ) - 1)
DECL|macro|MAX_SKIP_JIFFIES
mdefine_line|#define MAX_SKIP_JIFFIES&t;&t;25
DECL|macro|TIMER_32K_SYNCHRONIZED
mdefine_line|#define TIMER_32K_SYNCHRONIZED&t;&t;0xfffbc410
DECL|macro|JIFFIES_TO_HW_TICKS
mdefine_line|#define JIFFIES_TO_HW_TICKS(nr_jiffies, clock_rate)&t;&t;&t;&bslash;&n;&t;&t;&t;&t;(((nr_jiffies) * (clock_rate)) / HZ)
DECL|function|omap_32k_timer_write
r_static
r_inline
r_void
id|omap_32k_timer_write
c_func
(paren
r_int
id|val
comma
r_int
id|reg
)paren
(brace
id|omap_writew
c_func
(paren
id|val
comma
id|reg
op_plus
id|OMAP_32K_TIMER_BASE
)paren
suffix:semicolon
)brace
DECL|function|omap_32k_timer_read
r_static
r_inline
r_int
r_int
id|omap_32k_timer_read
c_func
(paren
r_int
id|reg
)paren
(brace
r_return
id|omap_readl
c_func
(paren
id|reg
op_plus
id|OMAP_32K_TIMER_BASE
)paren
op_amp
l_int|0xffffff
suffix:semicolon
)brace
multiline_comment|/*&n; * The 32KHz synchronized timer is an additional timer on 16xx.&n; * It is always running.&n; */
DECL|function|omap_32k_sync_timer_read
r_static
r_inline
r_int
r_int
id|omap_32k_sync_timer_read
c_func
(paren
r_void
)paren
(brace
r_return
id|omap_readl
c_func
(paren
id|TIMER_32K_SYNCHRONIZED
)paren
suffix:semicolon
)brace
DECL|function|omap_32k_timer_start
r_static
r_inline
r_void
id|omap_32k_timer_start
c_func
(paren
r_int
r_int
id|load_val
)paren
(brace
id|omap_32k_timer_write
c_func
(paren
id|load_val
comma
id|OMAP_32K_TIMER_TVR
)paren
suffix:semicolon
id|omap_32k_timer_write
c_func
(paren
l_int|0x0f
comma
id|OMAP_32K_TIMER_CR
)paren
suffix:semicolon
)brace
DECL|function|omap_32k_timer_stop
r_static
r_inline
r_void
id|omap_32k_timer_stop
c_func
(paren
r_void
)paren
(brace
id|omap_32k_timer_write
c_func
(paren
l_int|0x0
comma
id|OMAP_32K_TIMER_CR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Rounds down to nearest usec&n; */
DECL|function|omap_32k_ticks_to_usecs
r_static
r_inline
r_int
r_int
id|omap_32k_ticks_to_usecs
c_func
(paren
r_int
r_int
id|ticks_32k
)paren
(brace
r_return
(paren
id|ticks_32k
op_star
l_int|5
op_star
l_int|5
op_star
l_int|5
op_star
l_int|5
op_star
l_int|5
op_star
l_int|5
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
DECL|variable|omap_32k_last_tick
r_static
r_int
r_int
id|omap_32k_last_tick
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Returns elapsed usecs since last 32k timer interrupt&n; */
DECL|function|omap_32k_timer_gettimeoffset
r_static
r_int
r_int
id|omap_32k_timer_gettimeoffset
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|now
op_assign
id|omap_32k_sync_timer_read
c_func
(paren
)paren
suffix:semicolon
r_return
id|omap_32k_ticks_to_usecs
c_func
(paren
id|now
op_minus
id|omap_32k_last_tick
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Timer interrupt for 32KHz timer. When dynamic tick is enabled, this&n; * function is also called from other interrupts to remove latency&n; * issues with dynamic tick. In the dynamic tick case, we need to lock&n; * with irqsave.&n; */
DECL|function|omap_32k_timer_interrupt
r_static
id|irqreturn_t
id|omap_32k_timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
id|write_seqlock_irqsave
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
id|now
op_assign
id|omap_32k_sync_timer_read
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|now
op_minus
id|omap_32k_last_tick
op_ge
id|OMAP_32K_TICKS_PER_HZ
)paren
(brace
id|omap_32k_last_tick
op_add_assign
id|OMAP_32K_TICKS_PER_HZ
suffix:semicolon
id|timer_tick
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* Restart timer so we don&squot;t drift off due to modulo or dynamic tick.&n;&t; * By default we program the next timer to be continuous to avoid&n;&t; * latencies during high system load. During dynamic tick operation the&n;&t; * continuous timer can be overridden from pm_idle to be longer.&n;&t; */
id|omap_32k_timer_start
c_func
(paren
id|omap_32k_last_tick
op_plus
id|OMAP_32K_TICKS_PER_HZ
op_minus
id|now
)paren
suffix:semicolon
id|write_sequnlock_irqrestore
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|omap_32k_timer_irq
r_static
r_struct
id|irqaction
id|omap_32k_timer_irq
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;32KHz timer&quot;
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|handler
op_assign
id|omap_32k_timer_interrupt
)brace
suffix:semicolon
DECL|function|omap_init_32k_timer
r_static
id|__init
r_void
id|omap_init_32k_timer
c_func
(paren
r_void
)paren
(brace
id|setup_irq
c_func
(paren
id|INT_OS_TIMER
comma
op_amp
id|omap_32k_timer_irq
)paren
suffix:semicolon
id|omap_timer.offset
op_assign
id|omap_32k_timer_gettimeoffset
suffix:semicolon
id|omap_32k_last_tick
op_assign
id|omap_32k_sync_timer_read
c_func
(paren
)paren
suffix:semicolon
id|omap_32k_timer_start
c_func
(paren
id|OMAP_32K_TIMER_TICK_PERIOD
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_OMAP_32K_TIMER */
multiline_comment|/*&n; * ---------------------------------------------------------------------------&n; * Timer initialization&n; * ---------------------------------------------------------------------------&n; */
DECL|function|omap_timer_init
r_void
id|__init
id|omap_timer_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_OMAP_MPU_TIMER)
id|omap_init_mpu_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_OMAP_32K_TIMER)
id|omap_init_32k_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#error No system timer selected in Kconfig!
macro_line|#endif
)brace
DECL|variable|omap_timer
r_struct
id|sys_timer
id|omap_timer
op_assign
(brace
dot
id|init
op_assign
id|omap_timer_init
comma
dot
id|offset
op_assign
l_int|NULL
comma
multiline_comment|/* Initialized later */
)brace
suffix:semicolon
eof
