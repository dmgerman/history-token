multiline_comment|/*&n; * linux/arch/arm/mach-omap/irq.c&n; *&n; * Interrupt handler for all OMAP boards&n; *&n; * Copyright (C) 2004 Nokia Corporation&n; * Written by Tony Lindgren &lt;tony@atomide.com&gt;&n; *&n; * Completely re-written to support various OMAP chips with bank specific&n; * interrupt handlers.&n; *&n; * Some snippets of the code taken from the older OMAP interrupt handler&n; * Copyright (C) 2001 RidgeRun, Inc. Greg Lonnon &lt;glonnon@ridgerun.com&gt;&n; *&n; * GPIO interrupt handler moved to gpio.c by Juha Yrjola&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN&n; * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&n; * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; * You should have received a copy of the  GNU General Public License along&n; * with this program; if not, write  to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/arch/gpio.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;irq.h&quot;
DECL|variable|banks
r_static
r_int
r_int
id|banks
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq_banks
r_static
r_struct
id|omap_irq_bank
id|irq_banks
(braket
id|MAX_NR_IRQ_BANKS
)braket
suffix:semicolon
DECL|function|irq_bank_readl
r_static
r_inline
r_int
r_int
id|irq_bank_readl
c_func
(paren
r_int
id|bank
comma
r_int
id|offset
)paren
(brace
r_return
id|omap_readl
c_func
(paren
id|irq_banks
(braket
id|bank
)braket
dot
id|base_reg
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|irq_bank_writel
r_static
r_inline
r_void
id|irq_bank_writel
c_func
(paren
r_int
r_int
id|value
comma
r_int
id|bank
comma
r_int
id|offset
)paren
(brace
id|omap_writel
c_func
(paren
id|value
comma
id|irq_banks
(braket
id|bank
)braket
dot
id|base_reg
op_plus
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ack routine for chips with register offsets of 0x100&n; */
DECL|function|omap_offset_ack_irq
r_static
r_void
id|omap_offset_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OG
l_int|31
)paren
id|omap_writel
c_func
(paren
l_int|0x1
comma
id|OMAP_IH2_BASE
op_plus
id|IRQ_CONTROL_REG
)paren
suffix:semicolon
id|omap_writel
c_func
(paren
l_int|0x1
comma
id|OMAP_IH1_BASE
op_plus
id|IRQ_CONTROL_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mask routine for chips with register offsets of 0x100&n; */
DECL|function|omap_offset_mask_irq
r_static
r_void
id|omap_offset_mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|bank
op_assign
id|IRQ_TO_BANK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
)paren
(brace
id|omap_writel
c_func
(paren
id|omap_readl
c_func
(paren
id|OMAP_IH2_BASE
op_plus
id|BANK_OFFSET
c_func
(paren
id|bank
)paren
op_plus
id|IRQ_MIR
)paren
op_or
(paren
l_int|1
op_lshift
id|IRQ_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|OMAP_IH2_BASE
op_plus
id|BANK_OFFSET
c_func
(paren
id|bank
)paren
op_plus
id|IRQ_MIR
)paren
suffix:semicolon
)brace
r_else
(brace
id|omap_writel
c_func
(paren
id|omap_readl
c_func
(paren
id|OMAP_IH1_BASE
op_plus
id|IRQ_MIR
)paren
op_or
(paren
l_int|1
op_lshift
id|IRQ_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|OMAP_IH1_BASE
op_plus
id|IRQ_MIR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Unmask routine for chips with register offsets of 0x100&n; */
DECL|function|omap_offset_unmask_irq
r_static
r_void
id|omap_offset_unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|bank
op_assign
id|IRQ_TO_BANK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
)paren
(brace
id|omap_writel
c_func
(paren
id|omap_readl
c_func
(paren
id|OMAP_IH2_BASE
op_plus
id|BANK_OFFSET
c_func
(paren
id|bank
)paren
op_plus
id|IRQ_MIR
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|IRQ_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|OMAP_IH2_BASE
op_plus
id|BANK_OFFSET
c_func
(paren
id|bank
)paren
op_plus
id|IRQ_MIR
)paren
suffix:semicolon
)brace
r_else
(brace
id|omap_writel
c_func
(paren
id|omap_readl
c_func
(paren
id|OMAP_IH1_BASE
op_plus
id|IRQ_MIR
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|IRQ_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|OMAP_IH1_BASE
op_plus
id|IRQ_MIR
)paren
suffix:semicolon
)brace
)brace
DECL|function|omap_offset_mask_ack_irq
r_static
r_void
id|omap_offset_mask_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|omap_offset_mask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|omap_offset_ack_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the irq number returns the bank number&n; */
DECL|function|irq_get_bank
r_int
r_int
id|irq_get_bank
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|banks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
id|irq_banks
(braket
id|i
)braket
dot
id|start_irq
op_logical_and
id|irq
op_le
id|irq_banks
(braket
id|i
)braket
dot
id|start_irq
op_plus
id|BANK_NR_IRQS
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No irq handler found for irq %i&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the bank and irq number returns the irq bit at the bank register&n; */
DECL|function|irq_bank_get_bit
r_int
r_int
id|irq_bank_get_bit
c_func
(paren
r_int
id|bank
comma
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq_banks
(braket
id|bank
)braket
dot
id|start_irq
OG
id|irq
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Incorrect irq %i: bank %i offset %i&bslash;n&quot;
comma
id|irq
comma
id|bank
comma
id|irq_banks
(braket
id|bank
)braket
dot
id|start_irq
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|irq
op_minus
id|irq_banks
(braket
id|bank
)braket
dot
id|start_irq
suffix:semicolon
)brace
multiline_comment|/*&n; * Allows tuning the IRQ type and priority&n; *&n; * NOTE: There is currently no OMAP fiq handler for Linux. Read the&n; *&t; mailing list threads on FIQ handlers if you are planning to&n; *&t; add a FIQ handler for OMAP.&n; */
DECL|function|omap_irq_set_cfg
r_void
id|omap_irq_set_cfg
c_func
(paren
r_int
id|irq
comma
r_int
id|fiq
comma
r_int
id|priority
comma
r_int
id|irq_level
)paren
(brace
r_int
r_int
id|bank
suffix:semicolon
r_int
r_int
id|irq_bit
suffix:semicolon
r_int
r_int
id|val
comma
id|offset
suffix:semicolon
id|bank
op_assign
id|irq_get_bank
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
OL
l_int|0
)paren
r_return
suffix:semicolon
id|irq_bit
op_assign
id|irq_bank_get_bit
c_func
(paren
id|bank
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_bit
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* FIQ is only availabe on bank 0 interrupts */
id|fiq
op_assign
id|bank
ques
c_cond
l_int|0
suffix:colon
(paren
id|fiq
op_amp
l_int|0x1
)paren
suffix:semicolon
id|val
op_assign
id|fiq
op_or
(paren
(paren
id|priority
op_amp
l_int|0x1f
)paren
op_lshift
l_int|2
)paren
op_or
(paren
(paren
id|irq_level
op_amp
l_int|0x1
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|offset
op_assign
id|IRQ_ILR0
op_plus
id|irq_bit
op_star
l_int|0x4
suffix:semicolon
id|irq_bank_writel
c_func
(paren
id|val
comma
id|bank
comma
id|offset
)paren
suffix:semicolon
)brace
DECL|variable|__initdata
r_static
r_struct
id|omap_irq_desc
op_star
id|irq_bank_desc
(braket
)braket
id|__initdata
op_assign
(brace
op_amp
id|omap730_bank0_irqs
comma
op_amp
id|omap730_bank1_irqs
comma
op_amp
id|omap730_bank2_irqs
comma
op_amp
id|omap1510_bank0_irqs
comma
op_amp
id|omap1510_bank1_irqs
comma
op_amp
id|omap1610_bank0_irqs
comma
op_amp
id|omap1610_bank1_irqs
comma
op_amp
id|omap1610_bank2_irqs
comma
op_amp
id|omap1610_bank3_irqs
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|function|omap_init_irq
r_void
id|__init
id|omap_init_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|board_irq_type
op_assign
l_int|0
comma
id|interrupts
op_assign
l_int|0
suffix:semicolon
r_struct
id|omap_irq_desc
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|cpu_is_omap730
c_func
(paren
)paren
)paren
(brace
id|board_irq_type
op_assign
id|OMAP_IRQ_TYPE730
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
id|board_irq_type
op_assign
id|OMAP_IRQ_TYPE1510
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_is_omap1610
c_func
(paren
)paren
op_logical_or
id|cpu_is_omap5912
c_func
(paren
)paren
)paren
(brace
id|board_irq_type
op_assign
id|OMAP_IRQ_TYPE1610
suffix:semicolon
)brace
r_if
c_cond
(paren
id|board_irq_type
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Could not detect OMAP type&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Scan through the interrupt bank maps and copy the right data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|entry
op_assign
id|irq_bank_desc
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;cpu_type
op_eq
id|board_irq_type
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Type %i IRQs from %3i to %3i base at 0x%lx&bslash;n&quot;
comma
id|board_irq_type
comma
id|entry-&gt;start_irq
comma
id|entry-&gt;start_irq
op_plus
id|BANK_NR_IRQS
comma
id|entry-&gt;base_reg
)paren
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|start_irq
op_assign
id|entry-&gt;start_irq
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|level_map
op_assign
id|entry-&gt;level_map
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|base_reg
op_assign
id|entry-&gt;base_reg
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|mask_reg
op_assign
id|entry-&gt;mask_reg
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|ack_reg
op_assign
id|entry-&gt;ack_reg
suffix:semicolon
id|irq_banks
(braket
id|banks
)braket
dot
id|handler
op_assign
id|entry-&gt;handler
suffix:semicolon
id|interrupts
op_add_assign
id|BANK_NR_IRQS
suffix:semicolon
id|banks
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Found total of %i interrupts in %i interrupt banks&bslash;n&quot;
comma
id|interrupts
comma
id|banks
)paren
suffix:semicolon
multiline_comment|/* Mask and clear all interrupts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|banks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_bank_writel
c_func
(paren
op_complement
l_int|0x0
comma
id|i
comma
id|IRQ_MIR
)paren
suffix:semicolon
id|irq_bank_writel
c_func
(paren
l_int|0x0
comma
id|i
comma
id|IRQ_ITR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear any pending interrupts&n;&t; */
id|irq_bank_writel
c_func
(paren
l_int|3
comma
l_int|0
comma
id|IRQ_CONTROL_REG
)paren
suffix:semicolon
id|irq_bank_writel
c_func
(paren
l_int|3
comma
l_int|1
comma
id|IRQ_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* Install the interrupt handlers for each bank */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|banks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|irq_banks
(braket
id|i
)braket
dot
id|start_irq
suffix:semicolon
id|j
op_le
id|irq_banks
(braket
id|i
)braket
dot
id|start_irq
op_plus
id|BANK_NR_IRQS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|irq_level
suffix:semicolon
id|set_irq_chip
c_func
(paren
id|j
comma
id|irq_banks
(braket
id|i
)braket
dot
id|handler
)paren
suffix:semicolon
id|set_irq_handler
c_func
(paren
id|j
comma
id|do_level_IRQ
)paren
suffix:semicolon
id|set_irq_flags
c_func
(paren
id|j
comma
id|IRQF_VALID
)paren
suffix:semicolon
id|irq_level
op_assign
id|irq_banks
(braket
id|i
)braket
dot
id|level_map
op_rshift
(paren
id|j
op_minus
id|irq_banks
(braket
id|i
)braket
dot
id|start_irq
)paren
op_amp
l_int|1
suffix:semicolon
id|omap_irq_set_cfg
c_func
(paren
id|j
comma
l_int|0
comma
l_int|0
comma
id|irq_level
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Unmask level 2 handler */
id|omap_writel
c_func
(paren
l_int|0
comma
id|irq_banks
(braket
l_int|0
)braket
dot
id|mask_reg
)paren
suffix:semicolon
)brace
DECL|variable|omap_irq_set_cfg
id|EXPORT_SYMBOL
c_func
(paren
id|omap_irq_set_cfg
)paren
suffix:semicolon
eof
