multiline_comment|/*&n; * linux/arch/arm/mach-omap/irq.c&n; *&n; * Interrupt handler for OMAP-1510 and 1610&n; *&n; * Copyright (C) 2001 RidgeRun, Inc.&n; * Author: Greg Lonnon &lt;glonnon@ridgerun.com&gt;&n; *&n; * Modified for OMAP-1610 by Tony Lindgren &lt;tony.lindgren@nokia.com&gt;&n; * GPIO interrupt handler moved to gpio.c for OMAP-1610 by Juha Yrjola&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN&n; * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&n; * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/arch/gpio.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|NUM_IRQS
mdefine_line|#define NUM_IRQS&t;IH_BOARD_BASE
r_static
r_void
id|mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|write_ih
id|write_ih
c_func
(paren
r_int
id|level
comma
r_int
id|reg
comma
id|u32
id|value
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
id|__raw_writel
c_func
(paren
id|value
comma
(paren
id|IO_ADDRESS
c_func
(paren
(paren
id|level
ques
c_cond
id|OMAP_IH2_BASE
suffix:colon
id|OMAP_IH1_BASE
)paren
op_plus
(paren
id|reg
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|level
)paren
(brace
id|__raw_writel
c_func
(paren
id|value
comma
id|IO_ADDRESS
c_func
(paren
id|OMAP_IH2_BASE
op_plus
(paren
(paren
id|level
op_minus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__raw_writel
c_func
(paren
id|value
comma
id|IO_ADDRESS
c_func
(paren
id|OMAP_IH1_BASE
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
id|u32
DECL|function|read_ih
id|read_ih
c_func
(paren
r_int
id|level
comma
r_int
id|reg
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
r_return
id|__raw_readl
c_func
(paren
(paren
id|IO_ADDRESS
c_func
(paren
(paren
id|level
ques
c_cond
id|OMAP_IH2_BASE
suffix:colon
id|OMAP_IH1_BASE
)paren
op_plus
(paren
id|reg
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|level
)paren
(brace
r_return
id|__raw_readl
c_func
(paren
id|IO_ADDRESS
c_func
(paren
id|OMAP_IH2_BASE
op_plus
(paren
(paren
id|level
op_minus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|__raw_readl
c_func
(paren
id|IO_ADDRESS
c_func
(paren
id|OMAP_IH1_BASE
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
r_int
DECL|function|get_level
id|get_level
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
r_return
(paren
(paren
(paren
id|irq
)paren
OL
id|IH2_BASE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|irq
OL
id|IH2_BASE
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
r_return
(paren
id|irq
op_rshift
l_int|5
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
r_int
DECL|function|get_irq_num
id|get_irq_num
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
r_return
(paren
(paren
(paren
id|irq
)paren
OL
id|IH2_BASE
)paren
ques
c_cond
id|irq
suffix:colon
id|irq
op_minus
id|IH2_BASE
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|irq
op_amp
l_int|0x1f
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|mask_irq
id|mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|level
op_assign
id|get_level
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_num
op_assign
id|get_irq_num
c_func
(paren
id|irq
)paren
suffix:semicolon
id|u32
id|mask
op_assign
id|read_ih
c_func
(paren
id|level
comma
id|IRQ_MIR
)paren
op_or
(paren
l_int|1
op_lshift
id|irq_num
)paren
suffix:semicolon
id|write_ih
c_func
(paren
id|level
comma
id|IRQ_MIR
comma
id|mask
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ack_irq
id|ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|level
op_assign
id|get_level
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|1
)paren
id|level
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|write_ih
c_func
(paren
id|level
comma
id|IRQ_CONTROL_REG
comma
l_int|0x1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * REVISIT: So says the TRM:&n;&t;&t; *&t;if (level) write_ih(0, ITR, 0);&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|level
op_decrement
)paren
suffix:semicolon
)brace
r_void
DECL|function|unmask_irq
id|unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|level
op_assign
id|get_level
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_num
op_assign
id|get_irq_num
c_func
(paren
id|irq
)paren
suffix:semicolon
id|u32
id|mask
op_assign
id|read_ih
c_func
(paren
id|level
comma
id|IRQ_MIR
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|irq_num
)paren
suffix:semicolon
id|write_ih
c_func
(paren
id|level
comma
id|IRQ_MIR
comma
id|mask
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|mask_ack_irq
id|mask_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|mask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ack_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|omap_normal_irq
r_static
r_struct
id|irqchip
id|omap_normal_irq
op_assign
(brace
dot
id|ack
op_assign
id|mask_ack_irq
comma
dot
id|mask
op_assign
id|mask_irq
comma
dot
id|unmask
op_assign
id|unmask_irq
comma
)brace
suffix:semicolon
r_static
r_void
DECL|function|irq_priority
id|irq_priority
c_func
(paren
r_int
id|irq
comma
r_int
id|fiq
comma
r_int
id|priority
comma
r_int
id|trigger
)paren
(brace
r_int
id|level
comma
id|irq_num
suffix:semicolon
r_int
r_int
id|reg_value
comma
id|reg_addr
suffix:semicolon
id|level
op_assign
id|get_level
c_func
(paren
id|irq
)paren
suffix:semicolon
id|irq_num
op_assign
id|get_irq_num
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* FIQ is only available on level 0 interrupts */
id|fiq
op_assign
id|level
ques
c_cond
l_int|0
suffix:colon
(paren
id|fiq
op_amp
l_int|0x1
)paren
suffix:semicolon
id|reg_value
op_assign
(paren
id|fiq
)paren
op_or
(paren
(paren
id|priority
op_amp
l_int|0x1f
)paren
op_lshift
l_int|2
)paren
op_or
(paren
(paren
id|trigger
op_amp
l_int|0x1
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|reg_addr
op_assign
(paren
id|IRQ_ILR0
op_plus
id|irq_num
op_star
l_int|0x4
)paren
suffix:semicolon
id|write_ih
c_func
(paren
id|level
comma
id|reg_addr
comma
id|reg_value
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|omap_init_irq
id|omap_init_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|irq_count
comma
id|irq_bank_count
op_assign
l_int|0
suffix:semicolon
id|uint
op_star
id|trigger
suffix:semicolon
r_if
c_cond
(paren
id|cpu_is_omap1510
c_func
(paren
)paren
)paren
(brace
r_static
id|uint
id|trigger_1510
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xb3febfff
comma
l_int|0xffbfffed
)brace
suffix:semicolon
id|irq_bank_count
op_assign
l_int|2
suffix:semicolon
id|irq_count
op_assign
l_int|64
suffix:semicolon
id|trigger
op_assign
id|trigger_1510
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_is_omap1610
c_func
(paren
)paren
)paren
(brace
r_static
id|uint
id|trigger_1610
(braket
l_int|5
)braket
op_assign
(brace
l_int|0xb3fefe8f
comma
l_int|0xfffff7ff
comma
l_int|0xffffffff
)brace
suffix:semicolon
id|irq_bank_count
op_assign
l_int|5
suffix:semicolon
id|irq_count
op_assign
l_int|160
suffix:semicolon
id|trigger
op_assign
id|trigger_1610
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_is_omap730
c_func
(paren
)paren
)paren
(brace
r_static
id|uint
id|trigger_730
(braket
)braket
op_assign
(brace
l_int|0xb3f8e22f
comma
l_int|0xfdb9c1f2
comma
l_int|0x800040f3
)brace
suffix:semicolon
id|irq_bank_count
op_assign
l_int|3
suffix:semicolon
id|irq_count
op_assign
l_int|96
suffix:semicolon
id|trigger
op_assign
id|trigger_730
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|irq_bank_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Mask and clear all interrupts */
id|write_ih
c_func
(paren
id|i
comma
id|IRQ_MIR
comma
op_complement
l_int|0x0
)paren
suffix:semicolon
id|write_ih
c_func
(paren
id|i
comma
id|IRQ_ITR
comma
l_int|0x0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear any pending interrupts */
id|write_ih
c_func
(paren
l_int|1
comma
id|IRQ_CONTROL_REG
comma
l_int|3
)paren
suffix:semicolon
id|write_ih
c_func
(paren
l_int|0
comma
id|IRQ_CONTROL_REG
comma
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|irq_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_irq_chip
c_func
(paren
id|i
comma
op_amp
id|omap_normal_irq
)paren
suffix:semicolon
id|set_irq_handler
c_func
(paren
id|i
comma
id|do_level_IRQ
)paren
suffix:semicolon
id|set_irq_flags
c_func
(paren
id|i
comma
id|IRQF_VALID
)paren
suffix:semicolon
id|irq_priority
c_func
(paren
id|i
comma
l_int|0
comma
l_int|0
comma
id|trigger
(braket
id|get_level
c_func
(paren
id|i
)paren
)braket
op_rshift
id|get_irq_num
c_func
(paren
id|i
)paren
op_amp
l_int|1
)paren
suffix:semicolon
)brace
id|unmask_irq
c_func
(paren
id|INT_IH2_IRQ
)paren
suffix:semicolon
)brace
eof
