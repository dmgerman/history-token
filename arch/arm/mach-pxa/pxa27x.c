multiline_comment|/*&n; *  linux/arch/arm/mach-pxa/pxa27x.c&n; *&n; *  Author:&t;Nicolas Pitre&n; *  Created:&t;Nov 05, 2002&n; *  Copyright:&t;MontaVista Software Inc.&n; *&n; * Code specific to PXA27x aka Bulverde.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &quot;generic.h&quot;
multiline_comment|/* Crystal clock : 13-MHZ*/
DECL|macro|BASE_CLK
mdefine_line|#define BASE_CLK&t;13000000
multiline_comment|/*&n; * Get the clock frequency as reflected by CCSR and the turbo flag.&n; * We assume these values have been applied via a fcs.&n; * If info is not 0 we also display the current settings.&n; *&n; * For more details, refer to Bulverde Manual, section 3.8.2.1&n; */
DECL|function|get_clk_frequency_khz
r_int
r_int
id|get_clk_frequency_khz
c_func
(paren
r_int
id|info
)paren
(brace
r_int
r_int
id|ccsr
comma
id|turbo
comma
id|b
comma
id|ht
suffix:semicolon
r_int
r_int
id|l
comma
id|L
comma
id|m
comma
id|M
comma
id|n2
comma
id|N
comma
id|S
comma
id|cccra
suffix:semicolon
id|ccsr
op_assign
id|CCSR
suffix:semicolon
id|cccra
op_assign
id|CCCR
op_amp
(paren
l_int|0x1
op_lshift
l_int|25
)paren
suffix:semicolon
multiline_comment|/* Read clkcfg register: it has turbo, b, half-turbo (and f) */
id|asm
c_func
(paren
l_string|&quot;mrc&bslash;tp14, 0, %0, c6, c0, 0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|turbo
)paren
)paren
suffix:semicolon
id|b
op_assign
(paren
id|turbo
op_amp
(paren
l_int|0x1
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|ht
op_assign
(paren
id|turbo
op_amp
(paren
l_int|0x1
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|l
op_assign
id|ccsr
op_amp
l_int|0x1f
suffix:semicolon
id|n2
op_assign
(paren
id|ccsr
op_rshift
l_int|7
)paren
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|31
)paren
(brace
multiline_comment|/* The calculation from the Yellow Book is incorrect:&n;&t;&t;   it says M=4 for L=21-30 (which is easy to calculate&n;&t;&t;   by subtracting 1 and then dividing by 10, but not&n;&t;&t;   with 31, so we&squot;ll do it manually */
id|m
op_assign
l_int|1
op_lshift
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|m
op_assign
l_int|1
op_lshift
(paren
(paren
id|l
op_minus
l_int|1
)paren
op_div
l_int|10
)paren
suffix:semicolon
)brace
id|L
op_assign
id|l
op_star
id|BASE_CLK
suffix:semicolon
id|N
op_assign
(paren
id|n2
op_star
id|L
)paren
op_div
l_int|2
suffix:semicolon
id|S
op_assign
(paren
id|b
)paren
ques
c_cond
id|L
suffix:colon
(paren
id|L
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cccra
op_eq
l_int|0
)paren
id|M
op_assign
id|L
op_div
id|m
suffix:semicolon
r_else
id|M
op_assign
(paren
id|b
)paren
ques
c_cond
id|L
suffix:colon
(paren
id|L
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Run Mode clock: %d.%02dMHz (*%d)&bslash;n&quot;
comma
id|L
op_div
l_int|1000000
comma
(paren
id|L
op_mod
l_int|1000000
)paren
op_div
l_int|10000
comma
id|l
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Memory clock: %d.%02dMHz (/%d)&bslash;n&quot;
comma
id|M
op_div
l_int|1000000
comma
(paren
id|M
op_mod
l_int|1000000
)paren
op_div
l_int|10000
comma
id|m
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Turbo Mode clock: %d.%02dMHz (*%d.%d, %sactive)&bslash;n&quot;
comma
id|N
op_div
l_int|1000000
comma
(paren
id|N
op_mod
l_int|1000000
)paren
op_div
l_int|10000
comma
id|n2
op_div
l_int|2
comma
(paren
id|n2
op_mod
l_int|2
)paren
op_star
l_int|5
comma
(paren
id|turbo
op_amp
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;in&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;System bus clock: %d.%02dMHz &bslash;n&quot;
comma
id|S
op_div
l_int|1000000
comma
(paren
id|S
op_mod
l_int|1000000
)paren
op_div
l_int|10000
)paren
suffix:semicolon
)brace
r_return
(paren
id|turbo
op_amp
l_int|1
)paren
ques
c_cond
(paren
id|N
op_div
l_int|1000
)paren
suffix:colon
(paren
id|L
op_div
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the current mem clock frequency in units of 10kHz as&n; * reflected by CCCR[A], B, and L&n; */
DECL|function|get_lclk_frequency_10khz
r_int
r_int
id|get_lclk_frequency_10khz
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ccsr
comma
id|clkcfg
comma
id|b
suffix:semicolon
r_int
r_int
id|l
comma
id|L
comma
id|m
comma
id|M
comma
id|cccra
suffix:semicolon
id|cccra
op_assign
id|CCCR
op_amp
(paren
l_int|0x1
op_lshift
l_int|25
)paren
suffix:semicolon
multiline_comment|/* Read clkcfg register to obtain b */
id|asm
c_func
(paren
l_string|&quot;mrc&bslash;tp14, 0, %0, c6, c0, 0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|clkcfg
)paren
)paren
suffix:semicolon
id|b
op_assign
(paren
id|clkcfg
op_amp
(paren
l_int|0x1
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|ccsr
op_assign
id|CCSR
suffix:semicolon
id|l
op_assign
id|ccsr
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|31
)paren
(brace
multiline_comment|/* The calculation from the Yellow Book is incorrect:&n;&t;&t;   it says M=4 for L=21-30 (which is easy to calculate&n;&t;&t;   by subtracting 1 and then dividing by 10, but not&n;&t;&t;   with 31, so we&squot;ll do it manually */
id|m
op_assign
l_int|1
op_lshift
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|m
op_assign
l_int|1
op_lshift
(paren
(paren
id|l
op_minus
l_int|1
)paren
op_div
l_int|10
)paren
suffix:semicolon
)brace
id|L
op_assign
id|l
op_star
id|BASE_CLK
suffix:semicolon
r_if
c_cond
(paren
id|cccra
op_eq
l_int|0
)paren
id|M
op_assign
id|L
op_div
id|m
suffix:semicolon
r_else
id|M
op_assign
(paren
id|b
)paren
ques
c_cond
id|L
suffix:colon
id|L
op_div
l_int|2
suffix:semicolon
r_return
(paren
id|M
op_div
l_int|10000
)paren
suffix:semicolon
)brace
DECL|variable|get_clk_frequency_khz
id|EXPORT_SYMBOL
c_func
(paren
id|get_clk_frequency_khz
)paren
suffix:semicolon
DECL|variable|get_lclk_frequency_10khz
id|EXPORT_SYMBOL
c_func
(paren
id|get_lclk_frequency_10khz
)paren
suffix:semicolon
eof
