multiline_comment|/*&n; * linux/arch/arm/mach-sa1100/sa1111.c&n; *&n; * SA1111 support&n; *&n; * Original code by John Dorsey&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * This file contains all generic SA1111 support, except for DMA which is&n; * provided separately in dma-sa1111.c.&n; *&n; * All initialization functions provided here are intended to be called&n; * from machine specific code with proper arguments when required.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/arch/irq.h&gt;
macro_line|#include &quot;sa1111.h&quot;
multiline_comment|/*&n; * SA1111  Interrupt support&n; */
DECL|function|sa1111_IRQ_demux
r_void
id|sa1111_IRQ_demux
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|stat0
comma
id|stat1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|stat0
op_assign
id|INTSTATCLR0
comma
id|stat1
op_assign
id|INTSTATCLR1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat0
op_logical_and
op_logical_neg
id|stat1
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|stat0
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|do_IRQ
c_func
(paren
id|SA1111_IRQ
c_func
(paren
id|i
)paren
comma
id|regs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat1
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|55
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|stat1
op_amp
(paren
l_int|1
op_lshift
(paren
id|i
op_minus
l_int|32
)paren
)paren
)paren
(brace
id|do_IRQ
c_func
(paren
id|SA1111_IRQ
c_func
(paren
id|i
)paren
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|sa1111_irq
r_static
r_struct
id|irqaction
id|sa1111_irq
op_assign
(brace
id|name
suffix:colon
l_string|&quot;SA1111&quot;
comma
id|handler
suffix:colon
id|sa1111_IRQ_demux
comma
id|flags
suffix:colon
id|SA_INTERRUPT
)brace
suffix:semicolon
DECL|function|sa1111_mask_and_ack_lowirq
r_static
r_void
id|sa1111_mask_and_ack_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
(paren
id|irq
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
singleline_comment|// broken hardware: interrupt events are lost if they occur
singleline_comment|// while the interrupts are disabled.
singleline_comment|//INTEN0 &amp;= ~mask;
id|INTSTATCLR0
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sa1111_mask_and_ack_highirq
r_static
r_void
id|sa1111_mask_and_ack_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
(paren
id|irq
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|32
)paren
)paren
suffix:semicolon
singleline_comment|//INTEN1 &amp;= ~mask;
id|INTSTATCLR1
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sa1111_mask_lowirq
r_static
r_void
id|sa1111_mask_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
singleline_comment|//INTEN0 &amp;= ~(1 &lt;&lt; (irq - SA1111_IRQ(0)));
)brace
DECL|function|sa1111_mask_highirq
r_static
r_void
id|sa1111_mask_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
singleline_comment|//INTEN1 &amp;= ~(1 &lt;&lt; (irq - SA1111_IRQ(32)));
)brace
DECL|function|sa1111_unmask_lowirq
r_static
r_void
id|sa1111_unmask_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN0
op_or_assign
l_int|1
op_lshift
(paren
id|irq
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|sa1111_unmask_highirq
r_static
r_void
id|sa1111_unmask_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN1
op_or_assign
l_int|1
op_lshift
(paren
(paren
id|irq
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|32
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|sa1111_init_irq
r_void
id|__init
id|sa1111_init_irq
c_func
(paren
r_int
id|irq_nr
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/* disable all IRQs */
id|INTEN0
op_assign
l_int|0
suffix:semicolon
id|INTEN1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * detect on rising edge.  Note: Feb 2001 Errata for SA1111&n;&t; * specifies that S0ReadyInt and S1ReadyInt should be &squot;1&squot;.&n;&t; */
id|INTPOL0
op_assign
l_int|0
suffix:semicolon
id|INTPOL1
op_assign
l_int|1
op_lshift
(paren
id|S0_READY_NINT
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|32
)paren
)paren
op_or
l_int|1
op_lshift
(paren
id|S1_READY_NINT
op_minus
id|SA1111_IRQ
c_func
(paren
l_int|32
)paren
)paren
suffix:semicolon
multiline_comment|/* clear all IRQs */
id|INTSTATCLR0
op_assign
op_minus
l_int|1
suffix:semicolon
id|INTSTATCLR1
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|SA1111_IRQ
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|irq
op_le
id|SA1111_IRQ
c_func
(paren
l_int|26
)paren
suffix:semicolon
id|irq
op_increment
)paren
(brace
id|irq_desc
(braket
id|irq
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|probe_ok
op_assign
l_int|0
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|mask_ack
op_assign
id|sa1111_mask_and_ack_lowirq
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|mask
op_assign
id|sa1111_mask_lowirq
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|unmask
op_assign
id|sa1111_unmask_lowirq
suffix:semicolon
)brace
r_for
c_loop
(paren
id|irq
op_assign
id|SA1111_IRQ
c_func
(paren
l_int|32
)paren
suffix:semicolon
id|irq
op_le
id|SA1111_IRQ
c_func
(paren
l_int|54
)paren
suffix:semicolon
id|irq
op_increment
)paren
(brace
id|irq_desc
(braket
id|irq
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|probe_ok
op_assign
l_int|0
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|mask_ack
op_assign
id|sa1111_mask_and_ack_highirq
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|mask
op_assign
id|sa1111_mask_highirq
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|unmask
op_assign
id|sa1111_unmask_highirq
suffix:semicolon
)brace
multiline_comment|/* Register SA1111 interrupt */
r_if
c_cond
(paren
id|irq_nr
op_ge
l_int|0
)paren
id|setup_arm_irq
c_func
(paren
id|irq_nr
comma
op_amp
id|sa1111_irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for a SA1111 chip.&n; */
DECL|function|sa1111_probe
r_int
id|__init
id|sa1111_probe
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|id
op_assign
id|SBI_SKID
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_amp
id|SKID_ID_MASK
)paren
op_eq
id|SKID_SA1111_ID
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SA-1111 Microprocessor Companion Chip: &quot;
l_string|&quot;silicon revision %lx, metal revision %lx&bslash;n&quot;
comma
(paren
id|id
op_amp
id|SKID_SIREV_MASK
)paren
op_rshift
l_int|4
comma
(paren
id|id
op_amp
id|SKID_MTREV_MASK
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SA-1111 not detected: ID = %08lx&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Bring the SA1111 out of reset.  This requires a set procedure:&n; *  1. nRESET asserted (by hardware)&n; *  2. CLK turned on from SA1110&n; *  3. nRESET deasserted&n; *  4. VCO turned on, PLL_BYPASS turned off&n; *  5. Wait lock time, then assert RCLKEn&n; *  7. PCR set to allow clocking of individual functions&n; *&n; * Until we&squot;ve done this, the only registers we can access are:&n; *   SBI_SKCR&n; *   SBI_SMCR&n; *   SBI_SKID&n; */
DECL|function|sa1111_wake
r_void
id|sa1111_wake
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * First, set up the 3.6864MHz clock on GPIO 27 for the SA-1111:&n;&t; * (SA-1110 Developer&squot;s Manual, section 9.1.2.1)&n;&t; */
id|GAFR
op_or_assign
id|GPIO_32_768kHz
suffix:semicolon
id|GPDR
op_or_assign
id|GPIO_32_768kHz
suffix:semicolon
id|TUCR
op_assign
id|TUCR_3_6864MHz
suffix:semicolon
multiline_comment|/*&n;&t; * Turn VCO on, and disable PLL Bypass.&n;&t; */
id|SBI_SKCR
op_and_assign
op_complement
id|SKCR_VCO_OFF
suffix:semicolon
id|SBI_SKCR
op_or_assign
id|SKCR_PLL_BYPASS
op_or
id|SKCR_OE_EN
suffix:semicolon
multiline_comment|/*&n;&t; * Wait lock time.  SA1111 manual _doesn&squot;t_&n;&t; * specify a figure for this!  We choose 100us.&n;&t; */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable RCLK.  We also ensure that RDYEN is set.&n;&t; */
id|SBI_SKCR
op_or_assign
id|SKCR_RCLKEN
op_or
id|SKCR_RDYEN
suffix:semicolon
multiline_comment|/*&n;&t; * Wait 14 RCLK cycles for the chip to finish coming out&n;&t; * of reset. (RCLK=24MHz).  This is 590ns.&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure all clocks are initially off.&n;&t; */
id|SKPCR
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|sa1111_doze
r_void
id|sa1111_doze
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|SKPCR
op_amp
id|SKPCR_UCLKEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SA1111 doze mode refused&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SBI_SKCR
op_and_assign
op_complement
id|SKCR_RCLKEN
suffix:semicolon
)brace
multiline_comment|/*&n; * Configure the SA1111 shared memory controller.&n; */
DECL|function|sa1111_configure_smc
r_void
id|sa1111_configure_smc
c_func
(paren
r_int
id|sdram
comma
r_int
r_int
id|drac
comma
r_int
r_int
id|cas_latency
)paren
(brace
r_int
r_int
id|smcr
op_assign
id|SMCR_DTIM
op_or
id|SMCR_MBGE
op_or
id|FInsrt
c_func
(paren
id|drac
comma
id|SMCR_DRAC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cas_latency
op_eq
l_int|3
)paren
id|smcr
op_or_assign
id|SMCR_CLAT
suffix:semicolon
id|SBI_SMCR
op_assign
id|smcr
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable the memory bus request/grant signals on the SA1110 to&n; * ensure that we don&squot;t receive spurious memory requests.  We set&n; * the MBGNT signal false to ensure the SA1111 doesn&squot;t own the&n; * SDRAM bus.&n; */
DECL|function|sa1110_mb_disable
r_void
id|__init
id|sa1110_mb_disable
c_func
(paren
r_void
)paren
(brace
id|PGSR
op_and_assign
op_complement
id|GPIO_MBGNT
suffix:semicolon
id|GPCR
op_assign
id|GPIO_MBGNT
suffix:semicolon
id|GPDR
op_assign
(paren
id|GPDR
op_amp
op_complement
id|GPIO_MBREQ
)paren
op_or
id|GPIO_MBGNT
suffix:semicolon
id|GAFR
op_and_assign
op_complement
(paren
id|GPIO_MBGNT
op_or
id|GPIO_MBREQ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the system is going to use the SA-1111 DMA engines, set up&n; * the memory bus request/grant pins.&n; */
DECL|function|sa1110_mb_enable
r_void
id|__init
id|sa1110_mb_enable
c_func
(paren
r_void
)paren
(brace
id|PGSR
op_and_assign
op_complement
id|GPIO_MBGNT
suffix:semicolon
id|GPCR
op_assign
id|GPIO_MBGNT
suffix:semicolon
id|GPDR
op_assign
(paren
id|GPDR
op_amp
op_complement
id|GPIO_MBREQ
)paren
op_or
id|GPIO_MBGNT
suffix:semicolon
id|GAFR
op_or_assign
(paren
id|GPIO_MBGNT
op_or
id|GPIO_MBREQ
)paren
suffix:semicolon
id|TUCR
op_or_assign
id|TUCR_MR
suffix:semicolon
)brace
eof
