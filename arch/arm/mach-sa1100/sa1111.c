multiline_comment|/*&n; * linux/arch/arm/mach-sa1100/sa1111.c&n; *&n; * SA1111 support&n; *&n; * Original code by John Dorsey&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * This file contains all generic SA1111 support.&n; *&n; * All initialization functions provided here are intended to be called&n; * from machine specific code with proper arguments when required.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach/irq.h&gt;
macro_line|#include &lt;asm/hardware/sa1111.h&gt;
multiline_comment|/*&n; * We keep the following data for the overall SA1111.  Note that the&n; * struct device and struct resource are &quot;fake&quot;; they should be supplied&n; * by the bus above us.  However, in the interests of getting all SA1111&n; * drivers converted over to the device model, we provide this as an&n; * anchor point for all the other drivers.&n; */
DECL|struct|sa1111
r_struct
id|sa1111
(brace
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|member|res
r_struct
id|resource
id|res
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|base
r_void
op_star
id|base
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * We _really_ need to eliminate this.  Its only users&n; * are the PWM and DMA checking code.&n; */
DECL|variable|g_sa1111
r_static
r_struct
id|sa1111
op_star
id|g_sa1111
suffix:semicolon
DECL|variable|usb_dev
r_static
r_struct
id|sa1111_dev
id|usb_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [USB Controller]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
id|SKPCR_UCLKEN
comma
dot
id|devid
op_assign
id|SA1111_DEVID_USB
comma
dot
id|irq
op_assign
(brace
id|IRQ_USBPWR
comma
id|IRQ_HCIM
comma
id|IRQ_HCIBUFFACC
comma
id|IRQ_HCIRMTWKP
comma
id|IRQ_NHCIMFCIR
comma
id|IRQ_USB_PORT_RESUME
)brace
comma
)brace
suffix:semicolon
DECL|variable|sac_dev
r_static
r_struct
id|sa1111_dev
id|sac_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [Audio Controller]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
id|SKPCR_I2SCLKEN
op_or
id|SKPCR_L3CLKEN
comma
dot
id|devid
op_assign
id|SA1111_DEVID_SAC
comma
dot
id|irq
op_assign
(brace
id|AUDXMTDMADONEA
comma
id|AUDXMTDMADONEB
comma
id|AUDRCVDMADONEA
comma
id|AUDRCVDMADONEB
)brace
comma
)brace
suffix:semicolon
DECL|variable|ssp_dev
r_static
r_struct
id|sa1111_dev
id|ssp_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [SSP Controller]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
id|SKPCR_SCLKEN
comma
dot
id|devid
op_assign
id|SA1111_DEVID_SSP
comma
)brace
suffix:semicolon
DECL|variable|kbd_dev
r_static
r_struct
id|sa1111_dev
id|kbd_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [PS2]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
id|SKPCR_PTCLKEN
comma
dot
id|devid
op_assign
id|SA1111_DEVID_PS2
comma
dot
id|irq
op_assign
(brace
id|IRQ_TPRXINT
comma
id|IRQ_TPTXINT
)brace
comma
)brace
suffix:semicolon
DECL|variable|mse_dev
r_static
r_struct
id|sa1111_dev
id|mse_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [PS2]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
id|SKPCR_PMCLKEN
comma
dot
id|devid
op_assign
id|SA1111_DEVID_PS2
comma
dot
id|irq
op_assign
(brace
id|IRQ_MSRXINT
comma
id|IRQ_MSTXINT
)brace
comma
)brace
suffix:semicolon
DECL|variable|int_dev
r_static
r_struct
id|sa1111_dev
id|int_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [Interrupt Controller]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
l_int|0
comma
dot
id|devid
op_assign
id|SA1111_DEVID_INT
comma
)brace
suffix:semicolon
DECL|variable|pcmcia_dev
r_static
r_struct
id|sa1111_dev
id|pcmcia_dev
op_assign
(brace
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111 [PCMCIA Controller]&quot;
comma
)brace
comma
dot
id|skpcr_mask
op_assign
l_int|0
comma
dot
id|devid
op_assign
id|SA1111_DEVID_PCMCIA
comma
dot
id|irq
op_assign
(brace
id|IRQ_S0_READY_NINT
comma
id|IRQ_S0_CD_VALID
comma
id|IRQ_S0_BVD1_STSCHG
comma
id|IRQ_S1_READY_NINT
comma
id|IRQ_S1_CD_VALID
comma
id|IRQ_S1_BVD1_STSCHG
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|sa1111_dev
op_star
id|devs
(braket
)braket
op_assign
(brace
op_amp
id|usb_dev
comma
op_amp
id|sac_dev
comma
op_amp
id|ssp_dev
comma
op_amp
id|kbd_dev
comma
op_amp
id|mse_dev
comma
op_amp
id|pcmcia_dev
comma
)brace
suffix:semicolon
DECL|variable|dev_offset
r_static
r_int
r_int
id|dev_offset
(braket
)braket
op_assign
(brace
id|SA1111_USB
comma
l_int|0x0600
comma
l_int|0x0800
comma
id|SA1111_KBD
comma
id|SA1111_MSE
comma
l_int|0x1800
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * SA1111 interrupt support.  Since clearing an IRQ while there are&n; * active IRQs causes the interrupt output to pulse, the upper levels&n; * will call us again if there are more interrupts to process.&n; */
r_static
r_void
DECL|function|sa1111_irq_handler
id|sa1111_irq_handler
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqdesc
op_star
id|desc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|stat0
comma
id|stat1
comma
id|i
suffix:semicolon
id|stat0
op_assign
id|INTSTATCLR0
suffix:semicolon
id|stat1
op_assign
id|INTSTATCLR1
suffix:semicolon
id|INTSTATCLR0
op_assign
id|stat0
suffix:semicolon
id|desc-&gt;chip
op_member_access_from_pointer
id|ack
c_func
(paren
id|irq
)paren
suffix:semicolon
id|INTSTATCLR1
op_assign
id|stat1
suffix:semicolon
r_if
c_cond
(paren
id|stat0
op_eq
l_int|0
op_logical_and
id|stat1
op_eq
l_int|0
)paren
(brace
id|do_bad_IRQ
c_func
(paren
id|irq
comma
id|desc
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|IRQ_SA1111_START
suffix:semicolon
id|stat0
suffix:semicolon
id|i
op_increment
comma
id|stat0
op_rshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|stat0
op_amp
l_int|1
)paren
id|do_edge_IRQ
c_func
(paren
id|i
comma
id|irq_desc
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|IRQ_SA1111_START
op_plus
l_int|32
suffix:semicolon
id|stat1
suffix:semicolon
id|i
op_increment
comma
id|stat1
op_rshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|stat1
op_amp
l_int|1
)paren
id|do_edge_IRQ
c_func
(paren
id|i
comma
id|irq_desc
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* For level-based interrupts */
id|desc-&gt;chip
op_member_access_from_pointer
id|unmask
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|macro|SA1111_IRQMASK_LO
mdefine_line|#define SA1111_IRQMASK_LO(x)&t;(1 &lt;&lt; (x - IRQ_SA1111_START))
DECL|macro|SA1111_IRQMASK_HI
mdefine_line|#define SA1111_IRQMASK_HI(x)&t;(1 &lt;&lt; (x - IRQ_SA1111_START - 32))
DECL|function|sa1111_ack_irq
r_static
r_void
id|sa1111_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|sa1111_mask_lowirq
r_static
r_void
id|sa1111_mask_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN0
op_and_assign
op_complement
id|SA1111_IRQMASK_LO
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|sa1111_unmask_lowirq
r_static
r_void
id|sa1111_unmask_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN0
op_or_assign
id|SA1111_IRQMASK_LO
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to re-trigger the interrupt.  The SA1111 contains a register&n; * (INTSET) which claims to do this.  However, in practice no amount of&n; * manipulation of INTEN and INTSET guarantees that the interrupt will&n; * be triggered.  In fact, its very difficult, if not impossible to get&n; * INTSET to re-trigger the interrupt.&n; */
DECL|function|sa1111_rerun_lowirq
r_static
r_void
id|sa1111_rerun_lowirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_LO
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INTPOL0
op_xor_assign
id|mask
suffix:semicolon
id|INTPOL0
op_xor_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|INTSTATCLR1
op_amp
id|mask
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|8
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Danger Will Robinson: failed to &quot;
l_string|&quot;re-trigger IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|function|sa1111_type_lowirq
r_static
r_int
id|sa1111_type_lowirq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_LO
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|IRQT_PROBE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|flags
op_amp
id|__IRQT_RISEDGE
)paren
op_xor
op_logical_neg
(paren
id|flags
op_amp
id|__IRQT_FALEDGE
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|__IRQT_RISEDGE
)paren
id|INTPOL0
op_and_assign
op_complement
id|mask
suffix:semicolon
r_else
id|INTPOL0
op_or_assign
id|mask
suffix:semicolon
id|WAKE_POL0
op_assign
id|INTPOL0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1111_wake_lowirq
r_static
r_int
id|sa1111_wake_lowirq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|on
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_LO
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
id|WAKE_EN0
op_or_assign
id|mask
suffix:semicolon
r_else
id|WAKE_EN0
op_and_assign
op_complement
id|mask
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sa1111_low_chip
r_static
r_struct
id|irqchip
id|sa1111_low_chip
op_assign
(brace
dot
id|ack
op_assign
id|sa1111_ack_irq
comma
dot
id|mask
op_assign
id|sa1111_mask_lowirq
comma
dot
id|unmask
op_assign
id|sa1111_unmask_lowirq
comma
dot
id|rerun
op_assign
id|sa1111_rerun_lowirq
comma
dot
id|type
op_assign
id|sa1111_type_lowirq
comma
dot
id|wake
op_assign
id|sa1111_wake_lowirq
comma
)brace
suffix:semicolon
DECL|function|sa1111_mask_highirq
r_static
r_void
id|sa1111_mask_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN1
op_and_assign
op_complement
id|SA1111_IRQMASK_HI
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|sa1111_unmask_highirq
r_static
r_void
id|sa1111_unmask_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|INTEN1
op_or_assign
id|SA1111_IRQMASK_HI
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to re-trigger the interrupt.  The SA1111 contains a register&n; * (INTSET) which claims to do this.  However, in practice no amount of&n; * manipulation of INTEN and INTSET guarantees that the interrupt will&n; * be triggered.  In fact, its very difficult, if not impossible to get&n; * INTSET to re-trigger the interrupt.&n; */
DECL|function|sa1111_rerun_highirq
r_static
r_void
id|sa1111_rerun_highirq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_HI
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INTPOL1
op_xor_assign
id|mask
suffix:semicolon
id|INTPOL1
op_xor_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|INTSTATCLR1
op_amp
id|mask
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|8
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Danger Will Robinson: failed to &quot;
l_string|&quot;re-trigger IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|function|sa1111_type_highirq
r_static
r_int
id|sa1111_type_highirq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_HI
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|IRQT_PROBE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|flags
op_amp
id|__IRQT_RISEDGE
)paren
op_xor
op_logical_neg
(paren
id|flags
op_amp
id|__IRQT_FALEDGE
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|__IRQT_RISEDGE
)paren
id|INTPOL1
op_and_assign
op_complement
id|mask
suffix:semicolon
r_else
id|INTPOL1
op_or_assign
id|mask
suffix:semicolon
id|WAKE_POL1
op_assign
id|INTPOL1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1111_wake_highirq
r_static
r_int
id|sa1111_wake_highirq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|on
)paren
(brace
r_int
r_int
id|mask
op_assign
id|SA1111_IRQMASK_HI
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
id|WAKE_EN1
op_or_assign
id|mask
suffix:semicolon
r_else
id|WAKE_EN1
op_and_assign
op_complement
id|mask
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sa1111_high_chip
r_static
r_struct
id|irqchip
id|sa1111_high_chip
op_assign
(brace
dot
id|ack
op_assign
id|sa1111_ack_irq
comma
dot
id|mask
op_assign
id|sa1111_mask_highirq
comma
dot
id|unmask
op_assign
id|sa1111_unmask_highirq
comma
dot
id|rerun
op_assign
id|sa1111_rerun_highirq
comma
dot
id|type
op_assign
id|sa1111_type_highirq
comma
dot
id|wake
op_assign
id|sa1111_wake_highirq
comma
)brace
suffix:semicolon
DECL|function|sa1111_init_irq
r_static
r_void
id|__init
id|sa1111_init_irq
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_int
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re guaranteed that this region hasn&squot;t been taken.&n;&t; */
id|request_mem_region
c_func
(paren
id|sadev-&gt;res.start
comma
l_int|512
comma
l_string|&quot;irqs&quot;
)paren
suffix:semicolon
multiline_comment|/* disable all IRQs */
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTEN0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTEN1
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_WAKEEN0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_WAKEEN1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * detect on rising edge.  Note: Feb 2001 Errata for SA1111&n;&t; * specifies that S0ReadyInt and S1ReadyInt should be &squot;1&squot;.&n;&t; */
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTPOL0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|SA1111_IRQMASK_HI
c_func
(paren
id|IRQ_S0_READY_NINT
)paren
op_or
id|SA1111_IRQMASK_HI
c_func
(paren
id|IRQ_S1_READY_NINT
)paren
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTPOL1
)paren
suffix:semicolon
multiline_comment|/* clear all IRQs */
id|sa1111_writel
c_func
(paren
op_complement
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTSTATCLR0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
op_complement
l_int|0
comma
id|sadev-&gt;mapbase
op_plus
id|SA1111_INTSTATCLR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|IRQ_GPAIN0
suffix:semicolon
id|irq
op_le
id|SSPROR
suffix:semicolon
id|irq
op_increment
)paren
(brace
id|set_irq_chip
c_func
(paren
id|irq
comma
op_amp
id|sa1111_low_chip
)paren
suffix:semicolon
id|set_irq_handler
c_func
(paren
id|irq
comma
id|do_edge_IRQ
)paren
suffix:semicolon
id|set_irq_flags
c_func
(paren
id|irq
comma
id|IRQF_VALID
op_or
id|IRQF_PROBE
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|irq
op_assign
id|AUDXMTDMADONEA
suffix:semicolon
id|irq
op_le
id|IRQ_S1_BVD1_STSCHG
suffix:semicolon
id|irq
op_increment
)paren
(brace
id|set_irq_chip
c_func
(paren
id|irq
comma
op_amp
id|sa1111_high_chip
)paren
suffix:semicolon
id|set_irq_handler
c_func
(paren
id|irq
comma
id|do_edge_IRQ
)paren
suffix:semicolon
id|set_irq_flags
c_func
(paren
id|irq
comma
id|IRQF_VALID
op_or
id|IRQF_PROBE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register SA1111 interrupt&n;&t; */
id|set_irq_type
c_func
(paren
id|sadev-&gt;irq
(braket
l_int|0
)braket
comma
id|IRQT_RISING
)paren
suffix:semicolon
id|set_irq_chained_handler
c_func
(paren
id|sadev-&gt;irq
(braket
l_int|0
)braket
comma
id|sa1111_irq_handler
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bring the SA1111 out of reset.  This requires a set procedure:&n; *  1. nRESET asserted (by hardware)&n; *  2. CLK turned on from SA1110&n; *  3. nRESET deasserted&n; *  4. VCO turned on, PLL_BYPASS turned off&n; *  5. Wait lock time, then assert RCLKEn&n; *  7. PCR set to allow clocking of individual functions&n; *&n; * Until we&squot;ve done this, the only registers we can access are:&n; *   SBI_SKCR&n; *   SBI_SMCR&n; *   SBI_SKID&n; */
DECL|function|sa1111_wake
r_static
r_void
id|sa1111_wake
c_func
(paren
r_struct
id|sa1111
op_star
id|sachip
)paren
(brace
r_int
r_int
id|flags
comma
id|r
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First, set up the 3.6864MHz clock on GPIO 27 for the SA-1111:&n;&t; * (SA-1110 Developer&squot;s Manual, section 9.1.2.1)&n;&t; */
id|GAFR
op_or_assign
id|GPIO_32_768kHz
suffix:semicolon
id|GPDR
op_or_assign
id|GPIO_32_768kHz
suffix:semicolon
id|TUCR
op_assign
id|TUCR_3_6864MHz
suffix:semicolon
multiline_comment|/*&n;&t; * Turn VCO on, and disable PLL Bypass.&n;&t; */
id|r
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|r
op_and_assign
op_complement
id|SKCR_VCO_OFF
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|r
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|r
op_or_assign
id|SKCR_PLL_BYPASS
op_or
id|SKCR_OE_EN
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|r
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait lock time.  SA1111 manual _doesn&squot;t_&n;&t; * specify a figure for this!  We choose 100us.&n;&t; */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable RCLK.  We also ensure that RDYEN is set.&n;&t; */
id|r
op_or_assign
id|SKCR_RCLKEN
op_or
id|SKCR_RDYEN
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|r
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait 14 RCLK cycles for the chip to finish coming out&n;&t; * of reset. (RCLK=24MHz).  This is 590ns.&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure all clocks are initially off.&n;&t; */
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Configure the SA1111 shared memory controller.&n; */
r_void
DECL|function|sa1111_configure_smc
id|sa1111_configure_smc
c_func
(paren
r_struct
id|sa1111
op_star
id|sachip
comma
r_int
id|sdram
comma
r_int
r_int
id|drac
comma
r_int
r_int
id|cas_latency
)paren
(brace
r_int
r_int
id|smcr
op_assign
id|SMCR_DTIM
op_or
id|SMCR_MBGE
op_or
id|FInsrt
c_func
(paren
id|drac
comma
id|SMCR_DRAC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cas_latency
op_eq
l_int|3
)paren
id|smcr
op_or_assign
id|SMCR_CLAT
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|smcr
comma
id|sachip-&gt;base
op_plus
id|SA1111_SMCR
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sa1111_init_one_child
id|sa1111_init_one_child
c_func
(paren
r_struct
id|sa1111
op_star
id|sachip
comma
r_struct
id|sa1111_dev
op_star
id|sadev
comma
r_int
r_int
id|offset
)paren
(brace
id|snprintf
c_func
(paren
id|sadev-&gt;dev.bus_id
comma
r_sizeof
(paren
id|sadev-&gt;dev.bus_id
)paren
comma
l_string|&quot;%4.4x&quot;
comma
id|offset
)paren
suffix:semicolon
id|sadev-&gt;dev.parent
op_assign
id|sachip-&gt;dev
suffix:semicolon
id|sadev-&gt;dev.bus
op_assign
op_amp
id|sa1111_bus_type
suffix:semicolon
id|sadev-&gt;res.start
op_assign
id|sachip-&gt;res.start
op_plus
id|offset
suffix:semicolon
id|sadev-&gt;res.end
op_assign
id|sadev-&gt;res.start
op_plus
l_int|511
suffix:semicolon
id|sadev-&gt;res.name
op_assign
id|sadev-&gt;dev.name
suffix:semicolon
id|sadev-&gt;res.flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|sadev-&gt;mapbase
op_assign
id|sachip-&gt;base
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|sachip-&gt;res
comma
op_amp
id|sadev-&gt;res
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SA1111: failed to allocate resource for %s&bslash;n&quot;
comma
id|sadev-&gt;res.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|device_register
c_func
(paren
op_amp
id|sadev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_probe - probe for a single SA1111 chip.&n; *&t;@phys_addr: physical address of device.&n; *&n; *&t;Probe for a SA1111 chip.  This must be called&n; *&t;before any other SA1111-specific code.&n; *&n; *&t;Returns:&n; *&t;%-ENODEV&t;device not found.&n; *&t;%-EBUSY&t;&t;physical address already marked in-use.&n; *&t;%0&t;&t;successful.&n; */
r_static
r_int
id|__init
DECL|function|__sa1111_probe
id|__sa1111_probe
c_func
(paren
r_struct
id|device
op_star
id|me
comma
r_int
r_int
id|phys_addr
comma
r_int
id|irq
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
suffix:semicolon
r_int
r_int
id|id
suffix:semicolon
r_int
r_int
id|has_devs
comma
id|val
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|sachip
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sa1111
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sachip
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|sachip
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sa1111
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sachip-&gt;lock
)paren
suffix:semicolon
id|sachip-&gt;dev
op_assign
id|me
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|sachip-&gt;dev
comma
id|sachip
)paren
suffix:semicolon
id|sachip-&gt;res.name
op_assign
id|me-&gt;name
suffix:semicolon
id|sachip-&gt;res.start
op_assign
id|phys_addr
suffix:semicolon
id|sachip-&gt;res.end
op_assign
id|phys_addr
op_plus
l_int|0x2000
suffix:semicolon
id|sachip-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|sachip-&gt;res
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Map the whole region.  This also maps the&n;&t; * registers for our children.&n;&t; */
id|sachip-&gt;base
op_assign
id|ioremap
c_func
(paren
id|phys_addr
comma
id|PAGE_SIZE
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sachip-&gt;base
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Probe for the chip.  Only touch the SBI registers.&n;&t; */
id|id
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_amp
id|SKID_ID_MASK
)paren
op_ne
id|SKID_SA1111_ID
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SA1111 not detected: ID = %08lx&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|unmap
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SA1111 Microprocessor Companion Chip: &quot;
l_string|&quot;silicon revision %lx, metal revision %lx&bslash;n&quot;
comma
(paren
id|id
op_amp
id|SKID_SIREV_MASK
)paren
op_rshift
l_int|4
comma
(paren
id|id
op_amp
id|SKID_MTREV_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We found it.  Wake the chip up, and initialise.&n;&t; */
id|sa1111_wake
c_func
(paren
id|sachip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The SDRAM configuration of the SA1110 and the SA1111 must&n;&t; * match.  This is very important to ensure that SA1111 accesses&n;&t; * don&squot;t corrupt the SDRAM.  Note that this ungates the SA1111&squot;s&n;&t; * MBGNT signal, so we must have called sa1110_mb_disable()&n;&t; * beforehand.&n;&t; */
id|sa1111_configure_smc
c_func
(paren
id|sachip
comma
l_int|1
comma
id|FExtr
c_func
(paren
id|MDCNFG
comma
id|MDCNFG_SA1110_DRAC0
)paren
comma
id|FExtr
c_func
(paren
id|MDCNFG
comma
id|MDCNFG_SA1110_TDL0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only need to turn on DCLK whenever we want to use the&n;&t; * DMA.  It can otherwise be held firmly in the off position.&n;&t; * (currently, we always enable it.)&n;&t; */
id|val
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|val
op_or
id|SKPCR_DCLKEN
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the SA1110 memory bus request and grant signals.&n;&t; */
id|sa1110_mb_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The interrupt controller must be initialised before any&n;&t; * other device to ensure that the interrupts are available.&n;&t; */
id|int_dev.irq
(braket
l_int|0
)braket
op_assign
id|irq
suffix:semicolon
id|sa1111_init_one_child
c_func
(paren
id|sachip
comma
op_amp
id|int_dev
comma
id|SA1111_INTC
)paren
suffix:semicolon
id|sa1111_init_irq
c_func
(paren
op_amp
id|int_dev
)paren
suffix:semicolon
id|g_sa1111
op_assign
id|sachip
suffix:semicolon
id|has_devs
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_assabet
c_func
(paren
)paren
op_logical_or
id|machine_is_jornada720
c_func
(paren
)paren
op_logical_or
id|machine_is_badge4
c_func
(paren
)paren
)paren
id|has_devs
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
r_else
id|has_devs
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|devs
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|has_devs
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|sa1111_init_one_child
c_func
(paren
id|sachip
comma
id|devs
(braket
id|i
)braket
comma
id|dev_offset
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unmap
suffix:colon
id|iounmap
c_func
(paren
id|sachip-&gt;base
)paren
suffix:semicolon
id|release
suffix:colon
id|release_resource
c_func
(paren
op_amp
id|sachip-&gt;res
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|sachip
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__sa1111_remove
r_static
r_void
id|__sa1111_remove
c_func
(paren
r_struct
id|sa1111
op_star
id|sachip
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|devs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|put_device
c_func
(paren
op_amp
id|devs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
suffix:semicolon
id|release_resource
c_func
(paren
op_amp
id|devs
(braket
id|i
)braket
op_member_access_from_pointer
id|res
)paren
suffix:semicolon
)brace
id|iounmap
c_func
(paren
id|sachip-&gt;base
)paren
suffix:semicolon
id|release_resource
c_func
(paren
op_amp
id|sachip-&gt;res
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sachip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * According to the &quot;Intel StrongARM SA-1111 Microprocessor Companion&n; * Chip Specification Update&quot; (June 2000), erratum #7, there is a&n; * significant bug in the SA1111 SDRAM shared memory controller.  If&n; * an access to a region of memory above 1MB relative to the bank base,&n; * it is important that address bit 10 _NOT_ be asserted. Depending&n; * on the configuration of the RAM, bit 10 may correspond to one&n; * of several different (processor-relative) address bits.&n; *&n; * This routine only identifies whether or not a given DMA address&n; * is susceptible to the bug.&n; */
DECL|function|sa1111_check_dma_bug
r_int
id|sa1111_check_dma_bug
c_func
(paren
id|dma_addr_t
id|addr
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|g_sa1111
suffix:semicolon
r_int
r_int
id|physaddr
op_assign
id|SA1111_DMA_ADDR
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
r_int
r_int
id|smcr
suffix:semicolon
multiline_comment|/* Section 4.6 of the &quot;Intel StrongARM SA-1111 Development Module&n;&t; * User&squot;s Guide&quot; mentions that jumpers R51 and R52 control the&n;&t; * target of SA-1111 DMA (either SDRAM bank 0 on Assabet, or&n;&t; * SDRAM bank 1 on Neponset). The default configuration selects&n;&t; * Assabet, so any address in bank 1 is necessarily invalid.&n;&t; */
r_if
c_cond
(paren
(paren
id|machine_is_assabet
c_func
(paren
)paren
op_logical_or
id|machine_is_pfs168
c_func
(paren
)paren
)paren
op_logical_and
id|addr
op_ge
l_int|0xc8000000
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* The bug only applies to buffers located more than one megabyte&n;&t; * above the start of the target bank:&n;&t; */
r_if
c_cond
(paren
id|physaddr
OL
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|smcr
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SMCR
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|FExtr
c_func
(paren
id|smcr
comma
id|SMCR_DRAC
)paren
)paren
(brace
r_case
l_int|01
suffix:colon
multiline_comment|/* 10 row + bank address bits, A&lt;20&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|02
suffix:colon
multiline_comment|/* 11 row + bank address bits, A&lt;23&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|23
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|03
suffix:colon
multiline_comment|/* 12 row + bank address bits, A&lt;24&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|24
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|04
suffix:colon
multiline_comment|/* 13 row + bank address bits, A&lt;25&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|25
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|05
suffix:colon
multiline_comment|/* 14 row + bank address bits, A&lt;20&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|06
suffix:colon
multiline_comment|/* 15 row + bank address bits, A&lt;20&gt; must not be set */
r_if
c_cond
(paren
id|physaddr
op_amp
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(): invalid SMCR DRAC value 0%lo&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|FExtr
c_func
(paren
id|smcr
comma
id|SMCR_DRAC
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|sa1111_save_data
r_struct
id|sa1111_save_data
(brace
DECL|member|skcr
r_int
r_int
id|skcr
suffix:semicolon
DECL|member|skpcr
r_int
r_int
id|skpcr
suffix:semicolon
DECL|member|skcdr
r_int
r_int
id|skcdr
suffix:semicolon
DECL|member|skaud
r_int
r_char
id|skaud
suffix:semicolon
DECL|member|skpwm0
r_int
r_char
id|skpwm0
suffix:semicolon
DECL|member|skpwm1
r_int
r_char
id|skpwm1
suffix:semicolon
multiline_comment|/*&n;&t; * Interrupt controller&n;&t; */
DECL|member|intpol0
r_int
r_int
id|intpol0
suffix:semicolon
DECL|member|intpol1
r_int
r_int
id|intpol1
suffix:semicolon
DECL|member|inten0
r_int
r_int
id|inten0
suffix:semicolon
DECL|member|inten1
r_int
r_int
id|inten1
suffix:semicolon
DECL|member|wakepol0
r_int
r_int
id|wakepol0
suffix:semicolon
DECL|member|wakepol1
r_int
r_int
id|wakepol1
suffix:semicolon
DECL|member|wakeen0
r_int
r_int
id|wakeen0
suffix:semicolon
DECL|member|wakeen1
r_int
r_int
id|wakeen1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|sa1111_suspend
r_static
r_int
id|sa1111_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
multiline_comment|/*&n;&t; * Save state.&n;&t; */
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_SAVE_STATE
op_logical_or
id|level
op_eq
id|SUSPEND_DISABLE
op_logical_or
id|level
op_eq
id|SUSPEND_POWER_DOWN
)paren
(brace
r_struct
id|sa1111_save_data
op_star
id|save
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;saved_state
)paren
id|dev-&gt;saved_state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sa1111_save_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;saved_state
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|save
op_assign
(paren
r_struct
id|sa1111_save_data
op_star
)paren
id|dev-&gt;saved_state
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|base
op_assign
id|sachip-&gt;base
suffix:semicolon
id|save-&gt;skcr
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|save-&gt;skpcr
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|save-&gt;skcdr
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKCDR
)paren
suffix:semicolon
id|save-&gt;skaud
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKAUD
)paren
suffix:semicolon
id|save-&gt;skpwm0
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKPWM0
)paren
suffix:semicolon
id|save-&gt;skpwm1
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKPWM1
)paren
suffix:semicolon
id|base
op_assign
id|sachip-&gt;base
op_plus
id|SA1111_INTC
suffix:semicolon
id|save-&gt;intpol0
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_INTPOL0
)paren
suffix:semicolon
id|save-&gt;intpol1
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_INTPOL1
)paren
suffix:semicolon
id|save-&gt;inten0
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_INTEN0
)paren
suffix:semicolon
id|save-&gt;inten1
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_INTEN1
)paren
suffix:semicolon
id|save-&gt;wakepol0
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_WAKEPOL0
)paren
suffix:semicolon
id|save-&gt;wakepol1
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_WAKEPOL1
)paren
suffix:semicolon
id|save-&gt;wakeen0
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_WAKEEN0
)paren
suffix:semicolon
id|save-&gt;wakeen1
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_WAKEEN1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable.&n;&t; */
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_DISABLE
op_logical_and
id|state
op_eq
l_int|4
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|base
op_assign
id|sachip-&gt;base
suffix:semicolon
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|base
op_plus
id|SA1111_SKPWM0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
l_int|0
comma
id|base
op_plus
id|SA1111_SKPWM1
)paren
suffix:semicolon
id|val
op_assign
id|sa1111_readl
c_func
(paren
id|base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|val
op_or
id|SKCR_SLEEP
comma
id|base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;sa1111_resume - Restore the SA1111 device state.&n; *&t;@dev: device to restore&n; *&t;@level: resume level&n; *&n; *&t;Restore the general state of the SA1111; clock control and&n; *&t;interrupt controller.  Other parts of the SA1111 must be&n; *&t;restored by their respective drivers, and must be called&n; *&t;via LDM after this function.&n; */
DECL|function|sa1111_resume
r_static
r_int
id|sa1111_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|sa1111_save_data
op_star
id|save
suffix:semicolon
r_int
r_int
id|flags
comma
id|id
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|RESUME_RESTORE_STATE
op_logical_and
id|level
op_ne
id|RESUME_ENABLE
)paren
r_return
l_int|0
suffix:semicolon
id|save
op_assign
(paren
r_struct
id|sa1111_save_data
op_star
)paren
id|dev-&gt;saved_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|save
)paren
r_return
l_int|0
suffix:semicolon
id|dev-&gt;saved_state
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the SA1111 is still here.&n;&t; */
id|id
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_amp
id|SKID_ID_MASK
)paren
op_ne
id|SKID_SA1111_ID
)paren
(brace
id|__sa1111_remove
c_func
(paren
id|sachip
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|save
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|sa1111_wake
c_func
(paren
id|sachip
)paren
suffix:semicolon
id|base
op_assign
id|sachip-&gt;base
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skcr
comma
id|base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skpcr
comma
id|base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skcdr
comma
id|base
op_plus
id|SA1111_SKCDR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skaud
comma
id|base
op_plus
id|SA1111_SKAUD
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skpwm0
comma
id|base
op_plus
id|SA1111_SKPWM0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;skpwm1
comma
id|base
op_plus
id|SA1111_SKPWM1
)paren
suffix:semicolon
id|base
op_assign
id|sachip-&gt;base
op_plus
id|SA1111_INTC
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;intpol0
comma
id|base
op_plus
id|SA1111_INTPOL0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;intpol1
comma
id|base
op_plus
id|SA1111_INTPOL1
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;inten0
comma
id|base
op_plus
id|SA1111_INTEN0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;inten1
comma
id|base
op_plus
id|SA1111_INTEN1
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;wakepol0
comma
id|base
op_plus
id|SA1111_WAKEPOL0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;wakepol1
comma
id|base
op_plus
id|SA1111_WAKEPOL1
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;wakeen0
comma
id|base
op_plus
id|SA1111_WAKEEN0
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|save-&gt;wakeen1
comma
id|base
op_plus
id|SA1111_WAKEEN1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|save
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1111_probe
r_static
r_int
id|sa1111_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|sa1111_remove
r_static
r_int
id|sa1111_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sachip
)paren
(brace
id|__sa1111_remove
c_func
(paren
id|sachip
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;saved_state
)paren
suffix:semicolon
id|dev-&gt;saved_state
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Not sure if this should be on the system bus or not yet.&n; *&t;We really want some way to register a system device at&n; *&t;the per-machine level, and then have this driver pick&n; *&t;up the registered devices.&n; *&n; *&t;We also need to handle the SDRAM configuration for&n; *&t;PXA250/SA1110 machine classes.&n; */
DECL|variable|sa1111_device_driver
r_static
r_struct
id|device_driver
id|sa1111_device_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;sa1111&quot;
comma
dot
id|bus
op_assign
op_amp
id|system_bus_type
comma
dot
id|probe
op_assign
id|sa1111_probe
comma
dot
id|remove
op_assign
id|sa1111_remove
comma
dot
id|suspend
op_assign
id|sa1111_suspend
comma
dot
id|resume
op_assign
id|sa1111_resume
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Register the SA1111 driver with LDM.&n; */
DECL|function|sa1111_driver_init
r_static
r_int
id|sa1111_driver_init
c_func
(paren
r_void
)paren
(brace
id|driver_register
c_func
(paren
op_amp
id|sa1111_device_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sa1111_driver_init
id|arch_initcall
c_func
(paren
id|sa1111_driver_init
)paren
suffix:semicolon
DECL|variable|sa1111_device
r_static
r_struct
id|sys_device
id|sa1111_device
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;SA1111&quot;
comma
dot
id|id
op_assign
l_int|0
comma
dot
id|root
op_assign
l_int|NULL
comma
dot
id|dev
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Intel Corporation SA1111&quot;
comma
dot
id|driver
op_assign
op_amp
id|sa1111_device_driver
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|sa1111_init
r_int
id|sa1111_init
c_func
(paren
r_int
r_int
id|phys
comma
r_int
r_int
id|irq
)paren
(brace
r_int
id|ret
suffix:semicolon
id|snprintf
c_func
(paren
id|sa1111_device.dev.bus_id
comma
r_sizeof
(paren
id|sa1111_device.dev.bus_id
)paren
comma
l_string|&quot;%8.8lx&quot;
comma
id|phys
)paren
suffix:semicolon
id|ret
op_assign
id|sys_device_register
c_func
(paren
op_amp
id|sa1111_device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;sa1111 device_register failed: %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|__sa1111_probe
c_func
(paren
op_amp
id|sa1111_device.dev
comma
id|phys
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get the parent device driver (us) structure&n; *&t;from a child function device&n; */
DECL|function|sa1111_chip_driver
r_static
r_inline
r_struct
id|sa1111
op_star
id|sa1111_chip_driver
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_return
(paren
r_struct
id|sa1111
op_star
)paren
id|dev_get_drvdata
c_func
(paren
id|sadev-&gt;dev.parent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The bits in the opdiv field are non-linear.&n; */
DECL|variable|opdiv_table
r_static
r_int
r_char
id|opdiv_table
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|4
comma
l_int|2
comma
l_int|8
)brace
suffix:semicolon
DECL|function|__sa1111_pll_clock
r_static
r_int
r_int
id|__sa1111_pll_clock
c_func
(paren
r_struct
id|sa1111
op_star
id|sachip
)paren
(brace
r_int
r_int
id|skcdr
comma
id|fbdiv
comma
id|ipdiv
comma
id|opdiv
suffix:semicolon
id|skcdr
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKCDR
)paren
suffix:semicolon
id|fbdiv
op_assign
(paren
id|skcdr
op_amp
l_int|0x007f
)paren
op_plus
l_int|2
suffix:semicolon
id|ipdiv
op_assign
(paren
(paren
id|skcdr
op_amp
l_int|0x0f80
)paren
op_rshift
l_int|7
)paren
op_plus
l_int|2
suffix:semicolon
id|opdiv
op_assign
id|opdiv_table
(braket
(paren
id|skcdr
op_amp
l_int|0x3000
)paren
op_rshift
l_int|12
)braket
suffix:semicolon
r_return
l_int|3686400
op_star
id|fbdiv
op_div
(paren
id|ipdiv
op_star
id|opdiv
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_pll_clock - return the current PLL clock frequency.&n; *&t;@sadev: SA1111 function block&n; *&n; *&t;BUG: we should look at SKCR.  We also blindly believe that&n; *&t;the chip is being fed with the 3.6864MHz clock.&n; *&n; *&t;Returns the PLL clock in Hz.&n; */
DECL|function|sa1111_pll_clock
r_int
r_int
id|sa1111_pll_clock
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_return
id|__sa1111_pll_clock
c_func
(paren
id|sachip
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_select_audio_mode - select I2S or AC link mode&n; *&t;@sadev: SA1111 function block&n; *&t;@mode: One of %SA1111_AUDIO_ACLINK or %SA1111_AUDIO_I2S&n; *&n; *&t;Frob the SKCR to select AC Link mode or I2S mode for&n; *&t;the audio block.&n; */
DECL|function|sa1111_select_audio_mode
r_void
id|sa1111_select_audio_mode
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
comma
r_int
id|mode
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|SA1111_AUDIO_I2S
)paren
(brace
id|val
op_and_assign
op_complement
id|SKCR_SELAC
suffix:semicolon
)brace
r_else
(brace
id|val
op_or_assign
id|SKCR_SELAC
suffix:semicolon
)brace
id|sa1111_writel
c_func
(paren
id|val
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKCR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_set_audio_rate - set the audio sample rate&n; *&t;@sadev: SA1111 SAC function block&n; *&t;@rate: sample rate to select&n; */
DECL|function|sa1111_set_audio_rate
r_int
id|sa1111_set_audio_rate
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
comma
r_int
id|rate
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_int
r_int
id|div
suffix:semicolon
r_if
c_cond
(paren
id|sadev-&gt;devid
op_ne
id|SA1111_DEVID_SAC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|div
op_assign
(paren
id|__sa1111_pll_clock
c_func
(paren
id|sachip
)paren
op_div
l_int|256
op_plus
id|rate
op_div
l_int|2
)paren
op_div
id|rate
suffix:semicolon
r_if
c_cond
(paren
id|div
op_eq
l_int|0
)paren
id|div
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|div
OG
l_int|128
)paren
id|div
op_assign
l_int|128
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|div
op_minus
l_int|1
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKAUD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_get_audio_rate - get the audio sample rate&n; *&t;@sadev: SA1111 SAC function block device&n; */
DECL|function|sa1111_get_audio_rate
r_int
id|sa1111_get_audio_rate
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_int
r_int
id|div
suffix:semicolon
r_if
c_cond
(paren
id|sadev-&gt;devid
op_ne
id|SA1111_DEVID_SAC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|div
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKAUD
)paren
op_plus
l_int|1
suffix:semicolon
r_return
id|__sa1111_pll_clock
c_func
(paren
id|sachip
)paren
op_div
(paren
l_int|256
op_star
id|div
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Individual device operations.&n; */
multiline_comment|/**&n; *&t;sa1111_enable_device - enable an on-chip SA1111 function block&n; *&t;@sadev: SA1111 function block device to enable&n; */
DECL|function|sa1111_enable_device
r_void
id|sa1111_enable_device
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|val
op_or
id|sadev-&gt;skpcr_mask
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sa1111_disable_device - disable an on-chip SA1111 function block&n; *&t;@sadev: SA1111 function block device to disable&n; */
DECL|function|sa1111_disable_device
r_void
id|sa1111_disable_device
c_func
(paren
r_struct
id|sa1111_dev
op_star
id|sadev
)paren
(brace
r_struct
id|sa1111
op_star
id|sachip
op_assign
id|sa1111_chip_driver
c_func
(paren
id|sadev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|sa1111_readl
c_func
(paren
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|sa1111_writel
c_func
(paren
id|val
op_amp
op_complement
id|sadev-&gt;skpcr_mask
comma
id|sachip-&gt;base
op_plus
id|SA1111_SKPCR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sachip-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SA1111 &quot;Register Access Bus.&quot;&n; *&n; *&t;We model this as a regular bus type, and hang devices directly&n; *&t;off this.&n; */
DECL|function|sa1111_match
r_static
r_int
id|sa1111_match
c_func
(paren
r_struct
id|device
op_star
id|_dev
comma
r_struct
id|device_driver
op_star
id|_drv
)paren
(brace
r_struct
id|sa1111_dev
op_star
id|dev
op_assign
id|SA1111_DEV
c_func
(paren
id|_dev
)paren
suffix:semicolon
r_struct
id|sa1111_driver
op_star
id|drv
op_assign
id|SA1111_DRV
c_func
(paren
id|_drv
)paren
suffix:semicolon
r_return
id|dev-&gt;devid
op_eq
id|drv-&gt;devid
suffix:semicolon
)brace
DECL|variable|sa1111_bus_type
r_struct
id|bus_type
id|sa1111_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;RAB&quot;
comma
dot
id|match
op_assign
id|sa1111_match
comma
)brace
suffix:semicolon
DECL|function|sa1111_rab_bus_init
r_static
r_int
id|sa1111_rab_bus_init
c_func
(paren
r_void
)paren
(brace
r_return
id|bus_register
c_func
(paren
op_amp
id|sa1111_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sa1111_rab_bus_init
id|postcore_initcall
c_func
(paren
id|sa1111_rab_bus_init
)paren
suffix:semicolon
DECL|variable|sa1111_check_dma_bug
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_check_dma_bug
)paren
suffix:semicolon
DECL|variable|sa1111_select_audio_mode
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_select_audio_mode
)paren
suffix:semicolon
DECL|variable|sa1111_set_audio_rate
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_set_audio_rate
)paren
suffix:semicolon
DECL|variable|sa1111_get_audio_rate
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_get_audio_rate
)paren
suffix:semicolon
DECL|variable|sa1111_enable_device
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_enable_device
)paren
suffix:semicolon
DECL|variable|sa1111_disable_device
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_disable_device
)paren
suffix:semicolon
DECL|variable|sa1111_pll_clock
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_pll_clock
)paren
suffix:semicolon
DECL|variable|sa1111_bus_type
id|EXPORT_SYMBOL
c_func
(paren
id|sa1111_bus_type
)paren
suffix:semicolon
eof
