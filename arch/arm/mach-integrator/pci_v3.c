multiline_comment|/*&n; *  linux/arch/arm/mach-integrator/pci_v3.c&n; *&n; *  PCI functions for V3 host PCI bridge&n; *&n; *  Copyright (C) 1999 ARM Limited&n; *  Copyright (C) 2000 Deep Blue Solutions Ltd&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mach/pci.h&gt;
macro_line|#include &lt;asm/hardware/pci_v3.h&gt;
multiline_comment|/*&n; * The V3 PCI interface chip in Integrator provides several windows from&n; * local bus memory into the PCI memory areas.   Unfortunately, there&n; * are not really enough windows for our usage, therefore we reuse &n; * one of the windows for access to PCI configuration space.  The&n; * memory map is as follows:&n; * &n; * Local Bus Memory         Usage&n; * &n; * 40000000 - 4FFFFFFF      PCI memory.  256M non-prefetchable&n; * 50000000 - 5FFFFFFF      PCI memory.  256M prefetchable&n; * 60000000 - 60FFFFFF      PCI IO.  16M&n; * 68000000 - 68FFFFFF      PCI Configuration. 16M&n; * &n; * There are three V3 windows, each described by a pair of V3 registers.&n; * These are LB_BASE0/LB_MAP0, LB_BASE1/LB_MAP1 and LB_BASE2/LB_MAP2.&n; * Base0 and Base1 can be used for any type of PCI memory access.   Base2&n; * can be used either for PCI I/O or for I20 accesses.  By default, uHAL&n; * uses this only for PCI IO space.&n; * &n; * PCI Memory is mapped so that assigned addresses in PCI Memory match&n; * local bus memory addresses.  In other words, if a PCI device is assigned&n; * address 80200000 then that address is a valid local bus address as well&n; * as a valid PCI Memory address.  PCI IO addresses are mapped to start&n; * at zero.  This means that local bus address 60000000 maps to PCI IO address&n; * 00000000 and so on.   Device driver writers need to be aware of this &n; * distinction.&n; * &n; * Normally these spaces are mapped using the following base registers:&n; * &n; * Usage Local Bus Memory         Base/Map registers used&n; * &n; * Mem   40000000 - 4FFFFFFF      LB_BASE0/LB_MAP0&n; * Mem   50000000 - 5FFFFFFF      LB_BASE1/LB_MAP1&n; * IO    60000000 - 60FFFFFF      LB_BASE2/LB_MAP2&n; * Cfg   68000000 - 68FFFFFF      &n; * &n; * This means that I20 and PCI configuration space accesses will fail.&n; * When PCI configuration accesses are needed (via the uHAL PCI &n; * configuration space primitives) we must remap the spaces as follows:&n; * &n; * Usage Local Bus Memory         Base/Map registers used&n; * &n; * Mem   40000000 - 4FFFFFFF      LB_BASE0/LB_MAP0&n; * Mem   50000000 - 5FFFFFFF      LB_BASE0/LB_MAP0&n; * IO    60000000 - 60FFFFFF      LB_BASE2/LB_MAP2&n; * Cfg   68000000 - 68FFFFFF      LB_BASE1/LB_MAP1&n; * &n; * To make this work, the code depends on overlapping windows working.&n; * The V3 chip translates an address by checking its range within &n; * each of the BASE/MAP pairs in turn (in ascending register number&n; * order).  It will use the first matching pair.   So, for example,&n; * if the same address is mapped by both LB_BASE0/LB_MAP0 and&n; * LB_BASE1/LB_MAP1, the V3 will use the translation from &n; * LB_BASE0/LB_MAP0.&n; * &n; * To allow PCI Configuration space access, the code enlarges the&n; * window mapped by LB_BASE0/LB_MAP0 from 256M to 512M.  This occludes&n; * the windows currently mapped by LB_BASE1/LB_MAP1 so that it can&n; * be remapped for use by configuration cycles.&n; * &n; * At the end of the PCI Configuration space accesses, &n; * LB_BASE1/LB_MAP1 is reset to map PCI Memory.  Finally the window&n; * mapped by LB_BASE0/LB_MAP0 is reduced in size from 512M to 256M to&n; * reveal the now restored LB_BASE1/LB_MAP1 window.&n; * &n; * NOTE: We do not set up I2O mapping.  I suspect that this is only&n; * for an intelligent (target) device.  Using I2O disables most of&n; * the mappings into PCI memory.&n; */
singleline_comment|// V3 access routines
DECL|macro|_V3Write16
mdefine_line|#define _V3Write16(o,v) __raw_writew(v, PCI_V3_VADDR + (unsigned int)(o))
DECL|macro|_V3Read16
mdefine_line|#define _V3Read16(o)    (__raw_readw(PCI_V3_VADDR + (unsigned int)(o)))
DECL|macro|_V3Write32
mdefine_line|#define _V3Write32(o,v) __raw_writel(v, PCI_V3_VADDR + (unsigned int)(o))
DECL|macro|_V3Read32
mdefine_line|#define _V3Read32(o)    (__raw_readl(PCI_V3_VADDR + (unsigned int)(o)))
multiline_comment|/*============================================================================&n; *&n; * routine:&t;uHALir_PCIMakeConfigAddress()&n; *&n; * parameters:&t;bus = which bus&n; *              device = which device&n; *              function = which function&n; *&t;&t;offset = configuration space register we are interested in&n; *&n; * description:&t;this routine will generate a platform dependant config&n; *&t;&t;address.&n; *&n; * calls:&t;none&n; *&n; * returns:&t;configuration address to play on the PCI bus&n; *&n; * To generate the appropriate PCI configuration cycles in the PCI &n; * configuration address space, you present the V3 with the following pattern &n; * (which is very nearly a type 1 (except that the lower two bits are 00 and&n; * not 01).   In order for this mapping to work you need to set up one of&n; * the local to PCI aperatures to 16Mbytes in length translating to&n; * PCI configuration space starting at 0x0000.0000.&n; *&n; * PCI configuration cycles look like this:&n; *&n; * Type 0:&n; *&n; *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 &n; *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; *&n; *&t;31:11&t;Device select bit.&n; * &t;10:8&t;Function number&n; * &t; 7:2&t;Register number&n; *&n; * Type 1:&n; *&n; *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 &n; *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; *&n; *&t;31:24&t;reserved&n; *&t;23:16&t;bus number (8 bits = 128 possible buses)&n; *&t;15:11&t;Device number (5 bits)&n; *&t;10:8&t;function number&n; *&t; 7:2&t;register number&n; *  &n; */
DECL|variable|v3_lock
r_static
id|spinlock_t
id|v3_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|PCI_BUS_NONMEM_START
mdefine_line|#define PCI_BUS_NONMEM_START&t;0x00000000
DECL|macro|PCI_BUS_NONMEM_SIZE
mdefine_line|#define PCI_BUS_NONMEM_SIZE&t;0x10000000
DECL|macro|PCI_BUS_PREMEM_START
mdefine_line|#define PCI_BUS_PREMEM_START&t;0x10000000
DECL|macro|PCI_BUS_PREMEM_SIZE
mdefine_line|#define PCI_BUS_PREMEM_SIZE&t;0x10000000
macro_line|#if PCI_BUS_NONMEM_START &amp; 0x000fffff
macro_line|#error PCI_BUS_NONMEM_START must be megabyte aligned
macro_line|#endif
macro_line|#if PCI_BUS_PREMEM_START &amp; 0x000fffff
macro_line|#error PCI_BUS_PREMEM_START must be megabyte aligned
macro_line|#endif
DECL|function|v3_open_config_window
r_static
r_int
r_int
id|v3_open_config_window
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
)paren
(brace
r_int
r_int
id|address
comma
id|mapaddress
comma
id|busnr
suffix:semicolon
id|busnr
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
multiline_comment|/*&n;&t; * Trap out illegal values&n;&t; */
r_if
c_cond
(paren
id|offset
OG
l_int|255
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busnr
OG
l_int|255
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;devfn
OG
l_int|255
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busnr
op_eq
l_int|0
)paren
(brace
r_int
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * local bus segment so need a type 0 config cycle&n;&t;&t; *&n;&t;&t; * build the PCI configuration &quot;address&quot; with one-hot in&n;&t;&t; * A31-A11&n;&t;&t; *&n;&t;&t; * mapaddress:&n;&t;&t; *  3:1 = config cycle (101)&n;&t;&t; *  0   = PCI A1 &amp; A0 are 0 (0)&n;&t;&t; */
id|address
op_assign
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_lshift
l_int|8
suffix:semicolon
id|mapaddress
op_assign
l_int|0x0a
suffix:semicolon
r_if
c_cond
(paren
id|slot
OG
l_int|12
)paren
multiline_comment|/*&n;&t;&t;&t; * high order bits are handled by the MAP register&n;&t;&t;&t; */
id|mapaddress
op_or_assign
l_int|1
op_lshift
(paren
id|slot
op_minus
l_int|4
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t; * low order bits handled directly in the address&n;&t;&t;&t; */
id|address
op_or_assign
l_int|1
op_lshift
(paren
id|slot
op_plus
l_int|11
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * not the local bus segment so need a type 1 config cycle&n;&t;&t; *&n;&t;&t; * address:&n;&t;&t; *  23:16 = bus number&n;&t;&t; *  15:11 = slot number (7:3 of devfn)&n;&t;&t; *  10:8  = func number (2:0 of devfn)&n;&t;&t; *&n;&t;&t; * mapaddress:&n;&t;&t; *  3:1 = config cycle (101)&n;&t;&t; *  0   = PCI A1 &amp; A0 from host bus (1)&n;&t;&t; */
id|mapaddress
op_assign
l_int|0x0b
suffix:semicolon
id|address
op_assign
(paren
id|busnr
op_lshift
l_int|16
)paren
op_or
(paren
id|dev-&gt;devfn
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up base0 to see all 512Mbytes of memory space (not prefetchable), this&n;&t; * frees up base1 for re-use by configuration memory&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE0
comma
(paren
id|PHYS_PCI_MEM_BASE
op_amp
l_int|0xFFF00000
)paren
op_or
l_int|0x90
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up base1/map1 to point into configuration space.&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE1
comma
(paren
id|PHYS_PCI_CONFIG_BASE
op_amp
l_int|0xFFF00000
)paren
op_or
l_int|0x40
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
id|_V3Write16
c_func
(paren
id|V3_LB_MAP1
comma
id|mapaddress
)paren
suffix:semicolon
r_return
id|PCI_CONFIG_VADDR
op_plus
id|address
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|v3_close_config_window
r_static
r_void
id|v3_close_config_window
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Reassign base1 for use by prefetchable PCI memory&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE1
comma
(paren
(paren
id|PHYS_PCI_MEM_BASE
op_plus
id|SZ_256M
)paren
op_amp
l_int|0xFFF00000
)paren
op_or
l_int|0x84
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
id|_V3Write16
c_func
(paren
id|V3_LB_MAP1
comma
(paren
(paren
id|PCI_BUS_PREMEM_START
op_amp
l_int|0xFFF00000
)paren
op_rshift
l_int|16
)paren
op_or
l_int|0x0006
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And shrink base0 back to a 256M window (NOTE: MAP0 already correct)&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE0
comma
(paren
id|PHYS_PCI_MEM_BASE
op_amp
l_int|0xFFF00000
)paren
op_or
l_int|0x80
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
)brace
DECL|function|v3_read_config_byte
r_static
r_int
id|v3_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u8
op_star
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|v
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|v
op_assign
id|__raw_readb
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|val
op_assign
id|v
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|v3_read_config_word
r_static
r_int
id|v3_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u16
op_star
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|v
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|v
op_assign
id|__raw_readw
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|val
op_assign
id|v
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|v3_read_config_dword
r_static
r_int
id|v3_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
op_star
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|v
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|v
op_assign
id|__raw_readl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|val
op_assign
id|v
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|v3_write_config_byte
r_static
r_int
id|v3_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u8
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|__raw_writeb
c_func
(paren
id|val
comma
id|addr
)paren
suffix:semicolon
id|__raw_readb
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|v3_write_config_word
r_static
r_int
id|v3_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u16
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|__raw_writew
c_func
(paren
id|val
comma
id|addr
)paren
suffix:semicolon
id|__raw_readw
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|v3_write_config_dword
r_static
r_int
id|v3_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|addr
op_assign
id|v3_open_config_window
c_func
(paren
id|dev
comma
id|where
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|val
comma
id|addr
)paren
suffix:semicolon
id|__raw_readl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|v3_close_config_window
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|variable|pci_v3_ops
r_static
r_struct
id|pci_ops
id|pci_v3_ops
op_assign
(brace
id|read_byte
suffix:colon
id|v3_read_config_byte
comma
id|read_word
suffix:colon
id|v3_read_config_word
comma
id|read_dword
suffix:colon
id|v3_read_config_dword
comma
id|write_byte
suffix:colon
id|v3_write_config_byte
comma
id|write_word
suffix:colon
id|v3_write_config_word
comma
id|write_dword
suffix:colon
id|v3_write_config_dword
comma
)brace
suffix:semicolon
DECL|variable|non_mem
r_static
r_struct
id|resource
id|non_mem
op_assign
(brace
id|name
suffix:colon
l_string|&quot;PCI non-prefetchable&quot;
comma
id|start
suffix:colon
id|PCI_BUS_NONMEM_START
comma
id|end
suffix:colon
id|PCI_BUS_NONMEM_START
op_plus
id|PCI_BUS_NONMEM_SIZE
op_minus
l_int|1
comma
id|flags
suffix:colon
id|IORESOURCE_MEM
comma
)brace
suffix:semicolon
DECL|variable|pre_mem
r_static
r_struct
id|resource
id|pre_mem
op_assign
(brace
id|name
suffix:colon
l_string|&quot;PCI prefetchable&quot;
comma
id|start
suffix:colon
id|PCI_BUS_PREMEM_START
comma
id|end
suffix:colon
id|PCI_BUS_PREMEM_START
op_plus
id|PCI_BUS_PREMEM_SIZE
op_minus
l_int|1
comma
id|flags
suffix:colon
id|IORESOURCE_MEM
op_or
id|IORESOURCE_PREFETCH
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * V3_LB_BASE? - local bus address&n; * V3_LB_MAP?  - pci bus address&n; */
DECL|function|pci_v3_init
r_void
id|__init
id|pci_v3_init
c_func
(paren
r_struct
id|arm_pci_sysdata
op_star
id|sysdata
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|pci_cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup window 0 - PCI non-prefetchable memory&n;&t; *  Local: 0x40000000 Bus: 0x00000000 Size: 256MB&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE0
comma
(paren
id|PHYS_PCI_MEM_BASE
op_amp
l_int|0xfff00000
)paren
op_or
l_int|0x80
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
id|_V3Write16
c_func
(paren
id|V3_LB_MAP0
comma
(paren
id|PCI_BUS_NONMEM_START
op_rshift
l_int|16
)paren
op_or
l_int|0x0006
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup window 1 - PCI prefetchable memory&n;&t; *  Local: 0x50000000 Bus: 0x10000000 Size: 256MB&n;&t; */
id|_V3Write32
c_func
(paren
id|V3_LB_BASE1
comma
(paren
(paren
id|PHYS_PCI_MEM_BASE
op_plus
id|SZ_256M
)paren
op_amp
l_int|0xFFF00000
)paren
op_or
l_int|0x84
op_or
id|V3_LB_BASE_M_ENABLE
)paren
suffix:semicolon
id|_V3Write16
c_func
(paren
id|V3_LB_MAP1
comma
(paren
id|PCI_BUS_PREMEM_START
op_rshift
l_int|16
)paren
op_or
l_int|0x0006
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup window 2 - PCI IO&n;&t; */
singleline_comment|//&t;_V3Write32(V3_LB_BASE2, (PHYS_PCI_IO_BASE &amp; 0xff000000) | V3_LB_BASE_M_ENABLE);
singleline_comment|//&t;_V3Write16(V3_LB_MAP2, 0);
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|v3_lock
comma
id|flags
)paren
suffix:semicolon
id|bus
op_assign
id|pci_scan_bus
c_func
(paren
l_int|0
comma
op_amp
id|pci_v3_ops
comma
id|sysdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|non_mem
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;PCI: unable to allocate non-prefetchable memory region&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|pre_mem
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;PCI: unable to allocate prefetchable memory region&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bus-&gt;resource[0] is the IO resource for this bus&n;&t; * bus-&gt;resource[1] is the mem resource for this bus&n;&t; * bus-&gt;resource[2] is the prefetch mem resource for this bus&n;&t; */
id|bus-&gt;resource
(braket
l_int|1
)braket
op_assign
op_amp
id|non_mem
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|2
)braket
op_assign
op_amp
id|pre_mem
suffix:semicolon
id|pci_cmd
op_assign
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_cmd
op_or_assign
id|sysdata-&gt;bus
(braket
l_int|0
)braket
dot
id|features
suffix:semicolon
id|_V3Write16
c_func
(paren
id|V3_PCI_CMD
comma
id|pci_cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Fast back to back transfers %sabled&bslash;n&quot;
comma
(paren
id|sysdata-&gt;bus
(braket
l_int|0
)braket
dot
id|features
op_amp
id|PCI_COMMAND_FAST_BACK
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
eof
