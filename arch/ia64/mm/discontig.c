multiline_comment|/*&n; * Copyright (c) 2000 Silicon Graphics, Inc.  All rights reserved.&n; * Copyright (c) 2001 Intel Corp.&n; * Copyright (c) 2001 Tony Luck &lt;tony.luck@intel.com&gt;&n; * Copyright (c) 2002 NEC Corp.&n; * Copyright (c) 2002 Kimio Suganuma &lt;k-suganuma@da.jp.nec.com&gt;&n; */
multiline_comment|/*&n; * Platform initialization for Discontig Memory&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
multiline_comment|/*&n; * Round an address upward to the next multiple of GRANULE size.&n; */
DECL|macro|GRANULEROUNDUP
mdefine_line|#define GRANULEROUNDUP(n) (((n)+IA64_GRANULE_SIZE-1) &amp; ~(IA64_GRANULE_SIZE-1))
DECL|variable|node_data
r_static
r_struct
id|ia64_node_data
op_star
id|node_data
(braket
id|NR_NODES
)braket
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|boot_pg_data
(braket
l_int|8
op_star
id|NR_NODES
op_plus
r_sizeof
(paren
id|pg_data_t
)paren
)braket
id|__initdata
suffix:semicolon
DECL|variable|__initdata
r_static
id|pg_data_t
op_star
id|pg_data_ptr
(braket
id|NR_NODES
)braket
id|__initdata
suffix:semicolon
DECL|variable|__initdata
r_static
id|bootmem_data_t
id|bdata
(braket
id|NR_NODES
)braket
(braket
id|NR_BANKS_PER_NODE
op_plus
l_int|1
)braket
id|__initdata
suffix:semicolon
r_extern
r_int
id|filter_rsvd_memory
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n; * Return the compact node number of this cpu. Used prior to&n; * setting up the cpu_data area.&n; *&t;Note - not fast, intended for boot use only!!&n; */
r_int
DECL|function|boot_get_local_nodeid
id|boot_get_local_nodeid
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|node_cpuid
(braket
id|i
)braket
dot
id|phys_id
op_eq
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
r_return
id|node_cpuid
(braket
id|i
)braket
dot
id|nid
suffix:semicolon
multiline_comment|/* node info missing, so nid should be 0.. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a pointer to the pg_data structure for a node.&n; * This function is used ONLY in early boot before the cpu_data&n; * structure is available.&n; */
id|pg_data_t
op_star
id|__init
DECL|function|boot_get_pg_data_ptr
id|boot_get_pg_data_ptr
c_func
(paren
r_int
id|node
)paren
(brace
r_return
id|pg_data_ptr
(braket
id|node
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a pointer to the node data for the current node.&n; *&t;(boottime initialization only)&n; */
r_struct
id|ia64_node_data
op_star
DECL|function|get_node_data_ptr
id|get_node_data_ptr
c_func
(paren
r_void
)paren
(brace
r_return
id|node_data
(braket
id|boot_get_local_nodeid
c_func
(paren
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * We allocate one of the bootmem_data_t structs for each piece of memory&n; * that we wish to treat as a contiguous block.  Each such block must start&n; * on a BANKSIZE boundary.  Multiple banks per node is not supported.&n; */
r_static
r_int
id|__init
DECL|function|build_maps
id|build_maps
c_func
(paren
r_int
r_int
id|pstart
comma
r_int
r_int
id|length
comma
r_int
id|node
)paren
(brace
id|bootmem_data_t
op_star
id|bdp
suffix:semicolon
r_int
r_int
id|cstart
comma
id|epfn
suffix:semicolon
id|bdp
op_assign
id|pg_data_ptr
(braket
id|node
)braket
op_member_access_from_pointer
id|bdata
suffix:semicolon
id|epfn
op_assign
id|GRANULEROUNDUP
c_func
(paren
id|pstart
op_plus
id|length
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|cstart
op_assign
id|pstart
op_amp
op_complement
(paren
id|BANKSIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdp-&gt;node_low_pfn
)paren
(brace
id|bdp-&gt;node_boot_start
op_assign
id|cstart
suffix:semicolon
id|bdp-&gt;node_low_pfn
op_assign
id|epfn
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;node_boot_start
op_assign
id|min
c_func
(paren
id|cstart
comma
id|bdp-&gt;node_boot_start
)paren
suffix:semicolon
id|bdp-&gt;node_low_pfn
op_assign
id|max
c_func
(paren
id|epfn
comma
id|bdp-&gt;node_low_pfn
)paren
suffix:semicolon
)brace
id|min_low_pfn
op_assign
id|min
c_func
(paren
id|min_low_pfn
comma
id|bdp-&gt;node_boot_start
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|max_low_pfn
op_assign
id|max
c_func
(paren
id|max_low_pfn
comma
id|bdp-&gt;node_low_pfn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Find space on each node for the bootmem map.&n; *&n; * Called by efi_memmap_walk to find boot memory on each node. Note that&n; * only blocks that are free are passed to this routine (currently filtered by&n; * free_available_memory).&n; */
r_static
r_int
id|__init
DECL|function|find_bootmap_space
id|find_bootmap_space
c_func
(paren
r_int
r_int
id|pstart
comma
r_int
r_int
id|length
comma
r_int
id|node
)paren
(brace
r_int
r_int
id|mapsize
comma
id|pages
comma
id|epfn
suffix:semicolon
id|bootmem_data_t
op_star
id|bdp
suffix:semicolon
id|epfn
op_assign
(paren
id|pstart
op_plus
id|length
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|bdp
op_assign
op_amp
id|pg_data_ptr
(braket
id|node
)braket
op_member_access_from_pointer
id|bdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pstart
template_param
id|bdp-&gt;node_low_pfn
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdp-&gt;node_bootmem_map
)paren
(brace
id|pages
op_assign
id|bdp-&gt;node_low_pfn
op_minus
(paren
id|bdp-&gt;node_boot_start
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|mapsize
op_assign
id|bootmem_bootmap_pages
c_func
(paren
id|pages
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|mapsize
)paren
(brace
id|init_bootmem_node
c_func
(paren
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
comma
id|pstart
op_rshift
id|PAGE_SHIFT
comma
id|bdp-&gt;node_boot_start
op_rshift
id|PAGE_SHIFT
comma
id|bdp-&gt;node_low_pfn
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free available memory to the bootmem allocator.&n; *&n; * Note that only blocks that are free are passed to this routine (currently &n; * filtered by free_available_memory).&n; *&n; */
r_static
r_int
id|__init
DECL|function|discontig_free_bootmem_node
id|discontig_free_bootmem_node
c_func
(paren
r_int
r_int
id|pstart
comma
r_int
r_int
id|length
comma
r_int
id|node
)paren
(brace
id|free_bootmem_node
c_func
(paren
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
comma
id|pstart
comma
id|length
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reserve the space used by the bootmem maps.&n; */
r_static
r_void
id|__init
DECL|function|discontig_reserve_bootmem
id|discontig_reserve_bootmem
c_func
(paren
r_void
)paren
(brace
r_int
id|node
suffix:semicolon
r_int
r_int
id|mapbase
comma
id|mapsize
comma
id|pages
suffix:semicolon
id|bootmem_data_t
op_star
id|bdp
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
(brace
id|bdp
op_assign
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|bdata
suffix:semicolon
id|pages
op_assign
id|bdp-&gt;node_low_pfn
op_minus
(paren
id|bdp-&gt;node_boot_start
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|mapsize
op_assign
id|bootmem_bootmap_pages
c_func
(paren
id|pages
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|mapbase
op_assign
id|__pa
c_func
(paren
id|bdp-&gt;node_bootmem_map
)paren
suffix:semicolon
id|reserve_bootmem_node
c_func
(paren
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
comma
id|mapbase
comma
id|mapsize
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate per node tables.&n; * &t;- the pg_data structure is allocated on each node. This minimizes offnode &n; *&t;  memory references&n; *&t;- the node data is allocated &amp; initialized. Portions of this structure is read-only (after &n; *&t;  boot) and contains node-local pointers to usefuls data structures located on&n; *&t;  other nodes.&n; *&n; * We also switch to using the &quot;real&quot; pg_data structures at this point. Earlier in boot, we&n; * use a different structure. The only use for pg_data prior to the point in boot is to get &n; * the pointer to the bdata for the node.&n; */
r_static
r_void
id|__init
DECL|function|allocate_pernode_structures
id|allocate_pernode_structures
c_func
(paren
r_void
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
l_int|0
comma
op_star
id|new_pgdat_list
op_assign
l_int|0
suffix:semicolon
r_int
id|node
comma
id|mynode
suffix:semicolon
id|mynode
op_assign
id|boot_get_local_nodeid
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|numnodes
op_minus
l_int|1
suffix:semicolon
id|node
op_ge
l_int|0
suffix:semicolon
id|node
op_decrement
)paren
(brace
id|node_data
(braket
id|node
)braket
op_assign
id|alloc_bootmem_node
c_func
(paren
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
comma
r_sizeof
(paren
r_struct
id|ia64_node_data
)paren
)paren
suffix:semicolon
id|pgdat
op_assign
id|__alloc_bootmem_node
c_func
(paren
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
comma
r_sizeof
(paren
id|pg_data_t
)paren
comma
id|SMP_CACHE_BYTES
comma
l_int|0
)paren
suffix:semicolon
id|pgdat-&gt;bdata
op_assign
op_amp
(paren
id|bdata
(braket
id|node
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|pg_data_ptr
(braket
id|node
)braket
op_assign
id|pgdat
suffix:semicolon
id|pgdat-&gt;pgdat_next
op_assign
id|new_pgdat_list
suffix:semicolon
id|new_pgdat_list
op_assign
id|pgdat
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|node_data
(braket
id|mynode
)braket
op_member_access_from_pointer
id|pg_data_ptrs
comma
id|pg_data_ptr
comma
r_sizeof
(paren
id|pg_data_ptr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|node_data
(braket
id|mynode
)braket
op_member_access_from_pointer
id|node_data_ptrs
comma
id|node_data
comma
r_sizeof
(paren
id|node_data
)paren
)paren
suffix:semicolon
id|pgdat_list
op_assign
id|new_pgdat_list
suffix:semicolon
)brace
multiline_comment|/*&n; * Called early in boot to setup the boot memory allocator, and to&n; * allocate the node-local pg_data &amp; node-directory data structures..&n; */
r_void
id|__init
DECL|function|discontig_mem_init
id|discontig_mem_init
c_func
(paren
r_void
)paren
(brace
r_int
id|node
suffix:semicolon
r_if
c_cond
(paren
id|numnodes
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;node info missing!&bslash;n&quot;
)paren
suffix:semicolon
id|numnodes
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
(brace
id|pg_data_ptr
(braket
id|node
)braket
op_assign
(paren
id|pg_data_t
op_star
)paren
op_amp
id|boot_pg_data
(braket
id|node
)braket
suffix:semicolon
id|pg_data_ptr
(braket
id|node
)braket
op_member_access_from_pointer
id|bdata
op_assign
op_amp
id|bdata
(braket
id|node
)braket
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|min_low_pfn
op_assign
op_minus
l_int|1
suffix:semicolon
id|max_low_pfn
op_assign
l_int|0
suffix:semicolon
id|efi_memmap_walk
c_func
(paren
id|filter_rsvd_memory
comma
id|build_maps
)paren
suffix:semicolon
id|efi_memmap_walk
c_func
(paren
id|filter_rsvd_memory
comma
id|find_bootmap_space
)paren
suffix:semicolon
id|efi_memmap_walk
c_func
(paren
id|filter_rsvd_memory
comma
id|discontig_free_bootmem_node
)paren
suffix:semicolon
id|discontig_reserve_bootmem
c_func
(paren
)paren
suffix:semicolon
id|allocate_pernode_structures
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the paging system.&n; *&t;- determine sizes of each node&n; *&t;- initialize the paging system for the node&n; *&t;- build the nodedir for the node. This contains pointers to&n; *&t;  the per-bank mem_map entries.&n; *&t;- fix the page struct &quot;virtual&quot; pointers. These are bank specific&n; *&t;  values that the paging system doesn&squot;t understand.&n; *&t;- replicate the nodedir structure to other nodes&t;&n; */
r_void
id|__init
DECL|function|discontig_paging_init
id|discontig_paging_init
c_func
(paren
r_void
)paren
(brace
r_int
id|node
comma
id|mynode
suffix:semicolon
r_int
r_int
id|max_dma
comma
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
suffix:semicolon
r_int
r_int
id|kaddr
comma
id|ekaddr
comma
id|bid
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|bootmem_data_t
op_star
id|bdp
suffix:semicolon
id|max_dma
op_assign
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|MAX_DMA_ADDRESS
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|mynode
op_assign
id|boot_get_local_nodeid
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
(brace
r_int
id|pfn
comma
id|startpfn
suffix:semicolon
id|memset
c_func
(paren
id|zones_size
comma
l_int|0
comma
r_sizeof
(paren
id|zones_size
)paren
)paren
suffix:semicolon
id|startpfn
op_assign
op_minus
l_int|1
suffix:semicolon
id|bdp
op_assign
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|bdata
suffix:semicolon
id|pfn
op_assign
id|bdp-&gt;node_boot_start
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|startpfn
op_eq
op_minus
l_int|1
)paren
id|startpfn
op_assign
id|pfn
suffix:semicolon
r_if
c_cond
(paren
id|pfn
OG
id|max_dma
)paren
id|zones_size
(braket
id|ZONE_NORMAL
)braket
op_add_assign
(paren
id|bdp-&gt;node_low_pfn
op_minus
id|pfn
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bdp-&gt;node_low_pfn
OL
id|max_dma
)paren
id|zones_size
(braket
id|ZONE_DMA
)braket
op_add_assign
(paren
id|bdp-&gt;node_low_pfn
op_minus
id|pfn
)paren
suffix:semicolon
r_else
(brace
id|zones_size
(braket
id|ZONE_DMA
)braket
op_add_assign
(paren
id|max_dma
op_minus
id|pfn
)paren
suffix:semicolon
id|zones_size
(braket
id|ZONE_NORMAL
)braket
op_add_assign
(paren
id|bdp-&gt;node_low_pfn
op_minus
id|max_dma
)paren
suffix:semicolon
)brace
id|free_area_init_node
c_func
(paren
id|node
comma
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
l_int|NULL
comma
id|zones_size
comma
id|startpfn
comma
l_int|0
)paren
suffix:semicolon
id|page
op_assign
id|NODE_DATA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|node_mem_map
suffix:semicolon
id|bdp
op_assign
id|BOOT_NODE_DATA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|bdata
suffix:semicolon
id|kaddr
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|bdp-&gt;node_boot_start
)paren
suffix:semicolon
id|ekaddr
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|bdp-&gt;node_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|kaddr
OL
id|ekaddr
)paren
(brace
r_if
c_cond
(paren
id|paddr_to_nid
c_func
(paren
id|__pa
c_func
(paren
id|kaddr
)paren
)paren
op_eq
id|node
)paren
(brace
id|bid
op_assign
id|BANK_MEM_MAP_INDEX
c_func
(paren
id|kaddr
)paren
suffix:semicolon
id|node_data
(braket
id|mynode
)braket
op_member_access_from_pointer
id|node_id_map
(braket
id|bid
)braket
op_assign
id|node
suffix:semicolon
id|node_data
(braket
id|mynode
)braket
op_member_access_from_pointer
id|bank_mem_map_base
(braket
id|bid
)braket
op_assign
id|page
suffix:semicolon
)brace
id|kaddr
op_add_assign
id|BANKSIZE
suffix:semicolon
id|page
op_add_assign
id|BANKSIZE
op_div
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Finish setting up the node data for this node, then copy it to the other nodes.&n;&t; */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
r_if
c_cond
(paren
id|mynode
op_ne
id|node
)paren
(brace
id|memcpy
c_func
(paren
id|node_data
(braket
id|node
)braket
comma
id|node_data
(braket
id|mynode
)braket
comma
r_sizeof
(paren
r_struct
id|ia64_node_data
)paren
)paren
suffix:semicolon
id|node_data
(braket
id|node
)braket
op_member_access_from_pointer
id|node
op_assign
id|node
suffix:semicolon
)brace
)brace
eof
