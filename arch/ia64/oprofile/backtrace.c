multiline_comment|/**&n; * @file backtrace.c&n; *&n; * @remark Copyright 2004 Silicon Graphics Inc.  All Rights Reserved.&n; * @remark Read the file COPYING&n; *&n; * @author Greg Banks &lt;gnb@melbourne.sgi.com&gt;&n; * @author Keith Owens &lt;kaos@melbourne.sgi.com&gt;&n; * Based on work done for the ia64 port of the SGI kernprof patch, which is&n; *    Copyright (c) 2003-2004 Silicon Graphics Inc.  All Rights Reserved.&n; */
macro_line|#include &lt;linux/oprofile.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * For IA64 we need to perform a complex little dance to get both&n; * the struct pt_regs and a synthetic struct switch_stack in place&n; * to allow the unwind code to work.  This dance requires our unwind&n; * using code to be called from a function called from unw_init_running().&n; * There we only get a single void* data pointer, so use this struct&n; * to hold all the data we need during the unwind.&n; */
r_typedef
r_struct
(brace
DECL|member|depth
r_int
r_int
id|depth
suffix:semicolon
DECL|member|regs
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
DECL|member|frame
r_struct
id|unw_frame_info
id|frame
suffix:semicolon
DECL|member|prev_pfs_loc
id|u64
op_star
id|prev_pfs_loc
suffix:semicolon
multiline_comment|/* state for WAR for old spinlock ool code */
DECL|typedef|ia64_backtrace_t
)brace
id|ia64_backtrace_t
suffix:semicolon
macro_line|#if __GNUC__ &lt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &lt; 3)
multiline_comment|/*&n; * Returns non-zero if the PC is in the spinlock contention out-of-line code&n; * with non-standard calling sequence (on older compilers).&n; */
DECL|function|in_old_ool_spinlock_code
r_static
id|__inline__
r_int
id|in_old_ool_spinlock_code
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_extern
r_const
r_char
id|ia64_spinlock_contention_pre3_4
(braket
)braket
id|__attribute__
(paren
(paren
id|weak
)paren
)paren
suffix:semicolon
r_extern
r_const
r_char
id|ia64_spinlock_contention_pre3_4_end
(braket
)braket
id|__attribute__
(paren
(paren
id|weak
)paren
)paren
suffix:semicolon
r_int
r_int
id|sc_start
op_assign
(paren
r_int
r_int
)paren
id|ia64_spinlock_contention_pre3_4
suffix:semicolon
r_int
r_int
id|sc_end
op_assign
(paren
r_int
r_int
)paren
id|ia64_spinlock_contention_pre3_4_end
suffix:semicolon
r_return
(paren
id|sc_start
op_logical_and
id|sc_end
op_logical_and
id|pc
op_ge
id|sc_start
op_logical_and
id|pc
OL
id|sc_end
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Newer spinlock code does a proper br.call and works fine with the unwinder */
DECL|macro|in_old_ool_spinlock_code
mdefine_line|#define in_old_ool_spinlock_code(pc)&t;0
macro_line|#endif
multiline_comment|/* Returns non-zero if the PC is in the Interrupt Vector Table */
DECL|function|in_ivt_code
r_static
id|__inline__
r_int
id|in_ivt_code
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_extern
r_char
id|ia64_ivt
(braket
)braket
suffix:semicolon
r_return
(paren
id|pc
op_ge
(paren
id|u_long
)paren
id|ia64_ivt
op_logical_and
id|pc
OL
(paren
id|u_long
)paren
id|ia64_ivt
op_plus
l_int|32768
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unwind to next stack frame.&n; */
DECL|function|next_frame
r_static
id|__inline__
r_int
id|next_frame
c_func
(paren
id|ia64_backtrace_t
op_star
id|bt
)paren
(brace
multiline_comment|/*&n;&t; * Avoid unsightly console message from unw_unwind() when attempting&n;&t; * to unwind through the Interrupt Vector Table which has no unwind&n;&t; * information.&n;&t; */
r_if
c_cond
(paren
id|in_ivt_code
c_func
(paren
id|bt-&gt;frame.ip
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * WAR for spinlock contention from leaf functions.  ia64_spinlock_contention_pre3_4&n;&t; * has ar.pfs == r0.  Leaf functions do not modify ar.pfs so ar.pfs remains&n;&t; * as 0, stopping the backtrace.  Record the previous ar.pfs when the current&n;&t; * IP is in ia64_spinlock_contention_pre3_4 then unwind, if pfs_loc has not changed&n;&t; * after unwind then use pt_regs.ar_pfs which is where the real ar.pfs is for&n;&t; * leaf functions.&n;&t; */
r_if
c_cond
(paren
id|bt-&gt;prev_pfs_loc
op_logical_and
id|bt-&gt;regs
op_logical_and
id|bt-&gt;frame.pfs_loc
op_eq
id|bt-&gt;prev_pfs_loc
)paren
id|bt-&gt;frame.pfs_loc
op_assign
op_amp
id|bt-&gt;regs-&gt;ar_pfs
suffix:semicolon
id|bt-&gt;prev_pfs_loc
op_assign
(paren
id|in_old_ool_spinlock_code
c_func
(paren
id|bt-&gt;frame.ip
)paren
ques
c_cond
id|bt-&gt;frame.pfs_loc
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_return
id|unw_unwind
c_func
(paren
op_amp
id|bt-&gt;frame
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|do_ia64_backtrace
r_static
r_void
id|do_ia64_backtrace
c_func
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_void
op_star
id|vdata
)paren
(brace
id|ia64_backtrace_t
op_star
id|bt
op_assign
id|vdata
suffix:semicolon
r_struct
id|switch_stack
op_star
id|sw
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|u_long
id|pc
comma
id|sp
suffix:semicolon
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
(paren
id|info
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* padding from unw_init_running */
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|sw
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|unw_init_frame_info
c_func
(paren
op_amp
id|bt-&gt;frame
comma
id|current
comma
id|sw
)paren
suffix:semicolon
multiline_comment|/* skip over interrupt frame and oprofile calls */
r_do
(brace
id|unw_get_sp
c_func
(paren
op_amp
id|bt-&gt;frame
comma
op_amp
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_ge
(paren
id|u_long
)paren
id|bt-&gt;regs
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_frame
c_func
(paren
id|bt
)paren
)paren
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|200
)paren
suffix:semicolon
multiline_comment|/* finally, grab the actual sample */
r_while
c_loop
(paren
id|bt-&gt;depth
op_decrement
op_logical_and
id|next_frame
c_func
(paren
id|bt
)paren
)paren
(brace
id|unw_get_ip
c_func
(paren
op_amp
id|bt-&gt;frame
comma
op_amp
id|pc
)paren
suffix:semicolon
id|oprofile_add_trace
c_func
(paren
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unw_is_intr_frame
c_func
(paren
op_amp
id|bt-&gt;frame
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Interrupt received on kernel stack; this can&n;&t;&t;&t; * happen when timer interrupt fires while processing&n;&t;&t;&t; * a softirq from the tail end of a hardware interrupt&n;&t;&t;&t; * which interrupted a system call.  Don&squot;t laugh, it&n;&t;&t;&t; * happens!  Splice the backtrace into two parts to&n;&t;&t;&t; * avoid spurious cycles in the gprof output.&n;&t;&t;&t; */
multiline_comment|/* TODO: split rather than drop the 2nd half */
r_break
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|ia64_backtrace
id|ia64_backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
r_const
id|regs
comma
r_int
r_int
id|depth
)paren
(brace
id|ia64_backtrace_t
id|bt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * On IA64 there is little hope of getting backtraces from&n;&t; * user space programs -- the problems of getting the unwind&n;&t; * information from arbitrary user programs are extreme.&n;&t; */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_return
suffix:semicolon
id|bt.depth
op_assign
id|depth
suffix:semicolon
id|bt.regs
op_assign
id|regs
suffix:semicolon
id|bt.prev_pfs_loc
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|unw_init_running
c_func
(paren
id|do_ia64_backtrace
comma
op_amp
id|bt
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
eof
