multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/nodemask.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &quot;pci/pcibus_provider_defs.h&quot;
macro_line|#include &quot;pci/pcidev.h&quot;
macro_line|#include &quot;pci/pcibr_provider.h&quot;
macro_line|#include &quot;xtalk/xwidgetdev.h&quot;
macro_line|#include &lt;asm/sn/geo.h&gt;
macro_line|#include &quot;xtalk/hubdev.h&quot;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
DECL|variable|master_baseio_wid
r_char
id|master_baseio_wid
suffix:semicolon
DECL|variable|master_nasid
id|nasid_t
id|master_nasid
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/* Partition Master */
DECL|struct|slab_info
r_struct
id|slab_info
(brace
DECL|member|hubdev
r_struct
id|hubdev_info
id|hubdev
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|brick
r_struct
id|brick
(brace
DECL|member|id
id|moduleid_t
id|id
suffix:semicolon
multiline_comment|/* Module ID of this module        */
DECL|member|slab_info
r_struct
id|slab_info
id|slab_info
(braket
id|MAX_SLABS
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|sn_ioif_inited
r_int
id|sn_ioif_inited
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SN I/O infrastructure initialized? */
multiline_comment|/*&n; * Retrieve the DMA Flush List given nasid.  This list is needed &n; * to implement the WAR - Flush DMA data on PIO Reads.&n; */
r_static
r_inline
r_uint64
DECL|function|sal_get_widget_dmaflush_list
id|sal_get_widget_dmaflush_list
c_func
(paren
id|u64
id|nasid
comma
id|u64
id|widget_num
comma
id|u64
id|address
)paren
(brace
r_struct
id|ia64_sal_retval
id|ret_stuff
suffix:semicolon
id|ret_stuff.status
op_assign
l_int|0
suffix:semicolon
id|ret_stuff.v0
op_assign
l_int|0
suffix:semicolon
id|SAL_CALL_NOLOCK
c_func
(paren
id|ret_stuff
comma
(paren
id|u64
)paren
id|SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST
comma
(paren
id|u64
)paren
id|nasid
comma
(paren
id|u64
)paren
id|widget_num
comma
(paren
id|u64
)paren
id|address
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret_stuff.v0
suffix:semicolon
)brace
multiline_comment|/*&n; * Retrieve the hub device info structure for the given nasid.&n; */
DECL|function|sal_get_hubdev_info
r_static
r_inline
r_uint64
id|sal_get_hubdev_info
c_func
(paren
id|u64
id|handle
comma
id|u64
id|address
)paren
(brace
r_struct
id|ia64_sal_retval
id|ret_stuff
suffix:semicolon
id|ret_stuff.status
op_assign
l_int|0
suffix:semicolon
id|ret_stuff.v0
op_assign
l_int|0
suffix:semicolon
id|SAL_CALL_NOLOCK
c_func
(paren
id|ret_stuff
comma
(paren
id|u64
)paren
id|SN_SAL_IOIF_GET_HUBDEV_INFO
comma
(paren
id|u64
)paren
id|handle
comma
(paren
id|u64
)paren
id|address
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret_stuff.v0
suffix:semicolon
)brace
multiline_comment|/*&n; * Retrieve the pci bus information given the bus number.&n; */
DECL|function|sal_get_pcibus_info
r_static
r_inline
r_uint64
id|sal_get_pcibus_info
c_func
(paren
id|u64
id|segment
comma
id|u64
id|busnum
comma
id|u64
id|address
)paren
(brace
r_struct
id|ia64_sal_retval
id|ret_stuff
suffix:semicolon
id|ret_stuff.status
op_assign
l_int|0
suffix:semicolon
id|ret_stuff.v0
op_assign
l_int|0
suffix:semicolon
id|SAL_CALL_NOLOCK
c_func
(paren
id|ret_stuff
comma
(paren
id|u64
)paren
id|SN_SAL_IOIF_GET_PCIBUS_INFO
comma
(paren
id|u64
)paren
id|segment
comma
(paren
id|u64
)paren
id|busnum
comma
(paren
id|u64
)paren
id|address
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret_stuff.v0
suffix:semicolon
)brace
multiline_comment|/*&n; * Retrieve the pci device information given the bus and device|function number.&n; */
r_static
r_inline
r_uint64
DECL|function|sal_get_pcidev_info
id|sal_get_pcidev_info
c_func
(paren
id|u64
id|segment
comma
id|u64
id|bus_number
comma
id|u64
id|devfn
comma
id|u64
id|pci_dev
comma
id|u64
id|sn_irq_info
)paren
(brace
r_struct
id|ia64_sal_retval
id|ret_stuff
suffix:semicolon
id|ret_stuff.status
op_assign
l_int|0
suffix:semicolon
id|ret_stuff.v0
op_assign
l_int|0
suffix:semicolon
id|SAL_CALL_NOLOCK
c_func
(paren
id|ret_stuff
comma
(paren
id|u64
)paren
id|SN_SAL_IOIF_GET_PCIDEV_INFO
comma
(paren
id|u64
)paren
id|segment
comma
(paren
id|u64
)paren
id|bus_number
comma
(paren
id|u64
)paren
id|devfn
comma
(paren
id|u64
)paren
id|pci_dev
comma
id|sn_irq_info
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret_stuff.v0
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_alloc_pci_sysdata() - This routine allocates a pci controller&n; *&t;which is expected as the pci_dev and pci_bus sysdata by the Linux&n; *&t;PCI infrastructure.&n; */
DECL|function|sn_alloc_pci_sysdata
r_static
r_inline
r_struct
id|pci_controller
op_star
id|sn_alloc_pci_sysdata
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_controller
op_star
id|pci_sysdata
suffix:semicolon
id|pci_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pci_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_sysdata
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pci_sysdata
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pci_sysdata
)paren
)paren
suffix:semicolon
r_return
id|pci_sysdata
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for &n; *&t;each node in the system.&n; */
DECL|function|sn_fixup_ionodes
r_static
r_void
id|sn_fixup_ionodes
c_func
(paren
r_void
)paren
(brace
r_struct
id|sn_flush_device_list
op_star
id|sn_flush_device_list
suffix:semicolon
r_struct
id|hubdev_info
op_star
id|hubdev
suffix:semicolon
r_uint64
id|status
suffix:semicolon
r_uint64
id|nasid
suffix:semicolon
r_int
id|i
comma
id|widget
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numionodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hubdev
op_assign
(paren
r_struct
id|hubdev_info
op_star
)paren
(paren
id|NODEPDA
c_func
(paren
id|i
)paren
op_member_access_from_pointer
id|pdinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|i
)paren
suffix:semicolon
id|status
op_assign
id|sal_get_hubdev_info
c_func
(paren
id|nasid
comma
(paren
r_uint64
)paren
id|__pa
c_func
(paren
id|hubdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|widget
op_assign
l_int|0
suffix:semicolon
id|widget
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widget
op_increment
)paren
id|hubdev-&gt;hdi_xwidget_info
(braket
id|widget
)braket
dot
id|xwi_hubinfo
op_assign
id|hubdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hubdev-&gt;hdi_flush_nasid_list.widget_p
)paren
r_continue
suffix:semicolon
id|hubdev-&gt;hdi_flush_nasid_list.widget_p
op_assign
id|kmalloc
c_func
(paren
(paren
id|HUB_WIDGET_ID_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hubdev-&gt;hdi_flush_nasid_list.widget_p
comma
l_int|0x0
comma
(paren
id|HUB_WIDGET_ID_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|widget
op_assign
l_int|0
suffix:semicolon
id|widget
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widget
op_increment
)paren
(brace
id|sn_flush_device_list
op_assign
id|kmalloc
c_func
(paren
id|DEV_PER_WIDGET
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sn_flush_device_list
comma
l_int|0x0
comma
id|DEV_PER_WIDGET
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
)paren
)paren
suffix:semicolon
id|status
op_assign
id|sal_get_widget_dmaflush_list
c_func
(paren
id|nasid
comma
id|widget
comma
(paren
r_uint64
)paren
id|__pa
(paren
id|sn_flush_device_list
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|kfree
c_func
(paren
id|sn_flush_device_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hubdev-&gt;hdi_flush_nasid_list.widget_p
(braket
id|widget
)braket
op_assign
id|sn_flush_device_list
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_amp
l_int|1
)paren
)paren
id|hub_error_init
c_func
(paren
id|hubdev
)paren
suffix:semicolon
r_else
id|ice_error_init
c_func
(paren
id|hubdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * sn_pci_fixup_slot() - This routine sets up a slot&squot;s resources&n; * consistent with the Linux PCI abstraction layer.  Resources acquired&n; * from our PCI provider include PIO maps to BAR space and interrupt&n; * objects.&n; */
DECL|function|sn_pci_fixup_slot
r_static
r_void
id|sn_pci_fixup_slot
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
id|idx
suffix:semicolon
r_int
id|segment
op_assign
l_int|0
suffix:semicolon
r_uint64
id|size
suffix:semicolon
r_struct
id|sn_irq_info
op_star
id|sn_irq_info
suffix:semicolon
r_struct
id|pci_dev
op_star
id|host_pci_dev
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pcidev_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Cannot afford to run out of memory */
id|memset
c_func
(paren
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pcidev_info
)paren
)paren
suffix:semicolon
id|sn_irq_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn_irq_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_irq_info
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Cannot afford to run out of memory */
id|memset
c_func
(paren
id|sn_irq_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sn_irq_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Call to retrieve pci device information needed by kernel. */
id|status
op_assign
id|sal_get_pcidev_info
c_func
(paren
(paren
id|u64
)paren
id|segment
comma
(paren
id|u64
)paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
(paren
id|u64
)paren
id|__pa
c_func
(paren
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
)paren
comma
(paren
id|u64
)paren
id|__pa
c_func
(paren
id|sn_irq_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Cannot get platform pci device information information */
multiline_comment|/* Copy over PIO Mapped Addresses */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
op_le
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
comma
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_pio_mapped_addr
(braket
id|idx
)braket
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
id|end
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
id|addr
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_pio_mapped_addr
(braket
id|idx
)braket
suffix:semicolon
id|addr
op_assign
(paren
(paren
id|addr
op_lshift
l_int|4
)paren
op_rshift
l_int|4
)paren
op_or
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|addr
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|parent
op_assign
op_amp
id|ioport_resource
suffix:semicolon
r_else
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
)brace
multiline_comment|/* set up host bus linkages */
id|host_pci_dev
op_assign
id|pci_find_slot
c_func
(paren
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_slot_host_handle
op_rshift
l_int|32
comma
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_slot_host_handle
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_host_pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|host_pci_dev
)paren
suffix:semicolon
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_linux_pcidev
op_assign
id|dev
suffix:semicolon
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_pcibus_info
op_assign
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|dev-&gt;bus
)paren
suffix:semicolon
multiline_comment|/* Only set up IRQ stuff if this device has a host bus context */
r_if
c_cond
(paren
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|dev
)paren
op_logical_and
id|sn_irq_info-&gt;irq_irq
)paren
(brace
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_sn_irq_info
op_assign
id|sn_irq_info
suffix:semicolon
id|dev-&gt;irq
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|pdi_sn_irq_info-&gt;irq_irq
suffix:semicolon
id|sn_irq_fixup
c_func
(paren
id|dev
comma
id|sn_irq_info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * sn_pci_controller_fixup() - This routine sets up a bus&squot;s resources&n; * consistent with the Linux PCI abstraction layer.&n; */
DECL|function|sn_pci_controller_fixup
r_static
r_void
id|sn_pci_controller_fixup
c_func
(paren
r_int
id|segment
comma
r_int
id|busnum
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|nasid
comma
id|cnode
suffix:semicolon
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_struct
id|pci_controller
op_star
id|controller
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|prom_bussoft_ptr
suffix:semicolon
r_struct
id|hubdev_info
op_star
id|hubdev_info
suffix:semicolon
r_void
op_star
id|provider_soft
suffix:semicolon
id|status
op_assign
id|sal_get_pcibus_info
c_func
(paren
(paren
id|u64
)paren
id|segment
comma
(paren
id|u64
)paren
id|busnum
comma
(paren
id|u64
)paren
id|ia64_tpa
c_func
(paren
op_amp
id|prom_bussoft_ptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OG
l_int|0
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* bus # does not exist */
)brace
id|prom_bussoft_ptr
op_assign
id|__va
c_func
(paren
id|prom_bussoft_ptr
)paren
suffix:semicolon
id|controller
op_assign
id|sn_alloc_pci_sysdata
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* controller non-zero is BUG&squot;d in sn_alloc_pci_sysdata */
id|bus
op_assign
id|pci_scan_bus
c_func
(paren
id|busnum
comma
op_amp
id|pci_root_ops
comma
id|controller
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* error, or bus already scanned */
)brace
multiline_comment|/*&n;&t; * Per-provider fixup.  Copies the contents from prom to local&n;&t; * area and links SN_PCIBUS_BUSSOFT().&n;&t; *&n;&t; * Note:  Provider is responsible for ensuring that prom_bussoft_ptr&n;&t; * represents an asic-type that it can handle.&n;&t; */
r_if
c_cond
(paren
id|prom_bussoft_ptr-&gt;bs_asic_type
op_eq
id|PCIIO_ASIC_TYPE_PPB
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* no further fixup necessary */
)brace
id|provider_soft
op_assign
id|pcibr_bus_fixup
c_func
(paren
id|prom_bussoft_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|provider_soft
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* fixup failed or not applicable */
)brace
multiline_comment|/*&n;&t; * Generic bus fixup goes here.  Don&squot;t reference prom_bussoft_ptr&n;&t; * after this point.&n;&t; */
id|bus-&gt;sysdata
op_assign
id|controller
suffix:semicolon
id|PCI_CONTROLLER
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|platform_data
op_assign
id|provider_soft
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_base
)paren
suffix:semicolon
id|cnode
op_assign
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|hubdev_info
op_assign
(paren
r_struct
id|hubdev_info
op_star
)paren
(paren
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|pdinfo
)paren
suffix:semicolon
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_xwidget_info
op_assign
op_amp
(paren
id|hubdev_info-&gt;hdi_xwidget_info
(braket
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_xid
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugly hack to get PCI setup until we have a proper ACPI namespace.&n; */
DECL|macro|PCI_BUSES_TO_SCAN
mdefine_line|#define PCI_BUSES_TO_SCAN 256
DECL|function|sn_pci_init
r_static
r_int
id|__init
id|sn_pci_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_void
id|sn_init_cpei_timer
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_extern
r_void
id|register_sn_procfs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
op_logical_or
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is needed to avoid bounce limit checks in the blk layer&n;&t; */
id|ia64_max_iommu_merge_mask
op_assign
op_complement
id|PAGE_MASK
suffix:semicolon
id|sn_fixup_ionodes
c_func
(paren
)paren
suffix:semicolon
id|sn_irq
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn_irq_info
op_star
)paren
op_star
id|NR_IRQS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_irq
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Canno afford to run out of memory. */
id|memset
c_func
(paren
id|sn_irq
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sn_irq_info
op_star
)paren
op_star
id|NR_IRQS
)paren
suffix:semicolon
id|sn_init_cpei_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|register_sn_procfs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_BUSES_TO_SCAN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sn_pci_controller_fixup
c_func
(paren
l_int|0
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Generic Linux PCI Layer has created the pci_bus and pci_dev &n;&t; * structures - time for us to add our SN PLatform specific &n;&t; * information.&n;&t; */
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|pci_dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sn_pci_fixup_slot
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
)brace
id|sn_ioif_inited
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* sn I/O infrastructure now initialized */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hubdev_init_node() - Creates the HUB data structure and link them to it&squot;s &n; *&t;own NODE specific data area.&n; */
DECL|function|hubdev_init_node
r_void
id|hubdev_init_node
c_func
(paren
id|nodepda_t
op_star
id|npda
comma
id|cnodeid_t
id|node
)paren
(brace
r_struct
id|hubdev_info
op_star
id|hubdev_info
suffix:semicolon
r_if
c_cond
(paren
id|node
op_ge
id|num_online_nodes
c_func
(paren
)paren
)paren
multiline_comment|/* Headless/memless IO nodes */
id|hubdev_info
op_assign
(paren
r_struct
id|hubdev_info
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
r_sizeof
(paren
r_struct
id|hubdev_info
)paren
)paren
suffix:semicolon
r_else
id|hubdev_info
op_assign
(paren
r_struct
id|hubdev_info
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
r_sizeof
(paren
r_struct
id|hubdev_info
)paren
)paren
suffix:semicolon
id|npda-&gt;pdinfo
op_assign
(paren
r_void
op_star
)paren
id|hubdev_info
suffix:semicolon
)brace
id|geoid_t
DECL|function|cnodeid_get_geoid
id|cnodeid_get_geoid
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_struct
id|hubdev_info
op_star
id|hubdev
suffix:semicolon
id|hubdev
op_assign
(paren
r_struct
id|hubdev_info
op_star
)paren
(paren
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|pdinfo
)paren
suffix:semicolon
r_return
id|hubdev-&gt;hdi_geoid
suffix:semicolon
)brace
DECL|variable|sn_pci_init
id|subsys_initcall
c_func
(paren
id|sn_pci_init
)paren
suffix:semicolon
eof
