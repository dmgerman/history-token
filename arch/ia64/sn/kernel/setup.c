multiline_comment|/*&n; * Copyright (C) 1999,2001-2002 Silicon Graphics, Inc. All rights reserved.&n; * &n; * This program is free software; you can redistribute it and/or modify it &n; * under the terms of version 2 of the GNU General Public License &n; * as published by the Free Software Foundation.&n; * &n; * This program is distributed in the hope that it would be useful, but &n; * WITHOUT ANY WARRANTY; without even the implied warranty of &n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &n; * &n; * Further, this software is distributed without any warranty that it is &n; * free of the rightful claim of any third person regarding infringement &n; * or the like.  Any license provided herein, whether implied or &n; * otherwise, applies only to this software file.  Patent licenses, if &n; * any, provided herein do not apply to combinations of this program with &n; * other software, or any other product whatsoever.&n; * &n; * You should have received a copy of the GNU General Public &n; * License along with this program; if not, write the Free Software &n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; * &n; * Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pkwy, &n; * Mountain View, CA  94043, or:&n; * &n; * http://www.sgi.com &n; * &n; * For further information regarding this notice, see: &n; * &n; * http://oss.sgi.com/projects/GenInfo/NoticeExplan&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#ifdef CONFIG_IA64_MCA
macro_line|#include &lt;asm/acpi-ext.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/pda.h&gt;
macro_line|#include &lt;asm/sn/nodepda.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
macro_line|#include &lt;asm/sn/leds.h&gt;
macro_line|#include &lt;asm/sn/bte.h&gt;
macro_line|#ifdef CONFIG_IA64_SGI_SN2
macro_line|#include &lt;asm/sn/sn2/shub.h&gt;
macro_line|#endif
r_extern
r_void
id|bte_init_node
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
)paren
suffix:semicolon
r_extern
r_void
id|bte_init_cpu
(paren
r_void
)paren
suffix:semicolon
DECL|variable|sn_rtc_cycles_per_second
r_int
id|sn_rtc_cycles_per_second
suffix:semicolon
multiline_comment|/*&n; * This is the address of the RRegs in the HSpace of the global&n; * master.  It is used by a hack in serial.c (serial_[in|out],&n; * printk.c (early_printk), and kdb_io.c to put console output on that&n; * node&squot;s Bedrock UART.  It is initialized here to 0, so that&n; * early_printk won&squot;t try to access the UART before&n; * master_node_bedrock_address is properly calculated.&n; */
DECL|variable|master_node_bedrock_address
id|u64
id|master_node_bedrock_address
op_assign
l_int|0UL
suffix:semicolon
r_static
r_void
id|sn_init_pdas
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|irq_desc
op_star
id|_sn1_irq_desc
(braket
)braket
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
r_extern
id|synergy_da_t
op_star
id|Synergy_da_indr
(braket
)braket
suffix:semicolon
macro_line|#endif
DECL|variable|nodepdaindr
r_static
id|nodepda_t
op_star
id|nodepdaindr
(braket
id|MAX_COMPACT_NODES
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN2
DECL|variable|irqpdaindr
id|irqpda_t
op_star
id|irqpdaindr
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif /* CONFIG_IA64_SGI_SN2 */
multiline_comment|/*&n; * The format of &quot;screen_info&quot; is strange, and due to early i386-setup&n; * code. This is just enough to make the console code think we&squot;re on a&n; * VGA color display.&n; */
DECL|variable|sn1_screen_info
r_struct
id|screen_info
id|sn1_screen_info
op_assign
(brace
id|orig_x
suffix:colon
l_int|0
comma
id|orig_y
suffix:colon
l_int|0
comma
id|orig_video_mode
suffix:colon
l_int|3
comma
id|orig_video_cols
suffix:colon
l_int|80
comma
id|orig_video_ega_bx
suffix:colon
l_int|3
comma
id|orig_video_lines
suffix:colon
l_int|25
comma
id|orig_video_isVGA
suffix:colon
l_int|1
comma
id|orig_video_points
suffix:colon
l_int|16
)brace
suffix:semicolon
multiline_comment|/*&n; * This is here so we can use the CMOS detection in ide-probe.c to&n; * determine what drives are present.  In theory, we don&squot;t need this&n; * as the auto-detection could be done via ide-probe.c:do_probe() but&n; * in practice that would be much slower, which is painful when&n; * running in the simulator.  Note that passing zeroes in DRIVE_INFO&n; * is sufficient (the IDE driver will autodetect the drive geometry).&n; */
DECL|variable|drive_info
r_char
id|drive_info
(braket
l_int|4
op_star
l_int|16
)braket
suffix:semicolon
multiline_comment|/**&n; * sn1_map_nr - return the mem_map entry for a given kernel address&n; * @addr: kernel address to query&n; *&n; * Finds the mem_map entry for the kernel address given.  Used by&n; * virt_to_page() (asm-ia64/page.h), among other things.&n; */
r_int
r_int
DECL|function|sn1_map_nr
id|sn1_map_nr
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
id|MAP_NR_DISCONTIG
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * early_sn1_setup - early setup routine for SN platforms&n; *&n; * Sets up an intial console to aid debugging.  Intended primarily&n; * for bringup, it&squot;s only called if %BRINGUP and %CONFIG_IA64_EARLY_PRINTK&n; * are turned on.  See start_kernel() in init/main.c.&n; */
macro_line|#if defined(CONFIG_IA64_EARLY_PRINTK)
r_void
id|__init
DECL|function|early_sn1_setup
id|early_sn1_setup
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
macro_line|#endif
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN2
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HUB
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
id|SH_JUNK_BUS_UART0
)paren
suffix:semicolon
macro_line|#else
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HSPEC_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;early_sn1_setup: setting master_node_bedrock_address to 0x%lx&bslash;n&quot;
comma
id|master_node_bedrock_address
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_IA64_EARLY_PRINTK */
macro_line|#ifdef NOT_YET_CONFIG_IA64_MCA
r_extern
r_void
id|ia64_mca_cpe_int_handler
(paren
r_int
id|cpe_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
suffix:semicolon
DECL|variable|mca_cpe_irqaction
r_static
r_struct
id|irqaction
id|mca_cpe_irqaction
op_assign
(brace
id|handler
suffix:colon
id|ia64_mca_cpe_int_handler
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;cpe_hndlr&quot;
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IA64_MCA
r_extern
r_int
id|platform_irq_list
(braket
)braket
suffix:semicolon
macro_line|#endif
r_extern
id|nasid_t
id|master_nasid
suffix:semicolon
multiline_comment|/**&n; * sn1_setup - SN platform setup routine&n; * @cmdline_p: kernel command line&n; *&n; * Handles platform setup for SN machines.  This includes determining&n; * the RTC frequency (via a SAL call), initializing secondary CPUs, and&n; * setting up per-node data areas.  The console is also initialized here.&n; */
r_void
id|__init
DECL|function|sn1_setup
id|sn1_setup
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_int
id|status
comma
id|ticks_per_sec
comma
id|drift
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if defined(CONFIG_SERIAL) &amp;&amp; !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_struct
id|serial_struct
id|req
suffix:semicolon
macro_line|#endif
id|master_nasid
op_assign
id|get_nasid
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|get_console_nasid
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|ia64_sal_freq_base
c_func
(paren
id|SAL_FREQ_BASE_REALTIME_CLOCK
comma
op_amp
id|ticks_per_sec
comma
op_amp
id|drift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
op_logical_or
id|ticks_per_sec
OL
l_int|100000
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;unable to determine platform RTC clock frequency&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|sn_rtc_cycles_per_second
op_assign
id|ticks_per_sec
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|_sn1_irq_desc
(braket
id|i
)braket
op_assign
id|_irq_desc
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_MCA
id|platform_irq_list
(braket
id|ACPI20_ENTRY_PIS_CPEI
)braket
op_assign
id|IA64_PCE_VECTOR
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
macro_line|#endif
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN2
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HUB
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
id|SH_JUNK_BUS_UART0
)paren
suffix:semicolon
macro_line|#else
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HSPEC_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sn1_setup: setting master_node_bedrock_address to 0x%lx&bslash;n&quot;
comma
id|master_node_bedrock_address
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SERIAL) &amp;&amp; !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
multiline_comment|/*&n;&t; * We do early_serial_setup() to clean out the rs-table[] from the&n;&t; * statically compiled in version.&n;&t; */
id|memset
c_func
(paren
op_amp
id|req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
id|req.line
op_assign
l_int|0
suffix:semicolon
id|req.baud_base
op_assign
l_int|124800
suffix:semicolon
id|req.port
op_assign
l_int|0
suffix:semicolon
id|req.port_high
op_assign
l_int|0
suffix:semicolon
id|req.irq
op_assign
l_int|0
suffix:semicolon
id|req.flags
op_assign
(paren
id|ASYNC_BOOT_AUTOCONF
op_or
id|ASYNC_SKIP_TEST
)paren
suffix:semicolon
id|req.io_type
op_assign
id|SERIAL_IO_MEM
suffix:semicolon
id|req.hub6
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN2
id|req.iomem_base
op_assign
(paren
id|u8
op_star
)paren
(paren
id|master_node_bedrock_address
)paren
suffix:semicolon
macro_line|#else
id|req.iomem_base
op_assign
(paren
id|u8
op_star
)paren
(paren
id|master_node_bedrock_address
op_plus
l_int|0x80
)paren
suffix:semicolon
macro_line|#endif
id|req.iomem_reg_shift
op_assign
l_int|3
suffix:semicolon
id|req.type
op_assign
l_int|0
suffix:semicolon
id|req.xmit_fifo_size
op_assign
l_int|0
suffix:semicolon
id|req.custom_divisor
op_assign
l_int|0
suffix:semicolon
id|req.closing_wait
op_assign
l_int|0
suffix:semicolon
id|early_serial_setup
c_func
(paren
op_amp
id|req
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL &amp;&amp; !CONFIG_SERIAL_SGI_L1_PROTOCOL */
multiline_comment|/*&n;&t; * we set the default root device to /dev/hda&n;&t; * to make simulation easy&n;&t; */
id|ROOT_DEV
op_assign
id|Root_HDA1
suffix:semicolon
multiline_comment|/*&n;&t; * Create the PDAs and NODEPDAs for all the cpus.&n;&t; */
id|sn_init_pdas
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * For the bootcpu, we do this here. All other cpus will make the&n;&t; * call as part of cpu_init in slave cpu initialization.&n;&t; */
id|sn_cpu_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|init_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|screen_info
op_assign
id|sn1_screen_info
suffix:semicolon
multiline_comment|/*&n;&t; * Turn off &quot;floating-point assist fault&quot; warnings by default.&n;&t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_FPEMU_NOPRINT
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_init_pdas - setup node data areas&n; *&n; * One time setup for Node Data Area.  Called by sn1_setup().&n; */
r_void
DECL|function|sn_init_pdas
id|sn_init_pdas
c_func
(paren
r_void
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that the PDA fits entirely in the same page as the &n;&t; * cpu_data area.&n;&t; */
r_if
c_cond
(paren
(paren
id|PDAADDR
op_amp
op_complement
id|PAGE_MASK
)paren
op_plus
r_sizeof
(paren
id|pda_t
)paren
OG
id|PAGE_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;overflow of cpu_data page&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;         * Allocate &amp; initalize the nodepda for each node.&n;         */
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|nodepdaindr
(braket
id|cnode
)braket
op_assign
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|cnode
)paren
comma
r_sizeof
(paren
id|nodepda_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|nodepdaindr
(braket
id|cnode
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|nodepda_t
)paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
id|Synergy_da_indr
(braket
id|cnode
op_star
l_int|2
)braket
op_assign
(paren
id|synergy_da_t
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|cnode
)paren
comma
r_sizeof
(paren
id|synergy_da_t
)paren
)paren
suffix:semicolon
id|Synergy_da_indr
(braket
id|cnode
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
(paren
id|synergy_da_t
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|cnode
)paren
comma
r_sizeof
(paren
id|synergy_da_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|Synergy_da_indr
(braket
id|cnode
op_star
l_int|2
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|synergy_da_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|Synergy_da_indr
(braket
id|cnode
op_star
l_int|2
op_plus
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|synergy_da_t
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Now copy the array of nodepda pointers to each nodepda.&n;&t; */
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
id|memcpy
c_func
(paren
id|nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|pernode_pdaindr
comma
id|nodepdaindr
comma
r_sizeof
(paren
id|nodepdaindr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up IO related platform-dependent nodepda fields.&n;&t; * The following routine actually sets up the hubinfo struct&n;&t; * in nodepda.&n;&t; */
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|init_platform_nodepda
c_func
(paren
id|nodepdaindr
(braket
id|cnode
)braket
comma
id|cnode
)paren
suffix:semicolon
id|bte_init_node
(paren
id|nodepdaindr
(braket
id|cnode
)braket
comma
id|cnode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * sn_cpu_init - initialize per-cpu data areas&n; * @cpuid: cpuid of the caller&n; *&n; * Called during cpu initialization on each cpu as it starts.&n; * Currently, initializes the per-cpu data area for SNIA.&n; * Also sets up a few fields in the nodepda.  Also known as&n; * platform_cpu_init() by the ia64 machvec code.&n; */
r_void
id|__init
DECL|function|sn_cpu_init
id|sn_cpu_init
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
suffix:semicolon
r_int
id|cpuphyid
suffix:semicolon
r_int
id|nasid
suffix:semicolon
r_int
id|slice
suffix:semicolon
r_int
id|cnode
suffix:semicolon
multiline_comment|/*&n;&t; * The boot cpu makes this call again after platform initialization is&n;&t; * complete.&n;&t; */
r_if
c_cond
(paren
id|nodepdaindr
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|cpuid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|cpuphyid
op_assign
(paren
(paren
id|ia64_get_lid
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|nasid
op_assign
id|cpu_physical_id_to_nasid
c_func
(paren
id|cpuphyid
)paren
suffix:semicolon
id|cnode
op_assign
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|slice
op_assign
id|cpu_physical_id_to_slice
c_func
(paren
id|cpuphyid
)paren
suffix:semicolon
id|pda.p_nodepda
op_assign
id|nodepdaindr
(braket
id|cnode
)braket
suffix:semicolon
id|pda.led_address
op_assign
(paren
r_int
op_star
)paren
(paren
id|LED0
op_plus
(paren
id|slice
op_lshift
id|LED_CPU_SHIFT
)paren
)paren
suffix:semicolon
id|pda.led_state
op_assign
l_int|0
suffix:semicolon
id|pda.hb_count
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
id|pda.hb_state
op_assign
l_int|0
suffix:semicolon
id|pda.idle_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|local_node_data-&gt;active_cpu_count
op_eq
l_int|1
)paren
id|nodepda-&gt;node_first_cpu
op_assign
id|cpuid
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
(brace
r_int
id|synergy
suffix:semicolon
id|synergy
op_assign
id|cpu_physical_id_to_synergy
c_func
(paren
id|cpuphyid
)paren
suffix:semicolon
id|pda.p_subnodepda
op_assign
op_amp
id|nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|snpda
(braket
id|synergy
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_IA64_SGI_SN2
multiline_comment|/*&n;&t; * We must use different memory allocators for first cpu (bootmem &n;&t; * allocator) than for the other cpus (regular allocator).&n;&t; */
r_if
c_cond
(paren
id|cpuid
op_eq
l_int|0
)paren
id|irqpdaindr
(braket
id|cpuid
)braket
op_assign
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|cpuid_to_cnodeid
c_func
(paren
id|cpuid
)paren
)paren
comma
r_sizeof
(paren
id|irqpda_t
)paren
)paren
suffix:semicolon
r_else
id|irqpdaindr
(braket
id|cpuid
)braket
op_assign
id|page_address
c_func
(paren
id|alloc_pages_node
c_func
(paren
id|local_cnodeid
c_func
(paren
)paren
comma
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
r_sizeof
(paren
id|irqpda_t
)paren
)paren
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|irqpdaindr
(braket
id|cpuid
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|irqpda_t
)paren
)paren
suffix:semicolon
id|pda.p_irqpda
op_assign
id|irqpdaindr
(braket
id|cpuid
)braket
suffix:semicolon
id|pda.pio_write_status_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|LOCAL_MMR_ADDR
c_func
(paren
(paren
id|slice
OL
l_int|2
ques
c_cond
id|SH_PIO_WRITE_STATUS_0
suffix:colon
id|SH_PIO_WRITE_STATUS_1
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|pda.bedrock_rev_id
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|LOCAL_HUB
c_func
(paren
id|LB_REV_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid_to_synergy
c_func
(paren
id|cpuid
)paren
)paren
multiline_comment|/* CPU B */
id|pda.pio_write_status_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|GBL_PERF_B_ADDR
suffix:semicolon
r_else
multiline_comment|/* CPU A */
id|pda.pio_write_status_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|GBL_PERF_A_ADDR
suffix:semicolon
macro_line|#endif
id|bte_init_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * cnodeid_to_cpuid - convert a cnode to a cpuid of a cpu on the node.&n; * @cnode: node to get a cpuid from&n; *&t;&n; * Returns -1 if no cpus exist on the node.&n; * NOTE:BRINGUP ZZZ This is NOT a good way to find cpus on the node.&n; * Need a better way!!&n; */
r_int
DECL|function|cnodeid_to_cpuid
id|cnodeid_to_cpuid
c_func
(paren
r_int
id|cnode
)paren
(brace
r_int
id|cpu
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
op_eq
id|cnode
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu
op_eq
id|NR_CPUS
)paren
id|cpu
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|cpu
suffix:semicolon
)brace
eof
