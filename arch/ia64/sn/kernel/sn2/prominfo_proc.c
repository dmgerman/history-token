multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1999,2001-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * Module to export the system&squot;s Firmware Interface Tables, including&n; * PROM revision numbers, in /proc&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
multiline_comment|/* to lookup nasids */
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;PROM version reporting for /proc&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Chad Talbott&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|macro|DEBUG_PROMINFO
macro_line|#undef DEBUG_PROMINFO
DECL|macro|TRACE_PROMINFO
mdefine_line|#define TRACE_PROMINFO
macro_line|#if defined(DEBUG_PROMINFO)
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(x...) printk(KERN_DEBUG x)
macro_line|#else
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(x...)
macro_line|#endif
macro_line|#if defined(TRACE_PROMINFO) &amp;&amp; defined(DEBUG_PROMINFO)
macro_line|#  if defined(__GNUC__)
DECL|macro|TRACE
macro_line|#    define TRACE()&t;printk(KERN_DEBUG &quot;%s:%d:%s&bslash;n&quot;, &bslash;&n;&t;&t;&t;       __FILE__, __LINE__, __FUNCTION__)
macro_line|#  else
DECL|macro|TRACE
macro_line|#    define TRACE()&t;printk(KERN_DEBUG &quot;%s:%d&bslash;n&quot;, __LINE__, __FILE__)
macro_line|#  endif
macro_line|#else
DECL|macro|TRACE
macro_line|#  define TRACE()
macro_line|#endif
multiline_comment|/* Sub-regions determined by bits in Node Offset */
DECL|macro|LB_PROM_SPACE
mdefine_line|#define&t;LB_PROM_SPACE&t;&t;0x0000000700000000ul /* Local LB PROM */
DECL|macro|FIT_SIGNATURE
mdefine_line|#define FIT_SIGNATURE&t;&t;0x2020205f5449465ful
multiline_comment|/* Standard Intel FIT entry types */
DECL|macro|FIT_ENTRY_FIT_HEADER
mdefine_line|#define FIT_ENTRY_FIT_HEADER&t;0x00&t;/* FIT header entry */
DECL|macro|FIT_ENTRY_PAL_B
mdefine_line|#define FIT_ENTRY_PAL_B&t;&t;0x01&t;/* PAL_B entry */
multiline_comment|/* Entries 0x02 through 0x0D reserved by Intel */
DECL|macro|FIT_ENTRY_PAL_A_PROC
mdefine_line|#define FIT_ENTRY_PAL_A_PROC&t;0x0E&t;/* Processor-specific PAL_A entry */
DECL|macro|FIT_ENTRY_PAL_A
mdefine_line|#define FIT_ENTRY_PAL_A&t;&t;0x0F&t;/* PAL_A entry, same as... */
DECL|macro|FIT_ENTRY_PAL_A_GEN
mdefine_line|#define FIT_ENTRY_PAL_A_GEN&t;0x0F&t;/* ...Generic PAL_A entry */
DECL|macro|FIT_ENTRY_UNUSED
mdefine_line|#define FIT_ENTRY_UNUSED&t;0x7F&t;/* Unused (reserved by Intel?) */
multiline_comment|/* OEM-defined entries range from 0x10 to 0x7E. */
DECL|macro|FIT_ENTRY_SAL_A
mdefine_line|#define FIT_ENTRY_SAL_A&t;&t;0x10&t;/* SAL_A entry */
DECL|macro|FIT_ENTRY_SAL_B
mdefine_line|#define FIT_ENTRY_SAL_B&t;&t;0x11&t;/* SAL_B entry */
DECL|macro|FIT_ENTRY_SALRUNTIME
mdefine_line|#define FIT_ENTRY_SALRUNTIME&t;0x12&t;/* SAL runtime entry */
DECL|macro|FIT_ENTRY_EFI
mdefine_line|#define FIT_ENTRY_EFI&t;&t;0x1F&t;/* EFI entry */
DECL|macro|FIT_ENTRY_FPSWA
mdefine_line|#define FIT_ENTRY_FPSWA&t;&t;0x20&t;/* embedded fpswa entry */
DECL|macro|FIT_ENTRY_VMLINUX
mdefine_line|#define FIT_ENTRY_VMLINUX&t;0x21&t;/* embedded vmlinux entry */
DECL|macro|FIT_MAJOR_SHIFT
mdefine_line|#define FIT_MAJOR_SHIFT&t;(32 + 8)
DECL|macro|FIT_MAJOR_MASK
mdefine_line|#define FIT_MAJOR_MASK&t;((1 &lt;&lt; 8) - 1)
DECL|macro|FIT_MINOR_SHIFT
mdefine_line|#define FIT_MINOR_SHIFT&t;32
DECL|macro|FIT_MINOR_MASK
mdefine_line|#define FIT_MINOR_MASK&t;((1 &lt;&lt; 8) - 1)
DECL|macro|FIT_MAJOR
mdefine_line|#define FIT_MAJOR(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_MAJOR_SHIFT) &amp; FIT_MAJOR_MASK)
DECL|macro|FIT_MINOR
mdefine_line|#define FIT_MINOR(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_MINOR_SHIFT) &amp; FIT_MINOR_MASK)
DECL|macro|FIT_TYPE_SHIFT
mdefine_line|#define FIT_TYPE_SHIFT&t;(32 + 16)
DECL|macro|FIT_TYPE_MASK
mdefine_line|#define FIT_TYPE_MASK&t;((1 &lt;&lt; 7) - 1)
DECL|macro|FIT_TYPE
mdefine_line|#define FIT_TYPE(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_TYPE_SHIFT) &amp; FIT_TYPE_MASK)
DECL|macro|FIT_ENTRY
mdefine_line|#define FIT_ENTRY(type, maj, min, size)&t;&t;&t;&t;&t;&bslash;&n;&t;((((unsigned long)(maj) &amp; FIT_MAJOR_MASK) &lt;&lt; FIT_MAJOR_SHIFT) |&t;&bslash;&n;&t; (((unsigned long)(min) &amp; FIT_MINOR_MASK) &lt;&lt; FIT_MINOR_SHIFT) |&t;&bslash;&n;&t; (((unsigned long)(type) &amp; FIT_TYPE_MASK) &lt;&lt; FIT_TYPE_SHIFT) |&t;&bslash;&n;&t; (size))
DECL|struct|fit_type_map_t
r_struct
id|fit_type_map_t
(brace
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|fit_entry_types
r_static
r_const
r_struct
id|fit_type_map_t
id|fit_entry_types
(braket
)braket
op_assign
(brace
(brace
id|FIT_ENTRY_FIT_HEADER
comma
l_string|&quot;FIT Header&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A_GEN
comma
l_string|&quot;Generic PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A_PROC
comma
l_string|&quot;Processor-specific PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A
comma
l_string|&quot;PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_B
comma
l_string|&quot;PAL_B&quot;
)brace
comma
(brace
id|FIT_ENTRY_SAL_A
comma
l_string|&quot;SAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_SAL_B
comma
l_string|&quot;SAL_B&quot;
)brace
comma
(brace
id|FIT_ENTRY_SALRUNTIME
comma
l_string|&quot;SAL runtime&quot;
)brace
comma
(brace
id|FIT_ENTRY_EFI
comma
l_string|&quot;EFI&quot;
)brace
comma
(brace
id|FIT_ENTRY_VMLINUX
comma
l_string|&quot;Embedded Linux&quot;
)brace
comma
(brace
id|FIT_ENTRY_FPSWA
comma
l_string|&quot;Embedded FPSWA&quot;
)brace
comma
(brace
id|FIT_ENTRY_UNUSED
comma
l_string|&quot;Unused&quot;
)brace
comma
(brace
l_int|0xff
comma
l_string|&quot;Error&quot;
)brace
comma
)brace
suffix:semicolon
r_static
r_const
r_char
op_star
DECL|function|fit_type_name
id|fit_type_name
c_func
(paren
r_int
r_char
id|type
)paren
(brace
r_struct
id|fit_type_map_t
r_const
op_star
id|mapp
suffix:semicolon
r_for
c_loop
(paren
id|mapp
op_assign
id|fit_entry_types
suffix:semicolon
id|mapp-&gt;type
op_ne
l_int|0xff
suffix:semicolon
id|mapp
op_increment
)paren
r_if
c_cond
(paren
id|type
op_eq
id|mapp-&gt;type
)paren
r_return
id|mapp-&gt;name
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
OG
id|FIT_ENTRY_PAL_A
)paren
op_logical_and
(paren
id|type
OL
id|FIT_ENTRY_UNUSED
)paren
)paren
r_return
l_string|&quot;OEM type&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
OG
id|FIT_ENTRY_PAL_B
)paren
op_logical_and
(paren
id|type
OL
id|FIT_ENTRY_PAL_A
)paren
)paren
r_return
l_string|&quot;Reserved&quot;
suffix:semicolon
r_return
l_string|&quot;Unknown type&quot;
suffix:semicolon
)brace
multiline_comment|/* These two routines read the FIT table directly from the FLASH PROM&n; * on a specific node.  The PROM can only be accessed using aligned 64&n; * bit reads, so we do that and then shift and mask the result to get&n; * at each field.&n; */
r_static
r_int
DECL|function|dump_fit_entry
id|dump_fit_entry
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
op_star
id|fentry
)paren
(brace
r_int
r_int
id|q1
comma
id|q2
suffix:semicolon
r_int
id|type
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|q1
op_assign
id|readq
c_func
(paren
id|fentry
)paren
suffix:semicolon
id|q2
op_assign
id|readq
c_func
(paren
id|fentry
op_plus
l_int|1
)paren
suffix:semicolon
id|type
op_assign
id|FIT_TYPE
c_func
(paren
id|q2
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%02x %-25s %x.%02x %016lx %u&bslash;n&quot;
comma
id|type
comma
id|fit_type_name
c_func
(paren
id|type
)paren
comma
id|FIT_MAJOR
c_func
(paren
id|q2
)paren
comma
id|FIT_MINOR
c_func
(paren
id|q2
)paren
comma
id|q1
comma
multiline_comment|/* mult by sixteen to get size in bytes */
(paren
r_int
)paren
id|q2
op_star
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/* We assume that the fit table will be small enough that we can print&n; * the whole thing into one page.  (This is true for our default 16kB&n; * pages -- each entry is about 60 chars wide when printed.)  I read&n; * somewhere that the maximum size of the FIT is 128 entries, so we&squot;re&n; * OK except for 4kB pages (and no one is going to do that on SN&n; * anyway).&n; */
r_static
r_int
DECL|function|dump_fit
id|dump_fit
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
op_star
id|fit
)paren
(brace
r_int
r_int
id|qw
suffix:semicolon
r_int
id|nentries
suffix:semicolon
r_int
id|fentry
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;dumping fit from %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|fit
)paren
suffix:semicolon
id|qw
op_assign
id|readq
c_func
(paren
id|fit
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;FIT signature: %016lx (%.8s)&bslash;n&quot;
comma
id|qw
comma
(paren
r_char
op_star
)paren
op_amp
id|qw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qw
op_ne
id|FIT_SIGNATURE
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unrecognized FIT signature&quot;
)paren
suffix:semicolon
id|qw
op_assign
id|readq
c_func
(paren
id|fit
op_plus
l_int|1
)paren
suffix:semicolon
id|nentries
op_assign
(paren
r_int
)paren
id|qw
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;number of fit entries: %u&bslash;n&quot;
comma
id|nentries
)paren
suffix:semicolon
multiline_comment|/* check that we won&squot;t overflow the page -- see comment above */
id|BUG_ON
c_func
(paren
id|nentries
op_star
l_int|60
OG
id|PAGE_SIZE
)paren
suffix:semicolon
id|p
op_assign
id|page
suffix:semicolon
r_for
c_loop
(paren
id|fentry
op_assign
l_int|0
suffix:semicolon
id|fentry
OL
id|nentries
suffix:semicolon
id|fentry
op_increment
)paren
multiline_comment|/* each FIT entry is two 64 bit words */
id|p
op_add_assign
id|dump_fit_entry
c_func
(paren
id|p
comma
id|fit
op_plus
l_int|2
op_star
id|fentry
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|dump_version
id|dump_version
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
op_star
id|fit
)paren
(brace
r_int
id|nentries
suffix:semicolon
r_int
id|fentry
suffix:semicolon
r_int
r_int
id|qw
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|nentries
op_assign
(paren
r_int
)paren
id|readq
c_func
(paren
id|fit
op_plus
l_int|1
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nentries
op_star
l_int|60
OG
id|PAGE_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fentry
op_assign
l_int|0
suffix:semicolon
id|fentry
OL
id|nentries
suffix:semicolon
id|fentry
op_increment
)paren
(brace
id|qw
op_assign
id|readq
c_func
(paren
id|fit
op_plus
l_int|2
op_star
id|fentry
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FIT_TYPE
c_func
(paren
id|qw
)paren
op_eq
id|FIT_ENTRY_SAL_A
)paren
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%x.%02x&bslash;n&quot;
comma
id|FIT_MAJOR
c_func
(paren
id|qw
)paren
comma
id|FIT_MINOR
c_func
(paren
id|qw
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* same as in proc_misc.c */
r_static
r_int
DECL|function|proc_calc_metrics
id|proc_calc_metrics
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_version_entry
id|read_version_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* data holds the pointer to this node&squot;s FIT */
id|len
op_assign
id|dump_version
c_func
(paren
id|page
comma
(paren
r_int
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
id|len
op_assign
id|proc_calc_metrics
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_fit_entry
id|read_fit_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* data holds the pointer to this node&squot;s FIT */
id|len
op_assign
id|dump_fit
c_func
(paren
id|page
comma
(paren
r_int
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
id|len
op_assign
id|proc_calc_metrics
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* this is a fake FIT that&squot;s used on the medusa simulator which&n; * doesn&squot;t usually run a complete PROM. &n; */
macro_line|#ifdef CONFIG_IA64_SGI_SN_SIM
DECL|variable|fakefit
r_static
r_int
r_int
id|fakefit
(braket
)braket
op_assign
(brace
multiline_comment|/* this is all we need to satisfy the code below */
id|FIT_SIGNATURE
comma
id|FIT_ENTRY
c_func
(paren
id|FIT_ENTRY_FIT_HEADER
comma
l_int|0x02
comma
l_int|0x60
comma
l_int|2
)paren
comma
multiline_comment|/* dump something arbitrary for&n;&t; * /proc/sgi_prominfo/nodeX/version */
l_int|0xbadbeef00fa3ef17ul
comma
id|FIT_ENTRY
c_func
(paren
id|FIT_ENTRY_SAL_A
comma
l_int|0
comma
l_int|0x99
comma
l_int|0x100
)paren
)brace
suffix:semicolon
macro_line|#endif
r_static
r_int
r_int
op_star
DECL|function|lookup_fit
id|lookup_fit
c_func
(paren
r_int
id|nasid
)paren
(brace
r_int
r_int
op_star
id|fitp
suffix:semicolon
r_int
r_int
id|fit_paddr
suffix:semicolon
r_int
r_int
op_star
id|fit_vaddr
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN_SIM
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|fakefit
suffix:semicolon
macro_line|#endif
id|fitp
op_assign
(paren
r_void
op_star
)paren
id|GLOBAL_MMR_ADDR
c_func
(paren
id|nasid
comma
id|LB_PROM_SPACE
op_minus
l_int|32
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;pointer to fit at %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|fitp
)paren
suffix:semicolon
id|fit_paddr
op_assign
id|readq
c_func
(paren
id|fitp
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;fit pointer contains %lx&bslash;n&quot;
comma
id|fit_paddr
)paren
suffix:semicolon
multiline_comment|/* snag just the node-relative offset */
id|fit_paddr
op_and_assign
op_complement
l_int|0ul
op_rshift
(paren
l_int|63
op_minus
l_int|35
)paren
suffix:semicolon
multiline_comment|/* the pointer to the FIT is relative to IA-64 compatibility&n;&t; * space.  However, the PROM is mapped at a different offset&n;&t; * in MMR space (both local and global)&n;&t; */
id|fit_paddr
op_add_assign
l_int|0x700000000
suffix:semicolon
id|fit_vaddr
op_assign
(paren
r_void
op_star
)paren
id|GLOBAL_MMR_ADDR
c_func
(paren
id|nasid
comma
id|fit_paddr
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;fit at %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|fit_vaddr
)paren
suffix:semicolon
r_return
id|fit_vaddr
suffix:semicolon
)brace
multiline_comment|/* module entry points */
r_int
id|__init
id|prominfo_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|__exit
id|prominfo_exit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|prominfo_init
id|module_init
c_func
(paren
id|prominfo_init
)paren
suffix:semicolon
DECL|variable|prominfo_exit
id|module_exit
c_func
(paren
id|prominfo_exit
)paren
suffix:semicolon
DECL|variable|proc_entries
r_static
r_struct
id|proc_dir_entry
op_star
op_star
id|proc_entries
suffix:semicolon
DECL|variable|sgi_prominfo_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|sgi_prominfo_entry
suffix:semicolon
DECL|macro|NODE_NAME_LEN
mdefine_line|#define NODE_NAME_LEN 11
r_int
id|__init
DECL|function|prominfo_init
id|prominfo_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
op_star
id|entp
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_char
id|name
(braket
id|NODE_NAME_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;running on cpu %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;numnodes %d&bslash;n&quot;
comma
id|numnodes
)paren
suffix:semicolon
id|proc_entries
op_assign
id|kmalloc
c_func
(paren
id|numnodes
op_star
r_sizeof
(paren
r_struct
id|proc_dir_entry
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sgi_prominfo_entry
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;sgi_prominfo&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
comma
id|entp
op_assign
id|proc_entries
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
comma
id|entp
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;node%d&quot;
comma
id|cnodeid
)paren
suffix:semicolon
op_star
id|entp
op_assign
id|proc_mkdir
c_func
(paren
id|name
comma
id|sgi_prominfo_entry
)paren
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
l_string|&quot;fit&quot;
comma
l_int|0
comma
op_star
id|entp
comma
id|read_fit_entry
comma
id|lookup_fit
c_func
(paren
id|nasid
)paren
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
l_string|&quot;version&quot;
comma
l_int|0
comma
op_star
id|entp
comma
id|read_version_entry
comma
id|lookup_fit
c_func
(paren
id|nasid
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
id|__exit
DECL|function|prominfo_exit
id|prominfo_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
op_star
id|entp
suffix:semicolon
r_int
id|cnodeid
suffix:semicolon
r_char
id|name
(braket
id|NODE_NAME_LEN
)braket
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
comma
id|entp
op_assign
id|proc_entries
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
comma
id|entp
op_increment
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;fit&quot;
comma
op_star
id|entp
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;version&quot;
comma
op_star
id|entp
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;node%d&quot;
comma
id|cnodeid
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|name
comma
id|sgi_prominfo_entry
)paren
suffix:semicolon
)brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;sgi_prominfo&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|proc_entries
)paren
suffix:semicolon
)brace
eof
