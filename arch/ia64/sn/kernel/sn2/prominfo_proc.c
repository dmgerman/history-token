multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1999,2001-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * Module to export the system&squot;s Firmware Interface Tables, including&n; * PROM revision numbers and banners, in /proc&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/sn2/addrs.h&gt;
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;PROM version reporting for /proc&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Chad Talbott&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* Standard Intel FIT entry types */
DECL|macro|FIT_ENTRY_FIT_HEADER
mdefine_line|#define FIT_ENTRY_FIT_HEADER&t;0x00&t;/* FIT header entry */
DECL|macro|FIT_ENTRY_PAL_B
mdefine_line|#define FIT_ENTRY_PAL_B&t;&t;0x01&t;/* PAL_B entry */
multiline_comment|/* Entries 0x02 through 0x0D reserved by Intel */
DECL|macro|FIT_ENTRY_PAL_A_PROC
mdefine_line|#define FIT_ENTRY_PAL_A_PROC&t;0x0E&t;/* Processor-specific PAL_A entry */
DECL|macro|FIT_ENTRY_PAL_A
mdefine_line|#define FIT_ENTRY_PAL_A&t;&t;0x0F&t;/* PAL_A entry, same as... */
DECL|macro|FIT_ENTRY_PAL_A_GEN
mdefine_line|#define FIT_ENTRY_PAL_A_GEN&t;0x0F&t;/* ...Generic PAL_A entry */
DECL|macro|FIT_ENTRY_UNUSED
mdefine_line|#define FIT_ENTRY_UNUSED&t;0x7F&t;/* Unused (reserved by Intel?) */
multiline_comment|/* OEM-defined entries range from 0x10 to 0x7E. */
DECL|macro|FIT_ENTRY_SAL_A
mdefine_line|#define FIT_ENTRY_SAL_A&t;&t;0x10&t;/* SAL_A entry */
DECL|macro|FIT_ENTRY_SAL_B
mdefine_line|#define FIT_ENTRY_SAL_B&t;&t;0x11&t;/* SAL_B entry */
DECL|macro|FIT_ENTRY_SALRUNTIME
mdefine_line|#define FIT_ENTRY_SALRUNTIME&t;0x12&t;/* SAL runtime entry */
DECL|macro|FIT_ENTRY_EFI
mdefine_line|#define FIT_ENTRY_EFI&t;&t;0x1F&t;/* EFI entry */
DECL|macro|FIT_ENTRY_FPSWA
mdefine_line|#define FIT_ENTRY_FPSWA&t;&t;0x20&t;/* embedded fpswa entry */
DECL|macro|FIT_ENTRY_VMLINUX
mdefine_line|#define FIT_ENTRY_VMLINUX&t;0x21&t;/* embedded vmlinux entry */
DECL|macro|FIT_MAJOR_SHIFT
mdefine_line|#define FIT_MAJOR_SHIFT&t;(32 + 8)
DECL|macro|FIT_MAJOR_MASK
mdefine_line|#define FIT_MAJOR_MASK&t;((1 &lt;&lt; 8) - 1)
DECL|macro|FIT_MINOR_SHIFT
mdefine_line|#define FIT_MINOR_SHIFT&t;32
DECL|macro|FIT_MINOR_MASK
mdefine_line|#define FIT_MINOR_MASK&t;((1 &lt;&lt; 8) - 1)
DECL|macro|FIT_MAJOR
mdefine_line|#define FIT_MAJOR(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_MAJOR_SHIFT) &amp; FIT_MAJOR_MASK)
DECL|macro|FIT_MINOR
mdefine_line|#define FIT_MINOR(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_MINOR_SHIFT) &amp; FIT_MINOR_MASK)
DECL|macro|FIT_TYPE_SHIFT
mdefine_line|#define FIT_TYPE_SHIFT&t;(32 + 16)
DECL|macro|FIT_TYPE_MASK
mdefine_line|#define FIT_TYPE_MASK&t;((1 &lt;&lt; 7) - 1)
DECL|macro|FIT_TYPE
mdefine_line|#define FIT_TYPE(q)&t;&bslash;&n;&t;((unsigned) ((q) &gt;&gt; FIT_TYPE_SHIFT) &amp; FIT_TYPE_MASK)
DECL|struct|fit_type_map_t
r_struct
id|fit_type_map_t
(brace
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|fit_entry_types
r_static
r_const
r_struct
id|fit_type_map_t
id|fit_entry_types
(braket
)braket
op_assign
(brace
(brace
id|FIT_ENTRY_FIT_HEADER
comma
l_string|&quot;FIT Header&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A_GEN
comma
l_string|&quot;Generic PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A_PROC
comma
l_string|&quot;Processor-specific PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_A
comma
l_string|&quot;PAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_PAL_B
comma
l_string|&quot;PAL_B&quot;
)brace
comma
(brace
id|FIT_ENTRY_SAL_A
comma
l_string|&quot;SAL_A&quot;
)brace
comma
(brace
id|FIT_ENTRY_SAL_B
comma
l_string|&quot;SAL_B&quot;
)brace
comma
(brace
id|FIT_ENTRY_SALRUNTIME
comma
l_string|&quot;SAL runtime&quot;
)brace
comma
(brace
id|FIT_ENTRY_EFI
comma
l_string|&quot;EFI&quot;
)brace
comma
(brace
id|FIT_ENTRY_VMLINUX
comma
l_string|&quot;Embedded Linux&quot;
)brace
comma
(brace
id|FIT_ENTRY_FPSWA
comma
l_string|&quot;Embedded FPSWA&quot;
)brace
comma
(brace
id|FIT_ENTRY_UNUSED
comma
l_string|&quot;Unused&quot;
)brace
comma
(brace
l_int|0xff
comma
l_string|&quot;Error&quot;
)brace
comma
)brace
suffix:semicolon
r_static
r_const
r_char
op_star
DECL|function|fit_type_name
id|fit_type_name
c_func
(paren
r_int
r_char
id|type
)paren
(brace
r_struct
id|fit_type_map_t
r_const
op_star
id|mapp
suffix:semicolon
r_for
c_loop
(paren
id|mapp
op_assign
id|fit_entry_types
suffix:semicolon
id|mapp-&gt;type
op_ne
l_int|0xff
suffix:semicolon
id|mapp
op_increment
)paren
r_if
c_cond
(paren
id|type
op_eq
id|mapp-&gt;type
)paren
r_return
id|mapp-&gt;name
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
OG
id|FIT_ENTRY_PAL_A
)paren
op_logical_and
(paren
id|type
OL
id|FIT_ENTRY_UNUSED
)paren
)paren
r_return
l_string|&quot;OEM type&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
OG
id|FIT_ENTRY_PAL_B
)paren
op_logical_and
(paren
id|type
OL
id|FIT_ENTRY_PAL_A
)paren
)paren
r_return
l_string|&quot;Reserved&quot;
suffix:semicolon
r_return
l_string|&quot;Unknown type&quot;
suffix:semicolon
)brace
multiline_comment|/* ============ BEGIN temp til old PROMs are no longer supported =============&n; *&n; * The OS should not make direct access to the PROM flash memory. Access to&n; * this region must be serialized with a PROM lock. If SAL on one cpu is&n; * updating the FLASH error log at the same time another cpu is accessing the&n; * PROM, data corruption will occur.&n; *&n; * To solve the problem, all flash PROM access has been moved to SAL. Because&n; * not all systems will have instant PROM updates, we need to support a new OS&n; * running on a system with old PROMs.&n; *&n; * This code should be deleted after 1 OS/PROM release has occurred &amp; the OS&n; * no longer supports downrev PROMs. (PROM support should be in the 3.50&n; * PROMs).&n; */
DECL|macro|SUPPORT_OLD_PROMS
mdefine_line|#define SUPPORT_OLD_PROMS
macro_line|#ifdef SUPPORT_OLD_PROMS
DECL|macro|FIT_SIGNATURE
mdefine_line|#define FIT_SIGNATURE&t;&t;0x2020205f5449465ful
multiline_comment|/* Sub-regions determined by bits in Node Offset */
DECL|macro|LB_PROM_SPACE
mdefine_line|#define&t;LB_PROM_SPACE&t;&t;0x0000000700000000ul /* Local LB PROM */
multiline_comment|/* Offset of PROM banner pointers in SAL A and SAL B */
DECL|macro|SAL_A_BANNER_OFFSET
mdefine_line|#define SAL_A_BANNER_OFFSET&t;(1 * 16)
DECL|macro|SAL_B_BANNER_OFFSET
mdefine_line|#define SAL_B_BANNER_OFFSET&t;(3 * 16)
multiline_comment|/* Architected IA64 firmware space */
DECL|macro|FW_BASE
mdefine_line|#define FW_BASE                 0x00000000FF000000
DECL|macro|FW_TOP
mdefine_line|#define FW_TOP                  0x0000000100000000
r_static
r_int
r_int
DECL|function|convert_fw_addr
id|convert_fw_addr
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
r_int
id|addr
)paren
(brace
multiline_comment|/* snag just the node-relative offset */
id|addr
op_and_assign
op_complement
l_int|0ul
op_rshift
(paren
l_int|63
op_minus
l_int|35
)paren
suffix:semicolon
multiline_comment|/* the pointer to SAL A is relative to IA-64 compatibility&n;&t; * space.  However, the PROM is mapped at a different offset&n;&t; * in MMR space (both local and global)&n;&t; */
id|addr
op_add_assign
l_int|0x700000000
suffix:semicolon
r_return
id|GLOBAL_MMR_ADDR
c_func
(paren
id|nasid
comma
id|addr
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|valid_fw_addr
id|valid_fw_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|addr
op_and_assign
op_complement
(paren
l_int|1ul
op_lshift
l_int|63
)paren
suffix:semicolon
multiline_comment|/* Clear cached/uncached bit */
r_return
(paren
id|addr
op_ge
id|FW_BASE
op_logical_and
id|addr
OL
id|FW_TOP
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
op_star
DECL|function|lookup_fit
id|lookup_fit
c_func
(paren
r_int
id|nasid
)paren
(brace
r_int
r_int
op_star
id|fitp
suffix:semicolon
r_int
r_int
id|fit_paddr
suffix:semicolon
r_int
r_int
op_star
id|fit_vaddr
suffix:semicolon
id|fitp
op_assign
(paren
r_void
op_star
)paren
id|GLOBAL_MMR_ADDR
c_func
(paren
id|nasid
comma
id|LB_PROM_SPACE
op_minus
l_int|32
)paren
suffix:semicolon
id|fit_paddr
op_assign
id|readq
c_func
(paren
id|fitp
)paren
suffix:semicolon
id|fit_vaddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|convert_fw_addr
c_func
(paren
id|nasid
comma
id|fit_paddr
)paren
suffix:semicolon
r_return
id|fit_vaddr
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_OLD_PROMS */
multiline_comment|/* ============ END temp til old PROMs are no longer supported ============= */
r_static
r_int
DECL|function|get_fit_entry
id|get_fit_entry
c_func
(paren
r_int
r_int
id|nasid
comma
r_int
id|index
comma
r_int
r_int
op_star
id|fentry
comma
r_char
op_star
id|banner
comma
r_int
id|banlen
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ia64_sn_get_fit_compt
c_func
(paren
id|nasid
comma
id|index
comma
id|fentry
comma
id|banner
comma
id|banlen
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_OLD_PROMS
multiline_comment|/* The following is hack is temporary until PROMs are updated */
r_if
c_cond
(paren
id|ret
op_eq
id|SALRET_NOT_IMPLEMENTED
)paren
(brace
r_int
r_int
op_star
id|fitadr
op_assign
id|lookup_fit
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_int
id|nentries
suffix:semicolon
r_if
c_cond
(paren
id|readq
c_func
(paren
id|fitadr
)paren
op_ne
id|FIT_SIGNATURE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unrecognized FIT signature&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|nentries
op_assign
(paren
r_int
r_int
)paren
(paren
id|readq
c_func
(paren
id|fitadr
op_plus
l_int|1
)paren
op_amp
l_int|0xffffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|nentries
)paren
r_return
op_minus
l_int|2
suffix:semicolon
id|fentry
(braket
l_int|0
)braket
op_assign
id|readq
c_func
(paren
id|fitadr
op_plus
l_int|2
op_star
id|index
)paren
suffix:semicolon
id|fentry
(braket
l_int|1
)braket
op_assign
id|readq
c_func
(paren
id|fitadr
op_plus
l_int|2
op_star
id|index
op_plus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|banner
op_logical_and
id|FIT_TYPE
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
op_eq
id|FIT_ENTRY_SAL_A
)paren
(brace
r_int
r_int
id|i
comma
id|qw
comma
op_star
id|bwp
comma
op_star
id|qwp
suffix:semicolon
id|banner
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|qw
op_assign
id|fentry
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Address of SAL A */
r_if
c_cond
(paren
op_logical_neg
id|valid_fw_addr
c_func
(paren
id|qw
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|qw
op_add_assign
id|SAL_A_BANNER_OFFSET
suffix:semicolon
id|qw
op_assign
id|convert_fw_addr
c_func
(paren
id|nasid
comma
id|qw
)paren
suffix:semicolon
id|qw
op_assign
id|readq
c_func
(paren
id|qw
)paren
suffix:semicolon
multiline_comment|/* Address of banner */
r_if
c_cond
(paren
op_logical_neg
id|valid_fw_addr
c_func
(paren
id|qw
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|qw
op_assign
id|convert_fw_addr
c_func
(paren
id|nasid
comma
id|qw
)paren
suffix:semicolon
id|qwp
op_assign
(paren
r_int
r_int
op_star
)paren
id|qw
suffix:semicolon
id|bwp
op_assign
(paren
r_int
r_int
op_star
)paren
id|banner
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|banlen
op_div
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|bwp
(braket
id|i
)braket
op_assign
id|qwp
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
macro_line|#endif /* SUPPORT_OLD_PROMS */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * These two routines display the FIT table for each node.&n; */
r_static
r_int
DECL|function|dump_fit_entry
id|dump_fit_entry
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
op_star
id|fentry
)paren
(brace
r_int
id|type
suffix:semicolon
id|type
op_assign
id|FIT_TYPE
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%02x %-25s %x.%02x %016lx %u&bslash;n&quot;
comma
id|type
comma
id|fit_type_name
c_func
(paren
id|type
)paren
comma
id|FIT_MAJOR
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
comma
id|FIT_MINOR
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
comma
id|fentry
(braket
l_int|0
)braket
comma
multiline_comment|/* mult by sixteen to get size in bytes */
(paren
r_int
)paren
(paren
id|fentry
(braket
l_int|1
)braket
op_amp
l_int|0xffffff
)paren
op_star
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We assume that the fit table will be small enough that we can print&n; * the whole thing into one page.  (This is true for our default 16kB&n; * pages -- each entry is about 60 chars wide when printed.)  I read&n; * somewhere that the maximum size of the FIT is 128 entries, so we&squot;re&n; * OK except for 4kB pages (and no one is going to do that on SN&n; * anyway).&n; */
r_static
r_int
DECL|function|dump_fit
id|dump_fit
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
id|nasid
)paren
(brace
r_int
r_int
id|fentry
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|index
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|page
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|index
op_increment
)paren
(brace
id|BUG_ON
c_func
(paren
id|index
op_star
l_int|60
OG
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_fit_entry
c_func
(paren
id|nasid
comma
id|index
comma
id|fentry
comma
l_int|NULL
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|p
op_add_assign
id|dump_fit_entry
c_func
(paren
id|p
comma
id|fentry
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|dump_version
id|dump_version
c_func
(paren
r_char
op_star
id|page
comma
r_int
r_int
id|nasid
)paren
(brace
r_int
r_int
id|fentry
(braket
l_int|2
)braket
suffix:semicolon
r_char
id|banner
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|len
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_fit_entry
c_func
(paren
id|nasid
comma
id|index
comma
id|fentry
comma
id|banner
comma
r_sizeof
(paren
id|banner
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FIT_TYPE
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
op_eq
id|FIT_ENTRY_SAL_A
)paren
r_break
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%x.%02x&bslash;n&quot;
comma
id|FIT_MAJOR
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
comma
id|FIT_MINOR
c_func
(paren
id|fentry
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|page
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|banner
(braket
l_int|0
)braket
)paren
id|len
op_add_assign
id|snprintf
c_func
(paren
id|page
comma
id|PAGE_SIZE
op_minus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|banner
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* same as in proc_misc.c */
r_static
r_int
DECL|function|proc_calc_metrics
id|proc_calc_metrics
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_version_entry
id|read_version_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* data holds the NASID of the node */
id|len
op_assign
id|dump_version
c_func
(paren
id|page
comma
(paren
r_int
r_int
)paren
id|data
)paren
suffix:semicolon
id|len
op_assign
id|proc_calc_metrics
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_fit_entry
id|read_fit_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* data holds the NASID of the node */
id|len
op_assign
id|dump_fit
c_func
(paren
id|page
comma
(paren
r_int
r_int
)paren
id|data
)paren
suffix:semicolon
id|len
op_assign
id|proc_calc_metrics
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* module entry points */
r_int
id|__init
id|prominfo_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|__exit
id|prominfo_exit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|prominfo_init
id|module_init
c_func
(paren
id|prominfo_init
)paren
suffix:semicolon
DECL|variable|prominfo_exit
id|module_exit
c_func
(paren
id|prominfo_exit
)paren
suffix:semicolon
DECL|variable|proc_entries
r_static
r_struct
id|proc_dir_entry
op_star
op_star
id|proc_entries
suffix:semicolon
DECL|variable|sgi_prominfo_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|sgi_prominfo_entry
suffix:semicolon
DECL|macro|NODE_NAME_LEN
mdefine_line|#define NODE_NAME_LEN 11
r_int
id|__init
DECL|function|prominfo_init
id|prominfo_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
op_star
id|entp
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
r_int
r_int
id|nasid
suffix:semicolon
r_char
id|name
(braket
id|NODE_NAME_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|proc_entries
op_assign
id|kmalloc
c_func
(paren
id|numnodes
op_star
r_sizeof
(paren
r_struct
id|proc_dir_entry
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sgi_prominfo_entry
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;sgi_prominfo&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
comma
id|entp
op_assign
id|proc_entries
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
comma
id|entp
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;node%d&quot;
comma
id|cnodeid
)paren
suffix:semicolon
op_star
id|entp
op_assign
id|proc_mkdir
c_func
(paren
id|name
comma
id|sgi_prominfo_entry
)paren
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|p
op_assign
id|create_proc_read_entry
c_func
(paren
l_string|&quot;fit&quot;
comma
l_int|0
comma
op_star
id|entp
comma
id|read_fit_entry
comma
(paren
r_void
op_star
)paren
id|nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|p
op_assign
id|create_proc_read_entry
c_func
(paren
l_string|&quot;version&quot;
comma
l_int|0
comma
op_star
id|entp
comma
id|read_version_entry
comma
(paren
r_void
op_star
)paren
id|nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
id|__exit
DECL|function|prominfo_exit
id|prominfo_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
op_star
id|entp
suffix:semicolon
r_int
id|cnodeid
suffix:semicolon
r_char
id|name
(braket
id|NODE_NAME_LEN
)braket
suffix:semicolon
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
comma
id|entp
op_assign
id|proc_entries
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
comma
id|entp
op_increment
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;fit&quot;
comma
op_star
id|entp
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;version&quot;
comma
op_star
id|entp
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;node%d&quot;
comma
id|cnodeid
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|name
comma
id|sgi_prominfo_entry
)paren
suffix:semicolon
)brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;sgi_prominfo&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|proc_entries
)paren
suffix:semicolon
)brace
eof
