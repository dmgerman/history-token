multiline_comment|/*&n; * SN1 Platform specific SMP Support&n; *&n; * Copyright (C) 2000-2002 Silicon Graphics, Inc. All rights reserved.&n; * &n; * This program is free software; you can redistribute it and/or modify it &n; * under the terms of version 2 of the GNU General Public License &n; * as published by the Free Software Foundation.&n; * &n; * This program is distributed in the hope that it would be useful, but &n; * WITHOUT ANY WARRANTY; without even the implied warranty of &n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &n; * &n; * Further, this software is distributed without any warranty that it is &n; * free of the rightful claim of any third person regarding infringement &n; * or the like.  Any license provided herein, whether implied or &n; * otherwise, applies only to this software file.  Patent licenses, if &n; * any, provided herein do not apply to combinations of this program with &n; * other software, or any other product whatsoever.&n; * &n; * You should have received a copy of the GNU General Public &n; * License along with this program; if not, write the Free Software &n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; * &n; * Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pkwy, &n; * Mountain View, CA  94043, or:&n; * &n; * http://www.sgi.com &n; * &n; * For further information regarding this notice, see: &n; * &n; * http://oss.sgi.com/projects/GenInfo/NoticeExplan&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
multiline_comment|/*&n; * The following structure is used to pass params thru smp_call_function&n; * to other cpus for flushing TLB ranges.&n; */
r_typedef
r_struct
(brace
r_union
(brace
r_struct
(brace
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|end
r_int
r_int
id|end
suffix:semicolon
DECL|member|nbits
r_int
r_int
id|nbits
suffix:semicolon
DECL|member|rid
r_int
r_int
id|rid
suffix:semicolon
DECL|member|unfinished_count
id|atomic_t
id|unfinished_count
suffix:semicolon
DECL|member|ptc
)brace
id|ptc
suffix:semicolon
DECL|member|pad
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|ptc_params_t
)brace
id|ptc_params_t
suffix:semicolon
DECL|macro|NUMPTC
mdefine_line|#define NUMPTC&t;512
DECL|variable|ptcParamArray
r_static
id|ptc_params_t
id|ptcParamArray
(braket
id|NUMPTC
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
l_int|128
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* use separate cache lines on ptcParamsNextByCpu to avoid false sharing */
DECL|variable|ptcParamsNextByCpu
r_static
id|ptc_params_t
op_star
id|ptcParamsNextByCpu
(braket
id|NR_CPUS
op_star
l_int|16
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
l_int|128
)paren
)paren
)paren
suffix:semicolon
DECL|variable|__cacheline_aligned
r_static
r_volatile
id|ptc_params_t
op_star
id|ptcParamsEmpty
id|__cacheline_aligned
suffix:semicolon
multiline_comment|/*REFERENCED*/
DECL|variable|__cacheline_aligned
r_static
id|spinlock_t
id|ptcParamsLock
id|__cacheline_aligned
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|ptcInit
r_static
r_int
id|ptcInit
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef PTCDEBUG
DECL|variable|ptcParamsAllBusy
r_static
r_int
id|ptcParamsAllBusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* debugging/statistics */
DECL|variable|ptcCountBacklog
r_static
r_int
id|ptcCountBacklog
op_assign
l_int|0
suffix:semicolon
DECL|variable|ptcBacklog
r_static
r_int
id|ptcBacklog
(braket
id|NUMPTC
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|ptcParamsCounts
r_static
r_char
id|ptcParamsCounts
(braket
id|NR_CPUS
)braket
(braket
id|NUMPTC
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
l_int|128
)paren
)paren
)paren
suffix:semicolon
DECL|variable|ptcParamsResults
r_static
r_char
id|ptcParamsResults
(braket
id|NR_CPUS
)braket
(braket
id|NUMPTC
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
l_int|128
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Make smp_send_flush_tlbsmp_send_flush_tlb() a weak reference,&n; * so that we get a clean compile with the ia64 patch without the&n; * actual SN1 specific code in arch/ia64/kernel/smp.c.&n; */
r_extern
r_void
id|smp_send_flush_tlb
(paren
r_void
)paren
id|__attribute
c_func
(paren
(paren
id|weak
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * The following table/struct is for remembering PTC coherency domains. It&n; * is also used to translate sapicid into cpuids. We dont want to start &n; * cpus unless we know their cache domain.&n; */
macro_line|#ifdef PTC_NOTYET
DECL|variable|sn_sapicid_info
id|sn_sapicid_info_t
id|sn_sapicid_info
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * sn1_ptc_l_range - purge local translation cache&n; * @start: start of virtual address range&n; * @end: end of virtual address range&n; * @nbits: specifies number of bytes to purge per instruction (num = 1&lt;&lt;(nbits &amp; 0xfc))&n; *&n; * Purges the range specified from the local processor&squot;s translation cache&n; * (as opposed to the translation registers).  Note that more than the specified&n; * range *may* be cleared from the cache by some processors.&n; *&n; * This is probably not good enough, but I don&squot;t want to try to make it better &n; * until I get some statistics on a running system. At a minimum, we should only &n; * send IPIs to 1 processor in each TLB domain &amp; have it issue a ptc.g on it&squot;s &n; * own FSB. Also, we only have to serialize per FSB, not globally.&n; *&n; * More likely, we will have to do some work to reduce the frequency of calls to&n; * this routine.&n; */
r_static
r_inline
r_void
DECL|function|sn1_ptc_l_range
id|sn1_ptc_l_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|nbits
)paren
(brace
r_do
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ptc.l %0,%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|start
)paren
comma
l_string|&quot;r&quot;
(paren
id|nbits
op_lshift
l_int|2
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|start
op_add_assign
(paren
l_int|1UL
op_lshift
id|nbits
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
OL
id|end
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn1_received_flush_tlb - cpu tlb flush routine&n; *&n; * Flushes the TLB of a given processor.&n; */
r_void
DECL|function|sn1_received_flush_tlb
id|sn1_received_flush_tlb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|start
comma
id|end
comma
id|nbits
suffix:semicolon
r_int
r_int
id|rid
comma
id|saved_rid
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|ptc_params_t
op_star
id|ptcParams
suffix:semicolon
id|ptcParams
op_assign
id|ptcParamsNextByCpu
(braket
id|cpu
op_star
l_int|16
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ptcParams
op_eq
id|ptcParamsEmpty
)paren
r_return
suffix:semicolon
r_do
(brace
id|start
op_assign
id|ptcParams-&gt;ptc.start
suffix:semicolon
id|saved_rid
op_assign
(paren
r_int
r_int
)paren
id|ia64_get_rr
c_func
(paren
id|start
)paren
suffix:semicolon
id|end
op_assign
id|ptcParams-&gt;ptc.end
suffix:semicolon
id|nbits
op_assign
id|ptcParams-&gt;ptc.nbits
suffix:semicolon
id|rid
op_assign
id|ptcParams-&gt;ptc.rid
suffix:semicolon
r_if
c_cond
(paren
id|saved_rid
op_ne
id|rid
)paren
(brace
id|ia64_set_rr
c_func
(paren
id|start
comma
(paren
r_int
r_int
)paren
id|rid
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
id|sn1_ptc_l_range
c_func
(paren
id|start
comma
id|end
comma
id|nbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saved_rid
op_ne
id|rid
)paren
id|ia64_set_rr
c_func
(paren
id|start
comma
(paren
r_int
r_int
)paren
id|saved_rid
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|atomic_dec
c_func
(paren
op_amp
id|ptcParams-&gt;ptc.unfinished_count
)paren
suffix:semicolon
macro_line|#ifdef PTCDEBUG
(brace
r_int
id|i
op_assign
id|ptcParams
op_minus
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
id|ptcParamsResults
(braket
id|cpu
)braket
(braket
id|i
)braket
op_assign
(paren
r_char
)paren
id|result
suffix:semicolon
id|ptcParamsCounts
(braket
id|cpu
)braket
(braket
id|i
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif /* PTCDEBUG */
r_if
c_cond
(paren
op_increment
id|ptcParams
op_eq
op_amp
id|ptcParamArray
(braket
id|NUMPTC
)braket
)paren
id|ptcParams
op_assign
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ptcParams
op_ne
id|ptcParamsEmpty
)paren
suffix:semicolon
id|ptcParamsNextByCpu
(braket
id|cpu
op_star
l_int|16
)braket
op_assign
id|ptcParams
suffix:semicolon
)brace
multiline_comment|/**&n; * sn1_global_tlb_purge - flush a translation cache range on all processors&n; * @start: start of virtual address range to flush&n; * @end: end of virtual address range&n; * @nbits: specifies number of bytes to purge per instruction (num = 1&lt;&lt;(nbits &amp; 0xfc))&n; *&n; * Flushes the translation cache of all processors from @start to @end.&n; */
r_void
DECL|function|sn1_global_tlb_purge
id|sn1_global_tlb_purge
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|nbits
)paren
(brace
id|ptc_params_t
op_star
id|params
suffix:semicolon
id|ptc_params_t
op_star
id|next
suffix:semicolon
r_int
r_int
id|irqflags
suffix:semicolon
macro_line|#ifdef PTCDEBUG
id|ptc_params_t
op_star
id|nextnext
suffix:semicolon
r_int
id|backlog
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|smp_num_cpus
op_eq
l_int|1
)paren
(brace
id|sn1_ptc_l_range
c_func
(paren
id|start
comma
id|end
comma
id|nbits
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  If at interrupt level and cannot get spinlock, &n;&t;&t; *  then do something useful by flushing own tlbflush queue&n;&t;&t; *  so as to avoid a possible deadlock.&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|ptcParamsLock
)paren
)paren
(brace
id|local_irq_save
c_func
(paren
id|irqflags
)paren
suffix:semicolon
id|sn1_received_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|irqflags
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* take it easier on the bus */
)brace
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|ptcParamsLock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ptcInit
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|ptcInit
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|ptcParamArray
comma
l_int|0
comma
r_sizeof
(paren
id|ptcParamArray
)paren
)paren
suffix:semicolon
id|ptcParamsEmpty
op_assign
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
id|ptcParamsNextByCpu
(braket
id|cpu
op_star
l_int|16
)braket
op_assign
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef PTCDEBUG
id|memset
c_func
(paren
id|ptcBacklog
comma
l_int|0
comma
r_sizeof
(paren
id|ptcBacklog
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ptcParamsCounts
comma
l_int|0
comma
r_sizeof
(paren
id|ptcParamsCounts
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ptcParamsResults
comma
l_int|0
comma
r_sizeof
(paren
id|ptcParamsResults
)paren
)paren
suffix:semicolon
macro_line|#endif&t;/* PTCDEBUG */
)brace
id|params
op_assign
(paren
id|ptc_params_t
op_star
)paren
id|ptcParamsEmpty
suffix:semicolon
id|next
op_assign
(paren
id|ptc_params_t
op_star
)paren
id|ptcParamsEmpty
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
op_amp
id|ptcParamArray
(braket
id|NUMPTC
)braket
)paren
id|next
op_assign
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef PTCDEBUG
id|nextnext
op_assign
id|next
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nextnext
op_eq
op_amp
id|ptcParamArray
(braket
id|NUMPTC
)braket
)paren
id|nextnext
op_assign
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ptcCountBacklog
)paren
(brace
multiline_comment|/* quick count of backlog */
id|ptc_params_t
op_star
id|ptr
suffix:semicolon
multiline_comment|/* check the current pointer to the beginning */
id|ptr
op_assign
id|params
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|ptr
op_ge
op_amp
id|ptcParamArray
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ptr-&gt;ptc.unfinished_count
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
op_increment
id|backlog
suffix:semicolon
)brace
r_if
c_cond
(paren
id|backlog
)paren
(brace
multiline_comment|/* check the end of the array */
id|ptr
op_assign
op_amp
id|ptcParamArray
(braket
id|NUMPTC
)braket
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|ptr
OG
id|params
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ptr-&gt;ptc.unfinished_count
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
op_increment
id|backlog
suffix:semicolon
)brace
)brace
id|ptcBacklog
(braket
id|backlog
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif&t;/* PTCDEBUG */
multiline_comment|/* wait for the next entry to clear...should be rare */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|next-&gt;ptc.unfinished_count
)paren
OG
l_int|0
)paren
(brace
macro_line|#ifdef PTCDEBUG
id|ptcParamsAllBusy
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nextnext-&gt;ptc.unfinished_count
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|next-&gt;ptc.unfinished_count
)paren
OG
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;&bslash;nnonzero next zero nextnext %lx %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|next
comma
(paren
r_int
)paren
id|nextnext
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* it could be this cpu that is behind */
id|local_irq_save
c_func
(paren
id|irqflags
)paren
suffix:semicolon
id|sn1_received_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|irqflags
)paren
suffix:semicolon
multiline_comment|/* now we know it&squot;s not this cpu, so just wait */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|next-&gt;ptc.unfinished_count
)paren
OG
l_int|0
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|params-&gt;ptc.start
op_assign
id|start
suffix:semicolon
id|params-&gt;ptc.end
op_assign
id|end
suffix:semicolon
id|params-&gt;ptc.nbits
op_assign
id|nbits
suffix:semicolon
id|params-&gt;ptc.rid
op_assign
(paren
r_int
r_int
)paren
id|ia64_get_rr
c_func
(paren
id|start
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|params-&gt;ptc.unfinished_count
comma
id|smp_num_cpus
)paren
suffix:semicolon
multiline_comment|/* The atomic_set above can hit memory *after* the update&n;&t; * to ptcParamsEmpty below, which opens a timing window&n;&t; * that other cpus can squeeze into!&n;&t; */
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* everything is ready to process:&n;&t; *&t;-- global lock is held&n;&t; *&t;-- new entry + 1 is free&n;&t; *&t;-- new entry is set up&n;&t; * so now:&n;&t; *&t;-- update the global next pointer&n;&t; *&t;-- unlock the global lock&n;&t; *&t;-- send IPI to notify other cpus&n;&t; *&t;-- process the data ourselves&n;&t; */
id|ptcParamsEmpty
op_assign
id|next
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ptcParamsLock
)paren
suffix:semicolon
id|smp_send_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|irqflags
)paren
suffix:semicolon
id|sn1_received_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|irqflags
)paren
suffix:semicolon
multiline_comment|/* Currently we don&squot;t think global TLB purges need to be atomic.&n;&t; * All CPUs get sent IPIs, so if they haven&squot;t done the purge,&n;&t; * they&squot;re busy with interrupts that are at the IPI level, which is&n;&t; * priority 15.  We&squot;re asserting that any code at that level&n;&t; * shouldn&squot;t be using user TLB entries.  To change this to wait&n;&t; * for all the flushes to complete, enable the following code.&n;&t; */
macro_line|#if defined(SN1_SYNCHRONOUS_GLOBAL_TLB_PURGE) || defined(BUS_INT_WAR)
multiline_comment|/* this code is not tested */
multiline_comment|/* wait for the flush to complete */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|params-&gt;ptc.unfinished_count
)paren
OG
l_int|0
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * sn_send_IPI_phys - send an IPI to a Nasid and slice&n; * @physid: physical cpuid to receive the interrupt.&n; * @vector: command to send&n; * @delivery_mode: delivery mechanism&n; *&n; * Sends an IPI (interprocessor interrupt) to the processor specified by&n; * @physid&n; *&n; * @delivery_mode can be one of the following&n; *&n; * %IA64_IPI_DM_INT - pend an interrupt&n; * %IA64_IPI_DM_PMI - pend a PMI&n; * %IA64_IPI_DM_NMI - pend an NMI&n; * %IA64_IPI_DM_INIT - pend an INIT interrupt&n; */
r_void
DECL|function|sn_send_IPI_phys
id|sn_send_IPI_phys
c_func
(paren
r_int
id|physid
comma
r_int
id|vector
comma
r_int
id|delivery_mode
)paren
(brace
r_int
op_star
id|p
suffix:semicolon
r_int
id|nasid
comma
id|slice
suffix:semicolon
r_static
r_int
id|off
(braket
l_int|4
)braket
op_assign
(brace
l_int|0x1800080
comma
l_int|0x1800088
comma
l_int|0x1a00080
comma
l_int|0x1a00088
)brace
suffix:semicolon
macro_line|#ifdef BUS_INT_WAR
r_if
c_cond
(paren
id|vector
op_ne
id|ap_wakeup_vector
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif
id|nasid
op_assign
id|cpu_physical_id_to_nasid
c_func
(paren
id|physid
)paren
suffix:semicolon
id|slice
op_assign
id|cpu_physical_id_to_slice
c_func
(paren
id|physid
)paren
suffix:semicolon
id|p
op_assign
(paren
r_int
op_star
)paren
(paren
l_int|0xc0000a0000000000LL
op_or
(paren
id|nasid
op_lshift
l_int|33
)paren
op_or
id|off
(braket
id|slice
)braket
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
id|p
op_assign
(paren
id|delivery_mode
op_lshift
l_int|8
)paren
op_or
(paren
id|vector
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn1_send_IPI - send an IPI to a processor&n; * @cpuid: target of the IPI&n; * @vector: command to send&n; * @delivery_mode: delivery mechanism&n; * @redirect: redirect the IPI?&n; *&n; * Sends an IPI (interprocessor interrupt) to the processor specified by&n; * @cpuid.  @delivery_mode can be one of the following&n; *&n; * %IA64_IPI_DM_INT - pend an interrupt&n; * %IA64_IPI_DM_PMI - pend a PMI&n; * %IA64_IPI_DM_NMI - pend an NMI&n; * %IA64_IPI_DM_INIT - pend an INIT interrupt&n; */
r_void
DECL|function|sn1_send_IPI
id|sn1_send_IPI
c_func
(paren
r_int
id|cpuid
comma
r_int
id|vector
comma
r_int
id|delivery_mode
comma
r_int
id|redirect
)paren
(brace
r_int
id|physid
suffix:semicolon
id|physid
op_assign
id|cpu_physical_id
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|sn_send_IPI_phys
c_func
(paren
id|physid
comma
id|vector
comma
id|delivery_mode
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
macro_line|#ifdef PTC_NOTYET
r_static
r_void
id|__init
DECL|function|process_sal_ptc_domain_info
id|process_sal_ptc_domain_info
c_func
(paren
id|ia64_sal_ptc_domain_info_t
op_star
id|di
comma
r_int
id|domain
)paren
(brace
id|ia64_sal_ptc_domain_proc_entry_t
op_star
id|pe
suffix:semicolon
r_int
id|i
comma
id|sapicid
comma
id|cpuid
suffix:semicolon
id|pe
op_assign
id|__va
c_func
(paren
id|di-&gt;proc_list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|di-&gt;proc_count
suffix:semicolon
id|i
op_increment
comma
id|pe
op_increment
)paren
(brace
id|sapicid
op_assign
id|id_eid_to_sapicid
c_func
(paren
id|pe-&gt;id
comma
id|pe-&gt;eid
)paren
suffix:semicolon
id|cpuid
op_assign
id|cpu_logical_id
c_func
(paren
id|sapicid
)paren
suffix:semicolon
id|sn_sapicid_info
(braket
id|cpuid
)braket
dot
id|domain
op_assign
id|domain
suffix:semicolon
id|sn_sapicid_info
(braket
id|cpuid
)braket
dot
id|sapicid
op_assign
id|sapicid
suffix:semicolon
)brace
)brace
r_static
r_void
id|__init
DECL|function|process_sal_desc_ptc
id|process_sal_desc_ptc
c_func
(paren
id|ia64_sal_desc_ptc_t
op_star
id|ptc
)paren
(brace
id|ia64_sal_ptc_domain_info_t
op_star
id|di
suffix:semicolon
r_int
id|i
suffix:semicolon
id|di
op_assign
id|__va
c_func
(paren
id|ptc-&gt;domain_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ptc-&gt;num_domains
suffix:semicolon
id|i
op_increment
comma
id|di
op_increment
)paren
(brace
id|process_sal_ptc_domain_info
c_func
(paren
id|di
comma
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* PTC_NOTYET */
multiline_comment|/**&n; * init_sn1_smp_config - setup PTC domains per processor&n; */
r_void
id|__init
DECL|function|init_sn1_smp_config
id|init_sn1_smp_config
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ia64_ptc_domain_info
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP: Can&squot;t find PTC domain info. Forcing UP mode&bslash;n&quot;
)paren
suffix:semicolon
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PTC_NOTYET
id|memset
(paren
id|sn_sapicid_info
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|sn_sapicid_info
)paren
)paren
suffix:semicolon
id|process_sal_desc_ptc
c_func
(paren
id|ia64_ptc_domain_info
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* CONFIG_SMP */
r_void
id|__init
DECL|function|init_sn1_smp_config
id|init_sn1_smp_config
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef PTC_NOTYET
id|sn_sapicid_info
(braket
l_int|0
)braket
dot
id|sapicid
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* CONFIG_SMP */
eof
