multiline_comment|/*&n; * SN1 Platform specific SMP Support&n; *&n; * Copyright (C) 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 Jack Steiner &lt;steiner@sgi.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/sn/mmzone_sn1.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
multiline_comment|/*&n; * The following structure is used to pass params thru smp_call_function&n; * to other cpus for flushing TLB ranges.&n; */
r_typedef
r_struct
(brace
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|end
r_int
r_int
id|end
suffix:semicolon
DECL|member|nbits
r_int
r_int
id|nbits
suffix:semicolon
DECL|typedef|ptc_params_t
)brace
id|ptc_params_t
suffix:semicolon
multiline_comment|/*&n; * The following table/struct is for remembering PTC coherency domains. It&n; * is also used to translate sapicid into cpuids. We dont want to start &n; * cpus unless we know their cache domain.&n; */
macro_line|#ifdef PTC_NOTYET
DECL|variable|sn_sapicid_info
id|sn_sapicid_info_t
id|sn_sapicid_info
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PTC_NOTYET
multiline_comment|/*&n; * NOTE: This is probably not good enough, but I dont want to try to make&n; * it better until I get some statistics on a running system. &n; * At a minimum, we should only send IPIs to 1 processor in each TLB domain&n; * &amp; have it issue a ptc.g on it&squot;s own FSB. Also, serialize per FSB, not &n; * globally.&n; *&n; * More likely, we will have to do some work to reduce the frequency of calls to&n; * this routine.&n; */
r_static
r_void
DECL|function|sn1_ptc_local
id|sn1_ptc_local
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|ptc_params_t
op_star
id|params
op_assign
id|arg
suffix:semicolon
r_int
r_int
id|start
comma
id|end
comma
id|nbits
suffix:semicolon
id|start
op_assign
id|params-&gt;start
suffix:semicolon
id|end
op_assign
id|params-&gt;end
suffix:semicolon
id|nbits
op_assign
id|params-&gt;nbits
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ptc.l %0,%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|start
)paren
comma
l_string|&quot;r&quot;
(paren
id|nbits
op_lshift
l_int|2
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|start
op_add_assign
(paren
l_int|1UL
op_lshift
id|nbits
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
OL
id|end
)paren
suffix:semicolon
)brace
r_void
DECL|function|sn1_ptc_global
id|sn1_ptc_global
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|nbits
)paren
(brace
id|ptc_params_t
id|params
suffix:semicolon
id|params.start
op_assign
id|start
suffix:semicolon
id|params.end
op_assign
id|end
suffix:semicolon
id|params.nbits
op_assign
id|nbits
suffix:semicolon
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|sn1_ptc_local
comma
op_amp
id|params
comma
l_int|1
comma
l_int|0
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Unable to do ptc_global - timed out&quot;
)paren
suffix:semicolon
id|sn1_ptc_local
c_func
(paren
op_amp
id|params
)paren
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|sn1_send_IPI
id|sn1_send_IPI
c_func
(paren
r_int
id|cpuid
comma
r_int
id|vector
comma
r_int
id|delivery_mode
comma
r_int
id|redirect
)paren
(brace
r_int
op_star
id|p
comma
id|nasid
comma
id|slice
suffix:semicolon
r_static
r_int
id|off
(braket
l_int|4
)braket
op_assign
(brace
l_int|0x1800080
comma
l_int|0x1800088
comma
l_int|0x1a00080
comma
l_int|0x1a00088
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * ZZZ - Replace with standard macros when available.&n;&t; */
id|nasid
op_assign
id|cpuid_to_nasid
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|slice
op_assign
id|cpuid_to_slice
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|p
op_assign
(paren
r_int
op_star
)paren
(paren
l_int|0xc0000a0000000000LL
op_or
(paren
id|nasid
op_lshift
l_int|33
)paren
op_or
id|off
(braket
id|slice
)braket
)paren
suffix:semicolon
macro_line|#if defined(ZZZBRINGUP)
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
op_increment
OL
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ZZ sendIPI 0x%x-&gt;0x%x, vec %d, nasid 0x%lx, slice %ld, adr 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpuid
comma
id|vector
comma
id|nasid
comma
id|slice
comma
(paren
r_int
)paren
id|p
)paren
suffix:semicolon
)brace
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
id|p
op_assign
(paren
id|delivery_mode
op_lshift
l_int|8
)paren
op_or
(paren
id|vector
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|__init
DECL|function|process_sal_ptc_domain_info
id|process_sal_ptc_domain_info
c_func
(paren
id|ia64_sal_ptc_domain_info_t
op_star
id|di
comma
r_int
id|domain
)paren
(brace
macro_line|#ifdef PTC_NOTYET
id|ia64_sal_ptc_domain_proc_entry_t
op_star
id|pe
suffix:semicolon
r_int
id|i
comma
id|sapicid
comma
id|cpuid
suffix:semicolon
id|pe
op_assign
id|__va
c_func
(paren
id|di-&gt;proc_list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|di-&gt;proc_count
suffix:semicolon
id|i
op_increment
comma
id|pe
op_increment
)paren
(brace
id|sapicid
op_assign
id|id_eid_to_sapicid
c_func
(paren
id|pe-&gt;id
comma
id|pe-&gt;eid
)paren
suffix:semicolon
id|cpuid
op_assign
id|cpu_logical_id
c_func
(paren
id|sapicid
)paren
suffix:semicolon
id|sn_sapicid_info
(braket
id|cpuid
)braket
dot
id|domain
op_assign
id|domain
suffix:semicolon
id|sn_sapicid_info
(braket
id|cpuid
)braket
dot
id|sapicid
op_assign
id|sapicid
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
id|__init
DECL|function|process_sal_desc_ptc
id|process_sal_desc_ptc
c_func
(paren
id|ia64_sal_desc_ptc_t
op_star
id|ptc
)paren
(brace
id|ia64_sal_ptc_domain_info_t
op_star
id|di
suffix:semicolon
r_int
id|i
suffix:semicolon
id|di
op_assign
id|__va
c_func
(paren
id|ptc-&gt;domain_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ptc-&gt;num_domains
suffix:semicolon
id|i
op_increment
comma
id|di
op_increment
)paren
(brace
id|process_sal_ptc_domain_info
c_func
(paren
id|di
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_void
id|__init
DECL|function|init_sn1_smp_config
id|init_sn1_smp_config
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ia64_ptc_domain_info
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP: Can&squot;t find PTC domain info. Forcing UP mode&bslash;n&quot;
)paren
suffix:semicolon
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PTC_NOTYET
id|memset
(paren
id|sn_sapicid_info
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|sn_sapicid_info
)paren
)paren
suffix:semicolon
id|process_sal_desc_ptc
c_func
(paren
id|ia64_ptc_domain_info
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* CONFIG_SMP */
r_void
id|__init
DECL|function|init_sn1_smp_config
id|init_sn1_smp_config
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef PTC_NOTYET
id|sn_sapicid_info
(braket
l_int|0
)braket
dot
id|sapicid
op_assign
id|hard_processor_sapicid
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* CONFIG_SMP */
eof
