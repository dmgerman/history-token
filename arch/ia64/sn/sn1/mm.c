multiline_comment|/*&n; * Copyright, 2000, Silicon Graphics.&n; * Copyright Srinivasa Thirumalachar (sprasad@engr.sgi.com)&n; * Copyright 2000 Kanoj Sarcar (kanoj@sgi.com)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/efi.h&gt;
macro_line|#include &lt;asm/sn/mmzone_sn1.h&gt;
DECL|macro|MIN
macro_line|#       define MIN(a,b)         ((a) &lt; (b) ? (a) : (b))
DECL|macro|MAX
macro_line|#       define MAX(a,b)         ((a) &gt; (b) ? (a) : (b))
multiline_comment|/*&n; * Note that the nodemem[] data structure does not support arbitrary&n; * memory types and memory descriptors inside the node. For example, &n; * you can not have multiple efi-mem-type segments in the node and&n; * expect the OS not to use specific mem-types. Currently, the &n; * assumption is that &quot;start&quot; is the start of virtual/physical memory &n; * on the node. PROM can reserve some memory _only_ at the beginning. &n; * This is tracked via the &quot;usable&quot; field, that maintains where the &n; * os can start using memory from on a node (ie end of PROM memory).&n; * setup_node_bootmem() is passed the above &quot;usable&quot; value, and is&n; * expected to make bootmem calls that ensure lower memory is not used.&n; * Note that the bootmem for a node is initialized on the entire node, &n; * without regards to any holes - then we reserve the holes in &n; * setup_sn1_bootmem(), to make sure the holes are not handed out by&n; * alloc_bootmem, as well as the corresponding mem_map entries are not&n; * considered allocatable by the page_alloc routines.&n; */
DECL|struct|nodemem_s
r_struct
id|nodemem_s
(brace
DECL|member|start
id|u64
id|start
suffix:semicolon
DECL|member|end
id|u64
id|end
suffix:semicolon
DECL|member|hole
id|u64
id|hole
(braket
id|SN1_MAX_BANK_PER_NODE
)braket
suffix:semicolon
DECL|member|usable
id|u64
id|usable
suffix:semicolon
DECL|variable|nodemem
)brace
id|nodemem
(braket
id|MAXNODES
)braket
suffix:semicolon
DECL|variable|nodemem_valid
r_static
r_int
id|nodemem_valid
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|__init
DECL|function|free_unused_memmap_hole
id|free_unused_memmap_hole
c_func
(paren
r_int
id|nid
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
id|pageend
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get the memmap ptrs to the start and end of the holes.&n;&t; * virt_to_page(start) will panic, if start is in hole.&n;&t; * Can we do virt_to_page(end), if end is on the next node?&n;&t; */
id|page
op_assign
id|virt_to_page
c_func
(paren
id|start
op_minus
l_int|1
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
id|pageend
op_assign
id|virt_to_page
c_func
(paren
id|end
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hpage=0x%lx, hpageend=0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|page
comma
(paren
id|u64
)paren
id|pageend
)paren
suffix:semicolon
id|free_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|nid
)paren
comma
id|__pa
c_func
(paren
id|page
)paren
comma
(paren
id|u64
)paren
id|pageend
op_minus
(paren
id|u64
)paren
id|page
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_void
DECL|function|free_unused_memmap_node
id|free_unused_memmap_node
c_func
(paren
r_int
id|nid
)paren
(brace
id|u64
id|i
op_assign
l_int|0
suffix:semicolon
id|u64
id|holestart
op_assign
op_minus
l_int|1
suffix:semicolon
r_do
(brace
id|holestart
op_assign
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
OL
id|SN1_MAX_BANK_PER_NODE
)paren
op_logical_and
(paren
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|i
)braket
op_eq
(paren
id|u64
)paren
op_minus
l_int|1
)paren
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|SN1_MAX_BANK_PER_NODE
)paren
id|free_unused_memmap_hole
c_func
(paren
id|nid
comma
id|holestart
comma
id|nodemem
(braket
id|nid
)braket
dot
id|start
op_plus
(paren
id|i
op_lshift
id|SN1_BANK_ADDR_SHIFT
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|SN1_MAX_BANK_PER_NODE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Since efi_memmap_walk merges contiguous banks, this code will need&n; * to find all the nasid/banks covered by the input memory descriptor.&n; */
r_static
r_int
id|__init
DECL|function|build_nodemem_map
id|build_nodemem_map
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|vaddr
op_assign
id|start
suffix:semicolon
r_int
r_int
id|nvaddr
suffix:semicolon
r_int
id|nasid
op_assign
id|GetNasId
c_func
(paren
id|__pa
c_func
(paren
id|vaddr
)paren
)paren
suffix:semicolon
r_int
id|cnodeid
comma
id|bankid
suffix:semicolon
r_while
c_loop
(paren
id|vaddr
OL
id|end
)paren
(brace
id|cnodeid
op_assign
id|NASID_TO_CNODEID
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|bankid
op_assign
id|GetBankId
c_func
(paren
id|__pa
c_func
(paren
id|vaddr
)paren
)paren
suffix:semicolon
id|nodemem
(braket
id|cnodeid
)braket
dot
id|start
op_assign
id|MIN
c_func
(paren
id|nodemem
(braket
id|cnodeid
)braket
dot
id|start
comma
id|vaddr
)paren
suffix:semicolon
id|nodemem
(braket
id|cnodeid
)braket
dot
id|usable
op_assign
id|MIN
c_func
(paren
id|nodemem
(braket
id|cnodeid
)braket
dot
id|usable
comma
id|vaddr
)paren
suffix:semicolon
id|nvaddr
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
(paren
r_int
r_int
)paren
(paren
op_increment
id|nasid
)paren
op_lshift
id|SN1_NODE_ADDR_SHIFT
)paren
suffix:semicolon
id|nodemem
(braket
id|cnodeid
)braket
dot
id|end
op_assign
id|MAX
c_func
(paren
id|nodemem
(braket
id|cnodeid
)braket
dot
id|end
comma
id|MIN
c_func
(paren
id|end
comma
id|nvaddr
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bankid
OL
id|SN1_MAX_BANK_PER_NODE
)paren
op_logical_and
(paren
id|vaddr
OL
id|nodemem
(braket
id|cnodeid
)braket
dot
id|end
)paren
)paren
(brace
id|nvaddr
op_assign
id|nodemem
(braket
id|cnodeid
)braket
dot
id|start
op_plus
(paren
(paren
r_int
r_int
)paren
(paren
id|bankid
op_plus
l_int|1
)paren
op_lshift
id|SN1_BANK_ADDR_SHIFT
)paren
suffix:semicolon
id|nodemem
(braket
id|cnodeid
)braket
dot
id|hole
(braket
id|bankid
op_increment
)braket
op_assign
id|MIN
c_func
(paren
id|nvaddr
comma
id|end
)paren
suffix:semicolon
id|vaddr
op_assign
id|nvaddr
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|pgtbl_size_ok
id|pgtbl_size_ok
c_func
(paren
r_int
id|nid
)paren
(brace
r_int
r_int
id|numpfn
comma
id|bank0size
comma
id|nodesize
suffix:semicolon
id|nodesize
op_assign
id|nodemem
(braket
id|nid
)braket
dot
id|end
op_minus
id|nodemem
(braket
id|nid
)braket
dot
id|start
suffix:semicolon
id|numpfn
op_assign
id|nodesize
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|bank0size
op_assign
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
l_int|0
)braket
op_minus
id|nodemem
(braket
id|nid
)braket
dot
id|start
suffix:semicolon
multiline_comment|/* If nid == master node &amp;&amp; no kernel text replication */
id|bank0size
op_sub_assign
l_int|0xA00000
suffix:semicolon
multiline_comment|/* Kernel text + stuff */
id|bank0size
op_sub_assign
(paren
(paren
id|numpfn
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|numpfn
op_star
r_sizeof
(paren
id|mem_map_t
)paren
)paren
OG
id|bank0size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nid = %d, ns=0x%lx, npfn=0x%lx, bank0size=0x%lx&bslash;n&quot;
comma
id|nid
comma
id|nodesize
comma
id|numpfn
comma
id|bank0size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|check_pgtbl_size
id|check_pgtbl_size
c_func
(paren
r_int
id|nid
)paren
(brace
r_int
id|bank
op_assign
id|SN1_MAX_BANK_PER_NODE
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Find highest bank with valid memory */
r_while
c_loop
(paren
(paren
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|bank
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|bank
)paren
)paren
id|bank
op_decrement
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|pgtbl_size_ok
c_func
(paren
id|nid
)paren
)paren
(brace
multiline_comment|/* Remove that bank of memory */
multiline_comment|/* Collect some numbers later */
id|printk
c_func
(paren
l_string|&quot;Ignoring node %d bank %d&bslash;n&quot;
comma
id|nid
comma
id|bank
)paren
suffix:semicolon
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|bank
op_decrement
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Get to the next populated bank */
r_while
c_loop
(paren
(paren
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|bank
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|bank
)paren
)paren
id|bank
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using only upto bank %d on node %d&bslash;n&quot;
comma
id|bank
comma
id|nid
)paren
suffix:semicolon
id|nodemem
(braket
id|nid
)braket
dot
id|end
op_assign
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|bank
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bank
)paren
r_break
suffix:semicolon
)brace
)brace
r_void
id|dump_nodemem_map
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
r_extern
id|bootmem_data_t
id|bdata
(braket
)braket
suffix:semicolon
DECL|variable|curnodeid
r_static
r_int
id|curnodeid
suffix:semicolon
r_static
r_int
id|__init
DECL|function|setup_node_bootmem
id|setup_node_bootmem
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|nodefree
)paren
(brace
r_extern
r_char
id|_end
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|kernelend
op_assign
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
(paren
op_amp
id|_end
)paren
)paren
suffix:semicolon
r_int
r_int
id|pkernelend
op_assign
id|__pa
c_func
(paren
id|kernelend
)paren
suffix:semicolon
r_int
r_int
id|bootmap_start
comma
id|bootmap_size
suffix:semicolon
r_int
r_int
id|pstart
comma
id|pend
suffix:semicolon
id|pstart
op_assign
id|__pa
c_func
(paren
id|start
)paren
suffix:semicolon
id|pend
op_assign
id|__pa
c_func
(paren
id|end
)paren
suffix:semicolon
multiline_comment|/* If we are past a node mem boundary, on simulated dig numa&n;&t; * increment current node id. */
id|curnodeid
op_assign
id|NASID_TO_CNODEID
c_func
(paren
id|GetNasId
c_func
(paren
id|pstart
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;        * Make sure we are being passed page aligned addresses.&n;        */
r_if
c_cond
(paren
(paren
id|start
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|end
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;setup_node_bootmem:align&quot;
)paren
suffix:semicolon
multiline_comment|/* For now, just go to the lower CHUNK alignment so that &n;&t; * chunktonid of 0-8MB and other lower mem pages get initted. */
id|pstart
op_and_assign
id|CHUNKMASK
suffix:semicolon
id|pend
op_assign
(paren
id|pend
op_plus
id|CHUNKSZ
op_minus
l_int|1
)paren
op_amp
id|CHUNKMASK
suffix:semicolon
multiline_comment|/* If pend == 0, both addrs below 8 MB, special case it&n;&t; * FIX: CHUNKNUM(pend-1) broken if pend == 0 &n;&t; * both addrs within 8MB */
r_if
c_cond
(paren
id|pend
op_eq
l_int|0
)paren
(brace
id|chunktonid
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fill up the chunktonid array first. */
r_for
c_loop
(paren
id|i
op_assign
id|PCHUNKNUM
c_func
(paren
id|pstart
)paren
suffix:semicolon
id|i
op_le
id|PCHUNKNUM
c_func
(paren
id|pend
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
id|chunktonid
(braket
id|i
)braket
op_assign
id|curnodeid
suffix:semicolon
multiline_comment|/* This check is bogus for now till MAXCHUNKS is properly&n;&t; * defined to say if it includes holes or not. */
r_if
c_cond
(paren
(paren
id|CHUNKTONID
c_func
(paren
id|PCHUNKNUM
c_func
(paren
id|pend
)paren
)paren
OG
id|MAXCHUNKS
)paren
op_logical_or
(paren
id|PCHUNKNUM
c_func
(paren
id|pstart
)paren
op_ge
id|PCHUNKNUM
c_func
(paren
id|pend
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ign 0x%lx-0x%lx, &quot;
comma
id|__pa
c_func
(paren
id|start
)paren
comma
id|__pa
c_func
(paren
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine gets called many times in node 0.&n;&t; * The first one to reach here would be the one after&n;&t; * kernelend to end of first node. */
id|NODE_DATA
c_func
(paren
id|curnodeid
)paren
op_member_access_from_pointer
id|bdata
op_assign
op_amp
(paren
id|bdata
(braket
id|curnodeid
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curnodeid
op_eq
l_int|0
)paren
(brace
multiline_comment|/* for master node, forcibly assign these values&n;&t;&t; * This gets called many times on dig but we&n;&t;&t; * want these exact values &n;&t;&t; * Also on softsdv, the memdesc for 0 is missing */
id|NODE_START
c_func
(paren
id|curnodeid
)paren
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|NODE_SIZE
c_func
(paren
id|curnodeid
)paren
op_assign
(paren
id|end
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This gets called only once for non zero nodes&n;&t;&t; * If it does not, then NODE_STARt should be &n;&t;&t; * LOCAL_BASE(nid) */
id|NODE_START
c_func
(paren
id|curnodeid
)paren
op_assign
id|start
suffix:semicolon
id|NODE_SIZE
c_func
(paren
id|curnodeid
)paren
op_assign
(paren
id|end
op_minus
id|start
)paren
suffix:semicolon
)brace
multiline_comment|/* if end &lt; kernelend do not do anything below this */
r_if
c_cond
(paren
id|pend
OL
id|pkernelend
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;        * Handle the node that contains kernel text/data. It would&n;        * be nice if the loader loads the kernel at a &quot;chunk&quot;, ie&n;        * not in memory that the kernel will ignore (else free_initmem&n;        * has to worry about not freeing memory that the kernel ignores).&n;        * Note that we assume the space from the node start to&n;        * KERNEL_START can not hold all the bootmem data, but from kernel&n;        * end to node end can.&n;        */
multiline_comment|/* TBD: This may be bogus in light of the above check. */
r_if
c_cond
(paren
(paren
id|pstart
OL
id|pkernelend
)paren
op_logical_and
(paren
id|pend
op_ge
id|pkernelend
)paren
)paren
(brace
id|bootmap_start
op_assign
id|pkernelend
suffix:semicolon
)brace
r_else
(brace
id|bootmap_start
op_assign
id|__pa
c_func
(paren
id|start
)paren
suffix:semicolon
multiline_comment|/* chunk &amp; page aligned */
)brace
multiline_comment|/*&n;&t; * Low memory is reserved for PROM use on SN1. The current node&n;&t; * memory model is [PROM mem ... kernel ... free], where the &n;&t; * first two components are optional on a node.&n;&t; */
r_if
c_cond
(paren
id|bootmap_start
OL
id|__pa
c_func
(paren
id|nodefree
)paren
)paren
id|bootmap_start
op_assign
id|__pa
c_func
(paren
id|nodefree
)paren
suffix:semicolon
multiline_comment|/* XXX TBD */
multiline_comment|/* For curnodeid of 0, this gets called many times because of many&n; * &lt; 8MB segments. start gets bumped each time. We want to fix it&n; * to 0 now. &n; */
r_if
c_cond
(paren
id|curnodeid
op_eq
l_int|0
)paren
id|start
op_assign
id|PAGE_OFFSET
suffix:semicolon
multiline_comment|/*&n; * This makes sure that in free_area_init_core - paging_init&n; * idx is the entire node page range and for loop goes thro&n; * all pages. test_bit for kernel pages should remain reserved&n; * because free available mem takes care of kernel_start and end&n; */
id|bootmap_size
op_assign
id|init_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|curnodeid
)paren
comma
(paren
id|bootmap_start
op_rshift
id|PAGE_SHIFT
)paren
comma
(paren
id|__pa
c_func
(paren
id|start
)paren
op_rshift
id|PAGE_SHIFT
)paren
comma
(paren
id|__pa
c_func
(paren
id|end
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|free_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|curnodeid
)paren
comma
id|bootmap_start
op_plus
id|bootmap_size
comma
id|__pa
c_func
(paren
id|end
)paren
op_minus
(paren
id|bootmap_start
op_plus
id|bootmap_size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|setup_sn1_bootmem
id|setup_sn1_bootmem
c_func
(paren
r_int
id|maxnodes
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXNODES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nodemem
(braket
id|i
)braket
dot
id|usable
op_assign
id|nodemem
(braket
id|i
)braket
dot
id|start
op_assign
op_minus
l_int|1
suffix:semicolon
id|nodemem
(braket
id|i
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|nodemem
(braket
id|i
)braket
dot
id|hole
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|nodemem
(braket
id|i
)braket
dot
id|hole
)paren
)paren
suffix:semicolon
)brace
id|efi_memmap_walk
c_func
(paren
id|build_nodemem_map
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run thru all the nodes, adjusting their starts. This is needed&n;&t; * because efi_memmap_walk() might not process certain mds that &n;&t; * are marked reserved for PROM at node low memory.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
id|nodemem
(braket
id|i
)braket
dot
id|start
op_assign
(paren
(paren
id|nodemem
(braket
id|i
)braket
dot
id|start
op_rshift
id|SN1_NODE_ADDR_SHIFT
)paren
op_lshift
id|SN1_NODE_ADDR_SHIFT
)paren
suffix:semicolon
id|nodemem_valid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* After building the nodemem map, check if the page table&n;&t; * will fit in the first bank of each node. If not change&n;&t; * the node end addr till it fits. We dont want to do this&n;&t; * in mm/page_alloc.c&n; &t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
id|check_pgtbl_size
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
id|setup_node_bootmem
c_func
(paren
id|nodemem
(braket
id|i
)braket
dot
id|start
comma
id|nodemem
(braket
id|i
)braket
dot
id|end
comma
id|nodemem
(braket
id|i
)braket
dot
id|usable
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the holes as reserved, so the corresponding mem_map&n;&t; * entries will not be marked allocatable in free_all_bootmem*().&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
op_assign
l_int|0
suffix:semicolon
id|u64
id|holestart
op_assign
op_minus
l_int|1
suffix:semicolon
r_do
(brace
id|holestart
op_assign
id|nodemem
(braket
id|i
)braket
dot
id|hole
(braket
id|j
op_increment
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|j
OL
id|SN1_MAX_BANK_PER_NODE
)paren
op_logical_and
(paren
id|nodemem
(braket
id|i
)braket
dot
id|hole
(braket
id|j
)braket
op_eq
(paren
id|u64
)paren
op_minus
l_int|1
)paren
)paren
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|SN1_MAX_BANK_PER_NODE
)paren
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
comma
id|__pa
c_func
(paren
id|holestart
)paren
comma
(paren
id|nodemem
(braket
id|i
)braket
dot
id|start
op_plus
(paren
(paren
r_int
)paren
id|j
op_lshift
id|SN1_BANK_ADDR_SHIFT
)paren
op_minus
id|holestart
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|j
OL
id|SN1_MAX_BANK_PER_NODE
)paren
suffix:semicolon
)brace
id|dump_nodemem_map
c_func
(paren
id|maxnodes
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * This used to be invoked from an SN1 specific hack in efi_memmap_walk.&n; * It tries to ignore banks which the kernel is ignoring because bank 0 &n; * is too small to hold the memmap entries for this bank.&n; * The current SN1 efi_memmap_walk callbacks do not need this. That &n; * leaves the generic ia64 callbacks find_max_pfn, count_pages and&n; * count_reserved_pages, of which the first can probably get by without&n; * this, the last two probably need this, although they also can probably&n; * get by. &n; */
r_int
DECL|function|sn1_bank_ignore
id|sn1_bank_ignore
c_func
(paren
id|u64
id|start
comma
id|u64
id|end
)paren
(brace
r_int
id|nid
op_assign
id|NASID_TO_CNODEID
c_func
(paren
id|GetNasId
c_func
(paren
id|__pa
c_func
(paren
id|end
)paren
)paren
)paren
suffix:semicolon
r_int
id|bank
op_assign
id|GetBankId
c_func
(paren
id|__pa
c_func
(paren
id|end
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nodemem_valid
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nodemem
(braket
id|nid
)braket
dot
id|hole
(braket
id|bank
)braket
op_eq
op_minus
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|dump_nodemem_map
id|dump_nodemem_map
c_func
(paren
r_int
id|maxnodes
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NODEMEM_S info ....&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Node         start                end                 usable&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d      0x%lx   0x%lx   0x%lx&bslash;n&quot;
comma
id|i
comma
id|nodemem
(braket
id|i
)braket
dot
id|start
comma
id|nodemem
(braket
id|i
)braket
dot
id|end
comma
id|nodemem
(braket
id|i
)braket
dot
id|usable
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Holes -&gt; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SN1_MAX_BANK_PER_NODE
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;0x%lx &quot;
comma
id|nodemem
(braket
id|i
)braket
dot
id|hole
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
eof
