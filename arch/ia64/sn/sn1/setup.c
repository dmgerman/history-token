multiline_comment|/*&n; *&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Copyright (C) Vijay Chander(vijay@engr.sgi.com)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;asm/sn/mmzone_sn1.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm-ia64/sn/arch.h&gt;
macro_line|#include &lt;asm-ia64/sn/addrs.h&gt;
multiline_comment|/*&n; * This is the address of the RRegs in the HSpace of the global&n; * master.  It is used by a hack in serial.c (serial_[in|out],&n; * printk.c (early_printk), and kdb_io.c to put console output on that&n; * node&squot;s Bedrock UART.  It is initialized here to 0, so that&n; * early_printk won&squot;t try to access the UART before&n; * master_node_bedrock_address is properly calculated.&n; */
DECL|variable|master_node_bedrock_address
id|u64
id|master_node_bedrock_address
op_assign
l_int|0UL
suffix:semicolon
r_static
r_void
id|sn_fix_ivt_for_partitioned_system
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The format of &quot;screen_info&quot; is strange, and due to early i386-setup&n; * code. This is just enough to make the console code think we&squot;re on a&n; * VGA color display.&n; */
DECL|variable|sn1_screen_info
r_struct
id|screen_info
id|sn1_screen_info
op_assign
(brace
id|orig_x
suffix:colon
l_int|0
comma
id|orig_y
suffix:colon
l_int|0
comma
id|orig_video_mode
suffix:colon
l_int|3
comma
id|orig_video_cols
suffix:colon
l_int|80
comma
id|orig_video_ega_bx
suffix:colon
l_int|3
comma
id|orig_video_lines
suffix:colon
l_int|25
comma
id|orig_video_isVGA
suffix:colon
l_int|1
comma
id|orig_video_points
suffix:colon
l_int|16
)brace
suffix:semicolon
multiline_comment|/*&n; * This is here so we can use the CMOS detection in ide-probe.c to&n; * determine what drives are present.  In theory, we don&squot;t need this&n; * as the auto-detection could be done via ide-probe.c:do_probe() but&n; * in practice that would be much slower, which is painful when&n; * running in the simulator.  Note that passing zeroes in DRIVE_INFO&n; * is sufficient (the IDE driver will autodetect the drive geometry).&n; */
DECL|variable|drive_info
r_char
id|drive_info
(braket
l_int|4
op_star
l_int|16
)braket
suffix:semicolon
r_int
r_int
DECL|function|sn1_map_nr
id|sn1_map_nr
(paren
r_int
r_int
id|addr
)paren
(brace
macro_line|#ifdef CONFIG_DISCONTIGMEM
r_return
id|MAP_NR_SN1
c_func
(paren
id|addr
)paren
suffix:semicolon
macro_line|#else
r_return
id|MAP_NR_DENSE
c_func
(paren
id|addr
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined(BRINGUP) &amp;&amp; defined(CONFIG_IA64_EARLY_PRINTK)
r_void
id|__init
DECL|function|early_sn1_setup
id|early_sn1_setup
c_func
(paren
r_void
)paren
(brace
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HSPEC_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;early_sn1_setup: setting master_node_bedrock_address to 0x%lx&bslash;n&quot;
comma
id|master_node_bedrock_address
)paren
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP &amp;&amp; CONFIG_IA64_EARLY_PRINTK */
r_void
id|__init
DECL|function|sn1_setup
id|sn1_setup
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
macro_line|#if defined(CONFIG_SERIAL) &amp;&amp; !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_struct
id|serial_struct
id|req
suffix:semicolon
macro_line|#endif
id|MAX_DMA_ADDRESS
op_assign
id|PAGE_OFFSET
op_plus
l_int|0x10000000000UL
suffix:semicolon
id|master_node_bedrock_address
op_assign
(paren
id|u64
)paren
id|REMOTE_HSPEC_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn1_setup: setting master_node_bedrock_address to 0x%lx&bslash;n&quot;
comma
id|master_node_bedrock_address
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SERIAL) &amp;&amp; !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
multiline_comment|/*&n;&t; * We do early_serial_setup() to clean out the rs-table[] from the&n;&t; * statically compiled in version.&n;&t; */
id|memset
c_func
(paren
op_amp
id|req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
id|req.line
op_assign
l_int|0
suffix:semicolon
id|req.baud_base
op_assign
l_int|124800
suffix:semicolon
id|req.port
op_assign
l_int|0
suffix:semicolon
id|req.port_high
op_assign
l_int|0
suffix:semicolon
id|req.irq
op_assign
l_int|0
suffix:semicolon
id|req.flags
op_assign
(paren
id|ASYNC_BOOT_AUTOCONF
op_or
id|ASYNC_SKIP_TEST
)paren
suffix:semicolon
id|req.io_type
op_assign
id|SERIAL_IO_MEM
suffix:semicolon
id|req.hub6
op_assign
l_int|0
suffix:semicolon
id|req.iomem_base
op_assign
(paren
id|u8
op_star
)paren
(paren
id|master_node_bedrock_address
op_plus
l_int|0x80
)paren
suffix:semicolon
id|req.iomem_reg_shift
op_assign
l_int|3
suffix:semicolon
id|req.type
op_assign
l_int|0
suffix:semicolon
id|req.xmit_fifo_size
op_assign
l_int|0
suffix:semicolon
id|req.custom_divisor
op_assign
l_int|0
suffix:semicolon
id|req.closing_wait
op_assign
l_int|0
suffix:semicolon
id|early_serial_setup
c_func
(paren
op_amp
id|req
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL &amp;&amp; !CONFIG_SERIAL_SGI_L1_PROTOCOL */
id|ROOT_DEV
op_assign
id|to_kdev_t
c_func
(paren
l_int|0x0301
)paren
suffix:semicolon
multiline_comment|/* default to first IDE drive */
id|sn_fix_ivt_for_partitioned_system
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|init_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|screen_info
op_assign
id|sn1_screen_info
suffix:semicolon
)brace
multiline_comment|/* &n; * sn_fix_ivt_for_partitioned_system&n; *&n; * This is an ugly hack that is needed for partitioned systems.&n; *&n; * On a partitioned system, most partitions do NOT have a physical address 0.&n; * Unfortunately, the exception handling code in ivt.S has a couple of physical&n; * addresses of kernel structures hardcoded into &quot;movl&quot; instructions.&n; * These addresses are correct on partition 0 only. On all other partitions,&n; * the addresses must be changed to reference the correct address.&n; *&n; * This routine scans the ivt code and replaces the hardcoded addresses with &n; * the correct address.&n; *&n; * Note that we could have made the ivt.S code dynamically determine the correct&n; * address but this would add code to performance critical pathes. This option&n; * was rejected.&n; */
DECL|macro|TEMP_mlx
mdefine_line|#define TEMP_mlx&t;4&t;&t;/* template type that contains movl instruction */
DECL|macro|TEMP_mlX
mdefine_line|#define TEMP_mlX&t;5&t;&t;/* template type that contains movl instruction */
r_typedef
r_union
(brace
multiline_comment|/* Instruction encoding for movl instruction */
r_struct
(brace
DECL|member|qp
r_int
r_int
id|qp
suffix:colon
l_int|6
suffix:semicolon
DECL|member|r1
r_int
r_int
id|r1
suffix:colon
l_int|7
suffix:semicolon
DECL|member|imm7b
r_int
r_int
id|imm7b
suffix:colon
l_int|7
suffix:semicolon
DECL|member|vc
r_int
r_int
id|vc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ic
r_int
r_int
id|ic
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imm5c
r_int
r_int
id|imm5c
suffix:colon
l_int|5
suffix:semicolon
DECL|member|imm9d
r_int
r_int
id|imm9d
suffix:colon
l_int|9
suffix:semicolon
DECL|member|i
r_int
r_int
id|i
suffix:colon
l_int|1
suffix:semicolon
DECL|member|op
r_int
r_int
id|op
suffix:colon
l_int|4
suffix:semicolon
DECL|member|fill
r_int
r_int
id|fill
suffix:colon
l_int|23
suffix:semicolon
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|member|l
r_int
r_int
id|l
suffix:semicolon
DECL|typedef|movl_instruction_t
)brace
id|movl_instruction_t
suffix:semicolon
DECL|macro|MOVL_OPCODE
mdefine_line|#define MOVL_OPCODE&t;6
DECL|macro|MOVL_ARG
mdefine_line|#define MOVL_ARG(a,b)&t;(((long)a.i&lt;&lt;63) | ((long)b&lt;&lt;22) | ((long)a.ic&lt;&lt;21) | &bslash;&n;&t;&t;&t;((long)a.imm5c&lt;&lt;16) | ((long)a.imm9d&lt;&lt;7) | ((long)a.imm7b))
r_typedef
r_struct
(brace
multiline_comment|/* Instruction bundle */
DECL|member|template
r_int
r_int
r_template
suffix:colon
l_int|5
suffix:semicolon
DECL|member|ins2
r_int
r_int
id|ins2
suffix:colon
l_int|41
suffix:semicolon
DECL|member|ins1l
r_int
r_int
id|ins1l
suffix:colon
l_int|18
suffix:semicolon
DECL|member|ins1u
r_int
r_int
id|ins1u
suffix:colon
l_int|23
suffix:semicolon
DECL|member|ins0
r_int
r_int
id|ins0
suffix:colon
l_int|41
suffix:semicolon
DECL|typedef|instruction_bundle_t
)brace
id|instruction_bundle_t
suffix:semicolon
r_static
r_void
id|__init
DECL|function|sn_fix_ivt_for_partitioned_system
id|sn_fix_ivt_for_partitioned_system
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|ia64_ivt
suffix:semicolon
id|instruction_bundle_t
op_star
id|p
comma
op_star
id|pend
suffix:semicolon
id|movl_instruction_t
id|ins0
comma
id|ins1
comma
id|ins2
suffix:semicolon
r_int
id|new_ins1
comma
id|phys_offset
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * Setup to scan the ivt code.&n;&t; */
id|p
op_assign
(paren
id|instruction_bundle_t
op_star
)paren
op_amp
id|ia64_ivt
suffix:semicolon
id|pend
op_assign
id|p
op_plus
l_int|0x8000
op_div
r_sizeof
(paren
id|instruction_bundle_t
)paren
suffix:semicolon
id|phys_offset
op_assign
id|__pa
c_func
(paren
id|p
)paren
op_amp
op_complement
l_int|0x1ffffffffUL
suffix:semicolon
multiline_comment|/*&n;&t; * Hunt for movl instructions that contain the node 0 physical address &n;&t; * of &quot;SWAPPER_PGD_ADDR&quot;.  These addresses must be relocated to reference the &n;&t; * actual node that the kernel is loaded on.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|pend
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p
op_member_access_from_pointer
r_template
op_ne
id|TEMP_mlx
op_logical_and
id|p
op_member_access_from_pointer
r_template
op_ne
id|TEMP_mlX
)paren
r_continue
suffix:semicolon
id|ins0.l
op_assign
id|p-&gt;ins0
suffix:semicolon
r_if
c_cond
(paren
id|ins0.b.op
op_ne
id|MOVL_OPCODE
)paren
r_continue
suffix:semicolon
id|ins1.l
op_assign
(paren
(paren
r_int
)paren
id|p-&gt;ins1u
op_lshift
l_int|18
)paren
op_or
id|p-&gt;ins1l
suffix:semicolon
id|ins2.l
op_assign
id|p-&gt;ins2
suffix:semicolon
id|val
op_assign
id|MOVL_ARG
c_func
(paren
id|ins0.b
comma
id|ins1.l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Test for correct address. SWAPPER_PGD_ADDR will&n;&t;&t; * always be a node 0 virtual address. Note that we cant&n;&t;&t; * use the __pa or __va macros here since they may contain&n;&t;&t; * debug code that gets fooled here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|PAGE_OFFSET
op_or
id|val
)paren
op_ne
id|SWAPPER_PGD_ADDR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We found an instruction that needs to be fixed. The following&n;&t;&t; * inserts the NASID of the ivt into the movl instruction.&n;&t;&t; */
id|new_ins1
op_assign
id|ins1.l
op_or
(paren
id|phys_offset
op_rshift
l_int|22
)paren
suffix:semicolon
id|p-&gt;ins1l
op_assign
id|new_ins1
op_amp
l_int|0x3ffff
suffix:semicolon
id|p-&gt;ins1u
op_assign
(paren
id|new_ins1
op_rshift
l_int|18
)paren
op_amp
l_int|0x7fffff
suffix:semicolon
id|ia64_fc
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do necessary serialization.&n;&t; */
id|ia64_sync_i
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|IS_RUNNING_ON_SIMULATOR
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN1_SIM
r_int
id|sn
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mov %0=cpuid[%1]&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sn
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|2
)paren
)paren
suffix:semicolon
r_return
id|sn
op_eq
id|SNMAGIC
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
eof
