multiline_comment|/* &n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000-2003 Silicon Graphics, Inc.  All rights reserved.&n; */
multiline_comment|/*&n; * FPROM EFI memory descriptor build routines&n; *&n; * &t;- Routines to build the EFI memory descriptor map&n; * &t;- Should also be usable by the SGI prom to convert&n; * &t;  klconfig to efi_memmap&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &quot;fpmem.h&quot;
multiline_comment|/*&n; * args points to a layout in memory like this&n; *&n; *&t;&t;32 bit&t;&t;32 bit&n; *&n; * &t;&t;numnodes&t;numcpus&n; *&n; *&t;&t;16 bit   16 bit&t;&t;   32 bit&n; *&t;&t;nasid0&t;cpuconf&t;&t;membankdesc0&n; *&t;&t;nasid1&t;cpuconf&t;&t;membankdesc1&n; *&t;&t;&t;   .&n; *&t;&t;&t;   .&n; *&t;&t;&t;   .&n; *&t;&t;&t;   .&n; *&t;&t;&t;   .&n; */
DECL|variable|sn_memmap
id|sn_memmap_t
op_star
id|sn_memmap
suffix:semicolon
DECL|variable|sn_config
id|sn_config_t
op_star
id|sn_config
suffix:semicolon
multiline_comment|/*&n; * There is a hole in the node 0 address space. Dont put it&n; * in the memory map&n; */
DECL|macro|NODE0_HOLE_SIZE
mdefine_line|#define NODE0_HOLE_SIZE         (20*MB)
DECL|macro|NODE0_HOLE_END
mdefine_line|#define NODE0_HOLE_END          (4UL*GB)
DECL|macro|MB
mdefine_line|#define&t;MB&t;&t;&t;(1024*1024)
DECL|macro|GB
mdefine_line|#define GB&t;&t;&t;(1024*MB)
DECL|macro|KERNEL_SIZE
mdefine_line|#define KERNEL_SIZE&t;&t;(4*MB)
DECL|macro|PROMRESERVED_SIZE
mdefine_line|#define PROMRESERVED_SIZE&t;(1*MB)
macro_line|#ifdef SGI_SN2
DECL|macro|PHYS_ADDRESS
mdefine_line|#define PHYS_ADDRESS(_n, _x)&t;&t;(((long)_n&lt;&lt;38) | (long)_x | 0x3000000000UL)
DECL|macro|MD_BANK_SHFT
mdefine_line|#define MD_BANK_SHFT 34
macro_line|#endif
multiline_comment|/*&n; * For SN, this may not take an arg and gets the numnodes from &n; * the prom variable or by traversing klcfg or promcfg&n; */
r_int
DECL|function|GetNumNodes
id|GetNumNodes
c_func
(paren
r_void
)paren
(brace
r_return
id|sn_config-&gt;nodes
suffix:semicolon
)brace
r_int
DECL|function|GetNumCpus
id|GetNumCpus
c_func
(paren
r_void
)paren
(brace
r_return
id|sn_config-&gt;cpus
suffix:semicolon
)brace
multiline_comment|/* For SN, get the index th nasid */
r_int
DECL|function|GetNasid
id|GetNasid
c_func
(paren
r_int
id|index
)paren
(brace
r_return
id|sn_memmap
(braket
id|index
)braket
dot
id|nasid
suffix:semicolon
)brace
id|node_memmap_t
DECL|function|GetMemBankInfo
id|GetMemBankInfo
c_func
(paren
r_int
id|index
)paren
(brace
r_return
id|sn_memmap
(braket
id|index
)braket
dot
id|node_memmap
suffix:semicolon
)brace
r_int
DECL|function|IsCpuPresent
id|IsCpuPresent
c_func
(paren
r_int
id|cnode
comma
r_int
id|cpu
)paren
(brace
r_return
id|sn_memmap
(braket
id|cnode
)braket
dot
id|cpuconfig
op_amp
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Made this into an explicit case statement so that&n; * we can assign specific properties to banks like bank0&n; * actually disabled etc.&n; */
macro_line|#ifdef SGI_SN2
r_int
DECL|function|IsBankPresent
id|IsBankPresent
c_func
(paren
r_int
id|index
comma
id|node_memmap_t
id|nmemmap
)paren
(brace
r_switch
c_cond
(paren
id|index
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|BankPresent
c_func
(paren
id|nmemmap.b0size
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
id|BankPresent
c_func
(paren
id|nmemmap.b1size
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|BankPresent
c_func
(paren
id|nmemmap.b2size
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|BankPresent
c_func
(paren
id|nmemmap.b3size
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_int
DECL|function|GetBankSize
id|GetBankSize
c_func
(paren
r_int
id|index
comma
id|node_memmap_t
id|nmemmap
)paren
(brace
multiline_comment|/*&n;&t; * Add 2 because there are 4 dimms per bank.&n;&t; */
r_switch
c_cond
(paren
id|index
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
l_int|2
op_plus
(paren
(paren
r_int
)paren
id|nmemmap.b0size
op_plus
id|nmemmap.b0dou
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
l_int|2
op_plus
(paren
(paren
r_int
)paren
id|nmemmap.b1size
op_plus
id|nmemmap.b1dou
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
l_int|2
op_plus
(paren
(paren
r_int
)paren
id|nmemmap.b2size
op_plus
id|nmemmap.b2dou
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
l_int|2
op_plus
(paren
(paren
r_int
)paren
id|nmemmap.b3size
op_plus
id|nmemmap.b3dou
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_void
DECL|function|build_mem_desc
id|build_mem_desc
c_func
(paren
id|efi_memory_desc_t
op_star
id|md
comma
r_int
id|type
comma
r_int
id|paddr
comma
r_int
id|numbytes
comma
r_int
id|attr
)paren
(brace
id|md-&gt;type
op_assign
id|type
suffix:semicolon
id|md-&gt;phys_addr
op_assign
id|paddr
suffix:semicolon
id|md-&gt;virt_addr
op_assign
l_int|0
suffix:semicolon
id|md-&gt;num_pages
op_assign
id|numbytes
op_rshift
l_int|12
suffix:semicolon
id|md-&gt;attribute
op_assign
id|attr
suffix:semicolon
)brace
r_int
DECL|function|build_efi_memmap
id|build_efi_memmap
c_func
(paren
r_void
op_star
id|md
comma
r_int
id|mdsize
)paren
(brace
r_int
id|numnodes
op_assign
id|GetNumNodes
c_func
(paren
)paren
suffix:semicolon
r_int
id|cnode
comma
id|bank
suffix:semicolon
r_int
id|nasid
suffix:semicolon
id|node_memmap_t
id|membank_info
suffix:semicolon
r_int
id|bsize
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|paddr
comma
id|hole
comma
id|numbytes
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|nasid
op_assign
id|GetNasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|membank_info
op_assign
id|GetMemBankInfo
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
id|MD_BANKS_PER_NODE
suffix:semicolon
id|bank
op_increment
)paren
(brace
r_if
c_cond
(paren
id|IsBankPresent
c_func
(paren
id|bank
comma
id|membank_info
)paren
)paren
(brace
id|bsize
op_assign
id|GetBankSize
c_func
(paren
id|bank
comma
id|membank_info
)paren
suffix:semicolon
id|paddr
op_assign
id|PHYS_ADDRESS
c_func
(paren
id|nasid
comma
(paren
r_int
)paren
id|bank
op_lshift
id|MD_BANK_SHFT
)paren
suffix:semicolon
id|numbytes
op_assign
id|BankSizeBytes
c_func
(paren
id|bsize
)paren
suffix:semicolon
macro_line|#ifdef SGI_SN2
multiline_comment|/* &n;&t;&t;&t;&t; * Ignore directory.&n;&t;&t;&t;&t; * Shorten memory chunk by 1 page - makes a better&n;&t;&t;&t;&t; * testcase &amp; is more like the real PROM.&n;&t;&t;&t;&t; */
id|numbytes
op_assign
id|numbytes
op_star
l_int|31
op_div
l_int|32
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t; * Only emulate the memory prom grabs&n;&t;&t;&t;&t; * if we have lots of memory, to allow&n;&t;&t;&t;&t; * us to simulate smaller memory configs than&n;&t;&t;&t;&t; * we can actually run on h/w.  Otherwise,&n;&t;&t;&t;&t; * linux throws away a whole &quot;granule&quot;.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|cnode
op_eq
l_int|0
op_logical_and
id|bank
op_eq
l_int|0
op_logical_and
id|numbytes
OG
l_int|128
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|numbytes
op_sub_assign
l_int|1000
suffix:semicolon
)brace
multiline_comment|/*&n;                                 * Check for the node 0 hole. Since banks cant&n;                                 * span the hole, we only need to check if the end of&n;                                 * the range is the end of the hole.&n;                                 */
r_if
c_cond
(paren
id|paddr
op_plus
id|numbytes
op_eq
id|NODE0_HOLE_END
)paren
id|numbytes
op_sub_assign
id|NODE0_HOLE_SIZE
suffix:semicolon
multiline_comment|/*&n;                                 * UGLY hack - we must skip overr the kernel and&n;                                 * PROM runtime services but we dont exactly where it is.&n;                                 * So lets just reserve:&n;&t;&t;&t;&t; *&t;node 0&n;&t;&t;&t;&t; *&t;&t;0-1MB for PAL&n;&t;&t;&t;&t; *&t;&t;1-4MB for SAL&n;&t;&t;&t;&t; *&t;node 1-N&n;&t;&t;&t;&t; *&t;&t;0-1 for SAL&n;                                 */
r_if
c_cond
(paren
id|bank
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cnode
op_eq
l_int|0
)paren
(brace
id|hole
op_assign
l_int|2
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_PAL_CODE
comma
id|paddr
comma
id|hole
comma
id|EFI_MEMORY_WB
op_or
id|EFI_MEMORY_WB
)paren
suffix:semicolon
id|numbytes
op_sub_assign
id|hole
suffix:semicolon
id|paddr
op_add_assign
id|hole
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
id|hole
op_assign
l_int|1
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_CONVENTIONAL_MEMORY
comma
id|paddr
comma
id|hole
comma
id|EFI_MEMORY_UC
)paren
suffix:semicolon
id|numbytes
op_sub_assign
id|hole
suffix:semicolon
id|paddr
op_add_assign
id|hole
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
id|hole
op_assign
l_int|1
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_RUNTIME_SERVICES_DATA
comma
id|paddr
comma
id|hole
comma
id|EFI_MEMORY_WB
op_or
id|EFI_MEMORY_WB
)paren
suffix:semicolon
id|numbytes
op_sub_assign
id|hole
suffix:semicolon
id|paddr
op_add_assign
id|hole
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
)brace
r_else
(brace
id|hole
op_assign
l_int|2
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_RUNTIME_SERVICES_DATA
comma
id|paddr
comma
id|hole
comma
id|EFI_MEMORY_WB
op_or
id|EFI_MEMORY_WB
)paren
suffix:semicolon
id|numbytes
op_sub_assign
id|hole
suffix:semicolon
id|paddr
op_add_assign
id|hole
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
id|hole
op_assign
l_int|2
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_RUNTIME_SERVICES_DATA
comma
id|paddr
comma
id|hole
comma
id|EFI_MEMORY_UC
)paren
suffix:semicolon
id|numbytes
op_sub_assign
id|hole
suffix:semicolon
id|paddr
op_add_assign
id|hole
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
)brace
)brace
id|build_mem_desc
c_func
(paren
id|md
comma
id|EFI_CONVENTIONAL_MEMORY
comma
id|paddr
comma
id|numbytes
comma
id|EFI_MEMORY_WB
op_or
id|EFI_MEMORY_WB
)paren
suffix:semicolon
id|md
op_add_assign
id|mdsize
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
r_void
DECL|function|build_init
id|build_init
c_func
(paren
r_int
r_int
id|args
)paren
(brace
id|sn_config
op_assign
(paren
id|sn_config_t
op_star
)paren
(paren
id|args
)paren
suffix:semicolon
id|sn_memmap
op_assign
(paren
id|sn_memmap_t
op_star
)paren
(paren
id|args
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* SN equiv for this is */
multiline_comment|/* init to klconfig start */
)brace
eof
