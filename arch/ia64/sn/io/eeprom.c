multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1999-2002 Silicon Graphics, Inc. All rights reserved.&n; */
multiline_comment|/*&n; * WARNING:     There is more than one copy of this file in different isms.&n; *              All copies must be kept exactly in sync.&n; *              Do not modify this file without also updating the following:&n; *&n; *              irix/kern/io/eeprom.c&n; *              stand/arcs/lib/libsk/ml/eeprom.c&n; *&t;&t;stand/arcs/lib/libkl/io/eeprom.c&n; *&n; *      (from time to time they might not be in sync but that&squot;s due to bringup&n; *       activity - this comment is to remind us that they eventually have to&n; *       get back together)&n; *&n; * eeprom.c&n; *&n; * access to board-mounted EEPROMs via the L1 system controllers&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/router.h&gt;
macro_line|#include &lt;asm/sn/module.h&gt;
macro_line|#include &lt;asm/sn/ksys/l1.h&gt;
macro_line|#include &lt;asm/sn/nodepda.h&gt;
macro_line|#include &lt;asm/sn/clksupport.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
macro_line|#if defined(EEPROM_DEBUG)
DECL|macro|db_printf
mdefine_line|#define db_printf(x) printk x
macro_line|#else
DECL|macro|db_printf
mdefine_line|#define db_printf(x) printk x
macro_line|#endif
DECL|macro|BCOPY
mdefine_line|#define BCOPY(x,y,z)&t;memcpy(y,x,z)
DECL|macro|UNDERSCORE
mdefine_line|#define UNDERSCORE&t;0&t;/* don&squot;t convert underscores to hyphens */
DECL|macro|HYPHEN
mdefine_line|#define HYPHEN&t;&t;1&t;/* convert underscores to hyphens */
r_void
id|copy_ascii_field
c_func
(paren
r_char
op_star
id|to
comma
r_char
op_star
id|from
comma
r_int
id|length
comma
r_int
id|change_underscore
)paren
suffix:semicolon
r_uint64
id|generate_unique_id
c_func
(paren
r_char
op_star
id|sn
comma
r_int
id|sn_len
)paren
suffix:semicolon
id|uchar_t
id|char_to_base36
c_func
(paren
r_char
id|c
)paren
suffix:semicolon
r_int
id|nicify
c_func
(paren
r_char
op_star
id|dst
comma
id|eeprom_brd_record_t
op_star
id|src
)paren
suffix:semicolon
r_static
r_void
id|int64_to_hex_string
c_func
(paren
r_char
op_star
id|out
comma
r_uint64
id|val
)paren
suffix:semicolon
singleline_comment|// extern int router_lock( net_vec_t, int, int );
singleline_comment|// extern int router_unlock( net_vec_t );
DECL|macro|ROUTER_LOCK
mdefine_line|#define ROUTER_LOCK(p) &t;
singleline_comment|// router_lock(p, 10000, 3000000)
DECL|macro|ROUTER_UNLOCK
mdefine_line|#define ROUTER_UNLOCK(p) &t;
singleline_comment|// router_unlock(p)
DECL|macro|IP27LOG_OVNIC
mdefine_line|#define IP27LOG_OVNIC           &quot;OverrideNIC&quot;
multiline_comment|/* the following function converts an EEPROM record to a close facsimile&n; * of the string returned by reading a Dallas Semiconductor NIC (see&n; * one of the many incarnations of nic.c for details on that driver)&n; */
DECL|function|nicify
r_int
id|nicify
c_func
(paren
r_char
op_star
id|dst
comma
id|eeprom_brd_record_t
op_star
id|src
)paren
(brace
r_int
id|field_len
suffix:semicolon
r_uint64
id|unique_id
suffix:semicolon
r_char
op_star
id|cur_dst
op_assign
id|dst
suffix:semicolon
id|eeprom_board_ia_t
op_star
id|board
suffix:semicolon
id|board
op_assign
id|src-&gt;board_ia
suffix:semicolon
id|ASSERT
c_func
(paren
id|board
)paren
suffix:semicolon
multiline_comment|/* there should always be a board info area */
multiline_comment|/* copy part number */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;Part:&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|board-&gt;part_num_tl
op_amp
id|FIELD_FORMAT_MASK
)paren
op_eq
id|FIELD_FORMAT_ASCII
)paren
suffix:semicolon
id|field_len
op_assign
id|board-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
suffix:semicolon
id|copy_ascii_field
c_func
(paren
id|cur_dst
comma
id|board-&gt;part_num
comma
id|field_len
comma
id|HYPHEN
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|field_len
suffix:semicolon
multiline_comment|/* copy product name */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;;Name:&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|board-&gt;product_tl
op_amp
id|FIELD_FORMAT_MASK
)paren
op_eq
id|FIELD_FORMAT_ASCII
)paren
suffix:semicolon
id|field_len
op_assign
id|board-&gt;product_tl
op_amp
id|FIELD_LENGTH_MASK
suffix:semicolon
id|copy_ascii_field
c_func
(paren
id|cur_dst
comma
id|board-&gt;product
comma
id|field_len
comma
id|UNDERSCORE
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|field_len
suffix:semicolon
multiline_comment|/* copy serial number */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;;Serial:&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|board-&gt;serial_num_tl
op_amp
id|FIELD_FORMAT_MASK
)paren
op_eq
id|FIELD_FORMAT_ASCII
)paren
suffix:semicolon
id|field_len
op_assign
id|board-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
suffix:semicolon
id|copy_ascii_field
c_func
(paren
id|cur_dst
comma
id|board-&gt;serial_num
comma
id|field_len
comma
id|HYPHEN
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|field_len
suffix:semicolon
multiline_comment|/* copy revision */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;;Revision:&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|board-&gt;board_rev_tl
op_amp
id|FIELD_FORMAT_MASK
)paren
op_eq
id|FIELD_FORMAT_ASCII
)paren
suffix:semicolon
id|field_len
op_assign
id|board-&gt;board_rev_tl
op_amp
id|FIELD_LENGTH_MASK
suffix:semicolon
id|copy_ascii_field
c_func
(paren
id|cur_dst
comma
id|board-&gt;board_rev
comma
id|field_len
comma
id|HYPHEN
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|field_len
suffix:semicolon
multiline_comment|/* EEPROMs don&squot;t have equivalents for the Group, Capability and&n;     * Variety fields, so we pad these with 0&squot;s&n;     */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;;Group:ff;Capability:ffffffff;Variety:ff&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
multiline_comment|/* use the board serial number to &quot;fake&quot; a laser id */
id|strcpy
c_func
(paren
id|cur_dst
comma
l_string|&quot;;Laser:&quot;
)paren
suffix:semicolon
id|cur_dst
op_add_assign
id|strlen
c_func
(paren
id|cur_dst
)paren
suffix:semicolon
id|unique_id
op_assign
id|generate_unique_id
c_func
(paren
id|board-&gt;serial_num
comma
id|board-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|int64_to_hex_string
c_func
(paren
id|cur_dst
comma
id|unique_id
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|dst
comma
l_string|&quot;;&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* These functions borrow heavily from chars2* in nic.c&n; */
DECL|function|copy_ascii_field
r_void
id|copy_ascii_field
c_func
(paren
r_char
op_star
id|to
comma
r_char
op_star
id|from
comma
r_int
id|length
comma
r_int
id|change_underscore
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* change underscores to hyphens if requested */
r_if
c_cond
(paren
id|from
(braket
id|i
)braket
op_eq
l_char|&squot;_&squot;
op_logical_and
id|change_underscore
op_eq
id|HYPHEN
)paren
(brace
id|to
(braket
id|i
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
multiline_comment|/* ; and ; are separators, so mustn&squot;t appear within&n;&t; * a field */
r_else
r_if
c_cond
(paren
id|from
(braket
id|i
)braket
op_eq
l_char|&squot;:&squot;
op_logical_or
id|from
(braket
id|i
)braket
op_eq
l_char|&squot;;&squot;
)paren
(brace
id|to
(braket
id|i
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
)brace
multiline_comment|/* I&squot;m not sure why or if ASCII character 0xff would&n;&t; * show up in an EEPROM field, but the NIC parsing&n;&t; * routines wouldn&squot;t like it if it did... so we&n;&t; * get rid of it, just in case. */
r_else
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|from
(braket
id|i
)braket
op_eq
(paren
r_int
r_char
)paren
l_int|0xff
)paren
(brace
id|to
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
multiline_comment|/* unprintable characters are replaced with . */
r_else
r_if
c_cond
(paren
id|from
(braket
id|i
)braket
OL
l_char|&squot; &squot;
op_logical_or
id|from
(braket
id|i
)braket
op_ge
l_int|0x7f
)paren
(brace
id|to
(braket
id|i
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
multiline_comment|/* otherwise, just copy the character */
r_else
id|to
(braket
id|i
)braket
op_assign
id|from
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|to
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
multiline_comment|/* return at least a space... */
id|i
op_increment
suffix:semicolon
)brace
id|to
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* terminating null */
)brace
multiline_comment|/* Note that int64_to_hex_string currently only has a big-endian&n; * implementation.&n; */
macro_line|#ifdef _MIPSEB
DECL|function|int64_to_hex_string
r_static
r_void
id|int64_to_hex_string
c_func
(paren
r_char
op_star
id|out
comma
r_uint64
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|uchar_t
id|table
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
id|uchar_t
op_star
id|byte_ptr
op_assign
(paren
id|uchar_t
op_star
)paren
op_amp
id|val
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_uint64
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|out
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|table
(braket
(paren
(paren
op_star
id|byte_ptr
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|out
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|table
(braket
(paren
op_star
id|byte_ptr
)paren
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|byte_ptr
op_increment
suffix:semicolon
)brace
id|out
(braket
id|i
op_star
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
macro_line|#else /* little endian */
DECL|function|int64_to_hex_string
r_static
r_void
id|int64_to_hex_string
c_func
(paren
r_char
op_star
id|out
comma
r_uint64
id|val
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;int64_to_hex_string needs a little-endian implementation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* _MIPSEB */
multiline_comment|/* Convert a standard ASCII serial number to a unique integer&n; * id number by treating the serial number string as though&n; * it were a base 36 number&n; */
DECL|function|generate_unique_id
r_uint64
id|generate_unique_id
c_func
(paren
r_char
op_star
id|sn
comma
r_int
id|sn_len
)paren
(brace
r_int
id|uid
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
DECL|macro|VALID_BASE36
mdefine_line|#define VALID_BASE36(c)&t;((c &gt;= &squot;0&squot; &amp;&amp; c &lt;=&squot;9&squot;) &bslash;&n;&t;&t;&t;    ||   (c &gt;= &squot;A&squot; &amp;&amp; c &lt;=&squot;Z&squot;) &bslash;&n;&t;&t;&t;    ||   (c &gt;= &squot;a&squot; &amp;&amp; c &lt;=&squot;z&squot;))
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sn_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|VALID_BASE36
c_func
(paren
id|sn
(braket
id|i
)braket
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|uid
op_mul_assign
l_int|36
suffix:semicolon
id|uid
op_add_assign
id|char_to_base36
c_func
(paren
id|sn
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uid
op_eq
l_int|0
)paren
(brace
r_return
id|rtc_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|uid
suffix:semicolon
)brace
DECL|function|char_to_base36
id|uchar_t
id|char_to_base36
c_func
(paren
r_char
id|c
)paren
(brace
id|uchar_t
id|val
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
id|val
op_assign
(paren
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;Z&squot;
)paren
(brace
id|val
op_assign
(paren
id|c
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
(brace
id|val
op_assign
(paren
id|c
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|val
op_assign
l_int|0
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/* given a pointer to the three-byte little-endian EEPROM representation&n; * of date-of-manufacture, this function translates to a big-endian&n; * integer format&n; */
DECL|function|eeprom_xlate_board_mfr_date
r_int
id|eeprom_xlate_board_mfr_date
c_func
(paren
id|uchar_t
op_star
id|src
)paren
(brace
r_int
id|rval
op_assign
l_int|0
suffix:semicolon
id|rval
op_add_assign
op_star
id|src
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|rval
op_add_assign
(paren
(paren
r_int
)paren
(paren
op_star
id|src
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|rval
op_add_assign
(paren
(paren
r_int
)paren
(paren
op_star
id|src
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
DECL|function|eeprom_str
r_int
id|eeprom_str
c_func
(paren
r_char
op_star
id|nic_str
comma
id|nasid_t
id|nasid
comma
r_int
id|component
)paren
(brace
id|eeprom_brd_record_t
id|eep
suffix:semicolon
id|eeprom_board_ia_t
id|board
suffix:semicolon
id|eeprom_chassis_ia_t
id|chassis
suffix:semicolon
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
(paren
id|component
op_amp
id|C_DIMM
)paren
op_eq
id|C_DIMM
)paren
(brace
multiline_comment|/* this function isn&squot;t applicable to DIMMs */
r_return
id|EEP_PARAM
suffix:semicolon
)brace
r_else
(brace
id|eep.board_ia
op_assign
op_amp
id|board
suffix:semicolon
id|eep.spd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
)paren
(brace
id|eep.chassis_ia
op_assign
op_amp
id|chassis
suffix:semicolon
)brace
multiline_comment|/* only main boards have a chassis&n;&t;&t;&t;&t;&t; * info area */
r_else
id|eep.chassis_ia
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|component
op_amp
id|BRICK_MASK
)paren
(brace
r_case
id|C_BRICK
suffix:colon
id|r
op_assign
id|cbrick_eeprom_read
c_func
(paren
op_amp
id|eep
comma
id|nasid
comma
id|component
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO_BRICK
suffix:colon
id|r
op_assign
id|iobrick_eeprom_read
c_func
(paren
op_amp
id|eep
comma
id|nasid
comma
id|component
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|EEP_PARAM
suffix:semicolon
multiline_comment|/* must be an invalid component */
)brace
r_if
c_cond
(paren
id|r
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nicify
c_func
(paren
id|nic_str
comma
op_amp
id|eep
)paren
)paren
(brace
r_return
id|EEP_NICIFY
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|function|vector_eeprom_str
r_int
id|vector_eeprom_str
c_func
(paren
r_char
op_star
id|nic_str
comma
id|nasid_t
id|nasid
comma
r_int
id|component
comma
id|net_vec_t
id|path
)paren
(brace
id|eeprom_brd_record_t
id|eep
suffix:semicolon
id|eeprom_board_ia_t
id|board
suffix:semicolon
id|eeprom_chassis_ia_t
id|chassis
suffix:semicolon
r_int
id|r
suffix:semicolon
id|eep.board_ia
op_assign
op_amp
id|board
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
)paren
(brace
id|eep.chassis_ia
op_assign
op_amp
id|chassis
suffix:semicolon
)brace
multiline_comment|/* only main boards have a chassis&n;                                     * info area */
r_else
id|eep.chassis_ia
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|VECTOR
)paren
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|r
op_assign
id|vector_eeprom_read
c_func
(paren
op_amp
id|eep
comma
id|nasid
comma
id|path
comma
id|component
)paren
)paren
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nicify
c_func
(paren
id|nic_str
comma
op_amp
id|eep
)paren
)paren
(brace
r_return
id|EEP_NICIFY
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|function|is_iobrick
r_int
id|is_iobrick
c_func
(paren
r_int
id|nasid
comma
r_int
id|widget_num
)paren
(brace
r_uint32
id|wid_reg
suffix:semicolon
r_int
id|part_num
comma
id|mfg_num
suffix:semicolon
multiline_comment|/* Read the widget&squot;s WIDGET_ID register to get&n;     * its part number and mfg number&n;     */
id|wid_reg
op_assign
op_star
(paren
r_volatile
r_int32
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
id|widget_num
)paren
op_plus
id|WIDGET_ID
)paren
suffix:semicolon
id|part_num
op_assign
(paren
id|wid_reg
op_amp
id|WIDGET_PART_NUM
)paren
op_rshift
id|WIDGET_PART_NUM_SHFT
suffix:semicolon
id|mfg_num
op_assign
(paren
id|wid_reg
op_amp
id|WIDGET_MFG_NUM
)paren
op_rshift
id|WIDGET_MFG_NUM_SHFT
suffix:semicolon
multiline_comment|/* Is this the &quot;xbow part&quot; of an XBridge?  If so, this&n;     * widget is definitely part of an I/O brick.&n;     */
r_if
c_cond
(paren
id|part_num
op_eq
id|XXBOW_WIDGET_PART_NUM
op_logical_and
id|mfg_num
op_eq
id|XXBOW_WIDGET_MFGR_NUM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Is this a &quot;bridge part&quot; of an XBridge?  If so, once&n;     * again, we know this widget is part of an I/O brick.&n;     */
r_if
c_cond
(paren
id|part_num
op_eq
id|XBRIDGE_WIDGET_PART_NUM
op_logical_and
id|mfg_num
op_eq
id|XBRIDGE_WIDGET_MFGR_NUM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbrick_uid_get
r_int
id|cbrick_uid_get
c_func
(paren
id|nasid_t
id|nasid
comma
r_uint64
op_star
id|uid
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_char
id|uid_str
(braket
l_int|32
)braket
suffix:semicolon
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|subch
comma
id|len
suffix:semicolon
id|l1sc_t
id|sc
suffix:semicolon
id|l1sc_t
op_star
id|scp
suffix:semicolon
r_int
id|local
op_assign
(paren
id|nasid
op_eq
id|get_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
multiline_comment|/* If the promlog variable pointed to by IP27LOG_OVNIC is set,&n;     * use that value for the cbrick UID rather than the EEPROM&n;     * serial number.&n;     */
macro_line|#ifdef LOG_GETENV
r_if
c_cond
(paren
id|ip27log_getenv
c_func
(paren
id|nasid
comma
id|IP27LOG_OVNIC
comma
id|uid_str
comma
l_int|NULL
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* We successfully read IP27LOG_OVNIC, so return it as the UID. */
id|db_printf
c_func
(paren
(paren
l_string|&quot;cbrick_uid_get:&quot;
l_string|&quot;Overriding UID with environment variable %s&bslash;n&quot;
comma
id|IP27LOG_OVNIC
)paren
)paren
suffix:semicolon
op_star
id|uid
op_assign
id|strtoull
c_func
(paren
id|uid_str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|EEP_OK
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* If this brick is retrieving its own uid, use the local l1sc_t to&n;     * arbitrate access to the l1; otherwise, set up a new one.&n;     */
r_if
c_cond
(paren
id|local
)paren
(brace
id|scp
op_assign
id|get_l1sc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|scp
op_assign
op_amp
id|sc
suffix:semicolon
id|sc_init
c_func
(paren
op_amp
id|sc
comma
id|nasid
comma
id|BRL1_LOCALHUB_UART
)paren
suffix:semicolon
)brace
multiline_comment|/* fill in msg with the opcode &amp; params */
id|BZERO
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|scp
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|scp
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_SER_NUM
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|scp
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_ASCII
comma
id|uid_str
)paren
OL
l_int|0
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
op_star
id|uid
op_assign
id|generate_unique_id
c_func
(paren
id|uid_str
comma
id|strlen
c_func
(paren
id|uid_str
)paren
)paren
suffix:semicolon
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|rbrick_uid_get
r_int
id|rbrick_uid_get
c_func
(paren
id|nasid_t
id|nasid
comma
id|net_vec_t
id|path
comma
r_uint64
op_star
id|uid
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_char
id|uid_str
(braket
l_int|32
)braket
suffix:semicolon
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|subch
comma
id|len
suffix:semicolon
id|l1sc_t
id|sc
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
mdefine_line|#define FAIL&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;*uid = rtc_time();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;printk( &quot;rbrick_uid_get failed; using current time as uid&bslash;n&quot; );&t;&bslash;&n;&t;return EEP_OK;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }
id|ROUTER_LOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|sc_init
c_func
(paren
op_amp
id|sc
comma
id|nasid
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* fill in msg with the opcode &amp; params */
id|BZERO
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
op_amp
id|sc
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|FAIL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
op_amp
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_SER_NUM
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
id|FAIL
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
op_amp
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
id|FAIL
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_ASCII
comma
id|uid_str
)paren
OL
l_int|0
)paren
(brace
id|FAIL
suffix:semicolon
)brace
op_star
id|uid
op_assign
id|generate_unique_id
c_func
(paren
id|uid_str
comma
id|strlen
c_func
(paren
id|uid_str
)paren
)paren
suffix:semicolon
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|iobrick_uid_get
r_int
id|iobrick_uid_get
c_func
(paren
id|nasid_t
id|nasid
comma
r_uint64
op_star
id|uid
)paren
(brace
id|eeprom_brd_record_t
id|eep
suffix:semicolon
id|eeprom_board_ia_t
id|board
suffix:semicolon
id|eeprom_chassis_ia_t
id|chassis
suffix:semicolon
r_int
id|r
suffix:semicolon
id|eep.board_ia
op_assign
op_amp
id|board
suffix:semicolon
id|eep.chassis_ia
op_assign
op_amp
id|chassis
suffix:semicolon
id|eep.spd
op_assign
l_int|NULL
suffix:semicolon
id|r
op_assign
id|iobrick_eeprom_read
c_func
(paren
op_amp
id|eep
comma
id|nasid
comma
id|IO_BRICK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
op_star
id|uid
op_assign
id|rtc_time
c_func
(paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
op_star
id|uid
op_assign
id|generate_unique_id
c_func
(paren
id|board.serial_num
comma
id|board.serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|function|ibrick_mac_addr_get
r_int
id|ibrick_mac_addr_get
c_func
(paren
id|nasid_t
id|nasid
comma
r_char
op_star
id|eaddr
)paren
(brace
id|eeprom_brd_record_t
id|eep
suffix:semicolon
id|eeprom_board_ia_t
id|board
suffix:semicolon
id|eeprom_chassis_ia_t
id|chassis
suffix:semicolon
r_int
id|r
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|eep.board_ia
op_assign
op_amp
id|board
suffix:semicolon
id|eep.chassis_ia
op_assign
op_amp
id|chassis
suffix:semicolon
id|eep.spd
op_assign
l_int|NULL
suffix:semicolon
id|r
op_assign
id|iobrick_eeprom_read
c_func
(paren
op_amp
id|eep
comma
id|nasid
comma
id|IO_BRICK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_ne
id|EEP_OK
)paren
op_logical_or
(paren
id|board.mac_addr
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;ibrick_mac_addr_get: &quot;
l_string|&quot;Couldn&squot;t read MAC address from EEPROM&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* successfully read info area */
r_int
id|ix
suffix:semicolon
id|tmp
op_assign
id|board.mac_addr
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
(paren
id|board.mac_addr_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ix
op_increment
)paren
(brace
op_star
id|eaddr
op_increment
op_assign
op_star
id|tmp
op_increment
suffix:semicolon
)brace
op_star
id|eaddr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
)brace
multiline_comment|/* &n; * eeprom_vertex_info_set&n; *&n; * Given a vertex handle, a component designation, a starting nasid&n; * and (in the case of a router) a vector path to the component, this&n; * function will read the EEPROM and attach the resulting information&n; * to the vertex in the same string format as that provided by the&n; * Dallas Semiconductor NIC drivers.  If the vertex already has the&n; * string, this function just returns the string.&n; */
r_extern
r_char
op_star
id|nic_vertex_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_extern
r_void
id|nic_vmc_check
c_func
(paren
id|devfs_handle_t
comma
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* the following were lifted from nic.c - change later? */
DECL|macro|MAX_INFO
mdefine_line|#define MAX_INFO 2048
DECL|macro|NEWSZ
mdefine_line|#define NEWSZ(ptr,sz)   ((ptr) = kern_malloc((sz)))
DECL|macro|DEL
mdefine_line|#define DEL(ptr) (kern_free((ptr)))
DECL|function|eeprom_vertex_info_set
r_char
op_star
id|eeprom_vertex_info_set
c_func
(paren
r_int
id|component
comma
r_int
id|nasid
comma
id|devfs_handle_t
id|v
comma
id|net_vec_t
id|path
)paren
(brace
r_char
op_star
id|info_tmp
suffix:semicolon
r_int
id|info_len
suffix:semicolon
r_char
op_star
id|info
suffix:semicolon
multiline_comment|/* see if this vertex is already marked */
id|info_tmp
op_assign
id|nic_vertex_info_get
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info_tmp
)paren
r_return
id|info_tmp
suffix:semicolon
multiline_comment|/* get a temporary place for the data */
id|NEWSZ
c_func
(paren
id|info_tmp
comma
id|MAX_INFO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info_tmp
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* read the EEPROM */
r_if
c_cond
(paren
id|component
op_amp
id|R_BRICK
)paren
(brace
r_if
c_cond
(paren
id|RBRICK_EEPROM_STR
c_func
(paren
id|info_tmp
comma
id|nasid
comma
id|path
)paren
op_ne
id|EEP_OK
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|eeprom_str
c_func
(paren
id|info_tmp
comma
id|nasid
comma
id|component
)paren
op_ne
id|EEP_OK
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate a smaller final place */
id|info_len
op_assign
id|strlen
c_func
(paren
id|info_tmp
)paren
op_plus
l_int|1
suffix:semicolon
id|NEWSZ
c_func
(paren
id|info
comma
id|info_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
id|strcpy
c_func
(paren
id|info
comma
id|info_tmp
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|info_tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|info
op_assign
id|info_tmp
suffix:semicolon
)brace
multiline_comment|/* add info to the vertex */
id|hwgraph_info_add_LBL
c_func
(paren
id|v
comma
id|INFO_LBL_NIC
comma
(paren
id|arbitrary_info_t
)paren
id|info
)paren
suffix:semicolon
multiline_comment|/* see if someone else got there first */
id|info_tmp
op_assign
id|nic_vertex_info_get
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_ne
id|info_tmp
)paren
(brace
id|DEL
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
id|info_tmp
suffix:semicolon
)brace
multiline_comment|/* export the data */
id|hwgraph_info_export_LBL
c_func
(paren
id|v
comma
id|INFO_LBL_NIC
comma
id|info_len
)paren
suffix:semicolon
multiline_comment|/* trigger all matching callbacks */
id|nic_vmc_check
c_func
(paren
id|v
comma
id|info
)paren
suffix:semicolon
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; *&n; * stubs for use until the Bedrock/L1 link is available&n; *&n; */
macro_line|#include &lt;asm/sn/nic.h&gt;
multiline_comment|/* #define EEPROM_TEST */
multiline_comment|/* fake eeprom reading functions (replace when the BR/L1 communication&n; * channel is in working order)&n; */
multiline_comment|/* generate a charater in [0-9A-Z]; if an &quot;extra&quot; character is&n; * specified (such as &squot;_&squot;), include it as one of the possibilities.&n; */
DECL|function|random_eeprom_ch
r_char
id|random_eeprom_ch
c_func
(paren
r_char
id|extra
)paren
(brace
r_char
id|ch
suffix:semicolon
r_int
id|modval
op_assign
l_int|36
suffix:semicolon
r_if
c_cond
(paren
id|extra
)paren
(brace
id|modval
op_increment
suffix:semicolon
)brace
id|ch
op_assign
id|rtc_time
c_func
(paren
)paren
op_mod
id|modval
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|10
)paren
(brace
id|ch
op_add_assign
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_int|10
op_logical_and
id|ch
OL
l_int|36
)paren
(brace
id|ch
op_add_assign
(paren
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|ch
op_assign
id|extra
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/* create a part number of the form xxx-xxxx-xxx.&n; * It may be important later to generate different&n; * part numbers depending on the component we&squot;re&n; * supposed to be &quot;reading&quot; from, so the component&n; * paramter is provided.&n; */
DECL|function|fake_a_part_number
r_void
id|fake_a_part_number
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|component
)paren
(brace
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|component
)paren
(brace
multiline_comment|/* insert component-specific routines here */
r_case
id|C_BRICK
suffix:colon
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;030-1266-001&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|3
op_logical_or
id|i
op_eq
l_int|8
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
r_else
id|buf
(braket
id|i
)braket
op_assign
id|random_eeprom_ch
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* create a six-character serial number */
DECL|function|fake_a_serial_number
r_void
id|fake_a_serial_number
c_func
(paren
r_char
op_star
id|buf
comma
r_uint64
id|ser
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
r_if
c_cond
(paren
id|ser
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|hexchars
(braket
id|ser
op_amp
l_int|0xf
)braket
suffix:semicolon
id|ser
op_rshift_assign
l_int|4
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|random_eeprom_ch
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|fake_a_product_name
r_void
id|fake_a_product_name
c_func
(paren
id|uchar_t
op_star
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|component
)paren
(brace
r_switch
c_cond
(paren
id|component
op_amp
id|BRICK_MASK
)paren
(brace
r_case
id|C_BRICK
suffix:colon
r_if
c_cond
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;C_BRICK_SUB&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xCB
suffix:semicolon
)brace
r_else
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;IP35&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xC4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|R_BRICK
suffix:colon
r_if
c_cond
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;R_BRICK_SUB&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xCB
suffix:semicolon
)brace
r_else
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;R_BRICK&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xC7
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IO_BRICK
suffix:colon
r_if
c_cond
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;IO_BRICK_SUB&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xCC
suffix:semicolon
)brace
r_else
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;IO_BRICK&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xC8
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;UNK_DEVICE&quot;
)paren
suffix:semicolon
op_star
id|format
op_assign
l_int|0xCA
suffix:semicolon
)brace
)brace
DECL|function|fake_an_eeprom_record
r_int
id|fake_an_eeprom_record
c_func
(paren
id|eeprom_brd_record_t
op_star
id|buf
comma
r_int
id|component
comma
r_uint64
id|ser
)paren
(brace
id|eeprom_board_ia_t
op_star
id|board
suffix:semicolon
id|eeprom_chassis_ia_t
op_star
id|chassis
suffix:semicolon
r_int
id|i
comma
id|cs
suffix:semicolon
id|board
op_assign
id|buf-&gt;board_ia
suffix:semicolon
id|chassis
op_assign
id|buf-&gt;chassis_ia
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|SUBORD_MASK
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chassis
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
id|chassis-&gt;format
op_assign
l_int|0
suffix:semicolon
id|chassis-&gt;length
op_assign
l_int|5
suffix:semicolon
id|chassis-&gt;type
op_assign
l_int|0x17
suffix:semicolon
id|chassis-&gt;part_num_tl
op_assign
l_int|0xCC
suffix:semicolon
id|fake_a_part_number
c_func
(paren
id|chassis-&gt;part_num
comma
id|component
)paren
suffix:semicolon
id|chassis-&gt;serial_num_tl
op_assign
l_int|0xC6
suffix:semicolon
id|fake_a_serial_number
c_func
(paren
id|chassis-&gt;serial_num
comma
id|ser
)paren
suffix:semicolon
id|cs
op_assign
id|chassis-&gt;format
op_plus
id|chassis-&gt;length
op_plus
id|chassis-&gt;type
op_plus
id|chassis-&gt;part_num_tl
op_plus
id|chassis-&gt;serial_num_tl
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|chassis-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|chassis-&gt;part_num
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|chassis-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|chassis-&gt;serial_num
(braket
id|i
)braket
suffix:semicolon
)brace
id|chassis-&gt;checksum
op_assign
l_int|256
op_minus
(paren
id|cs
op_mod
l_int|256
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|board
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
id|board-&gt;format
op_assign
l_int|0
suffix:semicolon
id|board-&gt;length
op_assign
l_int|10
suffix:semicolon
id|board-&gt;language
op_assign
l_int|0
suffix:semicolon
id|board-&gt;mfg_date
op_assign
l_int|1789200
suffix:semicolon
multiline_comment|/* noon, 5/26/99 */
id|board-&gt;manuf_tl
op_assign
l_int|0xC3
suffix:semicolon
id|strcpy
c_func
(paren
id|board-&gt;manuf
comma
l_string|&quot;SGI&quot;
)paren
suffix:semicolon
id|fake_a_product_name
c_func
(paren
op_amp
(paren
id|board-&gt;product_tl
)paren
comma
id|board-&gt;product
comma
id|component
)paren
suffix:semicolon
id|board-&gt;serial_num_tl
op_assign
l_int|0xC6
suffix:semicolon
id|fake_a_serial_number
c_func
(paren
id|board-&gt;serial_num
comma
id|ser
)paren
suffix:semicolon
id|board-&gt;part_num_tl
op_assign
l_int|0xCC
suffix:semicolon
id|fake_a_part_number
c_func
(paren
id|board-&gt;part_num
comma
id|component
)paren
suffix:semicolon
id|board-&gt;board_rev_tl
op_assign
l_int|0xC2
suffix:semicolon
id|board-&gt;board_rev
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|board-&gt;board_rev
(braket
l_int|1
)braket
op_assign
l_char|&squot;1&squot;
suffix:semicolon
id|board-&gt;eeprom_size_tl
op_assign
l_int|0x01
suffix:semicolon
id|board-&gt;eeprom_size
op_assign
l_int|1
suffix:semicolon
id|board-&gt;temp_waiver_tl
op_assign
l_int|0xC2
suffix:semicolon
id|board-&gt;temp_waiver
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|board-&gt;temp_waiver
(braket
l_int|1
)braket
op_assign
l_char|&squot;1&squot;
suffix:semicolon
id|cs
op_assign
id|board-&gt;format
op_plus
id|board-&gt;length
op_plus
id|board-&gt;language
op_plus
(paren
id|board-&gt;mfg_date
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|board-&gt;mfg_date
op_amp
l_int|0xFF00
)paren
op_plus
(paren
id|board-&gt;mfg_date
op_amp
l_int|0xFF0000
)paren
op_plus
id|board-&gt;manuf_tl
op_plus
id|board-&gt;product_tl
op_plus
id|board-&gt;serial_num_tl
op_plus
id|board-&gt;part_num_tl
op_plus
id|board-&gt;board_rev_tl
op_plus
id|board-&gt;board_rev
(braket
l_int|0
)braket
op_plus
id|board-&gt;board_rev
(braket
l_int|1
)braket
op_plus
id|board-&gt;eeprom_size_tl
op_plus
id|board-&gt;eeprom_size
op_plus
id|board-&gt;temp_waiver_tl
op_plus
id|board-&gt;temp_waiver
(braket
l_int|0
)braket
op_plus
id|board-&gt;temp_waiver
(braket
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|board-&gt;manuf_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|board-&gt;manuf
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|board-&gt;product_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|board-&gt;product
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|board-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|board-&gt;serial_num
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|board-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cs
op_add_assign
id|board-&gt;part_num
(braket
id|i
)braket
suffix:semicolon
)brace
id|board-&gt;checksum
op_assign
l_int|256
op_minus
(paren
id|cs
op_mod
l_int|256
)paren
suffix:semicolon
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|macro|EEPROM_CHUNKSIZE
mdefine_line|#define EEPROM_CHUNKSIZE&t;64
macro_line|#if defined(EEPROM_DEBUG)
DECL|macro|RETURN_ERROR
mdefine_line|#define RETURN_ERROR&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    printk( &quot;read_ia error return, component 0x%x, line %d&quot;&t;&t;&bslash;&n;&t;    &quot;, address 0x%x, ia code 0x%x&bslash;n&quot;,&t;&t;&t;&t;&bslash;&n;&t;    l1_compt, __LINE__, sc-&gt;subch[subch].target, ia_code );&t;&bslash;&n;    return EEP_L1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
macro_line|#else
DECL|macro|RETURN_ERROR
mdefine_line|#define RETURN_ERROR&t;return(EEP_L1)
macro_line|#endif
DECL|function|read_ia
r_int
id|read_ia
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|subch
comma
r_int
id|l1_compt
comma
r_int
id|ia_code
comma
r_char
op_star
id|eep_record
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* message buffer */
r_int
id|len
suffix:semicolon
multiline_comment|/* number of bytes used in message buffer */
r_int
id|ia_len
op_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
multiline_comment|/* remaining bytes in info area */
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* current offset into info area */
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
id|BZERO
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
multiline_comment|/* retrieve EEPROM data in 64-byte chunks&n;     */
r_while
c_loop
(paren
id|ia_len
)paren
(brace
multiline_comment|/* fill in msg with opcode &amp; params */
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_EEPROM
comma
l_int|8
comma
id|L1_ARG_INT
comma
id|l1_compt
comma
id|L1_ARG_INT
comma
id|ia_code
comma
id|L1_ARG_INT
comma
id|offset
comma
id|L1_ARG_INT
comma
id|ia_len
)paren
)paren
OL
l_int|0
)paren
(brace
id|RETURN_ERROR
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|RETURN_ERROR
suffix:semicolon
)brace
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|5
comma
id|L1_ARG_INT
comma
op_amp
id|ia_len
comma
id|L1_ARG_UNKNOWN
comma
op_amp
id|len
comma
id|eep_record
)paren
OL
l_int|0
)paren
(brace
id|RETURN_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ia_len
OG
id|EEPROM_CHUNKSIZE
)paren
(brace
id|ia_len
op_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
)brace
id|eep_record
op_add_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
id|offset
op_add_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|read_spd
r_int
id|read_spd
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|subch
comma
r_int
id|l1_compt
comma
id|eeprom_spd_u
op_star
id|spd
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* message buffer */
r_int
id|len
suffix:semicolon
multiline_comment|/* number of bytes used in message buffer */
r_int
id|resp
suffix:semicolon
multiline_comment|/* l1 response code */
r_int
id|spd_len
op_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
multiline_comment|/* remaining bytes in spd record */
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* current offset into spd record */
r_char
op_star
id|spd_p
op_assign
id|spd-&gt;bytes
suffix:semicolon
multiline_comment|/* &quot;thumb&quot; for writing to spd */
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
id|BZERO
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
multiline_comment|/* retrieve EEPROM data in 64-byte chunks&n;     */
r_while
c_loop
(paren
id|spd_len
)paren
(brace
multiline_comment|/* fill in msg with opcode &amp; params */
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_EEPROM
comma
l_int|8
comma
id|L1_ARG_INT
comma
id|l1_compt
comma
id|L1_ARG_INT
comma
id|L1_EEP_SPD
comma
id|L1_ARG_INT
comma
id|offset
comma
id|L1_ARG_INT
comma
id|spd_len
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* check response */
r_if
c_cond
(paren
(paren
id|resp
op_assign
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|5
comma
id|L1_ARG_INT
comma
op_amp
id|spd_len
comma
id|L1_ARG_UNKNOWN
comma
op_amp
id|len
comma
id|spd_p
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;             * translate l1 response code to eeprom.c error codes:&n;             * The L1 response will be L1_RESP_NAVAIL if the spd&n;             * can&squot;t be read (i.e. the spd isn&squot;t physically there). It will&n;             * return L1_RESP_INVAL if the spd exists, but fails the checksum&n;             * test because the eeprom wasn&squot;t programmed, programmed incorrectly,&n;             * or corrupted. L1_RESP_NAVAIL indicates the eeprom is likely not present,&n;             * whereas L1_RESP_INVAL indicates the eeprom is present, but the data is&n;             * invalid.&n;             */
r_if
c_cond
(paren
id|resp
op_eq
id|L1_RESP_INVAL
)paren
(brace
id|resp
op_assign
id|EEP_BAD_CHECKSUM
suffix:semicolon
)brace
r_else
(brace
id|resp
op_assign
id|EEP_L1
suffix:semicolon
)brace
r_return
id|resp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spd_len
OG
id|EEPROM_CHUNKSIZE
)paren
(brace
id|spd_len
op_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
)brace
id|spd_p
op_add_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
id|offset
op_add_assign
id|EEPROM_CHUNKSIZE
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|read_chassis_ia
r_int
id|read_chassis_ia
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|subch
comma
r_int
id|l1_compt
comma
id|eeprom_chassis_ia_t
op_star
id|ia
)paren
(brace
r_char
id|eep_record
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch area for building up info area */
r_char
op_star
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
multiline_comment|/* thumb for moving through eep_record */
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* use to verify eeprom record checksum */
r_int
id|i
suffix:semicolon
multiline_comment|/* Read in info area record from the L1.&n;     */
r_if
c_cond
(paren
id|read_ia
c_func
(paren
id|sc
comma
id|subch
comma
id|l1_compt
comma
id|L1_EEP_CHASSIS
comma
id|eep_record
)paren
op_ne
id|EEP_OK
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;ve got the whole info area.  Transfer it to the data structure.&n;     */
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
id|ia-&gt;format
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;length
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ia-&gt;length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* since we&squot;re using 8*ia-&gt;length-1 as an array index later, make&n;&t; * sure it&squot;s sane.&n;&t; */
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_chassis_ia: eeprom length byte of ZERO&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
id|ia-&gt;type
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;part_num_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
(paren
r_void
)paren
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;part_num
comma
(paren
id|ia-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;serial_num_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;serial_num
comma
(paren
id|ia-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;checksum
op_assign
id|eep_record
(braket
(paren
l_int|8
op_star
id|ia-&gt;length
)paren
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* verify checksum */
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|8
op_star
id|ia-&gt;length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|checksum
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_chassis_ia: bad checksum&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_chassis_ia: target 0x%x  uart 0x%lx&bslash;n&quot;
comma
id|sc-&gt;subch
(braket
id|subch
)braket
dot
id|target
comma
id|sc-&gt;uart
)paren
)paren
suffix:semicolon
r_return
id|EEP_BAD_CHECKSUM
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|function|read_board_ia
r_int
id|read_board_ia
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|subch
comma
r_int
id|l1_compt
comma
id|eeprom_board_ia_t
op_star
id|ia
)paren
(brace
r_char
id|eep_record
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch area for building up info area */
r_char
op_star
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
multiline_comment|/* thumb for moving through eep_record */
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* running checksum total */
r_int
id|i
suffix:semicolon
id|BZERO
c_func
(paren
id|ia
comma
r_sizeof
(paren
id|eeprom_board_ia_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Read in info area record from the L1.&n;     */
r_if
c_cond
(paren
id|read_ia
c_func
(paren
id|sc
comma
id|subch
comma
id|l1_compt
comma
id|L1_EEP_BOARD
comma
id|eep_record
)paren
op_ne
id|EEP_OK
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_board_ia: error reading info area from L1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;ve got the whole info area.  Transfer it to the data structure.&n;      */
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
id|ia-&gt;format
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;length
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ia-&gt;length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* since we&squot;re using 8*ia-&gt;length-1 as an array index later, make&n;&t; * sure it&squot;s sane.&n;&t; */
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_board_ia: eeprom length byte of ZERO&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
id|ia-&gt;language
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;mfg_date
op_assign
id|eeprom_xlate_board_mfr_date
c_func
(paren
(paren
id|uchar_t
op_star
)paren
id|eep_rec_p
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
l_int|3
suffix:semicolon
id|ia-&gt;manuf_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;manuf
comma
(paren
id|ia-&gt;manuf_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;manuf_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;product_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;product
comma
(paren
id|ia-&gt;product_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;product_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;serial_num_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;serial_num
comma
(paren
id|ia-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;serial_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;part_num_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;part_num
comma
(paren
id|ia-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;part_num_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|eep_rec_p
op_increment
suffix:semicolon
multiline_comment|/* we do not use the FRU file id */
id|ia-&gt;board_rev_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;board_rev
comma
(paren
id|ia-&gt;board_rev_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;board_rev_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;eeprom_size_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;eeprom_size
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|ia-&gt;temp_waiver_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;temp_waiver
comma
(paren
id|ia-&gt;temp_waiver_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;temp_waiver_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
multiline_comment|/* if there&squot;s more, we must be reading a main board; get&n;     * additional fields&n;     */
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
)paren
op_star
id|eep_rec_p
op_ne
(paren
r_int
r_char
)paren
id|EEPROM_EOF
)paren
)paren
(brace
id|ia-&gt;ekey_G_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
(paren
r_char
op_star
)paren
op_amp
id|ia-&gt;ekey_G
comma
id|ia-&gt;ekey_G_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;ekey_G_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;ekey_P_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
(paren
r_char
op_star
)paren
op_amp
id|ia-&gt;ekey_P
comma
id|ia-&gt;ekey_P_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;ekey_P_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;ekey_Y_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
(paren
r_char
op_star
)paren
op_amp
id|ia-&gt;ekey_Y
comma
id|ia-&gt;ekey_Y_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;ekey_Y_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * need to get a couple more fields if this is an I brick &n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
)paren
op_star
id|eep_rec_p
op_ne
(paren
r_int
r_char
)paren
id|EEPROM_EOF
)paren
)paren
(brace
id|ia-&gt;mac_addr_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;mac_addr
comma
id|ia-&gt;mac_addr_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|eep_rec_p
op_add_assign
(paren
id|ia-&gt;mac_addr_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
id|ia-&gt;ieee1394_cfg_tl
op_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
id|BCOPY
c_func
(paren
id|eep_rec_p
comma
id|ia-&gt;ieee1394_cfg
comma
id|ia-&gt;ieee1394_cfg_tl
op_amp
id|FIELD_LENGTH_MASK
)paren
suffix:semicolon
)brace
)brace
id|ia-&gt;checksum
op_assign
id|eep_record
(braket
(paren
id|ia-&gt;length
op_star
l_int|8
)paren
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* verify checksum */
id|eep_rec_p
op_assign
id|eep_record
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|8
op_star
id|ia-&gt;length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
op_star
id|eep_rec_p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|checksum
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_board_ia: bad checksum&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|db_printf
c_func
(paren
(paren
l_string|&quot;read_board_ia: target 0x%x  uart 0x%lx&bslash;n&quot;
comma
id|sc-&gt;subch
(braket
id|subch
)braket
dot
id|target
comma
id|sc-&gt;uart
)paren
)paren
suffix:semicolon
r_return
id|EEP_BAD_CHECKSUM
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
)brace
DECL|function|_cbrick_eeprom_read
r_int
id|_cbrick_eeprom_read
c_func
(paren
id|eeprom_brd_record_t
op_star
id|buf
comma
id|l1sc_t
op_star
id|scp
comma
r_int
id|component
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_int
id|r
suffix:semicolon
r_uint64
id|uid
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef LOG_GETENV
r_char
id|uid_str
(braket
l_int|32
)braket
suffix:semicolon
macro_line|#endif
r_int
id|l1_compt
comma
id|subch
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
multiline_comment|/* make sure we&squot;re targeting a cbrick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|C_BRICK
)paren
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
multiline_comment|/* If the promlog variable pointed to by IP27LOG_OVNIC is set,&n;     * use that value for the cbrick UID rather than the EEPROM&n;     * serial number.&n;     */
macro_line|#ifdef LOG_GETENV
r_if
c_cond
(paren
id|ip27log_getenv
c_func
(paren
id|scp-&gt;nasid
comma
id|IP27LOG_OVNIC
comma
id|uid_str
comma
l_string|&quot;0&quot;
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;_cbrick_eeprom_read: &quot;
l_string|&quot;Overriding UID with environment variable %s&bslash;n&quot;
comma
id|IP27LOG_OVNIC
)paren
)paren
suffix:semicolon
id|uid
op_assign
id|strtoull
c_func
(paren
id|uid_str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|scp
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|component
op_amp
id|C_DIMM
)paren
op_eq
id|C_DIMM
)paren
(brace
id|l1_compt
op_assign
id|L1_EEP_DIMM
c_func
(paren
id|component
op_amp
id|COMPT_MASK
)paren
suffix:semicolon
id|r
op_assign
id|read_spd
c_func
(paren
id|scp
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;spd
)paren
suffix:semicolon
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|component
)paren
(brace
r_case
id|C_BRICK
suffix:colon
multiline_comment|/* c-brick motherboard */
id|l1_compt
op_assign
id|L1_EEP_NODE
suffix:semicolon
id|r
op_assign
id|read_chassis_ia
c_func
(paren
id|scp
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;chassis_ia
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
id|db_printf
c_func
(paren
(paren
l_string|&quot;_cbrick_eeprom_read: using a fake eeprom record&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|fake_an_eeprom_record
c_func
(paren
id|buf
comma
id|component
comma
id|uid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uid
)paren
(brace
multiline_comment|/* If IP27LOG_OVNIC is set, we want to put that value&n;&t;     * in as our UID. */
id|fake_a_serial_number
c_func
(paren
id|buf-&gt;chassis_ia-&gt;serial_num
comma
id|uid
)paren
suffix:semicolon
id|buf-&gt;chassis_ia-&gt;serial_num_tl
op_assign
l_int|6
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|C_PIMM
suffix:colon
multiline_comment|/* one of the PIMM boards */
id|l1_compt
op_assign
id|L1_EEP_PIMM
c_func
(paren
id|component
op_amp
id|COMPT_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unsupported board type */
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_return
id|EEP_PARAM
suffix:semicolon
)brace
id|r
op_assign
id|read_board_ia
c_func
(paren
id|scp
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;board_ia
)paren
suffix:semicolon
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;_cbrick_eeprom_read: using a fake eeprom record&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|fake_an_eeprom_record
c_func
(paren
id|buf
comma
id|component
comma
id|uid
)paren
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|cbrick_eeprom_read
r_int
id|cbrick_eeprom_read
c_func
(paren
id|eeprom_brd_record_t
op_star
id|buf
comma
id|nasid_t
id|nasid
comma
r_int
id|component
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
id|l1sc_t
op_star
id|scp
suffix:semicolon
r_int
id|local
op_assign
(paren
id|nasid
op_eq
id|get_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
multiline_comment|/* If this brick is retrieving its own uid, use the local l1sc_t to&n;     * arbitrate access to the l1; otherwise, set up a new one (prom) or&n;     * use an existing remote l1sc_t (kernel)&n;     */
r_if
c_cond
(paren
id|local
)paren
(brace
id|scp
op_assign
id|get_l1sc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|scp
op_assign
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
suffix:semicolon
)brace
r_return
id|_cbrick_eeprom_read
c_func
(paren
id|buf
comma
id|scp
comma
id|component
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
DECL|function|iobrick_eeprom_read
r_int
id|iobrick_eeprom_read
c_func
(paren
id|eeprom_brd_record_t
op_star
id|buf
comma
id|nasid_t
id|nasid
comma
r_int
id|component
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_int
id|r
suffix:semicolon
r_int
id|l1_compt
comma
id|subch
suffix:semicolon
id|l1sc_t
op_star
id|scp
suffix:semicolon
r_int
id|local
op_assign
(paren
id|nasid
op_eq
id|get_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
multiline_comment|/* make sure we&squot;re talking to an applicable brick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|IO_BRICK
)paren
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re talking to this c-brick&squot;s attached io brick, use&n;     * the local l1sc_t; otherwise, set up a new one (prom) or&n;     * use an existing remote l1sc_t (kernel)&n;     */
r_if
c_cond
(paren
id|local
)paren
(brace
id|scp
op_assign
id|get_l1sc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|scp
op_assign
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|scp
comma
id|L1_ADDR_LOCALIO
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|EEP_L1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|component
)paren
(brace
r_case
id|IO_BRICK
suffix:colon
multiline_comment|/* IO brick motherboard */
id|l1_compt
op_assign
id|L1_EEP_LOGIC
suffix:semicolon
id|r
op_assign
id|read_chassis_ia
c_func
(paren
id|scp
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;chassis_ia
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Whenever we no longer need to test on hardware&n;&t; * that does not have EEPROMS, then this can be removed.&n;&t; */
id|r
op_assign
id|fake_an_eeprom_record
c_func
(paren
id|buf
comma
id|component
comma
id|rtc_time
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IO_POWER
suffix:colon
multiline_comment|/* IO brick power board */
id|l1_compt
op_assign
id|L1_EEP_POWER
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unsupported board type */
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_return
id|EEP_PARAM
suffix:semicolon
)brace
id|r
op_assign
id|read_board_ia
c_func
(paren
id|scp
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;board_ia
)paren
suffix:semicolon
id|sc_close
c_func
(paren
id|scp
comma
id|subch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */    
)brace
DECL|function|vector_eeprom_read
r_int
id|vector_eeprom_read
c_func
(paren
id|eeprom_brd_record_t
op_star
id|buf
comma
id|nasid_t
id|nasid
comma
id|net_vec_t
id|path
comma
r_int
id|component
)paren
(brace
macro_line|#if !defined(CONFIG_SERIAL_SGI_L1_PROTOCOL)
r_return
id|EEP_L1
suffix:semicolon
macro_line|#else
r_int
id|r
suffix:semicolon
r_uint64
id|uid
op_assign
l_int|0
suffix:semicolon
r_int
id|l1_compt
comma
id|subch
suffix:semicolon
id|l1sc_t
id|sc
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|EEP_L1
suffix:semicolon
multiline_comment|/* make sure we&squot;re targeting an applicable brick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|component
op_amp
id|VECTOR
)paren
)paren
(brace
r_return
id|EEP_PARAM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|component
op_amp
id|BRICK_MASK
)paren
(brace
r_case
id|R_BRICK
suffix:colon
id|ROUTER_LOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|sc_init
c_func
(paren
op_amp
id|sc
comma
id|nasid
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
op_amp
id|sc
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;vector_eeprom_read: couldn&squot;t open subch&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|EEP_L1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|component
)paren
(brace
r_case
id|R_BRICK
suffix:colon
multiline_comment|/* r-brick motherboard */
id|l1_compt
op_assign
id|L1_EEP_LOGIC
suffix:semicolon
id|r
op_assign
id|read_chassis_ia
c_func
(paren
op_amp
id|sc
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;chassis_ia
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;vector_eeprom_read: couldn&squot;t get rbrick eeprom info;&quot;
l_string|&quot; using current time as uid&bslash;n&quot;
)paren
suffix:semicolon
id|uid
op_assign
id|rtc_time
c_func
(paren
)paren
suffix:semicolon
id|db_printf
c_func
(paren
(paren
l_string|&quot;vector_eeprom_read: using a fake eeprom record&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|fake_an_eeprom_record
c_func
(paren
id|buf
comma
id|component
comma
id|uid
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|R_POWER
suffix:colon
multiline_comment|/* r-brick power board */
id|l1_compt
op_assign
id|L1_EEP_POWER
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unsupported board type */
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|EEP_PARAM
suffix:semicolon
)brace
id|r
op_assign
id|read_board_ia
c_func
(paren
op_amp
id|sc
comma
id|subch
comma
id|l1_compt
comma
id|buf-&gt;board_ia
)paren
suffix:semicolon
id|sc_close
c_func
(paren
op_amp
id|sc
comma
id|subch
)paren
suffix:semicolon
id|ROUTER_UNLOCK
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|EEP_OK
)paren
(brace
id|db_printf
c_func
(paren
(paren
l_string|&quot;vector_eeprom_read: using a fake eeprom record&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|fake_an_eeprom_record
c_func
(paren
id|buf
comma
id|component
comma
id|uid
)paren
suffix:semicolon
)brace
r_return
id|EEP_OK
suffix:semicolon
r_case
id|C_BRICK
suffix:colon
id|sc_init
c_func
(paren
op_amp
id|sc
comma
id|nasid
comma
id|path
)paren
suffix:semicolon
r_return
id|_cbrick_eeprom_read
c_func
(paren
id|buf
comma
op_amp
id|sc
comma
id|component
)paren
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unsupported brick type */
r_return
id|EEP_PARAM
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
eof
