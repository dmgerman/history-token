multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/nodemask.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/synergy.h&gt;
macro_line|#if defined (CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
macro_line|#include &lt;asm/sn/sn1/ip27config.h&gt;
macro_line|#include &lt;asm/sn/sn1/hubdev.h&gt;
macro_line|#include &lt;asm/sn/sn1/sn1.h&gt;
macro_line|#endif /* CONFIG_SGI_IP35 || CONFIG_IA64_SGI_SN1 */
r_extern
r_int
id|numcpus
suffix:semicolon
r_extern
r_char
id|arg_maxnodes
(braket
)braket
suffix:semicolon
r_extern
id|cpuid_t
id|master_procid
suffix:semicolon
r_extern
r_void
op_star
id|kmem_alloc_node
c_func
(paren
r_register
r_int
comma
r_register
r_int
comma
id|cnodeid_t
)paren
suffix:semicolon
r_extern
id|synergy_da_t
op_star
id|Synergy_da_indr
(braket
)braket
suffix:semicolon
r_extern
r_int
id|hasmetarouter
suffix:semicolon
DECL|variable|maxcpus
r_int
id|maxcpus
suffix:semicolon
DECL|variable|boot_cpumask
id|cpumask_t
id|boot_cpumask
suffix:semicolon
DECL|variable|region_mask
id|hubreg_t
id|region_mask
op_assign
l_int|0
suffix:semicolon
r_extern
id|xwidgetnum_t
id|hub_widget_id
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
DECL|variable|fine_mode
r_static
r_int
id|fine_mode
op_assign
l_int|0
suffix:semicolon
DECL|variable|hub_init_mask
r_static
id|cnodemask_t
id|hub_init_mask
suffix:semicolon
multiline_comment|/* Mask of cpu in a node doing init */
DECL|variable|hub_init_done_mask
r_static
r_volatile
id|cnodemask_t
id|hub_init_done_mask
suffix:semicolon
multiline_comment|/* Node mask where we wait for&n;&t;&t;&t;&t;&t; * per hub initialization&n;&t;&t;&t;&t;&t; */
DECL|variable|hub_mask_lock
id|spinlock_t
id|hub_mask_lock
suffix:semicolon
multiline_comment|/* Lock for hub_init_mask above. */
r_extern
r_int
id|valid_icache_reasons
suffix:semicolon
multiline_comment|/* Reasons to flush the icache */
r_extern
r_int
id|valid_dcache_reasons
suffix:semicolon
multiline_comment|/* Reasons to flush the dcache */
r_extern
r_int
id|numnodes
suffix:semicolon
r_extern
id|u_char
id|miniroot
suffix:semicolon
r_extern
r_volatile
r_int
id|need_utlbmiss_patch
suffix:semicolon
r_extern
r_void
id|iograph_early_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|master_nasid
id|nasid_t
id|master_nasid
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/*&n; * mlreset(int slave)&n; * &t;very early machine reset - at this point NO interrupts have been&n; * &t;enabled; nor is memory, tlb, p0, etc setup.&n; *&n; * &t;slave is zero when mlreset is called for the master processor and&n; *&t;is nonzero thereafter.&n; */
r_void
DECL|function|mlreset
id|mlreset
c_func
(paren
r_int
id|slave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are the master cpu and node.&n;&t;&t; */
id|master_nasid
op_assign
id|get_nasid
c_func
(paren
)paren
suffix:semicolon
id|set_master_bridge_base
c_func
(paren
)paren
suffix:semicolon
id|FIXME
c_func
(paren
l_string|&quot;mlreset: Enable when we support ioc3 ..&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;LATER
r_if
c_cond
(paren
id|get_console_nasid
c_func
(paren
)paren
op_eq
id|master_nasid
)paren
multiline_comment|/* Set up the IOC3 */
id|ioc3_mlreset
c_func
(paren
(paren
id|ioc3_cfg_t
op_star
)paren
id|KL_CONFIG_CH_CONS_INFO
c_func
(paren
id|master_nasid
)paren
op_member_access_from_pointer
id|config_base
comma
(paren
id|ioc3_mem_t
op_star
)paren
id|KL_CONFIG_CH_CONS_INFO
c_func
(paren
id|master_nasid
)paren
op_member_access_from_pointer
id|memory_base
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize Master nvram base.&n;&t;&t; */
id|nvram_baseinit
c_func
(paren
)paren
suffix:semicolon
id|fine_mode
op_assign
id|is_fine_dirmode
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* LATER */
multiline_comment|/* We&squot;re the master processor */
id|master_procid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|master_nasid
op_assign
id|cpuid_to_nasid
c_func
(paren
id|master_procid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * master_nasid we get back better be same as one from&n;&t;&t; * get_nasid()&n;&t;&t; */
id|ASSERT_ALWAYS
c_func
(paren
id|master_nasid
op_eq
id|get_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef&t;LATER
multiline_comment|/*&n;&t; * Activate when calias is implemented.&n;&t; */
multiline_comment|/* Set all nodes&squot; calias sizes to 8k */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|sn
suffix:semicolon
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Always have node 0 in the region mask, otherwise CALIAS accesses&n;&t;&t;&t; * get exceptions since the hub thinks it is a node 0 address.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_REGION_PRESENT
comma
(paren
id|region_mask
op_or
l_int|1
)paren
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CALIAS_SIZE
comma
id|PI_CALIAS_SIZE_8K
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Set up all hubs to havew a big window pointing at&n;&t;&t;&t; * widget 0.&n;&t;&t;&t; * Memory mode, widget 0, offset 0&n;&t;&t;&t; */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ITTE
c_func
(paren
id|SWIN0_BIGWIN
)paren
comma
(paren
(paren
id|HUB_PIO_MAP_TO_MEM
op_lshift
id|IIO_ITTE_IOSP_SHIFT
)paren
op_or
(paren
l_int|0
op_lshift
id|IIO_ITTE_WIDGET_SHIFT
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* LATER */
multiline_comment|/* Set up the hub initialization mask and init the lock */
id|CNODEMASK_CLRALL
c_func
(paren
id|hub_init_mask
)paren
suffix:semicolon
id|CNODEMASK_CLRALL
c_func
(paren
id|hub_init_done_mask
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hub_mask_lock
)paren
suffix:semicolon
multiline_comment|/* early initialization of iograph */
id|iograph_early_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize Hub Pseudodriver Management */
id|hubdev_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef&t;LATER
multiline_comment|/*&n;&t;&t; * Our IO system doesn&squot;t require cache writebacks.  Set some&n;&t;&t; * variables appropriately.&n;&t;&t; */
id|cachewrback
op_assign
l_int|0
suffix:semicolon
id|valid_icache_reasons
op_and_assign
op_complement
(paren
id|CACH_AVOID_VCES
op_or
id|CACH_IO_COHERENCY
)paren
suffix:semicolon
id|valid_dcache_reasons
op_and_assign
op_complement
(paren
id|CACH_AVOID_VCES
op_or
id|CACH_IO_COHERENCY
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * make sure we are running with the right rev of chips&n;&t;&t; */
id|verify_snchip_rev
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Since we&squot;ve wiped out memory at this point, we&n;                 * need to reset the ARCS vector table so that it&n;                 * points to appropriate functions in the kernel&n;                 * itself.  In this way, we can maintain the ARCS&n;                 * vector table conventions without having to actually&n;                 * keep redundant PROM code in memory.&n;                 */
id|he_arcs_set_vectors
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* LATER */
)brace
r_else
(brace
multiline_comment|/* slave != 0 */
multiline_comment|/*&n;&t;&t; * This code is performed ONLY by slave processors.&n;&t;&t; */
)brace
)brace
multiline_comment|/* XXX - Move the meat of this to intr.c ? */
multiline_comment|/*&n; * Set up the platform-dependent fields in the nodepda.&n; */
DECL|function|init_platform_nodepda
r_void
id|init_platform_nodepda
c_func
(paren
id|nodepda_t
op_star
id|npda
comma
id|cnodeid_t
id|node
)paren
(brace
id|hubinfo_t
id|hubinfo
suffix:semicolon
r_int
id|sn
suffix:semicolon
id|cnodeid_t
id|i
suffix:semicolon
id|ushort
op_star
id|numcpus_p
suffix:semicolon
r_extern
r_void
id|router_map_init
c_func
(paren
id|nodepda_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|router_queue_init
c_func
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
)paren
suffix:semicolon
r_extern
r_void
id|intr_init_vecblk
c_func
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
comma
r_int
)paren
suffix:semicolon
macro_line|#if defined(DEBUG)
r_extern
id|spinlock_t
id|intr_dev_targ_map_lock
suffix:semicolon
r_extern
r_uint64
id|intr_dev_targ_map_size
suffix:semicolon
multiline_comment|/* Initialize the lock to access the device - target cpu mapping&n;&t; * table. This table is explicitly for debugging purposes only and&n;&t; * to aid the &quot;intrmap&quot; idbg command&n;&t; */
r_if
c_cond
(paren
id|node
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Make sure we do this only once .&n;&t;&t; * There is always a cnode 0 present.&n;&t;&t; */
id|intr_dev_targ_map_size
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|intr_dev_targ_map_lock
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/* Allocate per-node platform-dependent data */
id|hubinfo
op_assign
(paren
id|hubinfo_t
)paren
id|kmem_alloc_node
c_func
(paren
r_sizeof
(paren
r_struct
id|hubinfo_s
)paren
comma
id|GFP_ATOMIC
comma
id|node
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hubinfo
)paren
suffix:semicolon
id|npda-&gt;pdinfo
op_assign
(paren
r_void
op_star
)paren
id|hubinfo
suffix:semicolon
id|hubinfo-&gt;h_nodepda
op_assign
id|npda
suffix:semicolon
id|hubinfo-&gt;h_cnodeid
op_assign
id|node
suffix:semicolon
id|hubinfo-&gt;h_nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|node
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hubinfo-&gt;h_crblock
)paren
suffix:semicolon
id|hubinfo-&gt;h_widgetid
op_assign
id|hub_widget_id
c_func
(paren
id|hubinfo-&gt;h_nasid
)paren
suffix:semicolon
id|npda-&gt;xbow_peer
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/* Initialize the linked list of&n;&t; * router info pointers to the dependent routers&n;&t; */
id|npda-&gt;npda_rip_first
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* npda_rip_last always points to the place&n;&t; * where the next element is to be inserted&n;&t; * into the list &n;&t; */
id|npda-&gt;npda_rip_last
op_assign
op_amp
id|npda-&gt;npda_rip_first
suffix:semicolon
id|npda-&gt;dependent_routers
op_assign
l_int|0
suffix:semicolon
id|npda-&gt;module_id
op_assign
id|INVALID_MODULE
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the subnodePDA.&n;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|SNPDA
c_func
(paren
id|npda
comma
id|sn
)paren
op_member_access_from_pointer
id|prof_count
op_assign
l_int|0
suffix:semicolon
id|SNPDA
c_func
(paren
id|npda
comma
id|sn
)paren
op_member_access_from_pointer
id|next_prof_timeout
op_assign
l_int|0
suffix:semicolon
id|intr_init_vecblk
c_func
(paren
id|npda
comma
id|node
comma
id|sn
)paren
suffix:semicolon
)brace
id|npda-&gt;vector_unit_busy
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|npda-&gt;vector_lock
)paren
suffix:semicolon
id|mutex_init_locked
c_func
(paren
op_amp
id|npda-&gt;xbow_sema
)paren
suffix:semicolon
multiline_comment|/* init it locked? */
id|spin_lock_init
c_func
(paren
op_amp
id|npda-&gt;fprom_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|npda-&gt;node_utlbswitchlock
)paren
suffix:semicolon
id|npda-&gt;ni_error_print
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;LATER
r_if
c_cond
(paren
id|need_utlbmiss_patch
)paren
(brace
id|npda-&gt;node_need_utlbmiss_patch
op_assign
l_int|1
suffix:semicolon
id|npda-&gt;node_utlbmiss_patched
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Clear out the nasid mask.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NASID_MASK_BYTES
suffix:semicolon
id|i
op_increment
)paren
id|npda-&gt;nasid_mask
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Set my mask bit */
id|npda-&gt;nasid_mask
(braket
id|nasid
op_div
l_int|8
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|nasid
op_mod
l_int|8
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;LATER
id|npda-&gt;node_first_cpu
op_assign
id|get_cnode_cpu
c_func
(paren
id|node
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|npda-&gt;node_first_cpu
op_ne
id|CPU_NONE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Count number of cpus only if first CPU is valid.&n;&t;&t; */
id|numcpus_p
op_assign
op_amp
id|npda-&gt;node_num_cpus
suffix:semicolon
op_star
id|numcpus_p
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|npda-&gt;node_first_cpu
suffix:semicolon
id|i
OL
id|MAXCPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|CPUID_TO_COMPACT_NODEID
c_func
(paren
id|i
)paren
op_ne
id|node
)paren
r_break
suffix:semicolon
r_else
(paren
op_star
id|numcpus_p
)paren
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|npda-&gt;node_num_cpus
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Allocate memory for the dump stack on each node &n;&t; * This is useful during nmi handling since we&n;&t; * may not be guaranteed shared memory at that time&n;&t; * which precludes depending on a global dump stack&n;&t; */
macro_line|#ifdef&t;LATER
id|npda-&gt;dump_stack
op_assign
(paren
r_uint64
op_star
)paren
id|kmem_zalloc_node
c_func
(paren
id|DUMP_STACK_SIZE
comma
id|VM_NOSLEEP
comma
id|node
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|npda-&gt;dump_stack
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|npda-&gt;dump_stack
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the counter which prevents&n;&t; * both the cpus on a node to proceed with nmi&n;&t; * handling.&n;&t; */
macro_line|#ifdef&t;LATER
id|npda-&gt;dump_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setup the (module,slot) --&gt; nic mapping for all the routers&n;&t; * in the system. This is useful during error handling when&n;&t; * there is no shared memory.&n;&t; */
id|router_map_init
c_func
(paren
id|npda
)paren
suffix:semicolon
multiline_comment|/* Allocate memory for the per-node router traversal queue */
id|router_queue_init
c_func
(paren
id|npda
comma
id|node
)paren
suffix:semicolon
id|npda-&gt;sbe_info
op_assign
id|kmem_zalloc_node_hint
c_func
(paren
r_sizeof
(paren
id|sbe_info_t
)paren
comma
l_int|0
comma
id|node
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|npda-&gt;sbe_info
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SGI_IP35 || CONFIG_IA64_SGI_SN1 || CONFIG_IA64_GENERIC
multiline_comment|/*&n;&t; * Initialize bte info pointers to NULL&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BTES_PER_NODE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|npda-&gt;node_bte_info
(braket
id|i
)braket
op_assign
(paren
id|bteinfo_t
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* LATER */
)brace
multiline_comment|/* XXX - Move the interrupt stuff to intr.c ? */
multiline_comment|/*&n; * Set up the platform-dependent fields in the processor pda.&n; * Must be done _after_ init_platform_nodepda().&n; * If we need a lock here, something else is wrong!&n; */
singleline_comment|// void init_platform_pda(pda_t *ppda, cpuid_t cpu)
DECL|function|init_platform_pda
r_void
id|init_platform_pda
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
id|hub_intmasks_t
op_star
id|intmasks
suffix:semicolon
macro_line|#ifdef&t;LATER
id|cpuinfo_t
id|cpuinfo
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
id|cnodeid_t
id|cnode
suffix:semicolon
id|synergy_da_t
op_star
id|sda
suffix:semicolon
r_int
id|which_synergy
suffix:semicolon
macro_line|#ifdef&t;LATER
multiline_comment|/* Allocate per-cpu platform-dependent data */
id|cpuinfo
op_assign
(paren
id|cpuinfo_t
)paren
id|kmem_alloc_node
c_func
(paren
r_sizeof
(paren
r_struct
id|cpuinfo_s
)paren
comma
id|GFP_ATOMIC
comma
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|cpuinfo
)paren
suffix:semicolon
id|ppda-&gt;pdinfo
op_assign
(paren
r_void
op_star
)paren
id|cpuinfo
suffix:semicolon
id|cpuinfo-&gt;ci_cpupda
op_assign
id|ppda
suffix:semicolon
id|cpuinfo-&gt;ci_cpuid
op_assign
id|cpu
suffix:semicolon
macro_line|#endif
id|cnode
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|which_synergy
op_assign
id|cpuid_to_synergy
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|sda
op_assign
id|Synergy_da_indr
(braket
(paren
id|cnode
op_star
l_int|2
)paren
op_plus
id|which_synergy
)braket
suffix:semicolon
singleline_comment|// intmasks = &amp;ppda-&gt;p_intmasks;
id|intmasks
op_assign
op_amp
id|sda-&gt;s_intmasks
suffix:semicolon
macro_line|#ifdef&t;LATER
id|ASSERT_ALWAYS
c_func
(paren
op_amp
id|ppda-&gt;p_nodepda
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Clear INT_PEND0 masks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND0_MASKS
suffix:semicolon
id|i
op_increment
)paren
id|intmasks-&gt;intpend0_masks
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set up pointer to the vector block in the nodepda. */
multiline_comment|/* (Cant use SUBNODEPDA - not working yet) */
id|intmasks-&gt;dispatch0
op_assign
op_amp
id|Nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|snpda
(braket
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
)braket
dot
id|intr_dispatch0
suffix:semicolon
id|intmasks-&gt;dispatch1
op_assign
op_amp
id|Nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|snpda
(braket
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
)braket
dot
id|intr_dispatch1
suffix:semicolon
multiline_comment|/* Clear INT_PEND1 masks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND1_MASKS
suffix:semicolon
id|i
op_increment
)paren
id|intmasks-&gt;intpend1_masks
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;LATER
multiline_comment|/* Don&squot;t read the routers unless we&squot;re the master. */
id|ppda-&gt;p_routertick
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if (defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)) &amp;&amp; !defined(BRINGUP)&t;/* protect low mem for IP35/7 */
macro_line|#error &quot;need protect_hub_calias, protect_nmi_handler_data&quot;
macro_line|#endif
macro_line|#ifdef&t;LATER
multiline_comment|/*&n; * For now, just protect the first page (exception handlers). We&n; * may want to protect more stuff later.&n; */
r_void
DECL|function|protect_hub_calias
id|protect_hub_calias
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|paddr_t
id|pa
op_assign
id|NODE_OFFSET
c_func
(paren
id|nasid
)paren
op_plus
l_int|0
suffix:semicolon
multiline_comment|/* page 0 on node nasid */
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_REGIONS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|nasid_to_region
c_func
(paren
id|nasid
)paren
)paren
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Protect the page of low memory used to communicate with the NMI handler.&n; */
r_void
DECL|function|protect_nmi_handler_data
id|protect_nmi_handler_data
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|slice
)paren
(brace
id|paddr_t
id|pa
op_assign
id|NODE_OFFSET
c_func
(paren
id|nasid
)paren
op_plus
id|NMI_OFFSET
c_func
(paren
id|nasid
comma
id|slice
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_REGIONS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|nasid_to_region
c_func
(paren
id|nasid
)paren
)paren
r_continue
suffix:semicolon
)brace
)brace
macro_line|#endif /* LATER */
macro_line|#ifdef LATER
multiline_comment|/*&n; * Protect areas of memory that we access uncached by marking them as&n; * poisoned so the T5 can&squot;t read them speculatively and erroneously&n; * mark them dirty in its cache only to write them back with old data&n; * later.&n; */
r_static
r_void
DECL|function|protect_low_memory
id|protect_low_memory
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
multiline_comment|/* Protect low memory directory */
id|poison_state_alter_range
c_func
(paren
id|KLDIR_ADDR
c_func
(paren
id|nasid
)paren
comma
id|KLDIR_SIZE
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Protect klconfig area */
id|poison_state_alter_range
c_func
(paren
id|KLCONFIG_ADDR
c_func
(paren
id|nasid
)paren
comma
id|KLCONFIG_SIZE
c_func
(paren
id|nasid
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Protect the PI error spool area. */
id|poison_state_alter_range
c_func
(paren
id|PI_ERROR_ADDR
c_func
(paren
id|nasid
)paren
comma
id|PI_ERROR_SIZE
c_func
(paren
id|nasid
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Protect CPU A&squot;s cache error eframe area. */
id|poison_state_alter_range
c_func
(paren
id|TO_NODE_UNCAC
c_func
(paren
id|nasid
comma
id|CACHE_ERR_EFRAME
)paren
comma
id|CACHE_ERR_AREA_SIZE
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Protect CPU B&squot;s area */
id|poison_state_alter_range
c_func
(paren
id|TO_NODE_UNCAC
c_func
(paren
id|nasid
comma
id|CACHE_ERR_EFRAME
)paren
op_xor
id|UALIAS_FLIP_BIT
comma
id|CACHE_ERR_AREA_SIZE
comma
l_int|1
)paren
suffix:semicolon
macro_line|#error &quot;SN1 not handled correctly&quot;
)brace
macro_line|#endif&t;/* LATER */
multiline_comment|/*&n; * per_hub_init&n; *&n; * &t;This code is executed once for each Hub chip.&n; */
r_void
DECL|function|per_hub_init
id|per_hub_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_uint64
id|done
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|nodepda_t
op_star
id|npdap
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)&t;/* SN1 specific */
id|ii_icmr_u_t
id|ii_icmr
suffix:semicolon
id|ii_ibcr_u_t
id|ii_ibcr
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;LATER
r_int
id|i
suffix:semicolon
macro_line|#endif
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nasid
op_ne
id|INVALID_NASID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
op_eq
id|cnode
)paren
suffix:semicolon
multiline_comment|/* Grab the hub_mask lock. */
id|spin_lock
c_func
(paren
op_amp
id|hub_mask_lock
)paren
suffix:semicolon
multiline_comment|/* Test our bit. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|done
op_assign
id|CNODEMASK_TSTB
c_func
(paren
id|hub_init_mask
comma
id|cnode
)paren
)paren
)paren
(brace
multiline_comment|/* Turn our bit on in the mask. */
id|CNODEMASK_SETB
c_func
(paren
id|hub_init_mask
comma
id|cnode
)paren
suffix:semicolon
)brace
macro_line|#if defined(SN0_HWDEBUG)
id|hub_config_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Release the hub_mask lock. */
id|spin_unlock
c_func
(paren
op_amp
id|hub_mask_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do the actual initialization if it hasn&squot;t been done yet.&n;&t; * We don&squot;t need to hold a lock for this work.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|npdap
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SYNERGY_PERF)
multiline_comment|/* initialize per-node synergy perf instrumentation */
id|npdap-&gt;synergy_perf_enabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* off by default */
id|npdap-&gt;synergy_perf_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|npdap-&gt;synergy_perf_freq
op_assign
id|SYNERGY_PERF_FREQ_DEFAULT
suffix:semicolon
id|npdap-&gt;synergy_inactive_intervals
op_assign
l_int|0
suffix:semicolon
id|npdap-&gt;synergy_active_intervals
op_assign
l_int|0
suffix:semicolon
id|npdap-&gt;synergy_perf_data
op_assign
l_int|NULL
suffix:semicolon
id|npdap-&gt;synergy_perf_first
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* CONFIG_IA64_SGI_SYNERGY_PERF */
id|npdap-&gt;hub_chip_rev
op_assign
id|get_hub_chiprev
c_func
(paren
id|nasid
)paren
suffix:semicolon
macro_line|#ifdef&t;LATER
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPUS_PER_NODE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cnode_slice_to_cpuid
c_func
(paren
id|cnode
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_enabled
c_func
(paren
id|cpu
)paren
)paren
id|SET_CPU_LEDS
c_func
(paren
id|nasid
comma
id|i
comma
l_int|0xf
)paren
suffix:semicolon
)brace
macro_line|#endif /* LATER */
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC) /* SN1 specific */
multiline_comment|/*&n;&t;&t; * Set the total number of CRBs that can be used.&n;&t;&t; */
id|ii_icmr.ii_icmr_regval
op_assign
l_int|0x0
suffix:semicolon
id|ii_icmr.ii_icmr_fld_s.i_c_cnt
op_assign
l_int|0xF
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICMR
comma
id|ii_icmr.ii_icmr_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the number of CRBs that both of the BTEs combined&n;&t;&t; * can use minus 1.&n;&t;&t; */
id|ii_ibcr.ii_ibcr_regval
op_assign
l_int|0x0
suffix:semicolon
id|ii_ibcr.ii_ibcr_fld_s.i_count
op_assign
l_int|0x8
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IBCR
comma
id|ii_ibcr.ii_ibcr_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set CRB timeout to be 10ms.&n;&t;&t; */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICTP
comma
l_int|0x1000
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICTO
comma
l_int|0xff
)paren
suffix:semicolon
macro_line|#endif /* SN0_HWDEBUG */
multiline_comment|/* Reserve all of the hardwired interrupt levels. */
id|intr_reserve_hardwired
c_func
(paren
id|cnode
)paren
suffix:semicolon
multiline_comment|/* Initialize error interrupts for this hub. */
id|hub_error_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
macro_line|#ifdef LATER
multiline_comment|/* Set up correctable memory/directory ECC error interrupt. */
id|install_eccintr
c_func
(paren
id|cnode
)paren
suffix:semicolon
multiline_comment|/* Protect our exception vectors from accidental corruption. */
id|protect_hub_calias
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/* Enable RT clock interrupts */
id|hub_rtc_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hub_migrintr_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
multiline_comment|/* Enable migration interrupt */
macro_line|#endif&t;/* LATER */
id|spin_lock
c_func
(paren
op_amp
id|hub_mask_lock
)paren
suffix:semicolon
id|CNODEMASK_SETB
c_func
(paren
id|hub_init_done_mask
comma
id|cnode
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hub_mask_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Wait for the other CPU to complete the initialization.&n;&t;&t; */
r_while
c_loop
(paren
id|CNODEMASK_TSTB
c_func
(paren
id|hub_init_done_mask
comma
id|cnode
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * On SNIA64 we should never get here ..&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;WARNING: per_hub_init: Should NEVER get here!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* LOOP */
suffix:semicolon
)brace
)brace
)brace
r_extern
r_void
DECL|function|update_node_information
id|update_node_information
c_func
(paren
id|cnodeid_t
id|cnodeid
)paren
(brace
id|nodepda_t
op_star
id|npda
op_assign
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|nodepda_router_info_t
op_star
id|npda_rip
suffix:semicolon
multiline_comment|/* Go through the list of router info &n;&t; * structures and copy some frequently&n;&t; * accessed info from the info hanging&n;&t; * off the corresponding router vertices&n;&t; */
id|npda_rip
op_assign
id|npda-&gt;npda_rip_first
suffix:semicolon
r_while
c_loop
(paren
id|npda_rip
)paren
(brace
r_if
c_cond
(paren
id|npda_rip-&gt;router_infop
)paren
(brace
id|npda_rip-&gt;router_portmask
op_assign
id|npda_rip-&gt;router_infop-&gt;ri_portmask
suffix:semicolon
id|npda_rip-&gt;router_slot
op_assign
id|npda_rip-&gt;router_infop-&gt;ri_slotnum
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No router, no ports. */
id|npda_rip-&gt;router_portmask
op_assign
l_int|0
suffix:semicolon
)brace
id|npda_rip
op_assign
id|npda_rip-&gt;router_next
suffix:semicolon
)brace
)brace
id|hubreg_t
DECL|function|get_region
id|get_region
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_if
c_cond
(paren
id|fine_mode
)paren
r_return
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
op_rshift
id|NASID_TO_FINEREG_SHFT
suffix:semicolon
r_else
r_return
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
op_rshift
id|NASID_TO_COARSEREG_SHFT
suffix:semicolon
)brace
id|hubreg_t
DECL|function|nasid_to_region
id|nasid_to_region
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_if
c_cond
(paren
id|fine_mode
)paren
r_return
id|nasid
op_rshift
id|NASID_TO_FINEREG_SHFT
suffix:semicolon
r_else
r_return
id|nasid
op_rshift
id|NASID_TO_COARSEREG_SHFT
suffix:semicolon
)brace
eof
