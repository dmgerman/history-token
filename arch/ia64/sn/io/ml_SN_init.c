multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/snconfig.h&gt;
r_extern
r_int
id|numcpus
suffix:semicolon
r_extern
r_char
id|arg_maxnodes
(braket
)braket
suffix:semicolon
r_extern
id|cpuid_t
id|master_procid
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
r_extern
id|synergy_da_t
op_star
id|Synergy_da_indr
(braket
)braket
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|hasmetarouter
suffix:semicolon
DECL|variable|maxcpus
r_int
id|maxcpus
suffix:semicolon
DECL|variable|boot_cpumask
id|cpumask_t
id|boot_cpumask
suffix:semicolon
DECL|variable|region_mask
id|hubreg_t
id|region_mask
op_assign
l_int|0
suffix:semicolon
r_extern
id|xwidgetnum_t
id|hub_widget_id
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
r_extern
r_int
id|valid_icache_reasons
suffix:semicolon
multiline_comment|/* Reasons to flush the icache */
r_extern
r_int
id|valid_dcache_reasons
suffix:semicolon
multiline_comment|/* Reasons to flush the dcache */
r_extern
id|u_char
id|miniroot
suffix:semicolon
r_extern
r_volatile
r_int
id|need_utlbmiss_patch
suffix:semicolon
r_extern
r_void
id|iograph_early_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|master_nasid
id|nasid_t
id|master_nasid
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/*&n; * mlreset(int slave)&n; * &t;very early machine reset - at this point NO interrupts have been&n; * &t;enabled; nor is memory, tlb, p0, etc setup.&n; *&n; * &t;slave is zero when mlreset is called for the master processor and&n; *&t;is nonzero thereafter.&n; */
r_void
DECL|function|mlreset
id|mlreset
c_func
(paren
r_int
id|slave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are the master cpu and node.&n;&t;&t; */
id|master_nasid
op_assign
id|get_nasid
c_func
(paren
)paren
suffix:semicolon
id|set_master_bridge_base
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We&squot;re the master processor */
id|master_procid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|master_nasid
op_assign
id|cpuid_to_nasid
c_func
(paren
id|master_procid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * master_nasid we get back better be same as one from&n;&t;&t; * get_nasid()&n;&t;&t; */
id|ASSERT_ALWAYS
c_func
(paren
id|master_nasid
op_eq
id|get_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* early initialization of iograph */
id|iograph_early_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize Hub Pseudodriver Management */
id|hubdev_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* slave != 0 */
multiline_comment|/*&n;&t;&t; * This code is performed ONLY by slave processors.&n;&t;&t; */
)brace
)brace
multiline_comment|/* XXX - Move the meat of this to intr.c ? */
multiline_comment|/*&n; * Set up the platform-dependent fields in the nodepda.&n; */
DECL|function|init_platform_nodepda
r_void
id|init_platform_nodepda
c_func
(paren
id|nodepda_t
op_star
id|npda
comma
id|cnodeid_t
id|node
)paren
(brace
id|hubinfo_t
id|hubinfo
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
r_int
id|sn
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|router_map_init
c_func
(paren
id|nodepda_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|router_queue_init
c_func
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
)paren
suffix:semicolon
r_extern
r_void
id|intr_init_vecblk
c_func
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Allocate per-node platform-dependent data */
id|hubinfo
op_assign
(paren
id|hubinfo_t
)paren
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
r_sizeof
(paren
r_struct
id|hubinfo_s
)paren
)paren
suffix:semicolon
id|npda-&gt;pdinfo
op_assign
(paren
r_void
op_star
)paren
id|hubinfo
suffix:semicolon
id|hubinfo-&gt;h_nodepda
op_assign
id|npda
suffix:semicolon
id|hubinfo-&gt;h_cnodeid
op_assign
id|node
suffix:semicolon
id|hubinfo-&gt;h_nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|node
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hubinfo-&gt;h_crblock
)paren
suffix:semicolon
id|hubinfo-&gt;h_widgetid
op_assign
id|hub_widget_id
c_func
(paren
id|hubinfo-&gt;h_nasid
)paren
suffix:semicolon
id|npda-&gt;xbow_peer
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/* &n;&t; * Initialize the linked list of&n;&t; * router info pointers to the dependent routers&n;&t; */
id|npda-&gt;npda_rip_first
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * npda_rip_last always points to the place&n;&t; * where the next element is to be inserted&n;&t; * into the list &n;&t; */
id|npda-&gt;npda_rip_last
op_assign
op_amp
id|npda-&gt;npda_rip_first
suffix:semicolon
id|npda-&gt;module_id
op_assign
id|INVALID_MODULE
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
multiline_comment|/*&n;&t;* Initialize the interrupts.&n;&t;* On sn2, this is done at pci init time,&n;&t;* because sn2 needs the cpus checked in&n;&t;* when it initializes interrupts.  This is&n;&t;* so we don&squot;t see all the nodes as headless.&n;&t;*/
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|intr_init_vecblk
c_func
(paren
id|npda
comma
id|node
comma
id|sn
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IA64_SGI_SN1 */
id|mutex_init_locked
c_func
(paren
op_amp
id|npda-&gt;xbow_sema
)paren
suffix:semicolon
multiline_comment|/* init it locked? */
macro_line|#ifdef&t;LATER
multiline_comment|/* Setup the (module,slot) --&gt; nic mapping for all the routers&n;&t; * in the system. This is useful during error handling when&n;&t; * there is no shared memory.&n;&t; */
id|router_map_init
c_func
(paren
id|npda
)paren
suffix:semicolon
multiline_comment|/* Allocate memory for the per-node router traversal queue */
id|router_queue_init
c_func
(paren
id|npda
comma
id|node
)paren
suffix:semicolon
id|npda-&gt;sbe_info
op_assign
id|alloc_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
r_sizeof
(paren
id|sbe_info_t
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|npda-&gt;sbe_info
)paren
suffix:semicolon
macro_line|#endif /* LATER */
)brace
multiline_comment|/* XXX - Move the interrupt stuff to intr.c ? */
multiline_comment|/*&n; * Set up the platform-dependent fields in the processor pda.&n; * Must be done _after_ init_platform_nodepda().&n; * If we need a lock here, something else is wrong!&n; */
DECL|function|init_platform_pda
r_void
id|init_platform_pda
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
id|hub_intmasks_t
op_star
id|intmasks
suffix:semicolon
r_int
id|i
comma
id|subnode
suffix:semicolon
id|cnodeid_t
id|cnode
suffix:semicolon
id|synergy_da_t
op_star
id|sda
suffix:semicolon
r_int
id|which_synergy
suffix:semicolon
id|cnode
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|which_synergy
op_assign
id|cpuid_to_synergy
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|sda
op_assign
id|Synergy_da_indr
(braket
(paren
id|cnode
op_star
l_int|2
)paren
op_plus
id|which_synergy
)braket
suffix:semicolon
id|intmasks
op_assign
op_amp
id|sda-&gt;s_intmasks
suffix:semicolon
multiline_comment|/* Clear INT_PEND0 masks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND0_MASKS
suffix:semicolon
id|i
op_increment
)paren
id|intmasks-&gt;intpend0_masks
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set up pointer to the vector block in the nodepda. */
multiline_comment|/* (Cant use SUBNODEPDA - not working yet) */
id|subnode
op_assign
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intmasks-&gt;dispatch0
op_assign
op_amp
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|snpda
(braket
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
)braket
dot
id|intr_dispatch0
suffix:semicolon
id|intmasks-&gt;dispatch1
op_assign
op_amp
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|snpda
(braket
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
)braket
dot
id|intr_dispatch1
suffix:semicolon
r_if
c_cond
(paren
id|intmasks-&gt;dispatch0
op_ne
op_amp
id|SUBNODEPDA
c_func
(paren
id|cnode
comma
id|subnode
)paren
op_member_access_from_pointer
id|intr_dispatch0
op_logical_or
id|intmasks-&gt;dispatch1
op_ne
op_amp
id|SUBNODEPDA
c_func
(paren
id|cnode
comma
id|subnode
)paren
op_member_access_from_pointer
id|intr_dispatch1
)paren
id|panic
c_func
(paren
l_string|&quot;xxx&quot;
)paren
suffix:semicolon
id|intmasks-&gt;dispatch0
op_assign
op_amp
id|SUBNODEPDA
c_func
(paren
id|cnode
comma
id|subnode
)paren
op_member_access_from_pointer
id|intr_dispatch0
suffix:semicolon
id|intmasks-&gt;dispatch1
op_assign
op_amp
id|SUBNODEPDA
c_func
(paren
id|cnode
comma
id|subnode
)paren
op_member_access_from_pointer
id|intr_dispatch1
suffix:semicolon
multiline_comment|/* Clear INT_PEND1 masks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND1_MASKS
suffix:semicolon
id|i
op_increment
)paren
id|intmasks-&gt;intpend1_masks
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
)brace
r_void
DECL|function|update_node_information
id|update_node_information
c_func
(paren
id|cnodeid_t
id|cnodeid
)paren
(brace
id|nodepda_t
op_star
id|npda
op_assign
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|nodepda_router_info_t
op_star
id|npda_rip
suffix:semicolon
multiline_comment|/* Go through the list of router info &n;&t; * structures and copy some frequently&n;&t; * accessed info from the info hanging&n;&t; * off the corresponding router vertices&n;&t; */
id|npda_rip
op_assign
id|npda-&gt;npda_rip_first
suffix:semicolon
r_while
c_loop
(paren
id|npda_rip
)paren
(brace
r_if
c_cond
(paren
id|npda_rip-&gt;router_infop
)paren
(brace
id|npda_rip-&gt;router_portmask
op_assign
id|npda_rip-&gt;router_infop-&gt;ri_portmask
suffix:semicolon
id|npda_rip-&gt;router_slot
op_assign
id|npda_rip-&gt;router_infop-&gt;ri_slotnum
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No router, no ports. */
id|npda_rip-&gt;router_portmask
op_assign
l_int|0
suffix:semicolon
)brace
id|npda_rip
op_assign
id|npda_rip-&gt;router_next
suffix:semicolon
)brace
)brace
eof
