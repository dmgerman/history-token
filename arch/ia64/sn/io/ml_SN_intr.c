multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Alan Mayer&n; */
multiline_comment|/*&n; * intr.c-&n; *&t;This file contains all of the routines necessary to set up and&n; *&t;handle interrupts on an IP27 board.&n; */
macro_line|#ident  &quot;$Revision: 1.167 $&quot;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/nodemask.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/synergy.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#if DEBUG_INTR_TSTAMP_DEBUG
macro_line|#include &lt;sys/debug.h&gt;
macro_line|#include &lt;sys/idbg.h&gt;
macro_line|#include &lt;sys/inst.h&gt;
r_void
id|do_splx_log
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|spldebug_log_event
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// FIXME - BRINGUP
macro_line|#ifdef CONFIG_SMP
r_extern
r_int
r_int
id|cpu_online_map
suffix:semicolon
macro_line|#endif
DECL|macro|cpu_allows_intr
mdefine_line|#define cpu_allows_intr(cpu)&t;(1)
singleline_comment|// If I understand what&squot;s going on with this, 32 should work.
singleline_comment|// physmem_maxradius seems to be the maximum number of router
singleline_comment|// hops to get from one end of the system to the other.  With
singleline_comment|// a maximally configured machine, with the dumbest possible
singleline_comment|// topology, we would make 32 router hops.  For what we&squot;re using
singleline_comment|// it for, the dumbest possible should suffice.
DECL|macro|physmem_maxradius
mdefine_line|#define physmem_maxradius()&t;32
DECL|macro|SUBNODE_ANY
mdefine_line|#define SUBNODE_ANY -1
r_extern
r_int
id|nmied
suffix:semicolon
r_extern
r_int
id|hub_intr_wakeup_cnt
suffix:semicolon
r_extern
id|synergy_da_t
op_star
id|Synergy_da_indr
(braket
)braket
suffix:semicolon
r_extern
id|cpuid_t
id|master_procid
suffix:semicolon
r_extern
id|cnodeid_t
id|master_node_get
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
suffix:semicolon
r_extern
id|snia_error_intr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
suffix:semicolon
DECL|macro|INTR_LOCK
mdefine_line|#define INTR_LOCK(vecblk) &bslash;&n;     (s = mutex_spinlock(&amp;(vecblk)-&gt;vector_lock))
DECL|macro|INTR_UNLOCK
mdefine_line|#define INTR_UNLOCK(vecblk) &bslash;&n;      mutex_spinunlock(&amp;(vecblk)-&gt;vector_lock, s)
multiline_comment|/*&n; * REACT/Pro&n; */
multiline_comment|/* &n; * Find first bit set &n; * Used outside this file also &n; */
DECL|function|ms1bit
r_int
id|ms1bit
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|b
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|32
)paren
id|b
op_assign
l_int|32
comma
id|x
op_rshift_assign
l_int|32
suffix:semicolon
r_else
id|b
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|16
)paren
id|b
op_add_assign
l_int|16
comma
id|x
op_rshift_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|8
)paren
id|b
op_add_assign
l_int|8
comma
id|x
op_rshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|4
)paren
id|b
op_add_assign
l_int|4
comma
id|x
op_rshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|2
)paren
id|b
op_add_assign
l_int|2
comma
id|x
op_rshift_assign
l_int|2
suffix:semicolon
r_return
id|b
op_plus
(paren
r_int
)paren
(paren
id|x
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
r_void
DECL|function|intr_stray
id|intr_stray
c_func
(paren
r_void
op_star
id|lvl
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Stray Interrupt - level %ld to cpu %d&quot;
comma
(paren
r_int
)paren
id|lvl
comma
id|cpuid
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG)
multiline_comment|/* Infrastructure  to gather the device - target cpu mapping info */
DECL|macro|MAX_DEVICES
mdefine_line|#define MAX_DEVICES&t;1000&t;/* Reasonable large number . Need not be &n;&t;&t;&t;&t; * the exact maximum # devices possible.&n;&t;&t;&t;&t; */
DECL|macro|MAX_NAME
mdefine_line|#define MAX_NAME&t;100&t;
r_typedef
r_struct
(brace
DECL|member|dev
id|dev_t
id|dev
suffix:semicolon
multiline_comment|/* device */
DECL|member|cpuid
id|cpuid_t
id|cpuid
suffix:semicolon
multiline_comment|/* target cpu */
DECL|member|cnodeid
id|cnodeid_t
id|cnodeid
suffix:semicolon
multiline_comment|/* node on which the target cpu is present */
DECL|member|bit
r_int
id|bit
suffix:semicolon
multiline_comment|/* intr bit reserved */
DECL|member|intr_name
r_char
id|intr_name
(braket
id|MAX_NAME
)braket
suffix:semicolon
multiline_comment|/* name of the interrupt */
DECL|typedef|intr_dev_targ_map_t
)brace
id|intr_dev_targ_map_t
suffix:semicolon
DECL|variable|intr_dev_targ_map
id|intr_dev_targ_map_t
id|intr_dev_targ_map
(braket
id|MAX_DEVICES
)braket
suffix:semicolon
DECL|variable|intr_dev_targ_map_size
r_uint64
id|intr_dev_targ_map_size
suffix:semicolon
DECL|variable|intr_dev_targ_map_lock
id|spinlock_t
id|intr_dev_targ_map_lock
suffix:semicolon
multiline_comment|/* Print out the device - target cpu mapping.&n; * This routine is used only in the idbg command&n; * &quot;intrmap&quot; &n; */
r_void
DECL|function|intr_dev_targ_map_print
id|intr_dev_targ_map_print
c_func
(paren
id|cnodeid_t
id|cnodeid
)paren
(brace
r_int
id|i
comma
id|j
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|print_flag
op_assign
l_int|0
comma
id|verbose
op_assign
l_int|0
suffix:semicolon
r_char
id|node_name
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
(brace
id|nodepda_t
op_star
id|npda
suffix:semicolon
id|npda
op_assign
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NUM_SUBNODES
suffix:semicolon
id|j
op_increment
)paren
(brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;n SUBNODE %d&bslash;n INT_PEND0: &quot;
comma
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND_BITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|qprintf
c_func
(paren
l_string|&quot;%d&quot;
comma
id|SNPDA
c_func
(paren
id|npda
comma
id|j
)paren
op_member_access_from_pointer
id|intr_dispatch0.info
(braket
id|i
)braket
dot
id|ii_flags
)paren
suffix:semicolon
)brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;n INT_PEND1: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND_BITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|qprintf
c_func
(paren
l_string|&quot;%d&quot;
comma
id|SNPDA
c_func
(paren
id|npda
comma
id|j
)paren
op_member_access_from_pointer
id|intr_dispatch1.info
(braket
id|i
)braket
dot
id|ii_flags
)paren
suffix:semicolon
)brace
)brace
id|verbose
op_assign
l_int|1
suffix:semicolon
)brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;n Device - Target Map [Interrupts: %s Node%s]&bslash;n&bslash;n&quot;
comma
(paren
id|verbose
ques
c_cond
l_string|&quot;All&quot;
suffix:colon
l_string|&quot;Non-hardwired&quot;
)paren
comma
(paren
id|cnodeid
op_eq
id|CNODEID_NONE
)paren
ques
c_cond
l_string|&quot;s: All&quot;
suffix:colon
id|node_name
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Device&bslash;tCpu&bslash;tCnode&bslash;tIntr_bit&bslash;tIntr_name&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intr_dev_targ_map_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|print_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
(brace
r_if
c_cond
(paren
id|cnodeid
op_eq
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|cnodeid
)paren
id|print_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|print_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|dev
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
(brace
r_if
c_cond
(paren
id|cnodeid
op_eq
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|cnodeid
)paren
id|print_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|print_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|print_flag
)paren
(brace
id|size
op_increment
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;%d&bslash;t%d&bslash;t%d&bslash;t%d&bslash;t%s&bslash;n&quot;
comma
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|dev
comma
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|cpuid
comma
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|cnodeid
comma
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|bit
comma
id|intr_dev_targ_map
(braket
id|i
)braket
dot
id|intr_name
)paren
suffix:semicolon
)brace
)brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;nTotal : %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n; * The spinlocks have already been initialized.  Now initialize the interrupt&n; * vectors.  One processor on each hub does the work.&n; */
r_void
DECL|function|intr_init_vecblk
id|intr_init_vecblk
c_func
(paren
id|nodepda_t
op_star
id|npda
comma
id|cnodeid_t
id|node
comma
r_int
id|sn
)paren
(brace
r_int
id|i
comma
id|ip
op_assign
l_int|0
suffix:semicolon
id|intr_vecblk_t
op_star
id|vecblk
suffix:semicolon
id|subnode_pda_t
op_star
id|snpda
suffix:semicolon
id|snpda
op_assign
id|SNPDA
c_func
(paren
id|npda
comma
id|sn
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|vecblk
op_assign
op_amp
id|snpda-&gt;intr_dispatch0
suffix:semicolon
)brace
r_else
(brace
id|vecblk
op_assign
op_amp
id|snpda-&gt;intr_dispatch1
suffix:semicolon
)brace
multiline_comment|/* Initialize this vector. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND_BITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|vecblk-&gt;vectors
(braket
id|i
)braket
dot
id|iv_func
op_assign
id|intr_stray
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|i
)braket
dot
id|iv_prefunc
op_assign
l_int|NULL
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|i
)braket
dot
id|iv_arg
op_assign
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|ip
op_star
id|N_INTPEND_BITS
op_plus
id|i
)paren
suffix:semicolon
id|vecblk-&gt;info
(braket
id|i
)braket
dot
id|ii_owner_dev
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|vecblk-&gt;info
(braket
id|i
)braket
dot
id|ii_name
comma
l_string|&quot;Unused&quot;
)paren
suffix:semicolon
id|vecblk-&gt;info
(braket
id|i
)braket
dot
id|ii_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No flags */
id|vecblk-&gt;vectors
(braket
id|i
)braket
dot
id|iv_mustruncpu
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No CPU yet. */
)brace
id|mutex_spinlock_init
c_func
(paren
op_amp
id|vecblk-&gt;vector_lock
)paren
suffix:semicolon
id|vecblk-&gt;vector_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPUS_PER_SUBNODE
suffix:semicolon
id|i
op_increment
)paren
id|vecblk-&gt;cpu_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|vecblk-&gt;vector_state
op_assign
id|VECTOR_UNINITED
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|ip
OL
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * do_intr_reserve_level(cpuid_t cpu, int bit, int resflags, int reserve, &n; *&t;&t;&t;&t;&t;devfs_handle_t owner_dev, char *name)&n; *&t;Internal work routine to reserve or unreserve an interrupt level.&n; *&t;&t;cpu is the CPU to which the interrupt will be sent.&n; *&t;&t;bit is the level bit to reserve.  -1 means any level&n; *&t;&t;resflags should include II_ERRORINT if this is an&n; *&t;&t;&t;error interrupt, II_THREADED if the interrupt handler&n; *&t;&t;&t;will be threaded, or 0 otherwise.&n; *&t;&t;reserve should be set to II_RESERVE or II_UNRESERVE&n; *&t;&t;&t;to get or clear a reservation.&n; *&t;&t;owner_dev is the device that &quot;owns&quot; this interrupt, if supplied&n; *&t;&t;name is a human-readable name for this interrupt, if supplied&n; *&t;intr_reserve_level returns the bit reserved or -1 to indicate an error&n; */
r_static
r_int
DECL|function|do_intr_reserve_level
id|do_intr_reserve_level
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
id|resflags
comma
r_int
id|reserve
comma
id|devfs_handle_t
id|owner_dev
comma
r_char
op_star
id|name
)paren
(brace
id|intr_vecblk_t
op_star
id|vecblk
suffix:semicolon
id|hub_intmasks_t
op_star
id|hub_intmasks
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|ip
suffix:semicolon
id|synergy_da_t
op_star
id|sda
suffix:semicolon
r_int
id|which_synergy
suffix:semicolon
id|cnodeid_t
id|cnode
suffix:semicolon
id|ASSERT
c_func
(paren
id|bit
OL
id|N_INTPEND_BITS
op_star
l_int|2
)paren
suffix:semicolon
id|cnode
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|which_synergy
op_assign
id|cpuid_to_synergy
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|sda
op_assign
id|Synergy_da_indr
(braket
(paren
id|cnode
op_star
l_int|2
)paren
op_plus
id|which_synergy
)braket
suffix:semicolon
id|hub_intmasks
op_assign
op_amp
id|sda-&gt;s_intmasks
suffix:semicolon
singleline_comment|// hub_intmasks = &amp;pdaindr[cpu].pda-&gt;p_intmasks;
singleline_comment|// if (pdaindr[cpu].pda == NULL) return -1;
r_if
c_cond
(paren
(paren
id|bit
OL
id|N_INTPEND_BITS
)paren
op_logical_and
op_logical_neg
(paren
id|resflags
op_amp
id|II_ERRORINT
)paren
)paren
(brace
id|vecblk
op_assign
id|hub_intmasks-&gt;dispatch0
suffix:semicolon
id|ip
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
(paren
id|bit
op_ge
id|N_INTPEND_BITS
)paren
op_logical_or
(paren
id|bit
op_eq
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|bit
op_sub_assign
id|N_INTPEND_BITS
suffix:semicolon
multiline_comment|/* Get position relative to INT_PEND1 reg. */
id|vecblk
op_assign
id|hub_intmasks-&gt;dispatch1
suffix:semicolon
id|ip
op_assign
l_int|1
suffix:semicolon
)brace
id|INTR_LOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_le
op_minus
l_int|1
)paren
(brace
id|bit
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|reserve
op_eq
id|II_RESERVE
)paren
suffix:semicolon
multiline_comment|/* Choose any available level */
r_for
c_loop
(paren
suffix:semicolon
id|bit
OL
id|N_INTPEND_BITS
suffix:semicolon
id|bit
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
id|II_RESERVE
)paren
)paren
(brace
id|rv
op_assign
id|bit
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Return -1 if all interrupt levels int this register are taken. */
r_if
c_cond
(paren
id|bit
op_eq
id|N_INTPEND_BITS
)paren
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Reserve a particular level if it&squot;s available. */
r_if
c_cond
(paren
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
id|II_RESERVE
)paren
op_eq
id|reserve
)paren
(brace
multiline_comment|/* Can&squot;t (un)reserve a level that&squot;s already (un)reserved. */
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|rv
op_assign
id|bit
suffix:semicolon
)brace
)brace
multiline_comment|/* Reserve the level and bump the count. */
r_if
c_cond
(paren
id|rv
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|reserve
)paren
(brace
r_int
id|maxlen
op_assign
r_sizeof
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_name
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_or_assign
(paren
id|II_RESERVE
op_or
id|resflags
)paren
suffix:semicolon
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_owner_dev
op_assign
id|owner_dev
suffix:semicolon
multiline_comment|/* Copy in the name. */
id|namelen
op_assign
id|name
ques
c_cond
id|strlen
c_func
(paren
id|name
)paren
suffix:colon
l_int|0
suffix:semicolon
id|strncpy
c_func
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_name
comma
id|name
comma
id|MIN
c_func
(paren
id|namelen
comma
id|maxlen
)paren
)paren
suffix:semicolon
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_name
(braket
id|maxlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|vecblk-&gt;vector_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear all the flags */
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_owner_dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the name. */
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|vecblk-&gt;vector_count
op_decrement
suffix:semicolon
)brace
)brace
id|INTR_UNLOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
macro_line|#if defined(DEBUG)
r_if
c_cond
(paren
id|rv
op_ge
l_int|0
)paren
(brace
r_int
id|namelen
op_assign
id|name
ques
c_cond
id|strlen
c_func
(paren
id|name
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Gather this device - target cpu mapping information&n;&t;     * in a table which can be used later by the idbg &quot;intrmap&quot;&n;&t;     * command&n;&t;     */
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|intr_dev_targ_map_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_dev_targ_map_size
OL
id|MAX_DEVICES
)paren
(brace
id|intr_dev_targ_map_t
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|intr_dev_targ_map
(braket
id|intr_dev_targ_map_size
)braket
suffix:semicolon
id|p-&gt;dev
op_assign
id|owner_dev
suffix:semicolon
id|p-&gt;cpuid
op_assign
id|cpu
suffix:semicolon
id|p-&gt;cnodeid
op_assign
id|cputocnode
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|p-&gt;bit
op_assign
id|ip
op_star
id|N_INTPEND_BITS
op_plus
id|rv
suffix:semicolon
id|strncpy
c_func
(paren
id|p-&gt;intr_name
comma
id|name
comma
id|MIN
c_func
(paren
id|MAX_NAME
comma
id|namelen
)paren
)paren
suffix:semicolon
id|intr_dev_targ_map_size
op_increment
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|intr_dev_targ_map_lock
comma
id|s
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
r_return
(paren
(paren
(paren
id|rv
op_eq
op_minus
l_int|1
)paren
ques
c_cond
id|rv
suffix:colon
(paren
id|ip
op_star
id|N_INTPEND_BITS
)paren
op_plus
id|rv
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * WARNING:  This routine should only be called from within ml/SN.&n; *&t;Reserve an interrupt level.&n; */
r_int
DECL|function|intr_reserve_level
id|intr_reserve_level
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
id|resflags
comma
id|devfs_handle_t
id|owner_dev
comma
r_char
op_star
id|name
)paren
(brace
r_return
id|do_intr_reserve_level
c_func
(paren
id|cpu
comma
id|bit
comma
id|resflags
comma
id|II_RESERVE
comma
id|owner_dev
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * WARNING:  This routine should only be called from within ml/SN.&n; *&t;Unreserve an interrupt level.&n; */
r_void
DECL|function|intr_unreserve_level
id|intr_unreserve_level
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
)paren
(brace
(paren
r_void
)paren
id|do_intr_reserve_level
c_func
(paren
id|cpu
comma
id|bit
comma
l_int|0
comma
id|II_UNRESERVE
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get values that vary depending on which CPU and bit we&squot;re operating on&n; */
r_static
id|hub_intmasks_t
op_star
DECL|function|intr_get_ptrs
id|intr_get_ptrs
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
op_star
id|new_bit
comma
multiline_comment|/* Bit relative to the register */
id|hubreg_t
op_star
op_star
id|intpend_masks
comma
multiline_comment|/* Masks for this register */
id|intr_vecblk_t
op_star
op_star
id|vecblk
comma
multiline_comment|/* Vecblock for this interrupt */
r_int
op_star
id|ip
)paren
multiline_comment|/* Which intpend register */
(brace
id|hub_intmasks_t
op_star
id|hub_intmasks
suffix:semicolon
id|synergy_da_t
op_star
id|sda
suffix:semicolon
r_int
id|which_synergy
suffix:semicolon
id|cnodeid_t
id|cnode
suffix:semicolon
id|ASSERT
c_func
(paren
id|bit
OL
id|N_INTPEND_BITS
op_star
l_int|2
)paren
suffix:semicolon
id|cnode
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|which_synergy
op_assign
id|cpuid_to_synergy
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|sda
op_assign
id|Synergy_da_indr
(braket
(paren
id|cnode
op_star
l_int|2
)paren
op_plus
id|which_synergy
)braket
suffix:semicolon
id|hub_intmasks
op_assign
op_amp
id|sda-&gt;s_intmasks
suffix:semicolon
singleline_comment|// hub_intmasks = &amp;pdaindr[cpu].pda-&gt;p_intmasks;
r_if
c_cond
(paren
id|bit
OL
id|N_INTPEND_BITS
)paren
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend0_masks
suffix:semicolon
op_star
id|vecblk
op_assign
id|hub_intmasks-&gt;dispatch0
suffix:semicolon
op_star
id|ip
op_assign
l_int|0
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
suffix:semicolon
)brace
r_else
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend1_masks
suffix:semicolon
op_star
id|vecblk
op_assign
id|hub_intmasks-&gt;dispatch1
suffix:semicolon
op_star
id|ip
op_assign
l_int|1
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
op_minus
id|N_INTPEND_BITS
suffix:semicolon
)brace
r_return
id|hub_intmasks
suffix:semicolon
)brace
multiline_comment|/*&n; * intr_connect_level(cpuid_t cpu, int bit, ilvl_t intr_swlevel, &n; *&t;&t;intr_func_t intr_func, void *intr_arg);&n; *&t;This is the lowest-level interface to the interrupt code.  It shouldn&squot;t&n; *&t;be called from outside the ml/SN directory.&n; *&t;intr_connect_level hooks up an interrupt to a particular bit in&n; *&t;the INT_PEND0/1 masks.  Returns 0 on success.&n; *&t;&t;cpu is the CPU to which the interrupt will be sent.&n; *&t;&t;bit is the level bit to connect to&n; *&t;&t;intr_swlevel tells which software level to use&n; *&t;&t;intr_func is the interrupt handler&n; *&t;&t;intr_arg is an arbitrary argument interpreted by the handler&n; *&t;&t;intr_prefunc is a prologue function, to be called&n; *&t;&t;&t;with interrupts disabled, to disable&n; *&t;&t;&t;the interrupt at source.  It is called&n; *&t;&t;&t;with the same argument.  Should be NULL for&n; *&t;&t;&t;typical interrupts, which can be masked&n; *&t;&t;&t;by the infrastructure at the level bit.&n; *&t;intr_connect_level returns 0 on success or nonzero on an error&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|intr_connect_level
id|intr_connect_level
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
id|ilvl_t
id|intr_swlevel
comma
id|intr_func_t
id|intr_func
comma
r_void
op_star
id|intr_arg
comma
id|intr_func_t
id|intr_prefunc
)paren
(brace
id|intr_vecblk_t
op_star
id|vecblk
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|ip
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|ASSERT
c_func
(paren
id|bit
OL
id|N_INTPEND_BITS
op_star
l_int|2
)paren
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|vecblk
comma
op_amp
id|ip
)paren
suffix:semicolon
id|INTR_LOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
id|II_INUSE
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
id|II_RESERVE
)paren
)paren
)paren
(brace
multiline_comment|/* Can&squot;t assign to a level that&squot;s in use or isn&squot;t reserved. */
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Stuff parameters into vector and info */
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_func
op_assign
id|intr_func
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_prefunc
op_assign
id|intr_prefunc
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_arg
op_assign
id|intr_arg
suffix:semicolon
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_or_assign
id|II_INUSE
suffix:semicolon
)brace
multiline_comment|/* Now stuff the masks if everything&squot;s okay. */
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
r_int
id|lslice
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
singleline_comment|// nasid_t nasid = COMPACT_TO_NASID_NODEID(cputocnode(cpu));
id|nasid_t
id|nasid
op_assign
id|cpuid_to_nasid
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_int
id|subnode
op_assign
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Make sure it&squot;s not already pending when we connect it. */
id|REMOTE_HUB_PI_CLR_INTR
c_func
(paren
id|nasid
comma
id|subnode
comma
id|bit
op_plus
id|ip
op_star
id|N_INTPEND_BITS
)paren
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_or_assign
(paren
l_int|1ULL
op_lshift
(paren
r_uint64
)paren
id|bit
)paren
suffix:semicolon
id|lslice
op_assign
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|vecblk-&gt;cpu_count
(braket
id|lslice
)braket
op_increment
suffix:semicolon
macro_line|#if SN1
multiline_comment|/*&n;&t; * On SN1, there are 8 interrupt mask registers per node:&n;&t; * &t;PI_0 MASK_0 A&n;&t; * &t;PI_0 MASK_1 A&n;&t; * &t;PI_0 MASK_0 B&n;&t; * &t;PI_0 MASK_1 B&n;&t; * &t;PI_1 MASK_0 A&n;&t; * &t;PI_1 MASK_1 A&n;&t; * &t;PI_1 MASK_0 B&n;&t; * &t;PI_1 MASK_1 B&n;&t; */
macro_line|#endif
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|nasid
comma
id|subnode
comma
id|PI_INT_MASK0_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|lslice
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|nasid
comma
id|subnode
comma
id|PI_INT_MASK1_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|lslice
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|INTR_UNLOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * intr_disconnect_level(cpuid_t cpu, int bit)&n; *&n; *&t;This is the lowest-level interface to the interrupt code.  It should&n; *&t;not be called from outside the ml/SN directory.&n; *&t;intr_disconnect_level removes a particular bit from an interrupt in&n; * &t;the INT_PEND0/1 masks.  Returns 0 on success or nonzero on failure.&n; */
r_int
DECL|function|intr_disconnect_level
id|intr_disconnect_level
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
)paren
(brace
id|intr_vecblk_t
op_star
id|vecblk
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|ip
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|vecblk
comma
op_amp
id|ip
)paren
suffix:semicolon
id|INTR_LOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
(paren
id|II_RESERVE
op_or
id|II_INUSE
)paren
)paren
op_ne
(paren
(paren
id|II_RESERVE
op_or
id|II_INUSE
)paren
)paren
)paren
(brace
multiline_comment|/* Can&squot;t remove a level that&squot;s not in use or isn&squot;t reserved. */
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Stuff parameters into vector and info */
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_func
op_assign
(paren
id|intr_func_t
)paren
l_int|NULL
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_prefunc
op_assign
(paren
id|intr_func_t
)paren
l_int|NULL
suffix:semicolon
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_arg
op_assign
l_int|0
suffix:semicolon
id|vecblk-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_and_assign
op_complement
id|II_INUSE
suffix:semicolon
macro_line|#ifdef BASE_ITHRTEAD
id|vecblk-&gt;vectors
(braket
id|bit
)braket
dot
id|iv_mustruncpu
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No mustrun CPU any more. */
macro_line|#endif
)brace
multiline_comment|/* Now clear the masks if everything&squot;s okay. */
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
r_int
id|lslice
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
l_int|1ULL
op_lshift
(paren
r_uint64
)paren
id|bit
)paren
suffix:semicolon
id|lslice
op_assign
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|vecblk-&gt;cpu_count
(braket
id|lslice
)braket
op_decrement
suffix:semicolon
id|mask_reg
op_assign
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
comma
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
comma
id|ip
op_eq
l_int|0
ques
c_cond
id|PI_INT_MASK0_A
suffix:colon
id|PI_INT_MASK1_A
)paren
suffix:semicolon
id|mask_reg
op_assign
(paren
r_volatile
id|hubreg_t
op_star
)paren
(paren
(paren
id|__psunsigned_t
)paren
id|mask_reg
op_plus
(paren
id|PI_INT_MASK_OFFSET
op_star
id|lslice
)paren
)paren
suffix:semicolon
op_star
id|mask_reg
op_assign
id|intpend_masks
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|INTR_UNLOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * Actually block or unblock an interrupt&n; */
r_void
DECL|function|do_intr_block_bit
id|do_intr_block_bit
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
id|block
)paren
(brace
id|intr_vecblk_t
op_star
id|vecblk
suffix:semicolon
r_int
id|ip
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
r_volatile
id|hubreg_t
id|mask_value
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|vecblk
comma
op_amp
id|ip
)paren
suffix:semicolon
id|INTR_LOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
)paren
multiline_comment|/* Block */
id|intpend_masks
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
l_int|1ULL
op_lshift
(paren
r_uint64
)paren
id|bit
)paren
suffix:semicolon
r_else
multiline_comment|/* Unblock */
id|intpend_masks
(braket
l_int|0
)braket
op_or_assign
(paren
l_int|1ULL
op_lshift
(paren
r_uint64
)paren
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
comma
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
comma
id|PI_INT_MASK0_A
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
comma
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
comma
id|PI_INT_MASK1_A
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for it to take effect.  (One read should suffice.)&n;&t; * This is only necessary when blocking an interrupt&n;&t; */
r_if
c_cond
(paren
id|block
)paren
r_while
c_loop
(paren
(paren
id|mask_value
op_assign
id|HUB_L
c_func
(paren
id|mask_reg
)paren
)paren
op_ne
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|INTR_UNLOCK
c_func
(paren
id|vecblk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Block a particular interrupt (cpu/bit pair).&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|intr_block_bit
id|intr_block_bit
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
)paren
(brace
id|do_intr_block_bit
c_func
(paren
id|cpu
comma
id|bit
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unblock a particular interrupt (cpu/bit pair).&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|intr_unblock_bit
id|intr_unblock_bit
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
)paren
(brace
id|do_intr_block_bit
c_func
(paren
id|cpu
comma
id|bit
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* verifies that the specified CPUID is on the specified SUBNODE (if any) */
DECL|macro|cpu_on_subnode
mdefine_line|#define cpu_on_subnode(cpuid, which_subnode) &bslash;&n;&t;   (((which_subnode) == SUBNODE_ANY) || (cpuid_to_subnode(cpuid) == (which_subnode)))
multiline_comment|/*&n; * Choose one of the CPUs on a specified node or subnode to receive&n; * interrupts. Don&squot;t pick a cpu which has been specified as a NOINTR cpu.&n; *&n; * Among all acceptable CPUs, the CPU that has the fewest total number&n; * of interrupts targetted towards it is chosen.  Note that we never&n; * consider how frequent each of these interrupts might occur, so a rare&n; * hardware error interrupt is weighted equally with a disk interrupt.&n; */
r_static
id|cpuid_t
DECL|function|do_intr_cpu_choose
id|do_intr_cpu_choose
c_func
(paren
id|cnodeid_t
id|cnode
comma
r_int
id|which_subnode
)paren
(brace
id|cpuid_t
id|cpu
comma
id|best_cpu
op_assign
id|CPU_NONE
suffix:semicolon
r_int
id|slice
comma
id|min_count
op_assign
l_int|1000
suffix:semicolon
id|min_count
op_assign
l_int|1000
suffix:semicolon
r_for
c_loop
(paren
id|slice
op_assign
l_int|0
suffix:semicolon
id|slice
OL
id|CPUS_PER_NODE
suffix:semicolon
id|slice
op_increment
)paren
(brace
id|intr_vecblk_t
op_star
id|vecblk0
comma
op_star
id|vecblk1
suffix:semicolon
r_int
id|total_intrs_to_slice
suffix:semicolon
id|subnode_pda_t
op_star
id|snpda
suffix:semicolon
r_int
id|local_cpu_num
suffix:semicolon
id|cpu
op_assign
id|cnode_slice_to_cpuid
c_func
(paren
id|cnode
comma
id|slice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|CPU_NONE
)paren
r_continue
suffix:semicolon
multiline_comment|/* If this cpu isn&squot;t enabled for interrupts, skip it */
r_if
c_cond
(paren
op_logical_neg
id|cpu_enabled
c_func
(paren
id|cpu
)paren
op_logical_or
op_logical_neg
id|cpu_allows_intr
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* If this isn&squot;t the right subnode, skip it */
r_if
c_cond
(paren
op_logical_neg
id|cpu_on_subnode
c_func
(paren
id|cpu
comma
id|which_subnode
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* OK, this one&squot;s a potential CPU for interrupts */
id|snpda
op_assign
id|SUBNODEPDA
c_func
(paren
id|cnode
comma
id|SUBNODE
c_func
(paren
id|slice
)paren
)paren
suffix:semicolon
id|vecblk0
op_assign
op_amp
id|snpda-&gt;intr_dispatch0
suffix:semicolon
id|vecblk1
op_assign
op_amp
id|snpda-&gt;intr_dispatch1
suffix:semicolon
id|local_cpu_num
op_assign
id|LOCALCPU
c_func
(paren
id|slice
)paren
suffix:semicolon
id|total_intrs_to_slice
op_assign
id|vecblk0-&gt;cpu_count
(braket
id|local_cpu_num
)braket
op_plus
id|vecblk1-&gt;cpu_count
(braket
id|local_cpu_num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|min_count
OG
id|total_intrs_to_slice
)paren
(brace
id|min_count
op_assign
id|total_intrs_to_slice
suffix:semicolon
id|best_cpu
op_assign
id|cpu
suffix:semicolon
)brace
)brace
r_return
id|best_cpu
suffix:semicolon
)brace
multiline_comment|/*&n; * Choose an appropriate interrupt target CPU on a specified node.&n; * If which_subnode is SUBNODE_ANY, then subnode is not considered.&n; * Otherwise, the chosen CPU must be on the specified subnode.&n; */
r_static
id|cpuid_t
DECL|function|intr_cpu_choose_from_node
id|intr_cpu_choose_from_node
c_func
(paren
id|cnodeid_t
id|cnode
comma
r_int
id|which_subnode
)paren
(brace
r_return
id|do_intr_cpu_choose
c_func
(paren
id|cnode
comma
id|which_subnode
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;LATER
multiline_comment|/*&n; * Convert a subnode vertex into a (cnodeid, which_subnode) pair.&n; * Return 0 on success, non-zero on failure.&n; */
r_static
r_int
DECL|function|subnodevertex_to_subnode
id|subnodevertex_to_subnode
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|cnodeid_t
op_star
id|cnodeidp
comma
r_int
op_star
id|which_subnodep
)paren
(brace
id|arbitrary_info_t
id|which_subnode
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
multiline_comment|/* Try to grab subnode information */
r_if
c_cond
(paren
id|hwgraph_info_get_LBL
c_func
(paren
id|vhdl
comma
id|INFO_LBL_CPUBUS
comma
op_amp
id|which_subnode
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* On which node? */
id|cnodeid
op_assign
id|master_node_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnodeid
op_eq
id|CNODEID_NONE
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_star
id|which_subnodep
op_assign
(paren
r_int
)paren
id|which_subnode
suffix:semicolon
op_star
id|cnodeidp
op_assign
id|cnodeid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
macro_line|#endif /* LATER */
multiline_comment|/* Make it easy to identify subnode vertices in the hwgraph */
r_void
DECL|function|mark_subnodevertex_as_subnode
id|mark_subnodevertex_as_subnode
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|which_subnode
)paren
(brace
id|graph_error_t
id|rv
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
op_le
id|which_subnode
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|which_subnode
OL
id|NUM_SUBNODES
)paren
suffix:semicolon
id|rv
op_assign
id|hwgraph_info_add_LBL
c_func
(paren
id|vhdl
comma
id|INFO_LBL_CPUBUS
comma
(paren
id|arbitrary_info_t
)paren
id|which_subnode
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rv
op_assign
id|hwgraph_info_export_LBL
c_func
(paren
id|vhdl
comma
id|INFO_LBL_CPUBUS
comma
r_sizeof
(paren
id|arbitrary_info_t
)paren
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a device descriptor, extract interrupt target information and&n; * choose an appropriate CPU.  Return CPU_NONE if we can&squot;t make sense&n; * out of the target information.&n; * TBD: Should this be considered platform-independent code?&n; */
macro_line|#ifdef&t;LATER
r_static
id|cpuid_t
DECL|function|intr_target_from_desc
id|intr_target_from_desc
c_func
(paren
id|device_desc_t
id|dev_desc
comma
r_int
id|favor_subnode
)paren
(brace
id|cpuid_t
id|cpuid
op_assign
id|CPU_NONE
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
r_int
id|which_subnode
suffix:semicolon
id|devfs_handle_t
id|intr_target_dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|intr_target_dev
op_assign
id|device_desc_intr_target_get
c_func
(paren
id|dev_desc
)paren
)paren
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
multiline_comment|/* &n;&t;&t; * A valid device was specified.  If it&squot;s a particular&n;&t;&t; * CPU, then use that CPU as target.  &n;&t;&t; */
id|cpuid
op_assign
id|cpuvertex_to_cpuid
c_func
(paren
id|intr_target_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
r_goto
id|cpuchosen
suffix:semicolon
multiline_comment|/* If a subnode vertex was specified, pick a CPU on that subnode. */
r_if
c_cond
(paren
id|subnodevertex_to_subnode
c_func
(paren
id|intr_target_dev
comma
op_amp
id|cnodeid
comma
op_amp
id|which_subnode
)paren
op_eq
l_int|0
)paren
(brace
id|cpuid
op_assign
id|intr_cpu_choose_from_node
c_func
(paren
id|cnodeid
comma
id|which_subnode
)paren
suffix:semicolon
r_goto
id|cpuchosen
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Otherwise, pick a CPU on the node that owns the &n;&t;&t; * specified target.  Favor &quot;favor_subnode&quot;, if specified.&n;&t;&t; */
id|cnodeid
op_assign
id|master_node_get
c_func
(paren
id|intr_target_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
(brace
id|cpuid
op_assign
id|intr_cpu_choose_from_node
c_func
(paren
id|cnodeid
comma
id|favor_subnode
)paren
suffix:semicolon
r_goto
id|cpuchosen
suffix:semicolon
)brace
)brace
id|cpuchosen
suffix:colon
r_return
id|cpuid
suffix:semicolon
)brace
macro_line|#endif&t;/* LATER */
macro_line|#ifdef&t;LATER
multiline_comment|/*&n; * Check if we had already visited this candidate cnode&n; */
r_static
r_void
op_star
DECL|function|intr_cnode_seen
id|intr_cnode_seen
c_func
(paren
id|cnodeid_t
id|candidate
comma
r_void
op_star
id|arg1
comma
r_void
op_star
id|arg2
)paren
(brace
r_int
id|i
suffix:semicolon
id|cnodeid_t
op_star
id|visited_cnodes
op_assign
(paren
id|cnodeid_t
op_star
)paren
id|arg1
suffix:semicolon
r_int
op_star
id|num_visited_cnodes
op_assign
(paren
r_int
op_star
)paren
id|arg2
suffix:semicolon
id|ASSERT
c_func
(paren
id|visited_cnodes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|num_visited_cnodes
op_le
id|numnodes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|num_visited_cnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|candidate
op_eq
id|visited_cnodes
(braket
id|i
)braket
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|visited_cnodes
suffix:semicolon
)brace
macro_line|#endif /* LATER */
multiline_comment|/*&n; * intr_bit_reserve_test(cpuid,which_subnode,cnode,req_bit,intr_resflags,&n; *&t;&t;owner_dev,intr_name,*resp_bit)&n; *&t;Either cpuid is not CPU_NONE or cnodeid not CNODE_NONE but&n; * &t;not both.&n; * 1. &t;If cpuid is specified, this routine tests if this cpu can be a valid&n; * &t;interrupt target candidate.&n; * 2. &t;If cnodeid is specified, this routine tests if there is a cpu on &n; *&t;this node which can be a valid interrupt target candidate.&n; * 3.&t;If a valid interrupt target cpu candidate is found then an attempt at &n; * &t;reserving an interrupt bit on the corresponding cnode is made.&n; *&n; * If steps 1 &amp; 2 both fail or step 3 fails then we are not able to get a valid&n; * interrupt target cpu then routine returns CPU_NONE (failure)&n; * Otherwise routine returns cpuid of interrupt target (success)&n; */
r_static
id|cpuid_t
DECL|function|intr_bit_reserve_test
id|intr_bit_reserve_test
c_func
(paren
id|cpuid_t
id|cpuid
comma
r_int
id|favor_subnode
comma
id|cnodeid_t
id|cnodeid
comma
r_int
id|req_bit
comma
r_int
id|intr_resflags
comma
id|devfs_handle_t
id|owner_dev
comma
r_char
op_star
id|intr_name
comma
r_int
op_star
id|resp_bit
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|cpuid
op_eq
id|CPU_NONE
)paren
op_logical_or
(paren
id|cnodeid
op_eq
id|CNODEID_NONE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
(brace
multiline_comment|/* Try to choose a interrupt cpu candidate */
id|cpuid
op_assign
id|intr_cpu_choose_from_node
c_func
(paren
id|cnodeid
comma
id|favor_subnode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
multiline_comment|/* Try to reserve an interrupt bit on the hub &n;&t;&t; * corresponding to the canidate cnode. If we&n;&t;&t; * are successful then we got a cpu which can&n;&t;&t; * act as an interrupt target for the io device.&n;&t;&t; * Otherwise we need to continue the search&n;&t;&t; * further.&n;&t;&t; */
op_star
id|resp_bit
op_assign
id|do_intr_reserve_level
c_func
(paren
id|cpuid
comma
id|req_bit
comma
id|intr_resflags
comma
id|II_RESERVE
comma
id|owner_dev
comma
id|intr_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|resp_bit
op_ge
l_int|0
)paren
multiline_comment|/* The interrupt target  specified was fine */
r_return
id|cpuid
suffix:semicolon
)brace
r_return
id|CPU_NONE
suffix:semicolon
)brace
multiline_comment|/*&n; * intr_heuristic(dev_t dev,device_desc_t dev_desc,&n; *&t;&t;  int req_bit,int intr_resflags,dev_t owner_dev,&n; *&t;&t;  char *intr_name,int *resp_bit)&n; *&n; * Choose an interrupt destination for an interrupt.&n; *&t;dev is the device for which the interrupt is being set up&n; *&t;dev_desc is a description of hardware and policy that could&n; *&t;&t;help determine where this interrupt should go&n; *&t;req_bit is the interrupt bit requested &n; *&t;&t;(can be INTRCONNECT_ANY_BIT in which the first available&n; * &t;&t; interrupt bit is used)&n; *&t;intr_resflags indicates whether we want to (un)reserve bit&n; *&t;owner_dev is the owner device&n; *&t;intr_name is the readable interrupt name&t;&n; * &t;resp_bit indicates whether we succeeded in getting the required&n; *&t;&t; action  { (un)reservation} done&t;&n; *&t;&t; negative value indicates failure&n; *&n; */
multiline_comment|/* ARGSUSED */
id|cpuid_t
DECL|function|intr_heuristic
id|intr_heuristic
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
r_int
id|req_bit
comma
r_int
id|intr_resflags
comma
id|devfs_handle_t
id|owner_dev
comma
r_char
op_star
id|intr_name
comma
r_int
op_star
id|resp_bit
)paren
(brace
id|cpuid_t
id|cpuid
suffix:semicolon
multiline_comment|/* possible intr targ*/
id|cnodeid_t
id|candidate
suffix:semicolon
multiline_comment|/* possible canidate */
macro_line|#ifdef LATER
id|cnodeid_t
id|visited_cnodes
(braket
id|MAX_NASIDS
)braket
comma
multiline_comment|/* nodes seen so far */
id|center
comma
multiline_comment|/* node we are on */
id|candidate
suffix:semicolon
multiline_comment|/* possible canidate */
r_int
id|num_visited_cnodes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # nodes seen */
r_int
id|radius
op_assign
l_int|1
comma
multiline_comment|/* start looking at the&n;&t;&t;&t;&t;&t;&t;&t; * current node&n;&t;&t;&t;&t;&t;&t;&t; */
id|maxradius
op_assign
id|physmem_maxradius
c_func
(paren
)paren
suffix:semicolon
r_void
op_star
id|rv
suffix:semicolon
macro_line|#endif /* LATER */
r_int
id|which_subnode
op_assign
id|SUBNODE_ANY
suffix:semicolon
multiline_comment|/* SN1 + pcibr Addressing Limitation */
(brace
id|devfs_handle_t
id|pconn_vhdl
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
multiline_comment|/*&n;&t; * This combination of SN1 and Bridge hardware has an odd &quot;limitation&quot;.&n;&t; * Due to the choice of addresses for PI0 and PI1 registers on SN1&n;&t; * and historical limitations in Bridge, Bridge is unable to&n;&t; * send interrupts to both PI0 CPUs and PI1 CPUs -- we have&n;&t; * to choose one set or the other.  That choice is implicitly&n;&t; * made when Bridge first attaches its error interrupt.  After&n;&t; * that point, all subsequent interrupts are restricted to the&n;&t; * same PI number (though it&squot;s possible to send interrupts to&n;&t; * the same PI number on a different node).&n;&t; *&n;&t; * Since neither SN1 nor Bridge designers are willing to admit a&n;&t; * bug, we can&squot;t really call this a &quot;workaround&quot;.  It&squot;s a permanent&n;&t; * solution for an SN1-specific and Bridge-specific hardware&n;&t; * limitation that won&squot;t ever be lifted.&n;&t; */
r_if
c_cond
(paren
(paren
id|hwgraph_edge_get
c_func
(paren
id|dev
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pconn_vhdl
)paren
op_eq
id|GRAPH_SUCCESS
)paren
op_logical_and
(paren
(paren
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pconn_vhdl
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We &quot;know&quot; that the error interrupt is the first&n;&t;&t; * interrupt set up by pcibr_attach.  Send all interrupts&n;&t;&t; * on this bridge to the same subnode number.&n;&t;&t; */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
(brace
id|which_subnode
op_assign
id|cpuid_to_subnode
c_func
(paren
(paren
(paren
id|hub_intr_t
)paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
op_member_access_from_pointer
id|i_cpuid
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef&t;LATER
multiline_comment|/* &n;&t; * If an interrupt target was specified for this&n;&t; * interrupt allocation, try to use it.&n;&t; */
r_if
c_cond
(paren
id|dev_desc
)paren
(brace
multiline_comment|/* Try to see if the interrupt target specified in the&n;&t;&t; * device descriptor is a legal candidate.&n;&t;&t; */
id|cpuid
op_assign
id|intr_bit_reserve_test
c_func
(paren
id|intr_target_from_desc
c_func
(paren
id|dev_desc
comma
id|which_subnode
)paren
comma
id|which_subnode
comma
id|CNODEID_NONE
comma
id|req_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
id|resp_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
r_if
c_cond
(paren
id|cpu_on_subnode
c_func
(paren
id|cpuid
comma
id|which_subnode
)paren
)paren
r_return
id|cpuid
suffix:semicolon
multiline_comment|/* got a valid interrupt target */
id|printk
c_func
(paren
l_string|&quot;Override explicit interrupt targetting: %v (0x%x)&bslash;n&quot;
comma
id|owner_dev
comma
id|owner_dev
)paren
suffix:semicolon
id|intr_unreserve_level
c_func
(paren
id|cpuid
comma
op_star
id|resp_bit
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through on to the next step in the search for&n;&t;&t; * the interrupt candidate.&n;&t;&t; */
)brace
macro_line|#endif  /* LATER */
multiline_comment|/* Check if we can find a valid interrupt target candidate on&n;&t; * the master node for the device.&n;&t; */
id|cpuid
op_assign
id|intr_bit_reserve_test
c_func
(paren
id|CPU_NONE
comma
id|which_subnode
comma
id|master_node_get
c_func
(paren
id|dev
)paren
comma
id|req_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
id|resp_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
r_if
c_cond
(paren
id|cpu_on_subnode
c_func
(paren
id|cpuid
comma
id|which_subnode
)paren
)paren
r_return
id|cpuid
suffix:semicolon
multiline_comment|/* got a valid interrupt target */
r_else
id|intr_unreserve_level
c_func
(paren
id|cpuid
comma
op_star
id|resp_bit
)paren
suffix:semicolon
)brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Cannot target interrupts to closest node(%d): %ld (0x%lx)&bslash;n&quot;
comma
id|master_node_get
c_func
(paren
id|dev
)paren
comma
(paren
r_int
)paren
id|owner_dev
comma
(paren
r_int
r_int
)paren
id|owner_dev
)paren
suffix:semicolon
multiline_comment|/* Fall through into the default algorithm&n;&t; * (exhaustive-search-for-the-nearest-possible-interrupt-target)&n;&t; * for finding the interrupt target&n;&t; */
macro_line|#ifndef BRINGUP
singleline_comment|// Use of this algorithm is deferred until the supporting
singleline_comment|// code has been implemented.
multiline_comment|/* &n;&t; * No valid interrupt specification exists.&n;&t; * Try to find a node which is closest to the current node&n;&t; * which can process interrupts from a device&n;&t; */
id|center
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|radius
op_le
id|maxradius
)paren
(brace
multiline_comment|/* Try to find a node at the given radius and which&n;&t;&t; * we haven&squot;t seen already.&n;&t;&t; */
id|rv
op_assign
id|physmem_select_neighbor_node
c_func
(paren
id|center
comma
id|radius
comma
op_amp
id|candidate
comma
id|intr_cnode_seen
comma
(paren
r_void
op_star
)paren
id|visited_cnodes
comma
(paren
r_void
op_star
)paren
op_amp
id|num_visited_cnodes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
multiline_comment|/* We have seen all the nodes at this particular radius&n;&t;&t;&t; * Go on to the next radius level.&n;&t;&t;&t; */
id|radius
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We are seeing this candidate  cnode for the first time&n;&t;&t; */
id|visited_cnodes
(braket
id|num_visited_cnodes
op_increment
)braket
op_assign
id|candidate
suffix:semicolon
id|cpuid
op_assign
id|intr_bit_reserve_test
c_func
(paren
id|CPU_NONE
comma
id|which_subnode
comma
id|candidate
comma
id|req_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
id|resp_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
r_if
c_cond
(paren
id|cpu_on_subnode
c_func
(paren
id|cpuid
comma
id|which_subnode
)paren
)paren
r_return
id|cpuid
suffix:semicolon
multiline_comment|/* got a valid interrupt target */
r_else
id|intr_unreserve_level
c_func
(paren
id|cpuid
comma
op_star
id|resp_bit
)paren
suffix:semicolon
)brace
)brace
macro_line|#else  /* BRINGUP */
(brace
singleline_comment|// Do a stupid round-robin assignment of the node.
r_static
id|cnodeid_t
id|last_node
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|last_node
op_ge
id|numnodes
)paren
id|last_node
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|candidate
op_assign
id|last_node
op_plus
l_int|1
suffix:semicolon
id|candidate
op_ne
id|last_node
suffix:semicolon
id|candidate
op_increment
)paren
(brace
r_if
c_cond
(paren
id|candidate
op_eq
id|numnodes
)paren
id|candidate
op_assign
l_int|0
suffix:semicolon
id|cpuid
op_assign
id|intr_bit_reserve_test
c_func
(paren
id|CPU_NONE
comma
id|which_subnode
comma
id|candidate
comma
id|req_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
id|resp_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
r_if
c_cond
(paren
id|cpu_on_subnode
c_func
(paren
id|cpuid
comma
id|which_subnode
)paren
)paren
(brace
id|last_node
op_assign
id|candidate
suffix:semicolon
r_return
id|cpuid
suffix:semicolon
multiline_comment|/* got a valid interrupt target */
)brace
r_else
id|intr_unreserve_level
c_func
(paren
id|cpuid
comma
op_star
id|resp_bit
)paren
suffix:semicolon
)brace
)brace
id|last_node
op_assign
id|candidate
suffix:semicolon
)brace
macro_line|#endif
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Cannot target interrupts to any close node: %ld (0x%lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|owner_dev
comma
(paren
r_int
r_int
)paren
id|owner_dev
)paren
suffix:semicolon
multiline_comment|/* In the worst case try to allocate interrupt bits on the&n;&t; * master processor&squot;s node. We may get here during error interrupt&n;&t; * allocation phase when the topology matrix is not yet setup&n;&t; * and hence cannot do an exhaustive search.&n;&t; */
id|ASSERT
c_func
(paren
id|cpu_allows_intr
c_func
(paren
id|master_procid
)paren
)paren
suffix:semicolon
id|cpuid
op_assign
id|intr_bit_reserve_test
c_func
(paren
id|master_procid
comma
id|which_subnode
comma
id|CNODEID_NONE
comma
id|req_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
id|resp_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
(brace
r_if
c_cond
(paren
id|cpu_on_subnode
c_func
(paren
id|cpuid
comma
id|which_subnode
)paren
)paren
r_return
id|cpuid
suffix:semicolon
r_else
id|intr_unreserve_level
c_func
(paren
id|cpuid
comma
op_star
id|resp_bit
)paren
suffix:semicolon
)brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Cannot target interrupts: %ld (0x%lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|owner_dev
comma
(paren
r_int
r_int
)paren
id|owner_dev
)paren
suffix:semicolon
r_return
id|CPU_NONE
suffix:semicolon
multiline_comment|/* Should never get here */
)brace
macro_line|#ifndef BRINGUP
multiline_comment|/*&n; * Should never receive an exception while running on the idle &n; * stack.  It IS possible to handle *interrupts* while on the&n; * idle stack, but a non-interrupt *exception* is a problem.&n; */
r_void
DECL|function|idle_err
id|idle_err
c_func
(paren
id|inst_t
op_star
id|epc
comma
id|uint
id|cause
comma
r_void
op_star
id|fep
comma
r_void
op_star
id|sp
)paren
(brace
id|eframe_t
op_star
id|ep
op_assign
(paren
id|eframe_t
op_star
)paren
id|fep
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cause
op_amp
id|CAUSE_EXCMASK
)paren
op_eq
id|EXC_IBE
op_logical_or
(paren
id|cause
op_amp
id|CAUSE_EXCMASK
)paren
op_eq
id|EXC_DBE
)paren
(brace
(paren
r_void
)paren
id|dobuserre
c_func
(paren
(paren
id|eframe_t
op_star
)paren
id|ep
comma
id|epc
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX - This will have to change to deal with various SN errors. */
id|panic
c_func
(paren
l_string|&quot;exception on IDLE stack &quot;
l_string|&quot;ep:0x%x epc:0x%x cause:0x%w32x sp:0x%x badvaddr:0x%x&quot;
comma
id|ep
comma
id|epc
comma
id|cause
comma
id|sp
comma
id|getbadvaddr
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/*&n; * earlynofault - handle very early global faults - usually just while&n; *      sizing memory&n; * Returns: 1 if should do nofault&n; *          0 if not&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|earlynofault
id|earlynofault
c_func
(paren
id|eframe_t
op_star
id|ep
comma
id|uint
id|code
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|EXC_DBE
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|cpuintr
id|cpuintr
c_func
(paren
r_void
op_star
id|arg1
comma
r_void
op_star
id|arg2
)paren
(brace
macro_line|#if RTE
r_static
r_int
id|rte_intrdebug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Frame Scheduler&n;&t; */
id|LOG_TSTAMP_EVENT
c_func
(paren
id|RTMON_INTR
comma
id|TSTAMP_EV_CPUINTR
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hardware clears the IO interrupts, but we need to clear software-&n;&t; * generated interrupts.&n;&t; */
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_ACTION_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* XXX - Handle error interrupts. */
r_if
c_cond
(paren
id|error_intr_reason
)paren
id|error_intr
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* 0 */
multiline_comment|/*&n;&t; * If we&squot;re headed for panicspin and it is due to a NMI, save the&n;&t; * eframe in the NMI area&n;&t; */
r_if
c_cond
(paren
r_private
dot
id|p_va_panicspin
op_logical_and
id|nmied
)paren
(brace
id|caddr_t
id|nmi_save_area
suffix:semicolon
id|nmi_save_area
op_assign
(paren
id|caddr_t
)paren
(paren
id|TO_UNCAC
c_func
(paren
id|TO_NODE
c_func
(paren
id|cputonasid
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
comma
id|IP27_NMI_EFRAME_OFFSET
)paren
)paren
op_plus
id|cputoslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
op_star
id|IP27_NMI_EFRAME_SIZE
)paren
suffix:semicolon
id|bcopy
c_func
(paren
(paren
id|caddr_t
)paren
id|arg2
comma
id|nmi_save_area
comma
r_sizeof
(paren
id|eframe_t
)paren
)paren
suffix:semicolon
)brace
id|doacvec
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RTE
r_if
c_cond
(paren
r_private
dot
id|p_flags
op_amp
id|PDAF_ISOLATED
op_logical_and
op_logical_neg
id|rte_intrdebug
)paren
r_goto
id|end_cpuintr
suffix:semicolon
macro_line|#endif
id|doactions
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RTE
id|end_cpuintr
suffix:colon
macro_line|#endif
id|LOG_TSTAMP_EVENT
c_func
(paren
id|RTMON_INTR
comma
id|TSTAMP_EV_INTREXIT
comma
id|TSTAMP_EV_CPUINTR
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|install_cpuintr
id|install_cpuintr
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
r_int
id|intr_bit
op_assign
id|CPU_ACTION_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|INTPEND0_MAXMASK
comma
(paren
id|intr_func_t
)paren
id|cpuintr
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_cpuintr: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP */
macro_line|#ifdef DEBUG_INTR_TSTAMP
multiline_comment|/* We allocate an array, but only use element number 64.  This guarantees that&n; * the entry is in a cacheline by itself.&n; */
DECL|macro|DINTR_CNTIDX
mdefine_line|#define DINTR_CNTIDX&t;32
DECL|macro|DINTR_TSTAMP1
mdefine_line|#define DINTR_TSTAMP1&t;48
DECL|macro|DINTR_TSTAMP2
mdefine_line|#define&t;DINTR_TSTAMP2&t;64
DECL|variable|dintr_tstamp_cnt
r_volatile
r_int
r_int
id|dintr_tstamp_cnt
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|dintr_debug_output
r_int
id|dintr_debug_output
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|idbg_tstamp_debug
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef SPLDEBUG
r_extern
r_void
id|idbg_splx_log
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_INTR_TSTAMP_DEBUG
DECL|variable|dintr_enter_symmon
r_int
id|dintr_enter_symmon
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 1000 microseconds is 1 millisecond */
macro_line|#endif
macro_line|#ifndef BRINGUP
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|cpulatintr
id|cpulatintr
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
multiline_comment|/*&n;&t; * Hardware only clears IO interrupts so we have to clear our level&n;&t; * here.&n;&t; */
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|CPU_INTRLAT_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG_INTR_TSTAMP_DEBUG
id|dintr_tstamp_cnt
(braket
id|DINTR_TSTAMP2
)braket
op_assign
id|GET_LOCAL_RTC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dintr_tstamp_cnt
(braket
id|DINTR_TSTAMP2
)braket
op_minus
id|dintr_tstamp_cnt
(braket
id|DINTR_TSTAMP1
)braket
)paren
OG
id|dintr_enter_symmon
)paren
(brace
macro_line|#ifdef SPLDEBUG
r_extern
r_int
id|spldebug_log_off
suffix:semicolon
id|spldebug_log_off
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* SPLDEBUG */
id|debug
c_func
(paren
l_string|&quot;ring&quot;
)paren
suffix:semicolon
macro_line|#ifdef SPLDEBUG
id|spldebug_log_off
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* SPLDEBUG */
)brace
macro_line|#endif
id|dintr_tstamp_cnt
(braket
id|DINTR_CNTIDX
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|install_cpulat_first
r_static
r_int
id|install_cpulat_first
op_assign
l_int|0
suffix:semicolon
r_void
DECL|function|install_cpulatintr
id|install_cpulatintr
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
r_int
id|intr_bit
suffix:semicolon
id|devfs_handle_t
id|cpuv
op_assign
id|cpuid_to_vertex
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_bit
op_assign
id|CPU_INTRLAT_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_bit
op_ne
id|intr_reserve_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|II_THREADED
comma
id|cpuv
comma
l_string|&quot;intrlat&quot;
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_cpulatintr: Can&squot;t reserve interrupt.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|INTPEND0_MAXMASK
comma
id|cpulatintr
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_cpulatintr: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|install_cpulat_first
)paren
(brace
id|install_cpulat_first
op_increment
suffix:semicolon
id|idbg_addfunc
c_func
(paren
l_string|&quot;tstamp_debug&quot;
comma
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|idbg_tstamp_debug
)paren
suffix:semicolon
macro_line|#if defined(SPLDEBUG) || defined(SPLDEBUG_CPU_EVENTS)
id|idbg_addfunc
c_func
(paren
l_string|&quot;splx_log&quot;
comma
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|idbg_splx_log
)paren
suffix:semicolon
macro_line|#endif /* SPLDEBUG || SPLDEBUG_CPU_EVENTS */
)brace
)brace
macro_line|#endif /* BRINGUP */
macro_line|#endif /* DEBUG_INTR_TSTAMP */
macro_line|#ifndef BRINGUP
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|dbgintr
id|dbgintr
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
multiline_comment|/*&n;&t; * Hardware only clears IO interrupts so we have to clear our level&n;&t; * here.&n;&t; */
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|N_INTPEND_BITS
op_plus
id|DEBUG_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;zing&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|install_dbgintr
id|install_dbgintr
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
r_int
id|intr_bit
suffix:semicolon
id|devfs_handle_t
id|cpuv
op_assign
id|cpuid_to_vertex
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_bit
op_assign
id|N_INTPEND_BITS
op_plus
id|DEBUG_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_bit
op_ne
id|intr_reserve_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
l_int|1
comma
id|cpuv
comma
l_string|&quot;DEBUG&quot;
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_dbgintr: Can&squot;t reserve interrupt. &quot;
l_string|&quot; intr_bit %d&quot;
comma
id|intr_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|INTPEND1_MAXMASK
comma
id|dbgintr
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_dbgintr: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTR_TSTAMP
multiline_comment|/* Set up my interrupt latency test interrupt */
id|install_cpulatintr
c_func
(paren
id|cpu
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|tlbintr
id|tlbintr
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_extern
r_void
id|tlbflush_rand
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hardware only clears IO interrupts so we have to clear our level&n;&t; * here.&n;&t; */
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|N_INTPEND_BITS
op_plus
id|TLB_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|tlbflush_rand
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|install_tlbintr
id|install_tlbintr
c_func
(paren
id|cpuid_t
id|cpu
)paren
(brace
r_int
id|intr_bit
suffix:semicolon
id|devfs_handle_t
id|cpuv
op_assign
id|cpuid_to_vertex
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_bit
op_assign
id|N_INTPEND_BITS
op_plus
id|TLB_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_bit
op_ne
id|intr_reserve_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
l_int|1
comma
id|cpuv
comma
l_string|&quot;DEBUG&quot;
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_tlbintr: Can&squot;t reserve interrupt. &quot;
l_string|&quot; intr_bit %d&quot;
comma
id|intr_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|INTPEND1_MAXMASK
comma
id|tlbintr
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_tlbintr: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send an interrupt to all nodes.  Don&squot;t panic if we get an error.&n; * Returns 1 if any exceptions occurred.&n; */
r_int
DECL|function|protected_broadcast
id|protected_broadcast
c_func
(paren
id|hubreg_t
id|intrbit
)paren
(brace
id|nodepda_t
op_star
id|npdap
op_assign
r_private
dot
id|p_nodepda
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|sn
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|_wbadaddr_val
c_func
(paren
r_volatile
r_void
op_star
comma
r_int
comma
r_volatile
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/* Send rather than clear an interrupt. */
id|intrbit
op_or_assign
l_int|0x100
suffix:semicolon
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
id|NASID_MASK_BYTES
suffix:semicolon
id|byte
op_increment
)paren
(brace
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
l_int|8
suffix:semicolon
id|bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|npdap-&gt;nasid_mask
(braket
id|byte
)braket
op_amp
(paren
l_int|1
op_lshift
id|bit
)paren
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|byte
op_star
l_int|8
op_plus
id|bit
suffix:semicolon
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|error
op_add_assign
id|_wbadaddr_val
c_func
(paren
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_PEND_MOD
)paren
comma
r_sizeof
(paren
id|hubreg_t
)paren
comma
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|intrbit
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Poll the interrupt register to see if another cpu has asked us&n; * to drop into the debugger (without lowering spl).&n; */
r_void
DECL|function|chkdebug
id|chkdebug
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND1
)paren
op_amp
(paren
l_int|1L
op_lshift
(paren
id|DEBUG_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpuid
c_func
(paren
)paren
)paren
)paren
)paren
)paren
id|dbgintr
c_func
(paren
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Install special graphics interrupt.&n; */
r_void
DECL|function|install_gfxintr
id|install_gfxintr
c_func
(paren
id|cpuid_t
id|cpu
comma
id|ilvl_t
id|swlevel
comma
id|intr_func_t
id|intr_func
comma
r_void
op_star
id|intr_arg
)paren
(brace
r_int
id|intr_bit
op_assign
id|GFX_INTR_A
op_plus
id|cputolocalslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
id|swlevel
comma
id|intr_func
comma
id|intr_arg
comma
l_int|NULL
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;install_gfxintr: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Install page migration interrupt handler.&n; */
r_void
DECL|function|hub_migrintr_init
id|hub_migrintr_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|cpuid_t
id|cpu
op_assign
id|cnodetocpu
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_int
id|intr_bit
op_assign
id|INT_PEND0_BASELVL
op_plus
id|PG_MIG_INTR
suffix:semicolon
r_if
c_cond
(paren
id|numnodes
op_eq
l_int|1
)paren
(brace
multiline_comment|/* &n;&t;&t; * No migration with just one node..&n;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
comma
l_int|0
comma
(paren
id|intr_func_t
)paren
id|migr_intr_handler
comma
l_int|0
comma
(paren
id|intr_func_t
)paren
id|migr_intr_prologue_handler
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;hub_migrintr_init: Can&squot;t connect interrupt.&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Cause all CPUs to stop by sending them each a DEBUG interrupt.&n; * Parameter is actually a (cpumask_t *).&n; */
r_void
DECL|function|debug_stop_all_cpus
id|debug_stop_all_cpus
c_func
(paren
r_void
op_star
id|stoplist
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|ulong
id|level
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|maxcpus
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu
op_eq
id|cpuid
c_func
(paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_enabled
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* &quot;-1&quot; is the old style parameter OR could be the new style&n;&t;&t; * if no-one is currently stopped.  We only stop the&n;&t;&t; * requested cpus, the others are already stopped (probably&n;&t;&t; * at a breakpoint).&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|cpumask_t
op_star
)paren
id|stoplist
op_ne
(paren
id|cpumask_t
op_star
)paren
op_minus
l_int|1LL
)paren
op_logical_and
(paren
op_logical_neg
id|CPUMASK_TSTB
c_func
(paren
op_star
(paren
id|cpumask_t
op_star
)paren
id|stoplist
comma
id|cpu
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * CPU lslice A gets level DEBUG_INTR_A&n;&t;&t; * CPU lslice B gets level DEBUG_INTR_B&n;&t;&t; */
id|level
op_assign
id|DEBUG_INTR_A
op_plus
id|LOCALCPU
c_func
(paren
id|get_cpu_slice
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Convert the compact hub number to the NASID to get the&n;&t;&t; * correct part of the address space.  Then set the interrupt&n;&t;&t; * bit associated with the CPU we want to send the interrupt&n;&t;&t; * to.&n;&t;&t; */
id|REMOTE_CPU_SEND_INTR
c_func
(paren
id|cpu
comma
id|N_INTPEND_BITS
op_plus
id|level
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* BRINGUP */
DECL|struct|hardwired_intr_s
r_struct
id|hardwired_intr_s
(brace
DECL|member|level
r_int
r_char
id|level
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|variable|hardwired_intr
)brace
r_const
id|hardwired_intr
(braket
)braket
op_assign
(brace
(brace
id|INT_PEND0_BASELVL
op_plus
id|RESERVED_INTR
comma
l_int|0
comma
l_string|&quot;Reserved&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|GFX_INTR_A
comma
l_int|0
comma
l_string|&quot;Gfx A&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|GFX_INTR_B
comma
l_int|0
comma
l_string|&quot;Gfx B&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|PG_MIG_INTR
comma
id|II_THREADED
comma
l_string|&quot;Migration&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|UART_INTR
comma
id|II_THREADED
comma
l_string|&quot;Bedrock/L1&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|CC_PEND_A
comma
l_int|0
comma
l_string|&quot;Crosscall A&quot;
)brace
comma
(brace
id|INT_PEND0_BASELVL
op_plus
id|CC_PEND_B
comma
l_int|0
comma
l_string|&quot;Crosscall B&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|CLK_ERR_INTR
comma
id|II_ERRORINT
comma
l_string|&quot;Clock Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|COR_ERR_INTR_A
comma
id|II_ERRORINT
comma
l_string|&quot;Correctable Error A&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|COR_ERR_INTR_B
comma
id|II_ERRORINT
comma
l_string|&quot;Correctable Error B&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|MD_COR_ERR_INTR
comma
id|II_ERRORINT
comma
l_string|&quot;MD Correct. Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|NI_ERROR_INTR
comma
id|II_ERRORINT
comma
l_string|&quot;NI Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|NI_BRDCAST_ERR_A
comma
id|II_ERRORINT
comma
l_string|&quot;Remote NI Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|NI_BRDCAST_ERR_B
comma
id|II_ERRORINT
comma
l_string|&quot;Remote NI Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|MSC_PANIC_INTR
comma
id|II_ERRORINT
comma
l_string|&quot;MSC Panic&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|LLP_PFAIL_INTR_A
comma
id|II_ERRORINT
comma
l_string|&quot;LLP Pfail WAR&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|LLP_PFAIL_INTR_B
comma
id|II_ERRORINT
comma
l_string|&quot;LLP Pfail WAR&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|NACK_INT_A
comma
l_int|0
comma
l_string|&quot;CPU A Nack count == NACK_CMP&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|NACK_INT_B
comma
l_int|0
comma
l_string|&quot;CPU B Nack count == NACK_CMP&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|LB_ERROR
comma
l_int|0
comma
l_string|&quot;Local Block Error&quot;
)brace
comma
(brace
id|INT_PEND1_BASELVL
op_plus
id|XB_ERROR
comma
l_int|0
comma
l_string|&quot;Local XBar Error&quot;
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
l_int|NULL
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Reserve all of the hardwired interrupt levels so they&squot;re not used as&n; * general purpose bits later.&n; */
r_void
DECL|function|intr_reserve_hardwired
id|intr_reserve_hardwired
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|cpuid_t
id|cpu
suffix:semicolon
r_int
id|level
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|subnode_done
(braket
id|NUM_SUBNODES
)braket
suffix:semicolon
singleline_comment|// cpu = cnodetocpu(cnode);
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|smp_num_cpus
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
op_eq
id|cnode
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cpu
op_eq
id|smp_num_cpus
)paren
id|cpu
op_assign
id|CPU_NONE
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|CPU_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Node %d has no CPUs&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_SUBNODES
suffix:semicolon
id|i
op_increment
)paren
id|subnode_done
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cpu
OL
id|smp_num_cpus
op_logical_and
id|cpu_enabled
c_func
(paren
id|cpu
)paren
op_logical_and
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
op_eq
id|cnode
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_int
id|which_subnode
op_assign
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subnode_done
(braket
id|which_subnode
)braket
)paren
r_continue
suffix:semicolon
id|subnode_done
(braket
id|which_subnode
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|hardwired_intr
(braket
id|i
)braket
dot
id|level
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|level
op_assign
id|hardwired_intr
(braket
id|i
)braket
dot
id|level
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|intr_reserve_level
c_func
(paren
id|cpu
comma
id|level
comma
id|hardwired_intr
(braket
id|i
)braket
dot
id|flags
comma
(paren
id|devfs_handle_t
)paren
l_int|NULL
comma
id|hardwired_intr
(braket
id|i
)braket
dot
id|name
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intr_reserve_hardwired: Can&squot;t reserve level %d.&quot;
comma
id|level
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Check and clear interrupts.&n; */
multiline_comment|/*ARGSUSED*/
r_static
r_void
DECL|function|intr_clear_bits
id|intr_clear_bits
c_func
(paren
id|nasid_t
id|nasid
comma
r_volatile
id|hubreg_t
op_star
id|pend
comma
r_int
id|base_level
comma
r_char
op_star
id|name
)paren
(brace
r_volatile
id|hubreg_t
id|bits
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check pending interrupts */
r_if
c_cond
(paren
(paren
id|bits
op_assign
id|HUB_L
c_func
(paren
id|pend
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_INTPEND_BITS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
macro_line|#ifdef INTRDEBUG
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Nasid %d interrupt bit %d set in %s&quot;
comma
id|nasid
comma
id|i
comma
id|name
)paren
suffix:semicolon
macro_line|#endif
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|base_level
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Clear out our interrupt registers.&n; */
r_void
DECL|function|intr_clear_all
id|intr_clear_all
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|sn
suffix:semicolon
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_MASK0_A
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_MASK0_B
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_MASK1_A
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_MASK1_B
comma
l_int|0
)paren
suffix:semicolon
id|intr_clear_bits
c_func
(paren
id|nasid
comma
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_PEND0
)paren
comma
id|INT_PEND0_BASELVL
comma
l_string|&quot;INT_PEND0&quot;
)paren
suffix:semicolon
id|intr_clear_bits
c_func
(paren
id|nasid
comma
id|REMOTE_HUB_PI_ADDR
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_INT_PEND1
)paren
comma
id|INT_PEND1_BASELVL
comma
l_string|&quot;INT_PEND1&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Dump information about a particular interrupt vector.&n; */
r_static
r_void
DECL|function|dump_vector
id|dump_vector
c_func
(paren
id|intr_info_t
op_star
id|info
comma
id|intr_vector_t
op_star
id|vector
comma
r_int
id|bit
comma
id|hubreg_t
id|ip
comma
id|hubreg_t
id|ima
comma
id|hubreg_t
id|imb
comma
r_void
(paren
op_star
id|pf
)paren
(paren
r_char
op_star
comma
dot
dot
dot
)paren
)paren
(brace
id|hubreg_t
id|value
op_assign
l_int|1LL
op_lshift
id|bit
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot;  Bit %02d: %s: func 0x%x arg 0x%x prefunc 0x%x&bslash;n&quot;
comma
id|bit
comma
id|info-&gt;ii_name
comma
id|vector-&gt;iv_func
comma
id|vector-&gt;iv_arg
comma
id|vector-&gt;iv_prefunc
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot;   vertex 0x%x %s%s&quot;
comma
id|info-&gt;ii_owner_dev
comma
(paren
(paren
id|info-&gt;ii_flags
)paren
op_amp
id|II_RESERVE
)paren
ques
c_cond
l_string|&quot;R&quot;
suffix:colon
l_string|&quot;U&quot;
comma
(paren
(paren
id|info-&gt;ii_flags
)paren
op_amp
id|II_INUSE
)paren
ques
c_cond
l_string|&quot;C&quot;
suffix:colon
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot;%s%s%s%s&quot;
comma
id|ip
op_amp
id|value
ques
c_cond
l_string|&quot;P&quot;
suffix:colon
l_string|&quot;-&quot;
comma
id|ima
op_amp
id|value
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
l_string|&quot;-&quot;
comma
id|imb
op_amp
id|value
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
l_string|&quot;-&quot;
comma
(paren
(paren
id|info-&gt;ii_flags
)paren
op_amp
id|II_ERRORINT
)paren
ques
c_cond
l_string|&quot;E&quot;
suffix:colon
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dump information about interrupt vector assignment.&n; */
r_void
DECL|function|intr_dumpvec
id|intr_dumpvec
c_func
(paren
id|cnodeid_t
id|cnode
comma
r_void
(paren
op_star
id|pf
)paren
(paren
r_char
op_star
comma
dot
dot
dot
)paren
)paren
(brace
id|nodepda_t
op_star
id|npda
suffix:semicolon
r_int
id|ip
comma
id|sn
comma
id|bit
suffix:semicolon
id|intr_vecblk_t
op_star
id|dispatch
suffix:semicolon
id|hubreg_t
id|ipr
comma
id|ima
comma
id|imb
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cnode
OL
l_int|0
)paren
op_logical_or
(paren
id|cnode
op_ge
id|numnodes
)paren
)paren
(brace
id|pf
c_func
(paren
l_string|&quot;intr_dumpvec: cnodeid out of range: %d&bslash;n&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|INVALID_NASID
)paren
(brace
id|pf
c_func
(paren
l_string|&quot;intr_dumpvec: Bad cnodeid: %d&bslash;n&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|npda
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
r_for
c_loop
(paren
id|ip
op_assign
l_int|0
suffix:semicolon
id|ip
OL
l_int|2
suffix:semicolon
id|ip
op_increment
)paren
(brace
id|dispatch
op_assign
id|ip
ques
c_cond
op_amp
(paren
id|SNPDA
c_func
(paren
id|npda
comma
id|sn
)paren
op_member_access_from_pointer
id|intr_dispatch1
)paren
suffix:colon
op_amp
(paren
id|SNPDA
c_func
(paren
id|npda
comma
id|sn
)paren
op_member_access_from_pointer
id|intr_dispatch0
)paren
suffix:semicolon
id|ipr
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|ip
ques
c_cond
id|PI_INT_PEND1
suffix:colon
id|PI_INT_PEND0
)paren
suffix:semicolon
id|ima
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|ip
ques
c_cond
id|PI_INT_MASK1_A
suffix:colon
id|PI_INT_MASK0_A
)paren
suffix:semicolon
id|imb
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|ip
ques
c_cond
id|PI_INT_MASK1_B
suffix:colon
id|PI_INT_MASK0_B
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot;Node %d INT_PEND%d:&bslash;n&quot;
comma
id|cnode
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dispatch-&gt;ithreads_enabled
)paren
id|pf
c_func
(paren
l_string|&quot; Ithreads enabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|pf
c_func
(paren
l_string|&quot; Ithreads disabled&bslash;n&quot;
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot; vector_count = %d, vector_state = %d&bslash;n&quot;
comma
id|dispatch-&gt;vector_count
comma
id|dispatch-&gt;vector_state
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot; CPU A count %d, CPU B count %d&bslash;n&quot;
comma
id|dispatch-&gt;cpu_count
(braket
l_int|0
)braket
comma
id|dispatch-&gt;cpu_count
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|pf
c_func
(paren
l_string|&quot; &amp;vector_lock = 0x%x&bslash;n&quot;
comma
op_amp
(paren
id|dispatch-&gt;vector_lock
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
id|N_INTPEND_BITS
suffix:semicolon
id|bit
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dispatch-&gt;info
(braket
id|bit
)braket
dot
id|ii_flags
op_amp
id|II_RESERVE
)paren
op_logical_or
(paren
id|ipr
op_amp
(paren
l_int|1L
op_lshift
id|bit
)paren
)paren
)paren
(brace
id|dump_vector
c_func
(paren
op_amp
(paren
id|dispatch-&gt;info
(braket
id|bit
)braket
)paren
comma
op_amp
(paren
id|dispatch-&gt;vectors
(braket
id|bit
)braket
)paren
comma
id|bit
comma
id|ipr
comma
id|ima
comma
id|imb
comma
id|pf
)paren
suffix:semicolon
)brace
)brace
id|pf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
eof
