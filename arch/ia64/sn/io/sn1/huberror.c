multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
r_extern
r_void
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
suffix:semicolon
r_extern
r_void
id|snia_error_intr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
suffix:semicolon
r_extern
r_int
id|maxcpus
suffix:semicolon
DECL|macro|HUB_ERROR_PERIOD
mdefine_line|#define HUB_ERROR_PERIOD        (120 * HZ)      /* 2 minutes */
r_void
DECL|function|hub_error_clear
id|hub_error_clear
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|i
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
r_int
id|sn
suffix:semicolon
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_PEND
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS0_A_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS0_B_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_SPURIOUS_HDR_0
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_SPURIOUS_HDR_1
comma
l_int|0
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_DIR_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_MEM_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_MISC1_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_PROTOCOL_ERR_CLR
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure spurious write response errors are cleared&n;     * (values are from hub_set_prb())&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|HUB_WIDGET_ID_MAX
op_minus
id|HUB_WIDGET_ID_MIN
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear out some fields */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * PIO reads in fire-and-forget mode on bedrock 1.0 don&squot;t&n;&t; * frob the credit count properly, making the responses appear&n;&t; * spurious.  So don&squot;t use fire-and-forget mode.  Bug 761802.&n;&t; */
id|prb.iprb_ff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable fire-and-forget mode by default */
id|prb.iprb_xtalkctr
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* approx. PIO credits for the widget */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IO_ERR_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
comma
(paren
id|idsr
op_amp
op_complement
(paren
id|IIO_IIDSR_SENT_MASK
)paren
)paren
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|NI_PORT_ERROR_CLEAR
)paren
suffix:semicolon
multiline_comment|/* No need to clear NI_PORT_HEADER regs; they are continually overwritten*/
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|LB_ERROR_MASK_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|LB_ERROR_HDR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear XB error regs, in order */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|XB_FIRST_ERROR_CLEAR
op_minus
id|XB_POQ0_ERROR_CLEAR
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|hubreg_t
)paren
)paren
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|XB_POQ0_ERROR_CLEAR
op_plus
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function&t;: hub_error_init&n; * Purpose&t;: initialize the error handling requirements for a given hub.&n; * Parameters&t;: cnode, the compact nodeid.&n; * Assumptions&t;: Called only once per hub, either by a local cpu. Or by a &n; *&t;&t;&t;remote cpu, when this hub is headless.(cpuless)&n; * Returns&t;: None&n; */
r_void
DECL|function|hub_error_init
id|hub_error_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hub_error_clear
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now setup the hub ii and ni error interrupt handler.&n;     */
id|hubii_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubni_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hubii_eint_init&n; * Parameters&t;: cnode&n; * Purpose&t;: to initialize the hub iio error interrupt.&n; * Assumptions&t;: Called once per hub, by the cpu which will ultimately&n; *&t;&t;&t;handle this interrupt.&n; * Returns&t;: None.&n; */
r_void
DECL|function|hubii_eint_init
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|bit
comma
id|rv
suffix:semicolon
id|ii_iidsr_u_t
id|hubio_eint
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|cpuid_t
id|intr_cpu
suffix:semicolon
id|devfs_handle_t
id|hub_v
suffix:semicolon
id|ii_ilcsr_u_t
id|ilcsr
suffix:semicolon
r_int
id|bit_pos_to_irq
c_func
(paren
r_int
id|bit
)paren
suffix:semicolon
r_int
id|synergy_intr_connect
c_func
(paren
r_int
id|bit
comma
r_int
id|cpuid
)paren
suffix:semicolon
id|hub_v
op_assign
(paren
id|devfs_handle_t
)paren
id|cnodeid_to_vertex
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo-&gt;h_cnodeid
op_eq
id|cnode
)paren
suffix:semicolon
id|ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ilcsr.ii_ilcsr_fld_s.i_llp_stat
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* &n;&t; * HUB II link is not up. &n;&t; * Just disable LLP, and don&squot;t connect any interrupts.&n;&t; */
id|ilcsr.ii_ilcsr_fld_s.i_llp_en
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
comma
id|ilcsr.ii_ilcsr_regval
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Select a possible interrupt target where there is a free interrupt&n;     * bit and also reserve the interrupt bit for this IO error interrupt&n;     */
id|intr_cpu
op_assign
id|intr_heuristic
c_func
(paren
id|hub_v
comma
l_int|0
comma
id|INTRCONNECT_ANYBIT
comma
id|II_ERRORINT
comma
id|hub_v
comma
l_string|&quot;HUB IO error interrupt&quot;
comma
op_amp
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_cpu
op_eq
id|CPU_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hubii_eint_init: intr_reserve_level failed, cnode %d&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rv
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpu
comma
id|bit
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|synergy_intr_connect
c_func
(paren
id|bit
comma
id|intr_cpu
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|bit_pos_to_irq
c_func
(paren
id|bit
)paren
op_plus
(paren
id|intr_cpu
op_lshift
l_int|8
)paren
comma
id|hubii_eint_handler
comma
l_int|0
comma
l_string|&quot;SN hub error&quot;
comma
(paren
r_void
op_star
)paren
id|hub_v
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_ge
l_int|0
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_regval
op_assign
l_int|0
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_enable
op_assign
l_int|1
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_level
op_assign
id|bit
suffix:semicolon
multiline_comment|/* Take the least significant bits*/
id|hubio_eint.ii_iidsr_fld_s.i_node
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_pi_id
op_assign
id|cpuid_to_subnode
c_func
(paren
id|intr_cpu
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|hubio_eint.ii_iidsr_regval
)paren
suffix:semicolon
)brace
r_void
DECL|function|hubni_eint_init
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|intr_bit
suffix:semicolon
id|cpuid_t
id|targ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targ
op_assign
id|cnodeid_to_cpuid
c_func
(paren
id|cnode
)paren
)paren
op_eq
id|CPU_NONE
)paren
r_return
suffix:semicolon
multiline_comment|/* The prom chooses which cpu gets these interrupts, but we&n;&t;*  don&squot;t know which one it chose.  We will register all of the &n;&t;*  cpus to be sure.  This only costs us an irqaction per cpu.&n;&t;*/
r_for
c_loop
(paren
suffix:semicolon
id|targ
OL
id|CPUS_PER_NODE
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_enabled
c_func
(paren
id|targ
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* connect the INTEND1 bits. */
r_for
c_loop
(paren
id|intr_bit
op_assign
id|XB_ERROR
suffix:semicolon
id|intr_bit
op_le
id|MSC_PANIC_INTR
suffix:semicolon
id|intr_bit
op_increment
)paren
(brace
id|intr_connect_level
c_func
(paren
id|targ
comma
id|intr_bit
comma
id|II_ERRORINT
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|request_irq
c_func
(paren
id|SGI_HUB_ERROR_IRQ
op_plus
(paren
id|targ
op_lshift
l_int|8
)paren
comma
id|snia_error_intr_handler
comma
l_int|0
comma
l_string|&quot;SN hub error&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* synergy masks are initialized in the prom to enable all interrupts. */
multiline_comment|/* We&squot;ll just leave them that way, here, for these interrupts. */
)brace
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hubii_eint_handler
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Hubii interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
