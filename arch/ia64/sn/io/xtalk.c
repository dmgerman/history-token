multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iobus.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xswitch.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk_private.h&gt;
multiline_comment|/*&n; * Implement crosstalk provider operations.  The xtalk* layer provides a&n; * platform-independent interface for crosstalk devices.  This layer&n; * switches among the possible implementations of a crosstalk adapter.&n; *&n; * On platforms with only one possible xtalk provider, macros can be&n; * set up at the top that cause the table lookups and indirections to&n; * completely disappear.&n; */
DECL|macro|NEW
mdefine_line|#define&t;NEW(ptr)&t;(ptr = kmalloc(sizeof (*(ptr)), GFP_KERNEL))
DECL|macro|DEL
mdefine_line|#define&t;DEL(ptr)&t;(kfree(ptr))
DECL|variable|widget_info_fingerprint
r_char
id|widget_info_fingerprint
(braket
)braket
op_assign
l_string|&quot;widget_info&quot;
suffix:semicolon
DECL|variable|xtalk_registry
id|cdl_p
id|xtalk_registry
op_assign
l_int|NULL
suffix:semicolon
macro_line|#include &lt;asm/sn/agent.h&gt;
DECL|macro|DEV_FUNC
mdefine_line|#define&t;DEV_FUNC(dev,func)&t;hub_##func
DECL|macro|CAST_PIOMAP
mdefine_line|#define&t;CAST_PIOMAP(x)&t;&t;((hub_piomap_t)(x))
DECL|macro|CAST_DMAMAP
mdefine_line|#define&t;CAST_DMAMAP(x)&t;&t;((hub_dmamap_t)(x))
DECL|macro|CAST_INTR
mdefine_line|#define&t;CAST_INTR(x)&t;&t;((hub_intr_t)(x))
multiline_comment|/* =====================================================================&n; *            Function Table of Contents&n; */
id|xtalk_piomap_t
id|xtalk_piomap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_piomap_free
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|xtalk_piomap_addr
c_func
(paren
id|xtalk_piomap_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_piomap_done
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|xtalk_piotrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|caddr_t
id|xtalk_pio_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|iopaddr_t
comma
r_int
comma
id|xtalk_piomap_t
op_star
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_set_early_piotrans_addr
c_func
(paren
id|xtalk_early_piotrans_addr_f
op_star
)paren
suffix:semicolon
id|caddr_t
id|xtalk_early_piotrans_addr
c_func
(paren
id|xwidget_part_num_t
comma
id|xwidget_mfg_num_t
comma
r_int
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
id|caddr_t
id|null_xtalk_early_piotrans_addr
c_func
(paren
id|xwidget_part_num_t
comma
id|xwidget_mfg_num_t
comma
r_int
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|xtalk_dmamap_t
id|xtalk_dmamap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap_t
)paren
suffix:semicolon
id|iopaddr_t
id|xtalk_dmamap_addr
c_func
(paren
id|xtalk_dmamap_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|xtalk_dmamap_list
c_func
(paren
id|xtalk_dmamap_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_dmamap_done
c_func
(paren
id|xtalk_dmamap_t
)paren
suffix:semicolon
id|iopaddr_t
id|xtalk_dmatrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|xtalk_dmatrans_list
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_dmamap_drain
c_func
(paren
id|xtalk_dmamap_t
)paren
suffix:semicolon
r_void
id|xtalk_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_dmalist_drain
c_func
(paren
id|devfs_handle_t
comma
id|alenlist_t
)paren
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr_alloc_nothd
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|xtalk_intr_free
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_int
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr_t
comma
id|intr_func_t
comma
id|intr_arg_t
comma
id|xtalk_intr_setfunc_t
comma
r_void
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_void
id|xtalk_intr_disconnect
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xtalk_intr_cpu_get
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_int
id|xtalk_error_handler
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_int
id|xtalk_error_devenable
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|xtalk_provider_startup
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|xtalk_provider_shutdown
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xtalk_intr_dev_get
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|xwidgetnum_t
id|xtalk_intr_target_get
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|iopaddr_t
id|xtalk_intr_addr_get
c_func
(paren
r_struct
id|xtalk_intr_s
op_star
)paren
suffix:semicolon
r_void
op_star
id|xtalk_intr_sfarg_get
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xtalk_pio_dev_get
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|xwidgetnum_t
id|xtalk_pio_target_get
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|iopaddr_t
id|xtalk_pio_xtalk_addr_get
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|ulong
id|xtalk_pio_mapsz_get
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|xtalk_pio_kvaddr_get
c_func
(paren
id|xtalk_piomap_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xtalk_dma_dev_get
c_func
(paren
id|xtalk_dmamap_t
)paren
suffix:semicolon
id|xwidgetnum_t
id|xtalk_dma_target_get
c_func
(paren
id|xtalk_dmamap_t
)paren
suffix:semicolon
id|xwidget_info_t
id|xwidget_info_chk
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|xwidget_info_t
id|xwidget_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|xwidget_info_set
c_func
(paren
id|devfs_handle_t
comma
id|xwidget_info_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xwidget_info_dev_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
id|xwidgetnum_t
id|xwidget_info_id_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
id|devfs_handle_t
id|xwidget_info_master_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
id|xwidgetnum_t
id|xwidget_info_masterid_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
id|xwidget_part_num_t
id|xwidget_info_part_num_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
id|xwidget_mfg_num_t
id|xwidget_info_mfg_num_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
r_char
op_star
id|xwidget_info_name_get
c_func
(paren
id|xwidget_info_t
)paren
suffix:semicolon
r_void
id|xtalk_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|xtalk_provider_register
c_func
(paren
id|devfs_handle_t
comma
id|xtalk_provider_t
op_star
)paren
suffix:semicolon
r_void
id|xtalk_provider_unregister
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|xtalk_provider_t
op_star
id|xtalk_provider_fns_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xwidget_driver_register
c_func
(paren
id|xwidget_part_num_t
comma
id|xwidget_mfg_num_t
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_void
id|xwidget_driver_unregister
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
r_int
id|xwidget_register
c_func
(paren
id|xwidget_hwid_t
comma
id|devfs_handle_t
comma
id|xwidgetnum_t
comma
id|devfs_handle_t
comma
id|xwidgetnum_t
comma
id|async_attach_t
)paren
suffix:semicolon
r_int
id|xwidget_unregister
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|xwidget_error_register
c_func
(paren
id|devfs_handle_t
comma
id|error_handler_f
op_star
comma
id|error_handler_arg_t
)paren
suffix:semicolon
r_void
id|xwidget_reset
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_char
op_star
id|xwidget_name_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
macro_line|#if !defined(DEV_FUNC)
multiline_comment|/*&n; * There is more than one possible provider&n; * for this platform. We need to examine the&n; * master vertex of the current vertex for&n; * a provider function structure, and indirect&n; * through the appropriately named member.&n; */
DECL|macro|DEV_FUNC
mdefine_line|#define&t;DEV_FUNC(dev,func)&t;xwidget_to_provider_fns(dev)-&gt;func
DECL|macro|CAST_PIOMAP
mdefine_line|#define&t;CAST_PIOMAP(x)&t;&t;((xtalk_piomap_t)(x))
DECL|macro|CAST_DMAMAP
mdefine_line|#define&t;CAST_DMAMAP(x)&t;&t;((xtalk_dmamap_t)(x))
DECL|macro|CAST_INTR
mdefine_line|#define&t;CAST_INTR(x)&t;&t;((xtalk_intr_t)(x))
r_static
id|xtalk_provider_t
op_star
DECL|function|xwidget_to_provider_fns
id|xwidget_to_provider_fns
c_func
(paren
id|devfs_handle_t
id|xconn
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
id|xtalk_provider_t
op_star
id|provider_fns
suffix:semicolon
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|widget_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|provider_fns
op_assign
id|xwidget_info_pops_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|provider_fns
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|provider_fns
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Many functions are not passed their vertex&n; * information directly; rather, they must&n; * dive through a resource map. These macros&n; * are available to coordinate this detail.&n; */
DECL|macro|PIOMAP_FUNC
mdefine_line|#define&t;PIOMAP_FUNC(map,func)&t;DEV_FUNC(map-&gt;xp_dev,func)
DECL|macro|DMAMAP_FUNC
mdefine_line|#define&t;DMAMAP_FUNC(map,func)&t;DEV_FUNC(map-&gt;xd_dev,func)
DECL|macro|INTR_FUNC
mdefine_line|#define&t;INTR_FUNC(intr,func)&t;DEV_FUNC(intr_hdl-&gt;xi_dev,func)
multiline_comment|/* =====================================================================&n; *                    PIO MANAGEMENT&n; *&n; *      For mapping system virtual address space to&n; *      xtalk space on a specified widget&n; */
id|xtalk_piomap_t
DECL|function|xtalk_piomap_alloc
id|xtalk_piomap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mapping for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk_addr range */
r_int
id|byte_count
comma
r_int
id|byte_count_max
comma
multiline_comment|/* maximum size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in sys/pio.h */
r_return
(paren
id|xtalk_piomap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piomap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|xtalk_addr
comma
id|byte_count
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_piomap_free
id|xtalk_piomap_free
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|xtalk_piomap
comma
id|piomap_free
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|xtalk_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|xtalk_piomap_addr
id|xtalk_piomap_addr
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
comma
multiline_comment|/* mapping resources */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
r_return
id|PIOMAP_FUNC
c_func
(paren
id|xtalk_piomap
comma
id|piomap_addr
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|xtalk_piomap
)paren
comma
id|xtalk_addr
comma
id|byte_count
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_piomap_done
id|xtalk_piomap_done
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|xtalk_piomap
comma
id|piomap_done
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|xtalk_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|xtalk_piotrans_addr
id|xtalk_piotrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* Crosstalk address */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
r_int
id|flags
)paren
(brace
multiline_comment|/* (currently unused) */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piotrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|xtalk_addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|xtalk_pio_addr
id|xtalk_pio_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|addr
comma
multiline_comment|/* starting address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
id|xtalk_piomap_t
op_star
id|mapp
comma
multiline_comment|/* where to return the map pointer */
r_int
id|flags
)paren
(brace
multiline_comment|/* PIO flags */
id|xtalk_piomap_t
id|map
op_assign
l_int|0
suffix:semicolon
id|caddr_t
id|res
suffix:semicolon
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* record &quot;no map used&quot; */
id|res
op_assign
id|xtalk_piotrans_addr
(paren
id|dev
comma
id|dev_desc
comma
id|addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* xtalk_piotrans worked */
id|map
op_assign
id|xtalk_piomap_alloc
(paren
id|dev
comma
id|dev_desc
comma
id|addr
comma
id|byte_count
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* xtalk_piomap_alloc failed */
id|res
op_assign
id|xtalk_piomap_addr
(paren
id|map
comma
id|addr
comma
id|byte_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|xtalk_piomap_free
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
multiline_comment|/* xtalk_piomap_addr failed */
)brace
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
id|map
suffix:semicolon
multiline_comment|/* pass back map used */
r_return
id|res
suffix:semicolon
multiline_comment|/* xtalk_piomap_addr succeeded */
)brace
multiline_comment|/* =====================================================================&n; *            EARLY PIOTRANS SUPPORT&n; *&n; *      There are places where drivers (mgras, for instance)&n; *      need to get PIO translations before the infrastructure&n; *      is extended to them (setting up textports, for&n; *      instance). These drivers should call&n; *      xtalk_early_piotrans_addr with their xtalk ID&n; *      information, a sequence number (so we can use the second&n; *      mgras for instance), and the usual piotrans parameters.&n; *&n; *      Machine specific code should provide an implementation&n; *      of early_piotrans_addr, and present a pointer to this&n; *      function to xtalk_set_early_piotrans_addr so it can be&n; *      used by clients without the clients having to know what&n; *      platform or what xtalk provider is in use.&n; */
DECL|variable|null_xtalk_early_piotrans_addr
r_static
id|xtalk_early_piotrans_addr_f
id|null_xtalk_early_piotrans_addr
suffix:semicolon
DECL|variable|impl_early_piotrans_addr
id|xtalk_early_piotrans_addr_f
op_star
id|impl_early_piotrans_addr
op_assign
id|null_xtalk_early_piotrans_addr
suffix:semicolon
multiline_comment|/* xtalk_set_early_piotrans_addr:&n; * specify the early_piotrans_addr implementation function.&n; */
r_void
DECL|function|xtalk_set_early_piotrans_addr
id|xtalk_set_early_piotrans_addr
c_func
(paren
id|xtalk_early_piotrans_addr_f
op_star
id|impl
)paren
(brace
id|impl_early_piotrans_addr
op_assign
id|impl
suffix:semicolon
)brace
multiline_comment|/* xtalk_early_piotrans_addr:&n; * figure out a PIO address for the &quot;nth&quot; crosstalk widget that&n; * matches the specified part and mfgr number. Returns NULL if&n; * there is no such widget, or if the requested mapping can not&n; * be constructed.&n; * Limitations on which crosstalk slots (and busses) are&n; * checked, and definitions of the ordering of the search across&n; * the crosstalk slots, are defined by the platform.&n; */
id|caddr_t
DECL|function|xtalk_early_piotrans_addr
id|xtalk_early_piotrans_addr
c_func
(paren
id|xwidget_part_num_t
id|part_num
comma
id|xwidget_mfg_num_t
id|mfg_num
comma
r_int
id|which
comma
id|iopaddr_t
id|xtalk_addr
comma
r_int
id|byte_count
comma
r_int
id|flags
)paren
(brace
r_return
id|impl_early_piotrans_addr
(paren
id|part_num
comma
id|mfg_num
comma
id|which
comma
id|xtalk_addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* null_xtalk_early_piotrans_addr:&n; * used as the early_piotrans_addr implementation until and&n; * unless a real implementation is provided. In DEBUG kernels,&n; * we want to know who is calling before the implementation is&n; * registered; in non-DEBUG kernels, return NULL representing&n; * lack of mapping support.&n; */
multiline_comment|/*ARGSUSED */
r_static
id|caddr_t
DECL|function|null_xtalk_early_piotrans_addr
id|null_xtalk_early_piotrans_addr
c_func
(paren
id|xwidget_part_num_t
id|part_num
comma
id|xwidget_mfg_num_t
id|mfg_num
comma
r_int
id|which
comma
id|iopaddr_t
id|xtalk_addr
comma
r_int
id|byte_count
comma
r_int
id|flags
)paren
(brace
macro_line|#if DEBUG
id|PRINT_PANIC
c_func
(paren
l_string|&quot;null_xtalk_early_piotrans_addr&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *                    DMA MANAGEMENT&n; *&n; *      For mapping from crosstalk space to system&n; *      physical space.&n; */
id|xtalk_dmamap_t
DECL|function|xtalk_dmamap_alloc
id|xtalk_dmamap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
(paren
id|xtalk_dmamap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmamap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_dmamap_free
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|xtalk_dmamap
comma
id|dmamap_free
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|xtalk_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|xtalk_dmamap_addr
id|xtalk_dmamap_addr
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
r_return
id|DMAMAP_FUNC
c_func
(paren
id|xtalk_dmamap
comma
id|dmamap_addr
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|xtalk_dmamap
)paren
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
id|alenlist_t
DECL|function|xtalk_dmamap_list
id|xtalk_dmamap_list
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
comma
multiline_comment|/* use these mapping resources */
id|alenlist_t
id|alenlist
comma
multiline_comment|/* map this Address/Length List */
r_int
id|flags
)paren
(brace
r_return
id|DMAMAP_FUNC
c_func
(paren
id|xtalk_dmamap
comma
id|dmamap_list
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|xtalk_dmamap
)paren
comma
id|alenlist
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_dmamap_done
id|xtalk_dmamap_done
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|xtalk_dmamap
comma
id|dmamap_done
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|xtalk_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|xtalk_dmatrans_addr
id|xtalk_dmatrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|alenlist_t
DECL|function|xtalk_dmatrans_list
id|xtalk_dmatrans_list
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|alenlist_t
id|palenlist
comma
multiline_comment|/* system address/length list */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_list
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|palenlist
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_dmamap_drain
id|xtalk_dmamap_drain
c_func
(paren
id|xtalk_dmamap_t
id|map
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|map
comma
id|dmamap_drain
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|map
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_dmaaddr_drain
id|xtalk_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|paddr_t
id|addr
comma
r_int
id|size
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmaaddr_drain
)paren
(paren
id|dev
comma
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
r_void
DECL|function|xtalk_dmalist_drain
id|xtalk_dmalist_drain
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|alenlist_t
id|list
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmalist_drain
)paren
(paren
id|dev
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *                    INTERRUPT MANAGEMENT&n; *&n; *      Allow crosstalk devices to establish interrupts&n; */
multiline_comment|/*&n; * Allocate resources required for an interrupt as specified in intr_desc.&n; * Return resource handle in intr_hdl.&n; */
id|xtalk_intr_t
DECL|function|xtalk_intr_alloc
id|xtalk_intr_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* which Crosstalk device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|devfs_handle_t
id|owner_dev
)paren
(brace
multiline_comment|/* owner of this interrupt */
r_return
(paren
id|xtalk_intr_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|intr_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|owner_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate resources required for an interrupt as specified in dev_desc.&n; * Unconditionally setup resources to be non-threaded.&n; * Return resource handle in intr_hdl.&n; */
id|xtalk_intr_t
DECL|function|xtalk_intr_alloc_nothd
id|xtalk_intr_alloc_nothd
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* which Crosstalk device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|devfs_handle_t
id|owner_dev
)paren
multiline_comment|/* owner of this interrupt */
(brace
r_return
(paren
id|xtalk_intr_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|intr_alloc_nothd
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|owner_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free resources consumed by intr_alloc.&n; */
r_void
DECL|function|xtalk_intr_free
id|xtalk_intr_free
c_func
(paren
id|xtalk_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_free
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate resources allocated with a previous xtalk_intr_alloc call with the&n; * described handler, arg, name, etc.&n; *&n; * Returns 0 on success, returns &lt;0 on failure.&n; */
r_int
DECL|function|xtalk_intr_connect
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr_t
id|intr_hdl
comma
multiline_comment|/* xtalk intr resource handle */
id|intr_func_t
id|intr_func
comma
multiline_comment|/* xtalk intr handler */
id|intr_arg_t
id|intr_arg
comma
multiline_comment|/* arg to intr handler */
id|xtalk_intr_setfunc_t
id|setfunc
comma
multiline_comment|/* func to set intr hw */
r_void
op_star
id|setfunc_arg
comma
multiline_comment|/* arg to setfunc */
r_void
op_star
id|thread
)paren
(brace
multiline_comment|/* intr thread to use */
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_connect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
comma
id|intr_func
comma
id|intr_arg
comma
id|setfunc
comma
id|setfunc_arg
comma
id|thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate handler with the specified interrupt.&n; */
r_void
DECL|function|xtalk_intr_disconnect
id|xtalk_intr_disconnect
c_func
(paren
id|xtalk_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_disconnect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a hwgraph vertex that represents the CPU currently&n; * targeted by an interrupt.&n; */
id|devfs_handle_t
DECL|function|xtalk_intr_cpu_get
id|xtalk_intr_cpu_get
c_func
(paren
id|xtalk_intr_t
id|intr_hdl
)paren
(brace
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_cpu_get
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * =====================================================================&n; *                      ERROR MANAGEMENT&n; */
multiline_comment|/*&n; * xtalk_error_handler:&n; * pass this error on to the handler registered&n; * at the specified xtalk connecdtion point,&n; * or complain about it here if there is no handler.&n; *&n; * This routine plays two roles during error delivery&n; * to most widgets: first, the external agent (heart,&n; * hub, or whatever) calls in with the error and the&n; * connect point representing the crosstalk switch,&n; * or whatever crosstalk device is directly connected&n; * to the agent.&n; *&n; * If there is a switch, it will generally look at the&n; * widget number stashed in the ioerror structure; and,&n; * if the error came from some widget other than the&n; * switch, it will call back into xtalk_error_handler&n; * with the connection point of the offending port.&n; */
r_int
DECL|function|xtalk_error_handler
id|xtalk_error_handler
c_func
(paren
id|devfs_handle_t
id|xconn
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioerror
)paren
(brace
id|xwidget_info_t
id|xwidget_info
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|printk
c_func
(paren
l_string|&quot;%v: xtalk_error_handler&bslash;n&quot;
comma
id|xconn
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%x: xtalk_error_handler&bslash;n&quot;
comma
id|xconn
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|xwidget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn
)paren
suffix:semicolon
multiline_comment|/* Make sure that xwidget_info is a valid pointer before derefencing it.&n;     * We could come in here during very early initialization. &n;     */
r_if
c_cond
(paren
id|xwidget_info
op_logical_and
id|xwidget_info-&gt;w_efunc
)paren
r_return
id|xwidget_info-&gt;w_efunc
(paren
id|xwidget_info-&gt;w_einfo
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
multiline_comment|/*&n;     * no error handler registered for&n;     * the offending port. it&squot;s not clear&n;     * what needs to be done, but reporting&n;     * it would be a good thing, unless it&n;     * is a mode that requires nothing.&n;     */
r_if
c_cond
(paren
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
op_logical_or
(paren
id|mode
op_eq
id|MODE_DEVUSERERROR
)paren
op_logical_or
(paren
id|mode
op_eq
id|MODE_DEVREENABLE
)paren
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
macro_line|#ifdef&t;LATER
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Xbow at %v encountered Fatal error&quot;
comma
id|xconn
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Xbow at %x encountered Fatal error&quot;
comma
id|xconn
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;/* LATER */
id|ioerror_dump
c_func
(paren
l_string|&quot;xtalk&quot;
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_return
id|IOERROR_UNHANDLED
suffix:semicolon
)brace
r_int
DECL|function|xtalk_error_devenable
id|xtalk_error_devenable
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|devnum
comma
r_int
id|error_code
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|xconn_vhdl
comma
id|error_devenable
)paren
(paren
id|xconn_vhdl
comma
id|devnum
comma
id|error_code
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *                    CONFIGURATION MANAGEMENT&n; */
multiline_comment|/*&n; * Startup a crosstalk provider&n; */
r_void
DECL|function|xtalk_provider_startup
id|xtalk_provider_startup
c_func
(paren
id|devfs_handle_t
id|xtalk_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|xtalk_provider
comma
id|provider_startup
)paren
(paren
id|xtalk_provider
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shutdown a crosstalk provider&n; */
r_void
DECL|function|xtalk_provider_shutdown
id|xtalk_provider_shutdown
c_func
(paren
id|devfs_handle_t
id|xtalk_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|xtalk_provider
comma
id|provider_shutdown
)paren
(paren
id|xtalk_provider
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Enable a device on a xtalk widget &n; */
r_void
DECL|function|xtalk_widgetdev_enable
id|xtalk_widgetdev_enable
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|devnum
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|xconn_vhdl
comma
id|widgetdev_enable
)paren
(paren
id|xconn_vhdl
comma
id|devnum
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Shutdown a device on a xtalk widget &n; */
r_void
DECL|function|xtalk_widgetdev_shutdown
id|xtalk_widgetdev_shutdown
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|devnum
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|xconn_vhdl
comma
id|widgetdev_shutdown
)paren
(paren
id|xconn_vhdl
comma
id|devnum
)paren
suffix:semicolon
)brace
r_int
DECL|function|xtalk_dma_enabled
id|xtalk_dma_enabled
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|xconn_vhdl
comma
id|dma_enabled
)paren
(paren
id|xconn_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic crosstalk functions, for use with all crosstalk providers&n; * and all crosstalk devices.&n; */
multiline_comment|/****** Generic crosstalk interrupt interfaces ******/
id|devfs_handle_t
DECL|function|xtalk_intr_dev_get
id|xtalk_intr_dev_get
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
r_return
(paren
id|xtalk_intr-&gt;xi_dev
)paren
suffix:semicolon
)brace
id|xwidgetnum_t
DECL|function|xtalk_intr_target_get
id|xtalk_intr_target_get
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
r_return
(paren
id|xtalk_intr-&gt;xi_target
)paren
suffix:semicolon
)brace
id|xtalk_intr_vector_t
DECL|function|xtalk_intr_vector_get
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
r_return
(paren
id|xtalk_intr-&gt;xi_vector
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|xtalk_intr_addr_get
id|xtalk_intr_addr_get
c_func
(paren
r_struct
id|xtalk_intr_s
op_star
id|xtalk_intr
)paren
(brace
r_return
(paren
id|xtalk_intr-&gt;xi_addr
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|xtalk_intr_sfarg_get
id|xtalk_intr_sfarg_get
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
r_return
(paren
id|xtalk_intr-&gt;xi_sfarg
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk pio interfaces ******/
id|devfs_handle_t
DECL|function|xtalk_pio_dev_get
id|xtalk_pio_dev_get
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
r_return
(paren
id|xtalk_piomap-&gt;xp_dev
)paren
suffix:semicolon
)brace
id|xwidgetnum_t
DECL|function|xtalk_pio_target_get
id|xtalk_pio_target_get
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
r_return
(paren
id|xtalk_piomap-&gt;xp_target
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|xtalk_pio_xtalk_addr_get
id|xtalk_pio_xtalk_addr_get
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
r_return
(paren
id|xtalk_piomap-&gt;xp_xtalk_addr
)paren
suffix:semicolon
)brace
id|ulong
DECL|function|xtalk_pio_mapsz_get
id|xtalk_pio_mapsz_get
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
r_return
(paren
id|xtalk_piomap-&gt;xp_mapsz
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|xtalk_pio_kvaddr_get
id|xtalk_pio_kvaddr_get
c_func
(paren
id|xtalk_piomap_t
id|xtalk_piomap
)paren
(brace
r_return
(paren
id|xtalk_piomap-&gt;xp_kvaddr
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk dma interfaces ******/
id|devfs_handle_t
DECL|function|xtalk_dma_dev_get
id|xtalk_dma_dev_get
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
)paren
(brace
r_return
(paren
id|xtalk_dmamap-&gt;xd_dev
)paren
suffix:semicolon
)brace
id|xwidgetnum_t
DECL|function|xtalk_dma_target_get
id|xtalk_dma_target_get
c_func
(paren
id|xtalk_dmamap_t
id|xtalk_dmamap
)paren
(brace
r_return
(paren
id|xtalk_dmamap-&gt;xd_target
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk widget information interfaces ******/
multiline_comment|/* xwidget_info_chk:&n; * check to see if this vertex is a widget;&n; * if so, return its widget_info (if any).&n; * if not, return NULL.&n; */
id|xwidget_info_t
DECL|function|xwidget_info_chk
id|xwidget_info_chk
c_func
(paren
id|devfs_handle_t
id|xwidget
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
id|hwgraph_info_get_LBL
c_func
(paren
id|xwidget
comma
id|INFO_LBL_XWIDGET
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info_t
)paren
id|ainfo
suffix:semicolon
)brace
id|xwidget_info_t
DECL|function|xwidget_info_get
id|xwidget_info_get
c_func
(paren
id|devfs_handle_t
id|xwidget
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
id|widget_info
op_assign
(paren
id|xwidget_info_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|xwidget
)paren
suffix:semicolon
macro_line|#ifdef&t;LATER
r_if
c_cond
(paren
(paren
id|widget_info
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|widget_info-&gt;w_fingerprint
op_ne
id|widget_info_fingerprint
)paren
)paren
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_PANIC
c_func
(paren
l_string|&quot;%v bad xwidget_info&quot;
comma
id|xwidget
)paren
suffix:semicolon
macro_line|#else
id|PRINT_PANIC
c_func
(paren
l_string|&quot;%x bad xwidget_info&quot;
comma
id|xwidget
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;/* LATER */
r_return
(paren
id|widget_info
)paren
suffix:semicolon
)brace
r_void
DECL|function|xwidget_info_set
id|xwidget_info_set
c_func
(paren
id|devfs_handle_t
id|xwidget
comma
id|xwidget_info_t
id|widget_info
)paren
(brace
r_if
c_cond
(paren
id|widget_info
op_ne
l_int|NULL
)paren
id|widget_info-&gt;w_fingerprint
op_assign
id|widget_info_fingerprint
suffix:semicolon
id|hwgraph_fastinfo_set
c_func
(paren
id|xwidget
comma
(paren
id|arbitrary_info_t
)paren
id|widget_info
)paren
suffix:semicolon
multiline_comment|/* Also, mark this vertex as an xwidget,&n;     * and use the widget_info, so xwidget_info_chk&n;     * can work (and be fairly efficient).&n;     */
id|hwgraph_info_add_LBL
c_func
(paren
id|xwidget
comma
id|INFO_LBL_XWIDGET
comma
(paren
id|arbitrary_info_t
)paren
id|widget_info
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|xwidget_info_dev_get
id|xwidget_info_dev_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_vertex
)paren
suffix:semicolon
)brace
id|xwidgetnum_t
DECL|function|xwidget_info_id_get
id|xwidget_info_id_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_id
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|xwidget_info_master_get
id|xwidget_info_master_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_master
)paren
suffix:semicolon
)brace
id|xwidgetnum_t
DECL|function|xwidget_info_masterid_get
id|xwidget_info_masterid_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_masterid
)paren
suffix:semicolon
)brace
id|xwidget_part_num_t
DECL|function|xwidget_info_part_num_get
id|xwidget_info_part_num_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_hwid.part_num
)paren
suffix:semicolon
)brace
id|xwidget_mfg_num_t
DECL|function|xwidget_info_mfg_num_get
id|xwidget_info_mfg_num_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget_info&quot;
)paren
suffix:semicolon
r_return
(paren
id|xwidget_info-&gt;w_hwid.mfg_num
)paren
suffix:semicolon
)brace
multiline_comment|/* Extract the widget name from the widget information&n; * for the xtalk widget.&n; */
r_char
op_star
DECL|function|xwidget_info_name_get
id|xwidget_info_name_get
c_func
(paren
id|xwidget_info_t
id|xwidget_info
)paren
(brace
r_if
c_cond
(paren
id|xwidget_info
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;null xwidget info&quot;
)paren
suffix:semicolon
r_return
id|xwidget_info-&gt;w_name
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk initialization interfaces ******/
multiline_comment|/*&n; * One-time initialization needed for systems that support crosstalk.&n; */
r_void
DECL|function|xtalk_init
id|xtalk_init
c_func
(paren
r_void
)paren
(brace
id|cdl_p
id|cp
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printf
c_func
(paren
l_string|&quot;xtalk_init&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate the registry.&n;     * We might already have one.&n;     * If we don&squot;t, go get one.&n;     * MPness: someone might have&n;     * set one up for us while we&n;     * were not looking; use an atomic&n;     * compare-and-swap to commit to&n;     * using the new registry if and&n;     * only if nobody else did first.&n;     * If someone did get there first,&n;     * toss the one we allocated back&n;     * into the pool.&n;     */
r_if
c_cond
(paren
id|xtalk_registry
op_eq
l_int|NULL
)paren
(brace
id|cp
op_assign
id|cdl_new
c_func
(paren
id|EDGE_LBL_XIO
comma
l_string|&quot;part&quot;
comma
l_string|&quot;mfgr&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|xtalk_registry
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|cp
)paren
)paren
(brace
id|cdl_del
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|xtalk_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate a set of xtalk_provider functions with a vertex.&n; */
r_void
DECL|function|xtalk_provider_register
id|xtalk_provider_register
c_func
(paren
id|devfs_handle_t
id|provider
comma
id|xtalk_provider_t
op_star
id|xtalk_fns
)paren
(brace
id|hwgraph_fastinfo_set
c_func
(paren
id|provider
comma
(paren
id|arbitrary_info_t
)paren
id|xtalk_fns
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate a set of xtalk_provider functions with a vertex.&n; */
r_void
DECL|function|xtalk_provider_unregister
id|xtalk_provider_unregister
c_func
(paren
id|devfs_handle_t
id|provider
)paren
(brace
id|hwgraph_fastinfo_set
c_func
(paren
id|provider
comma
(paren
id|arbitrary_info_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain a pointer to the xtalk_provider functions for a specified Crosstalk&n; * provider.&n; */
id|xtalk_provider_t
op_star
DECL|function|xtalk_provider_fns_get
id|xtalk_provider_fns_get
c_func
(paren
id|devfs_handle_t
id|provider
)paren
(brace
r_return
(paren
(paren
id|xtalk_provider_t
op_star
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|provider
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Announce a driver for a particular crosstalk part.&n; * Returns 0 on success or -1 on failure.  Failure occurs if the&n; * specified hardware already has a driver.&n; */
multiline_comment|/*ARGSUSED4 */
r_int
DECL|function|xwidget_driver_register
id|xwidget_driver_register
c_func
(paren
id|xwidget_part_num_t
id|part_num
comma
id|xwidget_mfg_num_t
id|mfg_num
comma
r_char
op_star
id|driver_prefix
comma
r_int
id|flags
)paren
(brace
multiline_comment|/* a driver&squot;s init routine could call&n;     * xwidget_driver_register before the&n;     * system calls xtalk_init; so, we&n;     * make the call here.&n;     */
r_if
c_cond
(paren
id|xtalk_registry
op_eq
l_int|NULL
)paren
id|xtalk_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|cdl_add_driver
c_func
(paren
id|xtalk_registry
comma
id|part_num
comma
id|mfg_num
comma
id|driver_prefix
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Inform xtalk infrastructure that a driver is no longer available for&n; * handling any widgets.&n; */
r_void
DECL|function|xwidget_driver_unregister
id|xwidget_driver_unregister
c_func
(paren
r_char
op_star
id|driver_prefix
)paren
(brace
multiline_comment|/* before a driver calls unregister,&n;     * it must have called registger; so we&n;     * can assume we have a registry here.&n;     */
id|ASSERT
c_func
(paren
id|xtalk_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cdl_del_driver
c_func
(paren
id|xtalk_registry
comma
id|driver_prefix
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Call some function with each vertex that&n; * might be one of this driver&squot;s attach points.&n; */
r_void
DECL|function|xtalk_iterate
id|xtalk_iterate
c_func
(paren
r_char
op_star
id|driver_prefix
comma
id|xtalk_iter_f
op_star
id|func
)paren
(brace
id|ASSERT
c_func
(paren
id|xtalk_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cdl_iterate
c_func
(paren
id|xtalk_registry
comma
id|driver_prefix
comma
(paren
id|cdl_iter_f
op_star
)paren
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xwidget_register:&n; *&t;Register a xtalk device (xwidget) by doing the following.&n; *      -allocate and initialize xwidget_info data&n; *      -allocate a hwgraph vertex with name based on widget number (id)&n; *      -look up the widget&squot;s initialization function and call it,&n; *      or remember the vertex for later initialization.&n; *&n; */
r_int
DECL|function|xwidget_register
id|xwidget_register
c_func
(paren
id|xwidget_hwid_t
id|hwid
comma
multiline_comment|/* widget&squot;s hardware ID */
id|devfs_handle_t
id|widget
comma
multiline_comment|/* widget to initialize */
id|xwidgetnum_t
id|id
comma
multiline_comment|/* widget&squot;s target id (0..f) */
id|devfs_handle_t
id|master
comma
multiline_comment|/* widget&squot;s master vertex */
id|xwidgetnum_t
id|targetid
comma
multiline_comment|/* master&squot;s target id (9/a) */
id|async_attach_t
id|aa
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
r_char
op_star
id|s
comma
id|devnm
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
multiline_comment|/* Allocate widget_info and associate it with widget vertex */
id|NEW
c_func
(paren
id|widget_info
)paren
suffix:semicolon
multiline_comment|/* Initialize widget_info */
id|widget_info-&gt;w_vertex
op_assign
id|widget
suffix:semicolon
id|widget_info-&gt;w_id
op_assign
id|id
suffix:semicolon
id|widget_info-&gt;w_master
op_assign
id|master
suffix:semicolon
id|widget_info-&gt;w_masterid
op_assign
id|targetid
suffix:semicolon
id|widget_info-&gt;w_hwid
op_assign
op_star
id|hwid
suffix:semicolon
multiline_comment|/* structure copy */
id|widget_info-&gt;w_efunc
op_assign
l_int|0
suffix:semicolon
id|widget_info-&gt;w_einfo
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * get the name of this xwidget vertex and keep the info.&n;     * This is needed during errors and interrupts, but as&n;     * long as we have it, we can use it elsewhere.&n;     */
id|s
op_assign
id|dev_to_name
c_func
(paren
id|widget
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|widget_info-&gt;w_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|widget_info-&gt;w_name
comma
id|s
)paren
suffix:semicolon
id|xwidget_info_set
c_func
(paren
id|widget
comma
id|widget_info
)paren
suffix:semicolon
id|device_master_set
c_func
(paren
id|widget
comma
id|master
)paren
suffix:semicolon
multiline_comment|/* All the driver init routines (including&n;     * xtalk_init) are called before we get into&n;     * attaching devices, so we can assume we&n;     * have a registry here.&n;     */
id|ASSERT
c_func
(paren
id|xtalk_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &n;     * Add pointer to async attach info -- tear down will be done when&n;     * the particular descendant is done with the info.&n;     */
r_if
c_cond
(paren
id|aa
)paren
id|async_attach_add_info
c_func
(paren
id|widget
comma
id|aa
)paren
suffix:semicolon
r_return
id|cdl_add_connpt
c_func
(paren
id|xtalk_registry
comma
id|hwid-&gt;part_num
comma
id|hwid-&gt;mfg_num
comma
id|widget
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xwidget_unregister :&n; *&t;Unregister the xtalk device and detach all its hwgraph namespace.&n; */
r_int
DECL|function|xwidget_unregister
id|xwidget_unregister
c_func
(paren
id|devfs_handle_t
id|widget
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
id|xwidget_hwid_t
id|hwid
suffix:semicolon
multiline_comment|/* Make sure that we have valid widget information initialized */
r_if
c_cond
(paren
op_logical_neg
(paren
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|widget
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Remove the inventory information associated&n;     * with the widget.&n;     */
id|hwgraph_inventory_remove
c_func
(paren
id|widget
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|hwid
op_assign
op_amp
(paren
id|widget_info-&gt;w_hwid
)paren
suffix:semicolon
id|cdl_del_connpt
c_func
(paren
id|xtalk_registry
comma
id|hwid-&gt;part_num
comma
id|hwid-&gt;mfg_num
comma
id|widget
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clean out the xwidget information */
(paren
r_void
)paren
id|kfree
c_func
(paren
id|widget_info-&gt;w_name
)paren
suffix:semicolon
id|BZERO
c_func
(paren
(paren
r_void
op_star
)paren
id|widget_info
comma
r_sizeof
(paren
id|widget_info
)paren
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|widget_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xwidget_error_register
id|xwidget_error_register
c_func
(paren
id|devfs_handle_t
id|xwidget
comma
id|error_handler_f
op_star
id|efunc
comma
id|error_handler_arg_t
id|einfo
)paren
(brace
id|xwidget_info_t
id|xwidget_info
suffix:semicolon
id|xwidget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|xwidget
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xwidget_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xwidget_info-&gt;w_efunc
op_assign
id|efunc
suffix:semicolon
id|xwidget_info-&gt;w_einfo
op_assign
id|einfo
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a link reset to a widget.&n; */
r_void
DECL|function|xwidget_reset
id|xwidget_reset
c_func
(paren
id|devfs_handle_t
id|xwidget
)paren
(brace
id|xswitch_reset_link
c_func
(paren
id|xwidget
)paren
suffix:semicolon
)brace
r_void
DECL|function|xwidget_gfx_reset
id|xwidget_gfx_reset
c_func
(paren
id|devfs_handle_t
id|xwidget
)paren
(brace
id|xwidget_info_t
id|info
suffix:semicolon
id|xswitch_reset_link
c_func
(paren
id|xwidget
)paren
suffix:semicolon
id|info
op_assign
id|xwidget_info_get
c_func
(paren
id|xwidget
)paren
suffix:semicolon
macro_line|#ifdef LATER
id|ASSERT_ALWAYS
c_func
(paren
id|info
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Enable this for other architectures once we add widget_reset to the&n;     * xtalk provider interface.&n;     */
id|DEV_FUNC
c_func
(paren
id|xtalk_provider
comma
id|widget_reset
)paren
(paren
id|xwidget_info_master_get
c_func
(paren
id|info
)paren
comma
id|xwidget_info_id_get
c_func
(paren
id|info
)paren
)paren
suffix:semicolon
)brace
DECL|macro|ANON_XWIDGET_NAME
mdefine_line|#define ANON_XWIDGET_NAME&t;&quot;No Name&quot;&t;/* Default Widget Name */
multiline_comment|/* Get the canonical hwgraph  name of xtalk widget */
r_char
op_star
DECL|function|xwidget_name_get
id|xwidget_name_get
c_func
(paren
id|devfs_handle_t
id|xwidget_vhdl
)paren
(brace
id|xwidget_info_t
id|info
suffix:semicolon
multiline_comment|/* If we have a bogus widget handle then return&n;&t; * a default anonymous widget name.&n;&t; */
r_if
c_cond
(paren
id|xwidget_vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
r_return
id|ANON_XWIDGET_NAME
suffix:semicolon
multiline_comment|/* Read the widget name stored in the widget info&n;&t; * for the widget setup during widget initialization.&n;&t; */
id|info
op_assign
id|xwidget_info_get
c_func
(paren
id|xwidget_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|xwidget_info_name_get
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xtalk_device_shutdown&n; *&t;Disable  the specified xtalk widget and clean out all the software&n; *&t;state associated with it.&n; */
r_int
DECL|function|xtalk_device_shutdown
id|xtalk_device_shutdown
c_func
(paren
id|devfs_handle_t
id|xbus_vhdl
comma
id|xwidgetnum_t
id|widget
)paren
(brace
id|devfs_handle_t
id|widget_vhdl
suffix:semicolon
r_char
id|edge_name
(braket
l_int|8
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|edge_name
comma
l_string|&quot;%d&quot;
comma
id|widget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xbus_vhdl
comma
id|edge_name
comma
op_amp
id|widget_vhdl
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
l_int|1
suffix:semicolon
id|xwidget_unregister
c_func
(paren
id|widget_vhdl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xtalk_device_inquiry&n; *&t;Find out hardware information about the xtalk widget.&n; */
r_int
DECL|function|xtalk_device_inquiry
id|xtalk_device_inquiry
c_func
(paren
id|devfs_handle_t
id|xbus_vhdl
comma
id|xwidgetnum_t
id|widget
)paren
(brace
r_extern
r_void
id|hub_device_inquiry
c_func
(paren
id|devfs_handle_t
comma
id|xwidgetnum_t
)paren
suffix:semicolon
id|hub_device_inquiry
c_func
(paren
id|xbus_vhdl
comma
id|widget
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
