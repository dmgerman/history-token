multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; *  hcl - SGI&squot;s Hardware Graph compatibility layer.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;linux/devfs_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
DECL|macro|HCL_NAME
mdefine_line|#define HCL_NAME &quot;SGI-HWGRAPH COMPATIBILITY DRIVER&quot;
DECL|macro|HCL_TEMP_NAME
mdefine_line|#define HCL_TEMP_NAME &quot;HCL_TEMP_NAME_USED_FOR_HWGRAPH_VERTEX_CREATE&quot;
DECL|macro|HCL_TEMP_NAME_LEN
mdefine_line|#define HCL_TEMP_NAME_LEN 44 
DECL|macro|HCL_VERSION
mdefine_line|#define HCL_VERSION &quot;1.0&quot;
DECL|variable|hwgraph_root
id|devfs_handle_t
id|hwgraph_root
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|linux_busnum
id|devfs_handle_t
id|linux_busnum
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Debug flag definition.&n; */
DECL|macro|OPTION_NONE
mdefine_line|#define OPTION_NONE             0x00
DECL|macro|HCL_DEBUG_NONE
mdefine_line|#define HCL_DEBUG_NONE 0x00000
DECL|macro|HCL_DEBUG_ALL
mdefine_line|#define HCL_DEBUG_ALL  0x0ffff
macro_line|#if defined(CONFIG_HCL_DEBUG)
DECL|variable|__initdata
r_static
r_int
r_int
id|hcl_debug_init
id|__initdata
op_assign
id|HCL_DEBUG_NONE
suffix:semicolon
macro_line|#endif
DECL|variable|hcl_debug
r_static
r_int
r_int
id|hcl_debug
op_assign
id|HCL_DEBUG_NONE
suffix:semicolon
macro_line|#if defined(CONFIG_HCL_DEBUG) &amp;&amp; !defined(MODULE)
DECL|variable|boot_options
r_static
r_int
r_int
id|boot_options
op_assign
id|OPTION_NONE
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Some Global definitions.&n; */
DECL|variable|hcl_spinlock
id|spinlock_t
id|hcl_spinlock
suffix:semicolon
DECL|variable|hcl_handle
id|devfs_handle_t
id|hcl_handle
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|invplace_none
id|invplace_t
id|invplace_none
op_assign
(brace
id|GRAPH_VERTEX_NONE
comma
id|GRAPH_VERTEX_PLACE_NONE
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * HCL device driver.&n; * The purpose of this device driver is to provide a facility &n; * for User Level Apps e.g. hinv, ioconfig etc. an ioctl path &n; * to manipulate label entries without having to implement&n; * system call interfaces.  This methodology will enable us to &n; * make this feature module loadable.&n; */
DECL|function|hcl_open
r_static
r_int
id|hcl_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|hcl_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hcl_open called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hcl_close
r_static
r_int
id|hcl_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|hcl_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hcl_close called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hcl_ioctl
r_static
r_int
id|hcl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
id|hcl_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hcl_ioctl called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|hcl_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hcl_ioctl cmd = 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hcl_fops
r_struct
id|file_operations
id|hcl_fops
op_assign
(brace
(paren
r_struct
id|module
op_star
)paren
l_int|0
comma
l_int|NULL
comma
multiline_comment|/* lseek - default */
l_int|NULL
comma
multiline_comment|/* read - general block-dev read */
l_int|NULL
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* poll */
id|hcl_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|hcl_open
comma
multiline_comment|/* open */
l_int|NULL
comma
multiline_comment|/* flush */
id|hcl_close
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* lock */
l_int|NULL
comma
multiline_comment|/* readv */
l_int|NULL
comma
multiline_comment|/* writev */
)brace
suffix:semicolon
multiline_comment|/*&n; * init_hcl() - Boot time initialization.  Ensure that it is called &n; *&t;after devfs has been initialized.&n; *&n; * For now this routine is being called out of devfs/base.c.  Actually &n; * Not a bad place to be ..&n; *&n; */
macro_line|#ifdef MODULE
r_int
id|init_module
(paren
r_void
)paren
macro_line|#else
DECL|function|init_hcl
r_int
id|__init
id|init_hcl
c_func
(paren
r_void
)paren
macro_line|#endif
(brace
r_extern
r_void
id|string_table_init
c_func
(paren
r_struct
id|string_table
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|string_table
id|label_string_table
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_HCL_DEBUG) &amp;&amp; !defined(MODULE)
id|printk
(paren
l_string|&quot;&bslash;n%s: v%s Colin Ngam (cngam@sgi.com)&bslash;n&quot;
comma
id|HCL_NAME
comma
id|HCL_VERSION
)paren
suffix:semicolon
id|hcl_debug
op_assign
id|hcl_debug_init
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: hcl_debug: 0x%0x&bslash;n&quot;
comma
id|HCL_NAME
comma
id|hcl_debug
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n%s: boot_options: 0x%0x&bslash;n&quot;
comma
id|HCL_NAME
comma
id|boot_options
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|hcl_spinlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the hwgraph_root on devfs.&n;&t; */
id|rv
op_assign
id|hwgraph_path_add
c_func
(paren
l_int|NULL
comma
l_string|&quot;hw&quot;
comma
op_amp
id|hwgraph_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|printk
(paren
l_string|&quot;WARNING: init_hcl: Failed to create hwgraph_root. Error = %d.&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the hcl driver to support inventory entry manipulations.&n;&t; * By default, it is expected that devfs is mounted on /dev.&n;&t; *&n;&t; */
id|hcl_handle
op_assign
id|hwgraph_register
c_func
(paren
id|hwgraph_root
comma
l_string|&quot;.hcl&quot;
comma
l_int|0
comma
id|DEVFS_FL_AUTO_DEVNUM
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
op_amp
id|hcl_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcl_handle
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;HCL: Unable to create HCL Driver in init_hcl().&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize the HCL string table.&n;&t; */
id|string_table_init
c_func
(paren
op_amp
id|label_string_table
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the directory that links Linux bus numbers to our Xwidget.&n;&t; */
id|rv
op_assign
id|hwgraph_path_add
c_func
(paren
id|hwgraph_root
comma
l_string|&quot;linux/busnum&quot;
comma
op_amp
id|linux_busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linux_busnum
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;HCL: Unable to create hw/linux/busnum&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hcl_setup() - Process boot time parameters if given.&n; *&t;&quot;hcl=&quot;&n; *&t;This routine gets called only if &quot;hcl=&quot; is given in the &n; *&t;boot line and before init_hcl().&n; *&n; *&t;We currently do not have any boot options .. when we do, &n; *&t;functionalities can be added here.&n; *&n; */
DECL|function|hcl_setup
r_static
r_int
id|__init
id|hcl_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
op_logical_neg
id|isspace
(paren
op_star
id|str
)paren
)paren
(brace
macro_line|#ifdef CONFIG_HCL_DEBUG
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;all&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|hcl_debug_init
op_or_assign
id|HCL_DEBUG_ALL
suffix:semicolon
id|str
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;,&squot;
)paren
r_return
l_int|0
suffix:semicolon
op_increment
id|str
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;hcl=&quot;
comma
id|hcl_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * Set device specific &quot;fast information&quot;.&n; *&n; */
r_void
DECL|function|hwgraph_fastinfo_set
id|hwgraph_fastinfo_set
c_func
(paren
id|devfs_handle_t
id|de
comma
id|arbitrary_info_t
id|fastinfo
)paren
(brace
r_if
c_cond
(paren
id|hcl_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hwgraph_fastinfo_set handle 0x%p fastinfo %ld&bslash;n&quot;
comma
id|de
comma
id|fastinfo
)paren
suffix:semicolon
)brace
id|labelcl_info_replace_IDX
c_func
(paren
id|de
comma
id|HWGRAPH_FASTINFO
comma
id|fastinfo
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get device specific &quot;fast information&quot;.&n; *&n; */
id|arbitrary_info_t
DECL|function|hwgraph_fastinfo_get
id|hwgraph_fastinfo_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
id|arbitrary_info_t
id|fastinfo
suffix:semicolon
r_int
id|rv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HCL: hwgraph_fastinfo_get handle given is NULL.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|rv
op_assign
id|labelcl_info_get_IDX
c_func
(paren
id|de
comma
id|HWGRAPH_FASTINFO
comma
op_amp
id|fastinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
r_return
id|fastinfo
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_connectpt_set - Sets the connect point handle in de to the &n; *&t;given connect_de handle.  By default, the connect point of the &n; *&t;devfs node is the parent.  This effectively changes this assumption.&n; */
r_int
DECL|function|hwgraph_connectpt_set
id|hwgraph_connectpt_set
c_func
(paren
id|devfs_handle_t
id|de
comma
id|devfs_handle_t
id|connect_de
)paren
(brace
r_int
id|rv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|rv
op_assign
id|labelcl_info_connectpt_set
c_func
(paren
id|de
comma
id|connect_de
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_connectpt_get: Returns the entry&squot;s connect point  in the devfs &n; *&t;tree.&n; */
id|devfs_handle_t
DECL|function|hwgraph_connectpt_get
id|hwgraph_connectpt_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_int
id|rv
suffix:semicolon
id|arbitrary_info_t
id|info
suffix:semicolon
id|devfs_handle_t
id|connect
suffix:semicolon
id|rv
op_assign
id|labelcl_info_get_IDX
c_func
(paren
id|de
comma
id|HWGRAPH_CONNECTPT
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|connect
op_assign
(paren
id|devfs_handle_t
)paren
id|info
suffix:semicolon
r_return
id|connect
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_mk_dir - Creates a directory entry with devfs.&n; *&t;Note that a directory entry in devfs can have children &n; *&t;but it cannot be a char|block special file.&n; */
id|devfs_handle_t
DECL|function|hwgraph_mk_dir
id|hwgraph_mk_dir
c_func
(paren
id|devfs_handle_t
id|de
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|rv
suffix:semicolon
id|labelcl_info_t
op_star
id|labelcl_info
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|new_devfs_handle
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|parent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Create the device info structure for hwgraph compatiblity support.&n;&t; */
id|labelcl_info
op_assign
id|labelcl_info_create
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|labelcl_info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Create a devfs entry.&n;&t; */
id|new_devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
id|de
comma
id|name
comma
(paren
r_void
op_star
)paren
id|labelcl_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_devfs_handle
)paren
(brace
id|labelcl_info_destroy
c_func
(paren
id|labelcl_info
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the parent handle.&n;&t; */
id|parent
op_assign
id|devfs_get_parent
(paren
id|new_devfs_handle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To provide the same semantics as the hwgraph, set the connect point.&n;&t; */
id|rv
op_assign
id|hwgraph_connectpt_set
c_func
(paren
id|new_devfs_handle
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to clean up!&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * If the caller provides a private data pointer, save it in the &n;&t; * labelcl info structure(fastinfo).  This can be retrieved via&n;&t; * hwgraph_fastinfo_get()&n;&t; */
r_if
c_cond
(paren
id|info
)paren
id|hwgraph_fastinfo_set
c_func
(paren
id|new_devfs_handle
comma
(paren
id|arbitrary_info_t
)paren
id|info
)paren
suffix:semicolon
r_return
id|new_devfs_handle
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_vertex_create - Create a vertex by giving it a temp name.&n; */
multiline_comment|/*&n; * hwgraph_path_add - Create a directory node with the given path starting &n; * from the given devfs_handle_t.&n; */
r_extern
r_char
op_star
id|dev_to_name
c_func
(paren
id|devfs_handle_t
comma
r_char
op_star
comma
id|uint
)paren
suffix:semicolon
r_int
DECL|function|hwgraph_path_add
id|hwgraph_path_add
c_func
(paren
id|devfs_handle_t
id|fromv
comma
r_char
op_star
id|path
comma
id|devfs_handle_t
op_star
id|new_de
)paren
(brace
r_int
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * We need to handle the case when fromv is NULL ..&n;&t; * in this case we need to create the path from the &n;&t; * hwgraph root!&n;&t; */
r_if
c_cond
(paren
id|fromv
op_eq
l_int|NULL
)paren
id|fromv
op_assign
id|hwgraph_root
suffix:semicolon
multiline_comment|/*&n;&t; * check the entry doesn&squot;t already exist, if it does&n;&t; * then we simply want new_de to point to it (otherwise&n;&t; * we&squot;ll overwrite the existing labelcl_info struct)&n;&t; */
id|rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|fromv
comma
id|path
comma
id|new_de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* couldn&squot;t find entry so we create it */
op_star
id|new_de
op_assign
id|hwgraph_mk_dir
c_func
(paren
id|fromv
comma
id|path
comma
id|namelen
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_de
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_register  - Creates a file entry with devfs.&n; *&t;Note that a file entry cannot have children .. it is like a &n; *&t;char|block special vertex in hwgraph.&n; */
id|devfs_handle_t
DECL|function|hwgraph_register
id|hwgraph_register
c_func
(paren
id|devfs_handle_t
id|de
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor
comma
id|umode_t
id|mode
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
r_struct
id|file_operations
op_star
id|fops
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|rv
suffix:semicolon
r_void
op_star
id|labelcl_info
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|new_devfs_handle
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|parent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;         * Create the labelcl info structure for hwgraph compatiblity support.&n;         */
id|labelcl_info
op_assign
id|labelcl_info_create
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|labelcl_info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;         * Create a devfs entry.&n;         */
id|new_devfs_handle
op_assign
id|devfs_register
c_func
(paren
id|de
comma
id|name
comma
id|flags
comma
id|major
comma
id|minor
comma
id|mode
comma
id|fops
comma
id|labelcl_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_devfs_handle
)paren
(brace
id|labelcl_info_destroy
c_func
(paren
(paren
id|labelcl_info_t
op_star
)paren
id|labelcl_info
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the parent handle.&n;&t; */
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
id|parent
op_assign
id|devfs_get_parent
(paren
id|new_devfs_handle
)paren
suffix:semicolon
r_else
id|parent
op_assign
id|de
suffix:semicolon
multiline_comment|/*&n;&t; * To provide the same semantics as the hwgraph, set the connect point.&n;&t; */
id|rv
op_assign
id|hwgraph_connectpt_set
c_func
(paren
id|new_devfs_handle
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to clean up!&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HCL: Unable to set the connect point to it&squot;s parent 0x%p&bslash;n&quot;
comma
id|new_devfs_handle
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * If the caller provides a private data pointer, save it in the &n;         * labelcl info structure(fastinfo).  This can be retrieved via&n;         * hwgraph_fastinfo_get()&n;         */
r_if
c_cond
(paren
id|info
)paren
id|hwgraph_fastinfo_set
c_func
(paren
id|new_devfs_handle
comma
(paren
id|arbitrary_info_t
)paren
id|info
)paren
suffix:semicolon
r_return
id|new_devfs_handle
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_mk_symlink - Create a symbolic link.&n; */
r_int
DECL|function|hwgraph_mk_symlink
id|hwgraph_mk_symlink
c_func
(paren
id|devfs_handle_t
id|de
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|link
comma
r_int
r_int
id|linklen
comma
id|devfs_handle_t
op_star
id|handle
comma
r_void
op_star
id|info
)paren
(brace
r_void
op_star
id|labelcl_info
op_assign
l_int|NULL
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|devfs_handle_t
id|new_devfs_handle
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Create the labelcl info structure for hwgraph compatiblity support.&n;&t; */
id|labelcl_info
op_assign
id|labelcl_info_create
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|labelcl_info
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Create a symbolic link devfs entry.&n;&t; */
id|status
op_assign
id|devfs_mk_symlink
c_func
(paren
id|de
comma
id|name
comma
id|flags
comma
id|link
comma
op_amp
id|new_devfs_handle
comma
id|labelcl_info
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|new_devfs_handle
)paren
op_logical_or
(paren
op_logical_neg
id|status
)paren
)paren
(brace
id|labelcl_info_destroy
c_func
(paren
(paren
id|labelcl_info_t
op_star
)paren
id|labelcl_info
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the caller provides a private data pointer, save it in the &n;&t; * labelcl info structure(fastinfo).  This can be retrieved via&n;&t; * hwgraph_fastinfo_get()&n;&t; */
r_if
c_cond
(paren
id|info
)paren
id|hwgraph_fastinfo_set
c_func
(paren
id|new_devfs_handle
comma
(paren
id|arbitrary_info_t
)paren
id|info
)paren
suffix:semicolon
op_star
id|handle
op_assign
id|new_devfs_handle
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_vertex_get_next - this routine returns the next sibbling for the &n; *&t;device entry given in de.  If there are no more sibbling, NULL &n; * &t;is returned in next_sibbling.&n; *&n; *&t;Currently we do not have any protection against de being deleted &n; *&t;while it&squot;s handle is being held.&n; */
r_int
DECL|function|hwgraph_vertex_get_next
id|hwgraph_vertex_get_next
c_func
(paren
id|devfs_handle_t
op_star
id|next_sibbling
comma
id|devfs_handle_t
op_star
id|de
)paren
(brace
op_star
id|next_sibbling
op_assign
id|devfs_get_next_sibling
(paren
op_star
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|next_sibbling
op_ne
l_int|NULL
)paren
op_star
id|de
op_assign
op_star
id|next_sibbling
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_vertex_destroy - Destroy the devfs entry&n; */
r_int
DECL|function|hwgraph_vertex_destroy
id|hwgraph_vertex_destroy
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_void
op_star
id|labelcl_info
op_assign
l_int|NULL
suffix:semicolon
id|labelcl_info
op_assign
id|devfs_get_info
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|labelcl_info
)paren
id|labelcl_info_destroy
c_func
(paren
(paren
id|labelcl_info_t
op_star
)paren
id|labelcl_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** See if a vertex has an outgoing edge with a specified name.&n;** Vertices in the hwgraph *implicitly* contain these edges:&n;**&t;&quot;.&quot; &t;refers to &quot;current vertex&quot;&n;**&t;&quot;..&quot; &t;refers to &quot;connect point vertex&quot;&n;**&t;&quot;char&quot;&t;refers to current vertex (character device access)&n;**&t;&quot;block&quot;&t;refers to current vertex (block device access)&n;*/
multiline_comment|/*&n; * hwgraph_edge_add - This routines has changed from the original conext.&n; * All it does now is to create a symbolic link from &quot;from&quot; to &quot;to&quot;.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_edge_add
id|hwgraph_edge_add
c_func
(paren
id|devfs_handle_t
id|from
comma
id|devfs_handle_t
id|to
comma
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|path
suffix:semicolon
r_char
op_star
id|s1
suffix:semicolon
r_char
op_star
id|index
suffix:semicolon
r_int
id|name_start
suffix:semicolon
id|devfs_handle_t
id|handle
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rv
suffix:semicolon
r_int
id|i
comma
id|count
suffix:semicolon
id|path
op_assign
id|kmalloc
c_func
(paren
l_int|1024
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0x0
comma
l_int|1024
)paren
suffix:semicolon
id|name_start
op_assign
id|devfs_generate_path
(paren
id|from
comma
id|path
comma
l_int|1024
)paren
suffix:semicolon
id|s1
op_assign
op_amp
id|path
(braket
id|name_start
)braket
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|index
op_assign
id|strstr
(paren
id|s1
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
)paren
(brace
id|count
op_increment
suffix:semicolon
id|s1
op_assign
op_increment
id|index
suffix:semicolon
)brace
r_else
(brace
id|count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|path
comma
l_int|0x0
comma
l_int|1024
)paren
suffix:semicolon
id|name_start
op_assign
id|devfs_generate_path
(paren
id|to
comma
id|path
comma
l_int|1024
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|strcat
c_func
(paren
id|path
comma
l_string|&quot;../&quot;
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|path
comma
op_amp
id|path
(braket
id|name_start
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise, just create a symlink to the vertex.&n;&t; * In this case the vertex was previous created with a REAL pathname.&n;&t; */
id|rv
op_assign
id|devfs_mk_symlink
(paren
id|from
comma
(paren
r_const
r_char
op_star
)paren
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|path
comma
op_amp
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
id|name_start
op_assign
id|devfs_generate_path
(paren
id|handle
comma
id|path
comma
l_int|1024
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_edge_get
id|hwgraph_edge_get
c_func
(paren
id|devfs_handle_t
id|from
comma
r_char
op_star
id|name
comma
id|devfs_handle_t
op_star
id|toptr
)paren
(brace
r_int
id|namelen
op_assign
l_int|0
suffix:semicolon
id|devfs_handle_t
id|target_handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|toptr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the name is &quot;.&quot; just return the current devfs entry handle.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|HWGRAPH_EDGELBL_DOT
)paren
)paren
(brace
r_if
c_cond
(paren
id|toptr
)paren
(brace
op_star
id|toptr
op_assign
id|from
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|HWGRAPH_EDGELBL_DOTDOT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Hmmm .. should we return the connect point or parent ..&n;&t;&t; * see in hwgraph, the concept of parent is the connectpt!&n;&t;&t; *&n;&t;&t; * Maybe we should see whether the connectpt is set .. if &n;&t;&t; * not just return the parent!&n;&t;&t; */
id|target_handle
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target_handle
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Just return the connect point.&n;&t;&t;&t; */
op_star
id|toptr
op_assign
id|target_handle
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|target_handle
op_assign
id|devfs_get_parent
c_func
(paren
id|from
)paren
suffix:semicolon
op_star
id|toptr
op_assign
id|target_handle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Call devfs to get the devfs entry.&n;&t;&t; */
id|namelen
op_assign
(paren
r_int
)paren
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|target_handle
op_assign
id|devfs_find_handle
(paren
id|from
comma
id|name
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Yes traverse symbolic links */
r_if
c_cond
(paren
id|target_handle
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
op_star
id|toptr
op_assign
id|target_handle
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_edge_get_next - Retrieves the next sibbling given the current&n; *&t;entry number &quot;placeptr&quot;.&n; *&n; * &t;Allow the caller to retrieve walk through the sibblings of &quot;source&quot; &n; * &t;devfs_handle_t.  The implicit edges &quot;.&quot; and &quot;..&quot; is returned first &n; * &t;followed by each of the real children.&n; *&n; *&t;We may end up returning garbage if another thread perform any deletion &n; *&t;in this directory before &quot;placeptr&quot;.&n; *&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_edge_get_next
id|hwgraph_edge_get_next
c_func
(paren
id|devfs_handle_t
id|source
comma
r_char
op_star
id|name
comma
id|devfs_handle_t
op_star
id|target
comma
id|uint
op_star
id|placeptr
)paren
(brace
id|uint
id|which_place
suffix:semicolon
r_int
r_int
id|namelen
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|tempname
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|placeptr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|which_place
op_assign
op_star
id|placeptr
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
id|which_place
op_le
id|HWGRAPH_RESERVED_PLACES
)paren
(brace
r_if
c_cond
(paren
id|which_place
op_eq
id|EDGE_PLACE_WANT_CURRENT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Looking for &quot;.&quot;&n;&t;&t;&t; * Return the current devfs handle.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
id|strcpy
c_func
(paren
id|name
comma
id|HWGRAPH_EDGELBL_DOT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
l_int|NULL
)paren
(brace
op_star
id|target
op_assign
id|source
suffix:semicolon
multiline_comment|/* XXX should incr &quot;source&quot; ref count here if we&n;&t;&t;&t;&t; * ever implement ref counts */
)brace
)brace
r_else
r_if
c_cond
(paren
id|which_place
op_eq
id|EDGE_PLACE_WANT_CONNECTPT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Looking for the connect point or parent.&n;&t;&t;&t; * If the connect point is set .. it returns the connect point.&n;&t;&t;&t; * Otherwise, it returns the parent .. will we support &n;&t;&t;&t; * connect point?&n;&t;&t;&t; */
id|devfs_handle_t
id|connect_point
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|source
)paren
suffix:semicolon
r_if
c_cond
(paren
id|connect_point
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * No connectpoint set .. either the User&n;&t;&t;&t;&t; * explicitly NULL it or this node was not &n;&t;&t;&t;&t; * created via hcl.&n;&t;&t;&t;&t; */
id|which_place
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
id|strcpy
c_func
(paren
id|name
comma
id|HWGRAPH_EDGELBL_DOTDOT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
l_int|NULL
)paren
op_star
id|target
op_assign
id|connect_point
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|which_place
op_eq
id|EDGE_PLACE_WANT_REAL_EDGES
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * return first &quot;real&quot; entry in directory, and increment&n;&t;&t;&t; * placeptr.  Next time around we should have &n;&t;&t;&t; * which_place &gt; HWGRAPH_RESERVED_EDGES so we&squot;ll fall through&n;&t;&t;&t; * this nested if block.&n;&t;&t;&t; */
op_star
id|target
op_assign
id|devfs_get_first_child
c_func
(paren
id|source
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|target
op_logical_and
id|name
)paren
(brace
id|tempname
op_assign
id|devfs_get_name
c_func
(paren
op_star
id|target
comma
op_amp
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tempname
op_logical_and
id|namelen
)paren
id|strcpy
c_func
(paren
id|name
comma
id|tempname
)paren
suffix:semicolon
)brace
op_star
id|placeptr
op_assign
id|which_place
op_plus
l_int|1
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
op_star
id|placeptr
op_assign
id|which_place
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * walk linked list, (which_place - HWGRAPH_RESERVED_PLACES) times&n;&t; */
(brace
id|devfs_handle_t
id|curr
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|curr
op_assign
id|devfs_get_first_child
c_func
(paren
id|source
)paren
comma
id|i
op_assign
id|i
op_plus
id|HWGRAPH_RESERVED_PLACES
suffix:semicolon
id|curr
op_ne
l_int|NULL
op_logical_and
id|i
OL
id|which_place
suffix:semicolon
id|curr
op_assign
id|devfs_get_next_sibling
c_func
(paren
id|curr
)paren
comma
id|i
op_increment
)paren
suffix:semicolon
op_star
id|target
op_assign
id|curr
suffix:semicolon
op_star
id|placeptr
op_assign
id|which_place
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_logical_and
id|name
)paren
(brace
id|tempname
op_assign
id|devfs_get_name
c_func
(paren
op_star
id|target
comma
op_amp
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tempname
op_logical_and
id|namelen
)paren
id|strcpy
c_func
(paren
id|name
comma
id|tempname
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|target
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_add_LBL - Adds a new label for the device.  Mark the info_desc&n; *&t;of the label as INFO_DESC_PRIVATE and store the info in the label.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_add_LBL
id|hwgraph_info_add_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
id|arbitrary_info_t
id|info
)paren
(brace
r_return
id|labelcl_info_add_LBL
c_func
(paren
id|de
comma
id|name
comma
id|INFO_DESC_PRIVATE
comma
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_remove_LBL - Remove the label entry for the device.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_remove_LBL
id|hwgraph_info_remove_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
id|arbitrary_info_t
op_star
id|old_info
)paren
(brace
r_return
id|labelcl_info_remove_LBL
c_func
(paren
id|de
comma
id|name
comma
l_int|NULL
comma
id|old_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_replace_LBL - replaces an existing label with &n; *&t;a new label info value.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_replace_LBL
id|hwgraph_info_replace_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
id|arbitrary_info_t
id|info
comma
id|arbitrary_info_t
op_star
id|old_info
)paren
(brace
r_return
id|labelcl_info_replace_LBL
c_func
(paren
id|de
comma
id|name
comma
id|INFO_DESC_PRIVATE
comma
id|info
comma
l_int|NULL
comma
id|old_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_get_LBL - Get and return the info value in the label of the &n; * &t;device.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_get_LBL
id|hwgraph_info_get_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
id|arbitrary_info_t
op_star
id|infop
)paren
(brace
r_return
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|name
comma
l_int|NULL
comma
id|infop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_get_exported_LBL - Retrieve the info_desc and info pointer &n; *&t;of the given label for the device.  The weird thing is that the label &n; *&t;that matches the name is return irrespective of the info_desc value!&n; *&t;Do not understand why the word &quot;exported&quot; is used!&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_get_exported_LBL
id|hwgraph_info_get_exported_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
r_int
op_star
id|export_info
comma
id|arbitrary_info_t
op_star
id|infop
)paren
(brace
r_int
id|rc
suffix:semicolon
id|arb_info_desc_t
id|info_desc
suffix:semicolon
id|rc
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|name
comma
op_amp
id|info_desc
comma
id|infop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
op_star
id|export_info
op_assign
(paren
r_int
)paren
id|info_desc
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_get_next_LBL - Returns the next label info given the &n; *&t;current label entry in place.&n; *&n; *&t;Once again this has no locking or reference count for protection.&n; *&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_get_next_LBL
id|hwgraph_info_get_next_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|buf
comma
id|arbitrary_info_t
op_star
id|infop
comma
id|labelcl_info_place_t
op_star
id|place
)paren
(brace
r_return
id|labelcl_info_get_next_LBL
c_func
(paren
id|de
comma
id|buf
comma
l_int|NULL
comma
id|infop
comma
id|place
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_export_LBL - Retrieve the specified label entry and modify &n; *&t;the info_desc field with the given value in nbytes.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_export_LBL
id|hwgraph_info_export_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
comma
r_int
id|nbytes
)paren
(brace
id|arbitrary_info_t
id|info
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
op_eq
l_int|0
)paren
id|nbytes
op_assign
id|INFO_DESC_EXPORT
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|rc
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|name
comma
l_int|NULL
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|labelcl_info_replace_LBL
c_func
(paren
id|de
comma
id|name
comma
id|nbytes
comma
id|info
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_info_unexport_LBL - Retrieve the given label entry and change the &n; * label info_descr filed to INFO_DESC_PRIVATE.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|hwgraph_info_unexport_LBL
id|hwgraph_info_unexport_LBL
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|name
)paren
(brace
id|arbitrary_info_t
id|info
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|name
comma
l_int|NULL
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|labelcl_info_replace_LBL
c_func
(paren
id|de
comma
id|name
comma
id|INFO_DESC_PRIVATE
comma
id|info
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_path_lookup - return the handle for the given path.&n; *&n; */
r_int
DECL|function|hwgraph_path_lookup
id|hwgraph_path_lookup
c_func
(paren
id|devfs_handle_t
id|start_vertex_handle
comma
r_char
op_star
id|lookup_path
comma
id|devfs_handle_t
op_star
id|vertex_handle_ptr
comma
r_char
op_star
op_star
id|remainder
)paren
(brace
op_star
id|vertex_handle_ptr
op_assign
id|devfs_find_handle
c_func
(paren
id|start_vertex_handle
comma
multiline_comment|/* start dir */
id|lookup_path
comma
multiline_comment|/* path */
l_int|0
comma
multiline_comment|/* major */
l_int|0
comma
multiline_comment|/* minor */
l_int|0
comma
multiline_comment|/* char | block */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* traverse symlinks */
r_if
c_cond
(paren
op_star
id|vertex_handle_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_traverse - Find and return the devfs handle starting from de.&n; *&n; */
id|graph_error_t
DECL|function|hwgraph_traverse
id|hwgraph_traverse
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|path
comma
id|devfs_handle_t
op_star
id|found
)paren
(brace
multiline_comment|/* &n;&t; * get the directory entry (path should end in a directory)&n;&t; */
op_star
id|found
op_assign
id|devfs_find_handle
c_func
(paren
id|de
comma
multiline_comment|/* start dir */
id|path
comma
multiline_comment|/* path */
l_int|0
comma
multiline_comment|/* major */
l_int|0
comma
multiline_comment|/* minor */
l_int|0
comma
multiline_comment|/* char | block */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* traverse symlinks */
r_if
c_cond
(paren
op_star
id|found
op_eq
l_int|NULL
)paren
r_return
id|GRAPH_NOT_FOUND
suffix:semicolon
r_else
r_return
id|GRAPH_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_path_to_vertex - Return the devfs entry handle for the given &n; *&t;pathname .. assume traverse symlinks too!.&n; */
id|devfs_handle_t
DECL|function|hwgraph_path_to_vertex
id|hwgraph_path_to_vertex
c_func
(paren
r_char
op_star
id|path
)paren
(brace
r_return
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
multiline_comment|/* start dir */
id|path
comma
multiline_comment|/* path */
l_int|0
comma
multiline_comment|/* major */
l_int|0
comma
multiline_comment|/* minor */
l_int|0
comma
multiline_comment|/* char | block */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* traverse symlinks */
)brace
multiline_comment|/*&n; * hwgraph_path_to_dev - Returns the devfs_handle_t of the given path ..&n; *&t;We only deal with devfs handle and not devfs_handle_t.&n;*/
id|devfs_handle_t
DECL|function|hwgraph_path_to_dev
id|hwgraph_path_to_dev
c_func
(paren
r_char
op_star
id|path
)paren
(brace
id|devfs_handle_t
id|de
suffix:semicolon
id|de
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_block_device_get - return the handle of the block device file.&n; *&t;The assumption here is that de is a directory.&n;*/
id|devfs_handle_t
DECL|function|hwgraph_block_device_get
id|hwgraph_block_device_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_return
id|devfs_find_handle
c_func
(paren
id|de
comma
multiline_comment|/* start dir */
l_string|&quot;block&quot;
comma
multiline_comment|/* path */
l_int|0
comma
multiline_comment|/* major */
l_int|0
comma
multiline_comment|/* minor */
id|DEVFS_SPECIAL_BLK
comma
multiline_comment|/* char | block */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* traverse symlinks */
)brace
multiline_comment|/*&n; * hwgraph_char_device_get - return the handle of the char device file.&n; *      The assumption here is that de is a directory.&n;*/
id|devfs_handle_t
DECL|function|hwgraph_char_device_get
id|hwgraph_char_device_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_return
id|devfs_find_handle
c_func
(paren
id|de
comma
multiline_comment|/* start dir */
l_string|&quot;char&quot;
comma
multiline_comment|/* path */
l_int|0
comma
multiline_comment|/* major */
l_int|0
comma
multiline_comment|/* minor */
id|DEVFS_SPECIAL_CHR
comma
multiline_comment|/* char | block */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* traverse symlinks */
)brace
multiline_comment|/*&n; * hwgraph_cdevsw_get - returns the fops of the given devfs entry.&n; */
r_struct
id|file_operations
op_star
DECL|function|hwgraph_cdevsw_get
id|hwgraph_cdevsw_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_struct
id|file_operations
op_star
id|fops
op_assign
id|devfs_get_ops
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put_ops
c_func
(paren
id|de
)paren
suffix:semicolon
multiline_comment|/*  FIXME: this may need to be moved to callers  */
r_return
id|fops
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_bdevsw_get - returns the fops of the given devfs entry.&n;*/
r_struct
id|file_operations
op_star
multiline_comment|/*  FIXME: shouldn&squot;t this be a blkdev?  */
DECL|function|hwgraph_bdevsw_get
id|hwgraph_bdevsw_get
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_struct
id|file_operations
op_star
id|fops
op_assign
id|devfs_get_ops
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put_ops
c_func
(paren
id|de
)paren
suffix:semicolon
multiline_comment|/*  FIXME: this may need to be moved to callers  */
r_return
id|fops
suffix:semicolon
)brace
multiline_comment|/*&n;** Inventory is now associated with a vertex in the graph.  For items that&n;** belong in the inventory but have no vertex &n;** (e.g. old non-graph-aware drivers), we create a bogus vertex under the &n;** INFO_LBL_INVENT name.&n;**&n;** For historical reasons, we prevent exact duplicate entries from being added&n;** to a single vertex.&n;*/
multiline_comment|/*&n; * hwgraph_inventory_add - Adds an inventory entry into de.&n; */
r_int
DECL|function|hwgraph_inventory_add
id|hwgraph_inventory_add
c_func
(paren
id|devfs_handle_t
id|de
comma
r_int
r_class
comma
r_int
id|type
comma
id|major_t
id|controller
comma
id|minor_t
id|unit
comma
r_int
id|state
)paren
(brace
id|inventory_t
op_star
id|pinv
op_assign
l_int|NULL
comma
op_star
id|old_pinv
op_assign
l_int|NULL
comma
op_star
id|last_pinv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * Add our inventory data to the list of inventory data&n;&t; * associated with this vertex.&n;&t; */
id|again
suffix:colon
multiline_comment|/* GRAPH_LOCK_UPDATE(&amp;invent_lock); */
id|rv
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
l_int|NULL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|old_pinv
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_ne
id|LABELCL_SUCCESS
)paren
op_logical_and
(paren
id|rv
op_ne
id|LABELCL_NOT_FOUND
)paren
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/*&n;&t; * Seek to end of inventory items associated with this&n;&t; * vertex.  Along the way, make sure we&squot;re not duplicating&n;&t; * an inventory item (for compatibility with old add_to_inventory)&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|old_pinv
suffix:semicolon
id|last_pinv
op_assign
id|old_pinv
comma
id|old_pinv
op_assign
id|old_pinv-&gt;inv_next
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
r_class
op_ne
op_minus
l_int|1
op_logical_and
id|old_pinv-&gt;inv_class
op_ne
r_class
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|old_pinv-&gt;inv_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|state
op_ne
op_minus
l_int|1
op_logical_and
id|old_pinv-&gt;inv_state
op_ne
id|state
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|controller
op_ne
op_minus
l_int|1
op_logical_and
id|old_pinv-&gt;inv_controller
op_ne
id|controller
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|unit
op_ne
op_minus
l_int|1
op_logical_and
id|old_pinv-&gt;inv_unit
op_ne
id|unit
)paren
r_continue
suffix:semicolon
multiline_comment|/* exact duplicate of previously-added inventory item */
id|rv
op_assign
id|LABELCL_DUP
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* Not a duplicate, so we know that we need to add something. */
r_if
c_cond
(paren
id|pinv
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Release lock while we wait for memory. */
multiline_comment|/* GRAPH_LOCK_DONE_UPDATE(&amp;invent_lock); */
id|pinv
op_assign
(paren
id|inventory_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|inventory_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|replace_in_inventory
c_func
(paren
id|pinv
comma
r_class
comma
id|type
comma
id|controller
comma
id|unit
comma
id|state
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|pinv-&gt;inv_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_pinv
)paren
(brace
id|last_pinv-&gt;inv_next
op_assign
id|pinv
suffix:semicolon
)brace
r_else
(brace
id|rv
op_assign
id|labelcl_info_add_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
r_sizeof
(paren
id|inventory_t
)paren
comma
(paren
id|arbitrary_info_t
)paren
id|pinv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* GRAPH_LOCK_DONE_UPDATE(&amp;invent_lock); */
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
multiline_comment|/* GRAPH_LOCK_DONE_UPDATE(&amp;invent_lock); */
r_if
c_cond
(paren
id|pinv
)paren
id|kfree
c_func
(paren
id|pinv
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_inventory_remove - Removes an inventory entry.&n; *&n; *&t;Remove an inventory item associated with a vertex.   It is the caller&squot;s&n; *&t;responsibility to make sure that there are no races between removing&n; *&t;inventory from a vertex and simultaneously removing that vertex.&n;*/
r_int
DECL|function|hwgraph_inventory_remove
id|hwgraph_inventory_remove
c_func
(paren
id|devfs_handle_t
id|de
comma
r_int
r_class
comma
r_int
id|type
comma
id|major_t
id|controller
comma
id|minor_t
id|unit
comma
r_int
id|state
)paren
(brace
id|inventory_t
op_star
id|pinv
op_assign
l_int|NULL
comma
op_star
id|last_pinv
op_assign
l_int|NULL
comma
op_star
id|next_pinv
op_assign
l_int|NULL
suffix:semicolon
id|labelcl_error_t
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * We never remove stuff from &quot;.invent&quot; ..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove our inventory data to the list of inventory data&n;&t; * associated with this vertex.&n;&t; */
multiline_comment|/* GRAPH_LOCK_UPDATE(&amp;invent_lock); */
id|rv
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
l_int|NULL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|pinv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|LABELCL_SUCCESS
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/*&n;&t; * Search through inventory items associated with this&n;&t; * vertex, looking for a match.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|pinv
suffix:semicolon
id|pinv
op_assign
id|next_pinv
)paren
(brace
id|next_pinv
op_assign
id|pinv-&gt;inv_next
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
r_class
op_eq
op_minus
l_int|1
op_logical_or
id|pinv-&gt;inv_class
op_eq
r_class
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|type
op_eq
op_minus
l_int|1
op_logical_or
id|pinv-&gt;inv_type
op_eq
id|type
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|state
op_eq
op_minus
l_int|1
op_logical_or
id|pinv-&gt;inv_state
op_eq
id|state
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|controller
op_eq
op_minus
l_int|1
op_logical_or
id|pinv-&gt;inv_controller
op_eq
id|controller
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|unit
op_eq
op_minus
l_int|1
op_logical_or
id|pinv-&gt;inv_unit
op_eq
id|unit
)paren
)paren
(brace
multiline_comment|/* Found a matching inventory item. Remove it. */
r_if
c_cond
(paren
id|last_pinv
)paren
(brace
id|last_pinv-&gt;inv_next
op_assign
id|pinv-&gt;inv_next
suffix:semicolon
)brace
r_else
(brace
id|rv
op_assign
id|hwgraph_info_replace_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
(paren
id|arbitrary_info_t
)paren
id|pinv-&gt;inv_next
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|LABELCL_SUCCESS
)paren
r_goto
id|failure
suffix:semicolon
)brace
id|pinv-&gt;inv_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* sanity */
id|kfree
c_func
(paren
id|pinv
)paren
suffix:semicolon
)brace
r_else
id|last_pinv
op_assign
id|pinv
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_pinv
op_eq
l_int|NULL
)paren
(brace
id|rv
op_assign
id|hwgraph_info_remove_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|LABELCL_SUCCESS
)paren
r_goto
id|failure
suffix:semicolon
)brace
id|rv
op_assign
id|LABELCL_SUCCESS
suffix:semicolon
id|failure
suffix:colon
multiline_comment|/* GRAPH_LOCK_DONE_UPDATE(&amp;invent_lock); */
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_inventory_get_next - Get next inventory item associated with the &n; *&t;specified vertex.&n; *&n; *&t;No locking is really needed.  We don&squot;t yet have the ability&n; *&t;to remove inventory items, and new items are always added to&n; *&t;the end of a vertex&squot; inventory list.&n; *&n; * &t;However, a devfs entry can be removed!&n;*/
r_int
DECL|function|hwgraph_inventory_get_next
id|hwgraph_inventory_get_next
c_func
(paren
id|devfs_handle_t
id|de
comma
id|invplace_t
op_star
id|place
comma
id|inventory_t
op_star
op_star
id|ppinv
)paren
(brace
id|inventory_t
op_star
id|pinv
suffix:semicolon
id|labelcl_error_t
id|rv
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
id|LABELCL_BAD_PARAM
suffix:semicolon
r_if
c_cond
(paren
id|place-&gt;invplace_vhdl
op_eq
l_int|NULL
)paren
(brace
id|place-&gt;invplace_vhdl
op_assign
id|de
suffix:semicolon
id|place-&gt;invplace_inv
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de
op_ne
id|place-&gt;invplace_vhdl
)paren
r_return
id|LABELCL_BAD_PARAM
suffix:semicolon
r_if
c_cond
(paren
id|place-&gt;invplace_inv
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Just starting on this vertex */
id|rv
op_assign
id|labelcl_info_get_LBL
c_func
(paren
id|de
comma
id|INFO_LBL_INVENT
comma
l_int|NULL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|pinv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|LABELCL_SUCCESS
)paren
r_return
id|LABELCL_NOT_FOUND
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Advance to next item on this vertex */
id|pinv
op_assign
id|place-&gt;invplace_inv-&gt;inv_next
suffix:semicolon
)brace
id|place-&gt;invplace_inv
op_assign
id|pinv
suffix:semicolon
op_star
id|ppinv
op_assign
id|pinv
suffix:semicolon
r_return
id|LABELCL_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_controller_num_get - Returns the controller number in the inventory &n; *&t;entry.&n; */
r_int
DECL|function|hwgraph_controller_num_get
id|hwgraph_controller_num_get
c_func
(paren
id|devfs_handle_t
id|device
)paren
(brace
id|inventory_t
op_star
id|pinv
suffix:semicolon
id|invplace_t
id|invplace
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pinv
op_assign
id|device_inventory_get_next
c_func
(paren
id|device
comma
op_amp
id|invplace
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|val
op_assign
(paren
id|pinv-&gt;inv_class
op_eq
id|INV_NETWORK
)paren
ques
c_cond
id|pinv-&gt;inv_unit
suffix:colon
id|pinv-&gt;inv_controller
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t; * It does not make any sense to call this on vertexes with multiple&n;&t; * inventory structs chained together&n;&t; */
r_if
c_cond
(paren
id|device_inventory_get_next
c_func
(paren
id|device
comma
op_amp
id|invplace
)paren
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Should panic here ... !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hwgraph_controller_num_set - Sets the controller number in the inventory &n; *&t;entry.&n; */
r_void
DECL|function|hwgraph_controller_num_set
id|hwgraph_controller_num_set
c_func
(paren
id|devfs_handle_t
id|device
comma
r_int
id|contr_num
)paren
(brace
id|inventory_t
op_star
id|pinv
suffix:semicolon
id|invplace_t
id|invplace
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pinv
op_assign
id|device_inventory_get_next
c_func
(paren
id|device
comma
op_amp
id|invplace
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pinv-&gt;inv_class
op_eq
id|INV_NETWORK
)paren
id|pinv-&gt;inv_unit
op_assign
id|contr_num
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|pinv-&gt;inv_class
op_eq
id|INV_FCNODE
)paren
id|pinv
op_assign
id|device_inventory_get_next
c_func
(paren
id|device
comma
op_amp
id|invplace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pinv
op_ne
l_int|NULL
)paren
id|pinv-&gt;inv_controller
op_assign
id|contr_num
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t; * It does not make any sense to call this on vertexes with multiple&n;&t; * inventory structs chained together&n;&t; */
r_if
c_cond
(paren
id|pinv
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|device_inventory_get_next
c_func
(paren
id|device
comma
op_amp
id|invplace
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Find the canonical name for a given vertex by walking back through&n; * connectpt&squot;s until we hit the hwgraph root vertex (or until we run&n; * out of buffer space or until something goes wrong).&n; *&n; *&t;COMPATIBILITY FUNCTIONALITY&n; * Walks back through &squot;parents&squot;, not necessarily the same as connectpts.&n; *&n; * Need to resolve the fact that devfs does not return the path from &n; * &quot;/&quot; but rather it just stops right before /dev ..&n; */
r_int
DECL|function|hwgraph_vertex_name_get
id|hwgraph_vertex_name_get
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
(brace
r_char
op_star
id|locbuf
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* XXX should be GRAPH_BAD_PARAM ? */
id|locbuf
op_assign
id|kmalloc
c_func
(paren
id|buflen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|vhdl
comma
id|locbuf
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|locbuf
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|buf
comma
op_amp
id|locbuf
(braket
id|pos
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|locbuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** vertex_to_name converts a vertex into a canonical name by walking&n;** back through connect points until we hit the hwgraph root (or until&n;** we run out of buffer space).&n;**&n;** Usually returns a pointer to the original buffer, filled in as&n;** appropriate.  If the buffer is too small to hold the entire name,&n;** or if anything goes wrong while determining the name, vertex_to_name&n;** returns &quot;UnknownDevice&quot;.&n;*/
DECL|macro|DEVNAME_UNKNOWN
mdefine_line|#define DEVNAME_UNKNOWN &quot;UnknownDevice&quot;
r_char
op_star
DECL|function|vertex_to_name
id|vertex_to_name
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
(brace
r_if
c_cond
(paren
id|hwgraph_vertex_name_get
c_func
(paren
id|vhdl
comma
id|buf
comma
id|buflen
)paren
op_eq
id|GRAPH_SUCCESS
)paren
r_return
id|buf
suffix:semicolon
r_else
r_return
id|DEVNAME_UNKNOWN
suffix:semicolon
)brace
macro_line|#ifdef LATER
multiline_comment|/*&n;** Return the compact node id of the node that ultimately &quot;owns&quot; the specified&n;** vertex.  In order to do this, we walk back through masters and connect points&n;** until we reach a vertex that represents a node.&n;*/
id|cnodeid_t
DECL|function|master_node_get
id|master_node_get
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|cnodeid_t
id|cnodeid
suffix:semicolon
id|devfs_handle_t
id|master
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|cnodeid
op_assign
id|nodevertex_to_cnodeid
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnodeid
op_ne
id|CNODEID_NONE
)paren
r_return
id|cnodeid
suffix:semicolon
id|master
op_assign
id|device_master_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
multiline_comment|/* Check for exceptional cases */
r_if
c_cond
(paren
id|master
op_eq
id|vhdl
)paren
(brace
multiline_comment|/* Since we got a reference to the &quot;master&quot; thru&n;&t;&t;&t; * device_master_get() we should decrement&n;&t;&t;&t; * its reference count by 1&n;&t;&t;&t; */
id|hwgraph_vertex_unref
c_func
(paren
id|master
)paren
suffix:semicolon
r_return
id|CNODEID_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|master
op_eq
id|GRAPH_VERTEX_NONE
)paren
(brace
id|master
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|master
op_eq
id|GRAPH_VERTEX_NONE
)paren
op_logical_or
(paren
id|master
op_eq
id|vhdl
)paren
)paren
(brace
r_if
c_cond
(paren
id|master
op_eq
id|vhdl
)paren
multiline_comment|/* Since we got a reference to the&n;&t;&t;&t;&t;&t; * &quot;master&quot; thru&n;&t;&t;&t;&t;&t; * hwgraph_connectpt_get() we should&n;&t;&t;&t;&t;&t; * decrement its reference count by 1&n;&t;&t;&t;&t;&t; */
id|hwgraph_vertex_unref
c_func
(paren
id|master
)paren
suffix:semicolon
r_return
id|CNODEID_NONE
suffix:semicolon
)brace
)brace
id|vhdl
op_assign
id|master
suffix:semicolon
multiline_comment|/* Decrement the reference to &quot;master&quot; which was got&n;&t;&t; * either thru device_master_get() or hwgraph_connectpt_get()&n;&t;&t; * above.&n;&t;&t; */
id|hwgraph_vertex_unref
c_func
(paren
id|master
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Using the canonical path name to get hold of the desired vertex handle will&n; * not work on multi-hub sn0 nodes. Hence, we use the following (slightly&n; * convoluted) algorithm.&n; *&n; * - Start at the vertex corresponding to the driver (provided as input parameter)&n; * - Loop till you reach a vertex which has EDGE_LBL_MEMORY&n; *    - If EDGE_LBL_CONN exists, follow that up.&n; *      else if EDGE_LBL_MASTER exists, follow that up.&n; *      else follow EDGE_LBL_DOTDOT up.&n; *&n; * * We should be at desired hub/heart vertex now *&n; * - Follow EDGE_LBL_CONN to the widget vertex.&n; *&n; * - return vertex handle of this widget.&n; */
id|devfs_handle_t
DECL|function|mem_vhdl_get
id|mem_vhdl_get
c_func
(paren
id|devfs_handle_t
id|drv_vhdl
)paren
(brace
id|devfs_handle_t
id|cur_vhdl
comma
id|cur_upper_vhdl
suffix:semicolon
id|devfs_handle_t
id|tmp_mem_vhdl
comma
id|mem_vhdl
suffix:semicolon
id|graph_error_t
id|loop_rv
suffix:semicolon
multiline_comment|/* Initializations */
id|cur_vhdl
op_assign
id|drv_vhdl
suffix:semicolon
id|loop_rv
op_assign
op_complement
id|GRAPH_SUCCESS
suffix:semicolon
multiline_comment|/* Loop till current vertex has EDGE_LBL_MEMORY */
r_while
c_loop
(paren
id|loop_rv
op_ne
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
(paren
id|hwgraph_edge_get
c_func
(paren
id|cur_vhdl
comma
id|EDGE_LBL_CONN
comma
op_amp
id|cur_upper_vhdl
)paren
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|hwgraph_edge_get
c_func
(paren
id|cur_vhdl
comma
id|EDGE_LBL_MASTER
comma
op_amp
id|cur_upper_vhdl
)paren
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
)brace
r_else
(brace
multiline_comment|/* Follow HWGRAPH_EDGELBL_DOTDOT up */
(paren
r_void
)paren
id|hwgraph_edge_get
c_func
(paren
id|cur_vhdl
comma
id|HWGRAPH_EDGELBL_DOTDOT
comma
op_amp
id|cur_upper_vhdl
)paren
suffix:semicolon
)brace
id|cur_vhdl
op_assign
id|cur_upper_vhdl
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; HWG_DEBUG
id|printf
c_func
(paren
l_string|&quot;Current vhdl %d &bslash;n&quot;
comma
id|cur_vhdl
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|loop_rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|cur_vhdl
comma
id|EDGE_LBL_MEMORY
comma
op_amp
id|tmp_mem_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/* We should be at desired hub/heart vertex now */
r_if
c_cond
(paren
(paren
id|hwgraph_edge_get
c_func
(paren
id|cur_vhdl
comma
id|EDGE_LBL_CONN
comma
op_amp
id|mem_vhdl
)paren
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
(paren
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
r_return
(paren
id|mem_vhdl
)paren
suffix:semicolon
)brace
macro_line|#endif /* LATER */
multiline_comment|/*&n;** Add a char device -- if the driver supports it -- at a specified vertex.&n;*/
id|graph_error_t
DECL|function|hwgraph_char_device_add
id|hwgraph_char_device_add
c_func
(paren
id|devfs_handle_t
id|from
comma
r_char
op_star
id|path
comma
r_char
op_star
id|prefix
comma
id|devfs_handle_t
op_star
id|devhdl
)paren
(brace
id|devfs_handle_t
id|xx
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WARNING: hwgraph_char_device_add() not supported .. use hwgraph_register.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|devhdl
op_assign
id|xx
suffix:semicolon
singleline_comment|// Must set devhdl
r_return
id|GRAPH_SUCCESS
suffix:semicolon
)brace
id|graph_error_t
DECL|function|hwgraph_edge_remove
id|hwgraph_edge_remove
c_func
(paren
id|devfs_handle_t
id|from
comma
r_char
op_star
id|name
comma
id|devfs_handle_t
op_star
id|toptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: hwgraph_edge_remove NOT supported.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|GRAPH_ILLEGAL_REQUEST
suffix:semicolon
)brace
id|graph_error_t
DECL|function|hwgraph_vertex_unref
id|hwgraph_vertex_unref
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
r_return
id|GRAPH_ILLEGAL_REQUEST
suffix:semicolon
)brace
DECL|variable|hwgraph_mk_dir
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_mk_dir
)paren
suffix:semicolon
DECL|variable|hwgraph_path_add
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_path_add
)paren
suffix:semicolon
DECL|variable|hwgraph_char_device_add
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_char_device_add
)paren
suffix:semicolon
DECL|variable|hwgraph_register
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_register
)paren
suffix:semicolon
DECL|variable|hwgraph_vertex_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_vertex_destroy
)paren
suffix:semicolon
DECL|variable|hwgraph_fastinfo_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_fastinfo_get
)paren
suffix:semicolon
DECL|variable|hwgraph_edge_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_edge_get
)paren
suffix:semicolon
DECL|variable|hwgraph_fastinfo_set
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_fastinfo_set
)paren
suffix:semicolon
DECL|variable|hwgraph_connectpt_set
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_connectpt_set
)paren
suffix:semicolon
DECL|variable|hwgraph_connectpt_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_connectpt_get
)paren
suffix:semicolon
DECL|variable|hwgraph_edge_get_next
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_edge_get_next
)paren
suffix:semicolon
DECL|variable|hwgraph_info_add_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_add_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_remove_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_remove_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_replace_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_replace_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_get_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_get_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_get_exported_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_get_exported_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_get_next_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_get_next_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_export_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_export_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_info_unexport_LBL
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_info_unexport_LBL
)paren
suffix:semicolon
DECL|variable|hwgraph_path_lookup
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_path_lookup
)paren
suffix:semicolon
DECL|variable|hwgraph_traverse
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_traverse
)paren
suffix:semicolon
DECL|variable|hwgraph_path_to_vertex
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_path_to_vertex
)paren
suffix:semicolon
DECL|variable|hwgraph_path_to_dev
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_path_to_dev
)paren
suffix:semicolon
DECL|variable|hwgraph_block_device_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_block_device_get
)paren
suffix:semicolon
DECL|variable|hwgraph_char_device_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_char_device_get
)paren
suffix:semicolon
DECL|variable|hwgraph_cdevsw_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_cdevsw_get
)paren
suffix:semicolon
DECL|variable|hwgraph_bdevsw_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_bdevsw_get
)paren
suffix:semicolon
DECL|variable|hwgraph_vertex_name_get
id|EXPORT_SYMBOL
c_func
(paren
id|hwgraph_vertex_name_get
)paren
suffix:semicolon
eof
