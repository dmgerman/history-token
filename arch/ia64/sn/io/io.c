multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/driver.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/sn/pio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalkaddrs.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
r_extern
id|xtalk_provider_t
id|hub_provider
suffix:semicolon
DECL|variable|force_fire_and_forget
r_static
r_int
id|force_fire_and_forget
op_assign
l_int|1
suffix:semicolon
DECL|variable|ignore_conveyor_override
r_static
r_int
id|ignore_conveyor_override
suffix:semicolon
multiline_comment|/* &n; * Implementation of hub iobus operations.&n; *&n; * Hub provides a crosstalk &quot;iobus&quot; on IP27 systems.  These routines&n; * provide a platform-specific implementation of xtalk used by all xtalk &n; * cards on IP27 systems.&n; *&n; * Called from corresponding xtalk_* routines.&n; */
multiline_comment|/* PIO MANAGEMENT */
multiline_comment|/* For mapping system virtual address space to xtalk space on a specified widget */
multiline_comment|/*&n; * Setup pio structures needed for a particular hub.&n; */
r_static
r_void
DECL|function|hub_pio_init
id|hub_pio_init
c_func
(paren
id|vertex_hdl_t
id|hubv
)paren
(brace
id|xwidgetnum_t
id|widget
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|bigwin
suffix:semicolon
id|hub_piomap_t
id|hub_piomap
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/* Initialize small window piomaps for this hub */
r_for
c_loop
(paren
id|widget
op_assign
l_int|0
suffix:semicolon
id|widget
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widget
op_increment
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_target
op_assign
id|widget
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_assign
l_int|0
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
op_assign
id|SWIN_SIZE
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_assign
(paren
id|caddr_t
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
id|widget
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_hub
op_assign
id|hubv
suffix:semicolon
id|hub_piomap-&gt;hpio_flags
op_assign
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
)brace
multiline_comment|/* Initialize big window piomaps for this hub */
r_for
c_loop
(paren
id|bigwin
op_assign
l_int|0
suffix:semicolon
id|bigwin
OL
id|HUB_NUM_BIG_WINDOW
suffix:semicolon
id|bigwin
op_increment
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|bigwin
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
op_assign
id|BWIN_SIZE
suffix:semicolon
id|hub_piomap-&gt;hpio_hub
op_assign
id|hubv
suffix:semicolon
id|hub_piomap-&gt;hpio_holdcnt
op_assign
l_int|0
suffix:semicolon
id|hub_piomap-&gt;hpio_flags
op_assign
id|HUB_PIOMAP_IS_BIGWINDOW
suffix:semicolon
id|IIO_ITTE_DISABLE
c_func
(paren
id|nasid
comma
id|bigwin
)paren
suffix:semicolon
)brace
id|hub_set_piomode
c_func
(paren
id|nasid
comma
id|HUB_PIO_CONVEYOR
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Create a caddr_t-to-xtalk_addr mapping.&n; *&n; * Use a small window if possible (that&squot;s the usual case), but&n; * manage big windows if needed.  Big window mappings can be&n; * either FIXED or UNFIXED -- we keep at least 1 big window available&n; * for UNFIXED mappings.&n; *&n; * Returns an opaque pointer-sized type which can be passed to&n; * other hub_pio_* routines on success, or NULL if the request&n; * cannot be satisfied.&n; */
multiline_comment|/* ARGSUSED */
id|hub_piomap_t
DECL|function|hub_piomap_alloc
id|hub_piomap_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* set up mapping for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk_addr range */
r_int
id|byte_count
comma
r_int
id|byte_count_max
comma
multiline_comment|/* maximum size of a mapping */
r_int
id|flags
)paren
multiline_comment|/* defined in sys/pio.h */
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|hub_piomap_t
id|bw_piomap
suffix:semicolon
r_int
id|bigwin
comma
id|free_bw_index
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_volatile
id|hubreg_t
id|junk
suffix:semicolon
id|caddr_t
id|kvaddr
suffix:semicolon
macro_line|#ifdef PIOMAP_UNC_ACC_SPACE
r_uint64
id|addr
suffix:semicolon
macro_line|#endif
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|byte_count_max
OG
id|byte_count
)paren
r_return
l_int|NULL
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
multiline_comment|/* If xtalk_addr range is mapped by a small window, we don&squot;t have &n;&t; * to do much &n;&t; */
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
op_le
id|SWIN_SIZE
)paren
(brace
id|hub_piomap_t
id|piomap
suffix:semicolon
id|piomap
op_assign
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
macro_line|#ifdef PIOMAP_UNC_ACC_SPACE
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_UNC_ACC
)paren
(brace
id|addr
op_assign
(paren
r_uint64
)paren
id|piomap-&gt;hpio_xtalk_info.xp_kvaddr
suffix:semicolon
id|addr
op_or_assign
id|PIOMAP_UNC_ACC_SPACE
suffix:semicolon
id|piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_assign
(paren
id|caddr_t
)paren
id|addr
suffix:semicolon
)brace
macro_line|#endif
r_return
id|piomap
suffix:semicolon
)brace
multiline_comment|/* We need to use a big window mapping.  */
multiline_comment|/*&n;&t; * TBD: Allow requests that would consume multiple big windows --&n;&t; * split the request up and use multiple mapping entries.&n;&t; * For now, reject requests that span big windows.&n;&t; */
r_if
c_cond
(paren
(paren
id|xtalk_addr
op_mod
id|BWIN_SIZE
)paren
op_plus
id|byte_count
OG
id|BWIN_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Round xtalk address down for big window alignement */
id|xtalk_addr
op_assign
id|xtalk_addr
op_amp
op_complement
(paren
id|BWIN_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if an existing big window mapping will suffice.&n;&t; */
id|tryagain
suffix:colon
id|free_bw_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bigwin
op_assign
l_int|0
suffix:semicolon
id|bigwin
OL
id|HUB_NUM_BIG_WINDOW
suffix:semicolon
id|bigwin
op_increment
)paren
(brace
id|bw_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|bigwin
)paren
suffix:semicolon
multiline_comment|/* If mapping is not valid, skip it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bw_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
)paren
(brace
id|free_bw_index
op_assign
id|bigwin
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * If mapping is UNFIXED, skip it.  We don&squot;t allow sharing&n;&t;&t; * of UNFIXED mappings, because this would allow starvation.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bw_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_FIXED
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_eq
id|bw_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_logical_and
id|widget
op_eq
id|bw_piomap-&gt;hpio_xtalk_info.xp_target
)paren
(brace
id|bw_piomap-&gt;hpio_holdcnt
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
r_return
id|bw_piomap
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * None of the existing big window mappings will work for us --&n;&t; * we need to establish a new mapping.&n;&t; */
multiline_comment|/* Insure that we don&squot;t consume all big windows with FIXED mappings */
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|hubinfo-&gt;h_num_big_window_fixed
OL
id|HUB_NUM_BIG_WINDOW
op_minus
l_int|1
)paren
(brace
id|ASSERT
c_func
(paren
id|free_bw_index
op_ge
l_int|0
)paren
suffix:semicolon
id|hubinfo-&gt;h_num_big_window_fixed
op_increment
suffix:semicolon
)brace
r_else
(brace
id|bw_piomap
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* PIOMAP_UNFIXED */
(brace
r_if
c_cond
(paren
id|free_bw_index
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_NOSLEEP
)paren
(brace
id|bw_piomap
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|tryagain
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OK!  Allocate big window free_bw_index for this mapping. */
multiline_comment|/* &n;&t; * The code below does a PIO write to setup an ITTE entry.&n;&t; * We need to prevent other CPUs from seeing our updated memory &n;&t; * shadow of the ITTE (in the piomap) until the ITTE entry is &n;&t; * actually set up; otherwise, another CPU might attempt a PIO &n;&t; * prematurely.  &n;&t; *&n;&t; * Also, the only way we can know that an entry has been received &n;&t; * by the hub and can be used by future PIO reads/writes is by &n;&t; * reading back the ITTE entry after writing it.&n;&t; *&n;&t; * For these two reasons, we PIO read back the ITTE entry after&n;&t; * we write it.&n;&t; */
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|IIO_ITTE_PUT
c_func
(paren
id|nasid
comma
id|free_bw_index
comma
id|HUB_PIO_MAP_TO_MEM
comma
id|widget
comma
id|xtalk_addr
)paren
suffix:semicolon
id|junk
op_assign
id|HUB_L
c_func
(paren
id|IIO_ITTE_GET
c_func
(paren
id|nasid
comma
id|free_bw_index
)paren
)paren
suffix:semicolon
id|bw_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|free_bw_index
)paren
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_dev
op_assign
id|dev
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_target
op_assign
id|widget
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_assign
id|xtalk_addr
suffix:semicolon
id|kvaddr
op_assign
(paren
id|caddr_t
)paren
id|NODE_BWIN_BASE
c_func
(paren
id|nasid
comma
id|free_bw_index
)paren
suffix:semicolon
macro_line|#ifdef PIOMAP_UNC_ACC_SPACE
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_UNC_ACC
)paren
(brace
id|addr
op_assign
(paren
r_uint64
)paren
id|kvaddr
suffix:semicolon
id|addr
op_or_assign
id|PIOMAP_UNC_ACC_SPACE
suffix:semicolon
id|kvaddr
op_assign
(paren
id|caddr_t
)paren
id|addr
suffix:semicolon
)brace
macro_line|#endif
id|bw_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_assign
id|kvaddr
suffix:semicolon
id|bw_piomap-&gt;hpio_holdcnt
op_increment
suffix:semicolon
id|bw_piomap-&gt;hpio_bigwin_num
op_assign
id|free_bw_index
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_FIXED
)paren
id|bw_piomap-&gt;hpio_flags
op_or_assign
id|HUB_PIOMAP_IS_VALID
op_or
id|HUB_PIOMAP_IS_FIXED
suffix:semicolon
r_else
id|bw_piomap-&gt;hpio_flags
op_or_assign
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
id|done
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
r_return
id|bw_piomap
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_piomap_free destroys a caddr_t-to-xtalk pio mapping and frees&n; * any associated mapping resources.  &n; *&n; * If this * piomap was handled with a small window, or if it was handled&n; * in a big window that&squot;s still in use by someone else, then there&squot;s &n; * nothing to do.  On the other hand, if this mapping was handled &n; * with a big window, AND if we were the final user of that mapping, &n; * then destroy the mapping.&n; */
r_void
DECL|function|hub_piomap_free
id|hub_piomap_free
c_func
(paren
id|hub_piomap_t
id|hub_piomap
)paren
(brace
id|vertex_hdl_t
id|hubv
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
multiline_comment|/* &n;&t; * Small windows are permanently mapped to corresponding widgets,&n;&t; * so there&squot;re no resources to free.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_BIGWINDOW
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_piomap-&gt;hpio_holdcnt
OG
l_int|0
)paren
suffix:semicolon
id|hubv
op_assign
id|hub_piomap-&gt;hpio_hub
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is the last hold on this mapping, free it.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|hub_piomap-&gt;hpio_holdcnt
op_eq
l_int|0
)paren
(brace
id|IIO_ITTE_DISABLE
c_func
(paren
id|nasid
comma
id|hub_piomap-&gt;hpio_bigwin_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_FIXED
)paren
(brace
id|hub_piomap-&gt;hpio_flags
op_and_assign
op_complement
(paren
id|HUB_PIOMAP_IS_VALID
op_or
id|HUB_PIOMAP_IS_FIXED
)paren
suffix:semicolon
id|hubinfo-&gt;h_num_big_window_fixed
op_decrement
suffix:semicolon
id|ASSERT
c_func
(paren
id|hubinfo-&gt;h_num_big_window_fixed
op_ge
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|hub_piomap-&gt;hpio_flags
op_and_assign
op_complement
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Establish a mapping to a given xtalk address range using the resources&n; * allocated earlier.&n; */
id|caddr_t
DECL|function|hub_piomap_addr
id|hub_piomap_addr
c_func
(paren
id|hub_piomap_t
id|hub_piomap
comma
multiline_comment|/* mapping resources */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk address */
r_int
id|byte_count
)paren
multiline_comment|/* map this many bytes */
(brace
multiline_comment|/* Verify that range can be mapped using the specified piomap */
r_if
c_cond
(paren
id|xtalk_addr
OL
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
OG
(paren
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_plus
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
r_return
id|hub_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_plus
(paren
id|xtalk_addr
op_mod
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver indicates that it&squot;s done with PIO&squot;s from an earlier piomap_addr.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|hub_piomap_done
id|hub_piomap_done
c_func
(paren
id|hub_piomap_t
id|hub_piomap
)paren
multiline_comment|/* done with these mapping resources */
(brace
multiline_comment|/* Nothing to do */
)brace
multiline_comment|/*&n; * For translations that require no mapping resources, supply a kernel virtual&n; * address that maps to the specified xtalk address range.&n; */
multiline_comment|/* ARGSUSED */
id|caddr_t
DECL|function|hub_piotrans_addr
id|hub_piotrans_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate to this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* Crosstalk address */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
r_int
id|flags
)paren
multiline_comment|/* (currently unused) */
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hub_piomap_t
id|hub_piomap
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|caddr_t
id|addr
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
op_le
id|SWIN_SIZE
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
id|addr
op_assign
id|hub_piomap_addr
c_func
(paren
id|hub_piomap
comma
id|xtalk_addr
comma
id|byte_count
)paren
suffix:semicolon
macro_line|#ifdef PIOMAP_UNC_ACC_SPACE
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_UNC_ACC
)paren
(brace
r_uint64
id|iaddr
suffix:semicolon
id|iaddr
op_assign
(paren
r_uint64
)paren
id|addr
suffix:semicolon
id|iaddr
op_or_assign
id|PIOMAP_UNC_ACC_SPACE
suffix:semicolon
id|addr
op_assign
(paren
id|caddr_t
)paren
id|iaddr
suffix:semicolon
)brace
macro_line|#endif
r_return
id|addr
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* DMA MANAGEMENT */
multiline_comment|/* Mapping from crosstalk space to system physical space */
multiline_comment|/*&n; * Allocate resources needed to set up DMA mappings up to a specified size&n; * on a specified adapter.&n; * &n; * We don&squot;t actually use the adapter ID for anything.  It&squot;s just the adapter&n; * that the lower level driver plans to use for DMA.&n; */
multiline_comment|/* ARGSUSED */
id|hub_dmamap_t
DECL|function|hub_dmamap_alloc
id|hub_dmamap_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
multiline_comment|/* defined in dma.h */
(brace
id|hub_dmamap_t
id|dmamap
suffix:semicolon
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|dmamap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hub_dmamap_s
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|dmamap-&gt;hdma_xtalk_info.xd_dev
op_assign
id|dev
suffix:semicolon
id|dmamap-&gt;hdma_xtalk_info.xd_target
op_assign
id|widget
suffix:semicolon
id|dmamap-&gt;hdma_hub
op_assign
id|hubv
suffix:semicolon
id|dmamap-&gt;hdma_flags
op_assign
id|HUB_DMAMAP_IS_VALID
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XTALK_FIXED
)paren
id|dmamap-&gt;hdma_flags
op_or_assign
id|HUB_DMAMAP_IS_FIXED
suffix:semicolon
r_return
id|dmamap
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy a DMA mapping from crosstalk space to system address space.&n; * There is no actual mapping hardware to destroy, but we at least mark&n; * the dmamap INVALID and free the space that it took.&n; */
r_void
DECL|function|hub_dmamap_free
id|hub_dmamap_free
c_func
(paren
id|hub_dmamap_t
id|hub_dmamap
)paren
(brace
id|hub_dmamap-&gt;hdma_flags
op_and_assign
op_complement
id|HUB_DMAMAP_IS_VALID
suffix:semicolon
id|kfree
c_func
(paren
id|hub_dmamap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Establish a DMA mapping using the resources allocated in a previous dmamap_alloc.&n; * Return an appropriate crosstalk address range that maps to the specified physical &n; * address range.&n; */
multiline_comment|/* ARGSUSED */
r_extern
id|iopaddr_t
DECL|function|hub_dmamap_addr
id|hub_dmamap_addr
c_func
(paren
id|hub_dmamap_t
id|dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
multiline_comment|/* map this many bytes */
(brace
id|vertex_hdl_t
id|vhdl
suffix:semicolon
id|ASSERT
c_func
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_VALID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_USED
)paren
(brace
multiline_comment|/* If the map is FIXED, re-use is OK. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_FIXED
)paren
)paren
(brace
r_char
id|name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|vhdl
op_assign
id|dmamap-&gt;hdma_xtalk_info.xd_dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: hub_dmamap_addr re-uses dmamap.&bslash;n&quot;
comma
id|vertex_to_name
c_func
(paren
id|vhdl
comma
id|name
comma
id|MAXDEVNAME
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dmamap-&gt;hdma_flags
op_or_assign
id|HUB_DMAMAP_USED
suffix:semicolon
)brace
multiline_comment|/* There isn&squot;t actually any DMA mapping hardware on the hub. */
r_return
(paren
id|PHYS_TO_DMA
c_func
(paren
id|paddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver indicates that it has completed whatever DMA it may have started&n; * after an earlier dmamap_addr call.&n; */
r_void
DECL|function|hub_dmamap_done
id|hub_dmamap_done
c_func
(paren
id|hub_dmamap_t
id|hub_dmamap
)paren
multiline_comment|/* done with these mapping resources */
(brace
id|vertex_hdl_t
id|vhdl
suffix:semicolon
r_if
c_cond
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_USED
)paren
(brace
id|hub_dmamap-&gt;hdma_flags
op_and_assign
op_complement
id|HUB_DMAMAP_USED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the map is FIXED, re-done is OK. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_FIXED
)paren
)paren
(brace
r_char
id|name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|vhdl
op_assign
id|hub_dmamap-&gt;hdma_xtalk_info.xd_dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: hub_dmamap_done already done with dmamap&bslash;n&quot;
comma
id|vertex_to_name
c_func
(paren
id|vhdl
comma
id|name
comma
id|MAXDEVNAME
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Translate a single system physical address into a crosstalk address.&n; */
multiline_comment|/* ARGSUSED */
id|iopaddr_t
DECL|function|hub_dmatrans_addr
id|hub_dmatrans_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
multiline_comment|/* defined in dma.h */
(brace
r_return
(paren
id|PHYS_TO_DMA
c_func
(paren
id|paddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hub_dmamap_drain
id|hub_dmamap_drain
c_func
(paren
id|hub_dmamap_t
id|map
)paren
(brace
multiline_comment|/* XXX- flush caches, if cache coherency WAR is needed */
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hub_dmaaddr_drain
id|hub_dmaaddr_drain
c_func
(paren
id|vertex_hdl_t
id|vhdl
comma
id|paddr_t
id|addr
comma
r_int
id|bytes
)paren
(brace
multiline_comment|/* XXX- flush caches, if cache coherency WAR is needed */
)brace
multiline_comment|/* CONFIGURATION MANAGEMENT */
multiline_comment|/*&n; * Perform initializations that allow this hub to start crosstalk support.&n; */
r_void
DECL|function|hub_provider_startup
id|hub_provider_startup
c_func
(paren
id|vertex_hdl_t
id|hubv
)paren
(brace
id|hub_pio_init
c_func
(paren
id|hubv
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shutdown crosstalk support from a hub.&n; */
r_void
DECL|function|hub_provider_shutdown
id|hub_provider_shutdown
c_func
(paren
id|vertex_hdl_t
id|hub
)paren
(brace
multiline_comment|/* TBD */
id|xtalk_provider_unregister
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that an address is in the real small window widget 0 space&n; * or else in the big window we&squot;re using to emulate small window 0&n; * in the kernel.&n; */
r_int
DECL|function|hub_check_is_widget0
id|hub_check_is_widget0
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|addr
op_ge
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|0
)paren
)paren
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|1
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that two addresses use the same widget&n; */
r_int
DECL|function|hub_check_window_equiv
id|hub_check_window_equiv
c_func
(paren
r_void
op_star
id|addra
comma
r_void
op_star
id|addrb
)paren
(brace
r_if
c_cond
(paren
id|hub_check_is_widget0
c_func
(paren
id|addra
)paren
op_logical_and
id|hub_check_is_widget0
c_func
(paren
id|addrb
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* XXX - Assume this is really a small window address */
r_if
c_cond
(paren
id|WIDGETID_GET
c_func
(paren
(paren
r_int
r_int
)paren
id|addra
)paren
op_eq
id|WIDGETID_GET
c_func
(paren
(paren
r_int
r_int
)paren
id|addrb
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_setup_prb(nasid, prbnum, credits, conveyor)&n; *&n; * &t;Put a PRB into fire-and-forget mode if conveyor isn&squot;t set.  Otherwise,&n; * &t;put it into conveyor belt mode with the specified number of credits.&n; */
r_void
DECL|function|hub_setup_prb
id|hub_setup_prb
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|prbnum
comma
r_int
id|credits
comma
r_int
id|conveyor
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
r_int
id|prb_offset
suffix:semicolon
r_if
c_cond
(paren
id|force_fire_and_forget
op_logical_and
op_logical_neg
id|ignore_conveyor_override
)paren
r_if
c_cond
(paren
id|conveyor
op_eq
id|HUB_PIO_CONVEYOR
)paren
id|conveyor
op_assign
id|HUB_PIO_FIRE_N_FORGET
suffix:semicolon
multiline_comment|/*&n;&t; * Get the current register value.&n;&t; */
id|prb_offset
op_assign
id|IIO_IOPRB
c_func
(paren
id|prbnum
)paren
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|prb_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out some fields.&n;&t; */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Enable or disable fire-and-forget mode.&n;&t; */
id|prb.iprb_ff
op_assign
(paren
(paren
id|conveyor
op_eq
id|HUB_PIO_CONVEYOR
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the appropriate number of PIO cresits for the widget.&n;&t; */
id|prb.iprb_xtalkctr
op_assign
id|credits
suffix:semicolon
multiline_comment|/*&n;&t; * Store the new value to the register.&n;&t; */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|prb_offset
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_set_piomode()&n; *&n; * &t;Put the hub into either &quot;PIO conveyor belt&quot; mode or &quot;fire-and-forget&quot;&n; * &t;mode.  To do this, we have to make absolutely sure that no PIOs&n; *&t;are in progress so we turn off access to all widgets for the duration&n; *&t;of the function.&n; * &n; * XXX - This code should really check what kind of widget we&squot;re talking&n; * to.  Bridges can only handle three requests, but XG will do more.&n; * How many can crossbow handle to widget 0?  We&squot;re assuming 1.&n; *&n; * XXX - There is a bug in the crossbow that link reset PIOs do not&n; * return write responses.  The easiest solution to this problem is to&n; * leave widget 0 (xbow) in fire-and-forget mode at all times.  This&n; * only affects pio&squot;s to xbow registers, which should be rare.&n; */
r_void
DECL|function|hub_set_piomode
id|hub_set_piomode
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|conveyor
)paren
(brace
id|hubreg_t
id|ii_iowa
suffix:semicolon
r_int
id|direct_connect
suffix:semicolon
id|hubii_wcr_t
id|ii_wcr
suffix:semicolon
r_int
id|prbnum
suffix:semicolon
id|ASSERT
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
op_ne
id|INVALID_CNODEID
)paren
suffix:semicolon
id|ii_iowa
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
comma
l_int|0
)paren
suffix:semicolon
id|ii_wcr.wcr_reg_value
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_WCR
)paren
suffix:semicolon
id|direct_connect
op_assign
id|ii_wcr.iwcr_dir_con
suffix:semicolon
r_if
c_cond
(paren
id|direct_connect
)paren
(brace
multiline_comment|/* &n;&t;&t; * Assume a bridge here.&n;&t;&t; */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
l_int|0
comma
l_int|3
comma
id|conveyor
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * Assume a crossbow here.&n;&t;&t; */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
l_int|0
comma
l_int|1
comma
id|conveyor
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|prbnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|prbnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|prbnum
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX - Here&squot;s where we should take the widget type into&n;&t;&t; * when account assigning credits.&n;&t;&t; */
multiline_comment|/* Always set the PRBs in fire-and-forget mode */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|prbnum
comma
l_int|3
comma
id|conveyor
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
comma
id|ii_iowa
)paren
suffix:semicolon
)brace
multiline_comment|/* Interface to allow special drivers to set hub specific&n; * device flags.&n; * Return 0 on failure , 1 on success&n; */
r_int
DECL|function|hub_widget_flags_set
id|hub_widget_flags_set
c_func
(paren
id|nasid_t
id|nasid
comma
id|xwidgetnum_t
id|widget_num
comma
id|hub_widget_flags_t
id|flags
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|HUB_WIDGET_FLAGS
)paren
op_eq
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|HUB_PIO_CONVEYOR
)paren
(brace
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|widget_num
comma
l_int|3
comma
id|HUB_PIO_CONVEYOR
)paren
suffix:semicolon
multiline_comment|/* set the PRB in conveyor &n;&t;&t;&t;&t;&t;&t;    * belt mode with 3 credits&n;&t;&t;&t;&t;&t;&t;    */
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|HUB_PIO_FIRE_N_FORGET
)paren
(brace
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|widget_num
comma
l_int|3
comma
id|HUB_PIO_FIRE_N_FORGET
)paren
suffix:semicolon
multiline_comment|/* set the PRB in fire&n;&t;&t;&t;&t;&t;&t;&t; *  and forget mode &n;&t;&t;&t;&t;&t;&t;&t; */
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * A pointer to this structure hangs off of every hub hwgraph vertex.&n; * The generic xtalk layer may indirect through it to get to this specific&n; * crosstalk bus provider.&n; */
DECL|variable|hub_provider
id|xtalk_provider_t
id|hub_provider
op_assign
(brace
dot
id|piomap_alloc
op_assign
(paren
id|xtalk_piomap_alloc_f
op_star
)paren
id|hub_piomap_alloc
comma
dot
id|piomap_free
op_assign
(paren
id|xtalk_piomap_free_f
op_star
)paren
id|hub_piomap_free
comma
dot
id|piomap_addr
op_assign
(paren
id|xtalk_piomap_addr_f
op_star
)paren
id|hub_piomap_addr
comma
dot
id|piomap_done
op_assign
(paren
id|xtalk_piomap_done_f
op_star
)paren
id|hub_piomap_done
comma
dot
id|piotrans_addr
op_assign
(paren
id|xtalk_piotrans_addr_f
op_star
)paren
id|hub_piotrans_addr
comma
dot
id|dmamap_alloc
op_assign
(paren
id|xtalk_dmamap_alloc_f
op_star
)paren
id|hub_dmamap_alloc
comma
dot
id|dmamap_free
op_assign
(paren
id|xtalk_dmamap_free_f
op_star
)paren
id|hub_dmamap_free
comma
dot
id|dmamap_addr
op_assign
(paren
id|xtalk_dmamap_addr_f
op_star
)paren
id|hub_dmamap_addr
comma
dot
id|dmamap_done
op_assign
(paren
id|xtalk_dmamap_done_f
op_star
)paren
id|hub_dmamap_done
comma
dot
id|dmatrans_addr
op_assign
(paren
id|xtalk_dmatrans_addr_f
op_star
)paren
id|hub_dmatrans_addr
comma
dot
id|dmamap_drain
op_assign
(paren
id|xtalk_dmamap_drain_f
op_star
)paren
id|hub_dmamap_drain
comma
dot
id|dmaaddr_drain
op_assign
(paren
id|xtalk_dmaaddr_drain_f
op_star
)paren
id|hub_dmaaddr_drain
comma
dot
id|intr_alloc
op_assign
(paren
id|xtalk_intr_alloc_f
op_star
)paren
id|hub_intr_alloc
comma
dot
id|intr_alloc_nothd
op_assign
(paren
id|xtalk_intr_alloc_f
op_star
)paren
id|hub_intr_alloc_nothd
comma
dot
id|intr_free
op_assign
(paren
id|xtalk_intr_free_f
op_star
)paren
id|hub_intr_free
comma
dot
id|intr_connect
op_assign
(paren
id|xtalk_intr_connect_f
op_star
)paren
id|hub_intr_connect
comma
dot
id|intr_disconnect
op_assign
(paren
id|xtalk_intr_disconnect_f
op_star
)paren
id|hub_intr_disconnect
comma
dot
id|provider_startup
op_assign
(paren
id|xtalk_provider_startup_f
op_star
)paren
id|hub_provider_startup
comma
dot
id|provider_shutdown
op_assign
(paren
id|xtalk_provider_shutdown_f
op_star
)paren
id|hub_provider_shutdown
comma
)brace
suffix:semicolon
eof
