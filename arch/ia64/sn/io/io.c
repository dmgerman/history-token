multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/cmn_err.h&gt;
macro_line|#include &lt;asm/sn/iobus.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/sn/pio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalkaddrs.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
r_extern
id|xtalk_provider_t
id|hub_provider
suffix:semicolon
macro_line|#ifndef CONFIG_IA64_SGI_IO
multiline_comment|/* Global variables */
r_extern
id|pdaindr_t
id|pdaindr
(braket
id|MAXCPUS
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Perform any initializations needed to support hub-based I/O.&n; * Called once during startup.&n; */
r_void
DECL|function|hubio_init
id|hubio_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
multiline_comment|/* This isn&squot;t needed unless we port the entire sio driver ... */
r_extern
r_void
id|early_brl1_port_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|early_brl1_port_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* &n; * Implementation of hub iobus operations.&n; *&n; * Hub provides a crosstalk &quot;iobus&quot; on IP27 systems.  These routines&n; * provide a platform-specific implementation of xtalk used by all xtalk &n; * cards on IP27 systems.&n; *&n; * Called from corresponding xtalk_* routines.&n; */
multiline_comment|/* PIO MANAGEMENT */
multiline_comment|/* For mapping system virtual address space to xtalk space on a specified widget */
multiline_comment|/*&n; * Setup pio structures needed for a particular hub.&n; */
r_static
r_void
DECL|function|hub_pio_init
id|hub_pio_init
c_func
(paren
id|devfs_handle_t
id|hubv
)paren
(brace
id|xwidgetnum_t
id|widget
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|bigwin
suffix:semicolon
id|hub_piomap_t
id|hub_piomap
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/* Initialize small window piomaps for this hub */
r_for
c_loop
(paren
id|widget
op_assign
l_int|0
suffix:semicolon
id|widget
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widget
op_increment
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_target
op_assign
id|widget
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_assign
l_int|0
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
op_assign
id|SWIN_SIZE
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_assign
(paren
id|caddr_t
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
id|widget
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_hub
op_assign
id|hubv
suffix:semicolon
id|hub_piomap-&gt;hpio_flags
op_assign
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
)brace
multiline_comment|/* Initialize big window piomaps for this hub */
r_for
c_loop
(paren
id|bigwin
op_assign
l_int|0
suffix:semicolon
id|bigwin
OL
id|HUB_NUM_BIG_WINDOW
suffix:semicolon
id|bigwin
op_increment
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|bigwin
)paren
suffix:semicolon
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
op_assign
id|BWIN_SIZE
suffix:semicolon
id|hub_piomap-&gt;hpio_hub
op_assign
id|hubv
suffix:semicolon
id|hub_piomap-&gt;hpio_holdcnt
op_assign
l_int|0
suffix:semicolon
id|hub_piomap-&gt;hpio_flags
op_assign
id|HUB_PIOMAP_IS_BIGWINDOW
suffix:semicolon
id|IIO_ITTE_DISABLE
c_func
(paren
id|nasid
comma
id|bigwin
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;BRINGUP
id|hub_set_piomode
c_func
(paren
id|nasid
comma
id|HUB_PIO_CONVEYOR
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Set all the xwidgets in fire-and-forget mode&n;&t; * by default&n;&t; */
id|hub_set_piomode
c_func
(paren
id|nasid
comma
id|HUB_PIO_FIRE_N_FORGET
)paren
suffix:semicolon
macro_line|#endif&t;/* BRINGUP */
id|sv_init
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
comma
id|SV_FIFO
comma
l_string|&quot;bigwin&quot;
)paren
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
comma
l_string|&quot;bigwin&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Create a caddr_t-to-xtalk_addr mapping.&n; *&n; * Use a small window if possible (that&squot;s the usual case), but&n; * manage big windows if needed.  Big window mappings can be&n; * either FIXED or UNFIXED -- we keep at least 1 big window available&n; * for UNFIXED mappings.&n; *&n; * Returns an opaque pointer-sized type which can be passed to&n; * other hub_pio_* routines on success, or NULL if the request&n; * cannot be satisfied.&n; */
multiline_comment|/* ARGSUSED */
id|hub_piomap_t
DECL|function|hub_piomap_alloc
id|hub_piomap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mapping for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk_addr range */
r_int
id|byte_count
comma
r_int
id|byte_count_max
comma
multiline_comment|/* maximum size of a mapping */
r_int
id|flags
)paren
multiline_comment|/* defined in sys/pio.h */
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|devfs_handle_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|hub_piomap_t
id|bw_piomap
suffix:semicolon
r_int
id|bigwin
comma
id|free_bw_index
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_volatile
id|hubreg_t
id|junk
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|byte_count_max
OG
id|byte_count
)paren
r_return
l_int|NULL
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
multiline_comment|/* If xtalk_addr range is mapped by a small window, we don&squot;t have &n;&t; * to do much &n;&t; */
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
op_le
id|SWIN_SIZE
)paren
r_return
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
multiline_comment|/* We need to use a big window mapping.  */
multiline_comment|/*&n;&t; * TBD: Allow requests that would consume multiple big windows --&n;&t; * split the request up and use multiple mapping entries.&n;&t; * For now, reject requests that span big windows.&n;&t; */
r_if
c_cond
(paren
(paren
id|xtalk_addr
op_mod
id|BWIN_SIZE
)paren
op_plus
id|byte_count
OG
id|BWIN_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Round xtalk address down for big window alignement */
id|xtalk_addr
op_assign
id|xtalk_addr
op_amp
op_complement
(paren
id|BWIN_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if an existing big window mapping will suffice.&n;&t; */
id|tryagain
suffix:colon
id|free_bw_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bigwin
op_assign
l_int|0
suffix:semicolon
id|bigwin
OL
id|HUB_NUM_BIG_WINDOW
suffix:semicolon
id|bigwin
op_increment
)paren
(brace
id|bw_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|bigwin
)paren
suffix:semicolon
multiline_comment|/* If mapping is not valid, skip it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bw_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
)paren
(brace
id|free_bw_index
op_assign
id|bigwin
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * If mapping is UNFIXED, skip it.  We don&squot;t allow sharing&n;&t;&t; * of UNFIXED mappings, because this would allow starvation.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bw_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_FIXED
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_eq
id|bw_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_logical_and
id|widget
op_eq
id|bw_piomap-&gt;hpio_xtalk_info.xp_target
)paren
(brace
id|bw_piomap-&gt;hpio_holdcnt
op_increment
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_return
id|bw_piomap
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * None of the existing big window mappings will work for us --&n;&t; * we need to establish a new mapping.&n;&t; */
multiline_comment|/* Insure that we don&squot;t consume all big windows with FIXED mappings */
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|hubinfo-&gt;h_num_big_window_fixed
OL
id|HUB_NUM_BIG_WINDOW
op_minus
l_int|1
)paren
(brace
id|ASSERT
c_func
(paren
id|free_bw_index
op_ge
l_int|0
)paren
suffix:semicolon
id|hubinfo-&gt;h_num_big_window_fixed
op_increment
suffix:semicolon
)brace
r_else
(brace
id|bw_piomap
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* PIOMAP_UNFIXED */
(brace
r_if
c_cond
(paren
id|free_bw_index
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_NOSLEEP
)paren
(brace
id|bw_piomap
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|sv_wait
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
comma
id|PZERO
comma
op_amp
id|hubinfo-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_goto
id|tryagain
suffix:semicolon
)brace
)brace
multiline_comment|/* OK!  Allocate big window free_bw_index for this mapping. */
multiline_comment|/* &n;&t; * The code below does a PIO write to setup an ITTE entry.&n;&t; * We need to prevent other CPUs from seeing our updated memory &n;&t; * shadow of the ITTE (in the piomap) until the ITTE entry is &n;&t; * actually set up; otherwise, another CPU might attempt a PIO &n;&t; * prematurely.  &n;&t; *&n;&t; * Also, the only way we can know that an entry has been received &n;&t; * by the hub and can be used by future PIO reads/writes is by &n;&t; * reading back the ITTE entry after writing it.&n;&t; *&n;&t; * For these two reasons, we PIO read back the ITTE entry after&n;&t; * we write it.&n;&t; */
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|IIO_ITTE_PUT
c_func
(paren
id|nasid
comma
id|free_bw_index
comma
id|HUB_PIO_MAP_TO_MEM
comma
id|widget
comma
id|xtalk_addr
)paren
suffix:semicolon
id|junk
op_assign
id|HUB_L
c_func
(paren
id|IIO_ITTE_GET
c_func
(paren
id|nasid
comma
id|free_bw_index
)paren
)paren
suffix:semicolon
id|bw_piomap
op_assign
id|hubinfo_bwin_piomap_get
c_func
(paren
id|hubinfo
comma
id|free_bw_index
)paren
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_dev
op_assign
id|dev
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_target
op_assign
id|widget
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_assign
id|xtalk_addr
suffix:semicolon
id|bw_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_assign
(paren
id|caddr_t
)paren
id|NODE_BWIN_BASE
c_func
(paren
id|nasid
comma
id|free_bw_index
)paren
suffix:semicolon
id|bw_piomap-&gt;hpio_holdcnt
op_increment
suffix:semicolon
id|bw_piomap-&gt;hpio_bigwin_num
op_assign
id|free_bw_index
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PIOMAP_FIXED
)paren
id|bw_piomap-&gt;hpio_flags
op_or_assign
id|HUB_PIOMAP_IS_VALID
op_or
id|HUB_PIOMAP_IS_FIXED
suffix:semicolon
r_else
id|bw_piomap-&gt;hpio_flags
op_or_assign
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
id|done
suffix:colon
id|mutex_spinunlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_return
id|bw_piomap
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_piomap_free destroys a caddr_t-to-xtalk pio mapping and frees&n; * any associated mapping resources.  &n; *&n; * If this * piomap was handled with a small window, or if it was handled&n; * in a big window that&squot;s still in use by someone else, then there&squot;s &n; * nothing to do.  On the other hand, if this mapping was handled &n; * with a big window, AND if we were the final user of that mapping, &n; * then destroy the mapping.&n; */
r_void
DECL|function|hub_piomap_free
id|hub_piomap_free
c_func
(paren
id|hub_piomap_t
id|hub_piomap
)paren
(brace
id|devfs_handle_t
id|hubv
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* &n;&t; * Small windows are permanently mapped to corresponding widgets,&n;&t; * so there&squot;re no resources to free.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_BIGWINDOW
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_piomap-&gt;hpio_holdcnt
OG
l_int|0
)paren
suffix:semicolon
id|hubv
op_assign
id|hub_piomap-&gt;hpio_hub
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is the last hold on this mapping, free it.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|hub_piomap-&gt;hpio_holdcnt
op_eq
l_int|0
)paren
(brace
id|IIO_ITTE_DISABLE
c_func
(paren
id|nasid
comma
id|hub_piomap-&gt;hpio_bigwin_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_FIXED
)paren
(brace
id|hub_piomap-&gt;hpio_flags
op_and_assign
op_complement
(paren
id|HUB_PIOMAP_IS_VALID
op_or
id|HUB_PIOMAP_IS_FIXED
)paren
suffix:semicolon
id|hubinfo-&gt;h_num_big_window_fixed
op_decrement
suffix:semicolon
id|ASSERT
c_func
(paren
id|hubinfo-&gt;h_num_big_window_fixed
op_ge
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|hub_piomap-&gt;hpio_flags
op_and_assign
op_complement
id|HUB_PIOMAP_IS_VALID
suffix:semicolon
(paren
r_void
)paren
id|sv_signal
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwwait
)paren
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|hubinfo-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Establish a mapping to a given xtalk address range using the resources&n; * allocated earlier.&n; */
id|caddr_t
DECL|function|hub_piomap_addr
id|hub_piomap_addr
c_func
(paren
id|hub_piomap_t
id|hub_piomap
comma
multiline_comment|/* mapping resources */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* map for this xtalk address */
r_int
id|byte_count
)paren
multiline_comment|/* map this many bytes */
(brace
multiline_comment|/* Verify that range can be mapped using the specified piomap */
r_if
c_cond
(paren
id|xtalk_addr
OL
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
OG
(paren
id|hub_piomap-&gt;hpio_xtalk_info.xp_xtalk_addr
op_plus
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hub_piomap-&gt;hpio_flags
op_amp
id|HUB_PIOMAP_IS_VALID
)paren
r_return
id|hub_piomap-&gt;hpio_xtalk_info.xp_kvaddr
op_plus
(paren
id|xtalk_addr
op_mod
id|hub_piomap-&gt;hpio_xtalk_info.xp_mapsz
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver indicates that it&squot;s done with PIO&squot;s from an earlier piomap_addr.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|hub_piomap_done
id|hub_piomap_done
c_func
(paren
id|hub_piomap_t
id|hub_piomap
)paren
multiline_comment|/* done with these mapping resources */
(brace
multiline_comment|/* Nothing to do */
)brace
multiline_comment|/*&n; * For translations that require no mapping resources, supply a kernel virtual&n; * address that maps to the specified xtalk address range.&n; */
multiline_comment|/* ARGSUSED */
id|caddr_t
DECL|function|hub_piotrans_addr
id|hub_piotrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate to this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|iopaddr_t
id|xtalk_addr
comma
multiline_comment|/* Crosstalk address */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
r_int
id|flags
)paren
multiline_comment|/* (currently unused) */
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|devfs_handle_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hub_piomap_t
id|hub_piomap
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_addr
op_plus
id|byte_count
op_le
id|SWIN_SIZE
)paren
(brace
id|hub_piomap
op_assign
id|hubinfo_swin_piomap_get
c_func
(paren
id|hubinfo
comma
(paren
r_int
)paren
id|widget
)paren
suffix:semicolon
r_return
id|hub_piomap_addr
c_func
(paren
id|hub_piomap
comma
id|xtalk_addr
comma
id|byte_count
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* DMA MANAGEMENT */
multiline_comment|/* Mapping from crosstalk space to system physical space */
multiline_comment|/* &n; * There&squot;s not really very much to do here, since crosstalk maps&n; * directly to system physical space.  It&squot;s quite possible that this&n; * DMA layer will be bypassed in performance kernels.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|hub_dma_init
id|hub_dma_init
c_func
(paren
id|devfs_handle_t
id|hubv
)paren
(brace
)brace
multiline_comment|/*&n; * Allocate resources needed to set up DMA mappings up to a specified size&n; * on a specified adapter.&n; * &n; * We don&squot;t actually use the adapter ID for anything.  It&squot;s just the adapter&n; * that the lower level driver plans to use for DMA.&n; */
multiline_comment|/* ARGSUSED */
id|hub_dmamap_t
DECL|function|hub_dmamap_alloc
id|hub_dmamap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
multiline_comment|/* defined in dma.h */
(brace
id|hub_dmamap_t
id|dmamap
suffix:semicolon
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|devfs_handle_t
id|hubv
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|dmamap
op_assign
id|kern_malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hub_dmamap_s
)paren
)paren
suffix:semicolon
id|dmamap-&gt;hdma_xtalk_info.xd_dev
op_assign
id|dev
suffix:semicolon
id|dmamap-&gt;hdma_xtalk_info.xd_target
op_assign
id|widget
suffix:semicolon
id|dmamap-&gt;hdma_hub
op_assign
id|hubv
suffix:semicolon
id|dmamap-&gt;hdma_flags
op_assign
id|HUB_DMAMAP_IS_VALID
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XTALK_FIXED
)paren
id|dmamap-&gt;hdma_flags
op_or_assign
id|HUB_DMAMAP_IS_FIXED
suffix:semicolon
r_return
id|dmamap
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy a DMA mapping from crosstalk space to system address space.&n; * There is no actual mapping hardware to destroy, but we at least mark&n; * the dmamap INVALID and free the space that it took.&n; */
r_void
DECL|function|hub_dmamap_free
id|hub_dmamap_free
c_func
(paren
id|hub_dmamap_t
id|hub_dmamap
)paren
(brace
id|hub_dmamap-&gt;hdma_flags
op_and_assign
op_complement
id|HUB_DMAMAP_IS_VALID
suffix:semicolon
id|kern_free
c_func
(paren
id|hub_dmamap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Establish a DMA mapping using the resources allocated in a previous dmamap_alloc.&n; * Return an appropriate crosstalk address range that maps to the specified physical &n; * address range.&n; */
multiline_comment|/* ARGSUSED */
r_extern
id|iopaddr_t
DECL|function|hub_dmamap_addr
id|hub_dmamap_addr
c_func
(paren
id|hub_dmamap_t
id|dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
multiline_comment|/* map this many bytes */
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|ASSERT
c_func
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_VALID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_USED
)paren
(brace
multiline_comment|/* If the map is FIXED, re-use is OK. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_FIXED
)paren
)paren
(brace
id|vhdl
op_assign
id|dmamap-&gt;hdma_xtalk_info.xd_dev
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%v: hub_dmamap_addr re-uses dmamap.&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;0x%p: hub_dmamap_addr re-uses dmamap.&bslash;n&quot;
comma
op_amp
id|vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|dmamap-&gt;hdma_flags
op_or_assign
id|HUB_DMAMAP_USED
suffix:semicolon
)brace
multiline_comment|/* There isn&squot;t actually any DMA mapping hardware on the hub. */
r_return
id|paddr
suffix:semicolon
)brace
multiline_comment|/*&n; * Establish a DMA mapping using the resources allocated in a previous dmamap_alloc.&n; * Return an appropriate crosstalk address list that maps to the specified physical &n; * address list.&n; */
multiline_comment|/* ARGSUSED */
id|alenlist_t
DECL|function|hub_dmamap_list
id|hub_dmamap_list
c_func
(paren
id|hub_dmamap_t
id|hub_dmamap
comma
multiline_comment|/* use these mapping resources */
id|alenlist_t
id|palenlist
comma
multiline_comment|/* map this area of memory */
r_int
id|flags
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_VALID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_USED
)paren
(brace
multiline_comment|/* If the map is FIXED, re-use is OK. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_FIXED
)paren
)paren
(brace
id|vhdl
op_assign
id|hub_dmamap-&gt;hdma_xtalk_info.xd_dev
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%v: hub_dmamap_list re-uses dmamap&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;0x%p: hub_dmamap_list re-uses dmamap&bslash;n&quot;
comma
op_amp
id|vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|hub_dmamap-&gt;hdma_flags
op_or_assign
id|HUB_DMAMAP_USED
suffix:semicolon
)brace
multiline_comment|/* There isn&squot;t actually any DMA mapping hardware on the hub.  */
r_return
id|palenlist
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver indicates that it has completed whatever DMA it may have started&n; * after an earlier dmamap_addr or dmamap_list call.&n; */
r_void
DECL|function|hub_dmamap_done
id|hub_dmamap_done
c_func
(paren
id|hub_dmamap_t
id|hub_dmamap
)paren
multiline_comment|/* done with these mapping resources */
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_if
c_cond
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_USED
)paren
(brace
id|hub_dmamap-&gt;hdma_flags
op_and_assign
op_complement
id|HUB_DMAMAP_USED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the map is FIXED, re-done is OK. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hub_dmamap-&gt;hdma_flags
op_amp
id|HUB_DMAMAP_IS_FIXED
)paren
)paren
(brace
id|vhdl
op_assign
id|hub_dmamap-&gt;hdma_xtalk_info.xd_dev
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%v: hub_dmamap_done already done with dmamap&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;0x%p: hub_dmamap_done already done with dmamap&bslash;n&quot;
comma
op_amp
id|vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/*&n; * Translate a single system physical address into a crosstalk address.&n; */
multiline_comment|/* ARGSUSED */
id|iopaddr_t
DECL|function|hub_dmatrans_addr
id|hub_dmatrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
multiline_comment|/* defined in dma.h */
(brace
multiline_comment|/* no translation needed */
r_return
id|paddr
suffix:semicolon
)brace
multiline_comment|/*&n; * Translate a list of IP27 addresses and lengths into a list of crosstalk &n; * addresses and lengths.  No actual hardware mapping takes place; the hub &n; * has no DMA mapping registers -- crosstalk addresses map directly.&n; */
multiline_comment|/* ARGSUSED */
id|alenlist_t
DECL|function|hub_dmatrans_list
id|hub_dmatrans_list
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|alenlist_t
id|palenlist
comma
multiline_comment|/* system address/length list */
r_int
id|flags
)paren
multiline_comment|/* defined in dma.h */
(brace
multiline_comment|/* no translation needed */
r_return
id|palenlist
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hub_dmamap_drain
id|hub_dmamap_drain
c_func
(paren
id|hub_dmamap_t
id|map
)paren
(brace
multiline_comment|/* XXX- flush caches, if cache coherency WAR is needed */
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hub_dmaaddr_drain
id|hub_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|paddr_t
id|addr
comma
r_int
id|bytes
)paren
(brace
multiline_comment|/* XXX- flush caches, if cache coherency WAR is needed */
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hub_dmalist_drain
id|hub_dmalist_drain
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|alenlist_t
id|list
)paren
(brace
multiline_comment|/* XXX- flush caches, if cache coherency WAR is needed */
)brace
multiline_comment|/* INTERRUPT MANAGEMENT */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|hub_intr_init
id|hub_intr_init
c_func
(paren
id|devfs_handle_t
id|hubv
)paren
(brace
)brace
multiline_comment|/*&n; * hub_device_desc_update&n; *&t;Update the passed in device descriptor with the actual the&n; * &t;target cpu number and interrupt priority level.&n; *&t;NOTE : These might be the same as the ones passed in thru&n; *&t;the descriptor.&n; */
r_static
r_void
DECL|function|hub_device_desc_update
id|hub_device_desc_update
c_func
(paren
id|device_desc_t
id|dev_desc
comma
id|ilvl_t
id|intr_swlevel
comma
id|cpuid_t
id|cpu
)paren
(brace
r_char
id|cpuname
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* Store the interrupt priority level in the device descriptor */
id|device_desc_intr_swlevel_set
c_func
(paren
id|dev_desc
comma
id|intr_swlevel
)paren
suffix:semicolon
multiline_comment|/* Convert the cpuid to the vertex handle in the hwgraph and&n;&t; * save it in the device descriptor.&n;&t; */
id|sprintf
c_func
(paren
id|cpuname
comma
l_string|&quot;/hw/cpunum/%ld&quot;
comma
id|cpu
)paren
suffix:semicolon
id|device_desc_intr_target_set
c_func
(paren
id|dev_desc
comma
id|hwgraph_path_to_dev
c_func
(paren
id|cpuname
)paren
)paren
suffix:semicolon
)brace
DECL|variable|allocate_my_bit
r_int
id|allocate_my_bit
op_assign
id|INTRCONNECT_ANYBIT
suffix:semicolon
multiline_comment|/*&n; * Allocate resources required for an interrupt as specified in dev_desc.&n; * Returns a hub interrupt handle on success, or 0 on failure.&n; */
id|hub_intr_t
DECL|function|hub_intr_alloc
id|hub_intr_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* which crosstalk device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|devfs_handle_t
id|owner_dev
)paren
multiline_comment|/* owner of this interrupt, if known */
(brace
id|cpuid_t
id|cpu
suffix:semicolon
multiline_comment|/* cpu to receive interrupt */
r_int
id|cpupicked
op_assign
l_int|0
suffix:semicolon
r_int
id|bit
suffix:semicolon
multiline_comment|/* interrupt vector */
multiline_comment|/*REFERENCED*/
r_int
id|intr_resflags
suffix:semicolon
id|hub_intr_t
id|intr_hdl
suffix:semicolon
id|cnodeid_t
id|nodeid
suffix:semicolon
multiline_comment|/* node to receive interrupt */
multiline_comment|/*REFERENCED*/
id|nasid_t
id|nasid
suffix:semicolon
multiline_comment|/* nasid to receive interrupt */
r_struct
id|xtalk_intr_s
op_star
id|xtalk_info
suffix:semicolon
id|iopaddr_t
id|xtalk_addr
suffix:semicolon
multiline_comment|/* xtalk addr on hub to set intr */
id|xwidget_info_t
id|xwidget_info
suffix:semicolon
multiline_comment|/* standard crosstalk widget info handle */
r_char
op_star
id|intr_name
op_assign
l_int|NULL
suffix:semicolon
id|ilvl_t
id|intr_swlevel
suffix:semicolon
r_extern
r_int
id|default_intr_pri
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1 
r_extern
r_void
id|synergy_intr_alloc
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If caller didn&squot;t explicily specify a device descriptor, see if there&squot;s&n;&t; * a default descriptor associated with the device.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev_desc
)paren
id|dev_desc
op_assign
id|device_desc_default_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_desc
)paren
(brace
id|intr_name
op_assign
id|device_desc_intr_name_get
c_func
(paren
id|dev_desc
)paren
suffix:semicolon
id|intr_swlevel
op_assign
id|device_desc_intr_swlevel_get
c_func
(paren
id|dev_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_desc-&gt;flags
op_amp
id|D_INTR_ISERR
)paren
(brace
id|intr_resflags
op_assign
id|II_ERRORINT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev_desc-&gt;flags
op_amp
id|D_INTR_NOTHREAD
)paren
)paren
(brace
id|intr_resflags
op_assign
id|II_THREADED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Neither an error nor a thread. */
id|intr_resflags
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|intr_swlevel
op_assign
id|default_intr_pri
suffix:semicolon
id|intr_resflags
op_assign
id|II_THREADED
suffix:semicolon
)brace
multiline_comment|/* XXX - Need to determine if the interrupt should be threaded. */
multiline_comment|/* If the cpu has not been picked already then choose a candidate &n;&t; * interrupt target and reserve the interrupt bit &n;&t; */
macro_line|#if defined(NEW_INTERRUPTS)
r_if
c_cond
(paren
op_logical_neg
id|cpupicked
)paren
(brace
id|cpu
op_assign
id|intr_heuristic
c_func
(paren
id|dev
comma
id|dev_desc
comma
id|allocate_my_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
comma
op_amp
id|bit
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* At this point we SHOULD have a valid cpu */
r_if
c_cond
(paren
id|cpu
op_eq
id|CPU_NONE
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%v hub_intr_alloc could not allocate interrupt&bslash;n&quot;
comma
id|owner_dev
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;0x%p hub_intr_alloc could not allocate interrupt&bslash;n&quot;
comma
op_amp
id|owner_dev
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the cpu has been picked already (due to the bridge data &n;&t; * corruption bug) then try to reserve an interrupt bit .&n;&t; */
macro_line|#if defined(NEW_INTERRUPTS)
r_if
c_cond
(paren
id|cpupicked
)paren
(brace
id|bit
op_assign
id|intr_reserve_level
c_func
(paren
id|cpu
comma
id|allocate_my_bit
comma
id|intr_resflags
comma
id|owner_dev
comma
id|intr_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
l_int|0
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;Could not reserve an interrupt bit for cpu &quot;
l_string|&quot; %d and dev %v&bslash;n&quot;
comma
id|cpu
comma
id|owner_dev
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;Could not reserve an interrupt bit for cpu &quot;
l_string|&quot; %d and dev 0x%x&bslash;n&quot;
comma
id|cpu
comma
op_amp
id|owner_dev
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* NEW_INTERRUPTS */
id|nodeid
op_assign
id|cpuid_to_cnodeid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|nasid
op_assign
id|cpuid_to_nasid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|xtalk_addr
op_assign
id|HUBREG_AS_XTALKADDR
c_func
(paren
id|nasid
comma
id|PIREG
c_func
(paren
id|PI_INT_PEND_MOD
comma
id|cpuid_to_subnode
c_func
(paren
id|cpu
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate an interrupt handle, and fill it in.  There are two&n;&t; * pieces to an interrupt handle: the piece needed by generic&n;&t; * xtalk code which is used by crosstalk device drivers, and&n;&t; * the piece needed by low-level IP27 hardware code.&n;&t; */
id|intr_hdl
op_assign
id|kmem_alloc_node
c_func
(paren
r_sizeof
(paren
r_struct
id|hub_intr_s
)paren
comma
id|KM_NOSLEEP
comma
id|nodeid
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|intr_hdl
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Fill in xtalk information for generic xtalk interfaces that&n;&t; * operate on xtalk_intr_hdl&squot;s.&n;&t; */
id|xtalk_info
op_assign
op_amp
id|intr_hdl-&gt;i_xtalk_info
suffix:semicolon
id|xtalk_info-&gt;xi_dev
op_assign
id|dev
suffix:semicolon
id|xtalk_info-&gt;xi_vector
op_assign
id|bit
suffix:semicolon
id|xtalk_info-&gt;xi_addr
op_assign
id|xtalk_addr
suffix:semicolon
id|xtalk_info-&gt;xi_flags
op_assign
(paren
id|intr_resflags
op_eq
id|II_THREADED
)paren
ques
c_cond
l_int|0
suffix:colon
id|XTALK_INTR_NOTHREAD
suffix:semicolon
multiline_comment|/*&n;&t; * Regardless of which CPU we ultimately interrupt, a given crosstalk&n;&t; * widget always handles interrupts (and PIO and DMA) through its &n;&t; * designated &quot;master&quot; crosstalk provider.&n;&t; */
id|xwidget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xwidget_info
)paren
id|xtalk_info-&gt;xi_target
op_assign
id|xwidget_info_masterid_get
c_func
(paren
id|xwidget_info
)paren
suffix:semicolon
multiline_comment|/* Fill in low level hub information for hub_* interrupt interface */
id|intr_hdl-&gt;i_swlevel
op_assign
id|intr_swlevel
suffix:semicolon
id|intr_hdl-&gt;i_cpuid
op_assign
id|cpu
suffix:semicolon
id|intr_hdl-&gt;i_bit
op_assign
id|bit
suffix:semicolon
id|intr_hdl-&gt;i_flags
op_assign
id|HUB_INTR_IS_ALLOCED
suffix:semicolon
multiline_comment|/* Store the actual interrupt priority level &amp; interrupt target&n;&t; * cpu back in the device descriptor.&n;&t; */
id|hub_device_desc_update
c_func
(paren
id|dev_desc
comma
id|intr_swlevel
comma
id|cpu
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|synergy_intr_alloc
c_func
(paren
(paren
r_int
)paren
id|bit
comma
(paren
r_int
)paren
id|cpu
)paren
suffix:semicolon
macro_line|#endif
r_return
id|intr_hdl
suffix:semicolon
)brace
multiline_comment|/*&n; * Free resources consumed by intr_alloc.&n; */
r_void
DECL|function|hub_intr_free
id|hub_intr_free
c_func
(paren
id|hub_intr_t
id|intr_hdl
)paren
(brace
id|cpuid_t
id|cpu
op_assign
id|intr_hdl-&gt;i_cpuid
suffix:semicolon
r_int
id|bit
op_assign
id|intr_hdl-&gt;i_bit
suffix:semicolon
id|xtalk_intr_t
id|xtalk_info
suffix:semicolon
r_if
c_cond
(paren
id|intr_hdl-&gt;i_flags
op_amp
id|HUB_INTR_IS_CONNECTED
)paren
(brace
multiline_comment|/* Setting the following fields in the xtalk interrupt info&n;&t; &t; * clears the interrupt target register in the xtalk user&n;&t; &t; */
id|xtalk_info
op_assign
op_amp
id|intr_hdl-&gt;i_xtalk_info
suffix:semicolon
id|xtalk_info-&gt;xi_dev
op_assign
id|NODEV
suffix:semicolon
id|xtalk_info-&gt;xi_vector
op_assign
l_int|0
suffix:semicolon
id|xtalk_info-&gt;xi_addr
op_assign
l_int|0
suffix:semicolon
id|hub_intr_disconnect
c_func
(paren
id|intr_hdl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_hdl-&gt;i_flags
op_amp
id|HUB_INTR_IS_ALLOCED
)paren
id|kfree
c_func
(paren
id|intr_hdl
)paren
suffix:semicolon
macro_line|#if defined(NEW_INTERRUPTS)
id|intr_unreserve_level
c_func
(paren
id|cpu
comma
id|bit
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Associate resources allocated with a previous hub_intr_alloc call with the&n; * described handler, arg, name, etc.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|hub_intr_connect
id|hub_intr_connect
c_func
(paren
id|hub_intr_t
id|intr_hdl
comma
multiline_comment|/* xtalk intr resource handle */
id|intr_func_t
id|intr_func
comma
multiline_comment|/* xtalk intr handler */
r_void
op_star
id|intr_arg
comma
multiline_comment|/* arg to intr handler */
id|xtalk_intr_setfunc_t
id|setfunc
comma
multiline_comment|/* func to set intr hw */
r_void
op_star
id|setfunc_arg
comma
multiline_comment|/* arg to setfunc */
r_void
op_star
id|thread
)paren
multiline_comment|/* intr thread to use */
(brace
r_int
id|rv
suffix:semicolon
id|cpuid_t
id|cpu
op_assign
id|intr_hdl-&gt;i_cpuid
suffix:semicolon
r_int
id|bit
op_assign
id|intr_hdl-&gt;i_bit
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
r_extern
r_int
id|synergy_intr_connect
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|intr_hdl-&gt;i_flags
op_amp
id|HUB_INTR_IS_ALLOCED
)paren
suffix:semicolon
macro_line|#if defined(NEW_INTERRUPTS)
id|rv
op_assign
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|bit
comma
id|intr_hdl-&gt;i_swlevel
comma
id|intr_func
comma
id|intr_arg
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
OL
l_int|0
)paren
r_return
id|rv
suffix:semicolon
macro_line|#endif
id|intr_hdl-&gt;i_xtalk_info.xi_setfunc
op_assign
id|setfunc
suffix:semicolon
id|intr_hdl-&gt;i_xtalk_info.xi_sfarg
op_assign
id|setfunc_arg
suffix:semicolon
r_if
c_cond
(paren
id|setfunc
)paren
(paren
op_star
id|setfunc
)paren
(paren
(paren
id|xtalk_intr_t
)paren
id|intr_hdl
)paren
suffix:semicolon
id|intr_hdl-&gt;i_flags
op_or_assign
id|HUB_INTR_IS_CONNECTED
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
r_return
id|synergy_intr_connect
c_func
(paren
(paren
r_int
)paren
id|bit
comma
(paren
r_int
)paren
id|cpu
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Disassociate handler with the specified interrupt.&n; */
r_void
DECL|function|hub_intr_disconnect
id|hub_intr_disconnect
c_func
(paren
id|hub_intr_t
id|intr_hdl
)paren
(brace
multiline_comment|/*REFERENCED*/
r_int
id|rv
suffix:semicolon
id|cpuid_t
id|cpu
op_assign
id|intr_hdl-&gt;i_cpuid
suffix:semicolon
r_int
id|bit
op_assign
id|intr_hdl-&gt;i_bit
suffix:semicolon
id|xtalk_intr_setfunc_t
id|setfunc
suffix:semicolon
id|setfunc
op_assign
id|intr_hdl-&gt;i_xtalk_info.xi_setfunc
suffix:semicolon
multiline_comment|/* TBD: send disconnected interrupts somewhere harmless */
r_if
c_cond
(paren
id|setfunc
)paren
(paren
op_star
id|setfunc
)paren
(paren
(paren
id|xtalk_intr_t
)paren
id|intr_hdl
)paren
suffix:semicolon
macro_line|#if defined(NEW_INTERRUPTS)
id|rv
op_assign
id|intr_disconnect_level
c_func
(paren
id|cpu
comma
id|bit
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rv
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|intr_hdl-&gt;i_flags
op_and_assign
op_complement
id|HUB_INTR_IS_CONNECTED
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a hwgraph vertex that represents the CPU currently&n; * targeted by an interrupt.&n; */
id|devfs_handle_t
DECL|function|hub_intr_cpu_get
id|hub_intr_cpu_get
c_func
(paren
id|hub_intr_t
id|intr_hdl
)paren
(brace
id|cpuid_t
id|cpuid
op_assign
id|intr_hdl-&gt;i_cpuid
suffix:semicolon
id|ASSERT
c_func
(paren
id|cpuid
op_ne
id|CPU_NONE
)paren
suffix:semicolon
r_return
id|cpuid_to_vertex
c_func
(paren
id|cpuid
)paren
suffix:semicolon
)brace
multiline_comment|/* CONFIGURATION MANAGEMENT */
multiline_comment|/*&n; * Perform initializations that allow this hub to start crosstalk support.&n; */
r_void
DECL|function|hub_provider_startup
id|hub_provider_startup
c_func
(paren
id|devfs_handle_t
id|hubv
)paren
(brace
id|hub_pio_init
c_func
(paren
id|hubv
)paren
suffix:semicolon
id|hub_dma_init
c_func
(paren
id|hubv
)paren
suffix:semicolon
id|hub_intr_init
c_func
(paren
id|hubv
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shutdown crosstalk support from a hub.&n; */
r_void
DECL|function|hub_provider_shutdown
id|hub_provider_shutdown
c_func
(paren
id|devfs_handle_t
id|hub
)paren
(brace
multiline_comment|/* TBD */
id|xtalk_provider_unregister
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that an address is in teh real small window widget 0 space&n; * or else in the big window we&squot;re using to emulate small window 0&n; * in the kernel.&n; */
r_int
DECL|function|hub_check_is_widget0
id|hub_check_is_widget0
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|__psunsigned_t
)paren
id|addr
op_ge
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|0
)paren
)paren
op_logical_and
(paren
(paren
id|__psunsigned_t
)paren
id|addr
OL
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|1
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that two addresses use the same widget&n; */
r_int
DECL|function|hub_check_window_equiv
id|hub_check_window_equiv
c_func
(paren
r_void
op_star
id|addra
comma
r_void
op_star
id|addrb
)paren
(brace
r_if
c_cond
(paren
id|hub_check_is_widget0
c_func
(paren
id|addra
)paren
op_logical_and
id|hub_check_is_widget0
c_func
(paren
id|addrb
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* XXX - Assume this is really a small window address */
r_if
c_cond
(paren
id|WIDGETID_GET
c_func
(paren
(paren
id|__psunsigned_t
)paren
id|addra
)paren
op_eq
id|WIDGETID_GET
c_func
(paren
(paren
id|__psunsigned_t
)paren
id|addrb
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine whether two PCI addresses actually refer to the same device.&n; * This only works if both addresses are in small windows.  It&squot;s used to&n; * determine whether prom addresses refer to particular PCI devices.&n; */
multiline_comment|/*&t;&n; * XXX - This won&squot;t work as written if we ever have more than two nodes&n; * on a crossbow.  In that case, we&squot;ll need an array or partners.&n; */
r_int
DECL|function|hub_check_pci_equiv
id|hub_check_pci_equiv
c_func
(paren
r_void
op_star
id|addra
comma
r_void
op_star
id|addrb
)paren
(brace
id|nasid_t
id|nasida
comma
id|nasidb
suffix:semicolon
multiline_comment|/*&n;&t; * This is for a permanent workaround that causes us to use a&n;&t; * big window in place of small window 0.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hub_check_window_equiv
c_func
(paren
id|addra
comma
id|addrb
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If the offsets aren&squot;t the same, forget it. */
r_if
c_cond
(paren
id|SWIN_WIDGETADDR
c_func
(paren
(paren
id|__psunsigned_t
)paren
id|addra
)paren
op_ne
(paren
id|SWIN_WIDGETADDR
c_func
(paren
(paren
id|__psunsigned_t
)paren
id|addrb
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Now, check the nasids */
id|nasida
op_assign
id|NASID_GET
c_func
(paren
id|addra
)paren
suffix:semicolon
id|nasidb
op_assign
id|NASID_GET
c_func
(paren
id|addrb
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasida
)paren
op_ne
id|INVALID_NASID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasidb
)paren
op_ne
id|INVALID_NASID
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Either the NASIDs must be the same or they must be crossbow&n;&t; * partners (on the same crossbow).&n;&t; */
r_return
(paren
id|check_nasid_equiv
c_func
(paren
id|nasida
comma
id|nasidb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_setup_prb(nasid, prbnum, credits, conveyor)&n; *&n; * &t;Put a PRB into fire-and-forget mode if conveyor isn&squot;t set.  Otehrwise,&n; * &t;put it into conveyor belt mode with the specified number of credits.&n; */
r_void
DECL|function|hub_setup_prb
id|hub_setup_prb
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|prbnum
comma
r_int
id|credits
comma
r_int
id|conveyor
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
r_int
id|prb_offset
suffix:semicolon
macro_line|#ifdef IRIX
r_extern
r_int
id|force_fire_and_forget
suffix:semicolon
r_extern
r_volatile
r_int
id|ignore_conveyor_override
suffix:semicolon
r_if
c_cond
(paren
id|force_fire_and_forget
op_logical_and
op_logical_neg
id|ignore_conveyor_override
)paren
r_if
c_cond
(paren
id|conveyor
op_eq
id|HUB_PIO_CONVEYOR
)paren
id|conveyor
op_assign
id|HUB_PIO_FIRE_N_FORGET
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get the current register value.&n;&t; */
id|prb_offset
op_assign
id|IIO_IOPRB
c_func
(paren
id|prbnum
)paren
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|prb_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out some fields.&n;&t; */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Enable or disable fire-and-forget mode.&n;&t; */
id|prb.iprb_ff
op_assign
(paren
(paren
id|conveyor
op_eq
id|HUB_PIO_CONVEYOR
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the appropriate number of PIO cresits for the widget.&n;&t; */
id|prb.iprb_xtalkctr
op_assign
id|credits
suffix:semicolon
multiline_comment|/*&n;&t; * Store the new value to the register.&n;&t; */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|prb_offset
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_set_piomode()&n; *&n; * &t;Put the hub into either &quot;PIO conveyor belt&quot; mode or &quot;fire-and-forget&quot;&n; * &t;mode.  To do this, we have to make absolutely sure that no PIOs&n; *&t;are in progress so we turn off access to all widgets for the duration&n; *&t;of the function.&n; * &n; * XXX - This code should really check what kind of widget we&squot;re talking&n; * to.  Bridges can only handle three requests, but XG will do more.&n; * How many can crossbow handle to widget 0?  We&squot;re assuming 1.&n; *&n; * XXX - There is a bug in the crossbow that link reset PIOs do not&n; * return write responses.  The easiest solution to this problem is to&n; * leave widget 0 (xbow) in fire-and-forget mode at all times.  This&n; * only affects pio&squot;s to xbow registers, which should be rare.&n; */
r_void
DECL|function|hub_set_piomode
id|hub_set_piomode
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|conveyor
)paren
(brace
id|hubreg_t
id|ii_iowa
suffix:semicolon
r_int
id|direct_connect
suffix:semicolon
id|hubii_wcr_t
id|ii_wcr
suffix:semicolon
r_int
id|prbnum
suffix:semicolon
r_int
id|s
comma
id|cons_lock
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
op_ne
id|INVALID_CNODEID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|get_console_nasid
c_func
(paren
)paren
)paren
(brace
id|PUTBUF_LOCK
c_func
(paren
id|s
)paren
suffix:semicolon
id|cons_lock
op_assign
l_int|1
suffix:semicolon
)brace
id|ii_iowa
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
comma
l_int|0
)paren
suffix:semicolon
id|ii_wcr.wcr_reg_value
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_WCR
)paren
suffix:semicolon
id|direct_connect
op_assign
id|ii_wcr.iwcr_dir_con
suffix:semicolon
r_if
c_cond
(paren
id|direct_connect
)paren
(brace
multiline_comment|/* &n;&t;&t; * Assume a bridge here.&n;&t;&t; */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
l_int|0
comma
l_int|3
comma
id|conveyor
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * Assume a crossbow here.&n;&t;&t; */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
l_int|0
comma
l_int|1
comma
id|conveyor
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|prbnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|prbnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|prbnum
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX - Here&squot;s where we should take the widget type into&n;&t;&t; * when account assigning credits.&n;&t;&t; */
multiline_comment|/* Always set the PRBs in fire-and-forget mode */
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|prbnum
comma
l_int|3
comma
id|conveyor
)paren
suffix:semicolon
)brace
macro_line|#ifdef IRIX
multiline_comment|/*&n;&t; * In direct connect mode, disable access to all widgets but 0.&n;&t; * Later, the prom will do this for us.&n;&t; */
r_if
c_cond
(paren
id|direct_connect
)paren
id|ii_iowa
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_OUTWIDGET_ACCESS
comma
id|ii_iowa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons_lock
)paren
id|PUTBUF_UNLOCK
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* Interface to allow special drivers to set hub specific&n; * device flags.&n; * Return 0 on failure , 1 on success&n; */
r_int
DECL|function|hub_widget_flags_set
id|hub_widget_flags_set
c_func
(paren
id|nasid_t
id|nasid
comma
id|xwidgetnum_t
id|widget_num
comma
id|hub_widget_flags_t
id|flags
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|HUB_WIDGET_FLAGS
)paren
op_eq
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|HUB_PIO_CONVEYOR
)paren
(brace
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|widget_num
comma
l_int|3
comma
id|HUB_PIO_CONVEYOR
)paren
suffix:semicolon
multiline_comment|/* set the PRB in conveyor &n;&t;&t;&t;&t;&t;&t;    * belt mode with 3 credits&n;&t;&t;&t;&t;&t;&t;    */
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|HUB_PIO_FIRE_N_FORGET
)paren
(brace
id|hub_setup_prb
c_func
(paren
id|nasid
comma
id|widget_num
comma
l_int|3
comma
id|HUB_PIO_FIRE_N_FORGET
)paren
suffix:semicolon
multiline_comment|/* set the PRB in fire&n;&t;&t;&t;&t;&t;&t;&t; *  and forget mode &n;&t;&t;&t;&t;&t;&t;&t; */
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Interface to allow special drivers to set hub specific&n; * device flags.&n; * Return 0 on failure , 1 on success&n; */
r_int
DECL|function|hub_device_flags_set
id|hub_device_flags_set
c_func
(paren
id|devfs_handle_t
id|widget_vhdl
comma
id|hub_widget_flags_t
id|flags
)paren
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|widget_vhdl
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget_num
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|devfs_handle_t
id|hub_vhdl
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hubinfo_t
id|hub_info
op_assign
l_int|0
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|s
comma
id|rv
suffix:semicolon
multiline_comment|/* Use the nasid from the hub info hanging off the hub vertex&n;&t; * and widget number from the widget vertex&n;&t; */
id|hubinfo_get
c_func
(paren
id|hub_vhdl
comma
op_amp
id|hub_info
)paren
suffix:semicolon
multiline_comment|/* Being over cautious by grabbing a lock */
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
)paren
suffix:semicolon
id|nasid
op_assign
id|hub_info-&gt;h_nasid
suffix:semicolon
id|rv
op_assign
id|hub_widget_flags_set
c_func
(paren
id|nasid
comma
id|widget_num
comma
id|flags
)paren
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#if ((defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)) &amp;&amp; defined(BRINGUP))
multiline_comment|/* BRINGUP:  This ought to be useful for IP27 too but, for now,&n; * make it SN1 only because `ii_ixtt_u_t&squot; is not in IP27/hubio.h&n; * (or anywhere else :-).&n; */
r_int
DECL|function|hubii_ixtt_set
id|hubii_ixtt_set
c_func
(paren
id|devfs_handle_t
id|widget_vhdl
comma
id|ii_ixtt_u_t
op_star
id|ixtt
)paren
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|widget_vhdl
)paren
suffix:semicolon
id|devfs_handle_t
id|hub_vhdl
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hubinfo_t
id|hub_info
op_assign
l_int|0
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* Use the nasid from the hub info hanging off the hub vertex&n;&t; * and widget number from the widget vertex&n;&t; */
id|hubinfo_get
c_func
(paren
id|hub_vhdl
comma
op_amp
id|hub_info
)paren
suffix:semicolon
multiline_comment|/* Being over cautious by grabbing a lock */
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
)paren
suffix:semicolon
id|nasid
op_assign
id|hub_info-&gt;h_nasid
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IXTT
comma
id|ixtt-&gt;ii_ixtt_regval
)paren
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|hubii_ixtt_get
id|hubii_ixtt_get
c_func
(paren
id|devfs_handle_t
id|widget_vhdl
comma
id|ii_ixtt_u_t
op_star
id|ixtt
)paren
(brace
id|xwidget_info_t
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|widget_vhdl
)paren
suffix:semicolon
id|devfs_handle_t
id|hub_vhdl
op_assign
id|xwidget_info_master_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
id|hubinfo_t
id|hub_info
op_assign
l_int|0
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* Use the nasid from the hub info hanging off the hub vertex&n;&t; * and widget number from the widget vertex&n;&t; */
id|hubinfo_get
c_func
(paren
id|hub_vhdl
comma
op_amp
id|hub_info
)paren
suffix:semicolon
multiline_comment|/* Being over cautious by grabbing a lock */
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
)paren
suffix:semicolon
id|nasid
op_assign
id|hub_info-&gt;h_nasid
suffix:semicolon
id|ixtt-&gt;ii_ixtt_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IXTT
)paren
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|hub_info-&gt;h_bwlock
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IA64_SGI_SN1 */
multiline_comment|/*&n; * hub_device_inquiry&n; *&t;Find out the xtalk widget related information stored in this &n; *&t;hub&squot;s II.&n; */
r_void
DECL|function|hub_device_inquiry
id|hub_device_inquiry
c_func
(paren
id|devfs_handle_t
id|xbus_vhdl
comma
id|xwidgetnum_t
id|widget
)paren
(brace
id|devfs_handle_t
id|xconn
comma
id|hub_vhdl
suffix:semicolon
r_char
id|widget_name
(braket
l_int|8
)braket
suffix:semicolon
id|hubreg_t
id|ii_iidem
comma
id|ii_iiwa
comma
id|ii_iowa
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|d
suffix:semicolon
id|sprintf
c_func
(paren
id|widget_name
comma
l_string|&quot;%d&quot;
comma
id|widget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xbus_vhdl
comma
id|widget_name
comma
op_amp
id|xconn
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
suffix:semicolon
id|hub_vhdl
op_assign
id|device_master_get
c_func
(paren
id|xconn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub_vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
r_return
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_vhdl
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hubinfo
)paren
r_return
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|ii_iidem
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IIDEM
)paren
suffix:semicolon
id|ii_iiwa
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IIWA
)paren
suffix:semicolon
id|ii_iowa
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOWA
)paren
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;Inquiry Info for %v&bslash;n&quot;
comma
id|xconn
)paren
suffix:semicolon
macro_line|#else
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;Inquiry Info for 0x%p&bslash;n&quot;
comma
op_amp
id|xconn
)paren
suffix:semicolon
macro_line|#endif
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;&bslash;tDevices shutdown [ &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
l_int|0
suffix:semicolon
id|d
op_le
l_int|7
suffix:semicolon
id|d
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|ii_iidem
op_amp
(paren
id|IIO_IIDEM_WIDGETDEV_MASK
c_func
(paren
id|widget
comma
id|d
)paren
)paren
)paren
)paren
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot; %d&quot;
comma
id|d
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;&bslash;tInbound access ? %s&bslash;n&quot;
comma
id|ii_iiwa
op_amp
id|IIO_IIWA_WIDGET
c_func
(paren
id|widget
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;&bslash;tOutbound access ? %s&bslash;n&quot;
comma
id|ii_iowa
op_amp
id|IIO_IOWA_WIDGET
c_func
(paren
id|widget
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A pointer to this structure hangs off of every hub hwgraph vertex.&n; * The generic xtalk layer may indirect through it to get to this specific&n; * crosstalk bus provider.&n; */
DECL|variable|hub_provider
id|xtalk_provider_t
id|hub_provider
op_assign
(brace
(paren
id|xtalk_piomap_alloc_f
op_star
)paren
id|hub_piomap_alloc
comma
(paren
id|xtalk_piomap_free_f
op_star
)paren
id|hub_piomap_free
comma
(paren
id|xtalk_piomap_addr_f
op_star
)paren
id|hub_piomap_addr
comma
(paren
id|xtalk_piomap_done_f
op_star
)paren
id|hub_piomap_done
comma
(paren
id|xtalk_piotrans_addr_f
op_star
)paren
id|hub_piotrans_addr
comma
(paren
id|xtalk_dmamap_alloc_f
op_star
)paren
id|hub_dmamap_alloc
comma
(paren
id|xtalk_dmamap_free_f
op_star
)paren
id|hub_dmamap_free
comma
(paren
id|xtalk_dmamap_addr_f
op_star
)paren
id|hub_dmamap_addr
comma
(paren
id|xtalk_dmamap_list_f
op_star
)paren
id|hub_dmamap_list
comma
(paren
id|xtalk_dmamap_done_f
op_star
)paren
id|hub_dmamap_done
comma
(paren
id|xtalk_dmatrans_addr_f
op_star
)paren
id|hub_dmatrans_addr
comma
(paren
id|xtalk_dmatrans_list_f
op_star
)paren
id|hub_dmatrans_list
comma
(paren
id|xtalk_dmamap_drain_f
op_star
)paren
id|hub_dmamap_drain
comma
(paren
id|xtalk_dmaaddr_drain_f
op_star
)paren
id|hub_dmaaddr_drain
comma
(paren
id|xtalk_dmalist_drain_f
op_star
)paren
id|hub_dmalist_drain
comma
(paren
id|xtalk_intr_alloc_f
op_star
)paren
id|hub_intr_alloc
comma
(paren
id|xtalk_intr_free_f
op_star
)paren
id|hub_intr_free
comma
(paren
id|xtalk_intr_connect_f
op_star
)paren
id|hub_intr_connect
comma
(paren
id|xtalk_intr_disconnect_f
op_star
)paren
id|hub_intr_disconnect
comma
(paren
id|xtalk_intr_cpu_get_f
op_star
)paren
id|hub_intr_cpu_get
comma
(paren
id|xtalk_provider_startup_f
op_star
)paren
id|hub_provider_startup
comma
(paren
id|xtalk_provider_shutdown_f
op_star
)paren
id|hub_provider_shutdown
comma
)brace
suffix:semicolon
eof
