multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/pda.h&gt;
r_extern
r_void
id|init_all_devices
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|klhwg_add_all_modules
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_void
id|klhwg_add_all_nodes
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_int
id|init_hcl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|vertex_hdl_t
id|hwgraph_root
suffix:semicolon
r_extern
r_void
id|io_module_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|pci_bus_to_hcl_cvlink
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|console_nasid
id|nasid_t
id|console_nasid
op_assign
(paren
id|nasid_t
)paren
op_minus
l_int|1
suffix:semicolon
DECL|variable|master_baseio_wid
r_char
id|master_baseio_wid
suffix:semicolon
DECL|variable|master_baseio_nasid
id|nasid_t
id|master_baseio_nasid
suffix:semicolon
DECL|variable|master_nasid
id|nasid_t
id|master_nasid
op_assign
id|INVALID_NASID
suffix:semicolon
multiline_comment|/* This is the partition master nasid */
multiline_comment|/*&n; * per_hub_init&n; *&n; * &t;This code is executed once for each Hub chip.&n; */
r_static
r_void
DECL|function|per_hub_init
id|per_hub_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nodepda_t
op_star
id|npdap
suffix:semicolon
id|ii_icmr_u_t
id|ii_icmr
suffix:semicolon
id|ii_ibcr_u_t
id|ii_ibcr
suffix:semicolon
id|ii_ilcsr_u_t
id|ii_ilcsr
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nasid
op_ne
id|INVALID_NASID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
op_eq
id|cnode
)paren
suffix:semicolon
id|npdap
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
suffix:semicolon
multiline_comment|/* Disable the request and reply errors. */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IWEIM
comma
l_int|0xC000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the total number of CRBs that can be used.&n;&t; */
id|ii_icmr.ii_icmr_regval
op_assign
l_int|0x0
suffix:semicolon
id|ii_icmr.ii_icmr_fld_s.i_c_cnt
op_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|enable_shub_wars_1_1
c_func
(paren
)paren
)paren
(brace
singleline_comment|// Set bit one of ICMR to prevent II from sending interrupt for II bug.
id|ii_icmr.ii_icmr_regval
op_or_assign
l_int|0x1
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICMR
comma
id|ii_icmr.ii_icmr_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the number of CRBs that both of the BTEs combined&n;&t; * can use minus 1.&n;&t; */
id|ii_ibcr.ii_ibcr_regval
op_assign
l_int|0x0
suffix:semicolon
id|ii_ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_LLP_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ii_ilcsr.ii_ilcsr_fld_s.i_llp_stat
op_amp
id|LNK_STAT_WORKING
)paren
(brace
id|ii_ibcr.ii_ibcr_fld_s.i_count
op_assign
l_int|0x8
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * if the LLP is down, there is no attached I/O, so&n;&t;&t; * give BTE all the CRBs.&n;&t;&t; */
id|ii_ibcr.ii_ibcr_fld_s.i_count
op_assign
l_int|0x14
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IBCR
comma
id|ii_ibcr.ii_ibcr_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set CRB timeout to be 10ms.&n;&t; */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICTP
comma
l_int|0xffffff
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_ICTO
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Initialize error interrupts for this hub. */
id|hub_error_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is responsible for the setup of all the IRIX hwgraph style&n; * stuff that&squot;s been pulled into linux.  It&squot;s called by sn_pci_find_bios which&n; * is called just before the generic Linux PCI layer does its probing (by &n; * platform_pci_fixup aka sn_pci_fixup).&n; *&n; * It is very IMPORTANT that this call is only made by the Master CPU!&n; *&n; */
r_void
id|__init
DECL|function|sgi_master_io_infr_init
id|sgi_master_io_infr_init
c_func
(paren
r_void
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
r_if
c_cond
(paren
id|init_hcl
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Sets up the hwgraph compatibility layer */
id|printk
c_func
(paren
l_string|&quot;sgi_master_io_infr_init: Cannot init hcl&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize platform-dependent vertices in the hwgraph:&n;&t; *      module&n;&t; *      node&n;&t; *      cpu&n;&t; *      memory&n;&t; *      slot&n;&t; *      hub&n;&t; *      router&n;&t; *      xbow&n;&t; */
id|io_module_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Use to be called module_init() .. */
id|klhwg_add_all_modules
c_func
(paren
id|hwgraph_root
)paren
suffix:semicolon
id|klhwg_add_all_nodes
c_func
(paren
id|hwgraph_root
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numionodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
r_extern
r_void
id|per_hub_init
c_func
(paren
id|cnodeid_t
)paren
suffix:semicolon
id|per_hub_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&n;&t; * Our IO Infrastructure drivers are in place .. &n;&t; * Initialize the whole IO Infrastructure .. xwidget/device probes.&n;&t; *&n;&t; */
id|init_all_devices
c_func
(paren
)paren
suffix:semicolon
id|pci_bus_to_hcl_cvlink
c_func
(paren
)paren
suffix:semicolon
)brace
r_inline
r_int
DECL|function|check_nasid_equiv
id|check_nasid_equiv
c_func
(paren
id|nasid_t
id|nasida
comma
id|nasid_t
id|nasidb
)paren
(brace
r_if
c_cond
(paren
(paren
id|nasida
op_eq
id|nasidb
)paren
op_logical_or
(paren
id|nasida
op_eq
id|NODEPDA
c_func
(paren
id|nasid_to_cnodeid
c_func
(paren
id|nasidb
)paren
)paren
op_member_access_from_pointer
id|xbow_peer
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|is_master_baseio_nasid_widget
id|is_master_baseio_nasid_widget
c_func
(paren
id|nasid_t
id|test_nasid
comma
id|xwidgetnum_t
id|test_wid
)paren
(brace
multiline_comment|/*&n;&t; * If the widget numbers are different, we&squot;re not the master.&n;&t; */
r_if
c_cond
(paren
id|test_wid
op_ne
(paren
id|xwidgetnum_t
)paren
id|master_baseio_wid
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the NASIDs are the same or equivalent, we&squot;re the master.&n;&t; */
r_if
c_cond
(paren
id|check_nasid_equiv
c_func
(paren
id|test_nasid
comma
id|master_baseio_nasid
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
eof
