multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
r_extern
r_int
id|bridge_rev_b_data_check_disable
suffix:semicolon
DECL|variable|busnum_to_pcibr_vhdl
id|vertex_hdl_t
id|busnum_to_pcibr_vhdl
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|busnum_to_nid
id|nasid_t
id|busnum_to_nid
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|busnum_to_atedmamaps
r_void
op_star
id|busnum_to_atedmamaps
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|num_bridges
r_int
r_char
id|num_bridges
suffix:semicolon
DECL|variable|done_probing
r_static
r_int
id|done_probing
suffix:semicolon
r_extern
id|irqpda_t
op_star
id|irqpdaindr
suffix:semicolon
r_static
r_int
id|pci_bus_map_create
c_func
(paren
r_struct
id|pcibr_list_s
op_star
id|softlistp
comma
id|moduleid_t
id|io_moduleid
)paren
suffix:semicolon
id|vertex_hdl_t
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
suffix:semicolon
r_extern
r_void
id|register_pcibr_intr
c_func
(paren
r_int
id|irq
comma
id|pcibr_intr_t
id|intr
)paren
suffix:semicolon
r_static
r_struct
id|sn_flush_device_list
op_star
id|sn_dma_flush_init
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|idx
comma
r_int
id|pin
comma
r_int
id|slot
)paren
suffix:semicolon
r_extern
r_int
id|cbrick_type_get_nasid
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
r_extern
r_void
id|ioconfig_bus_new_entries
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ioconfig_get_busnum
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|iomoduleid_get
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_int
id|isIO9
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|macro|IS_OPUS
mdefine_line|#define IS_OPUS(nasid) (cbrick_type_get_nasid(nasid) == MODULE_OPUSBRICK)
DECL|macro|IS_ALTIX
mdefine_line|#define IS_ALTIX(nasid) (cbrick_type_get_nasid(nasid) == MODULE_CBRICK)
multiline_comment|/*&n; * Init the provider asic for a given device&n; */
r_static
r_inline
r_void
id|__init
DECL|function|set_pci_provider
id|set_pci_provider
c_func
(paren
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|device_sysdata-&gt;vhdl
)paren
suffix:semicolon
id|device_sysdata-&gt;pci_provider
op_assign
id|pciio_info_pops_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_cvlink_init() - To be called once during initialization before&n; *&t;SGI IO Infrastructure init is called.&n; */
r_int
DECL|function|pci_bus_cvlink_init
id|pci_bus_cvlink_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|ioconfig_bus_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_pcibr_vhdl
comma
l_int|0x0
comma
r_sizeof
(paren
id|vertex_hdl_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_nid
comma
l_int|0x0
comma
r_sizeof
(paren
id|nasid_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_atedmamaps
comma
l_int|0x0
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|num_bridges
op_assign
l_int|0
suffix:semicolon
r_return
id|ioconfig_bus_init
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_vertex() - Given a logical Linux Bus Number returns the associated&n; *&t;pci bus vertex from the SGI IO Infrastructure.&n; */
r_static
r_inline
id|vertex_hdl_t
DECL|function|pci_bus_to_vertex
id|pci_bus_to_vertex
c_func
(paren
r_int
r_char
id|busnum
)paren
(brace
id|vertex_hdl_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * First get the xwidget vertex.&n;&t; */
id|pci_bus
op_assign
id|busnum_to_pcibr_vhdl
(braket
id|busnum
)braket
suffix:semicolon
r_return
id|pci_bus
suffix:semicolon
)brace
multiline_comment|/*&n; * devfn_to_vertex() - returns the vertex of the device given the bus, slot,&n; *&t;and function numbers.&n; */
id|vertex_hdl_t
DECL|function|devfn_to_vertex
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
(brace
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
r_int
id|func
op_assign
l_int|0
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|vertex_hdl_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
id|vertex_hdl_t
id|device_vertex
op_assign
(paren
id|vertex_hdl_t
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Go get the pci bus vertex.&n;&t; */
id|pci_bus
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
(brace
multiline_comment|/*&n;&t;&t; * During probing, the Linux pci code invents non-existent&n;&t;&t; * bus numbers and pci_dev structures and tries to access&n;&t;&t; * them to determine existence. Don&squot;t crib during probing.&n;&t;&t; */
r_if
c_cond
(paren
id|done_probing
)paren
id|printk
c_func
(paren
l_string|&quot;devfn_to_vertex: Invalid bus number %d given.&bslash;n&quot;
comma
id|busnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go get the slot&amp;function vertex.&n;&t; * Should call pciio_slot_func_to_name() when ready.&n;&t; */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
suffix:semicolon
id|func
op_assign
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a NON Multi-function card the name of the device looks like:&n;&t; * ../pci/1, ../pci/2 ..&n;&t; */
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|pci_bus
comma
id|name
comma
op_amp
id|device_vertex
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
id|device_vertex
)paren
(brace
r_return
id|device_vertex
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This maybe a multifunction card.  It&squot;s names look like:&n;&t; * ../pci/1a, ../pci/1b, etc.&n;&t; */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d%c&quot;
comma
id|slot
comma
l_char|&squot;a&squot;
op_plus
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|pci_bus
comma
id|name
comma
op_amp
id|device_vertex
)paren
op_ne
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device_vertex
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|device_vertex
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_alloc_pci_sysdata() - This routine allocates a pci controller&n; *&t;which is expected as the pci_dev and pci_bus sysdata by the Linux&n; *      PCI infrastructure.&n; */
r_static
r_struct
id|pci_controller
op_star
DECL|function|sn_alloc_pci_sysdata
id|sn_alloc_pci_sysdata
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_controller
op_star
id|pci_sysdata
suffix:semicolon
id|pci_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pci_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_sysdata
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pci_sysdata
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pci_sysdata
)paren
)paren
suffix:semicolon
r_return
id|pci_sysdata
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_pci_fixup_bus() - This routine sets up a bus&squot;s resources&n; * consistent with the Linux PCI abstraction layer.&n; */
r_static
r_int
id|__init
DECL|function|sn_pci_fixup_bus
id|sn_pci_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|pci_controller
op_star
id|pci_sysdata
suffix:semicolon
r_struct
id|sn_widget_sysdata
op_star
id|widget_sysdata
suffix:semicolon
id|pci_sysdata
op_assign
id|sn_alloc_pci_sysdata
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_sysdata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup_bus(): Unable to &quot;
l_string|&quot;allocate memory for pci_sysdata&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|widget_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn_widget_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|widget_sysdata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup_bus(): Unable to &quot;
l_string|&quot;allocate memory for widget_sysdata&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pci_sysdata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|widget_sysdata-&gt;vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|bus-&gt;number
)paren
suffix:semicolon
id|pci_sysdata-&gt;platform_data
op_assign
(paren
r_void
op_star
)paren
id|widget_sysdata
suffix:semicolon
id|bus-&gt;sysdata
op_assign
id|pci_sysdata
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_pci_fixup_slot() - This routine sets up a slot&squot;s resources&n; * consistent with the Linux PCI abstraction layer.  Resources acquired&n; * from our PCI provider include PIO maps to BAR space and interrupt&n; * objects.&n; */
r_static
r_int
DECL|function|sn_pci_fixup_slot
id|sn_pci_fixup_slot
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_extern
r_int
id|bit_pos_to_irq
c_func
(paren
r_int
)paren
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
id|vertex_hdl_t
id|vhdl
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_struct
id|pci_controller
op_star
id|pci_sysdata
suffix:semicolon
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|pciio_intr_line_t
id|lines
op_assign
l_int|0
suffix:semicolon
id|vertex_hdl_t
id|device_vertex
suffix:semicolon
id|pciio_provider_t
op_star
id|pci_provider
suffix:semicolon
id|pciio_intr_t
id|intr_handle
suffix:semicolon
multiline_comment|/* Allocate a controller structure */
id|pci_sysdata
op_assign
id|sn_alloc_pci_sysdata
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_sysdata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup_slot: Unable to &quot;
l_string|&quot;allocate memory for pci_sysdata&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Set the device vertex */
id|device_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn_device_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device_sysdata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup_slot: Unable to &quot;
l_string|&quot;allocate memory for device_sysdata&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pci_sysdata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|device_sysdata-&gt;vhdl
op_assign
id|devfn_to_vertex
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
id|pci_sysdata-&gt;platform_data
op_assign
(paren
r_void
op_star
)paren
id|device_sysdata
suffix:semicolon
id|dev-&gt;sysdata
op_assign
id|pci_sysdata
suffix:semicolon
id|set_pci_provider
c_func
(paren
id|device_sysdata
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the resources address correctly.  The assumption here&n;&t; * is that the addresses in the resource structure has been&n;&t; * read from the card and it was set in the card by our&n;&t; * Infrastructure.  NOTE: PIC and TIOCP don&squot;t have big-window&n;&t; * upport for PCI I/O space.  So by mapping the I/O space&n;&t; * first we will attempt to use Device(x) registers for I/O&n;&t; * BARs (which can&squot;t use big windows like MEM BARs can).&n;&t; */
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
multiline_comment|/* Allocate the IORESOURCE_IO space first */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
comma
id|addr
suffix:semicolon
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
id|end
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_continue
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|idx
)paren
comma
l_int|0
comma
id|size
comma
op_amp
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn_pci_fixup(): pio map failure for &quot;
l_string|&quot;%s bar%d&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|idx
)paren
suffix:semicolon
)brace
r_else
(brace
id|addr
op_or_assign
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|addr
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|parent
op_assign
op_amp
id|ioport_resource
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
multiline_comment|/* Allocate the IORESOURCE_MEM space next */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
comma
id|addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
id|end
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_continue
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|idx
)paren
comma
l_int|0
comma
id|size
comma
op_amp
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn_pci_fixup(): pio map failure for &quot;
l_string|&quot;%s bar%d&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|idx
)paren
suffix:semicolon
)brace
r_else
(brace
id|addr
op_or_assign
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|addr
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Assign addresses to the ROMs, but don&squot;t enable them yet&n;&t; * Also note that we only map display card ROMs due to PIO mapping&n;&t; * space scarcity.&n;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
id|size
op_assign
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_minus
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_ROM
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|PIOMAP_FIXED
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn_pci_fixup(): ROM pio map failure &quot;
l_string|&quot;for %s&bslash;n&quot;
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
)brace
id|addr
op_or_assign
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_assign
id|addr
suffix:semicolon
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Remove other ROM resources since they don&squot;t have valid&n;&t;&t; * CPU addresses.&n;&t;&t; */
id|size
op_assign
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_minus
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Update the Command Word on the Card.&n;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
multiline_comment|/* If the device doesn&squot;t support */
multiline_comment|/* bit gets dropped .. no harm */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_PIN
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|lines
)paren
suffix:semicolon
id|device_vertex
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
id|pci_provider
op_assign
id|device_sysdata-&gt;pci_provider
suffix:semicolon
id|device_sysdata-&gt;intr_handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lines
)paren
r_return
l_int|0
suffix:semicolon
id|irqpdaindr-&gt;curr
op_assign
id|dev
suffix:semicolon
id|intr_handle
op_assign
(paren
id|pci_provider-&gt;intr_alloc
)paren
(paren
id|device_vertex
comma
l_int|NULL
comma
id|lines
comma
id|device_vertex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_handle
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup:  pcibr_intr_alloc() failed&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pci_sysdata
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device_sysdata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|device_sysdata-&gt;intr_handle
op_assign
id|intr_handle
suffix:semicolon
id|irq
op_assign
id|intr_handle-&gt;pi_irq
suffix:semicolon
id|irqpdaindr-&gt;device_dev
(braket
id|irq
)braket
op_assign
id|dev
suffix:semicolon
(paren
id|pci_provider-&gt;intr_connect
)paren
(paren
id|intr_handle
comma
(paren
id|intr_func_t
)paren
l_int|0
comma
(paren
id|intr_arg_t
)paren
l_int|0
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|register_pcibr_intr
c_func
(paren
id|irq
comma
(paren
id|pcibr_intr_t
)paren
id|intr_handle
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
id|ibits
op_assign
(paren
(paren
id|pcibr_intr_t
)paren
id|intr_handle
)paren
op_member_access_from_pointer
id|bi_ibits
suffix:semicolon
r_int
id|i
suffix:semicolon
id|size
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_minus
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibits
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
id|device_sysdata-&gt;dma_flush_list
op_assign
id|sn_dma_flush_init
c_func
(paren
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
comma
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
comma
id|idx
comma
id|i
comma
id|PCIBR_INFO_SLOT_GET_EXT
c_func
(paren
id|pcibr_info_get
c_func
(paren
id|device_sysdata-&gt;vhdl
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HOTPLUG_PCI_SGI
r_void
DECL|function|sn_dma_flush_clear
id|sn_dma_flush_clear
c_func
(paren
r_struct
id|sn_flush_device_list
op_star
id|dma_flush_list
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
id|i
suffix:semicolon
id|dma_flush_list-&gt;pin
op_assign
op_minus
l_int|1
suffix:semicolon
id|dma_flush_list-&gt;bus
op_assign
op_minus
l_int|1
suffix:semicolon
id|dma_flush_list-&gt;slot
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|dma_flush_list-&gt;bar_list
(braket
id|i
)braket
dot
id|start
op_eq
id|start
)paren
op_logical_and
(paren
id|dma_flush_list-&gt;bar_list
(braket
id|i
)braket
dot
id|end
op_eq
id|end
)paren
)paren
(brace
id|dma_flush_list-&gt;bar_list
(braket
id|i
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dma_flush_list-&gt;bar_list
(braket
id|i
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * sn_pci_unfixup_slot() - This routine frees a slot&squot;s resources&n; * consistent with the Linux PCI abstraction layer.  Resources released&n; * back to our PCI provider include PIO maps to BAR space and interrupt&n; * objects.&n; */
r_void
DECL|function|sn_pci_unfixup_slot
id|sn_pci_unfixup_slot
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|vertex_hdl_t
id|vhdl
suffix:semicolon
id|pciio_intr_t
id|intr_handle
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|device_sysdata
op_assign
id|SN_DEVICE_SYSDATA
c_func
(paren
id|dev
)paren
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
r_if
c_cond
(paren
id|device_sysdata-&gt;dma_flush_list
)paren
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|size
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_minus
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|sn_dma_flush_clear
c_func
(paren
id|device_sysdata-&gt;dma_flush_list
comma
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
comma
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
)paren
suffix:semicolon
)brace
id|intr_handle
op_assign
id|device_sysdata-&gt;intr_handle
suffix:semicolon
r_if
c_cond
(paren
id|intr_handle
)paren
(brace
r_extern
r_void
id|unregister_pcibr_intr
c_func
(paren
r_int
comma
id|pcibr_intr_t
)paren
suffix:semicolon
id|irq
op_assign
id|intr_handle-&gt;pi_irq
suffix:semicolon
id|irqpdaindr-&gt;device_dev
(braket
id|irq
)braket
op_assign
l_int|NULL
suffix:semicolon
id|unregister_pcibr_intr
c_func
(paren
id|irq
comma
(paren
id|pcibr_intr_t
)paren
id|intr_handle
)paren
suffix:semicolon
id|pciio_intr_disconnect
c_func
(paren
id|intr_handle
)paren
suffix:semicolon
id|pciio_intr_free
c_func
(paren
id|intr_handle
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
)paren
(brace
id|pciio_piomap_done
(paren
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
)paren
suffix:semicolon
id|pciio_piomap_free
(paren
id|device_sysdata-&gt;pio_map
(braket
id|idx
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_HOTPLUG_PCI_SGI */
DECL|variable|flush_nasid_list
r_struct
id|sn_flush_nasid_entry
id|flush_nasid_list
(braket
id|MAX_NASIDS
)braket
suffix:semicolon
multiline_comment|/* Initialize the data structures for flushing write buffers after a PIO read.&n; * The theory is:&n; * Take an unused int. pin and associate it with a pin that is in use.&n; * After a PIO read, force an interrupt on the unused pin, forcing a write buffer flush&n; * on the in use pin.  This will prevent the race condition between PIO read responses and&n; * DMA writes.&n; */
r_static
r_struct
id|sn_flush_device_list
op_star
DECL|function|sn_dma_flush_init
id|sn_dma_flush_init
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|idx
comma
r_int
id|pin
comma
r_int
id|slot
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
r_int
id|dnasid
suffix:semicolon
r_int
id|wid_num
suffix:semicolon
r_int
id|bus
suffix:semicolon
r_struct
id|sn_flush_device_list
op_star
id|p
suffix:semicolon
r_void
op_star
id|b
suffix:semicolon
r_int
id|bwin
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|start
)paren
suffix:semicolon
id|wid_num
op_assign
id|SWIN_WIDGETNUM
c_func
(paren
id|start
)paren
suffix:semicolon
id|bus
op_assign
(paren
id|start
op_rshift
l_int|23
)paren
op_amp
l_int|0x1
suffix:semicolon
id|bwin
op_assign
id|BWIN_WINDOWNUM
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
op_eq
l_int|NULL
)paren
(brace
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
op_assign
(paren
r_struct
id|sn_flush_device_list
op_star
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|HUB_WIDGET_ID_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_dma_flush_init: Cannot allocate memory for nasid list&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
comma
l_int|0
comma
(paren
id|HUB_WIDGET_ID_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bwin
OG
l_int|0
)paren
(brace
r_int
id|itte_index
op_assign
id|bwin
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|itte
suffix:semicolon
id|itte
op_assign
id|HUB_L
c_func
(paren
id|IIO_ITTE_GET
c_func
(paren
id|nasid
comma
id|itte_index
)paren
)paren
suffix:semicolon
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|iio_itte
(braket
id|bwin
)braket
op_assign
id|itte
suffix:semicolon
id|wid_num
op_assign
(paren
id|itte
op_rshift
id|IIO_ITTE_WIDGET_SHIFT
)paren
op_amp
id|IIO_ITTE_WIDGET_MASK
suffix:semicolon
id|bus
op_assign
id|itte
op_amp
id|IIO_ITTE_OFFSET_MASK
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0x4
op_logical_or
id|bus
op_eq
l_int|0x8
)paren
(brace
id|bus
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|bus
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* if it&squot;s IO9, bus 1, we don&squot;t care about slots 1 and 4.  This is&n;&t; * because these are the IOC4 slots and we don&squot;t flush them.&n;&t; */
r_if
c_cond
(paren
id|isIO9
c_func
(paren
id|nasid
)paren
op_logical_and
id|bus
op_eq
l_int|0
op_logical_and
(paren
id|slot
op_eq
l_int|1
op_logical_or
id|slot
op_eq
l_int|4
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
op_eq
l_int|NULL
)paren
(brace
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
op_assign
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
id|kmalloc
c_func
(paren
id|DEV_PER_WIDGET
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_dma_flush_init: Cannot allocate memory for nasid sub-list&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
comma
l_int|0
comma
id|DEV_PER_WIDGET
op_star
r_sizeof
(paren
r_struct
id|sn_flush_device_list
)paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_PER_WIDGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;bus
op_assign
op_minus
l_int|1
suffix:semicolon
id|p-&gt;pin
op_assign
op_minus
l_int|1
suffix:semicolon
id|p-&gt;slot
op_assign
op_minus
l_int|1
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
id|p
op_assign
op_amp
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_PER_WIDGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pin
op_eq
id|pin
op_logical_and
id|p-&gt;bus
op_eq
id|bus
op_logical_and
id|p-&gt;slot
op_eq
id|slot
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pin
OL
l_int|0
)paren
(brace
id|p-&gt;pin
op_assign
id|pin
suffix:semicolon
id|p-&gt;bus
op_assign
id|bus
suffix:semicolon
id|p-&gt;slot
op_assign
id|slot
suffix:semicolon
r_break
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;bar_list
(braket
id|i
)braket
dot
id|start
op_eq
l_int|0
)paren
(brace
id|p-&gt;bar_list
(braket
id|i
)braket
dot
id|start
op_assign
id|start
suffix:semicolon
id|p-&gt;bar_list
(braket
id|i
)braket
dot
id|end
op_assign
id|end
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|b
op_assign
(paren
r_void
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
id|wid_num
)paren
op_or
(paren
id|bus
op_lshift
l_int|23
)paren
)paren
suffix:semicolon
multiline_comment|/* If it&squot;s IO9, then slot 2 maps to slot 7 and slot 6 maps to slot 8.&n;&t; * To see this is non-trivial.  By drawing pictures and reading manuals and talking&n;&t; * to HW guys, we can see that on IO9 bus 1, slots 7 and 8 are always unused.&n;&t; * Further, since we short-circuit slots  1, 3, and 4 above, we only have to worry&n;&t; * about the case when there is a card in slot 2.  A multifunction card will appear&n;&t; * to be in slot 6 (from an interrupt point of view) also.  That&squot;s the  most we&squot;ll&n;&t; * have to worry about.  A four function card will overload the interrupt lines in&n;&t; * slot 2 and 6.&n;&t; * We also need to special case the 12160 device in slot 3.  Fortunately, we have&n;&t; * a spare intr. line for pin 4, so we&squot;ll use that for the 12160.&n;&t; * All other buses have slot 3 and 4 and slots 7 and 8 unused.  Since we can only&n;&t; * see slots 1 and 2 and slots 5 and 6 coming through here for those buses (this&n;&t; * is true only on Pxbricks with 2 physical slots per bus), we just need to add&n;&t; * 2 to the slot number to find an unused slot.&n;&t; * We have convinced ourselves that we will never see a case where two different cards&n;&t; * in two different slots will ever share an interrupt line, so there is no need to&n;&t; * special case this.&n;&t; */
r_if
c_cond
(paren
id|isIO9
c_func
(paren
id|nasid
)paren
op_logical_and
(paren
(paren
id|IS_ALTIX
c_func
(paren
id|nasid
)paren
op_logical_and
id|wid_num
op_eq
l_int|0xc
)paren
op_logical_or
(paren
id|IS_OPUS
c_func
(paren
id|nasid
)paren
op_logical_and
id|wid_num
op_eq
l_int|0xf
)paren
)paren
op_logical_and
id|bus
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pin
op_eq
l_int|1
)paren
(brace
id|p-&gt;force_int_addr
op_assign
(paren
r_int
r_int
)paren
id|pcireg_bridge_force_always_addr_get
c_func
(paren
id|b
comma
l_int|6
)paren
suffix:semicolon
id|pcireg_bridge_intr_device_bit_set
c_func
(paren
id|b
comma
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
suffix:semicolon
id|dnasid
op_assign
id|NASID_GET
c_func
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
)paren
suffix:semicolon
id|pcireg_bridge_intr_addr_set
c_func
(paren
id|b
comma
l_int|6
comma
(paren
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
op_amp
l_int|0xfffffffff
)paren
op_or
(paren
id|dnasid
op_lshift
l_int|36
)paren
op_or
(paren
l_int|0xfUL
op_lshift
l_int|48
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pin
op_eq
l_int|2
)paren
(brace
multiline_comment|/* 12160 SCSI device in IO9 */
id|p-&gt;force_int_addr
op_assign
(paren
r_int
r_int
)paren
id|pcireg_bridge_force_always_addr_get
c_func
(paren
id|b
comma
l_int|4
)paren
suffix:semicolon
id|pcireg_bridge_intr_device_bit_set
c_func
(paren
id|b
comma
(paren
l_int|2
op_lshift
l_int|12
)paren
)paren
suffix:semicolon
id|dnasid
op_assign
id|NASID_GET
c_func
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
)paren
suffix:semicolon
id|pcireg_bridge_intr_addr_set
c_func
(paren
id|b
comma
l_int|4
comma
(paren
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
op_amp
l_int|0xfffffffff
)paren
op_or
(paren
id|dnasid
op_lshift
l_int|36
)paren
op_or
(paren
l_int|0xfUL
op_lshift
l_int|48
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* slot == 6 */
id|p-&gt;force_int_addr
op_assign
(paren
r_int
r_int
)paren
id|pcireg_bridge_force_always_addr_get
c_func
(paren
id|b
comma
l_int|7
)paren
suffix:semicolon
id|pcireg_bridge_intr_device_bit_set
c_func
(paren
id|b
comma
(paren
l_int|5
op_lshift
l_int|21
)paren
)paren
suffix:semicolon
id|dnasid
op_assign
id|NASID_GET
c_func
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
)paren
suffix:semicolon
id|pcireg_bridge_intr_addr_set
c_func
(paren
id|b
comma
l_int|7
comma
(paren
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
op_amp
l_int|0xfffffffff
)paren
op_or
(paren
id|dnasid
op_lshift
l_int|36
)paren
op_or
(paren
l_int|0xfUL
op_lshift
l_int|48
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|p-&gt;force_int_addr
op_assign
(paren
r_int
r_int
)paren
id|pcireg_bridge_force_always_addr_get
c_func
(paren
id|b
comma
(paren
id|pin
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|pcireg_bridge_intr_device_bit_set
c_func
(paren
id|b
comma
(paren
id|pin
op_lshift
(paren
id|pin
op_star
l_int|3
)paren
)paren
)paren
suffix:semicolon
id|dnasid
op_assign
id|NASID_GET
c_func
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
)paren
suffix:semicolon
id|pcireg_bridge_intr_addr_set
c_func
(paren
id|b
comma
(paren
id|pin
op_plus
l_int|2
)paren
comma
(paren
(paren
id|virt_to_phys
c_func
(paren
op_amp
id|p-&gt;flush_addr
)paren
op_amp
l_int|0xfffffffff
)paren
op_or
(paren
id|dnasid
op_lshift
l_int|36
)paren
op_or
(paren
l_int|0xfUL
op_lshift
l_int|48
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * linux_bus_cvlink() Creates a link between the Linux PCI Bus number&n; *&t;to the actual hardware component that it represents:&n; *&t;/dev/hw/linux/busnum/0 -&gt; ../../../hw/module/001c01/slab/0/Ibrick/xtalk/15/pci&n; *&n; *&t;The bus vertex, when called to devfs_generate_path() returns:&n; *&t;&t;hw/module/001c01/slab/0/Ibrick/xtalk/15/pci&n; *&t;&t;hw/module/001c01/slab/1/Pbrick/xtalk/12/pci-x/0&n; *&t;&t;hw/module/001c01/slab/1/Pbrick/xtalk/12/pci-x/1&n; */
r_void
DECL|function|linux_bus_cvlink
id|linux_bus_cvlink
c_func
(paren
r_void
)paren
(brace
r_char
id|name
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_PCI_XWIDGET
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|busnum_to_pcibr_vhdl
(braket
id|index
)braket
)paren
r_continue
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%x&quot;
comma
id|index
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_edge_add
c_func
(paren
id|linux_busnum
comma
id|busnum_to_pcibr_vhdl
(braket
id|index
)braket
comma
id|name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pci_bus_map_create() - Called by pci_bus_to_hcl_cvlink() to finish the job.&n; *&n; *&t;Linux PCI Bus numbers are assigned from lowest module_id numbers&n; *&t;(rack/slot etc.)&n; */
r_static
r_int
DECL|function|pci_bus_map_create
id|pci_bus_map_create
c_func
(paren
r_struct
id|pcibr_list_s
op_star
id|softlistp
comma
id|moduleid_t
id|moduleid
)paren
(brace
r_int
id|basebus_num
comma
id|bus_number
suffix:semicolon
id|vertex_hdl_t
id|pci_bus
op_assign
id|softlistp-&gt;bl_vhdl
suffix:semicolon
r_char
id|moduleid_str
(braket
l_int|16
)braket
suffix:semicolon
id|memset
c_func
(paren
id|moduleid_str
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|moduleid_str
comma
id|moduleid
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
(paren
r_void
)paren
id|ioconfig_get_busnum
c_func
(paren
(paren
r_char
op_star
)paren
id|moduleid_str
comma
op_amp
id|basebus_num
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Assign the correct bus number and also the nasid of this&n;&t; * pci Xwidget.&n;&t; */
id|bus_number
op_assign
id|basebus_num
op_plus
id|pcibr_widget_to_bus
c_func
(paren
id|pci_bus
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_char
id|hwpath
(braket
id|MAXDEVNAME
)braket
op_assign
l_string|&quot;&bslash;0&quot;
suffix:semicolon
r_extern
r_int
id|hwgraph_vertex_name_get
c_func
(paren
id|vertex_hdl_t
comma
r_char
op_star
comma
id|uint
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|softlistp-&gt;bl_soft
suffix:semicolon
id|hwgraph_vertex_name_get
c_func
(paren
id|pci_bus
comma
id|hwpath
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:&bslash;n&bslash;tbus_num %d, basebus_num %d, brick_bus %d, &quot;
l_string|&quot;bus_vhdl 0x%lx, brick_type %d&bslash;n&quot;
comma
id|hwpath
comma
id|bus_number
comma
id|basebus_num
comma
id|pcibr_widget_to_bus
c_func
(paren
id|pci_bus
)paren
comma
(paren
r_uint64
)paren
id|pci_bus
comma
id|pcibr_soft-&gt;bs_bricktype
)paren
suffix:semicolon
)brace
macro_line|#endif
id|busnum_to_pcibr_vhdl
(braket
id|bus_number
)braket
op_assign
id|pci_bus
suffix:semicolon
multiline_comment|/*&n;&t; * Pre assign DMA maps needed for 32 Bits Page Map DMA.&n;&t; */
id|busnum_to_atedmamaps
(braket
id|bus_number
)braket
op_assign
(paren
r_void
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pcibr_dmamap_s
)paren
op_star
id|MAX_ATE_MAPS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busnum_to_atedmamaps
(braket
id|bus_number
)braket
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_map_create: Cannot allocate memory for ate maps&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|busnum_to_atedmamaps
(braket
id|bus_number
)braket
comma
l_int|0x0
comma
r_sizeof
(paren
r_struct
id|pcibr_dmamap_s
)paren
op_star
id|MAX_ATE_MAPS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_hcl_cvlink() - This routine is called after SGI IO Infrastructure&n; *      initialization has completed to set up the mappings between PCI BRIDGE&n; *      ASIC and logical pci bus numbers.&n; *&n; *      Must be called before pci_init() is invoked.&n; */
r_int
DECL|function|pci_bus_to_hcl_cvlink
id|pci_bus_to_hcl_cvlink
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_extern
id|pcibr_list_p
id|pcibr_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nummodules
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pcibr_list_s
op_star
id|softlistp
op_assign
id|pcibr_list
suffix:semicolon
r_struct
id|pcibr_list_s
op_star
id|first_in_list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pcibr_list_s
op_star
id|last_in_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Walk the list of pcibr_soft structs looking for matches */
r_while
c_loop
(paren
id|softlistp
)paren
(brace
r_struct
id|pcibr_soft_s
op_star
id|pcibr_soft
op_assign
id|softlistp-&gt;bl_soft
suffix:semicolon
id|moduleid_t
id|moduleid
suffix:semicolon
multiline_comment|/* Is this PCI bus associated with this moduleid? */
id|moduleid
op_assign
id|NODE_MODULEID
c_func
(paren
id|nasid_to_cnodeid
c_func
(paren
id|pcibr_soft-&gt;bs_nasid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_modules
(braket
id|i
)braket
op_member_access_from_pointer
id|id
op_eq
id|moduleid
)paren
(brace
r_struct
id|pcibr_list_s
op_star
id|new_element
suffix:semicolon
id|new_element
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pcibr_soft_s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_element
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t allocate memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|new_element-&gt;bl_soft
op_assign
id|softlistp-&gt;bl_soft
suffix:semicolon
id|new_element-&gt;bl_vhdl
op_assign
id|softlistp-&gt;bl_vhdl
suffix:semicolon
id|new_element-&gt;bl_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* list empty so just put it on the list */
r_if
c_cond
(paren
id|first_in_list
op_eq
l_int|NULL
)paren
(brace
id|first_in_list
op_assign
id|new_element
suffix:semicolon
id|last_in_list
op_assign
id|new_element
suffix:semicolon
id|softlistp
op_assign
id|softlistp-&gt;bl_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * BASEIO IObricks attached to a module have&n;&t;&t;&t;&t; * a higher priority than non BASEIO IOBricks&n;&t;&t;&t;&t; * when it comes to persistant pci bus&n;&t;&t;&t;&t; * numbering, so put them on the front of the&n;&t;&t;&t;&t; * list.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|isIO9
c_func
(paren
id|pcibr_soft-&gt;bs_nasid
)paren
)paren
(brace
id|new_element-&gt;bl_next
op_assign
id|first_in_list
suffix:semicolon
id|first_in_list
op_assign
id|new_element
suffix:semicolon
)brace
r_else
(brace
id|last_in_list-&gt;bl_next
op_assign
id|new_element
suffix:semicolon
id|last_in_list
op_assign
id|new_element
suffix:semicolon
)brace
)brace
id|softlistp
op_assign
id|softlistp-&gt;bl_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We now have a list of all the pci bridges associated with&n;&t;&t; * the module_id, sn_modules[i].  Call pci_bus_map_create() for&n;&t;&t; * each pci bridge&n;&t;&t; */
id|softlistp
op_assign
id|first_in_list
suffix:semicolon
r_while
c_loop
(paren
id|softlistp
)paren
(brace
id|moduleid_t
id|iobrick
suffix:semicolon
r_struct
id|pcibr_list_s
op_star
id|next
op_assign
id|softlistp-&gt;bl_next
suffix:semicolon
id|iobrick
op_assign
id|iomoduleid_get
c_func
(paren
id|softlistp-&gt;bl_soft-&gt;bs_nasid
)paren
suffix:semicolon
id|pci_bus_map_create
c_func
(paren
id|softlistp
comma
id|iobrick
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|softlistp
)paren
suffix:semicolon
id|softlistp
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Create the Linux PCI bus number vertex link.&n;&t; */
(paren
r_void
)paren
id|linux_bus_cvlink
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|ioconfig_bus_new_entries
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugly hack to get PCI setup until we have a proper ACPI namespace.&n; */
DECL|macro|PCI_BUSES_TO_SCAN
mdefine_line|#define PCI_BUSES_TO_SCAN 256
r_extern
r_struct
id|pci_ops
id|sn_pci_ops
suffix:semicolon
r_int
id|__init
DECL|function|sn_pci_init
id|sn_pci_init
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_controller
op_star
id|controller
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_extern
r_void
id|register_sn_procfs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|sgi_master_io_infr_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sn_init_cpei_timer
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
op_logical_or
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is needed to avoid bounce limit checks in the blk layer&n;&t; */
id|ia64_max_iommu_merge_mask
op_assign
op_complement
id|PAGE_MASK
suffix:semicolon
multiline_comment|/*&n;&t; * set pci_raw_ops, etc.&n;&t; */
id|sgi_master_io_infr_init
c_func
(paren
)paren
suffix:semicolon
id|sn_init_cpei_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|register_sn_procfs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|controller
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_controller
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|controller
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cannot allocate PCI controller&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|controller
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pci_controller
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_BUSES_TO_SCAN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pci_bus_to_vertex
c_func
(paren
id|i
)paren
)paren
id|pci_scan_bus
c_func
(paren
id|i
comma
op_amp
id|sn_pci_ops
comma
id|controller
)paren
suffix:semicolon
id|done_probing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the pci bus vertex in the pci_bus struct.&n;&t; */
id|list_for_each_entry
c_func
(paren
id|pci_bus
comma
op_amp
id|pci_root_buses
comma
id|node
)paren
(brace
id|ret
op_assign
id|sn_pci_fixup_bus
c_func
(paren
id|pci_bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup: sn_pci_fixup_bus fails : error %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * set the root start and end so that drivers calling check_region()&n;&t; * won&squot;t see a conflict&n;&t; */
id|ioport_resource.start
op_assign
l_int|0xc000000000000000
suffix:semicolon
id|ioport_resource.end
op_assign
l_int|0xcfffffffffffffff
suffix:semicolon
multiline_comment|/*&n;&t; * Set the root start and end for Mem Resource.&n;&t; */
id|iomem_resource.start
op_assign
l_int|0
suffix:semicolon
id|iomem_resource.end
op_assign
l_int|0xffffffffffffffff
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the device vertex in the pci_dev struct.&n;&t; */
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|pci_dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|sn_pci_fixup_slot
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn_pci_fixup: sn_pci_fixup_slot fails : error %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sn_pci_init
id|subsys_initcall
c_func
(paren
id|sn_pci_init
)paren
suffix:semicolon
eof
