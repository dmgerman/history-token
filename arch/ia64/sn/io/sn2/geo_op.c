multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
multiline_comment|/*&n; * @doc file m:hwcfg&n; * DESCRIPTION:&n; * &n; * This file contains routines for manipulating and generating &n; * Geographic IDs.  They are in a file by themself since they have&n; * no dependencies on other modules.&n; *  &n; * ORIGIN:&n; * &n; * New for SN2&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/sn2/shub_mmr_t.h&gt;
macro_line|#include &lt;asm/sn/sn2/shubio.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/module.h&gt;
macro_line|#include &lt;asm/sn/geo.h&gt;
multiline_comment|/********** Global functions and data (visible outside the module) ***********/
multiline_comment|/*&n; * @doc gf:geo_module&n; * &n; * moduleid_t geo_module(geoid_t g)&n; * &n; * DESCRIPTION:&n; * &n; * Return the moduleid component of a geoid.&n; *  &n; * INTERNALS:&n; * &n; * Return INVALID_MODULE for an invalid geoid.  Otherwise extract the&n; * moduleid from the structure, and return it.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
id|moduleid_t
DECL|function|geo_module
id|geo_module
c_func
(paren
id|geoid_t
id|g
)paren
(brace
r_if
c_cond
(paren
id|g.any.type
op_eq
id|GEO_TYPE_INVALID
)paren
r_return
id|INVALID_MODULE
suffix:semicolon
r_else
r_return
id|g.any.module
suffix:semicolon
)brace
multiline_comment|/*&n; * @doc gf:geo_slab&n; * &n; * slabid_t geo_slab(geoid_t g)&n; * &n; * DESCRIPTION:&n; * &n; * Return the slabid component of a geoid.&n; *  &n; * INTERNALS:&n; * &n; * Return INVALID_SLAB for an invalid geoid.  Otherwise extract the&n; * slabid from the structure, and return it.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
id|slabid_t
DECL|function|geo_slab
id|geo_slab
c_func
(paren
id|geoid_t
id|g
)paren
(brace
r_if
c_cond
(paren
id|g.any.type
op_eq
id|GEO_TYPE_INVALID
)paren
r_return
id|INVALID_SLAB
suffix:semicolon
r_else
r_return
id|g.any.slab
suffix:semicolon
)brace
multiline_comment|/*&n; * @doc gf:geo_type&n; * &n; * geo_type_t geo_type(geoid_t g)&n; * &n; * DESCRIPTION:&n; * &n; * Return the type component of a geoid.&n; *  &n; * INTERNALS:&n; * &n; * Extract the type from the structure, and return it.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
id|geo_type_t
DECL|function|geo_type
id|geo_type
c_func
(paren
id|geoid_t
id|g
)paren
(brace
r_return
id|g.any.type
suffix:semicolon
)brace
multiline_comment|/*&n; * @doc gf:geo_valid&n; * &n; * int geo_valid(geoid_t g)&n; * &n; * DESCRIPTION:&n; * &n; * Return nonzero if g has a valid geoid type.&n; *  &n; * INTERNALS:&n; * &n; * Test the type against GEO_TYPE_INVALID, and return the result.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
r_int
DECL|function|geo_valid
id|geo_valid
c_func
(paren
id|geoid_t
id|g
)paren
(brace
r_return
id|g.any.type
op_ne
id|GEO_TYPE_INVALID
suffix:semicolon
)brace
multiline_comment|/*&n; * @doc gf:geo_cmp&n; * &n; * int geo_cmp(geoid_t g0, geoid_t g1)&n; * &n; * DESCRIPTION:&n; * &n; * Compare two geoid_t values, from the coarsest field to the finest.&n; * The comparison should be consistent with the physical locations of&n; * of the hardware named by the geoids.&n; *  &n; * INTERNALS:&n; * &n; * First compare the module, then the slab, type, and type-specific fields.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
r_int
DECL|function|geo_cmp
id|geo_cmp
c_func
(paren
id|geoid_t
id|g0
comma
id|geoid_t
id|g1
)paren
(brace
r_int
id|rv
suffix:semicolon
multiline_comment|/* Compare the common fields */
id|rv
op_assign
id|MODULE_CMP
c_func
(paren
id|geo_module
c_func
(paren
id|g0
)paren
comma
id|geo_module
c_func
(paren
id|g1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
l_int|0
)paren
r_return
id|rv
suffix:semicolon
id|rv
op_assign
id|geo_slab
c_func
(paren
id|g0
)paren
op_minus
id|geo_slab
c_func
(paren
id|g1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
l_int|0
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* Within a slab, sort by type */
id|rv
op_assign
id|geo_type
c_func
(paren
id|g0
)paren
op_minus
id|geo_type
c_func
(paren
id|g1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
l_int|0
)paren
r_return
id|rv
suffix:semicolon
r_switch
c_cond
(paren
id|geo_type
c_func
(paren
id|g0
)paren
)paren
(brace
r_case
id|GEO_TYPE_CPU
suffix:colon
id|rv
op_assign
id|g0.cpu.slice
op_minus
id|g1.cpu.slice
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEO_TYPE_IOCARD
suffix:colon
id|rv
op_assign
id|g0.pcicard.bus
op_minus
id|g1.pcicard.bus
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_break
suffix:semicolon
id|rv
op_assign
id|SLOTNUM_GETSLOT
c_func
(paren
id|g0.pcicard.slot
)paren
op_minus
id|SLOTNUM_GETSLOT
c_func
(paren
id|g1.pcicard.slot
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEO_TYPE_MEM
suffix:colon
id|rv
op_assign
id|g0.mem.membus
op_minus
id|g1.mem.membus
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_break
suffix:semicolon
id|rv
op_assign
id|g0.mem.memslot
op_minus
id|g1.mem.memslot
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * @doc gf:geo_new&n; * &n; * geoid_t geo_new(geo_type_t type, ...)&n; * &n; * DESCRIPTION:&n; * &n; * Generate a new geoid_t value of the given type from its components.&n; * Expected calling sequences:&n; * &bslash;@itemize &bslash;@bullet&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_INVALID)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_MODULE, moduleid_t m)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_NODE, moduleid_t m, slabid_t s)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_RTR, moduleid_t m, slabid_t s)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_IOCNTL, moduleid_t m, slabid_t s)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_IOCARD, moduleid_t m, slabid_t s, char bus, slotid_t slot)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_CPU, moduleid_t m, slabid_t s, char slice)&bslash;}&n; * &bslash;@item&n; * &bslash;@code&bslash;{geo_new(GEO_TYPE_MEM, moduleid_t m, slabid_t s, char membus, char slot)&bslash;}&n; * &bslash;@end itemize&n; *&n; * Invalid types return a GEO_TYPE_INVALID geoid_t.&n; *  &n; * INTERNALS:&n; * &n; * Use the type to determine which fields to expect.  Write the fields into&n; * a new geoid_t and return it.  Note:  scalars smaller than an &quot;int&quot; are&n; * promoted to &quot;int&quot; by the &quot;...&quot; operator, so we need extra casts on &quot;char&quot;,&n; * &quot;slotid_t&quot;, and &quot;slabid_t&quot;.&n; *   &n; * ORIGIN:&n; * &n; * New for SN2&n; */
id|geoid_t
DECL|function|geo_new
id|geo_new
c_func
(paren
id|geo_type_t
id|type
comma
dot
dot
dot
)paren
(brace
id|va_list
id|al
suffix:semicolon
id|geoid_t
id|g
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|g
comma
l_int|0
comma
r_sizeof
(paren
id|g
)paren
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|al
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Make sure the type is sane */
r_if
c_cond
(paren
id|type
op_ge
id|GEO_TYPE_MAX
)paren
id|type
op_assign
id|GEO_TYPE_INVALID
suffix:semicolon
id|g.any.type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|GEO_TYPE_INVALID
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* invalid geoids have no components at all */
id|g.any.module
op_assign
id|va_arg
c_func
(paren
id|al
comma
id|moduleid_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|GEO_TYPE_MODULE
)paren
r_goto
id|done
suffix:semicolon
id|g.any.slab
op_assign
(paren
id|slabid_t
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Some types have additional components */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|GEO_TYPE_CPU
suffix:colon
id|g.cpu.slice
op_assign
(paren
r_char
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEO_TYPE_IOCARD
suffix:colon
id|g.pcicard.bus
op_assign
(paren
r_char
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|g.pcicard.slot
op_assign
(paren
id|slotid_t
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEO_TYPE_MEM
suffix:colon
id|g.mem.membus
op_assign
(paren
r_char
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|g.mem.memslot
op_assign
(paren
r_char
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|done
suffix:colon
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
r_return
id|g
suffix:semicolon
)brace
eof
