multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
DECL|macro|USRPCI
mdefine_line|#define&t;USRPCI&t;0
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/pci_ids.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;&t;/* Must be before iograph.h to get MAX_PORT_NUM */
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/ioerror_handling.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio_private.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/ate_utils.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
macro_line|#ifdef __ia64
DECL|macro|rmallocmap
mdefine_line|#define rmallocmap atemapalloc
DECL|macro|rmfreemap
mdefine_line|#define rmfreemap atemapfree
DECL|macro|rmfree
mdefine_line|#define rmfree atefree
DECL|macro|rmalloc
mdefine_line|#define rmalloc atealloc
macro_line|#endif
DECL|macro|DEBUG_PCIIO
mdefine_line|#define DEBUG_PCIIO
DECL|macro|DEBUG_PCIIO
macro_line|#undef DEBUG_PCIIO&t;/* turn this on for yet more console output */
DECL|macro|GET_NEW
mdefine_line|#define GET_NEW(ptr)&t;(ptr = kmalloc(sizeof (*(ptr)), GFP_KERNEL))
DECL|macro|DO_DEL
mdefine_line|#define DO_DEL(ptr)&t;(kfree(ptr))
DECL|variable|pciio_info_fingerprint
r_char
id|pciio_info_fingerprint
(braket
)braket
op_assign
l_string|&quot;pciio_info&quot;
suffix:semicolon
DECL|variable|pciio_registry
id|cdl_p
id|pciio_registry
op_assign
l_int|NULL
suffix:semicolon
r_int
DECL|function|badaddr_val
id|badaddr_val
c_func
(paren
r_volatile
r_void
op_star
id|addr
comma
r_int
id|len
comma
r_volatile
r_void
op_star
id|ptr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_volatile
r_void
op_star
id|new_addr
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|4
suffix:colon
id|new_addr
op_assign
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
id|ret
op_assign
id|ia64_sn_probe_io_slot
c_func
(paren
(paren
r_int
)paren
id|new_addr
comma
id|len
comma
(paren
r_void
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;badaddr_val given len %x but supports len of 4 only&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;badaddr_val: unexpected status (%d) in probing&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|nasid_t
DECL|function|get_console_nasid
id|get_console_nasid
c_func
(paren
r_void
)paren
(brace
r_extern
id|nasid_t
id|console_nasid
suffix:semicolon
r_extern
id|nasid_t
id|master_baseio_nasid
suffix:semicolon
r_if
c_cond
(paren
id|console_nasid
OL
l_int|0
)paren
(brace
id|console_nasid
op_assign
id|ia64_sn_get_console_nasid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_nasid
OL
l_int|0
)paren
(brace
singleline_comment|// ZZZ What do we do if we don&squot;t get a console nasid on the hardware????
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|console_nasid
op_assign
id|master_baseio_nasid
suffix:semicolon
)brace
)brace
r_return
id|console_nasid
suffix:semicolon
)brace
id|nasid_t
DECL|function|get_master_baseio_nasid
id|get_master_baseio_nasid
c_func
(paren
r_void
)paren
(brace
r_extern
id|nasid_t
id|master_baseio_nasid
suffix:semicolon
r_extern
r_char
id|master_baseio_wid
suffix:semicolon
r_if
c_cond
(paren
id|master_baseio_nasid
OL
l_int|0
)paren
(brace
id|nasid_t
id|tmp
suffix:semicolon
id|master_baseio_nasid
op_assign
id|ia64_sn_get_master_baseio_nasid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master_baseio_nasid
op_ge
l_int|0
)paren
(brace
id|master_baseio_wid
op_assign
id|WIDGETID_GET
c_func
(paren
id|KL_CONFIG_CH_CONS_INFO
c_func
(paren
id|master_baseio_nasid
)paren
op_member_access_from_pointer
id|memory_base
)paren
suffix:semicolon
)brace
)brace
r_return
id|master_baseio_nasid
suffix:semicolon
)brace
r_int
DECL|function|hub_dma_enabled
id|hub_dma_enabled
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|hub_error_devenable
id|hub_error_devenable
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|devnum
comma
r_int
id|error_code
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ioerror_dump
id|ioerror_dump
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|error_code
comma
r_int
id|error_mode
comma
id|ioerror_t
op_star
id|ioerror
)paren
(brace
)brace
multiline_comment|/******&n; ****** end hack defines ......&n; ******/
multiline_comment|/* =====================================================================&n; *    PCI Generic Bus Provider&n; * Implement PCI provider operations.  The pciio* layer provides a&n; * platform-independent interface for PCI devices.  This layer&n; * switches among the possible implementations of a PCI adapter.&n; */
multiline_comment|/* =====================================================================&n; *    Provider Function Location SHORTCUT&n; *&n; * On platforms with only one possible PCI provider, macros can be&n; * set up at the top that cause the table lookups and indirections to&n; * completely disappear.&n; */
multiline_comment|/* =====================================================================&n; *    Function Table of Contents&n; */
macro_line|#if !defined(DEV_FUNC)
r_static
id|pciio_provider_t
op_star
id|pciio_to_provider_fns
c_func
(paren
id|devfs_handle_t
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|pciio_piomap_t
id|pciio_piomap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_piomap_free
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pciio_piomap_addr
c_func
(paren
id|pciio_piomap_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_piomap_done
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pciio_piotrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|caddr_t
id|pciio_pio_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
id|pciio_piomap_t
op_star
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_piospace_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_piospace_free
c_func
(paren
id|devfs_handle_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
id|pciio_dmamap_t
id|pciio_dmamap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_dmamap_free
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_dmamap_addr
c_func
(paren
id|pciio_dmamap_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|pciio_dmamap_list
c_func
(paren
id|pciio_dmamap_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_dmamap_done
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_dmatrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|pciio_dmatrans_list
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_dmamap_drain
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
r_void
id|pciio_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_dmalist_drain
c_func
(paren
id|devfs_handle_t
comma
id|alenlist_t
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_dma_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
id|pciio_dmamap_t
op_star
comma
r_int
)paren
suffix:semicolon
id|pciio_intr_t
id|pciio_intr_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_intr_line_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pciio_intr_free
c_func
(paren
id|pciio_intr_t
)paren
suffix:semicolon
r_int
id|pciio_intr_connect
c_func
(paren
id|pciio_intr_t
comma
id|intr_func_t
comma
id|intr_arg_t
)paren
suffix:semicolon
r_void
id|pciio_intr_disconnect
c_func
(paren
id|pciio_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_intr_cpu_get
c_func
(paren
id|pciio_intr_t
)paren
suffix:semicolon
r_void
id|pciio_slot_func_to_name
c_func
(paren
r_char
op_star
comma
id|pciio_slot_t
comma
id|pciio_function_t
)paren
suffix:semicolon
r_void
id|pciio_provider_startup
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pciio_provider_shutdown
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_endian_t
id|pciio_endian_set
c_func
(paren
id|devfs_handle_t
comma
id|pciio_endian_t
comma
id|pciio_endian_t
)paren
suffix:semicolon
id|pciio_priority_t
id|pciio_priority_set
c_func
(paren
id|devfs_handle_t
comma
id|pciio_priority_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_intr_dev_get
c_func
(paren
id|pciio_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_pio_dev_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_pio_slot_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|pciio_space_t
id|pciio_pio_space_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_pio_pciaddr_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|ulong
id|pciio_pio_mapsz_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pciio_pio_kvaddr_get
c_func
(paren
id|pciio_piomap_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_dma_dev_get
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_dma_slot_get
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info_chk
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pciio_info_set
c_func
(paren
id|devfs_handle_t
comma
id|pciio_info_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_info_dev_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_info_slot_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_function_t
id|pciio_info_function_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_vendor_id_t
id|pciio_info_vendor_id_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_device_id_t
id|pciio_info_device_id_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_info_master_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|arbitrary_info_t
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_provider_t
op_star
id|pciio_info_pops_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|error_handler_f
op_star
id|pciio_info_efunc_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|error_handler_arg_t
op_star
id|pciio_info_einfo_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|pciio_space_t
id|pciio_info_bar_space_get
c_func
(paren
id|pciio_info_t
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_info_bar_base_get
c_func
(paren
id|pciio_info_t
comma
r_int
)paren
suffix:semicolon
r_int
id|pciio_info_bar_size_get
c_func
(paren
id|pciio_info_t
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pciio_info_rom_base_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
r_int
id|pciio_info_rom_size_get
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
r_void
id|pciio_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|pciio_attach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pciio_provider_register
c_func
(paren
id|devfs_handle_t
comma
id|pciio_provider_t
op_star
id|pciio_fns
)paren
suffix:semicolon
r_void
id|pciio_provider_unregister
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_provider_t
op_star
id|pciio_provider_fns_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pciio_driver_register
c_func
(paren
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
comma
r_char
op_star
id|driver_prefix
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_driver_unregister
c_func
(paren
r_char
op_star
id|driver_prefix
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_device_register
c_func
(paren
id|devfs_handle_t
comma
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_void
id|pciio_device_unregister
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_device_info_new
c_func
(paren
id|pciio_info_t
comma
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_void
id|pciio_device_info_free
c_func
(paren
id|pciio_info_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pciio_device_info_register
c_func
(paren
id|devfs_handle_t
comma
id|pciio_info_t
)paren
suffix:semicolon
r_void
id|pciio_device_info_unregister
c_func
(paren
id|devfs_handle_t
comma
id|pciio_info_t
)paren
suffix:semicolon
r_int
id|pciio_device_attach
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
r_int
id|pciio_device_detach
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pciio_error_register
c_func
(paren
id|devfs_handle_t
comma
id|error_handler_f
op_star
comma
id|error_handler_arg_t
)paren
suffix:semicolon
r_int
id|pciio_reset
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pciio_write_gather_flush
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pciio_slot_inuse
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    Provider Function Location&n; *&n; *      If there is more than one possible provider for&n; *      this platform, we need to examine the master&n; *      vertex of the current vertex for a provider&n; *      function structure, and indirect through the&n; *      appropriately named member.&n; */
macro_line|#if !defined(DEV_FUNC)
r_static
id|pciio_provider_t
op_star
DECL|function|pciio_to_provider_fns
id|pciio_to_provider_fns
c_func
(paren
id|devfs_handle_t
id|dev
)paren
(brace
id|pciio_info_t
id|card_info
suffix:semicolon
id|pciio_provider_t
op_star
id|provider_fns
suffix:semicolon
multiline_comment|/*&n;     * We&squot;re called with two types of vertices, one is&n;     * the bridge vertex (ends with &quot;pci&quot;) and the other is the&n;     * pci slot vertex (ends with &quot;pci/[0-8]&quot;).  For the first type&n;     * we need to get the provider from the PFUNCS label.  For&n;     * the second we get it from fastinfo/c_pops.&n;     */
id|provider_fns
op_assign
id|pciio_provider_fns_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|provider_fns
op_eq
l_int|NULL
)paren
(brace
id|card_info
op_assign
id|pciio_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card_info
op_ne
l_int|NULL
)paren
(brace
id|provider_fns
op_assign
id|pciio_info_pops_get
c_func
(paren
id|card_info
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|provider_fns
op_eq
l_int|NULL
)paren
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|PRINT_PANIC
c_func
(paren
l_string|&quot;%v: provider_fns == NULL&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#else
id|PRINT_PANIC
c_func
(paren
l_string|&quot;0x%p: provider_fns == NULL&quot;
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_return
id|provider_fns
suffix:semicolon
)brace
DECL|macro|DEV_FUNC
mdefine_line|#define DEV_FUNC(dev,func)&t;pciio_to_provider_fns(dev)-&gt;func
DECL|macro|CAST_PIOMAP
mdefine_line|#define CAST_PIOMAP(x)&t;&t;((pciio_piomap_t)(x))
DECL|macro|CAST_DMAMAP
mdefine_line|#define CAST_DMAMAP(x)&t;&t;((pciio_dmamap_t)(x))
DECL|macro|CAST_INTR
mdefine_line|#define CAST_INTR(x)&t;&t;((pciio_intr_t)(x))
macro_line|#endif
multiline_comment|/*&n; * Many functions are not passed their vertex&n; * information directly; rather, they must&n; * dive through a resource map. These macros&n; * are available to coordinate this detail.&n; */
DECL|macro|PIOMAP_FUNC
mdefine_line|#define PIOMAP_FUNC(map,func)&t;&t;DEV_FUNC((map)-&gt;pp_dev,func)
DECL|macro|DMAMAP_FUNC
mdefine_line|#define DMAMAP_FUNC(map,func)&t;&t;DEV_FUNC((map)-&gt;pd_dev,func)
DECL|macro|INTR_FUNC
mdefine_line|#define INTR_FUNC(intr_hdl,func)&t;DEV_FUNC((intr_hdl)-&gt;pi_dev,func)
multiline_comment|/* =====================================================================&n; *          PIO MANAGEMENT&n; *&n; *      For mapping system virtual address space to&n; *      pciio space on a specified card&n; */
id|pciio_piomap_t
DECL|function|pciio_piomap_alloc
id|pciio_piomap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mapping for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* lowest address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* size of region containing our mappings */
r_int
id|byte_count_max
comma
multiline_comment|/* maximum size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in sys/pio.h */
r_return
(paren
id|pciio_piomap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piomap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_piomap_free
id|pciio_piomap_free
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_free
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_piomap_addr
id|pciio_piomap_addr
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
comma
multiline_comment|/* mapping resources */
id|iopaddr_t
id|pciio_addr
comma
multiline_comment|/* map for this pciio address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
id|pciio_piomap-&gt;pp_kvaddr
op_assign
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_addr
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
comma
id|pciio_addr
comma
id|byte_count
)paren
suffix:semicolon
r_return
id|pciio_piomap-&gt;pp_kvaddr
suffix:semicolon
)brace
r_void
DECL|function|pciio_piomap_done
id|pciio_piomap_done
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_done
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_piotrans_addr
id|pciio_piotrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* starting address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
r_int
id|flags
)paren
(brace
multiline_comment|/* (currently unused) */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piotrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_pio_addr
id|pciio_pio_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* starting address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
id|pciio_piomap_t
op_star
id|mapp
comma
multiline_comment|/* where to return the map pointer */
r_int
id|flags
)paren
(brace
multiline_comment|/* PIO flags */
id|pciio_piomap_t
id|map
op_assign
l_int|0
suffix:semicolon
r_int
id|errfree
op_assign
l_int|0
suffix:semicolon
id|caddr_t
id|res
suffix:semicolon
r_if
c_cond
(paren
id|mapp
)paren
(brace
id|map
op_assign
op_star
id|mapp
suffix:semicolon
multiline_comment|/* possible pre-allocated map */
op_star
id|mapp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* record &quot;no map used&quot; */
)brace
id|res
op_assign
id|pciio_piotrans_addr
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piotrans worked */
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|map
op_assign
id|pciio_piomap_alloc
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_alloc failed */
id|errfree
op_assign
l_int|1
suffix:semicolon
)brace
id|res
op_assign
id|pciio_piomap_addr
(paren
id|map
comma
id|addr
comma
id|byte_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|errfree
)paren
id|pciio_piomap_free
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_addr failed */
)brace
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
id|map
suffix:semicolon
multiline_comment|/* pass back map used */
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_addr succeeded */
)brace
id|iopaddr_t
DECL|function|pciio_piospace_alloc
id|pciio_piospace_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* Device requiring space */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* Device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* MEM32/MEM64/IO */
r_int
id|byte_count
comma
multiline_comment|/* Size of mapping */
r_int
id|align
)paren
(brace
multiline_comment|/* Alignment needed */
r_if
c_cond
(paren
id|align
OL
id|NBPP
)paren
id|align
op_assign
id|NBPP
suffix:semicolon
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piospace_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|byte_count
comma
id|align
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_piospace_free
id|pciio_piospace_free
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* Device freeing space */
id|pciio_space_t
id|space
comma
multiline_comment|/* Type of space        */
id|iopaddr_t
id|pciaddr
comma
multiline_comment|/* starting address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* Range of address   */
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piospace_free
)paren
(paren
id|dev
comma
id|space
comma
id|pciaddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          DMA MANAGEMENT&n; *&n; *      For mapping from pci space to system&n; *      physical space.&n; */
id|pciio_dmamap_t
DECL|function|pciio_dmamap_alloc
id|pciio_dmamap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
(paren
id|pciio_dmamap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmamap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmamap_free
id|pciio_dmamap_free
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_free
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dmamap_addr
id|pciio_dmamap_addr
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
r_return
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_addr
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
id|alenlist_t
DECL|function|pciio_dmamap_list
id|pciio_dmamap_list
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
comma
multiline_comment|/* use these mapping resources */
id|alenlist_t
id|alenlist
comma
multiline_comment|/* map this Address/Length List */
r_int
id|flags
)paren
(brace
r_return
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_list
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
comma
id|alenlist
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmamap_done
id|pciio_dmamap_done
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_done
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dmatrans_addr
id|pciio_dmatrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|alenlist_t
DECL|function|pciio_dmatrans_list
id|pciio_dmatrans_list
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|alenlist_t
id|palenlist
comma
multiline_comment|/* system address/length list */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_list
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|palenlist
comma
id|flags
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dma_addr
id|pciio_dma_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
id|pciio_dmamap_t
op_star
id|mapp
comma
multiline_comment|/* map to use, then map we used */
r_int
id|flags
)paren
(brace
multiline_comment|/* PIO flags */
id|pciio_dmamap_t
id|map
op_assign
l_int|0
suffix:semicolon
r_int
id|errfree
op_assign
l_int|0
suffix:semicolon
id|iopaddr_t
id|res
suffix:semicolon
r_if
c_cond
(paren
id|mapp
)paren
(brace
id|map
op_assign
op_star
id|mapp
suffix:semicolon
multiline_comment|/* possible pre-allocated map */
op_star
id|mapp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* record &quot;no map used&quot; */
)brace
id|res
op_assign
id|pciio_dmatrans_addr
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmatrans worked */
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|map
op_assign
id|pciio_dmamap_alloc
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_alloc failed */
id|errfree
op_assign
l_int|1
suffix:semicolon
)brace
id|res
op_assign
id|pciio_dmamap_addr
(paren
id|map
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|errfree
)paren
id|pciio_dmamap_free
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_addr failed */
)brace
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
id|map
suffix:semicolon
multiline_comment|/* pass back map used */
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_addr succeeded */
)brace
r_void
DECL|function|pciio_dmamap_drain
id|pciio_dmamap_drain
c_func
(paren
id|pciio_dmamap_t
id|map
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|map
comma
id|dmamap_drain
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|map
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmaaddr_drain
id|pciio_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|paddr_t
id|addr
comma
r_int
id|size
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmaaddr_drain
)paren
(paren
id|dev
comma
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmalist_drain
id|pciio_dmalist_drain
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|alenlist_t
id|list
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmalist_drain
)paren
(paren
id|dev
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          INTERRUPT MANAGEMENT&n; *&n; *      Allow crosstalk devices to establish interrupts&n; */
multiline_comment|/*&n; * Allocate resources required for an interrupt as specified in intr_desc.&n; * Return resource handle in intr_hdl.&n; */
id|pciio_intr_t
DECL|function|pciio_intr_alloc
id|pciio_intr_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
multiline_comment|/* which Crosstalk device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_intr_line_t
id|lines
comma
multiline_comment|/* INTR line(s) to attach */
id|devfs_handle_t
id|owner_dev
)paren
(brace
multiline_comment|/* owner of this interrupt */
r_return
(paren
id|pciio_intr_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|intr_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|lines
comma
id|owner_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free resources consumed by intr_alloc.&n; */
r_void
DECL|function|pciio_intr_free
id|pciio_intr_free
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_free
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate resources allocated with a previous pciio_intr_alloc call with the&n; * described handler, arg, name, etc.&n; *&n; * Returns 0 on success, returns &lt;0 on failure.&n; */
r_int
DECL|function|pciio_intr_connect
id|pciio_intr_connect
c_func
(paren
id|pciio_intr_t
id|intr_hdl
comma
id|intr_func_t
id|intr_func
comma
id|intr_arg_t
id|intr_arg
)paren
multiline_comment|/* pciio intr resource handle */
(brace
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_connect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
comma
id|intr_func
comma
id|intr_arg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate handler with the specified interrupt.&n; */
r_void
DECL|function|pciio_intr_disconnect
id|pciio_intr_disconnect
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_disconnect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a hwgraph vertex that represents the CPU currently&n; * targeted by an interrupt.&n; */
id|devfs_handle_t
DECL|function|pciio_intr_cpu_get
id|pciio_intr_cpu_get
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_cpu_get
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_slot_func_to_name
id|pciio_slot_func_to_name
c_func
(paren
r_char
op_star
id|name
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|func
)paren
(brace
multiline_comment|/*&n;     * standard connection points:&n;     *&n;     * PCIIO_SLOT_NONE:&t;.../pci/direct&n;     * PCIIO_FUNC_NONE: .../pci/&lt;SLOT&gt;&t;&t;&t;ie. .../pci/3&n;     * multifunction:   .../pci/&lt;SLOT&gt;&lt;FUNC&gt;&t;&t;ie. .../pci/3c&n;     */
r_if
c_cond
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
id|sprintf
c_func
(paren
id|name
comma
id|EDGE_LBL_DIRECT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|func
op_eq
id|PCIIO_FUNC_NONE
)paren
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d%c&quot;
comma
id|slot
comma
l_char|&squot;a&squot;
op_plus
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pciio_cardinfo_get&n; *&n; * Get the pciio info structure corresponding to the&n; * specified PCI &quot;slot&quot; (we like it when the same index&n; * number is used for the PCI IDSEL, the REQ/GNT pair,&n; * and the interrupt line being used for INTA. We like&n; * it so much we call it the slot number).&n; */
r_static
id|pciio_info_t
DECL|function|pciio_cardinfo_get
id|pciio_cardinfo_get
c_func
(paren
id|devfs_handle_t
id|pciio_vhdl
comma
id|pciio_slot_t
id|pci_slot
)paren
(brace
r_char
id|namebuf
(braket
l_int|16
)braket
suffix:semicolon
id|pciio_info_t
id|info
op_assign
l_int|0
suffix:semicolon
id|devfs_handle_t
id|conn
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|namebuf
comma
id|pci_slot
comma
id|PCIIO_FUNC_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_traverse
c_func
(paren
id|pciio_vhdl
comma
id|namebuf
comma
op_amp
id|conn
)paren
)paren
(brace
id|info
op_assign
id|pciio_info_chk
c_func
(paren
id|conn
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
suffix:semicolon
)brace
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/*&n; * pciio_error_handler:&n; * dispatch an error to the appropriate&n; * pciio connection point, or process&n; * it as a generic pci error.&n; * Yes, the first parameter is the&n; * provider vertex at the middle of&n; * the bus; we get to the pciio connect&n; * point using the ioerror widgetdev field.&n; *&n; * This function is called by the&n; * specific PCI provider, after it has figured&n; * out where on the PCI bus (including which slot,&n; * if it can tell) the error came from.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_error_handler
id|pciio_error_handler
c_func
(paren
id|devfs_handle_t
id|pciio_vhdl
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioerror
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|devfs_handle_t
id|pconn_vhdl
suffix:semicolon
macro_line|#if USRPCI
id|devfs_handle_t
id|usrpci_v
suffix:semicolon
macro_line|#endif
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|retval
suffix:semicolon
macro_line|#ifdef EHE_ENABLE
id|error_state_t
id|e_state
suffix:semicolon
macro_line|#endif /* EHE_ENABLE */
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pciio_error_handler&bslash;n&quot;
comma
id|pciio_vhdl
)paren
suffix:semicolon
macro_line|#endif
id|IOERR_PRINTF
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%v: PCI Bus Error: Error code: %d Error mode: %d&bslash;n&quot;
comma
id|pciio_vhdl
comma
id|error_code
comma
id|mode
)paren
)paren
suffix:semicolon
multiline_comment|/* If there is an error handler sitting on&n;     * the &quot;no-slot&quot; connection point, give it&n;     * first crack at the error. NOTE: it is&n;     * quite possible that this function may&n;     * do further refining of the ioerror.&n;     */
id|pciio_info
op_assign
id|pciio_cardinfo_get
c_func
(paren
id|pciio_vhdl
comma
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
op_logical_and
id|pciio_info-&gt;c_efunc
)paren
(brace
id|pconn_vhdl
op_assign
id|pciio_info_dev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
macro_line|#ifdef EHE_ENABLE
id|e_state
op_assign
id|error_state_get
c_func
(paren
id|pciio_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e_state
op_eq
id|ERROR_STATE_ACTION
)paren
(paren
r_void
)paren
id|error_state_set
c_func
(paren
id|pciio_vhdl
comma
id|ERROR_STATE_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_state_set
c_func
(paren
id|pconn_vhdl
comma
id|e_state
)paren
op_eq
id|ERROR_RETURN_CODE_CANNOT_SET_STATE
)paren
r_return
id|IOERROR_UNHANDLED
suffix:semicolon
macro_line|#endif 
id|retval
op_assign
id|pciio_info-&gt;c_efunc
(paren
id|pciio_info-&gt;c_einfo
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_UNHANDLED
)paren
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Is the error associated with a particular slot?&n;     */
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioerror
comma
id|widgetdev
)paren
)paren
(brace
r_int
id|widgetdev
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE : &n;&t; * widgetdev is a 4byte value encoded as slot in the higher order&n;&t; * 2 bytes and function in the lower order 2 bytes.&n;&t; */
id|IOERROR_GETVALUE
c_func
(paren
id|widgetdev
comma
id|ioerror
comma
id|widgetdev
)paren
suffix:semicolon
id|slot
op_assign
id|pciio_widgetdev_slot_get
c_func
(paren
id|widgetdev
)paren
suffix:semicolon
multiline_comment|/* If this slot has an error handler,&n;&t; * deliver the error to it.&n;&t; */
id|pciio_info
op_assign
id|pciio_cardinfo_get
c_func
(paren
id|pciio_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pciio_info-&gt;c_efunc
op_ne
l_int|NULL
)paren
(brace
id|pconn_vhdl
op_assign
id|pciio_info_dev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
macro_line|#ifdef EHE_ENABLE
id|e_state
op_assign
id|error_state_get
c_func
(paren
id|pciio_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e_state
op_eq
id|ERROR_STATE_ACTION
)paren
(paren
r_void
)paren
id|error_state_set
c_func
(paren
id|pciio_vhdl
comma
id|ERROR_STATE_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_state_set
c_func
(paren
id|pconn_vhdl
comma
id|e_state
)paren
op_eq
id|ERROR_RETURN_CODE_CANNOT_SET_STATE
)paren
r_return
id|IOERROR_UNHANDLED
suffix:semicolon
macro_line|#endif /* EHE_ENABLE */
id|retval
op_assign
id|pciio_info-&gt;c_efunc
(paren
id|pciio_info-&gt;c_einfo
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_UNHANDLED
)paren
r_return
id|retval
suffix:semicolon
)brace
macro_line|#if USRPCI
multiline_comment|/* If the USRPCI driver is available and&n;&t;     * knows about this connection point,&n;&t;     * deliver the error to it.&n;&t;     *&n;&t;     * OK to use pconn_vhdl here, even though we&n;&t;     * have already UNREF&squot;d it, since we know that&n;&t;     * it is not going away.&n;&t;     */
id|pconn_vhdl
op_assign
id|pciio_info_dev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_traverse
c_func
(paren
id|pconn_vhdl
comma
id|EDGE_LBL_USRPCI
comma
op_amp
id|usrpci_v
)paren
)paren
(brace
id|iopaddr_t
id|busaddr
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|busaddr
comma
id|ioerror
comma
id|busaddr
)paren
suffix:semicolon
id|retval
op_assign
id|usrpci_error_handler
(paren
id|usrpci_v
comma
id|error_code
comma
id|busaddr
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|usrpci_v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_UNHANDLED
)paren
(brace
multiline_comment|/*&n;&t;&t;     * This unref is not needed.  If this code is called often enough,&n;&t;&t;     * the system will crash, due to vertex reference count reaching 0,&n;&t;&t;     * causing vertex to be unallocated.  -jeremy&n;&t;&t;     * hwgraph_vertex_unref(pconn_vhdl);&n;&t;&t;     */
r_return
id|retval
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
r_return
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
ques
c_cond
id|IOERROR_HANDLED
multiline_comment|/* probes are OK */
suffix:colon
id|IOERROR_UNHANDLED
suffix:semicolon
multiline_comment|/* otherwise, foo! */
)brace
multiline_comment|/* =====================================================================&n; *          CONFIGURATION MANAGEMENT&n; */
multiline_comment|/*&n; * Startup a crosstalk provider&n; */
r_void
DECL|function|pciio_provider_startup
id|pciio_provider_startup
c_func
(paren
id|devfs_handle_t
id|pciio_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|pciio_provider
comma
id|provider_startup
)paren
(paren
id|pciio_provider
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shutdown a crosstalk provider&n; */
r_void
DECL|function|pciio_provider_shutdown
id|pciio_provider_shutdown
c_func
(paren
id|devfs_handle_t
id|pciio_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|pciio_provider
comma
id|provider_shutdown
)paren
(paren
id|pciio_provider
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Specify endianness constraints.  The driver tells us what the device&n; * does and how it would like to see things in memory.  We reply with&n; * how things will actually appear in memory.&n; */
id|pciio_endian_t
DECL|function|pciio_endian_set
id|pciio_endian_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|device_end
op_eq
id|PCIDMA_ENDIAN_BIG
)paren
op_logical_or
(paren
id|device_end
op_eq
id|PCIDMA_ENDIAN_LITTLE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|desired_end
op_eq
id|PCIDMA_ENDIAN_BIG
)paren
op_logical_or
(paren
id|desired_end
op_eq
id|PCIDMA_ENDIAN_LITTLE
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%v: pciio_endian_set is going away.&bslash;n&quot;
l_string|&quot;&bslash;tplease use PCIIO_BYTE_STREAM or PCIIO_WORD_VALUES in your&bslash;n&quot;
l_string|&quot;&bslash;tpciio_dmamap_alloc and pciio_dmatrans calls instead.&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;0x%x: pciio_endian_set is going away.&bslash;n&quot;
l_string|&quot;&bslash;tplease use PCIIO_BYTE_STREAM or PCIIO_WORD_VALUES in your&bslash;n&quot;
l_string|&quot;&bslash;tpciio_dmamap_alloc and pciio_dmatrans calls instead.&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|endian_set
)paren
(paren
id|dev
comma
id|device_end
comma
id|desired_end
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Specify PCI arbitration priority.&n; */
id|pciio_priority_t
DECL|function|pciio_priority_set
id|pciio_priority_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pciio_priority_t
id|device_prio
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|device_prio
op_eq
id|PCI_PRIO_HIGH
)paren
op_logical_or
(paren
id|device_prio
op_eq
id|PCI_PRIO_LOW
)paren
)paren
suffix:semicolon
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|priority_set
)paren
(paren
id|dev
comma
id|device_prio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read value of configuration register&n; */
r_uint64
DECL|function|pciio_config_get
id|pciio_config_get
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|reg
comma
r_int
id|size
)paren
(brace
r_uint64
id|value
op_assign
l_int|0
suffix:semicolon
r_int
id|shift
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* handle accesses that cross words here,&n;     * since that&squot;s common code between all&n;     * possible providers.&n;     */
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|biw
op_assign
l_int|4
op_minus
(paren
id|reg
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|biw
OG
id|size
)paren
id|biw
op_assign
id|size
suffix:semicolon
id|value
op_or_assign
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|config_get
)paren
(paren
id|dev
comma
id|reg
comma
id|biw
)paren
op_lshift
id|shift
suffix:semicolon
id|shift
op_add_assign
l_int|8
op_star
id|biw
suffix:semicolon
id|reg
op_add_assign
id|biw
suffix:semicolon
id|size
op_sub_assign
id|biw
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/*&n; * Change value of configuration register&n; */
r_void
DECL|function|pciio_config_set
id|pciio_config_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|reg
comma
r_int
id|size
comma
r_uint64
id|value
)paren
(brace
multiline_comment|/* handle accesses that cross words here,&n;     * since that&squot;s common code between all&n;     * possible providers.&n;     */
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|biw
op_assign
l_int|4
op_minus
(paren
id|reg
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|biw
OG
id|size
)paren
id|biw
op_assign
id|size
suffix:semicolon
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|config_set
)paren
(paren
id|dev
comma
id|reg
comma
id|biw
comma
id|value
)paren
suffix:semicolon
id|reg
op_add_assign
id|biw
suffix:semicolon
id|size
op_sub_assign
id|biw
suffix:semicolon
id|value
op_rshift_assign
id|biw
op_star
l_int|8
suffix:semicolon
)brace
)brace
multiline_comment|/* =====================================================================&n; *          GENERIC PCI SUPPORT FUNCTIONS&n; */
multiline_comment|/*&n; * Issue a hardware reset to a card.&n; */
r_int
DECL|function|pciio_reset
id|pciio_reset
c_func
(paren
id|devfs_handle_t
id|dev
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|reset
)paren
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * flush write gather buffers&n; */
r_int
DECL|function|pciio_write_gather_flush
id|pciio_write_gather_flush
c_func
(paren
id|devfs_handle_t
id|dev
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|write_gather_flush
)paren
(paren
id|dev
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|pciio_intr_dev_get
id|pciio_intr_dev_get
c_func
(paren
id|pciio_intr_t
id|pciio_intr
)paren
(brace
r_return
(paren
id|pciio_intr-&gt;pi_dev
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk pio interfaces ******/
id|devfs_handle_t
DECL|function|pciio_pio_dev_get
id|pciio_pio_dev_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_dev
)paren
suffix:semicolon
)brace
id|pciio_slot_t
DECL|function|pciio_pio_slot_get
id|pciio_pio_slot_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_slot
)paren
suffix:semicolon
)brace
id|pciio_space_t
DECL|function|pciio_pio_space_get
id|pciio_pio_space_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_space
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_pio_pciaddr_get
id|pciio_pio_pciaddr_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_pciaddr
)paren
suffix:semicolon
)brace
id|ulong
DECL|function|pciio_pio_mapsz_get
id|pciio_pio_mapsz_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_mapsz
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_pio_kvaddr_get
id|pciio_pio_kvaddr_get
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
r_return
(paren
id|pciio_piomap-&gt;pp_kvaddr
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic crosstalk dma interfaces ******/
id|devfs_handle_t
DECL|function|pciio_dma_dev_get
id|pciio_dma_dev_get
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
r_return
(paren
id|pciio_dmamap-&gt;pd_dev
)paren
suffix:semicolon
)brace
id|pciio_slot_t
DECL|function|pciio_dma_slot_get
id|pciio_dma_slot_get
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
r_return
(paren
id|pciio_dmamap-&gt;pd_slot
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic pci slot information interfaces ******/
id|pciio_info_t
DECL|function|pciio_info_chk
id|pciio_info_chk
c_func
(paren
id|devfs_handle_t
id|pciio
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
id|hwgraph_info_get_LBL
c_func
(paren
id|pciio
comma
id|INFO_LBL_PCIIO
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_return
(paren
id|pciio_info_t
)paren
id|ainfo
suffix:semicolon
)brace
id|pciio_info_t
DECL|function|pciio_info_get
id|pciio_info_get
c_func
(paren
id|devfs_handle_t
id|pciio
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_info
op_assign
(paren
id|pciio_info_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|pciio
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PCIIO
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|pciio
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_PCIIO */
r_if
c_cond
(paren
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|pciio_info-&gt;c_fingerprint
op_ne
id|pciio_info_fingerprint
)paren
op_logical_and
(paren
id|pciio_info-&gt;c_fingerprint
op_ne
l_int|NULL
)paren
)paren
(brace
r_return
(paren
id|pciio_info_t
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Should panic .. */
)brace
r_return
id|pciio_info
suffix:semicolon
)brace
r_void
DECL|function|pciio_info_set
id|pciio_info_set
c_func
(paren
id|devfs_handle_t
id|pciio
comma
id|pciio_info_t
id|pciio_info
)paren
(brace
r_if
c_cond
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
id|pciio_info-&gt;c_fingerprint
op_assign
id|pciio_info_fingerprint
suffix:semicolon
id|hwgraph_fastinfo_set
c_func
(paren
id|pciio
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_info
)paren
suffix:semicolon
multiline_comment|/* Also, mark this vertex as a PCI slot&n;     * and use the pciio_info, so pciio_info_chk&n;     * can work (and be fairly efficient).&n;     */
id|hwgraph_info_add_LBL
c_func
(paren
id|pciio
comma
id|INFO_LBL_PCIIO
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_info
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|pciio_info_dev_get
id|pciio_info_dev_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_vertex
)paren
suffix:semicolon
)brace
id|pciio_slot_t
DECL|function|pciio_info_slot_get
id|pciio_info_slot_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_slot
)paren
suffix:semicolon
)brace
id|pciio_function_t
DECL|function|pciio_info_function_get
id|pciio_info_function_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
)brace
id|pciio_vendor_id_t
DECL|function|pciio_info_vendor_id_get
id|pciio_info_vendor_id_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_vendor
)paren
suffix:semicolon
)brace
id|pciio_device_id_t
DECL|function|pciio_info_device_id_get
id|pciio_info_device_id_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_device
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|pciio_info_master_get
id|pciio_info_master_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_master
)paren
suffix:semicolon
)brace
id|arbitrary_info_t
DECL|function|pciio_info_mfast_get
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_mfast
)paren
suffix:semicolon
)brace
id|pciio_provider_t
op_star
DECL|function|pciio_info_pops_get
id|pciio_info_pops_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_pops
)paren
suffix:semicolon
)brace
id|error_handler_f
op_star
DECL|function|pciio_info_efunc_get
id|pciio_info_efunc_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_efunc
)paren
suffix:semicolon
)brace
id|error_handler_arg_t
op_star
DECL|function|pciio_info_einfo_get
id|pciio_info_einfo_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_einfo
)paren
suffix:semicolon
)brace
id|pciio_space_t
DECL|function|pciio_info_bar_space_get
id|pciio_info_bar_space_get
c_func
(paren
id|pciio_info_t
id|info
comma
r_int
id|win
)paren
(brace
r_return
id|info-&gt;c_window
(braket
id|win
)braket
dot
id|w_space
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_info_bar_base_get
id|pciio_info_bar_base_get
c_func
(paren
id|pciio_info_t
id|info
comma
r_int
id|win
)paren
(brace
r_return
id|info-&gt;c_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
)brace
r_int
DECL|function|pciio_info_bar_size_get
id|pciio_info_bar_size_get
c_func
(paren
id|pciio_info_t
id|info
comma
r_int
id|win
)paren
(brace
r_return
id|info-&gt;c_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_info_rom_base_get
id|pciio_info_rom_base_get
c_func
(paren
id|pciio_info_t
id|info
)paren
(brace
r_return
id|info-&gt;c_rbase
suffix:semicolon
)brace
r_int
DECL|function|pciio_info_rom_size_get
id|pciio_info_rom_size_get
c_func
(paren
id|pciio_info_t
id|info
)paren
(brace
r_return
id|info-&gt;c_rsize
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          GENERIC PCI INITIALIZATION FUNCTIONS&n; */
multiline_comment|/*&n; *    pciioinit: called once during device driver&n; *      initializtion if this driver is configured into&n; *      the system.&n; */
r_void
DECL|function|pciio_init
id|pciio_init
c_func
(paren
r_void
)paren
(brace
id|cdl_p
id|cp
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printf
c_func
(paren
l_string|&quot;pciio_init&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate the registry.&n;     * We might already have one.&n;     * If we don&squot;t, go get one.&n;     * MPness: someone might have&n;     * set one up for us while we&n;     * were not looking; use an atomic&n;     * compare-and-swap to commit to&n;     * using the new registry if and&n;     * only if nobody else did first.&n;     * If someone did get there first,&n;     * toss the one we allocated back&n;     * into the pool.&n;     */
r_if
c_cond
(paren
id|pciio_registry
op_eq
l_int|NULL
)paren
(brace
id|cp
op_assign
id|cdl_new
c_func
(paren
id|EDGE_LBL_PCI
comma
l_string|&quot;vendor&quot;
comma
l_string|&quot;device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|pciio_registry
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|cp
)paren
)paren
(brace
id|cdl_del
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|pciio_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *    pciioattach: called for each vertex in the graph&n; *      that is a PCI provider.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_attach
id|pciio_attach
c_func
(paren
id|devfs_handle_t
id|pciio
)paren
(brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
l_string|&quot;%v: pciio_attach&bslash;n&quot;
comma
id|pciio
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;0x%x: pciio_attach&bslash;n&quot;
comma
id|pciio
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate a set of pciio_provider functions with a vertex.&n; */
r_void
DECL|function|pciio_provider_register
id|pciio_provider_register
c_func
(paren
id|devfs_handle_t
id|provider
comma
id|pciio_provider_t
op_star
id|pciio_fns
)paren
(brace
id|hwgraph_info_add_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_fns
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate a set of pciio_provider functions with a vertex.&n; */
r_void
DECL|function|pciio_provider_unregister
id|pciio_provider_unregister
c_func
(paren
id|devfs_handle_t
id|provider
)paren
(brace
id|arbitrary_info_t
id|ainfo
suffix:semicolon
id|hwgraph_info_remove_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
(paren
r_int
op_star
)paren
op_amp
id|ainfo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain a pointer to the pciio_provider functions for a specified Crosstalk&n; * provider.&n; */
id|pciio_provider_t
op_star
DECL|function|pciio_provider_fns_get
id|pciio_provider_fns_get
c_func
(paren
id|devfs_handle_t
id|provider
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_info_get_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_return
(paren
id|pciio_provider_t
op_star
)paren
id|ainfo
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED4 */
r_int
DECL|function|pciio_driver_register
id|pciio_driver_register
c_func
(paren
id|pciio_vendor_id_t
id|vendor_id
comma
id|pciio_device_id_t
id|device_id
comma
r_char
op_star
id|driver_prefix
comma
r_int
id|flags
)paren
(brace
multiline_comment|/* a driver&squot;s init routine might call&n;     * pciio_driver_register before the&n;     * system calls pciio_init; so we&n;     * make the init call ourselves here.&n;     */
r_if
c_cond
(paren
id|pciio_registry
op_eq
l_int|NULL
)paren
id|pciio_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|cdl_add_driver
c_func
(paren
id|pciio_registry
comma
id|vendor_id
comma
id|device_id
comma
id|driver_prefix
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an initialization function.&n; */
r_void
DECL|function|pciio_driver_unregister
id|pciio_driver_unregister
c_func
(paren
r_char
op_star
id|driver_prefix
)paren
(brace
multiline_comment|/* before a driver calls unregister,&n;     * it must have called register; so&n;     * we can assume we have a registry here.&n;     */
id|ASSERT
c_func
(paren
id|pciio_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cdl_del_driver
c_func
(paren
id|pciio_registry
comma
id|driver_prefix
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Set the slot status for a device supported by the &n; * driver being registered.&n; */
r_void
DECL|function|pciio_driver_reg_callback
id|pciio_driver_reg_callback
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
id|key1
comma
r_int
id|key2
comma
r_int
id|error
)paren
(brace
)brace
multiline_comment|/* &n; * Set the slot status for a device supported by the &n; * driver being unregistered.&n; */
r_void
DECL|function|pciio_driver_unreg_callback
id|pciio_driver_unreg_callback
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
id|key1
comma
r_int
id|key2
comma
r_int
id|error
)paren
(brace
)brace
multiline_comment|/*&n; * Call some function with each vertex that&n; * might be one of this driver&squot;s attach points.&n; */
r_void
DECL|function|pciio_iterate
id|pciio_iterate
c_func
(paren
r_char
op_star
id|driver_prefix
comma
id|pciio_iter_f
op_star
id|func
)paren
(brace
multiline_comment|/* a driver&squot;s init routine might call&n;     * pciio_iterate before the&n;     * system calls pciio_init; so we&n;     * make the init call ourselves here.&n;     */
r_if
c_cond
(paren
id|pciio_registry
op_eq
l_int|NULL
)paren
id|pciio_init
c_func
(paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cdl_iterate
c_func
(paren
id|pciio_registry
comma
id|driver_prefix
comma
(paren
id|cdl_iter_f
op_star
)paren
id|func
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|pciio_device_register
id|pciio_device_register
c_func
(paren
id|devfs_handle_t
id|connectpt
comma
multiline_comment|/* vertex for /hw/.../pciio/%d */
id|devfs_handle_t
id|master
comma
multiline_comment|/* card&squot;s master ASIC (PCI provider) */
id|pciio_slot_t
id|slot
comma
multiline_comment|/* card&squot;s slot */
id|pciio_function_t
id|func
comma
multiline_comment|/* card&squot;s func */
id|pciio_vendor_id_t
id|vendor_id
comma
id|pciio_device_id_t
id|device_id
)paren
(brace
r_return
id|pciio_device_info_register
(paren
id|connectpt
comma
id|pciio_device_info_new
(paren
l_int|NULL
comma
id|master
comma
id|slot
comma
id|func
comma
id|vendor_id
comma
id|device_id
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_device_unregister
id|pciio_device_unregister
c_func
(paren
id|devfs_handle_t
id|pconn
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|pconn
comma
id|device_unregister
)paren
(paren
id|pconn
)paren
suffix:semicolon
)brace
id|pciio_info_t
DECL|function|pciio_device_info_new
id|pciio_device_info_new
c_func
(paren
id|pciio_info_t
id|pciio_info
comma
id|devfs_handle_t
id|master
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|func
comma
id|pciio_vendor_id_t
id|vendor_id
comma
id|pciio_device_id_t
id|device_id
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pciio_info
)paren
id|GET_NEW
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|pciio_info-&gt;c_slot
op_assign
id|slot
suffix:semicolon
id|pciio_info-&gt;c_func
op_assign
id|func
suffix:semicolon
id|pciio_info-&gt;c_vendor
op_assign
id|vendor_id
suffix:semicolon
id|pciio_info-&gt;c_device
op_assign
id|device_id
suffix:semicolon
id|pciio_info-&gt;c_master
op_assign
id|master
suffix:semicolon
id|pciio_info-&gt;c_mfast
op_assign
id|hwgraph_fastinfo_get
c_func
(paren
id|master
)paren
suffix:semicolon
id|pciio_info-&gt;c_pops
op_assign
id|pciio_provider_fns_get
c_func
(paren
id|master
)paren
suffix:semicolon
id|pciio_info-&gt;c_efunc
op_assign
l_int|0
suffix:semicolon
id|pciio_info-&gt;c_einfo
op_assign
l_int|0
suffix:semicolon
r_return
id|pciio_info
suffix:semicolon
)brace
r_void
DECL|function|pciio_device_info_free
id|pciio_device_info_free
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
multiline_comment|/* NOTE : pciio_info is a structure within the pcibr_info&n;     *&t;      and not a pointer to memory allocated on the heap !!&n;     */
id|BZERO
c_func
(paren
(paren
r_char
op_star
)paren
id|pciio_info
comma
r_sizeof
(paren
id|pciio_info
)paren
)paren
suffix:semicolon
)brace
id|devfs_handle_t
DECL|function|pciio_device_info_register
id|pciio_device_info_register
c_func
(paren
id|devfs_handle_t
id|connectpt
comma
multiline_comment|/* vertex at center of bus */
id|pciio_info_t
id|pciio_info
)paren
multiline_comment|/* details about the connectpt */
(brace
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
id|devfs_handle_t
id|pconn
suffix:semicolon
r_int
id|device_master_set
c_func
(paren
id|devfs_handle_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|name
comma
id|pciio_info-&gt;c_slot
comma
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_path_add
c_func
(paren
id|connectpt
comma
id|name
comma
op_amp
id|pconn
)paren
)paren
r_return
id|pconn
suffix:semicolon
id|pciio_info-&gt;c_vertex
op_assign
id|pconn
suffix:semicolon
id|pciio_info_set
c_func
(paren
id|pconn
comma
id|pciio_info
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PCIIO
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|pconn
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : pconn path= %s &bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_PCIIO */
multiline_comment|/*&n;     * create link to our pci provider&n;     */
id|device_master_set
c_func
(paren
id|pconn
comma
id|pciio_info-&gt;c_master
)paren
suffix:semicolon
macro_line|#if USRPCI
multiline_comment|/*&n;     * Call into usrpci provider to let it initialize for&n;     * the given slot.&n;     */
r_if
c_cond
(paren
id|pciio_info-&gt;c_slot
op_ne
id|PCIIO_SLOT_NONE
)paren
id|usrpci_device_register
c_func
(paren
id|pconn
comma
id|pciio_info-&gt;c_master
comma
id|pciio_info-&gt;c_slot
)paren
suffix:semicolon
macro_line|#endif
r_return
id|pconn
suffix:semicolon
)brace
r_void
DECL|function|pciio_device_info_unregister
id|pciio_device_info_unregister
c_func
(paren
id|devfs_handle_t
id|connectpt
comma
id|pciio_info_t
id|pciio_info
)paren
(brace
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
id|devfs_handle_t
id|pconn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pciio_info
)paren
r_return
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|name
comma
id|pciio_info-&gt;c_slot
comma
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
id|hwgraph_edge_remove
c_func
(paren
id|connectpt
comma
id|name
comma
op_amp
id|pconn
)paren
suffix:semicolon
id|pciio_info_set
c_func
(paren
id|pconn
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Remove the link to our pci provider */
id|hwgraph_edge_remove
c_func
(paren
id|pconn
comma
id|EDGE_LBL_MASTER
comma
l_int|NULL
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|hwgraph_vertex_destroy
c_func
(paren
id|pconn
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the pci card inventory information to the hwgraph&n; */
r_static
r_void
DECL|function|pciio_device_inventory_add
id|pciio_device_inventory_add
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info-&gt;c_vertex
op_eq
id|pconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* Donot add inventory  for non-existent devices */
r_if
c_cond
(paren
(paren
id|pciio_info-&gt;c_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
op_logical_or
(paren
id|pciio_info-&gt;c_device
op_eq
id|PCIIO_DEVICE_ID_NONE
)paren
)paren
r_return
suffix:semicolon
id|device_inventory_add
c_func
(paren
id|pconn_vhdl
comma
id|INV_IOBD
comma
id|INV_PCIADAP
comma
id|pciio_info-&gt;c_vendor
comma
id|pciio_info-&gt;c_device
comma
id|pciio_info-&gt;c_slot
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_device_attach
id|pciio_device_attach
c_func
(paren
id|devfs_handle_t
id|pconn
comma
r_int
id|drv_flags
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_vendor_id_t
id|vendor_id
suffix:semicolon
id|pciio_device_id_t
id|device_id
suffix:semicolon
id|pciio_device_inventory_add
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|vendor_id
op_assign
id|pciio_info-&gt;c_vendor
suffix:semicolon
id|device_id
op_assign
id|pciio_info-&gt;c_device
suffix:semicolon
multiline_comment|/* we don&squot;t start attaching things until&n;     * all the driver init routines (including&n;     * pciio_init) have been called; so we&n;     * can assume here that we have a registry.&n;     */
id|ASSERT
c_func
(paren
id|pciio_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|cdl_add_connpt
c_func
(paren
id|pciio_registry
comma
id|vendor_id
comma
id|device_id
comma
id|pconn
comma
id|drv_flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|pciio_device_detach
id|pciio_device_detach
c_func
(paren
id|devfs_handle_t
id|pconn
comma
r_int
id|drv_flags
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_vendor_id_t
id|vendor_id
suffix:semicolon
id|pciio_device_id_t
id|device_id
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|vendor_id
op_assign
id|pciio_info-&gt;c_vendor
suffix:semicolon
id|device_id
op_assign
id|pciio_info-&gt;c_device
suffix:semicolon
multiline_comment|/* we don&squot;t start attaching things until&n;     * all the driver init routines (including&n;     * pciio_init) have been called; so we&n;     * can assume here that we have a registry.&n;     */
id|ASSERT
c_func
(paren
id|pciio_registry
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|cdl_del_connpt
c_func
(paren
id|pciio_registry
comma
id|vendor_id
comma
id|device_id
comma
id|pconn
comma
id|drv_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* SN2 */
multiline_comment|/*&n; * Allocate (if necessary) and initialize a PCI window mapping structure.&n; */
id|pciio_win_map_t
DECL|function|pciio_device_win_map_new
id|pciio_device_win_map_new
c_func
(paren
id|pciio_win_map_t
id|win_map
comma
r_int
id|region_size
comma
r_int
id|page_size
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|page_size
op_amp
(paren
id|page_size
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|region_size
op_amp
(paren
id|page_size
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_map
op_eq
l_int|NULL
)paren
id|NEW
c_func
(paren
id|win_map
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The map array tracks the free ``pages&squot;&squot; in the region.  The worst&n;&t; * case scenario is when every other page in the region is free --&n;&t; * e.i. maximum fragmentation.  This leads to (max pages + 1) / 2 + 1&n;&t; * map entries.  The first &quot;+1&quot; handles the divide by 2 rounding; the&n;&t; * second handles the need for an end marker sentinel.&n;&t; */
id|win_map-&gt;wm_map
op_assign
id|rmallocmap
c_func
(paren
(paren
id|region_size
op_div
id|page_size
op_plus
l_int|1
)paren
op_div
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
id|win_map-&gt;wm_page_size
op_assign
id|page_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|win_map-&gt;wm_map
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|win_map
suffix:semicolon
)brace
multiline_comment|/*&n; * Free resources associated with a PCI window mapping structure.&n; */
r_extern
r_void
DECL|function|pciio_device_win_map_free
id|pciio_device_win_map_free
c_func
(paren
id|pciio_win_map_t
id|win_map
)paren
(brace
id|rmfreemap
c_func
(paren
id|win_map-&gt;wm_map
)paren
suffix:semicolon
id|bzero
c_func
(paren
id|win_map
comma
r_sizeof
op_star
id|win_map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Populate window map with specified free range.&n; */
r_void
DECL|function|pciio_device_win_populate
id|pciio_device_win_populate
c_func
(paren
id|pciio_win_map_t
id|win_map
comma
id|iopaddr_t
id|ioaddr
comma
r_int
id|size
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|size
op_amp
(paren
id|win_map-&gt;wm_page_size
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ioaddr
op_amp
(paren
id|win_map-&gt;wm_page_size
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|rmfree
c_func
(paren
id|win_map-&gt;wm_map
comma
id|size
op_div
id|win_map-&gt;wm_page_size
comma
(paren
r_int
r_int
)paren
id|ioaddr
op_div
id|win_map-&gt;wm_page_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space from the specified PCI window mapping resource.  On&n; * success record information about the allocation in the supplied window&n; * allocation cookie (if non-NULL) and return the address of the allocated&n; * window.  On failure return NULL.&n; *&n; * The &quot;size&quot; parameter is usually from a PCI device&squot;s Base Address Register&n; * (BAR) decoder.  As such, the allocation must be aligned to be a multiple of&n; * that.  The &quot;align&quot; parameter acts as a ``minimum alignment&squot;&squot; allocation&n; * constraint.  The alignment contraint reflects system or device addressing&n; * restrictions such as the inability to share higher level ``windows&squot;&squot;&n; * between devices, etc.  The returned PCI address allocation will be a&n; * multiple of the alignment constraint both in alignment and size.  Thus, the&n; * returned PCI address block is aligned to the maximum of the requested size&n; * and alignment.&n; */
id|iopaddr_t
DECL|function|pciio_device_win_alloc
id|pciio_device_win_alloc
c_func
(paren
id|pciio_win_map_t
id|win_map
comma
id|pciio_win_alloc_t
id|win_alloc
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
macro_line|#ifdef PIC_LATER
id|ASSERT
c_func
(paren
(paren
id|size
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|align
op_amp
(paren
id|align
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert size and alignment to pages.  If size is greated than the&n;&t; * requested alignment, we bump the alignment up to size; otherwise&n;&t; * convert the size into a multiple of the alignment request.&n;&t; */
id|size
op_assign
(paren
id|size
op_plus
id|win_map-&gt;wm_page_size
op_minus
l_int|1
)paren
op_div
id|win_map-&gt;wm_page_size
suffix:semicolon
id|align
op_assign
id|align
op_div
id|win_map-&gt;wm_page_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|align
)paren
id|align
op_assign
id|size
suffix:semicolon
r_else
id|size
op_assign
(paren
id|size
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* XXXX */
id|base
op_assign
id|rmalloc_align
c_func
(paren
id|win_map-&gt;wm_map
comma
id|size
comma
id|align
comma
id|VM_NOSLEEP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
id|RMALLOC_FAIL
)paren
r_return
(paren
id|iopaddr_t
)paren
l_int|NULL
suffix:semicolon
macro_line|#else
r_int
id|index_page
comma
id|index_page_align
suffix:semicolon
r_int
id|align_pages
comma
id|size_pages
suffix:semicolon
r_int
id|alloc_pages
comma
id|free_pages
suffix:semicolon
r_int
id|addr_align
suffix:semicolon
multiline_comment|/* Convert PCI bus alignment from bytes to pages */
id|align_pages
op_assign
id|align
op_div
id|win_map-&gt;wm_page_size
suffix:semicolon
multiline_comment|/* Convert PCI request from bytes to pages */
id|size_pages
op_assign
(paren
id|size
op_div
id|win_map-&gt;wm_page_size
)paren
op_plus
(paren
(paren
id|size
op_mod
id|win_map-&gt;wm_page_size
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Align address with the larger of the size or the requested slot align */
r_if
c_cond
(paren
id|size_pages
OG
id|align_pages
)paren
id|align_pages
op_assign
id|size_pages
suffix:semicolon
multiline_comment|/*&n;     * Avoid wasting space by aligning - 1; this will prevent crossing&n;     * another alignment boundary.&n;     */
id|alloc_pages
op_assign
id|size_pages
op_plus
(paren
id|align_pages
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Allocate PCI bus space in pages */
id|index_page
op_assign
(paren
r_int
)paren
id|rmalloc
c_func
(paren
id|win_map-&gt;wm_map
comma
(paren
r_int
)paren
id|alloc_pages
)paren
suffix:semicolon
multiline_comment|/* Error if no PCI bus address space available */
r_if
c_cond
(paren
op_logical_neg
id|index_page
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* PCI bus address index starts at 0 */
id|index_page
op_decrement
suffix:semicolon
multiline_comment|/* Align the page offset as requested */
id|index_page_align
op_assign
(paren
id|index_page
op_plus
(paren
id|align_pages
op_minus
l_int|1
)paren
)paren
op_minus
(paren
(paren
id|index_page
op_plus
(paren
id|align_pages
op_minus
l_int|1
)paren
)paren
op_mod
id|align_pages
)paren
suffix:semicolon
id|free_pages
op_assign
(paren
id|align_pages
op_minus
l_int|1
)paren
op_minus
(paren
id|index_page_align
op_minus
id|index_page
)paren
suffix:semicolon
multiline_comment|/* Free unused PCI bus pages adjusting the index to start at 1 */
id|rmfree
c_func
(paren
id|win_map-&gt;wm_map
comma
id|free_pages
comma
(paren
id|index_page_align
op_plus
l_int|1
)paren
op_plus
id|size_pages
)paren
suffix:semicolon
multiline_comment|/* Return aligned PCI bus space in bytes */
id|addr_align
op_assign
(paren
id|index_page_align
op_star
id|win_map-&gt;wm_page_size
)paren
suffix:semicolon
id|base
op_assign
id|index_page
suffix:semicolon
id|size
op_assign
id|alloc_pages
op_minus
id|free_pages
suffix:semicolon
macro_line|#endif&t;/* PIC_LATER */
multiline_comment|/*&n;&t; * If a window allocation cookie has been supplied, use it to keep&n;&t; * track of all the allocated space assigned to this window.&n;&t; */
r_if
c_cond
(paren
id|win_alloc
)paren
(brace
id|win_alloc-&gt;wa_map
op_assign
id|win_map
suffix:semicolon
id|win_alloc-&gt;wa_base
op_assign
id|base
suffix:semicolon
id|win_alloc-&gt;wa_pages
op_assign
id|size
suffix:semicolon
)brace
r_return
id|base
op_star
id|win_map-&gt;wm_page_size
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the specified window allocation back into the PCI window mapping&n; * resource.  As noted above, we keep page addresses offset by 1 ...&n; */
r_void
DECL|function|pciio_device_win_free
id|pciio_device_win_free
c_func
(paren
id|pciio_win_alloc_t
id|win_alloc
)paren
(brace
r_if
c_cond
(paren
id|win_alloc-&gt;wa_pages
)paren
id|rmfree
c_func
(paren
id|win_alloc-&gt;wa_map-&gt;wm_map
comma
id|win_alloc-&gt;wa_pages
comma
id|win_alloc-&gt;wa_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pciio_error_register:&n; * arrange for a function to be called with&n; * a specified first parameter plus other&n; * information when an error is encountered&n; * and traced to the pci slot corresponding&n; * to the connection point pconn.&n; *&n; * may also be called with a null function&n; * pointer to &quot;unregister&quot; the error handler.&n; *&n; * NOTE: subsequent calls silently overwrite&n; * previous data for this vertex. We assume that&n; * cooperating drivers, well, cooperate ...&n; */
r_void
DECL|function|pciio_error_register
id|pciio_error_register
c_func
(paren
id|devfs_handle_t
id|pconn
comma
id|error_handler_f
op_star
id|efunc
comma
id|error_handler_arg_t
id|einfo
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|pciio_info-&gt;c_efunc
op_assign
id|efunc
suffix:semicolon
id|pciio_info-&gt;c_einfo
op_assign
id|einfo
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if any device has been found in this slot, and return&n; * true or false&n; * vhdl is the vertex for the slot&n; */
r_int
DECL|function|pciio_slot_inuse
id|pciio_slot_inuse
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info-&gt;c_vertex
op_eq
id|pconn_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info-&gt;c_vendor
)paren
(brace
multiline_comment|/*&n;&t; * Non-zero value for vendor indicate&n;&t; * a board being found in this slot.&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pciio_dma_enabled
id|pciio_dma_enabled
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|pconn_vhdl
comma
id|dma_enabled
)paren
(paren
id|pconn_vhdl
)paren
suffix:semicolon
)brace
r_int
DECL|function|pciio_info_type1_get
id|pciio_info_type1_get
c_func
(paren
id|pciio_info_t
id|pci_info
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * These are complementary Linux interfaces that takes in a pci_dev * as the &n; * first arguement instead of devfs_handle_t.&n; */
id|iopaddr_t
id|snia_pciio_dmatrans_addr
c_func
(paren
r_struct
id|pci_dev
op_star
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|pciio_dmamap_t
id|snia_pciio_dmamap_alloc
c_func
(paren
r_struct
id|pci_dev
op_star
comma
id|device_desc_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|snia_pciio_dmamap_free
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|iopaddr_t
id|snia_pciio_dmamap_addr
c_func
(paren
id|pciio_dmamap_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|snia_pciio_dmamap_done
c_func
(paren
id|pciio_dmamap_t
)paren
suffix:semicolon
id|pciio_endian_t
id|snia_pciio_endian_set
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
DECL|variable|snia_pciio_dmatrans_addr
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_dmatrans_addr
)paren
suffix:semicolon
DECL|variable|snia_pciio_dmamap_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_dmamap_alloc
)paren
suffix:semicolon
DECL|variable|snia_pciio_dmamap_free
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_dmamap_free
)paren
suffix:semicolon
DECL|variable|snia_pciio_dmamap_addr
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_dmamap_addr
)paren
suffix:semicolon
DECL|variable|snia_pciio_dmamap_done
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_dmamap_done
)paren
suffix:semicolon
DECL|variable|snia_pciio_endian_set
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pciio_endian_set
)paren
suffix:semicolon
r_int
DECL|function|snia_pcibr_rrb_alloc
id|snia_pcibr_rrb_alloc
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
)paren
(brace
id|devfs_handle_t
id|dev
op_assign
id|PCIDEV_VERTEX
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
r_return
id|pcibr_rrb_alloc
c_func
(paren
id|dev
comma
id|count_vchan0
comma
id|count_vchan1
)paren
suffix:semicolon
)brace
DECL|variable|snia_pcibr_rrb_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|snia_pcibr_rrb_alloc
)paren
suffix:semicolon
id|pciio_endian_t
DECL|function|snia_pciio_endian_set
id|snia_pciio_endian_set
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
(brace
id|devfs_handle_t
id|dev
op_assign
id|PCIDEV_VERTEX
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|endian_set
)paren
(paren
id|dev
comma
id|device_end
comma
id|desired_end
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|snia_pciio_dmatrans_addr
id|snia_pciio_dmatrans_addr
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
id|devfs_handle_t
id|dev
op_assign
id|PCIDEV_VERTEX
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the device is not a PIC, we always want the PCIIO_BYTE_STREAM to be &n;     * set.  Otherwise, it must not be set.  This applies to SN1 and SN2.&n;     */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|pci_dev
)paren
)paren
ques
c_cond
(paren
id|flags
op_amp
op_complement
id|PCIIO_BYTE_STREAM
)paren
suffix:colon
id|flags
op_or
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
)brace
id|pciio_dmamap_t
DECL|function|snia_pciio_dmamap_alloc
id|snia_pciio_dmamap_alloc
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
id|devfs_handle_t
id|dev
op_assign
id|PCIDEV_VERTEX
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the device is not a PIC, we always want the PCIIO_BYTE_STREAM to be&n;     * set.  Otherwise, it must not be set.  This applies to SN1 and SN2.&n;     */
r_return
(paren
id|pciio_dmamap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmamap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count_max
comma
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|pci_dev
)paren
)paren
ques
c_cond
(paren
id|flags
op_amp
op_complement
id|PCIIO_BYTE_STREAM
)paren
suffix:colon
id|flags
op_or
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
)brace
r_void
DECL|function|snia_pciio_dmamap_free
id|snia_pciio_dmamap_free
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_free
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|snia_pciio_dmamap_addr
id|snia_pciio_dmamap_addr
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
r_return
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_addr
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
r_void
DECL|function|snia_pciio_dmamap_done
id|snia_pciio_dmamap_done
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_done
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
eof
