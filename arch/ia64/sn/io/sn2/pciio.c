multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
DECL|variable|pciio_info_fingerprint
r_char
id|pciio_info_fingerprint
(braket
)braket
op_assign
l_string|&quot;pciio_info&quot;
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    PCI Generic Bus Provider&n; * Implement PCI provider operations.  The pciio* layer provides a&n; * platform-independent interface for PCI devices.  This layer&n; * switches among the possible implementations of a PCI adapter.&n; */
multiline_comment|/* =====================================================================&n; *    Provider Function Location&n; *&n; *      If there is more than one possible provider for&n; *      this platform, we need to examine the master&n; *      vertex of the current vertex for a provider&n; *      function structure, and indirect through the&n; *      appropriately named member.&n; */
id|pciio_provider_t
op_star
DECL|function|pciio_to_provider_fns
id|pciio_to_provider_fns
c_func
(paren
id|vertex_hdl_t
id|dev
)paren
(brace
id|pciio_info_t
id|card_info
suffix:semicolon
id|pciio_provider_t
op_star
id|provider_fns
suffix:semicolon
multiline_comment|/*&n;     * We&squot;re called with two types of vertices, one is&n;     * the bridge vertex (ends with &quot;pci&quot;) and the other is the&n;     * pci slot vertex (ends with &quot;pci/[0-8]&quot;).  For the first type&n;     * we need to get the provider from the PFUNCS label.  For&n;     * the second we get it from fastinfo/c_pops.&n;     */
id|provider_fns
op_assign
id|pciio_provider_fns_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|provider_fns
op_eq
l_int|NULL
)paren
(brace
id|card_info
op_assign
id|pciio_info_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card_info
op_ne
l_int|NULL
)paren
(brace
id|provider_fns
op_assign
id|pciio_info_pops_get
c_func
(paren
id|card_info
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|provider_fns
op_eq
l_int|NULL
)paren
(brace
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;%s: provider_fns == NULL&quot;
comma
id|vertex_to_name
c_func
(paren
id|dev
comma
id|devname
comma
id|MAXDEVNAME
)paren
)paren
suffix:semicolon
)brace
r_return
id|provider_fns
suffix:semicolon
)brace
DECL|macro|DEV_FUNC
mdefine_line|#define DEV_FUNC(dev,func)&t;pciio_to_provider_fns(dev)-&gt;func
DECL|macro|CAST_PIOMAP
mdefine_line|#define CAST_PIOMAP(x)&t;&t;((pciio_piomap_t)(x))
DECL|macro|CAST_DMAMAP
mdefine_line|#define CAST_DMAMAP(x)&t;&t;((pciio_dmamap_t)(x))
DECL|macro|CAST_INTR
mdefine_line|#define CAST_INTR(x)&t;&t;((pciio_intr_t)(x))
multiline_comment|/*&n; * Many functions are not passed their vertex&n; * information directly; rather, they must&n; * dive through a resource map. These macros&n; * are available to coordinate this detail.&n; */
DECL|macro|PIOMAP_FUNC
mdefine_line|#define PIOMAP_FUNC(map,func)&t;&t;DEV_FUNC((map)-&gt;pp_dev,func)
DECL|macro|DMAMAP_FUNC
mdefine_line|#define DMAMAP_FUNC(map,func)&t;&t;DEV_FUNC((map)-&gt;pd_dev,func)
DECL|macro|INTR_FUNC
mdefine_line|#define INTR_FUNC(intr_hdl,func)&t;DEV_FUNC((intr_hdl)-&gt;pi_dev,func)
multiline_comment|/* =====================================================================&n; *          PIO MANAGEMENT&n; *&n; *      For mapping system virtual address space to&n; *      pciio space on a specified card&n; */
id|pciio_piomap_t
DECL|function|pciio_piomap_alloc
id|pciio_piomap_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* set up mapping for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* lowest address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* size of region containing our mappings */
r_int
id|byte_count_max
comma
multiline_comment|/* maximum size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in sys/pio.h */
r_return
(paren
id|pciio_piomap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piomap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_piomap_free
id|pciio_piomap_free
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_free
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_piomap_addr
id|pciio_piomap_addr
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
comma
multiline_comment|/* mapping resources */
id|iopaddr_t
id|pciio_addr
comma
multiline_comment|/* map for this pciio address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
id|pciio_piomap-&gt;pp_kvaddr
op_assign
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_addr
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
comma
id|pciio_addr
comma
id|byte_count
)paren
suffix:semicolon
r_return
id|pciio_piomap-&gt;pp_kvaddr
suffix:semicolon
)brace
r_void
DECL|function|pciio_piomap_done
id|pciio_piomap_done
c_func
(paren
id|pciio_piomap_t
id|pciio_piomap
)paren
(brace
id|PIOMAP_FUNC
c_func
(paren
id|pciio_piomap
comma
id|piomap_done
)paren
(paren
id|CAST_PIOMAP
c_func
(paren
id|pciio_piomap
)paren
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_piotrans_addr
id|pciio_piotrans_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* starting address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
r_int
id|flags
)paren
(brace
multiline_comment|/* (currently unused) */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piotrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|caddr_t
DECL|function|pciio_pio_addr
id|pciio_pio_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* CFG, MEM, IO, or a device-decoded window */
id|iopaddr_t
id|addr
comma
multiline_comment|/* starting address (or offset in window) */
r_int
id|byte_count
comma
multiline_comment|/* map this many bytes */
id|pciio_piomap_t
op_star
id|mapp
comma
multiline_comment|/* where to return the map pointer */
r_int
id|flags
)paren
(brace
multiline_comment|/* PIO flags */
id|pciio_piomap_t
id|map
op_assign
l_int|0
suffix:semicolon
r_int
id|errfree
op_assign
l_int|0
suffix:semicolon
id|caddr_t
id|res
suffix:semicolon
r_if
c_cond
(paren
id|mapp
)paren
(brace
id|map
op_assign
op_star
id|mapp
suffix:semicolon
multiline_comment|/* possible pre-allocated map */
op_star
id|mapp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* record &quot;no map used&quot; */
)brace
id|res
op_assign
id|pciio_piotrans_addr
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piotrans worked */
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|map
op_assign
id|pciio_piomap_alloc
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|addr
comma
id|byte_count
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_alloc failed */
id|errfree
op_assign
l_int|1
suffix:semicolon
)brace
id|res
op_assign
id|pciio_piomap_addr
(paren
id|map
comma
id|addr
comma
id|byte_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|errfree
)paren
id|pciio_piomap_free
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_addr failed */
)brace
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
id|map
suffix:semicolon
multiline_comment|/* pass back map used */
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_piomap_addr succeeded */
)brace
id|iopaddr_t
DECL|function|pciio_piospace_alloc
id|pciio_piospace_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* Device requiring space */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* Device descriptor */
id|pciio_space_t
id|space
comma
multiline_comment|/* MEM32/MEM64/IO */
r_int
id|byte_count
comma
multiline_comment|/* Size of mapping */
r_int
id|align
)paren
(brace
multiline_comment|/* Alignment needed */
r_if
c_cond
(paren
id|align
OL
id|PAGE_SIZE
)paren
id|align
op_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piospace_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|space
comma
id|byte_count
comma
id|align
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_piospace_free
id|pciio_piospace_free
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* Device freeing space */
id|pciio_space_t
id|space
comma
multiline_comment|/* Type of space        */
id|iopaddr_t
id|pciaddr
comma
multiline_comment|/* starting address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* Range of address   */
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|piospace_free
)paren
(paren
id|dev
comma
id|space
comma
id|pciaddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          DMA MANAGEMENT&n; *&n; *      For mapping from pci space to system&n; *      physical space.&n; */
id|pciio_dmamap_t
DECL|function|pciio_dmamap_alloc
id|pciio_dmamap_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* set up mappings for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
r_int
id|byte_count_max
comma
multiline_comment|/* max size of a mapping */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
(paren
id|pciio_dmamap_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmamap_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count_max
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmamap_free
id|pciio_dmamap_free
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_free
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dmamap_addr
id|pciio_dmamap_addr
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
comma
multiline_comment|/* use these mapping resources */
id|paddr_t
id|paddr
comma
multiline_comment|/* map for this address */
r_int
id|byte_count
)paren
(brace
multiline_comment|/* map this many bytes */
r_return
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_addr
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmamap_done
id|pciio_dmamap_done
c_func
(paren
id|pciio_dmamap_t
id|pciio_dmamap
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|pciio_dmamap
comma
id|dmamap_done
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|pciio_dmamap
)paren
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dmatrans_addr
id|pciio_dmatrans_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
r_int
id|flags
)paren
(brace
multiline_comment|/* defined in dma.h */
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmatrans_addr
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pciio_dma_addr
id|pciio_dma_addr
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* translate for this device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|paddr_t
id|paddr
comma
multiline_comment|/* system physical address */
r_int
id|byte_count
comma
multiline_comment|/* length */
id|pciio_dmamap_t
op_star
id|mapp
comma
multiline_comment|/* map to use, then map we used */
r_int
id|flags
)paren
(brace
multiline_comment|/* PIO flags */
id|pciio_dmamap_t
id|map
op_assign
l_int|0
suffix:semicolon
r_int
id|errfree
op_assign
l_int|0
suffix:semicolon
id|iopaddr_t
id|res
suffix:semicolon
r_if
c_cond
(paren
id|mapp
)paren
(brace
id|map
op_assign
op_star
id|mapp
suffix:semicolon
multiline_comment|/* possible pre-allocated map */
op_star
id|mapp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* record &quot;no map used&quot; */
)brace
id|res
op_assign
id|pciio_dmatrans_addr
(paren
id|dev
comma
id|dev_desc
comma
id|paddr
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmatrans worked */
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|map
op_assign
id|pciio_dmamap_alloc
(paren
id|dev
comma
id|dev_desc
comma
id|byte_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_alloc failed */
id|errfree
op_assign
l_int|1
suffix:semicolon
)brace
id|res
op_assign
id|pciio_dmamap_addr
(paren
id|map
comma
id|paddr
comma
id|byte_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|errfree
)paren
id|pciio_dmamap_free
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_addr failed */
)brace
r_if
c_cond
(paren
id|mapp
)paren
op_star
id|mapp
op_assign
id|map
suffix:semicolon
multiline_comment|/* pass back map used */
r_return
id|res
suffix:semicolon
multiline_comment|/* pciio_dmamap_addr succeeded */
)brace
r_void
DECL|function|pciio_dmamap_drain
id|pciio_dmamap_drain
c_func
(paren
id|pciio_dmamap_t
id|map
)paren
(brace
id|DMAMAP_FUNC
c_func
(paren
id|map
comma
id|dmamap_drain
)paren
(paren
id|CAST_DMAMAP
c_func
(paren
id|map
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmaaddr_drain
id|pciio_dmaaddr_drain
c_func
(paren
id|vertex_hdl_t
id|dev
comma
id|paddr_t
id|addr
comma
r_int
id|size
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmaaddr_drain
)paren
(paren
id|dev
comma
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_dmalist_drain
id|pciio_dmalist_drain
c_func
(paren
id|vertex_hdl_t
id|dev
comma
id|alenlist_t
id|list
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|dmalist_drain
)paren
(paren
id|dev
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          INTERRUPT MANAGEMENT&n; *&n; *      Allow crosstalk devices to establish interrupts&n; */
multiline_comment|/*&n; * Allocate resources required for an interrupt as specified in intr_desc.&n; * Return resource handle in intr_hdl.&n; */
id|pciio_intr_t
DECL|function|pciio_intr_alloc
id|pciio_intr_alloc
c_func
(paren
id|vertex_hdl_t
id|dev
comma
multiline_comment|/* which Crosstalk device */
id|device_desc_t
id|dev_desc
comma
multiline_comment|/* device descriptor */
id|pciio_intr_line_t
id|lines
comma
multiline_comment|/* INTR line(s) to attach */
id|vertex_hdl_t
id|owner_dev
)paren
(brace
multiline_comment|/* owner of this interrupt */
r_return
(paren
id|pciio_intr_t
)paren
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|intr_alloc
)paren
(paren
id|dev
comma
id|dev_desc
comma
id|lines
comma
id|owner_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free resources consumed by intr_alloc.&n; */
r_void
DECL|function|pciio_intr_free
id|pciio_intr_free
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_free
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate resources allocated with a previous pciio_intr_alloc call with the&n; * described handler, arg, name, etc.&n; *&n; * Returns 0 on success, returns &lt;0 on failure.&n; */
r_int
DECL|function|pciio_intr_connect
id|pciio_intr_connect
c_func
(paren
id|pciio_intr_t
id|intr_hdl
comma
id|intr_func_t
id|intr_func
comma
id|intr_arg_t
id|intr_arg
)paren
multiline_comment|/* pciio intr resource handle */
(brace
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_connect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
comma
id|intr_func
comma
id|intr_arg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate handler with the specified interrupt.&n; */
r_void
DECL|function|pciio_intr_disconnect
id|pciio_intr_disconnect
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_disconnect
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a hwgraph vertex that represents the CPU currently&n; * targeted by an interrupt.&n; */
id|vertex_hdl_t
DECL|function|pciio_intr_cpu_get
id|pciio_intr_cpu_get
c_func
(paren
id|pciio_intr_t
id|intr_hdl
)paren
(brace
r_return
id|INTR_FUNC
c_func
(paren
id|intr_hdl
comma
id|intr_cpu_get
)paren
(paren
id|CAST_INTR
c_func
(paren
id|intr_hdl
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciio_slot_func_to_name
id|pciio_slot_func_to_name
c_func
(paren
r_char
op_star
id|name
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|func
)paren
(brace
multiline_comment|/*&n;     * standard connection points:&n;     *&n;     * PCIIO_SLOT_NONE:&t;.../pci/direct&n;     * PCIIO_FUNC_NONE: .../pci/&lt;SLOT&gt;&t;&t;&t;ie. .../pci/3&n;     * multifunction:   .../pci/&lt;SLOT&gt;&lt;FUNC&gt;&t;&t;ie. .../pci/3c&n;     */
r_if
c_cond
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
id|sprintf
c_func
(paren
id|name
comma
id|EDGE_LBL_DIRECT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|func
op_eq
id|PCIIO_FUNC_NONE
)paren
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d%c&quot;
comma
id|slot
comma
l_char|&squot;a&squot;
op_plus
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pciio_cardinfo_get&n; *&n; * Get the pciio info structure corresponding to the&n; * specified PCI &quot;slot&quot; (we like it when the same index&n; * number is used for the PCI IDSEL, the REQ/GNT pair,&n; * and the interrupt line being used for INTA. We like&n; * it so much we call it the slot number).&n; */
r_static
id|pciio_info_t
DECL|function|pciio_cardinfo_get
id|pciio_cardinfo_get
c_func
(paren
id|vertex_hdl_t
id|pciio_vhdl
comma
id|pciio_slot_t
id|pci_slot
)paren
(brace
r_char
id|namebuf
(braket
l_int|16
)braket
suffix:semicolon
id|pciio_info_t
id|info
op_assign
l_int|0
suffix:semicolon
id|vertex_hdl_t
id|conn
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|namebuf
comma
id|pci_slot
comma
id|PCIIO_FUNC_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_traverse
c_func
(paren
id|pciio_vhdl
comma
id|namebuf
comma
op_amp
id|conn
)paren
)paren
(brace
id|info
op_assign
id|pciio_info_chk
c_func
(paren
id|conn
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
suffix:semicolon
)brace
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/*&n; * pciio_error_handler:&n; * dispatch an error to the appropriate&n; * pciio connection point, or process&n; * it as a generic pci error.&n; * Yes, the first parameter is the&n; * provider vertex at the middle of&n; * the bus; we get to the pciio connect&n; * point using the ioerror widgetdev field.&n; *&n; * This function is called by the&n; * specific PCI provider, after it has figured&n; * out where on the PCI bus (including which slot,&n; * if it can tell) the error came from.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_error_handler
id|pciio_error_handler
c_func
(paren
id|vertex_hdl_t
id|pciio_vhdl
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioerror
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|vertex_hdl_t
id|pconn_vhdl
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|retval
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pciio_error_handler&bslash;n&quot;
comma
id|pciio_vhdl
)paren
suffix:semicolon
macro_line|#endif
id|IOERR_PRINTF
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%v: PCI Bus Error: Error code: %d Error mode: %d&bslash;n&quot;
comma
id|pciio_vhdl
comma
id|error_code
comma
id|mode
)paren
)paren
suffix:semicolon
multiline_comment|/* If there is an error handler sitting on&n;     * the &quot;no-slot&quot; connection point, give it&n;     * first crack at the error. NOTE: it is&n;     * quite possible that this function may&n;     * do further refining of the ioerror.&n;     */
id|pciio_info
op_assign
id|pciio_cardinfo_get
c_func
(paren
id|pciio_vhdl
comma
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
op_logical_and
id|pciio_info-&gt;c_efunc
)paren
(brace
id|pconn_vhdl
op_assign
id|pciio_info_dev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|retval
op_assign
id|pciio_info-&gt;c_efunc
(paren
id|pciio_info-&gt;c_einfo
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_UNHANDLED
)paren
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Is the error associated with a particular slot?&n;     */
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioerror
comma
id|widgetdev
)paren
)paren
(brace
r_int
id|widgetdev
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE : &n;&t; * widgetdev is a 4byte value encoded as slot in the higher order&n;&t; * 2 bytes and function in the lower order 2 bytes.&n;&t; */
id|IOERROR_GETVALUE
c_func
(paren
id|widgetdev
comma
id|ioerror
comma
id|widgetdev
)paren
suffix:semicolon
id|slot
op_assign
id|pciio_widgetdev_slot_get
c_func
(paren
id|widgetdev
)paren
suffix:semicolon
multiline_comment|/* If this slot has an error handler,&n;&t; * deliver the error to it.&n;&t; */
id|pciio_info
op_assign
id|pciio_cardinfo_get
c_func
(paren
id|pciio_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pciio_info-&gt;c_efunc
op_ne
l_int|NULL
)paren
(brace
id|pconn_vhdl
op_assign
id|pciio_info_dev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|retval
op_assign
id|pciio_info-&gt;c_efunc
(paren
id|pciio_info-&gt;c_einfo
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_UNHANDLED
)paren
r_return
id|retval
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
ques
c_cond
id|IOERROR_HANDLED
multiline_comment|/* probes are OK */
suffix:colon
id|IOERROR_UNHANDLED
suffix:semicolon
multiline_comment|/* otherwise, foo! */
)brace
multiline_comment|/* =====================================================================&n; *          CONFIGURATION MANAGEMENT&n; */
multiline_comment|/*&n; * Startup a crosstalk provider&n; */
r_void
DECL|function|pciio_provider_startup
id|pciio_provider_startup
c_func
(paren
id|vertex_hdl_t
id|pciio_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|pciio_provider
comma
id|provider_startup
)paren
(paren
id|pciio_provider
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shutdown a crosstalk provider&n; */
r_void
DECL|function|pciio_provider_shutdown
id|pciio_provider_shutdown
c_func
(paren
id|vertex_hdl_t
id|pciio_provider
)paren
(brace
id|DEV_FUNC
c_func
(paren
id|pciio_provider
comma
id|provider_shutdown
)paren
(paren
id|pciio_provider
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read value of configuration register&n; */
r_uint64
DECL|function|pciio_config_get
id|pciio_config_get
c_func
(paren
id|vertex_hdl_t
id|dev
comma
r_int
id|reg
comma
r_int
id|size
)paren
(brace
r_uint64
id|value
op_assign
l_int|0
suffix:semicolon
r_int
id|shift
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* handle accesses that cross words here,&n;     * since that&squot;s common code between all&n;     * possible providers.&n;     */
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|biw
op_assign
l_int|4
op_minus
(paren
id|reg
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|biw
OG
id|size
)paren
id|biw
op_assign
id|size
suffix:semicolon
id|value
op_or_assign
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|config_get
)paren
(paren
id|dev
comma
id|reg
comma
id|biw
)paren
op_lshift
id|shift
suffix:semicolon
id|shift
op_add_assign
l_int|8
op_star
id|biw
suffix:semicolon
id|reg
op_add_assign
id|biw
suffix:semicolon
id|size
op_sub_assign
id|biw
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/*&n; * Change value of configuration register&n; */
r_void
DECL|function|pciio_config_set
id|pciio_config_set
c_func
(paren
id|vertex_hdl_t
id|dev
comma
r_int
id|reg
comma
r_int
id|size
comma
r_uint64
id|value
)paren
(brace
multiline_comment|/* handle accesses that cross words here,&n;     * since that&squot;s common code between all&n;     * possible providers.&n;     */
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|biw
op_assign
l_int|4
op_minus
(paren
id|reg
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|biw
OG
id|size
)paren
id|biw
op_assign
id|size
suffix:semicolon
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|config_set
)paren
(paren
id|dev
comma
id|reg
comma
id|biw
comma
id|value
)paren
suffix:semicolon
id|reg
op_add_assign
id|biw
suffix:semicolon
id|size
op_sub_assign
id|biw
suffix:semicolon
id|value
op_rshift_assign
id|biw
op_star
l_int|8
suffix:semicolon
)brace
)brace
multiline_comment|/* =====================================================================&n; *          GENERIC PCI SUPPORT FUNCTIONS&n; */
multiline_comment|/*&n; * Issue a hardware reset to a card.&n; */
r_int
DECL|function|pciio_reset
id|pciio_reset
c_func
(paren
id|vertex_hdl_t
id|dev
)paren
(brace
r_return
id|DEV_FUNC
c_func
(paren
id|dev
comma
id|reset
)paren
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/****** Generic pci slot information interfaces ******/
id|pciio_info_t
DECL|function|pciio_info_chk
id|pciio_info_chk
c_func
(paren
id|vertex_hdl_t
id|pciio
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
id|hwgraph_info_get_LBL
c_func
(paren
id|pciio
comma
id|INFO_LBL_PCIIO
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_return
(paren
id|pciio_info_t
)paren
id|ainfo
suffix:semicolon
)brace
id|pciio_info_t
DECL|function|pciio_info_get
id|pciio_info_get
c_func
(paren
id|vertex_hdl_t
id|pciio
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_info
op_assign
(paren
id|pciio_info_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|pciio
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|pciio_info-&gt;c_fingerprint
op_ne
id|pciio_info_fingerprint
)paren
op_logical_and
(paren
id|pciio_info-&gt;c_fingerprint
op_ne
l_int|NULL
)paren
)paren
(brace
r_return
(paren
id|pciio_info_t
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Should panic .. */
)brace
r_return
id|pciio_info
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a vertex_hdl_t, return the pciio_info_t from the host device - that&n; * is, the device plugged into the slot on the host bus.&n; */
id|pciio_info_t
DECL|function|pciio_hostinfo_get
id|pciio_hostinfo_get
c_func
(paren
id|vertex_hdl_t
id|pciio
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pciio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
op_logical_and
(paren
id|pciio_info-&gt;c_vertex
op_ne
id|pciio_info-&gt;c_hostvertex
)paren
)paren
(brace
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pciio_info-&gt;c_hostvertex
)paren
suffix:semicolon
)brace
r_return
id|pciio_info
suffix:semicolon
)brace
r_void
DECL|function|pciio_info_set
id|pciio_info_set
c_func
(paren
id|vertex_hdl_t
id|pciio
comma
id|pciio_info_t
id|pciio_info
)paren
(brace
r_if
c_cond
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
id|pciio_info-&gt;c_fingerprint
op_assign
id|pciio_info_fingerprint
suffix:semicolon
id|hwgraph_fastinfo_set
c_func
(paren
id|pciio
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_info
)paren
suffix:semicolon
multiline_comment|/* Also, mark this vertex as a PCI slot&n;     * and use the pciio_info, so pciio_info_chk&n;     * can work (and be fairly efficient).&n;     */
id|hwgraph_info_add_LBL
c_func
(paren
id|pciio
comma
id|INFO_LBL_PCIIO
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_info
)paren
suffix:semicolon
)brace
id|vertex_hdl_t
DECL|function|pciio_info_dev_get
id|pciio_info_dev_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_vertex
)paren
suffix:semicolon
)brace
id|vertex_hdl_t
DECL|function|pciio_info_hostdev_get
id|pciio_info_hostdev_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_hostvertex
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
id|pciio_bus_t
DECL|function|pciio_info_bus_get
id|pciio_info_bus_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_bus
)paren
suffix:semicolon
)brace
id|pciio_slot_t
DECL|function|pciio_info_slot_get
id|pciio_info_slot_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_slot
)paren
suffix:semicolon
)brace
id|pciio_slot_t
DECL|function|pciio_info_hostslot_get
id|pciio_info_hostslot_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
id|vertex_hdl_t
id|host_vhdl
op_assign
id|pciio_info_hostdev_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_info_t
id|host_info
op_assign
id|pciio_info_get
c_func
(paren
id|host_vhdl
)paren
suffix:semicolon
r_return
(paren
id|pciio_info_slot_get
c_func
(paren
id|host_info
)paren
)paren
suffix:semicolon
)brace
id|pciio_function_t
DECL|function|pciio_info_function_get
id|pciio_info_function_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
)brace
id|pciio_vendor_id_t
DECL|function|pciio_info_vendor_id_get
id|pciio_info_vendor_id_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_vendor
)paren
suffix:semicolon
)brace
id|pciio_device_id_t
DECL|function|pciio_info_device_id_get
id|pciio_info_device_id_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_device
)paren
suffix:semicolon
)brace
id|vertex_hdl_t
DECL|function|pciio_info_master_get
id|pciio_info_master_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_master
)paren
suffix:semicolon
)brace
id|arbitrary_info_t
DECL|function|pciio_info_mfast_get
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_mfast
)paren
suffix:semicolon
)brace
id|pciio_provider_t
op_star
DECL|function|pciio_info_pops_get
id|pciio_info_pops_get
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
r_return
(paren
id|pciio_info-&gt;c_pops
)paren
suffix:semicolon
)brace
r_int
DECL|function|pciio_businfo_multi_master_get
id|pciio_businfo_multi_master_get
c_func
(paren
id|pciio_businfo_t
id|businfo
)paren
(brace
r_return
id|businfo-&gt;bi_multi_master
suffix:semicolon
)brace
id|pciio_asic_type_t
DECL|function|pciio_businfo_asic_type_get
id|pciio_businfo_asic_type_get
c_func
(paren
id|pciio_businfo_t
id|businfo
)paren
(brace
r_return
id|businfo-&gt;bi_asic_type
suffix:semicolon
)brace
id|pciio_bus_type_t
DECL|function|pciio_businfo_bus_type_get
id|pciio_businfo_bus_type_get
c_func
(paren
id|pciio_businfo_t
id|businfo
)paren
(brace
r_return
id|businfo-&gt;bi_bus_type
suffix:semicolon
)brace
id|pciio_bus_speed_t
DECL|function|pciio_businfo_bus_speed_get
id|pciio_businfo_bus_speed_get
c_func
(paren
id|pciio_businfo_t
id|businfo
)paren
(brace
r_return
id|businfo-&gt;bi_bus_speed
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *          GENERIC PCI INITIALIZATION FUNCTIONS&n; */
multiline_comment|/*&n; *    pciioattach: called for each vertex in the graph&n; *      that is a PCI provider.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_attach
id|pciio_attach
c_func
(paren
id|vertex_hdl_t
id|pciio
)paren
(brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: pciio_attach&bslash;n&quot;
comma
id|vertex_to_name
c_func
(paren
id|pciio
comma
id|devname
comma
id|MAXDEVNAME
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Associate a set of pciio_provider functions with a vertex.&n; */
r_void
DECL|function|pciio_provider_register
id|pciio_provider_register
c_func
(paren
id|vertex_hdl_t
id|provider
comma
id|pciio_provider_t
op_star
id|pciio_fns
)paren
(brace
id|hwgraph_info_add_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
(paren
id|arbitrary_info_t
)paren
id|pciio_fns
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disassociate a set of pciio_provider functions with a vertex.&n; */
r_void
DECL|function|pciio_provider_unregister
id|pciio_provider_unregister
c_func
(paren
id|vertex_hdl_t
id|provider
)paren
(brace
id|arbitrary_info_t
id|ainfo
suffix:semicolon
id|hwgraph_info_remove_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
(paren
r_int
op_star
)paren
op_amp
id|ainfo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain a pointer to the pciio_provider functions for a specified Crosstalk&n; * provider.&n; */
id|pciio_provider_t
op_star
DECL|function|pciio_provider_fns_get
id|pciio_provider_fns_get
c_func
(paren
id|vertex_hdl_t
id|provider
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_info_get_LBL
c_func
(paren
id|provider
comma
id|INFO_LBL_PFUNCS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_return
(paren
id|pciio_provider_t
op_star
)paren
id|ainfo
suffix:semicolon
)brace
id|pciio_info_t
DECL|function|pciio_device_info_new
id|pciio_device_info_new
c_func
(paren
id|pciio_info_t
id|pciio_info
comma
id|vertex_hdl_t
id|master
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|func
comma
id|pciio_vendor_id_t
id|vendor_id
comma
id|pciio_device_id_t
id|device_id
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pciio_info
)paren
(brace
id|pciio_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pciio_info
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
)paren
id|memset
c_func
(paren
id|pciio_info
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pciio_info
)paren
)paren
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|pciio_info-&gt;c_slot
op_assign
id|slot
suffix:semicolon
id|pciio_info-&gt;c_func
op_assign
id|func
suffix:semicolon
id|pciio_info-&gt;c_vendor
op_assign
id|vendor_id
suffix:semicolon
id|pciio_info-&gt;c_device
op_assign
id|device_id
suffix:semicolon
id|pciio_info-&gt;c_master
op_assign
id|master
suffix:semicolon
id|pciio_info-&gt;c_mfast
op_assign
id|hwgraph_fastinfo_get
c_func
(paren
id|master
)paren
suffix:semicolon
id|pciio_info-&gt;c_pops
op_assign
id|pciio_provider_fns_get
c_func
(paren
id|master
)paren
suffix:semicolon
id|pciio_info-&gt;c_efunc
op_assign
l_int|0
suffix:semicolon
id|pciio_info-&gt;c_einfo
op_assign
l_int|0
suffix:semicolon
r_return
id|pciio_info
suffix:semicolon
)brace
r_void
DECL|function|pciio_device_info_free
id|pciio_device_info_free
c_func
(paren
id|pciio_info_t
id|pciio_info
)paren
(brace
multiline_comment|/* NOTE : pciio_info is a structure within the pcibr_info&n;     *&t;      and not a pointer to memory allocated on the heap !!&n;     */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|pciio_info
comma
l_int|0
comma
r_sizeof
(paren
id|pciio_info
)paren
)paren
suffix:semicolon
)brace
id|vertex_hdl_t
DECL|function|pciio_device_info_register
id|pciio_device_info_register
c_func
(paren
id|vertex_hdl_t
id|connectpt
comma
multiline_comment|/* vertex at center of bus */
id|pciio_info_t
id|pciio_info
)paren
multiline_comment|/* details about the connectpt */
(brace
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
id|vertex_hdl_t
id|pconn
suffix:semicolon
r_int
id|device_master_set
c_func
(paren
id|vertex_hdl_t
comma
id|vertex_hdl_t
)paren
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|name
comma
id|pciio_info-&gt;c_slot
comma
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_path_add
c_func
(paren
id|connectpt
comma
id|name
comma
op_amp
id|pconn
)paren
)paren
r_return
id|pconn
suffix:semicolon
id|pciio_info-&gt;c_vertex
op_assign
id|pconn
suffix:semicolon
id|pciio_info_set
c_func
(paren
id|pconn
comma
id|pciio_info
)paren
suffix:semicolon
multiline_comment|/*&n;     * create link to our pci provider&n;     */
id|device_master_set
c_func
(paren
id|pconn
comma
id|pciio_info-&gt;c_master
)paren
suffix:semicolon
r_return
id|pconn
suffix:semicolon
)brace
r_void
DECL|function|pciio_device_info_unregister
id|pciio_device_info_unregister
c_func
(paren
id|vertex_hdl_t
id|connectpt
comma
id|pciio_info_t
id|pciio_info
)paren
(brace
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
id|vertex_hdl_t
id|pconn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pciio_info
)paren
r_return
suffix:semicolon
id|pciio_slot_func_to_name
c_func
(paren
id|name
comma
id|pciio_info-&gt;c_slot
comma
id|pciio_info-&gt;c_func
)paren
suffix:semicolon
id|hwgraph_edge_remove
c_func
(paren
id|connectpt
comma
id|name
comma
op_amp
id|pconn
)paren
suffix:semicolon
id|pciio_info_set
c_func
(paren
id|pconn
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Remove the link to our pci provider */
id|hwgraph_edge_remove
c_func
(paren
id|pconn
comma
id|EDGE_LBL_MASTER
comma
l_int|NULL
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|hwgraph_vertex_destroy
c_func
(paren
id|pconn
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciio_device_attach
id|pciio_device_attach
c_func
(paren
id|vertex_hdl_t
id|pconn
comma
r_int
id|drv_flags
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_vendor_id_t
id|vendor_id
suffix:semicolon
id|pciio_device_id_t
id|device_id
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|vendor_id
op_assign
id|pciio_info-&gt;c_vendor
suffix:semicolon
id|device_id
op_assign
id|pciio_info-&gt;c_device
suffix:semicolon
multiline_comment|/* we don&squot;t start attaching things until&n;     * all the driver init routines (including&n;     * pciio_init) have been called; so we&n;     * can assume here that we have a registry.&n;     */
r_return
id|cdl_add_connpt
c_func
(paren
id|vendor_id
comma
id|device_id
comma
id|pconn
comma
id|drv_flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|pciio_device_detach
id|pciio_device_detach
c_func
(paren
id|vertex_hdl_t
id|pconn
comma
r_int
id|drv_flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space from the specified PCI window mapping resource.  On&n; * success record information about the allocation in the supplied window&n; * allocation cookie (if non-NULL) and return the address of the allocated&n; * window.  On failure return NULL.&n; *&n; * The &quot;size&quot; parameter is usually from a PCI device&squot;s Base Address Register&n; * (BAR) decoder.  As such, the allocation must be aligned to be a multiple of&n; * that.  The &quot;align&quot; parameter acts as a ``minimum alignment&squot;&squot; allocation&n; * constraint.  The alignment contraint reflects system or device addressing&n; * restrictions such as the inability to share higher level ``windows&squot;&squot;&n; * between devices, etc.  The returned PCI address allocation will be a&n; * multiple of the alignment constraint both in alignment and size.  Thus, the&n; * returned PCI address block is aligned to the maximum of the requested size&n; * and alignment.&n; */
id|iopaddr_t
DECL|function|pciio_device_win_alloc
id|pciio_device_win_alloc
c_func
(paren
r_struct
id|resource
op_star
id|root_resource
comma
id|pciio_win_alloc_t
id|win_alloc
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_struct
id|resource
op_star
id|new_res
suffix:semicolon
r_int
id|status
suffix:semicolon
id|new_res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_res
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
l_int|0
)paren
(brace
id|status
op_assign
id|allocate_resource
c_func
(paren
id|root_resource
comma
id|new_res
comma
id|size
comma
id|start
multiline_comment|/* Min start addr. */
comma
(paren
id|start
op_plus
id|size
)paren
op_minus
l_int|1
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|size
OG
id|align
)paren
id|align
op_assign
id|size
suffix:semicolon
id|status
op_assign
id|allocate_resource
c_func
(paren
id|root_resource
comma
id|new_res
comma
id|size
comma
id|align
multiline_comment|/* Min start addr. */
comma
id|root_resource-&gt;end
comma
id|align
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
(brace
id|kfree
c_func
(paren
id|new_res
)paren
suffix:semicolon
r_return
(paren
id|iopaddr_t
)paren
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a window allocation cookie has been supplied, use it to keep&n;&t; * track of all the allocated space assigned to this window.&n;&t; */
r_if
c_cond
(paren
id|win_alloc
)paren
(brace
id|win_alloc-&gt;wa_resource
op_assign
id|new_res
suffix:semicolon
id|win_alloc-&gt;wa_base
op_assign
id|new_res-&gt;start
suffix:semicolon
id|win_alloc-&gt;wa_pages
op_assign
id|size
suffix:semicolon
)brace
r_return
id|new_res-&gt;start
suffix:semicolon
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the specified window allocation back into the PCI window mapping&n; * resource.  As noted above, we keep page addresses offset by 1 ...&n; */
r_void
DECL|function|pciio_device_win_free
id|pciio_device_win_free
c_func
(paren
id|pciio_win_alloc_t
id|win_alloc
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|win_alloc-&gt;wa_resource
)paren
(brace
id|status
op_assign
id|release_resource
c_func
(paren
id|win_alloc-&gt;wa_resource
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|kfree
c_func
(paren
id|win_alloc-&gt;wa_resource
)paren
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pciio_error_register:&n; * arrange for a function to be called with&n; * a specified first parameter plus other&n; * information when an error is encountered&n; * and traced to the pci slot corresponding&n; * to the connection point pconn.&n; *&n; * may also be called with a null function&n; * pointer to &quot;unregister&quot; the error handler.&n; *&n; * NOTE: subsequent calls silently overwrite&n; * previous data for this vertex. We assume that&n; * cooperating drivers, well, cooperate ...&n; */
r_void
DECL|function|pciio_error_register
id|pciio_error_register
c_func
(paren
id|vertex_hdl_t
id|pconn
comma
id|error_handler_f
op_star
id|efunc
comma
id|error_handler_arg_t
id|einfo
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|pciio_info-&gt;c_efunc
op_assign
id|efunc
suffix:semicolon
id|pciio_info-&gt;c_einfo
op_assign
id|einfo
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if any device has been found in this slot, and return&n; * true or false&n; * vhdl is the vertex for the slot&n; */
r_int
DECL|function|pciio_slot_inuse
id|pciio_slot_inuse
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pciio_info-&gt;c_vertex
op_eq
id|pconn_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info-&gt;c_vendor
)paren
(brace
multiline_comment|/*&n;&t; * Non-zero value for vendor indicate&n;&t; * a board being found in this slot.&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pciio_info_type1_get
id|pciio_info_type1_get
c_func
(paren
id|pciio_info_t
id|pci_info
)paren
(brace
r_return
(paren
id|pci_info-&gt;c_type1
)paren
suffix:semicolon
)brace
id|pciio_businfo_t
DECL|function|pciio_businfo_get
id|pciio_businfo_get
c_func
(paren
id|vertex_hdl_t
id|conn
)paren
(brace
id|pciio_info_t
id|info
suffix:semicolon
id|info
op_assign
id|pciio_info_get
c_func
(paren
id|conn
)paren
suffix:semicolon
r_return
id|DEV_FUNC
c_func
(paren
id|conn
comma
id|businfo_get
)paren
(paren
id|conn
)paren
suffix:semicolon
)brace
eof
