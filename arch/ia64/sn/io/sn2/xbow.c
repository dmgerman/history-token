multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (c) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/sn2/sn_private.h&gt;
macro_line|#include &lt;asm/sn/sn2/shubio.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk_private.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
multiline_comment|/* #define DEBUG&t;&t;1 */
multiline_comment|/* #define XBOW_DEBUG&t;1 */
multiline_comment|/* #define DEBUG_ERROR&t;1 */
multiline_comment|/*&n; * Files needed to get the device driver entry points&n; */
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xswitch.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
DECL|macro|NEW
mdefine_line|#define NEW(ptr)&t;(ptr = kmalloc(sizeof (*(ptr)), GFP_KERNEL))
DECL|macro|DEL
mdefine_line|#define DEL(ptr)&t;(kfree(ptr))
multiline_comment|/*&n; * This file supports the Xbow chip.  Main functions: initializtion,&n; * error handling, and GBR.&n; */
multiline_comment|/*&n; * each vertex corresponding to an xbow chip&n; * has a &quot;fastinfo&quot; pointer pointing at one&n; * of these things.&n; */
DECL|typedef|xbow_soft_t
r_typedef
r_struct
id|xbow_soft_s
op_star
id|xbow_soft_t
suffix:semicolon
DECL|struct|xbow_soft_s
r_struct
id|xbow_soft_s
(brace
DECL|member|conn
id|vertex_hdl_t
id|conn
suffix:semicolon
multiline_comment|/* our connection point */
DECL|member|vhdl
id|vertex_hdl_t
id|vhdl
suffix:semicolon
multiline_comment|/* xbow&squot;s private vertex */
DECL|member|busv
id|vertex_hdl_t
id|busv
suffix:semicolon
multiline_comment|/* the xswitch vertex */
DECL|member|base
id|xbow_t
op_star
id|base
suffix:semicolon
multiline_comment|/* PIO pointer to crossbow chip */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* hwgraph name */
DECL|member|xbow_perfcnt
id|xbow_perf_t
id|xbow_perfcnt
(braket
id|XBOW_PERF_COUNTERS
)braket
suffix:semicolon
DECL|member|xbow_perflink
id|xbow_perf_link_t
id|xbow_perflink
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
DECL|member|xbow_link_status
id|xbow_link_status_t
id|xbow_link_status
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
DECL|member|xbow_perf_lock
id|spinlock_t
id|xbow_perf_lock
suffix:semicolon
DECL|member|link_monitor
r_int
id|link_monitor
suffix:semicolon
DECL|member|wpio
id|widget_cfg_t
op_star
id|wpio
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* cached PIO pointer */
multiline_comment|/* Bandwidth allocation state. Bandwidth values are for the&n;     * destination port since contention happens there.&n;     * Implicit mapping from xbow ports (8..f) -&gt; (0..7) array indices.&n;     */
DECL|member|xbow_bw_alloc_lock
id|spinlock_t
id|xbow_bw_alloc_lock
suffix:semicolon
multiline_comment|/* bw allocation lock */
DECL|member|bw_hiwm
r_int
r_int
r_int
id|bw_hiwm
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* hiwater mark values */
DECL|member|bw_cur_used
r_int
r_int
r_int
id|bw_cur_used
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* bw used currently */
)brace
suffix:semicolon
DECL|macro|xbow_soft_set
mdefine_line|#define xbow_soft_set(v,i)&t;hwgraph_fastinfo_set((v), (arbitrary_info_t)(i))
DECL|macro|xbow_soft_get
mdefine_line|#define xbow_soft_get(v)&t;((xbow_soft_t)hwgraph_fastinfo_get((v)))
multiline_comment|/*&n; * Function Table of Contents&n; */
r_void
id|xbow_mlreset
c_func
(paren
id|xbow_t
op_star
)paren
suffix:semicolon
r_int
id|xbow_attach
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|xbow_widget_present
c_func
(paren
id|xbow_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|xbow_link_alive
c_func
(paren
id|xbow_t
op_star
comma
r_int
)paren
suffix:semicolon
id|vertex_hdl_t
id|xbow_widget_lookup
c_func
(paren
id|vertex_hdl_t
comma
r_int
)paren
suffix:semicolon
r_void
id|xbow_intr_preset
c_func
(paren
r_void
op_star
comma
r_int
comma
id|xwidgetnum_t
comma
id|iopaddr_t
comma
id|xtalk_intr_vector_t
)paren
suffix:semicolon
r_void
id|xbow_update_perf_counters
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_get_perf_counters
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|xbow_enable_perf_counter
c_func
(paren
id|vertex_hdl_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_get_llp_status
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_void
id|xbow_update_llp_status
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|xbow_disable_llp_monitor
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|xbow_enable_llp_monitor
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|xbow_prio_bw_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|xwidgetnum_t
comma
id|xwidgetnum_t
comma
r_int
r_int
r_int
comma
r_int
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|xbow_setwidint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
DECL|variable|xbow_reset_link
id|xswitch_reset_link_f
id|xbow_reset_link
suffix:semicolon
DECL|variable|xbow_provider
id|xswitch_provider_t
id|xbow_provider
op_assign
(brace
id|xbow_reset_link
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|xbow_mmap
id|xbow_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_int
r_int
id|phys_addr
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|phys_addr
op_assign
(paren
r_int
r_int
)paren
id|file-&gt;private_data
op_amp
op_complement
l_int|0xc000000000000000
suffix:semicolon
multiline_comment|/* Mask out the Uncache bits */
id|vma-&gt;vm_page_prot
op_assign
id|pgprot_noncached
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|VM_RESERVED
op_or
id|VM_IO
suffix:semicolon
id|error
op_assign
id|io_remap_page_range
c_func
(paren
id|vma
comma
id|phys_addr
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the file operation table for the pcibr driver.&n; * As each of the functions are implemented, put the&n; * appropriate function name below.&n; */
DECL|variable|xbow_fops
r_struct
id|file_operations
id|xbow_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|mmap
op_assign
id|xbow_mmap
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *    xbow_mlreset: called at mlreset time if the&n; *      platform specific code determines that there is&n; *      a crossbow in a critical path that must be&n; *      functional before the driver would normally get&n; *      the device properly set up.&n; *&n; *      what do we need to do, that the boot prom can&n; *      not be counted on to have already done, that is&n; *      generic across all platforms using crossbows?&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|xbow_mlreset
id|xbow_mlreset
c_func
(paren
id|xbow_t
op_star
id|xbow
)paren
(brace
)brace
macro_line|#ifdef XBRIDGE_REGS_SIM
multiline_comment|/*    xbow_set_simulated_regs: sets xbow regs as needed&n; *&t;for powering through the boot&n; */
r_void
DECL|function|xbow_set_simulated_regs
id|xbow_set_simulated_regs
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
multiline_comment|/*&n;     * turn on link&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
op_assign
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:semicolon
multiline_comment|/*&n;     * and give it a live widget too&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_aux_status
op_assign
id|XB_AUX_STAT_PRESENT
suffix:semicolon
multiline_comment|/*&n;     * zero the link control reg&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
l_int|0x0
suffix:semicolon
)brace
macro_line|#endif /* XBRIDGE_REGS_SIM */
multiline_comment|/*&n; *    xbow_attach: the crosstalk provider has&n; *      determined that there is a crossbow widget&n; *      present, and has handed us the connection&n; *      point for that vertex.&n; *&n; *      We not only add our own vertex, but add&n; *      some &quot;xtalk switch&quot; data to the switch&n; *      vertex (at the connect point&squot;s parent) if&n; *      it does not have any.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_attach
id|xbow_attach
c_func
(paren
id|vertex_hdl_t
id|conn
)paren
(brace
multiline_comment|/*REFERENCED */
id|vertex_hdl_t
id|vhdl
suffix:semicolon
id|vertex_hdl_t
id|busv
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbow_soft_t
id|soft
suffix:semicolon
r_int
id|port
suffix:semicolon
id|xswitch_info_t
id|info
suffix:semicolon
id|xtalk_intr_t
id|intr_hdl
suffix:semicolon
r_char
id|devnm
(braket
id|MAXDEVNAME
)braket
comma
op_star
id|s
suffix:semicolon
id|xbowreg_t
id|id
suffix:semicolon
r_int
id|rev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|xbow_num
suffix:semicolon
r_static
r_void
id|xbow_errintr_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
l_string|&quot;%v: xbow_attach&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;0x%x: xbow_attach&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;     * Get a PIO pointer to the base of the crossbow&n;     * chip.&n;     */
macro_line|#ifdef XBRIDGE_REGS_SIM
id|printk
c_func
(paren
l_string|&quot;xbow_attach: XBRIDGE_REGS_SIM FIXME: allocating %ld bytes for xbow_s&bslash;n&quot;
comma
r_sizeof
(paren
id|xbow_t
)paren
)paren
suffix:semicolon
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|xbow_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;     * turn on ports e and f like in a real live ibrick&n;     */
id|xbow_set_simulated_regs
c_func
(paren
id|xbow
comma
l_int|0xe
)paren
suffix:semicolon
id|xbow_set_simulated_regs
c_func
(paren
id|xbow
comma
l_int|0xf
)paren
suffix:semicolon
macro_line|#else
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xtalk_piotrans_addr
c_func
(paren
id|conn
comma
l_int|0
comma
l_int|0
comma
r_sizeof
(paren
id|xbow_t
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* XBRIDGE_REGS_SIM */
multiline_comment|/*&n;     * Locate the &quot;switch&quot; vertex: it is the parent&n;     * of our connection point.&n;     */
id|busv
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|conn
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printk
c_func
(paren
l_string|&quot;xbow_attach: Bus Vertex 0x%p, conn 0x%p, xbow register 0x%p wid= 0x%x&bslash;n&quot;
comma
id|busv
comma
id|conn
comma
id|xbow
comma
op_star
(paren
r_volatile
id|u32
op_star
)paren
id|xbow
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|busv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
multiline_comment|/*&n;     * Create our private vertex, and connect our&n;     * driver information to it. This makes it possible&n;     * for diagnostic drivers to open the crossbow&n;     * vertex for access to registers.&n;     */
multiline_comment|/*&n;     * Register a xbow driver with hwgraph.&n;     * file ops.&n;     */
id|vhdl
op_assign
l_int|NULL
suffix:semicolon
id|vhdl
op_assign
id|hwgraph_register
c_func
(paren
id|conn
comma
id|EDGE_LBL_XBOW
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
(paren
r_struct
id|file_operations
op_star
)paren
op_amp
id|xbow_fops
comma
(paren
r_void
op_star
)paren
id|xbow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vhdl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;xbow_attach: Unable to create char device for xbow conn %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|conn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate the soft state structure and attach&n;     * it to the xbow&squot;s vertex&n;     */
id|NEW
c_func
(paren
id|soft
)paren
suffix:semicolon
id|soft-&gt;conn
op_assign
id|conn
suffix:semicolon
id|soft-&gt;vhdl
op_assign
id|vhdl
suffix:semicolon
id|soft-&gt;busv
op_assign
id|busv
suffix:semicolon
id|soft-&gt;base
op_assign
id|xbow
suffix:semicolon
multiline_comment|/* does the universe really need another macro?  */
multiline_comment|/* xbow_soft_set(vhdl, (arbitrary_info_t) soft); */
multiline_comment|/* hwgraph_fastinfo_set(vhdl, (arbitrary_info_t) soft); */
DECL|macro|XBOW_NUM_SUFFIX_FORMAT
mdefine_line|#define XBOW_NUM_SUFFIX_FORMAT&t;&quot;[xbow# %d]&quot;
multiline_comment|/* Add xbow number as a suffix to the hwgraph name of the xbow.&n;     * This is helpful while looking at the error/warning messages.&n;     */
id|xbow_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * get the name of this xbow vertex and keep the info.&n;     * This is needed during errors and interupts, but as&n;     * long as we have it, we can use it elsewhere.&n;     */
id|s
op_assign
id|dev_to_name
c_func
(paren
id|vhdl
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|soft-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
id|strlen
c_func
(paren
id|XBOW_NUM_SUFFIX_FORMAT
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|soft-&gt;name
comma
l_string|&quot;%s&quot;
id|XBOW_NUM_SUFFIX_FORMAT
comma
id|s
comma
id|xbow_num
)paren
suffix:semicolon
macro_line|#ifdef XBRIDGE_REGS_SIM
multiline_comment|/* my o200/ibrick has id=0x2d002049, but XXBOW_WIDGET_PART_NUM is defined&n;     * as 0xd000, so I&squot;m using that for the partnum bitfield.&n;     */
id|printk
c_func
(paren
l_string|&quot;xbow_attach: XBRIDGE_REGS_SIM FIXME: need xb_wid_id value!!&bslash;n&quot;
)paren
suffix:semicolon
id|id
op_assign
l_int|0x2d000049
suffix:semicolon
macro_line|#else
id|id
op_assign
id|xbow-&gt;xb_wid_id
suffix:semicolon
macro_line|#endif /* XBRIDGE_REGS_SIM */
id|rev
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|mutex_spinlock_init
c_func
(paren
op_amp
id|soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
id|soft-&gt;xbow_perfcnt
(braket
l_int|0
)braket
dot
id|xp_perf_reg
op_assign
op_amp
id|xbow-&gt;xb_perf_ctr_a
suffix:semicolon
id|soft-&gt;xbow_perfcnt
(braket
l_int|1
)braket
dot
id|xp_perf_reg
op_assign
op_amp
id|xbow-&gt;xb_perf_ctr_b
suffix:semicolon
multiline_comment|/* Initialization for GBR bw allocation */
id|mutex_spinlock_init
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
)paren
suffix:semicolon
DECL|macro|XBOW_8_BIT_PORT_BW_MAX
mdefine_line|#define&t;XBOW_8_BIT_PORT_BW_MAX&t;&t;(400 * 1000 * 1000)&t;/* 400 MB/s */
DECL|macro|XBOW_16_BIT_PORT_BW_MAX
mdefine_line|#define XBOW_16_BIT_PORT_BW_MAX&t;&t;(800 * 1000 * 1000)&t;/* 800 MB/s */
multiline_comment|/* Set bandwidth hiwatermark and current values */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|soft-&gt;bw_hiwm
(braket
id|i
)braket
op_assign
id|XBOW_16_BIT_PORT_BW_MAX
suffix:semicolon
multiline_comment|/* for now */
id|soft-&gt;bw_cur_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;      * attach the crossbow error interrupt.&n;      */
id|intr_hdl
op_assign
id|xtalk_intr_alloc
c_func
(paren
id|conn
comma
(paren
id|device_desc_t
)paren
l_int|0
comma
id|vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|intr_hdl
op_ne
l_int|NULL
)paren
suffix:semicolon
(brace
r_int
id|irq
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|intr_hdl
)paren
op_member_access_from_pointer
id|i_bit
suffix:semicolon
r_int
id|cpu
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|intr_hdl
)paren
op_member_access_from_pointer
id|i_cpuid
suffix:semicolon
id|intr_unreserve_level
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
(paren
(paren
id|hub_intr_t
)paren
id|intr_hdl
)paren
op_member_access_from_pointer
id|i_bit
op_assign
id|SGI_XBOW_ERROR
suffix:semicolon
)brace
id|xtalk_intr_connect
c_func
(paren
id|intr_hdl
comma
(paren
id|intr_func_t
)paren
id|xbow_errintr_handler
comma
(paren
id|intr_arg_t
)paren
id|soft
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|xbow_setwidint
comma
(paren
r_void
op_star
)paren
id|xbow
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|SGI_XBOW_ERROR
comma
(paren
r_void
op_star
)paren
id|xbow_errintr_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;XBOW error&quot;
comma
(paren
id|intr_arg_t
)paren
id|soft
)paren
suffix:semicolon
multiline_comment|/*&n;     * Enable xbow error interrupts&n;     */
id|xbow-&gt;xb_wid_control
op_assign
(paren
id|XB_WID_CTRL_REG_ACC_IE
op_or
id|XB_WID_CTRL_XTALK_IE
)paren
suffix:semicolon
multiline_comment|/*&n;     * take a census of the widgets present,&n;     * leaving notes at the switch vertex.&n;     */
id|info
op_assign
id|xswitch_info_new
c_func
(paren
id|busv
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|MAX_PORT_NUM
op_minus
id|MAX_XBOW_PORTS
suffix:semicolon
id|port
OL
id|MAX_PORT_NUM
suffix:semicolon
op_increment
id|port
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xbow_link_alive
c_func
(paren
id|xbow
comma
id|port
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d is not alive&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xbow_widget_present
c_func
(paren
id|xbow
comma
id|port
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d is alive but no widget is present&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d has a widget&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
id|xswitch_info_link_is_ok
c_func
(paren
id|info
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn some error interrupts on&n;&t; * and turn others off. The PROM has&n;&t; * some things turned on we don&squot;t&n;&t; * want to see (bandwidth allocation&n;&t; * errors for instance); so if it&n;&t; * is not listed here, it is not on.&n;&t; */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
(paren
(paren
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
multiline_comment|/*&n;&t; * Turn off these bits; they are non-fatal,&n;&t; * but we might want to save some statistics&n;&t; * on the frequency of these errors.&n;&t; * XXX FIXME XXX&n;&t; */
op_amp
op_complement
id|XB_CTRL_RCV_CNT_OFLOW_IE
op_amp
op_complement
id|XB_CTRL_XMT_CNT_OFLOW_IE
op_amp
op_complement
id|XB_CTRL_BNDWDTH_ALLOC_IE
op_amp
op_complement
id|XB_CTRL_RCV_IE
)paren
multiline_comment|/*&n;&t; * These are the ones we want to turn on.&n;&t; */
op_or
(paren
id|XB_CTRL_ILLEGAL_DST_IE
op_or
id|XB_CTRL_OALLOC_IBUF_IE
op_or
id|XB_CTRL_XMT_MAX_RTRY_IE
op_or
id|XB_CTRL_MAXREQ_TOUT_IE
op_or
id|XB_CTRL_XMT_RTRY_IE
op_or
id|XB_CTRL_SRC_TOUT_IE
)paren
)paren
suffix:semicolon
)brace
id|xswitch_provider_register
c_func
(paren
id|busv
comma
op_amp
id|xbow_provider
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* attach successful */
)brace
multiline_comment|/* This contains special-case code for grio. There are plans to make&n; * this general sometime in the future, but till then this should&n; * be good enough.&n; */
id|xwidgetnum_t
DECL|function|xbow_widget_num_get
id|xbow_widget_num_get
c_func
(paren
id|vertex_hdl_t
id|dev
)paren
(brace
id|vertex_hdl_t
id|tdev
suffix:semicolon
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|xwidget_info_t
id|xwidget_info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|dev
comma
id|devname
comma
id|MAXDEVNAME
)paren
suffix:semicolon
multiline_comment|/* If this is a pci controller vertex, traverse up using&n;&t; * the &quot;..&quot; links to get to the widget.&n;&t; */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|devname
comma
id|EDGE_LBL_PCI
)paren
op_logical_and
id|strstr
c_func
(paren
id|devname
comma
id|EDGE_LBL_CONTROLLER
)paren
)paren
(brace
id|tdev
op_assign
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hwgraph_edge_get
c_func
(paren
id|tdev
comma
id|HWGRAPH_EDGELBL_DOTDOT
comma
op_amp
id|tdev
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xwidget_info
op_assign
id|xwidget_info_chk
c_func
(paren
id|tdev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_return
(paren
id|xwidget_info_id_get
c_func
(paren
id|xwidget_info
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
)brace
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_widget_present: See if a device is present&n; * on the specified port of this crossbow.&n; */
r_int
DECL|function|xbow_widget_present
id|xbow_widget_present
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_eq
l_int|14
)paren
op_logical_or
(paren
id|port
op_eq
l_int|15
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* WAR: port 0xf on PIC is missing present bit */
r_if
c_cond
(paren
id|XBOW_WAR_ENABLED
c_func
(paren
id|PV854827
comma
id|xbow-&gt;xb_wid_id
)paren
op_logical_and
id|IS_PIC_XBOW
c_func
(paren
id|xbow-&gt;xb_wid_id
)paren
op_logical_and
id|port
op_eq
l_int|0xf
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_aux_status
op_amp
id|XB_AUX_STAT_PRESENT
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|xbow_link_alive
id|xbow_link_alive
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
id|xbwX_stat_t
id|xbow_linkstat
suffix:semicolon
id|xbow_linkstat.linkstatus
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
suffix:semicolon
r_return
(paren
id|xbow_linkstat.link_alive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_widget_lookup&n; *      Lookup the edges connected to the xbow specified, and&n; *      retrieve the handle corresponding to the widgetnum&n; *      specified.&n; *      If not found, return 0.&n; */
id|vertex_hdl_t
DECL|function|xbow_widget_lookup
id|xbow_widget_lookup
c_func
(paren
id|vertex_hdl_t
id|vhdl
comma
r_int
id|widgetnum
)paren
(brace
id|xswitch_info_t
id|xswitch_info
suffix:semicolon
id|vertex_hdl_t
id|conn
suffix:semicolon
id|xswitch_info
op_assign
id|xswitch_info_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|conn
op_assign
id|xswitch_info_vhdl_get
c_func
(paren
id|xswitch_info
comma
id|widgetnum
)paren
suffix:semicolon
r_return
id|conn
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_setwidint: called when xtalk&n; * is establishing or migrating our&n; * interrupt service.&n; */
r_static
r_void
DECL|function|xbow_setwidint
id|xbow_setwidint
c_func
(paren
id|xtalk_intr_t
id|intr
)paren
(brace
id|xwidgetnum_t
id|targ
op_assign
id|xtalk_intr_target_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xbow_intr_preset
c_func
(paren
(paren
r_void
op_star
)paren
id|xbow
comma
l_int|0
comma
id|targ
comma
id|addr
comma
id|vect
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_intr_preset: called during mlreset time&n; * if the platform specific code needs to route&n; * an xbow interrupt before the xtalk infrastructure&n; * is available for use.&n; *&n; * Also called from xbow_setwidint, so we don&squot;t&n; * replicate the guts of the routine.&n; *&n; * XXX- probably should be renamed xbow_wid_intr_set or&n; * something to reduce confusion.&n; */
multiline_comment|/*ARGSUSED3 */
r_void
DECL|function|xbow_intr_preset
id|xbow_intr_preset
c_func
(paren
r_void
op_star
id|which_widget
comma
r_int
id|which_widget_intr
comma
id|xwidgetnum_t
id|targ
comma
id|iopaddr_t
id|addr
comma
id|xtalk_intr_vector_t
id|vect
)paren
(brace
id|xbow_t
op_star
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|which_widget
suffix:semicolon
id|xbow-&gt;xb_wid_int_upper
op_assign
(paren
(paren
l_int|0xFF000000
op_amp
(paren
id|vect
op_lshift
l_int|24
)paren
)paren
op_or
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|xbow-&gt;xb_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|macro|XEM_ADD_STR
mdefine_line|#define&t;XEM_ADD_STR(s)&t;&t;printk(&quot;%s&quot;, (s))
DECL|macro|XEM_ADD_NVAR
mdefine_line|#define&t;XEM_ADD_NVAR(n,v)&t;printk(&quot;&bslash;t%20s: 0x%llx&bslash;n&quot;, (n), ((unsigned long long)v))
DECL|macro|XEM_ADD_VAR
mdefine_line|#define&t;XEM_ADD_VAR(v)&t;&t;XEM_ADD_NVAR(#v,(v))
DECL|macro|XEM_ADD_IOEF
mdefine_line|#define XEM_ADD_IOEF(p,n)&t;if (IOERROR_FIELDVALID(ioe,n)) {&t;&bslash;&n;&t;&t;&t;&t;    IOERROR_GETVALUE(p,ioe,n);&t;&t;&bslash;&n;&t;&t;&t;&t;    XEM_ADD_NVAR(&quot;ioe.&quot; #n, p);&t;&t;&bslash;&n;&t;&t;&t;&t;}
DECL|variable|xbow_xmit_retry_errors
r_int
id|xbow_xmit_retry_errors
suffix:semicolon
r_int
DECL|function|xbow_xmit_retry_error
id|xbow_xmit_retry_error
c_func
(paren
id|xbow_soft_t
id|soft
comma
r_int
id|port
)paren
(brace
id|xswitch_info_t
id|info
suffix:semicolon
id|vertex_hdl_t
id|vhdl
suffix:semicolon
id|widget_cfg_t
op_star
id|wid
suffix:semicolon
id|widgetreg_t
id|id
suffix:semicolon
r_int
id|part
suffix:semicolon
r_int
id|mfgr
suffix:semicolon
id|wid
op_assign
id|soft-&gt;wpio
(braket
id|port
op_minus
id|BASE_XBOW_PORT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wid
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If we can&squot;t track down a PIO&n;&t; * pointer to our widget yet,&n;&t; * leave our caller knowing that&n;&t; * we are interested in this&n;&t; * interrupt if it occurs in&n;&t; * the future.&n;&t; */
id|info
op_assign
id|xswitch_info_get
c_func
(paren
id|soft-&gt;busv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
l_int|1
suffix:semicolon
id|vhdl
op_assign
id|xswitch_info_vhdl_get
c_func
(paren
id|info
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
r_return
l_int|1
suffix:semicolon
id|wid
op_assign
(paren
id|widget_cfg_t
op_star
)paren
id|xtalk_piotrans_addr
(paren
id|vhdl
comma
l_int|0
comma
l_int|0
comma
r_sizeof
op_star
id|wid
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wid
)paren
r_return
l_int|1
suffix:semicolon
id|soft-&gt;wpio
(braket
id|port
op_minus
id|BASE_XBOW_PORT
)braket
op_assign
id|wid
suffix:semicolon
)brace
id|id
op_assign
id|wid-&gt;w_id
suffix:semicolon
id|part
op_assign
id|XWIDGET_PART_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|mfgr
op_assign
id|XWIDGET_MFG_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
multiline_comment|/* If this thing is not a Bridge,&n;     * do not activate the WAR, and&n;     * tell our caller we do not need&n;     * to be called again.&n;     */
r_if
c_cond
(paren
(paren
id|part
op_ne
id|BRIDGE_WIDGET_PART_NUM
)paren
op_logical_or
(paren
id|mfgr
op_ne
id|BRIDGE_WIDGET_MFGR_NUM
)paren
)paren
(brace
multiline_comment|/* FIXME: add Xbridge to the WAR.&n;&t;&t; * Shouldn&squot;t hurt anything.  Later need to&n;&t;&t; * check if we can remove this.&n;                 */
r_if
c_cond
(paren
(paren
id|part
op_ne
id|XBRIDGE_WIDGET_PART_NUM
)paren
op_logical_or
(paren
id|mfgr
op_ne
id|XBRIDGE_WIDGET_MFGR_NUM
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* count how many times we&n;     * have picked up after&n;     * LLP Transmit problems.&n;     */
id|xbow_xmit_retry_errors
op_increment
suffix:semicolon
multiline_comment|/* rewrite the control register&n;     * to fix things up.&n;     */
id|wid-&gt;w_control
op_assign
id|wid-&gt;w_control
suffix:semicolon
id|wid-&gt;w_control
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_errintr_handler will be called if the xbow&n; * sends an interrupt request to report an error.&n; */
r_static
r_void
DECL|function|xbow_errintr_handler
id|xbow_errintr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|ioerror_t
id|ioe
(braket
l_int|1
)braket
suffix:semicolon
id|xbow_soft_t
id|soft
op_assign
(paren
id|xbow_soft_t
)paren
id|arg
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
id|soft-&gt;base
suffix:semicolon
id|xbowreg_t
id|wid_control
suffix:semicolon
id|xbowreg_t
id|wid_stat
suffix:semicolon
id|xbowreg_t
id|wid_err_cmdword
suffix:semicolon
id|xbowreg_t
id|wid_err_upper
suffix:semicolon
id|xbowreg_t
id|wid_err_lower
suffix:semicolon
id|w_err_cmd_word_u
id|wid_err
suffix:semicolon
r_int
r_int
r_int
id|wid_err_addr
suffix:semicolon
r_int
id|fatal
op_assign
l_int|0
suffix:semicolon
r_int
id|dump_ioe
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|xbow_error_handler
c_func
(paren
r_void
op_star
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
id|wid_control
op_assign
id|xbow-&gt;xb_wid_control
suffix:semicolon
id|wid_stat
op_assign
id|xbow-&gt;xb_wid_stat_clr
suffix:semicolon
id|wid_err_cmdword
op_assign
id|xbow-&gt;xb_wid_err_cmdword
suffix:semicolon
id|wid_err_upper
op_assign
id|xbow-&gt;xb_wid_err_upper
suffix:semicolon
id|wid_err_lower
op_assign
id|xbow-&gt;xb_wid_err_lower
suffix:semicolon
id|xbow-&gt;xb_wid_err_cmdword
op_assign
l_int|0
suffix:semicolon
id|wid_err_addr
op_assign
id|wid_err_lower
op_or
(paren
(paren
(paren
id|iopaddr_t
)paren
id|wid_err_upper
op_amp
id|WIDGET_ERR_UPPER_ADDR_ONLY
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wid_stat
op_amp
id|XB_WID_STAT_LINK_INTR_MASK
)paren
(brace
r_int
id|port
suffix:semicolon
id|wid_err.r
op_assign
id|wid_err_cmdword
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|MAX_PORT_NUM
op_minus
id|MAX_XBOW_PORTS
suffix:semicolon
id|port
OL
id|MAX_PORT_NUM
suffix:semicolon
id|port
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wid_stat
op_amp
id|XB_WID_STAT_LINK_INTR
c_func
(paren
id|port
)paren
)paren
(brace
id|xb_linkregs_t
op_star
id|link
op_assign
op_amp
(paren
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|xbowreg_t
id|link_control
op_assign
id|link-&gt;link_control
suffix:semicolon
id|xbowreg_t
id|link_status
op_assign
id|link-&gt;link_status_clr
suffix:semicolon
id|xbowreg_t
id|link_aux_status
op_assign
id|link-&gt;link_aux_status
suffix:semicolon
id|xbowreg_t
id|link_pend
suffix:semicolon
id|link_pend
op_assign
id|link_status
op_amp
id|link_control
op_amp
(paren
id|XB_STAT_ILLEGAL_DST_ERR
op_or
id|XB_STAT_OALLOC_IBUF_ERR
op_or
id|XB_STAT_RCV_CNT_OFLOW_ERR
op_or
id|XB_STAT_XMT_CNT_OFLOW_ERR
op_or
id|XB_STAT_XMT_MAX_RTRY_ERR
op_or
id|XB_STAT_RCV_ERR
op_or
id|XB_STAT_XMT_RTRY_ERR
op_or
id|XB_STAT_MAXREQ_TOUT_ERR
op_or
id|XB_STAT_SRC_TOUT_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_pend
op_amp
id|XB_STAT_ILLEGAL_DST_ERR
)paren
(brace
r_if
c_cond
(paren
id|wid_err.f.sidn
op_eq
id|port
)paren
(brace
id|IOERROR_INIT
c_func
(paren
id|ioe
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetnum
comma
id|port
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|xtalkaddr
comma
id|wid_err_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IOERROR_HANDLED
op_eq
id|xbow_error_handler
c_func
(paren
id|soft
comma
id|IOECODE_DMA
comma
id|MODE_DEVERROR
comma
id|ioe
)paren
)paren
(brace
id|link_pend
op_and_assign
op_complement
id|XB_STAT_ILLEGAL_DST_ERR
suffix:semicolon
)brace
r_else
(brace
id|dump_ioe
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Xbow/Bridge WAR:&n;&t;&t; * if the bridge signals an LLP Transmitter Retry,&n;&t;&t; * rewrite its control register.&n;&t;&t; * If someone else triggers this interrupt,&n;&t;&t; * ignore (and disable) the interrupt.&n;&t;&t; */
r_if
c_cond
(paren
id|link_pend
op_amp
id|XB_STAT_XMT_RTRY_ERR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xbow_xmit_retry_error
c_func
(paren
id|soft
comma
id|port
)paren
)paren
(brace
id|link_control
op_and_assign
op_complement
id|XB_CTRL_XMT_RTRY_IE
suffix:semicolon
id|link-&gt;link_control
op_assign
id|link_control
suffix:semicolon
id|link-&gt;link_control
suffix:semicolon
multiline_comment|/* stall until written */
)brace
id|link_pend
op_and_assign
op_complement
id|XB_STAT_XMT_RTRY_ERR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link_pend
)paren
(brace
id|vertex_hdl_t
id|xwidget_vhdl
suffix:semicolon
r_char
op_star
id|xwidget_name
suffix:semicolon
multiline_comment|/* Get the widget name corresponding to the current&n;&t;&t;     * xbow link.&n;&t;&t;     */
id|xwidget_vhdl
op_assign
id|xbow_widget_lookup
c_func
(paren
id|soft-&gt;busv
comma
id|port
)paren
suffix:semicolon
id|xwidget_name
op_assign
id|xwidget_name_get
c_func
(paren
id|xwidget_vhdl
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s port %X[%s] XIO Bus Error&quot;
comma
id|soft-&gt;name
comma
id|port
comma
id|xwidget_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_MULTI_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tMultiple Errors&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_ILLEGAL_DST_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tInvalid Packet Destination&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_OALLOC_IBUF_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tInput Overallocation Error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_RCV_CNT_OFLOW_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLLP receive error counter overflow&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_XMT_CNT_OFLOW_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLLP transmit retry counter overflow&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_XMT_MAX_RTRY_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLLP Max Transmitter Retry&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_RCV_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLLP Receiver error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_XMT_RTRY_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLLP Transmitter Retry&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_MAXREQ_TOUT_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tMaximum Request Timeout&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_status
op_amp
id|XB_STAT_SRC_TOUT_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tSource Timeout Error&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_int
id|other_port
suffix:semicolon
r_for
c_loop
(paren
id|other_port
op_assign
l_int|8
suffix:semicolon
id|other_port
OL
l_int|16
suffix:semicolon
op_increment
id|other_port
)paren
(brace
r_if
c_cond
(paren
id|link_aux_status
op_amp
(paren
l_int|1
op_lshift
id|other_port
)paren
)paren
(brace
multiline_comment|/* XXX- need to go to &quot;other_port&quot;&n;&t;&t;&t;&t; * and clean up after the timeout?&n;&t;&t;&t;&t; */
id|XEM_ADD_VAR
c_func
(paren
id|other_port
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
id|XEM_ADD_VAR
c_func
(paren
id|link_control
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_status
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_aux_status
)paren
suffix:semicolon
macro_line|#if !DEBUG
)brace
macro_line|#endif
id|fatal
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|wid_stat
op_amp
id|wid_control
op_amp
id|XB_WID_STAT_WIDGET0_INTR
)paren
(brace
multiline_comment|/* we have a &quot;widget zero&quot; problem */
r_if
c_cond
(paren
id|wid_stat
op_amp
(paren
id|XB_WID_STAT_MULTI_ERR
op_or
id|XB_WID_STAT_XTALK_ERR
op_or
id|XB_WID_STAT_REG_ACC_ERR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s Port 0 XIO Bus Error&quot;
comma
id|soft-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wid_stat
op_amp
id|XB_WID_STAT_MULTI_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tMultiple Error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wid_stat
op_amp
id|XB_WID_STAT_XTALK_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tXIO Error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wid_stat
op_amp
id|XB_WID_STAT_REG_ACC_ERR
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tRegister Access Error&bslash;n&quot;
)paren
suffix:semicolon
id|fatal
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fatal
)paren
(brace
id|XEM_ADD_VAR
c_func
(paren
id|wid_stat
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_control
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_cmdword
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_upper
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_lower
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_addr
)paren
suffix:semicolon
id|PRINT_PANIC
c_func
(paren
l_string|&quot;XIO Bus Error&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XBOW ERROR Handling routines.&n; * These get invoked as part of walking down the error handling path&n; * from hub/heart towards the I/O device that caused the error.&n; */
multiline_comment|/*&n; * xbow_error_handler&n; *      XBow error handling dispatch routine.&n; *      This is the primary interface used by external world to invoke&n; *      in case of an error related to a xbow.&n; *      Only functionality in this layer is to identify the widget handle&n; *      given the widgetnum. Otherwise, xbow does not gathers any error&n; *      data.&n; */
r_static
r_int
DECL|function|xbow_error_handler
id|xbow_error_handler
c_func
(paren
r_void
op_star
id|einfo
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioerror
)paren
(brace
r_int
id|retval
op_assign
id|IOERROR_WIDGETLEVEL
suffix:semicolon
id|xbow_soft_t
id|soft
op_assign
(paren
id|xbow_soft_t
)paren
id|einfo
suffix:semicolon
r_int
id|port
suffix:semicolon
id|vertex_hdl_t
id|conn
suffix:semicolon
id|vertex_hdl_t
id|busv
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
id|soft-&gt;base
suffix:semicolon
id|xbowreg_t
id|wid_stat
suffix:semicolon
id|xbowreg_t
id|wid_err_cmdword
suffix:semicolon
id|xbowreg_t
id|wid_err_upper
suffix:semicolon
id|xbowreg_t
id|wid_err_lower
suffix:semicolon
r_int
r_int
r_int
id|wid_err_addr
suffix:semicolon
id|xb_linkregs_t
op_star
id|link
suffix:semicolon
id|xbowreg_t
id|link_control
suffix:semicolon
id|xbowreg_t
id|link_status
suffix:semicolon
id|xbowreg_t
id|link_aux_status
suffix:semicolon
id|ASSERT
c_func
(paren
id|soft
op_ne
l_int|0
)paren
suffix:semicolon
id|busv
op_assign
id|soft-&gt;busv
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: xbow_error_handler&bslash;n&quot;
comma
id|soft-&gt;name
comma
id|busv
)paren
suffix:semicolon
macro_line|#endif
id|IOERROR_GETVALUE
c_func
(paren
id|port
comma
id|ioerror
comma
id|widgetnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|0
)paren
(brace
multiline_comment|/* error during access to xbow:&n;&t; * do NOT attempt to access xbow regs.&n;&t; */
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;DMA error blamed on Crossbow at %s&bslash;n&quot;
l_string|&quot;&bslash;tbut Crosbow never initiates DMA!&quot;
comma
id|soft-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
(brace
id|iopaddr_t
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioerror
comma
id|xtalkaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;PIO Error on XIO Bus %s&bslash;n&quot;
l_string|&quot;&bslash;tattempting to access XIO controller&bslash;n&quot;
l_string|&quot;&bslash;twith offset 0x%lx&quot;
comma
id|soft-&gt;name
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* caller will dump contents of ioerror&n;&t; * in DEBUG and kdebug kernels.&n;&t; */
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;     * error not on port zero:&n;     * safe to read xbow registers.&n;     */
id|wid_stat
op_assign
id|xbow-&gt;xb_wid_stat
suffix:semicolon
id|wid_err_cmdword
op_assign
id|xbow-&gt;xb_wid_err_cmdword
suffix:semicolon
id|wid_err_upper
op_assign
id|xbow-&gt;xb_wid_err_upper
suffix:semicolon
id|wid_err_lower
op_assign
id|xbow-&gt;xb_wid_err_lower
suffix:semicolon
id|wid_err_addr
op_assign
id|wid_err_lower
op_or
(paren
(paren
(paren
id|iopaddr_t
)paren
id|wid_err_upper
op_amp
id|WIDGET_ERR_UPPER_ADDR_ONLY
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port
OL
id|BASE_XBOW_PORT
)paren
op_logical_or
(paren
id|port
op_ge
id|MAX_PORT_NUM
)paren
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;DMA error blamed on XIO port at %s/%d&bslash;n&quot;
l_string|&quot;&bslash;tbut Crossbow does not support that port&quot;
comma
id|soft-&gt;name
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
(brace
id|iopaddr_t
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioerror
comma
id|xtalkaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;PIO Error on XIO Bus %s&bslash;n&quot;
l_string|&quot;&bslash;tattempting to access XIO port %d&bslash;n&quot;
l_string|&quot;&bslash;t(which Crossbow does not support)&quot;
l_string|&quot;&bslash;twith offset 0x%lx&quot;
comma
id|soft-&gt;name
comma
id|port
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#if !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;Raw status values for Crossbow:&bslash;n&quot;
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_stat
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_cmdword
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_upper
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_lower
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_addr
)paren
suffix:semicolon
macro_line|#if !DEBUG
)brace
macro_line|#endif
multiline_comment|/* caller will dump contents of ioerror&n;&t; * in DEBUG and kdebug kernels.&n;&t; */
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* access to valid port:&n;     * ok to check port status.&n;     */
id|link
op_assign
op_amp
(paren
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|link_control
op_assign
id|link-&gt;link_control
suffix:semicolon
id|link_status
op_assign
id|link-&gt;link_status
suffix:semicolon
id|link_aux_status
op_assign
id|link-&gt;link_aux_status
suffix:semicolon
multiline_comment|/* Check that there is something present&n;     * in that XIO port.&n;     */
multiline_comment|/* WAR: PIC widget 0xf is missing prescense bit */
r_if
c_cond
(paren
id|XBOW_WAR_ENABLED
c_func
(paren
id|PV854827
comma
id|xbow-&gt;xb_wid_id
)paren
op_logical_and
id|IS_PIC_XBOW
c_func
(paren
id|xbow-&gt;xb_wid_id
)paren
op_logical_and
(paren
id|port
op_eq
l_int|0xf
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|link_aux_status
op_amp
id|XB_AUX_STAT_PRESENT
)paren
)paren
(brace
multiline_comment|/* nobody connected. */
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;DMA error blamed on XIO port at %s/%d&bslash;n&quot;
l_string|&quot;&bslash;tbut there is no device connected there.&quot;
comma
id|soft-&gt;name
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
(brace
id|iopaddr_t
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioerror
comma
id|xtalkaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;PIO Error on XIO Bus %s&bslash;n&quot;
l_string|&quot;&bslash;tattempting to access XIO port %d&bslash;n&quot;
l_string|&quot;&bslash;t(which has no device connected)&quot;
l_string|&quot;&bslash;twith offset 0x%lx&quot;
comma
id|soft-&gt;name
comma
id|port
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#if !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;Raw status values for Crossbow:&bslash;n&quot;
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_stat
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_cmdword
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_upper
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_lower
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_addr
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|port
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_control
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_status
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_aux_status
)paren
suffix:semicolon
macro_line|#if !DEBUG
)brace
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Check that the link is alive.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|link_status
op_amp
id|XB_STAT_LINKALIVE
)paren
)paren
(brace
id|iopaddr_t
id|tmp
suffix:semicolon
multiline_comment|/* nobody connected. */
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s%sError on XIO Bus %s port %d&quot;
comma
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
ques
c_cond
l_string|&quot;DMA &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
ques
c_cond
l_string|&quot;PIO &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|soft-&gt;name
comma
id|port
)paren
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioerror
comma
id|xtalkaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
op_logical_and
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioerror
comma
id|xtalkaddr
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tAccess attempted to offset 0x%lx&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link_aux_status
op_amp
id|XB_AUX_LINKFAIL_RST_BAD
)paren
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLink never came out of reset&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;&bslash;tLink failed while transferring data&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* get the connection point for the widget&n;     * involved in this error; if it exists and&n;     * is not our connectpoint, cycle back through&n;     * xtalk_error_handler to deliver control to&n;     * the proper handler (or to report a generic&n;     * crosstalk error).&n;     *&n;     * If the downstream handler won&squot;t handle&n;     * the problem, we let our upstream caller&n;     * deal with it, after (in DEBUG and kdebug&n;     * kernels) dumping the xbow state for this&n;     * port.&n;     */
id|conn
op_assign
id|xbow_widget_lookup
c_func
(paren
id|busv
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conn
op_ne
id|GRAPH_VERTEX_NONE
)paren
op_logical_and
(paren
id|conn
op_ne
id|soft-&gt;conn
)paren
)paren
(brace
id|retval
op_assign
id|xtalk_error_handler
c_func
(paren
id|conn
comma
id|error_code
comma
id|mode
comma
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IOERROR_HANDLED
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
r_return
id|IOERROR_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IOERROR_UNHANDLED
)paren
(brace
id|iopaddr_t
id|tmp
suffix:semicolon
id|retval
op_assign
id|IOERROR_PANIC
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s%sError on XIO Bus %s port %d&quot;
comma
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
ques
c_cond
l_string|&quot;DMA &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
ques
c_cond
l_string|&quot;PIO &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|soft-&gt;name
comma
id|port
)paren
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioerror
comma
id|xtalkaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
op_logical_and
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioerror
comma
id|xtalkaddr
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tAccess attempted to offset 0x%lx&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
)brace
macro_line|#if !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
id|XEM_ADD_STR
c_func
(paren
l_string|&quot;Raw status values for Crossbow:&bslash;n&quot;
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_stat
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_cmdword
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_upper
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_lower
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|wid_err_addr
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|port
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_control
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_status
)paren
suffix:semicolon
id|XEM_ADD_VAR
c_func
(paren
id|link_aux_status
)paren
suffix:semicolon
macro_line|#if !DEBUG
)brace
macro_line|#endif
multiline_comment|/* caller will dump raw ioerror data&n;     * in DEBUG and kdebug kernels.&n;     */
r_return
id|retval
suffix:semicolon
)brace
r_void
DECL|function|xbow_update_perf_counters
id|xbow_update_perf_counters
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_t
op_star
id|xbow_perf
op_assign
id|xbow_soft-&gt;xbow_perfcnt
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_plink
op_assign
id|xbow_soft-&gt;xbow_perflink
suffix:semicolon
id|xbow_perfcount_t
id|perf_reg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|link
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XBOW_PERF_COUNTERS
suffix:semicolon
id|i
op_increment
comma
id|xbow_perf
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xbow_perf-&gt;xp_mode
op_eq
id|XBOW_MONITOR_NONE
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
id|perf_reg.xb_counter_val
op_assign
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
suffix:semicolon
id|link
op_assign
id|perf_reg.xb_perf.link_select
suffix:semicolon
(paren
id|xbow_plink
op_plus
id|link
)paren
op_member_access_from_pointer
id|xlp_cumulative
(braket
id|xbow_perf-&gt;xp_curmode
)braket
op_add_assign
(paren
(paren
id|perf_reg.xb_perf.count
op_minus
id|xbow_perf-&gt;xp_current
)paren
op_amp
id|XBOW_COUNTER_MASK
)paren
suffix:semicolon
id|xbow_perf-&gt;xp_current
op_assign
id|perf_reg.xb_perf.count
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
)brace
)brace
id|xbow_perf_link_t
op_star
DECL|function|xbow_get_perf_counters
id|xbow_get_perf_counters
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_perf_link
op_assign
id|xbow_soft-&gt;xbow_perflink
suffix:semicolon
r_return
id|xbow_perf_link
suffix:semicolon
)brace
r_int
DECL|function|xbow_enable_perf_counter
id|xbow_enable_perf_counter
c_func
(paren
id|vertex_hdl_t
id|vhdl
comma
r_int
id|link
comma
r_int
id|mode
comma
r_int
id|counter
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_t
op_star
id|xbow_perf
op_assign
id|xbow_soft-&gt;xbow_perfcnt
suffix:semicolon
id|xbow_linkctrl_t
id|xbow_link_ctrl
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
id|xbow_soft-&gt;base
suffix:semicolon
id|xbow_perfcount_t
id|perf_reg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
id|link
op_sub_assign
id|BASE_XBOW_PORT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|link
OL
l_int|0
)paren
op_logical_or
(paren
id|link
op_ge
id|MAX_XBOW_PORTS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
OL
id|XBOW_MONITOR_NONE
)paren
op_logical_or
(paren
id|mode
OG
id|XBOW_MONITOR_DEST_LINK
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|counter
OL
l_int|0
)paren
op_logical_or
(paren
id|counter
op_ge
id|XBOW_PERF_COUNTERS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xbow_perf
op_plus
id|counter
)paren
op_member_access_from_pointer
id|xp_mode
op_logical_and
id|mode
)paren
(brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XBOW_PERF_COUNTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|counter
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|xbow_perf
op_plus
id|i
)paren
op_member_access_from_pointer
id|xp_link
op_eq
id|link
)paren
op_logical_and
(paren
(paren
id|xbow_perf
op_plus
id|i
)paren
op_member_access_from_pointer
id|xp_mode
)paren
)paren
(brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|xbow_perf
op_add_assign
id|counter
suffix:semicolon
id|xbow_perf-&gt;xp_curlink
op_assign
id|xbow_perf-&gt;xp_link
op_assign
id|link
suffix:semicolon
id|xbow_perf-&gt;xp_curmode
op_assign
id|xbow_perf-&gt;xp_mode
op_assign
id|mode
suffix:semicolon
id|xbow_link_ctrl.xbl_ctrlword
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_control
suffix:semicolon
id|xbow_link_ctrl.xb_linkcontrol.perf_mode
op_assign
id|mode
suffix:semicolon
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_control
op_assign
id|xbow_link_ctrl.xbl_ctrlword
suffix:semicolon
id|perf_reg.xb_counter_val
op_assign
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
suffix:semicolon
id|perf_reg.xb_perf.link_select
op_assign
id|link
suffix:semicolon
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
op_assign
id|perf_reg.xb_counter_val
suffix:semicolon
id|xbow_perf-&gt;xp_current
op_assign
id|perf_reg.xb_perf.count
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xbow_link_status_t
op_star
DECL|function|xbow_get_llp_status
id|xbow_get_llp_status
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_llp_status
op_assign
id|xbow_soft-&gt;xbow_link_status
suffix:semicolon
r_return
id|xbow_llp_status
suffix:semicolon
)brace
r_void
DECL|function|xbow_update_llp_status
id|xbow_update_llp_status
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_llp_status
op_assign
id|xbow_soft-&gt;xbow_link_status
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbwX_stat_t
id|lnk_sts
suffix:semicolon
id|xbow_aux_link_status_t
id|aux_sts
suffix:semicolon
r_int
id|link
suffix:semicolon
id|vertex_hdl_t
id|xwidget_vhdl
suffix:semicolon
r_char
op_star
id|xwidget_name
suffix:semicolon
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xbow_soft-&gt;base
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|link
op_increment
comma
id|xbow_llp_status
op_increment
)paren
(brace
multiline_comment|/* Get the widget name corresponding the current link.&n;&t; * Note : 0 &lt;= link &lt; MAX_XBOW_PORTS(8).&n;&t; * &t;  BASE_XBOW_PORT(0x8) &lt;= xwidget number &lt; MAX_PORT_NUM (0x10)&n;&t; */
id|xwidget_vhdl
op_assign
id|xbow_widget_lookup
c_func
(paren
id|xbow_soft-&gt;busv
comma
id|link
op_plus
id|BASE_XBOW_PORT
)paren
suffix:semicolon
id|xwidget_name
op_assign
id|xwidget_name_get
c_func
(paren
id|xwidget_vhdl
)paren
suffix:semicolon
id|aux_sts.aux_linkstatus
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_aux_status
suffix:semicolon
id|lnk_sts.linkstatus
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_status_clr
suffix:semicolon
r_if
c_cond
(paren
id|lnk_sts.link_alive
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|xbow_llp_status-&gt;rx_err_count
op_add_assign
id|aux_sts.xb_aux_linkstatus.rx_err_cnt
suffix:semicolon
id|xbow_llp_status-&gt;tx_retry_count
op_add_assign
id|aux_sts.xb_aux_linkstatus.tx_retry_cnt
suffix:semicolon
r_if
c_cond
(paren
id|lnk_sts.linkstatus
op_amp
op_complement
(paren
id|XB_STAT_RCV_ERR
op_or
id|XB_STAT_XMT_RTRY_ERR
op_or
id|XB_STAT_LINKALIVE
)paren
)paren
(brace
macro_line|#ifdef&t;LATER
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;link %d[%s]: bad status 0x%x&bslash;n&quot;
comma
id|link
comma
id|xwidget_name
comma
id|lnk_sts.linkstatus
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
r_int
DECL|function|xbow_disable_llp_monitor
id|xbow_disable_llp_monitor
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_int
id|port
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|port
op_increment
)paren
(brace
id|xbow_soft-&gt;xbow_link_status
(braket
id|port
)braket
dot
id|rx_err_count
op_assign
l_int|0
suffix:semicolon
id|xbow_soft-&gt;xbow_link_status
(braket
id|port
)braket
dot
id|tx_retry_count
op_assign
l_int|0
suffix:semicolon
)brace
id|xbow_soft-&gt;link_monitor
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xbow_enable_llp_monitor
id|xbow_enable_llp_monitor
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_soft-&gt;link_monitor
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xbow_reset_link
id|xbow_reset_link
c_func
(paren
id|vertex_hdl_t
id|xconn_vhdl
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
id|xwidgetnum_t
id|port
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbowreg_t
id|ctrl
suffix:semicolon
id|xbwX_stat_t
id|stat
suffix:semicolon
r_int
id|itick
suffix:semicolon
r_int
id|dtick
suffix:semicolon
r_static
r_int
id|ticks_per_ms
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ticks_per_ms
)paren
(brace
id|itick
op_assign
id|get_timestamp
c_func
(paren
)paren
suffix:semicolon
id|us_delay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ticks_per_ms
op_assign
id|get_timestamp
c_func
(paren
)paren
op_minus
id|itick
suffix:semicolon
)brace
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|port
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
macro_line|#ifdef XBOW_K1PTR&t;&t;&t;/* defined if we only have one xbow ... */
id|xbow
op_assign
id|XBOW_K1PTR
suffix:semicolon
macro_line|#else
(brace
id|vertex_hdl_t
id|xbow_vhdl
suffix:semicolon
id|xbow_soft_t
id|xbow_soft
suffix:semicolon
id|hwgraph_traverse
c_func
(paren
id|xconn_vhdl
comma
l_string|&quot;.master/xtalk/0/xbow&quot;
comma
op_amp
id|xbow_vhdl
)paren
suffix:semicolon
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|xbow_vhdl
)paren
suffix:semicolon
id|xbow
op_assign
id|xbow_soft-&gt;base
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;     * This requires three PIOs (reset the link, check for the&n;     * reset, restore the control register for the link) plus&n;     * 10us to wait for the reset. We allow up to 1ms for the&n;     * widget to come out of reset before giving up and&n;     * returning a failure.&n;     */
id|ctrl
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
suffix:semicolon
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_reset
op_assign
l_int|0
suffix:semicolon
id|itick
op_assign
id|get_timestamp
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|stat.linkstatus
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
suffix:semicolon
r_if
c_cond
(paren
id|stat.link_alive
)paren
r_break
suffix:semicolon
id|dtick
op_assign
id|get_timestamp
c_func
(paren
)paren
op_minus
id|itick
suffix:semicolon
r_if
c_cond
(paren
id|dtick
OG
id|ticks_per_ms
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* never came out of reset */
)brace
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* don&squot;t beat on link_status */
)brace
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
id|ctrl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|XBOW_ARB_RELOAD_TICKS
mdefine_line|#define XBOW_ARB_RELOAD_TICKS&t;&t;25
multiline_comment|/* granularity: 4 MB/s, max: 124 MB/s */
DECL|macro|GRANULARITY
mdefine_line|#define GRANULARITY&t;&t;&t;((100 * 1000000) / XBOW_ARB_RELOAD_TICKS)
DECL|macro|XBOW_BYTES_TO_GBR
mdefine_line|#define XBOW_BYTES_TO_GBR(BYTES_per_s)&t;(int) (BYTES_per_s / GRANULARITY)
DECL|macro|XBOW_GBR_TO_BYTES
mdefine_line|#define XBOW_GBR_TO_BYTES(cnt)&t;&t;(bandwidth_t) ((cnt) * GRANULARITY)
DECL|macro|CEILING_BYTES_TO_GBR
mdefine_line|#define CEILING_BYTES_TO_GBR(gbr, bytes_per_sec)&t;&bslash;&n;&t;&t;&t;((XBOW_GBR_TO_BYTES(gbr) &lt; bytes_per_sec) ? gbr+1 : gbr)
DECL|macro|XBOW_ARB_GBR_MAX
mdefine_line|#define XBOW_ARB_GBR_MAX&t;&t;31
DECL|macro|ABS
mdefine_line|#define ABS(x)&t;&t;&t;&t;((x &gt; 0) ? (x) : (-1 * x))
multiline_comment|/* absolute value */
r_int
DECL|function|xbow_bytes_to_gbr
id|xbow_bytes_to_gbr
c_func
(paren
id|bandwidth_t
id|old_bytes_per_sec
comma
id|bandwidth_t
id|bytes_per_sec
)paren
(brace
r_int
id|gbr_granted
suffix:semicolon
r_int
id|new_total_gbr
suffix:semicolon
r_int
id|change_gbr
suffix:semicolon
id|bandwidth_t
id|new_total_bw
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;xbow_bytes_to_gbr: old_bytes_per_sec %lld bytes_per_sec %lld&bslash;n&quot;
comma
id|old_bytes_per_sec
comma
id|bytes_per_sec
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
id|gbr_granted
op_assign
id|CEILING_BYTES_TO_GBR
c_func
(paren
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|old_bytes_per_sec
)paren
)paren
comma
id|old_bytes_per_sec
)paren
suffix:semicolon
id|new_total_bw
op_assign
id|old_bytes_per_sec
op_plus
id|bytes_per_sec
suffix:semicolon
id|new_total_gbr
op_assign
id|CEILING_BYTES_TO_GBR
c_func
(paren
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|new_total_bw
)paren
)paren
comma
id|new_total_bw
)paren
suffix:semicolon
id|change_gbr
op_assign
id|new_total_gbr
op_minus
id|gbr_granted
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;xbow_bytes_to_gbr: gbr_granted %d new_total_gbr %d change_gbr %d&bslash;n&quot;
comma
id|gbr_granted
comma
id|new_total_gbr
comma
id|change_gbr
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
r_return
(paren
id|change_gbr
)paren
suffix:semicolon
)brace
multiline_comment|/* Conversion from GBR to bytes */
id|bandwidth_t
DECL|function|xbow_gbr_to_bytes
id|xbow_gbr_to_bytes
c_func
(paren
r_int
id|gbr
)paren
(brace
r_return
(paren
id|XBOW_GBR_TO_BYTES
c_func
(paren
id|gbr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Given the vhdl for the desired xbow, the src and dest. widget ids&n; * and the req_bw value, this xbow driver entry point accesses the&n; * xbow registers and allocates the desired bandwidth if available.&n; *&n; * If bandwidth allocation is successful, return success else return failure.&n; */
r_int
DECL|function|xbow_prio_bw_alloc
id|xbow_prio_bw_alloc
c_func
(paren
id|vertex_hdl_t
id|vhdl
comma
id|xwidgetnum_t
id|src_wid
comma
id|xwidgetnum_t
id|dest_wid
comma
r_int
r_int
r_int
id|old_alloc_bw
comma
r_int
r_int
r_int
id|req_bw
)paren
(brace
id|xbow_soft_t
id|soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_volatile
id|xbowreg_t
op_star
id|xreg
suffix:semicolon
id|xbowreg_t
id|mask
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|bandwidth_t
id|old_bw_BYTES
comma
id|req_bw_BYTES
suffix:semicolon
id|xbowreg_t
id|old_xreg
suffix:semicolon
r_int
id|old_bw_GBR
comma
id|req_bw_GBR
comma
id|new_bw_GBR
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;xbow_prio_bw_alloc: vhdl %d src_wid %d dest_wid %d req_bw %lld&bslash;n&quot;
comma
(paren
r_int
)paren
id|vhdl
comma
(paren
r_int
)paren
id|src_wid
comma
(paren
r_int
)paren
id|dest_wid
comma
id|req_bw
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|XBOW_WIDGET_IS_VALID
c_func
(paren
id|src_wid
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XBOW_WIDGET_IS_VALID
c_func
(paren
id|dest_wid
)paren
)paren
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
)paren
suffix:semicolon
multiline_comment|/* Get pointer to the correct register */
id|xreg
op_assign
id|XBOW_PRIO_ARBREG_PTR
c_func
(paren
id|soft-&gt;base
comma
id|dest_wid
comma
id|src_wid
)paren
suffix:semicolon
multiline_comment|/* Get mask for GBR count value */
id|mask
op_assign
id|XB_ARB_GBR_MSK
op_lshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
suffix:semicolon
id|req_bw_GBR
op_assign
id|xbow_bytes_to_gbr
c_func
(paren
id|old_alloc_bw
comma
id|req_bw
)paren
suffix:semicolon
id|req_bw_BYTES
op_assign
(paren
id|req_bw_GBR
OL
l_int|0
)paren
ques
c_cond
(paren
op_minus
l_int|1
op_star
id|xbow_gbr_to_bytes
c_func
(paren
id|ABS
c_func
(paren
id|req_bw_GBR
)paren
)paren
)paren
suffix:colon
id|xbow_gbr_to_bytes
c_func
(paren
id|req_bw_GBR
)paren
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;req_bw %lld req_bw_BYTES %lld req_bw_GBR %d&bslash;n&quot;
comma
id|req_bw
comma
id|req_bw_BYTES
comma
id|req_bw_GBR
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
id|old_bw_BYTES
op_assign
id|soft-&gt;bw_cur_used
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
id|old_xreg
op_assign
op_star
id|xreg
suffix:semicolon
id|old_bw_GBR
op_assign
(paren
(paren
(paren
op_star
id|xreg
)paren
op_amp
id|mask
)paren
op_rshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
)paren
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|ASSERT
c_func
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|old_bw_BYTES
)paren
op_eq
id|old_bw_GBR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;old_bw_BYTES %lld old_bw_GBR %d&bslash;n&quot;
comma
id|old_bw_BYTES
comma
id|old_bw_GBR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;req_bw_BYTES %lld old_bw_BYTES %lld soft-&gt;bw_hiwm %lld&bslash;n&quot;
comma
id|req_bw_BYTES
comma
id|old_bw_BYTES
comma
id|soft-&gt;bw_hiwm
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* GRIO_DEBUG */
multiline_comment|/* Accept the request only if we don&squot;t exceed the destination&n;     * port HIWATER_MARK *AND* the max. link GBR arbitration count&n;     */
r_if
c_cond
(paren
(paren
(paren
id|old_bw_BYTES
op_plus
id|req_bw_BYTES
)paren
op_le
id|soft-&gt;bw_hiwm
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
)paren
op_logical_and
(paren
id|req_bw_GBR
op_plus
id|old_bw_GBR
op_le
id|XBOW_ARB_GBR_MAX
)paren
)paren
(brace
id|new_bw_GBR
op_assign
(paren
id|old_bw_GBR
op_plus
id|req_bw_GBR
)paren
suffix:semicolon
multiline_comment|/* Set this in the xbow link register */
op_star
id|xreg
op_assign
(paren
id|old_xreg
op_amp
op_complement
id|mask
)paren
op_or
"&bslash;"
(paren
id|new_bw_GBR
op_lshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
op_amp
id|mask
)paren
suffix:semicolon
id|soft-&gt;bw_cur_used
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
op_assign
id|xbow_gbr_to_bytes
c_func
(paren
id|new_bw_GBR
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
l_int|1
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
comma
id|s
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
eof
