multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#ifdef __ia64
DECL|macro|rmallocmap
mdefine_line|#define rmallocmap atemapalloc
DECL|macro|rmfreemap
mdefine_line|#define rmfreemap atemapfree
DECL|macro|rmfree
mdefine_line|#define rmfree atefree
DECL|macro|rmalloc
mdefine_line|#define rmalloc atealloc
macro_line|#endif
r_int
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
)paren
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_intr_line_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_int
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
comma
r_int
comma
id|xwidgetnum_t
comma
id|iopaddr_t
comma
id|xtalk_intr_vector_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_func
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    INTERRUPT MANAGEMENT&n; */
r_int
DECL|function|pcibr_intr_bits
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
)paren
(brace
id|pciio_slot_t
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|info
)paren
suffix:semicolon
r_int
id|bbits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Currently favored mapping from PCI&n;     * slot number and INTA/B/C/D to Bridge&n;     * PCI Interrupt Bit Number:&n;     *&n;     *     SLOT     A B C D&n;     *      0       0 4 0 4&n;     *      1       1 5 1 5&n;     *      2       2 6 2 6&n;     *      3       3 7 3 7&n;     *      4       4 0 4 0&n;     *      5       5 1 5 1&n;     *      6       6 2 6 2&n;     *      7       7 3 7 3&n;     */
r_if
c_cond
(paren
id|slot
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_A
op_or
id|PCIIO_INTR_LINE_C
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_B
op_or
id|PCIIO_INTR_LINE_D
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
(paren
id|slot
op_xor
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|bbits
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get the next wrapper pointer queued in the interrupt circular buffer.&n; */
id|pcibr_intr_wrap_t
DECL|function|pcibr_wrap_get
id|pcibr_wrap_get
c_func
(paren
id|pcibr_intr_cbuf_t
id|cbuf
)paren
(brace
id|pcibr_intr_wrap_t
id|wrap
suffix:semicolon
r_if
c_cond
(paren
id|cbuf-&gt;ib_in
op_eq
id|cbuf-&gt;ib_out
)paren
id|PRINT_PANIC
c_func
(paren
l_string|&quot;pcibr intr circular buffer empty, cbuf=0x%p, ib_in=ib_out=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|cbuf
comma
id|cbuf-&gt;ib_out
)paren
suffix:semicolon
id|wrap
op_assign
id|cbuf-&gt;ib_cbuf
(braket
id|cbuf-&gt;ib_out
op_increment
)braket
suffix:semicolon
id|cbuf-&gt;ib_out
op_assign
id|cbuf-&gt;ib_out
op_mod
id|IBUFSIZE
suffix:semicolon
r_return
id|wrap
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Queue a wrapper pointer in the interrupt circular buffer.&n; */
r_void
DECL|function|pcibr_wrap_put
id|pcibr_wrap_put
c_func
(paren
id|pcibr_intr_wrap_t
id|wrap
comma
id|pcibr_intr_cbuf_t
id|cbuf
)paren
(brace
r_int
id|in
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * Multiple CPUs could be executing this code simultaneously&n;&t; * if a handler has registered multiple interrupt lines and&n;&t; * the interrupts are directed to different CPUs.&n;&t; */
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|cbuf-&gt;ib_lock
)paren
suffix:semicolon
id|in
op_assign
(paren
id|cbuf-&gt;ib_in
op_plus
l_int|1
)paren
op_mod
id|IBUFSIZE
suffix:semicolon
r_if
c_cond
(paren
id|in
op_eq
id|cbuf-&gt;ib_out
)paren
id|PRINT_PANIC
c_func
(paren
l_string|&quot;pcibr intr circular buffer full, cbuf=0x%p, ib_in=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|cbuf
comma
id|cbuf-&gt;ib_in
)paren
suffix:semicolon
id|cbuf-&gt;ib_cbuf
(braket
id|cbuf-&gt;ib_in
)braket
op_assign
id|wrap
suffix:semicolon
id|cbuf-&gt;ib_in
op_assign
id|in
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|cbuf-&gt;ib_lock
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;There are end cases where a deadlock can occur if interrupt &n; *&t;processing completes and the Bridge b_int_status bit is still set.&n; *&n; *&t;One scenerio is if a second PCI interrupt occurs within 60ns of&n; *&t;the previous interrupt being cleared. In this case the Bridge&n; *&t;does not detect the transition, the Bridge b_int_status bit&n; *&t;remains set, and because no transition was detected no interrupt&n; *&t;packet is sent to the Hub/Heart.&n; *&n; *&t;A second scenerio is possible when a b_int_status bit is being&n; *&t;shared by multiple devices:&n; *&t;&t;&t;&t;&t;&t;Device #1 generates interrupt&n; *&t;&t;&t;&t;&t;&t;Bridge b_int_status bit set&n; *&t;&t;&t;&t;&t;&t;Device #2 generates interrupt&n; *&t;&t;interrupt processing begins&n; *&t;&t;  ISR for device #1 runs and&n; *&t;&t;&t;clears interrupt&n; *&t;&t;&t;&t;&t;&t;Device #1 generates interrupt&n; *&t;&t;  ISR for device #2 runs and&n; *&t;&t;&t;clears interrupt&n; *&t;&t;&t;&t;&t;&t;(b_int_status bit still set)&n; *&t;&t;interrupt processing completes&n; *&t;&t;  &n; *&t;Interrupt processing is now complete, but an interrupt is still&n; *&t;outstanding for Device #1. But because there was no transition of&n; *&t;the b_int_status bit, no interrupt packet will be generated and&n; *&t;a deadlock will occur.&n; *&n; *&t;To avoid these deadlock situations, this function is used&n; *&t;to check if a specific Bridge b_int_status bit is set, and if so,&n; *&t;cause the setting of the corresponding interrupt bit.&n; *&n; *&t;On a XBridge (IP35), we do this by writing the appropriate Bridge Force &n; *&t;Interrupt register.&n; */
r_void
DECL|function|pcibr_force_interrupt
id|pcibr_force_interrupt
c_func
(paren
id|pcibr_intr_wrap_t
id|wrap
)paren
(brace
r_int
id|bit
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|wrap-&gt;iw_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|cpuid_t
id|cpuvertex_to_cpuid
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
suffix:semicolon
id|bit
op_assign
id|wrap-&gt;iw_intr
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
id|bridge-&gt;b_force_pin
(braket
id|bit
)braket
dot
id|intr
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|bit
)paren
op_amp
op_star
id|wrap-&gt;iw_stat
)paren
(brace
id|cpuid_t
id|cpu
suffix:semicolon
r_int
id|intr_bit
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
id|intr_bit
op_assign
(paren
r_int
)paren
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|cpu
op_assign
id|cpuvertex_to_cpuid
c_func
(paren
id|xtalk_intr_cpu_get
c_func
(paren
id|xtalk_intr
)paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
id|REMOTE_CPU_SEND_INTR
c_func
(paren
id|cpu
comma
id|intr_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*ARGSUSED */
id|pcibr_intr_t
DECL|function|pcibr_intr_alloc
id|pcibr_intr_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_intr_line_t
id|lines
comma
id|devfs_handle_t
id|owner_dev
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pcibr_info-&gt;f_slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pcibr_info-&gt;f_mfast
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|is_threaded
op_assign
l_int|0
suffix:semicolon
r_int
id|thread_swlevel
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intr_p
suffix:semicolon
id|pcibr_intr_t
op_star
id|pcibr_intr_p
suffix:semicolon
id|pcibr_intr_list_t
op_star
id|intr_list_p
suffix:semicolon
r_int
id|pcibr_int_bits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
op_assign
(paren
id|xtalk_intr_t
)paren
l_int|0
suffix:semicolon
id|hub_intr_t
id|hub_intr
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr
suffix:semicolon
id|pcibr_intr_list_t
id|intr_entry
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pcibr_intr_alloc&bslash;n&quot;
l_string|&quot;%v:%s%s%s%s%s&bslash;n&quot;
comma
id|owner_dev
comma
id|pconn_vhdl
comma
op_logical_neg
(paren
id|lines
op_amp
l_int|15
)paren
ques
c_cond
l_string|&quot; No INTs?&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|1
ques
c_cond
l_string|&quot; INTA&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|2
ques
c_cond
l_string|&quot; INTB&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|4
ques
c_cond
l_string|&quot; INTC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|8
ques
c_cond
l_string|&quot; INTD&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NEW
c_func
(paren
id|pcibr_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_intr
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev_desc
)paren
(brace
id|cpuid_t
id|intr_target_from_desc
c_func
(paren
id|device_desc_t
comma
r_int
)paren
suffix:semicolon
)brace
r_else
(brace
r_extern
r_int
id|default_intr_pri
suffix:semicolon
id|is_threaded
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* PCI interrupts are threaded, by default */
id|thread_swlevel
op_assign
id|default_intr_pri
suffix:semicolon
)brace
id|pcibr_intr-&gt;bi_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_intr-&gt;bi_lines
op_assign
id|lines
suffix:semicolon
id|pcibr_intr-&gt;bi_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_intr-&gt;bi_ibits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bits will be added below */
id|pcibr_intr-&gt;bi_flags
op_assign
id|is_threaded
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_INTR_NOTHREAD
suffix:semicolon
id|pcibr_intr-&gt;bi_mustruncpu
op_assign
id|CPU_NONE
suffix:semicolon
id|pcibr_intr-&gt;bi_ibuf.ib_in
op_assign
l_int|0
suffix:semicolon
id|pcibr_intr-&gt;bi_ibuf.ib_out
op_assign
l_int|0
suffix:semicolon
id|mutex_spinlock_init
c_func
(paren
op_amp
id|pcibr_intr-&gt;bi_ibuf.ib_lock
)paren
suffix:semicolon
id|pcibr_int_bits
op_assign
id|pcibr_soft
op_member_access_from_pointer
id|bs_intr_bits
c_func
(paren
(paren
id|pciio_info_t
)paren
id|pcibr_info
comma
id|lines
)paren
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_int_bits: 0x%X&bslash;n&quot;
comma
id|pcibr_int_bits
)paren
suffix:semicolon
macro_line|#endif 
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|xtalk_intr_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This xtalk_intr_alloc is constrained for two reasons:&n;&t;&t; * 1) Normal interrupts and error interrupts need to be delivered&n;&t;&t; *    through a single xtalk target widget so that there aren&squot;t any&n;&t;&t; *    ordering problems with DMA, completion interrupts, and error&n;&t;&t; *    interrupts. (Use of xconn_vhdl forces this.)&n;&t;&t; *&n;&t;&t; * 2) On IP35, addressing constraints on IP35 and Bridge force&n;&t;&t; *    us to use a single PI number for all interrupts from a&n;&t;&t; *    single Bridge. (IP35-specific code forces this, and we&n;&t;&t; *    verify in pcibr_setwidint.)&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * All code dealing with threaded PCI interrupt handlers&n;&t;&t; * is located at the pcibr level. Because of this,&n;&t;&t; * we always want the lower layers (hub/heart_intr_alloc, &n;&t;&t; * intr_level_connect) to treat us as non-threaded so we&n;&t;&t; * don&squot;t set up a duplicate threaded environment. We make&n;&t;&t; * this happen by calling a special xtalk interface.&n;&t;&t; */
id|xtalk_intr
op_assign
id|xtalk_intr_alloc_nothd
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|owner_dev
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: xtalk_intr=0x%X&bslash;n&quot;
comma
id|xconn_vhdl
comma
id|xtalk_intr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* both an assert and a runtime check on this:&n;&t;&t; * we need to check in non-DEBUG kernels, and&n;&t;&t; * the ASSERT gets us more information when&n;&t;&t; * we use DEBUG kernels.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* it is quite possible that our&n;&t;&t;     * xtalk_intr_alloc failed because&n;&t;&t;     * someone else got there first,&n;&t;&t;     * and we can find their results&n;&t;&t;     * in xtalk_intr_p.&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
op_star
id|xtalk_intr_p
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc %v: unable to get xtalk interrupt resources&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc 0x%p: unable to get xtalk interrupt resources&quot;
comma
(paren
r_void
op_star
)paren
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|xtalk_intr_p
comma
l_int|NULL
comma
id|xtalk_intr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;     * now tell the bridge which slot is&n;&t;&t;     * using this interrupt line.&n;&t;&t;     */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|int_dev
op_or_assign
id|pciio_slot
op_lshift
id|BRIDGE_INT_DEV_SHFT
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
multiline_comment|/* XXXMP */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: bridge intr bit %d clears my wrb&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* someone else got one allocated first;&n;&t;&t;     * free the one we just created, and&n;&t;&t;     * retrieve the one they allocated.&n;&t;&t;     */
id|xtalk_intr_free
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
macro_line|#if PARANOID
multiline_comment|/* once xtalk_intr is set, we never clear it,&n;&t;&t;     * so if the CAS fails above, this condition&n;&t;&t;     * can &quot;never happen&quot; ...&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|xtalk_intr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc %v: unable to set xtalk interrupt resources&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
id|pcibr_intr-&gt;bi_ibits
op_or_assign
l_int|1
op_lshift
id|pcibr_int_bit
suffix:semicolon
id|NEW
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
id|intr_entry-&gt;il_next
op_assign
l_int|NULL
suffix:semicolon
id|intr_entry-&gt;il_intr
op_assign
id|pcibr_intr
suffix:semicolon
id|intr_entry-&gt;il_wrbf
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
id|intr_list_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
l_string|&quot;0x%x: Bridge bit %d wrap=0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bit
comma
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%v: Bridge bit %d wrap=0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bit
comma
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the first interrupt on this bridge bit.&n;&t;&t; */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) allocated [FIRST]&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* first entry on list was erased,&n;&t;&t; * and we replaced it, so we&n;&t;&t; * don&squot;t need our intr_entry.&n;&t;&t; */
id|DEL
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) replaces erased first&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the new second interrupt on this bit.&n;&t;&t; */
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) is new SECOND&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* an entry on list was erased,&n;&t;&t;     * and we replaced it, so we&n;&t;&t;     * don&squot;t need our intr_entry.&n;&t;&t;     */
id|DEL
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) replaces erased Nth&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* entry appended to share list&n;&t;&t;     */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) is new Nth&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* step to next record in chain&n;&t;&t; */
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
)brace
)brace
)brace
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v pcibr_intr_alloc complete&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
id|hub_intr
op_assign
(paren
id|hub_intr_t
)paren
id|xtalk_intr
suffix:semicolon
id|pcibr_intr-&gt;bi_irq
op_assign
id|hub_intr-&gt;i_bit
suffix:semicolon
id|pcibr_intr-&gt;bi_cpu
op_assign
id|hub_intr-&gt;i_cpuid
suffix:semicolon
r_return
id|pcibr_intr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_free
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
r_int
id|intr_shared
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intrp
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
r_for
c_loop
(paren
id|intr_list
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
suffix:semicolon
id|intr_list
op_ne
l_int|NULL
suffix:semicolon
id|intr_list
op_assign
id|intr_list-&gt;il_next
)paren
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|intr_list-&gt;il_intr
comma
id|pcibr_intr
comma
l_int|NULL
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: cleared a handler from bit %d&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* If this interrupt line is not being shared between multiple&n;&t;     * devices release the xtalk interrupt resources.&n;&t;     */
id|intr_shared
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
suffix:semicolon
id|xtalk_intrp
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|intr_shared
)paren
op_logical_and
(paren
op_star
id|xtalk_intrp
)paren
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
id|xtalk_intr_free
c_func
(paren
op_star
id|xtalk_intrp
)paren
suffix:semicolon
op_star
id|xtalk_intrp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the PCI device interrupt to bridge interrupt pin&n;&t;&t; * mapping.&n;&t;&t; */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
)brace
)brace
)brace
id|DEL
c_func
(paren
id|pcibr_intr
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_setpciint
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|bridgereg_t
op_star
id|int_addr
op_assign
(paren
id|bridgereg_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
op_star
id|int_addr
op_assign
(paren
(paren
id|BRIDGE_INT_ADDR_HOST
op_amp
(paren
id|addr
op_rshift
l_int|30
)paren
)paren
op_or
(paren
id|BRIDGE_INT_ADDR_FLD
op_amp
id|vect
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_intr_connect
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_intr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pcibr_intr_connect&bslash;n&quot;
comma
id|pcibr_intr-&gt;bi_dev
)paren
suffix:semicolon
macro_line|#endif
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_or_assign
id|PCIIO_INTR_CONNECTED
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
id|xtalk_intr
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
multiline_comment|/*&n;&t;     * If this interrupt line is being shared and the connect has&n;&t;     * already been done, no need to do it again.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;     * Use the pcibr wrapper function to handle all Bridge interrupts&n;&t;     * regardless of whether the interrupt line is shared or not.&n;&t;     */
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;b_int_addr
(braket
id|pcibr_int_bit
)braket
dot
id|addr
)paren
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v bridge bit %d wrapper connected&bslash;n&quot;
comma
id|pcibr_intr-&gt;bi_dev
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_or_assign
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_disconnect
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* Stop calling the function. Now.&n;     */
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_and_assign
op_complement
id|PCIIO_INTR_CONNECTED
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and disconnect the interrupt.&n;     */
multiline_comment|/* don&squot;t disable interrupts for lines that&n;     * are shared between devices.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
)paren
id|pcibr_int_bits
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_int_bits
)paren
r_return
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_and_assign
op_complement
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
multiline_comment|/* if the interrupt line is now shared,&n;&t;     * do not disconnect it.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
r_continue
suffix:semicolon
id|xtalk_intr_disconnect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: xtalk disconnect done for Bridge bit %d&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* if we are sharing the interrupt line,&n;&t;     * connect us up; this closes the hole&n;&t;     * where the another pcibr_intr_alloc()&n;&t;     * was in progress as we disconnected.&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
r_continue
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;b_int_addr
(braket
id|pcibr_int_bit
)braket
dot
id|addr
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*ARGSUSED */
id|devfs_handle_t
DECL|function|pcibr_intr_cpu_get
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
r_return
id|xtalk_intr_cpu_get
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    INTERRUPT HANDLING&n; */
r_void
DECL|function|pcibr_clearwidint
id|pcibr_clearwidint
c_func
(paren
id|bridge_t
op_star
id|bridge
)paren
(brace
id|bridge-&gt;b_wid_int_upper
op_assign
l_int|0
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_setwidint
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
id|intr
)paren
(brace
id|xwidgetnum_t
id|targ
op_assign
id|xtalk_intr_target_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|widgetreg_t
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
suffix:semicolon
id|widgetreg_t
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|NEW_b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|NEW_b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|OLD_b_wid_int_upper
op_assign
id|bridge-&gt;b_wid_int_upper
suffix:semicolon
id|OLD_b_wid_int_lower
op_assign
id|bridge-&gt;b_wid_int_lower
suffix:semicolon
multiline_comment|/* Verify that all interrupts from this Bridge are using a single PI */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
l_int|0
)paren
op_logical_and
(paren
id|OLD_b_wid_int_lower
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Once set, these registers shouldn&squot;t change; they should&n;&t; * be set multiple times with the same values.&n;&t; *&n;&t; * If we&squot;re attempting to change these registers, it means&n;&t; * that our heuristics for allocating interrupts in a way&n;&t; * appropriate for IP35 have failed, and the admin needs to&n;&t; * explicitly direct some interrupts (or we need to make the&n;&t; * heuristics more clever).&n;&t; *&n;&t; * In practice, we hope this doesn&squot;t happen very often, if&n;&t; * at all.&n;&t; */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
id|NEW_b_wid_int_upper
)paren
op_logical_or
(paren
id|OLD_b_wid_int_lower
op_ne
id|NEW_b_wid_int_lower
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Interrupt allocation is too complex.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use explicit administrative interrupt targetting.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bridge=0x%lx targ=0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bridge
comma
id|targ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NEW=0x%x/0x%x  OLD=0x%x/0x%x&bslash;n&quot;
comma
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
comma
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
)paren
suffix:semicolon
id|PRINT_PANIC
c_func
(paren
l_string|&quot;PCI Bridge interrupt targetting error&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|bridge-&gt;b_wid_int_upper
op_assign
id|NEW_b_wid_int_upper
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|NEW_b_wid_int_lower
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_intr_preset: called during mlreset time&n; * if the platform specific code needs to route&n; * one of the Bridge&squot;s xtalk interrupts before the&n; * xtalk infrastructure is available.&n; */
r_void
DECL|function|pcibr_xintr_preset
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
id|which_widget
comma
r_int
id|which_widget_intr
comma
id|xwidgetnum_t
id|targ
comma
id|iopaddr_t
id|addr
comma
id|xtalk_intr_vector_t
id|vect
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|which_widget
suffix:semicolon
r_if
c_cond
(paren
id|which_widget_intr
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* bridge widget error interrupt */
id|bridge-&gt;b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
multiline_comment|/* turn on all interrupts except&n;&t; * the PCI interrupt requests,&n;&t; * at least at heart.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
op_complement
id|BRIDGE_IMR_INT_MSK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* routing a PCI device interrupt.&n;&t; * targ and low 38 bits of addr must&n;&t; * be the same as the already set&n;&t; * value for the widget error interrupt.&n;&t; */
id|bridge-&gt;b_int_addr
(braket
id|which_widget_intr
)braket
dot
id|addr
op_assign
(paren
(paren
id|BRIDGE_INT_ADDR_HOST
op_amp
(paren
id|addr
op_rshift
l_int|30
)paren
)paren
op_or
(paren
id|BRIDGE_INT_ADDR_FLD
op_amp
id|vect
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now bridge can let it through;&n;&t; * NB: still should be blocked at&n;&t; * xtalk provider end, until the service&n;&t; * function is set.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|1
op_lshift
id|vect
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
multiline_comment|/*&n; * pcibr_intr_func()&n; *&n; * This is the pcibr interrupt &quot;wrapper&quot; function that is called,&n; * in interrupt context, to initiate the interrupt handler(s) registered&n; * (via pcibr_intr_alloc/connect) for the occuring interrupt. Non-threaded &n; * handlers will be called directly, and threaded handlers will have their &n; * thread woken up.&n; */
r_void
DECL|function|pcibr_intr_func
id|pcibr_intr_func
c_func
(paren
id|intr_arg_t
id|arg
)paren
(brace
id|pcibr_intr_wrap_t
id|wrap
op_assign
(paren
id|pcibr_intr_wrap_t
)paren
id|arg
suffix:semicolon
id|reg_p
id|wrbf
suffix:semicolon
id|pcibr_intr_t
id|intr
suffix:semicolon
id|pcibr_intr_list_t
id|list
suffix:semicolon
r_int
id|clearit
suffix:semicolon
r_int
id|do_nonthreaded
op_assign
l_int|1
suffix:semicolon
r_int
id|is_threaded
op_assign
l_int|0
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If any handler is still running from a previous interrupt&n;&t; * just return. If there&squot;s a need to call the handler(s) again,&n;&t; * another interrupt will be generated either by the device or by&n;&t; * pcibr_force_interrupt().&n;&t; */
r_if
c_cond
(paren
id|wrap-&gt;iw_hdlrcnt
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Call all interrupt handlers registered.&n;     * First, the pcibr_intrd threads for any threaded handlers will be&n;     * awoken, then any non-threaded handlers will be called sequentially.&n;     */
id|clearit
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|do_nonthreaded
)paren
(brace
r_for
c_loop
(paren
id|list
op_assign
id|wrap-&gt;iw_list
suffix:semicolon
id|list
op_ne
l_int|NULL
suffix:semicolon
id|list
op_assign
id|list-&gt;il_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|intr
op_assign
id|list-&gt;il_intr
)paren
op_logical_and
(paren
id|intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_CONNECTED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This device may have initiated write&n;&t;&t; * requests since the bridge last saw&n;&t;&t; * an edge on this interrupt input; flushing&n;&t;&t; * the buffer prior to invoking the handler&n;&t;&t; * should help but may not be sufficient if we &n;&t;&t; * get more requests after the flush, followed&n;&t;&t; * by the card deciding it wants service, before&n;&t;&t; * the interrupt handler checks to see if things need&n;&t;&t; * to be done.&n;&t;&t; *&n;&t;&t; * There is a similar race condition if&n;&t;&t; * an interrupt handler loops around and&n;&t;&t; * notices further service is required.&n;&t;&t; * Perhaps we need to have an explicit&n;&t;&t; * call that interrupt handlers need to&n;&t;&t; * do between noticing that DMA to memory&n;&t;&t; * has completed, but before observing the&n;&t;&t; * contents of memory?&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|do_nonthreaded
)paren
op_logical_and
(paren
op_logical_neg
id|is_threaded
)paren
)paren
(brace
multiline_comment|/* Non-threaded. &n;&t;&t;&t; * Call the interrupt handler at interrupt level&n;&t;&t;&t; */
multiline_comment|/* Only need to flush write buffers if sharing */
r_if
c_cond
(paren
(paren
id|wrap-&gt;iw_shared
)paren
op_logical_and
(paren
id|wrbf
op_assign
id|list-&gt;il_wrbf
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|x
op_assign
op_star
id|wrbf
)paren
)paren
multiline_comment|/* write request buffer flush */
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_func %v: &bslash;n&quot;
l_string|&quot;write buffer flush failed, wrbf=0x%x&bslash;n&quot;
comma
id|list-&gt;il_intr-&gt;bi_dev
comma
id|wrbf
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_func %p: &bslash;n&quot;
l_string|&quot;write buffer flush failed, wrbf=0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|list-&gt;il_intr-&gt;bi_dev
comma
(paren
r_int
)paren
id|wrbf
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|clearit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|do_nonthreaded
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the non-threaded handler was the last to complete,&n;&t;&t; * (i.e., no threaded handlers still running) force an&n;&t;&t; * interrupt to avoid a potential deadlock situation.&n;&t;&t; */
r_if
c_cond
(paren
id|wrap-&gt;iw_hdlrcnt
op_eq
l_int|0
)paren
(brace
id|pcibr_force_interrupt
c_func
(paren
id|wrap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If there were no handlers,&n;&t; * disable the interrupt and return.&n;&t; * It will get enabled again after&n;&t; * a handler is connected.&n;&t; * If we don&squot;t do this, we would&n;&t; * sit here and spin through the&n;&t; * list forever.&n;&t; */
r_if
c_cond
(paren
id|clearit
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|wrap-&gt;iw_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
id|bridgereg_t
id|mask
op_assign
l_int|1
op_lshift
id|wrap-&gt;iw_intr
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_and_assign
op_complement
id|mask
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
eof
