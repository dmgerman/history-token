multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#ifdef __ia64
r_inline
r_int
DECL|function|compare_and_swap_ptr
id|compare_and_swap_ptr
c_func
(paren
r_void
op_star
op_star
id|location
comma
r_void
op_star
id|old_ptr
comma
r_void
op_star
id|new_ptr
)paren
(brace
multiline_comment|/* FIXME - compare_and_swap_ptr NOT ATOMIC */
r_if
c_cond
(paren
op_star
id|location
op_eq
id|old_ptr
)paren
(brace
op_star
id|location
op_assign
id|new_ptr
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_int
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
comma
r_int
id|nslots
)paren
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|pciio_intr_line_t
comma
id|vertex_hdl_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_int
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
comma
id|intr_func_t
comma
id|intr_arg_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
id|vertex_hdl_t
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
comma
r_int
comma
id|xwidgetnum_t
comma
id|iopaddr_t
comma
id|xtalk_intr_vector_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_func
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    INTERRUPT MANAGEMENT&n; */
r_int
DECL|function|pcibr_intr_bits
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
comma
r_int
id|nslots
)paren
(brace
id|pciio_slot_t
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|info
)paren
suffix:semicolon
r_int
id|bbits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Currently favored mapping from PCI&n;     * slot number and INTA/B/C/D to Bridge&n;     * PCI Interrupt Bit Number:&n;     *&n;     *     SLOT     A B C D&n;     *      0       0 4 0 4&n;     *      1       1 5 1 5&n;     *      2       2 6 2 6&n;     *      3       3 7 3 7&n;     *      4       4 0 4 0&n;     *      5       5 1 5 1&n;     *      6       6 2 6 2&n;     *      7       7 3 7 3&n;     */
r_if
c_cond
(paren
id|slot
OL
id|nslots
)paren
(brace
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_A
op_or
id|PCIIO_INTR_LINE_C
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_B
op_or
id|PCIIO_INTR_LINE_D
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
(paren
id|slot
op_xor
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|bbits
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;On SN systems there is a race condition between a PIO read response&n; *&t;and DMA&squot;s.  In rare cases, the read response may beat the DMA, causing&n; *&t;the driver to think that data in memory is complete and meaningful.&n; *&t;This code eliminates that race.&n; *&t;This routine is called by the PIO read routines after doing the read.&n; *&t;This routine then forces a fake interrupt on another line, which&n; *&t;is logically associated with the slot that the PIO is addressed to.&n; *&t;(see sn_dma_flush_init() )&n; *&t;It then spins while watching the memory location that the interrupt&n; *&t;is targetted to.  When the interrupt response arrives, we are sure&n; *&t;that the DMA has landed in memory and it is safe for the driver&n; *&t;to proceed.&n; */
r_extern
r_struct
id|sn_flush_nasid_entry
id|flush_nasid_list
(braket
id|MAX_NASIDS
)braket
suffix:semicolon
r_void
DECL|function|sn_dma_flush
id|sn_dma_flush
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|wid_num
suffix:semicolon
r_volatile
r_struct
id|sn_flush_device_list
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|bwin
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|addr
)paren
suffix:semicolon
id|wid_num
op_assign
id|SWIN_WIDGETNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bwin
op_assign
id|BWIN_WINDOWNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bwin
OG
l_int|0
)paren
(brace
r_int
r_int
id|itte
op_assign
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|iio_itte
(braket
id|bwin
)braket
suffix:semicolon
id|wid_num
op_assign
(paren
id|itte
op_rshift
id|IIO_ITTE_WIDGET_SHIFT
)paren
op_amp
id|IIO_ITTE_WIDGET_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|p
op_assign
op_amp
id|flush_nasid_list
(braket
id|nasid
)braket
dot
id|widget_p
(braket
id|wid_num
)braket
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* find a matching BAR */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_PER_WIDGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;bar_list
(braket
id|j
)braket
dot
id|start
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|p-&gt;bar_list
(braket
id|j
)braket
dot
id|start
op_logical_and
id|addr
op_le
id|p-&gt;bar_list
(braket
id|j
)braket
dot
id|end
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|PCI_ROM_RESOURCE
op_logical_and
id|p-&gt;bar_list
(braket
id|j
)braket
dot
id|start
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* if no matching BAR, return without doing anything. */
r_if
c_cond
(paren
id|i
op_eq
id|DEV_PER_WIDGET
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;flush_lock
comma
id|flags
)paren
suffix:semicolon
id|p-&gt;flush_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force an interrupt. */
op_star
(paren
id|bridgereg_t
op_star
)paren
(paren
id|p-&gt;force_int_addr
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for the interrupt to come back. */
r_while
c_loop
(paren
id|p-&gt;flush_addr
op_ne
l_int|0x10f
)paren
suffix:semicolon
multiline_comment|/* okay, everything is synched up. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|p-&gt;flush_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|sn_dma_flush
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_flush
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;There are end cases where a deadlock can occur if interrupt &n; *&t;processing completes and the Bridge b_int_status bit is still set.&n; *&n; *&t;One scenerio is if a second PCI interrupt occurs within 60ns of&n; *&t;the previous interrupt being cleared. In this case the Bridge&n; *&t;does not detect the transition, the Bridge b_int_status bit&n; *&t;remains set, and because no transition was detected no interrupt&n; *&t;packet is sent to the Hub/Heart.&n; *&n; *&t;A second scenerio is possible when a b_int_status bit is being&n; *&t;shared by multiple devices:&n; *&t;&t;&t;&t;&t;&t;Device #1 generates interrupt&n; *&t;&t;&t;&t;&t;&t;Bridge b_int_status bit set&n; *&t;&t;&t;&t;&t;&t;Device #2 generates interrupt&n; *&t;&t;interrupt processing begins&n; *&t;&t;  ISR for device #1 runs and&n; *&t;&t;&t;clears interrupt&n; *&t;&t;&t;&t;&t;&t;Device #1 generates interrupt&n; *&t;&t;  ISR for device #2 runs and&n; *&t;&t;&t;clears interrupt&n; *&t;&t;&t;&t;&t;&t;(b_int_status bit still set)&n; *&t;&t;interrupt processing completes&n; *&t;&t;  &n; *&t;Interrupt processing is now complete, but an interrupt is still&n; *&t;outstanding for Device #1. But because there was no transition of&n; *&t;the b_int_status bit, no interrupt packet will be generated and&n; *&t;a deadlock will occur.&n; *&n; *&t;To avoid these deadlock situations, this function is used&n; *&t;to check if a specific Bridge b_int_status bit is set, and if so,&n; *&t;cause the setting of the corresponding interrupt bit.&n; *&n; *&t;On a XBridge (SN1) and PIC (SN2), we do this by writing the appropriate Bridge Force &n; *&t;Interrupt register.&n; */
r_void
DECL|function|pcibr_force_interrupt
id|pcibr_force_interrupt
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
(brace
r_int
id|bit
suffix:semicolon
r_int
id|bits
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bits
op_assign
id|intr-&gt;bi_ibits
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
l_int|8
suffix:semicolon
id|bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
(paren
l_int|1
op_lshift
id|bit
)paren
)paren
(brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;pcibr_force_interrupt: bit=0x%x&bslash;n&quot;
comma
id|bit
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_force_pin
(braket
id|bit
)braket
dot
id|intr
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*ARGSUSED */
id|pcibr_intr_t
DECL|function|pcibr_intr_alloc
id|pcibr_intr_alloc
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_intr_line_t
id|lines
comma
id|vertex_hdl_t
id|owner_dev
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pcibr_info-&gt;f_mfast
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|is_threaded
op_assign
l_int|0
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intr_p
suffix:semicolon
id|pcibr_intr_t
op_star
id|pcibr_intr_p
suffix:semicolon
id|pcibr_intr_list_t
op_star
id|intr_list_p
suffix:semicolon
r_int
id|pcibr_int_bits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
op_assign
(paren
id|xtalk_intr_t
)paren
l_int|0
suffix:semicolon
id|hub_intr_t
id|hub_intr
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr
suffix:semicolon
id|pcibr_intr_list_t
id|intr_entry
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_intr_alloc: %s%s%s%s%s&bslash;n&quot;
comma
op_logical_neg
(paren
id|lines
op_amp
l_int|15
)paren
ques
c_cond
l_string|&quot; No INTs?&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|1
ques
c_cond
l_string|&quot; INTA&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|2
ques
c_cond
l_string|&quot; INTB&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|4
ques
c_cond
l_string|&quot; INTC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|8
ques
c_cond
l_string|&quot; INTD&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|pcibr_intr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_intr
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_intr
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pcibr_intr
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pcibr_intr
)paren
)paren
)paren
suffix:semicolon
id|pcibr_intr-&gt;bi_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_intr-&gt;bi_lines
op_assign
id|lines
suffix:semicolon
id|pcibr_intr-&gt;bi_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_intr-&gt;bi_ibits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bits will be added below */
id|pcibr_intr-&gt;bi_func
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unset until connect */
id|pcibr_intr-&gt;bi_arg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unset until connect */
id|pcibr_intr-&gt;bi_flags
op_assign
id|is_threaded
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_INTR_NOTHREAD
suffix:semicolon
id|pcibr_intr-&gt;bi_mustruncpu
op_assign
id|CPU_NONE
suffix:semicolon
id|pcibr_intr-&gt;bi_ibuf.ib_in
op_assign
l_int|0
suffix:semicolon
id|pcibr_intr-&gt;bi_ibuf.ib_out
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pcibr_intr-&gt;bi_ibuf.ib_lock
)paren
suffix:semicolon
id|pcibr_int_bits
op_assign
id|pcibr_soft
op_member_access_from_pointer
id|bs_intr_bits
c_func
(paren
(paren
id|pciio_info_t
)paren
id|pcibr_info
comma
id|lines
comma
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_intr_alloc: pcibr_int_bits: 0x%x&bslash;n&quot;
comma
id|pcibr_int_bits
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|xtalk_intr_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This xtalk_intr_alloc is constrained for two reasons:&n;&t;&t; * 1) Normal interrupts and error interrupts need to be delivered&n;&t;&t; *    through a single xtalk target widget so that there aren&squot;t any&n;&t;&t; *    ordering problems with DMA, completion interrupts, and error&n;&t;&t; *    interrupts. (Use of xconn_vhdl forces this.)&n;&t;&t; *&n;&t;&t; * 2) On SN1, addressing constraints on SN1 and Bridge force&n;&t;&t; *    us to use a single PI number for all interrupts from a&n;&t;&t; *    single Bridge. (SN1-specific code forces this).&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * All code dealing with threaded PCI interrupt handlers&n;&t;&t; * is located at the pcibr level. Because of this,&n;&t;&t; * we always want the lower layers (hub/heart_intr_alloc, &n;&t;&t; * intr_level_connect) to treat us as non-threaded so we&n;&t;&t; * don&squot;t set up a duplicate threaded environment. We make&n;&t;&t; * this happen by calling a special xtalk interface.&n;&t;&t; */
id|xtalk_intr
op_assign
id|xtalk_intr_alloc_nothd
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|owner_dev
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_intr_alloc: xtalk_intr=0x%x&bslash;n&quot;
comma
id|xtalk_intr
)paren
)paren
suffix:semicolon
multiline_comment|/* both an assert and a runtime check on this:&n;&t;&t; * we need to check in non-DEBUG kernels, and&n;&t;&t; * the ASSERT gets us more information when&n;&t;&t; * we use DEBUG kernels.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* it is quite possible that our&n;&t;&t;     * xtalk_intr_alloc failed because&n;&t;&t;     * someone else got there first,&n;&t;&t;     * and we can find their results&n;&t;&t;     * in xtalk_intr_p.&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
op_star
id|xtalk_intr_p
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc %s: &quot;
l_string|&quot;unable to get xtalk interrupt resources&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|xtalk_intr_p
comma
l_int|NULL
comma
id|xtalk_intr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;     * now tell the bridge which slot is&n;&t;&t;     * using this interrupt line.&n;&t;&t;     */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|int_dev
op_or_assign
id|pciio_slot
op_lshift
id|BRIDGE_INT_DEV_SHFT
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
multiline_comment|/* XXXMP */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;bridge intr bit %d clears my wrb&bslash;n&quot;
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* someone else got one allocated first;&n;&t;&t;     * free the one we just created, and&n;&t;&t;     * retrieve the one they allocated.&n;&t;&t;     */
id|xtalk_intr_free
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
macro_line|#if PARANOID
multiline_comment|/* once xtalk_intr is set, we never clear it,&n;&t;&t;     * so if the CAS fails above, this condition&n;&t;&t;     * can &quot;never happen&quot; ...&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|xtalk_intr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc %v: unable to set xtalk interrupt resources&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
id|pcibr_intr-&gt;bi_ibits
op_or_assign
l_int|1
op_lshift
id|pcibr_int_bit
suffix:semicolon
id|intr_entry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|intr_entry
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intr_entry
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_alloc %s: &quot;
l_string|&quot;unable to get memory&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|intr_entry
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|intr_entry
)paren
)paren
)paren
suffix:semicolon
id|intr_entry-&gt;il_next
op_assign
l_int|NULL
suffix:semicolon
id|intr_entry-&gt;il_intr
op_assign
id|pcibr_intr
suffix:semicolon
id|intr_entry-&gt;il_wrbf
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
id|intr_list_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;Bridge bit 0x%x wrap=0x%x&bslash;n&quot;
comma
id|pcibr_int_bit
comma
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the first interrupt on this bridge bit.&n;&t;&t; */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;INT 0x%x (bridge bit %d) allocated [FIRST]&bslash;n&quot;
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* first entry on list was erased,&n;&t;&t; * and we replaced it, so we&n;&t;&t; * don&squot;t need our intr_entry.&n;&t;&t; */
id|kfree
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;INT 0x%x (bridge bit %d) replaces erased first&bslash;n&quot;
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the new second interrupt on this bit.&n;&t;&t; */
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
op_assign
l_int|1
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;INT 0x%x (bridge bit %d) is new SECOND&bslash;n&quot;
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* an entry on list was erased,&n;&t;&t;     * and we replaced it, so we&n;&t;&t;     * don&squot;t need our intr_entry.&n;&t;&t;     */
id|kfree
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;INT 0x%x (bridge bit %d) replaces erase Nth&bslash;n&quot;
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* entry appended to share list&n;&t;&t;     */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pconn_vhdl
comma
l_string|&quot;INT 0x%x (bridge bit %d) is new Nth&bslash;n&quot;
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* step to next record in chain&n;&t;&t; */
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
)brace
)brace
)brace
id|hub_intr
op_assign
(paren
id|hub_intr_t
)paren
id|xtalk_intr
suffix:semicolon
id|pcibr_intr-&gt;bi_irq
op_assign
id|hub_intr-&gt;i_bit
suffix:semicolon
id|pcibr_intr-&gt;bi_cpu
op_assign
id|hub_intr-&gt;i_cpuid
suffix:semicolon
r_return
id|pcibr_intr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_free
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
r_int
id|intr_shared
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intrp
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
r_for
c_loop
(paren
id|intr_list
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
suffix:semicolon
id|intr_list
op_ne
l_int|NULL
suffix:semicolon
id|intr_list
op_assign
id|intr_list-&gt;il_next
)paren
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|intr_list-&gt;il_intr
comma
id|pcibr_intr
comma
l_int|NULL
)paren
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_intr_free: cleared hdlr from bit 0x%x&bslash;n&quot;
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If this interrupt line is not being shared between multiple&n;&t;     * devices release the xtalk interrupt resources.&n;&t;     */
id|intr_shared
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
suffix:semicolon
id|xtalk_intrp
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|intr_shared
)paren
op_logical_and
(paren
op_star
id|xtalk_intrp
)paren
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
id|xtalk_intr_free
c_func
(paren
op_star
id|xtalk_intrp
)paren
suffix:semicolon
op_star
id|xtalk_intrp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the PCI device interrupt to bridge interrupt pin&n;&t;&t; * mapping.&n;&t;&t; */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
id|pcibr_intr
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_setpciint
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
id|iopaddr_t
id|addr
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
suffix:semicolon
id|vertex_hdl_t
id|vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|picreg_t
op_star
id|int_addr
suffix:semicolon
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|vhdl
op_assign
id|xtalk_intr_dev_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_piotrans_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
l_int|0
comma
r_sizeof
(paren
id|bridge_t
)paren
comma
l_int|0
)paren
suffix:semicolon
id|int_addr
op_assign
(paren
id|picreg_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
op_star
id|int_addr
op_assign
(paren
(paren
id|PIC_INT_ADDR_FLD
op_amp
(paren
(paren
r_uint64
)paren
id|vect
op_lshift
l_int|48
)paren
)paren
op_or
(paren
id|PIC_INT_ADDR_HOST
op_amp
id|addr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_intr_connect
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
comma
id|intr_func_t
id|intr_func
comma
id|intr_arg_t
id|intr_arg
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
r_uint64
id|int_enable
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_intr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_intr_connect: intr_func=0x%x&bslash;n&quot;
comma
id|pcibr_intr
)paren
)paren
suffix:semicolon
id|pcibr_intr-&gt;bi_func
op_assign
id|intr_func
suffix:semicolon
id|pcibr_intr-&gt;bi_arg
op_assign
id|intr_arg
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_or_assign
id|PCIIO_INTR_CONNECTED
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
r_void
op_star
id|int_addr
suffix:semicolon
id|xtalk_intr
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
id|intr_wrap
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
multiline_comment|/*&n;&t;     * If this interrupt line is being shared and the connect has&n;&t;     * already been done, no need to do it again.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;     * Use the pcibr wrapper function to handle all Bridge interrupts&n;&t;     * regardless of whether the interrupt line is shared or not.&n;&t;     */
id|int_addr
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;p_int_addr_64
(braket
id|pcibr_int_bit
)braket
)paren
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
id|pcibr_intr_func
comma
(paren
id|intr_arg_t
)paren
id|intr_wrap
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
id|int_addr
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|1
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_setpciint: int_addr=0x%x, *int_addr=0x%x, &quot;
l_string|&quot;pcibr_int_bit=0x%x&bslash;n&quot;
comma
id|int_addr
comma
op_star
(paren
id|picreg_t
op_star
)paren
id|int_addr
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* PIC WAR. PV# 854697&n;&t; * On PIC we must write 64-bit MMRs with 64-bit stores&n;&t; */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV854697
comma
id|pcibr_soft
)paren
)paren
(brace
id|int_enable
op_assign
id|bridge-&gt;p_int_enable_64
suffix:semicolon
id|int_enable
op_or_assign
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|int_enable
suffix:semicolon
)brace
r_else
(brace
id|bridgereg_t
id|int_enable
suffix:semicolon
id|int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|int_enable
op_or_assign
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|int_enable
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_disconnect
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
r_uint64
id|int_enable
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* Stop calling the function. Now.&n;     */
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_and_assign
op_complement
id|PCIIO_INTR_CONNECTED
suffix:semicolon
id|pcibr_intr-&gt;bi_func
op_assign
l_int|0
suffix:semicolon
id|pcibr_intr-&gt;bi_arg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and disconnect the interrupt.&n;     */
multiline_comment|/* don&squot;t disable interrupts for lines that&n;     * are shared between devices.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
)paren
id|pcibr_int_bits
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_int_bits
)paren
r_return
suffix:semicolon
multiline_comment|/* PIC WAR. PV# 854697&n;     * On PIC we must write 64-bit MMRs with 64-bit stores&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV854697
comma
id|pcibr_soft
)paren
)paren
(brace
id|int_enable
op_assign
id|bridge-&gt;p_int_enable_64
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|int_enable
suffix:semicolon
)brace
r_else
(brace
id|int_enable
op_assign
(paren
r_uint64
)paren
id|bridge-&gt;b_int_enable
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
(paren
id|bridgereg_t
)paren
id|int_enable
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_intr_disconnect: disabled int_bits=0x%x&bslash;n&quot;
comma
id|pcibr_int_bits
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
r_void
op_star
id|int_addr
suffix:semicolon
multiline_comment|/* if the interrupt line is now shared,&n;&t;     * do not disconnect it.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
r_continue
suffix:semicolon
id|xtalk_intr_disconnect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|0
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_intr_disconnect: disconnect int_bits=0x%x&bslash;n&quot;
comma
id|pcibr_int_bits
)paren
)paren
suffix:semicolon
multiline_comment|/* if we are sharing the interrupt line,&n;&t;     * connect us up; this closes the hole&n;&t;     * where the another pcibr_intr_alloc()&n;&t;     * was in progress as we disconnected.&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
r_continue
suffix:semicolon
id|intr_wrap
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
)paren
r_continue
suffix:semicolon
id|int_addr
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;p_int_addr_64
(braket
id|pcibr_int_bit
)braket
)paren
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
comma
id|pcibr_intr_func
comma
(paren
id|intr_arg_t
)paren
id|intr_wrap
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_intr-&gt;bi_dev
comma
l_string|&quot;pcibr_intr_disconnect: now-sharing int_bits=0x%x&bslash;n&quot;
comma
id|pcibr_int_bit
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*ARGSUSED */
id|vertex_hdl_t
DECL|function|pcibr_intr_cpu_get
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
r_return
id|xtalk_intr_cpu_get
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    INTERRUPT HANDLING&n; */
r_void
DECL|function|pcibr_clearwidint
id|pcibr_clearwidint
c_func
(paren
id|bridge_t
op_star
id|bridge
)paren
(brace
id|bridge-&gt;b_wid_int_upper
op_assign
l_int|0
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_setwidint
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
id|intr
)paren
(brace
id|xwidgetnum_t
id|targ
op_assign
id|xtalk_intr_target_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|widgetreg_t
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
suffix:semicolon
id|widgetreg_t
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|NEW_b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|NEW_b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|OLD_b_wid_int_upper
op_assign
id|bridge-&gt;b_wid_int_upper
suffix:semicolon
id|OLD_b_wid_int_lower
op_assign
id|bridge-&gt;b_wid_int_lower
suffix:semicolon
multiline_comment|/* Verify that all interrupts from this Bridge are using a single PI */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
l_int|0
)paren
op_logical_and
(paren
id|OLD_b_wid_int_lower
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Once set, these registers shouldn&squot;t change; they should&n;&t; * be set multiple times with the same values.&n;&t; *&n;&t; * If we&squot;re attempting to change these registers, it means&n;&t; * that our heuristics for allocating interrupts in a way&n;&t; * appropriate for IP35 have failed, and the admin needs to&n;&t; * explicitly direct some interrupts (or we need to make the&n;&t; * heuristics more clever).&n;&t; *&n;&t; * In practice, we hope this doesn&squot;t happen very often, if&n;&t; * at all.&n;&t; */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
id|NEW_b_wid_int_upper
)paren
op_logical_or
(paren
id|OLD_b_wid_int_lower
op_ne
id|NEW_b_wid_int_lower
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Interrupt allocation is too complex.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use explicit administrative interrupt targetting.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bridge=0x%lx targ=0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bridge
comma
id|targ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NEW=0x%x/0x%x  OLD=0x%x/0x%x&bslash;n&quot;
comma
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
comma
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;PCI Bridge interrupt targetting error&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|bridge-&gt;b_wid_int_upper
op_assign
id|NEW_b_wid_int_upper
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|NEW_b_wid_int_lower
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_intr_preset: called during mlreset time&n; * if the platform specific code needs to route&n; * one of the Bridge&squot;s xtalk interrupts before the&n; * xtalk infrastructure is available.&n; */
r_void
DECL|function|pcibr_xintr_preset
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
id|which_widget
comma
r_int
id|which_widget_intr
comma
id|xwidgetnum_t
id|targ
comma
id|iopaddr_t
id|addr
comma
id|xtalk_intr_vector_t
id|vect
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|which_widget
suffix:semicolon
r_if
c_cond
(paren
id|which_widget_intr
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* bridge widget error interrupt */
id|bridge-&gt;b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pcibr_xintr_preset: b_wid_int_upper 0x%lx b_wid_int_lower 0x%lx b_int_host_err 0x%x&bslash;n&quot;
comma
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
comma
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
comma
id|vect
)paren
suffix:semicolon
multiline_comment|/* turn on all interrupts except&n;&t; * the PCI interrupt requests,&n;&t; * at least at heart.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
op_complement
id|BRIDGE_IMR_INT_MSK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* routing a PCI device interrupt.&n;&t; * targ and low 38 bits of addr must&n;&t; * be the same as the already set&n;&t; * value for the widget error interrupt.&n;&t; */
id|bridge-&gt;b_int_addr
(braket
id|which_widget_intr
)braket
dot
id|addr
op_assign
(paren
(paren
id|BRIDGE_INT_ADDR_HOST
op_amp
(paren
id|addr
op_rshift
l_int|30
)paren
)paren
op_or
(paren
id|BRIDGE_INT_ADDR_FLD
op_amp
id|vect
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now bridge can let it through;&n;&t; * NB: still should be blocked at&n;&t; * xtalk provider end, until the service&n;&t; * function is set.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|1
op_lshift
id|vect
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
multiline_comment|/*&n; * pcibr_intr_func()&n; *&n; * This is the pcibr interrupt &quot;wrapper&quot; function that is called,&n; * in interrupt context, to initiate the interrupt handler(s) registered&n; * (via pcibr_intr_alloc/connect) for the occurring interrupt. Non-threaded &n; * handlers will be called directly, and threaded handlers will have their &n; * thread woken up.&n; */
r_void
DECL|function|pcibr_intr_func
id|pcibr_intr_func
c_func
(paren
id|intr_arg_t
id|arg
)paren
(brace
id|pcibr_intr_wrap_t
id|wrap
op_assign
(paren
id|pcibr_intr_wrap_t
)paren
id|arg
suffix:semicolon
id|reg_p
id|wrbf
suffix:semicolon
id|intr_func_t
id|func
suffix:semicolon
id|pcibr_intr_t
id|intr
suffix:semicolon
id|pcibr_intr_list_t
id|list
suffix:semicolon
r_int
id|clearit
suffix:semicolon
r_int
id|do_nonthreaded
op_assign
l_int|1
suffix:semicolon
r_int
id|is_threaded
op_assign
l_int|0
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|wrap-&gt;iw_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_uint64
id|p_enable
op_assign
id|pcibr_soft-&gt;bs_int_enable
suffix:semicolon
r_int
id|bit
op_assign
id|wrap-&gt;iw_ibit
suffix:semicolon
multiline_comment|/*&n;&t; * PIC WAR.  PV#855272&n;&t; * Early attempt at a workaround for the runaway&n;&t; * interrupt problem.   Briefly disable the enable bit for&n;&t; * this device.&n;&t; */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV855272
comma
id|pcibr_soft
)paren
)paren
(brace
r_int
id|s
suffix:semicolon
multiline_comment|/* disable-enable interrupts for this bridge pin */
id|p_enable
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|p_enable
suffix:semicolon
id|p_enable
op_or_assign
(paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|p_enable
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If any handler is still running from a previous interrupt&n;&t; * just return. If there&squot;s a need to call the handler(s) again,&n;&t; * another interrupt will be generated either by the device or by&n;&t; * pcibr_force_interrupt().&n;&t; */
r_if
c_cond
(paren
id|wrap-&gt;iw_hdlrcnt
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Call all interrupt handlers registered.&n;     * First, the pcibr_intrd threads for any threaded handlers will be&n;     * awoken, then any non-threaded handlers will be called sequentially.&n;     */
id|clearit
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|do_nonthreaded
)paren
(brace
r_for
c_loop
(paren
id|list
op_assign
id|wrap-&gt;iw_list
suffix:semicolon
id|list
op_ne
l_int|NULL
suffix:semicolon
id|list
op_assign
id|list-&gt;il_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|intr
op_assign
id|list-&gt;il_intr
)paren
op_logical_and
(paren
id|intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_CONNECTED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;     * This device may have initiated write&n;&t;&t;     * requests since the bridge last saw&n;&t;&t;     * an edge on this interrupt input; flushing&n;&t;&t;     * the buffer prior to invoking the handler&n;&t;&t;     * should help but may not be sufficient if we &n;&t;&t;     * get more requests after the flush, followed&n;&t;&t;     * by the card deciding it wants service, before&n;&t;&t;     * the interrupt handler checks to see if things need&n;&t;&t;     * to be done.&n;&t;&t;     *&n;&t;&t;     * There is a similar race condition if&n;&t;&t;     * an interrupt handler loops around and&n;&t;&t;     * notices further service is required.&n;&t;&t;     * Perhaps we need to have an explicit&n;&t;&t;     * call that interrupt handlers need to&n;&t;&t;     * do between noticing that DMA to memory&n;&t;&t;     * has completed, but before observing the&n;&t;&t;     * contents of memory?&n;&t;&t;     */
r_if
c_cond
(paren
(paren
id|do_nonthreaded
)paren
op_logical_and
(paren
op_logical_neg
id|is_threaded
)paren
)paren
(brace
multiline_comment|/* Non-threaded -  Call the interrupt handler at interrupt level */
multiline_comment|/* Only need to flush write buffers if sharing */
r_if
c_cond
(paren
(paren
id|wrap-&gt;iw_shared
)paren
op_logical_and
(paren
id|wrbf
op_assign
id|list-&gt;il_wrbf
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|x
op_assign
op_star
id|wrbf
)paren
)paren
multiline_comment|/* write request buffer flush */
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_func %v: &bslash;n&quot;
l_string|&quot;write buffer flush failed, wrbf=0x%x&bslash;n&quot;
comma
id|list-&gt;il_intr-&gt;bi_dev
comma
id|wrbf
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pcibr_intr_func %p: &bslash;n&quot;
l_string|&quot;write buffer flush failed, wrbf=0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|list-&gt;il_intr-&gt;bi_dev
comma
(paren
r_int
)paren
id|wrbf
)paren
suffix:semicolon
macro_line|#endif
)brace
id|func
op_assign
id|intr-&gt;bi_func
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
id|func
c_func
(paren
id|intr-&gt;bi_arg
)paren
suffix:semicolon
)brace
id|clearit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|do_nonthreaded
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;     * If the non-threaded handler was the last to complete,&n;&t;     * (i.e., no threaded handlers still running) force an&n;&t;     * interrupt to avoid a potential deadlock situation.&n;&t;     */
r_if
c_cond
(paren
id|wrap-&gt;iw_hdlrcnt
op_eq
l_int|0
)paren
(brace
id|pcibr_force_interrupt
c_func
(paren
(paren
id|pcibr_intr_t
)paren
id|wrap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If there were no handlers,&n;&t; * disable the interrupt and return.&n;&t; * It will get enabled again after&n;&t; * a handler is connected.&n;&t; * If we don&squot;t do this, we would&n;&t; * sit here and spin through the&n;&t; * list forever.&n;&t; */
r_if
c_cond
(paren
id|clearit
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|wrap-&gt;iw_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|int_enable
suffix:semicolon
id|bridgereg_t
id|mask
op_assign
l_int|1
op_lshift
id|wrap-&gt;iw_ibit
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* PIC BRINUGP WAR (PV# 854697):&n;&t;     * On PIC we must write 64-bit MMRs with 64-bit stores&n;&t;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV854697
comma
id|pcibr_soft
)paren
)paren
(brace
id|int_enable
op_assign
id|bridge-&gt;p_int_enable_64
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|mask
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|int_enable
suffix:semicolon
)brace
r_else
(brace
id|int_enable
op_assign
(paren
r_uint64
)paren
id|bridge-&gt;b_int_enable
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|mask
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
(paren
id|bridgereg_t
)paren
id|int_enable
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
eof
