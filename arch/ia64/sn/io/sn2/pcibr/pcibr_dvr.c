multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt; 
macro_line|#include &lt;asm/sn/sn_private.h&gt;
multiline_comment|/*&n; * global variables to toggle the different levels of pcibr debugging.  &n; *   -pcibr_debug_mask is the mask of the different types of debugging&n; *    you want to enable.  See sys/PCI/pcibr_private.h &n; *   -pcibr_debug_module is the module you want to trace.  By default&n; *    all modules are trace.  The format is something like &quot;001c10&quot;.&n; *   -pcibr_debug_widget is the widget you want to trace.  For TIO &n; *    based bricks use the corelet id.&n; *   -pcibr_debug_slot is the pci slot you want to trace.&n; */
DECL|variable|pcibr_debug_mask
r_uint32
id|pcibr_debug_mask
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* 0x00000000 to disable */
DECL|variable|pcibr_debug_module
r_static
r_char
op_star
id|pcibr_debug_module
op_assign
l_string|&quot;all&quot;
suffix:semicolon
multiline_comment|/* &squot;all&squot; for all modules */
DECL|variable|pcibr_debug_widget
r_static
r_int
id|pcibr_debug_widget
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* &squot;-1&squot; for all widgets  */
DECL|variable|pcibr_debug_slot
r_static
r_int
id|pcibr_debug_slot
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* &squot;-1&squot; for all slots    */
multiline_comment|/* kbrick widgetnum-to-bus layout */
DECL|variable|p_busnum
r_int
id|p_busnum
(braket
id|MAX_PORT_NUM
)braket
op_assign
(brace
multiline_comment|/* widget#      */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x0 - 0x7    */
l_int|2
comma
multiline_comment|/* 0x8          */
l_int|1
comma
multiline_comment|/* 0x9          */
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0xa - 0xb    */
l_int|5
comma
multiline_comment|/* 0xc          */
l_int|6
comma
multiline_comment|/* 0xd          */
l_int|4
comma
multiline_comment|/* 0xe          */
l_int|3
comma
multiline_comment|/* 0xf          */
)brace
suffix:semicolon
DECL|variable|pci_space
r_char
op_star
id|pci_space
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ROM&quot;
comma
l_string|&quot;IO&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;MEM&quot;
comma
l_string|&quot;MEM32&quot;
comma
l_string|&quot;MEM64&quot;
comma
l_string|&quot;CFG&quot;
comma
l_string|&quot;WIN0&quot;
comma
l_string|&quot;WIN1&quot;
comma
l_string|&quot;WIN2&quot;
comma
l_string|&quot;WIN3&quot;
comma
l_string|&quot;WIN4&quot;
comma
l_string|&quot;WIN5&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;BAD&quot;
)brace
suffix:semicolon
macro_line|#if PCIBR_SOFT_LIST
DECL|variable|pcibr_list
id|pcibr_list_p
id|pcibr_list
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|hwgraph_vertex_name_get
c_func
(paren
id|vertex_hdl_t
id|vhdl
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
r_extern
r_int
id|atoi
c_func
(paren
r_register
r_char
op_star
id|p
)paren
suffix:semicolon
r_extern
id|cnodeid_t
id|nodevertex_to_cnodeid
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
suffix:semicolon
r_extern
r_char
op_star
id|dev_to_name
c_func
(paren
id|vertex_hdl_t
id|dev
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
r_extern
r_struct
id|map
op_star
id|atemapalloc
c_func
(paren
r_uint64
)paren
suffix:semicolon
r_extern
r_void
id|atefree
c_func
(paren
r_struct
id|map
op_star
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
r_extern
r_void
id|atemapfree
c_func
(paren
r_struct
id|map
op_star
)paren
suffix:semicolon
r_extern
id|pciio_dmamap_t
id|get_free_pciio_dmamap
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_void
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_extern
r_void
id|xwidget_error_register
c_func
(paren
id|vertex_hdl_t
comma
id|error_handler_f
op_star
comma
id|error_handler_arg_t
)paren
suffix:semicolon
DECL|macro|ATE_WRITE
mdefine_line|#define&t;ATE_WRITE()    ate_write(pcibr_soft, ate_ptr, ate_count, ate)
macro_line|#if PCIBR_FREEZE_TIME
DECL|macro|ATE_FREEZE
mdefine_line|#define&t;ATE_FREEZE()&t;s = ate_freeze(pcibr_dmamap, &amp;freeze_time, cmd_regs)
macro_line|#else
DECL|macro|ATE_FREEZE
mdefine_line|#define&t;ATE_FREEZE()&t;s = ate_freeze(pcibr_dmamap, cmd_regs)
macro_line|#endif /* PCIBR_FREEZE_TIME */
macro_line|#if PCIBR_FREEZE_TIME
DECL|macro|ATE_THAW
mdefine_line|#define&t;ATE_THAW()&t;ate_thaw(pcibr_dmamap, ate_index, ate, ate_total, freeze_time, cmd_regs, s)
macro_line|#else
DECL|macro|ATE_THAW
mdefine_line|#define&t;ATE_THAW()&t;ate_thaw(pcibr_dmamap, ate_index, cmd_regs, s)
macro_line|#endif
multiline_comment|/* =====================================================================&n; *    Function Table of Contents&n; *&n; *      The order of functions in this file has stopped&n; *      making much sense. We might want to take a look&n; *      at it some time and bring back some sanity, or&n; *      perhaps bust this file into smaller chunks.&n; */
r_extern
r_int
id|do_pcibr_rrb_free_all
c_func
(paren
id|pcibr_soft_t
comma
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_void
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_wrb_flush
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_rrb_flush
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_static
r_int
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
r_int
comma
id|bridgereg_t
)paren
suffix:semicolon
r_void
id|pcibr_release_device
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|bridgereg_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_clearwidint
c_func
(paren
id|bridge_t
op_star
)paren
suffix:semicolon
r_extern
id|iopaddr_t
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_win_info_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|pcibr_attach
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|pcibr_attach2
c_func
(paren
id|vertex_hdl_t
comma
id|bridge_t
op_star
comma
id|vertex_hdl_t
comma
r_int
comma
id|pcibr_soft_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_detach
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_init_ext_ate_ram
c_func
(paren
id|bridge_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
suffix:semicolon
r_extern
r_int
id|ate_freeze
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
macro_line|#if PCIBR_FREEZE_TIME
r_int
op_star
id|freeze_time_ptr
comma
macro_line|#endif
r_int
op_star
id|cmd_regs
)paren
suffix:semicolon
r_extern
r_void
id|ate_write
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|bridge_ate_p
id|ate_ptr
comma
r_int
id|ate_count
comma
id|bridge_ate_t
id|ate
)paren
suffix:semicolon
r_extern
r_void
id|ate_thaw
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
r_int
id|ate_index
comma
macro_line|#if PCIBR_FREEZE_TIME
id|bridge_ate_t
id|ate
comma
r_int
id|ate_total
comma
r_int
id|freeze_time_start
comma
macro_line|#endif
r_int
op_star
id|cmd_regs
comma
r_int
id|s
)paren
suffix:semicolon
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_static
id|iopaddr_t
id|pcibr_addr_pci_to_xio
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|pcibr_piomap_t
id|pcibr_piomap_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piomap_free
c_func
(paren
id|pcibr_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pcibr_piomap_addr
c_func
(paren
id|pcibr_piomap_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piomap_done
c_func
(paren
id|pcibr_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pcibr_piotrans_addr
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_piospace_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piospace_free
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_static
id|iopaddr_t
id|pcibr_flags_to_d64
c_func
(paren
r_int
comma
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
id|bridge_ate_t
id|pcibr_flags_to_ate
c_func
(paren
r_int
)paren
suffix:semicolon
id|pcibr_dmamap_t
id|pcibr_dmamap_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_free
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_extern
id|bridge_ate_p
id|pcibr_ate_addr
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
r_static
id|iopaddr_t
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmamap_addr
c_func
(paren
id|pcibr_dmamap_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_done
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
id|cnodeid_t
id|pcibr_get_dmatrans_node
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmatrans_addr
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_drain
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_void
id|pcibr_dmaaddr_drain
c_func
(paren
id|vertex_hdl_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmalist_drain
c_func
(paren
id|vertex_hdl_t
comma
id|alenlist_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmamap_pciaddr_get
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
comma
r_int
id|nslots
)paren
suffix:semicolon
r_extern
id|pcibr_intr_t
id|pcibr_intr_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|device_desc_t
comma
id|pciio_intr_line_t
comma
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
comma
id|intr_func_t
comma
id|intr_arg_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_extern
id|vertex_hdl_t
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_func
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
r_extern
r_void
id|print_bridge_errcmd
c_func
(paren
r_uint32
comma
r_char
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
r_uint32
id|pcibr_errintr_group
c_func
(paren
r_uint32
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_error_intr_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_addr_toslot
c_func
(paren
id|pcibr_soft_t
comma
id|iopaddr_t
comma
id|pciio_space_t
op_star
comma
id|iopaddr_t
op_star
comma
id|pciio_function_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_error_handler
c_func
(paren
id|error_handler_arg_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_error_handler_wrapper
c_func
(paren
id|error_handler_arg_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_void
id|pcibr_provider_startup
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_void
id|pcibr_provider_shutdown
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|pcibr_reset
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
id|pciio_endian_t
id|pcibr_endian_set
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_endian_t
comma
id|pciio_endian_t
)paren
suffix:semicolon
r_int
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_priority_t
)paren
suffix:semicolon
id|pciio_priority_t
id|pcibr_priority_set
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_priority_t
)paren
suffix:semicolon
r_int
id|pcibr_device_flags_set
c_func
(paren
id|vertex_hdl_t
comma
id|pcibr_device_flags_t
)paren
suffix:semicolon
r_extern
id|cfg_p
id|pcibr_config_addr
c_func
(paren
id|vertex_hdl_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_uint64
id|pcibr_config_get
c_func
(paren
id|vertex_hdl_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_config_set
c_func
(paren
id|vertex_hdl_t
comma
r_int
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
r_extern
id|pcibr_hints_t
id|pcibr_hints_get
c_func
(paren
id|vertex_hdl_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_fix_rrbs
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_dualslot
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_intr_bits
c_func
(paren
id|vertex_hdl_t
comma
id|pcibr_intr_bits_f
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_set_rrb_callback
c_func
(paren
id|vertex_hdl_t
comma
id|rrb_alloc_funct_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_handsoff
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_subdevs
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_uint64
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_info_free
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pcibr_slot_info_resp_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_slot_func_info_return
c_func
(paren
id|pcibr_info_h
comma
r_int
comma
id|pcibr_slot_func_info_resp_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_call_device_detach
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_attach
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_int
comma
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_detach
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_int
comma
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_initial_rrb
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    Device(x) register management&n; */
multiline_comment|/* pcibr_try_set_device: attempt to modify Device(x)&n; * for the specified slot on the specified bridge&n; * as requested in flags, limited to the specified&n; * bits. Returns which BRIDGE bits were in conflict,&n; * or ZERO if everything went OK.&n; *&n; * Caller MUST hold pcibr_lock when calling this function.&n; */
r_static
r_int
DECL|function|pcibr_try_set_device
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
r_int
id|flags
comma
id|bridgereg_t
id|mask
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|bridgereg_t
id|old
suffix:semicolon
id|bridgereg_t
r_new
suffix:semicolon
id|bridgereg_t
id|chg
suffix:semicolon
id|bridgereg_t
id|bad
suffix:semicolon
id|bridgereg_t
id|badpmu
suffix:semicolon
id|bridgereg_t
id|badd32
suffix:semicolon
id|bridgereg_t
id|badd64
suffix:semicolon
id|bridgereg_t
id|fix
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|bridgereg_t
id|xmask
suffix:semicolon
id|xmask
op_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|xmask
op_assign
id|XBRIDGE_DEV_PMU_BITS
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|xmask
op_assign
id|XBRIDGE_DEV_D64_BITS
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|old
op_assign
id|slotp-&gt;bss_device
suffix:semicolon
multiline_comment|/* figure out what the desired&n;     * Device(x) bits are based on&n;     * the flags specified.&n;     */
r_new
op_assign
id|old
suffix:semicolon
multiline_comment|/* Currently, we inherit anything that&n;     * the new caller has not specified in&n;     * one way or another, unless we take&n;     * action here to not inherit.&n;     *&n;     * This is needed for the &quot;swap&quot; stuff,&n;     * since it could have been set via&n;     * pcibr_endian_set -- altho note that&n;     * any explicit PCIBR_BYTE_STREAM or&n;     * PCIBR_WORD_VALUES will freely override&n;     * the effect of that call (and vice&n;     * versa, no protection either way).&n;     *&n;     * I want to get rid of pcibr_endian_set&n;     * in favor of tracking DMA endianness&n;     * using the flags specified when DMA&n;     * channels are created.&n;     */
DECL|macro|BRIDGE_DEV_WRGA_BITS
mdefine_line|#define&t;BRIDGE_DEV_WRGA_BITS&t;(BRIDGE_DEV_PMU_WRGA_EN | BRIDGE_DEV_DIR_WRGA_EN)
DECL|macro|BRIDGE_DEV_SWAP_BITS
mdefine_line|#define&t;BRIDGE_DEV_SWAP_BITS&t;(BRIDGE_DEV_SWAP_PMU | BRIDGE_DEV_SWAP_DIR)
multiline_comment|/* Do not use Barrier, Write Gather,&n;     * or Prefetch unless asked.&n;     * Leave everything else as it&n;     * was from the last time.&n;     */
r_new
op_assign
r_new
op_amp
op_complement
id|BRIDGE_DEV_BARRIER
op_amp
op_complement
id|BRIDGE_DEV_WRGA_BITS
op_amp
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
multiline_comment|/* Generic macro flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_DATA
)paren
(brace
r_new
op_assign
(paren
r_new
op_amp
op_complement
id|BRIDGE_DEV_BARRIER
)paren
multiline_comment|/* barrier off */
op_or
id|BRIDGE_DEV_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_CMD
)paren
(brace
r_new
op_assign
(paren
(paren
r_new
op_amp
op_complement
id|BRIDGE_DEV_PREF
)paren
multiline_comment|/* prefetch off */
op_amp
op_complement
id|BRIDGE_DEV_WRGA_BITS
)paren
multiline_comment|/* write gather off */
op_or
id|BRIDGE_DEV_BARRIER
suffix:semicolon
multiline_comment|/* barrier on */
)brace
multiline_comment|/* Generic detail flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WRITE_GATHER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOWRITE_GATHER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_PREFETCH
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOPREFETCH
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
r_new
op_or_assign
id|BRIDGE_DEV_SWAP_DIR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_SWAP_DIR
suffix:semicolon
multiline_comment|/* Provider-specific flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_64BIT
)paren
r_new
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NO64BIT
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
multiline_comment|/*&n;     * PIC BRINGUP WAR (PV# 855271):&n;     * Allow setting BRIDGE_DEV_VIRTUAL_EN on PIC iff we&squot;re a 64-bit&n;     * device.  The bit is only intended for 64-bit devices and, on&n;     * PIC, can cause problems for 32-bit devices.&n;     */
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
op_logical_and
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV855271
comma
id|pcibr_soft
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
(brace
r_new
op_or_assign
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
id|xmask
op_or_assign
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
)brace
)brace
multiline_comment|/* PIC BRINGUP WAR (PV# 878674):   Don&squot;t allow 64bit PIO accesses */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
(paren
id|flags
op_amp
id|PCIBR_64BIT
)paren
op_logical_and
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV878674
comma
id|pcibr_soft
)paren
)paren
(brace
r_new
op_and_assign
op_complement
(paren
l_int|1ull
op_lshift
l_int|22
)paren
suffix:semicolon
)brace
id|chg
op_assign
id|old
op_xor
r_new
suffix:semicolon
multiline_comment|/* what are we changing, */
id|chg
op_and_assign
id|xmask
suffix:semicolon
multiline_comment|/* of the interesting bits */
r_if
c_cond
(paren
id|chg
)paren
(brace
id|badd32
op_assign
id|slotp-&gt;bss_d32_uctr
ques
c_cond
(paren
id|BRIDGE_DEV_D32_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|badpmu
op_assign
id|slotp-&gt;bss_pmu_uctr
ques
c_cond
(paren
id|XBRIDGE_DEV_PMU_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|badd64
op_assign
id|slotp-&gt;bss_d64_uctr
ques
c_cond
(paren
id|XBRIDGE_DEV_D64_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|bad
op_assign
id|badpmu
op_or
id|badd32
op_or
id|badd64
suffix:semicolon
r_if
c_cond
(paren
id|bad
)paren
(brace
multiline_comment|/* some conflicts can be resolved by&n;&t;     * forcing the bit on. this may cause&n;&t;     * some performance degredation in&n;&t;     * the stream(s) that want the bit off,&n;&t;     * but the alternative is not allowing&n;&t;     * the new stream at all.&n;&t;     */
r_if
c_cond
(paren
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_PRECISE
op_or
id|BRIDGE_DEV_BARRIER
)paren
)paren
)paren
(brace
id|bad
op_and_assign
op_complement
id|fix
suffix:semicolon
multiline_comment|/* don&squot;t change these bits if&n;&t;&t; * they are already set in &quot;old&quot;&n;&t;&t; */
id|chg
op_and_assign
op_complement
(paren
id|fix
op_amp
id|old
)paren
suffix:semicolon
)brace
multiline_comment|/* some conflicts can be resolved by&n;&t;     * forcing the bit off. this may cause&n;&t;     * some performance degredation in&n;&t;     * the stream(s) that want the bit on,&n;&t;     * but the alternative is not allowing&n;&t;     * the new stream at all.&n;&t;     */
r_if
c_cond
(paren
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_WRGA_BITS
op_or
id|BRIDGE_DEV_PREF
)paren
)paren
)paren
(brace
id|bad
op_and_assign
op_complement
id|fix
suffix:semicolon
multiline_comment|/* don&squot;t change these bits if&n;&t;&t; * we wanted to turn them on.&n;&t;&t; */
id|chg
op_and_assign
op_complement
(paren
id|fix
op_amp
r_new
)paren
suffix:semicolon
)brace
multiline_comment|/* conflicts in other bits mean&n;&t;     * we can not establish this DMA&n;&t;     * channel while the other(s) are&n;&t;     * still present.&n;&t;     */
r_if
c_cond
(paren
id|bad
)paren
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;pcibr_try_set_device: mod blocked by 0x%x&bslash;n&quot;
comma
id|bad
)paren
)paren
suffix:semicolon
r_return
id|bad
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|slotp-&gt;bss_pmu_uctr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D32_BITS
)paren
id|slotp-&gt;bss_d32_uctr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|slotp-&gt;bss_d64_uctr
op_increment
suffix:semicolon
multiline_comment|/* the value we want to write is the&n;     * original value, with the bits for&n;     * our selected changes flipped, and&n;     * with any disabled features turned off.&n;     */
r_new
op_assign
id|old
op_xor
id|chg
suffix:semicolon
multiline_comment|/* only change what we want to change */
r_if
c_cond
(paren
id|slotp-&gt;bss_device
op_eq
r_new
)paren
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_assign
r_new
suffix:semicolon
id|slotp-&gt;bss_device
op_assign
r_new
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;pcibr_try_set_device: Device(%d): 0x%x&bslash;n&quot;
comma
id|slot
comma
r_new
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_release_device
id|pcibr_release_device
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|bridgereg_t
id|mask
)paren
(brace
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|slotp-&gt;bss_pmu_uctr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D32_BITS
)paren
id|slotp-&gt;bss_d32_uctr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|slotp-&gt;bss_d64_uctr
op_decrement
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * flush write gather buffer for slot&n; */
r_static
r_void
DECL|function|pcibr_device_write_gather_flush
id|pcibr_device_write_gather_flush
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_volatile
r_uint32
id|wrf
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|wrf
op_assign
id|bridge-&gt;b_wr_req_buf
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    Bridge (pcibr) &quot;Device Driver&quot; entry points&n; */
r_static
r_int
DECL|function|pcibr_mmap
id|pcibr_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|vertex_hdl_t
id|pcibr_vhdl
op_assign
id|file-&gt;f_dentry-&gt;d_fsdata
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|phys_addr
op_assign
(paren
r_int
r_int
)paren
id|bridge
op_amp
op_complement
l_int|0xc000000000000000
suffix:semicolon
multiline_comment|/* Mask out the Uncache bits */
id|vma-&gt;vm_page_prot
op_assign
id|pgprot_noncached
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|VM_RESERVED
op_or
id|VM_IO
suffix:semicolon
id|error
op_assign
id|io_remap_page_range
c_func
(paren
id|vma
comma
id|phys_addr
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the file operation table for the pcibr driver.&n; * As each of the functions are implemented, put the&n; * appropriate function name below.&n; */
r_static
r_int
id|pcibr_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
DECL|variable|pcibr_fops
r_struct
id|file_operations
id|pcibr_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|mmap
op_assign
id|pcibr_mmap
comma
)brace
suffix:semicolon
multiline_comment|/* This is special case code used by grio. There are plans to make&n; * this a bit more general in the future, but till then this should&n; * be sufficient.&n; */
id|pciio_slot_t
DECL|function|pcibr_device_slot_get
id|pcibr_device_slot_get
c_func
(paren
id|vertex_hdl_t
id|dev_vhdl
)paren
(brace
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|vertex_hdl_t
id|tdev
suffix:semicolon
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|PCIIO_SLOT_NONE
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|dev_vhdl
comma
id|devname
comma
id|MAXDEVNAME
)paren
suffix:semicolon
multiline_comment|/* run back along the canonical path&n;     * until we find a PCI connection point.&n;     */
id|tdev
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|dev_vhdl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tdev
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
id|pciio_info
op_assign
id|pciio_info_chk
c_func
(paren
id|tdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
)paren
(brace
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|tdev
)paren
suffix:semicolon
id|tdev
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|tdev
)paren
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|tdev
)paren
suffix:semicolon
r_return
id|slot
suffix:semicolon
)brace
id|pcibr_info_t
DECL|function|pcibr_info_get
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
id|vhdl
)paren
(brace
r_return
(paren
id|pcibr_info_t
)paren
id|pciio_info_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
)brace
id|pcibr_info_t
DECL|function|pcibr_device_info_new
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|rfunc
comma
id|pciio_vendor_id_t
id|vendor
comma
id|pciio_device_id_t
id|device
)paren
(brace
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
r_int
id|ibit
suffix:semicolon
id|func
op_assign
(paren
id|rfunc
op_eq
id|PCIIO_FUNC_NONE
)paren
ques
c_cond
l_int|0
suffix:colon
id|rfunc
suffix:semicolon
multiline_comment|/*&n;     * Create a pciio_info_s for this device.  pciio_device_info_new()&n;     * will set the c_slot (which is suppose to represent the external&n;     * slot (i.e the slot number silk screened on the back of the I/O&n;     * brick)).  So for PIC we need to adjust this &quot;internal slot&quot; num&n;     * passed into us, into its external representation.  See comment&n;     * for the PCIBR_DEVICE_TO_SLOT macro for more information.&n;     */
id|pcibr_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_info
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcibr_info
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pcibr_info
)paren
)paren
)paren
suffix:semicolon
id|pciio_device_info_new
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
comma
id|pcibr_soft-&gt;bs_vhdl
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
id|pcibr_info-&gt;f_dev
op_assign
id|slot
suffix:semicolon
multiline_comment|/* Set PCI bus number */
id|pcibr_info-&gt;f_bus
op_assign
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_soft-&gt;bs_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
multiline_comment|/*&n;&t; * Currently favored mapping from PCI&n;&t; * slot number and INTA/B/C/D to Bridge&n;&t; * PCI Interrupt Bit Number:&n;&t; *&n;&t; *     SLOT     A B C D&n;&t; *      0       0 4 0 4&n;&t; *      1       1 5 1 5&n;&t; *      2       2 6 2 6&n;&t; *      3       3 7 3 7&n;&t; *      4       4 0 4 0&n;&t; *      5       5 1 5 1&n;&t; *      6       6 2 6 2&n;&t; *      7       7 3 7 3&n;&t; *&n;&t; * XXX- allow pcibr_hints to override default&n;&t; * XXX- allow ADMIN to override pcibr_hints&n;&t; */
r_for
c_loop
(paren
id|ibit
op_assign
l_int|0
suffix:semicolon
id|ibit
OL
l_int|4
suffix:semicolon
op_increment
id|ibit
)paren
id|pcibr_info-&gt;f_ibit
(braket
id|ibit
)braket
op_assign
(paren
id|slot
op_plus
l_int|4
op_star
id|ibit
)paren
op_amp
l_int|7
suffix:semicolon
multiline_comment|/*&n;&t; * Record the info in the sparse func info space.&n;&t; */
r_if
c_cond
(paren
id|func
OL
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
)paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
(braket
id|func
)braket
op_assign
id|pcibr_info
suffix:semicolon
)brace
r_return
id|pcibr_info
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_device_unregister&n; *&t;This frees up any hardware resources reserved for this PCI device&n; * &t;and removes any PCI infrastructural information setup for it.&n; *&t;This is usually used at the time of shutting down of the PCI card.&n; */
r_int
DECL|function|pcibr_device_unregister
id|pcibr_device_unregister
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|count_vchan0
comma
id|count_vchan1
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error_call
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_vhdl
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Clear all the hardware xtalk resources for this device */
id|xtalk_widgetdev_shutdown
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Flush all the rrbs */
id|pcibr_rrb_flush
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the RRB configuration for this slot has changed, set it &n;     * back to the boot-time default&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
op_ge
l_int|0
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN2
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN3
)braket
suffix:semicolon
multiline_comment|/* Free the rrbs allocated to this slot, both the normal &amp; virtual */
id|do_pcibr_rrb_free_all
c_func
(paren
id|pcibr_soft
comma
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|count_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
suffix:semicolon
id|count_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|slot
)braket
(braket
id|VCHAN1
)braket
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|pcibr_rrb_alloc
c_func
(paren
id|pconn_vhdl
comma
op_amp
id|count_vchan0
comma
op_amp
id|count_vchan1
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush the write buffers !! */
id|error_call
op_assign
id|pcibr_wrb_flush
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_call
)paren
id|error
op_assign
id|error_call
suffix:semicolon
multiline_comment|/* Clear the information specific to the slot */
id|error_call
op_assign
id|pcibr_slot_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_call
)paren
id|error
op_assign
id|error_call
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_driver_reg_callback&n; *      CDL will call this function for each device found in the PCI&n; *      registry that matches the vendor/device IDs supported by &n; *      the driver being registered.  The device&squot;s connection vertex&n; *      and the driver&squot;s attach function return status enable the&n; *      slot&squot;s device status to be set.&n; */
r_void
DECL|function|pcibr_driver_reg_callback
id|pcibr_driver_reg_callback
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
r_int
id|key1
comma
r_int
id|key2
comma
r_int
id|error
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
multiline_comment|/* Do not set slot status for vendor/device ID wildcard drivers */
r_if
c_cond
(paren
(paren
id|key1
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|key2
op_eq
op_minus
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_vhdl
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_INCMPLT
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_CMPLT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pcibr_driver_unreg_callback&n; *      CDL will call this function for each device found in the PCI&n; *      registry that matches the vendor/device IDs supported by &n; *      the driver being unregistered.  The device&squot;s connection vertex&n; *      and the driver&squot;s detach function return status enable the&n; *      slot&squot;s device status to be set.&n; */
r_void
DECL|function|pcibr_driver_unreg_callback
id|pcibr_driver_unreg_callback
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
r_int
id|key1
comma
r_int
id|key2
comma
r_int
id|error
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
multiline_comment|/* Do not set slot status for vendor/device ID wildcard drivers */
r_if
c_cond
(paren
(paren
id|key1
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|key2
op_eq
op_minus
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_vhdl
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_INCMPLT
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_CMPLT
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * build a convenience link path in the&n; * form of &quot;.../&lt;iobrick&gt;/bus/&lt;busnum&gt;&quot;&n; * &n; * returns 1 on success, 0 otherwise&n; *&n; * depends on hwgraph separator == &squot;/&squot;&n; */
r_int
DECL|function|pcibr_bus_cnvlink
id|pcibr_bus_cnvlink
c_func
(paren
id|vertex_hdl_t
id|f_c
)paren
(brace
r_char
id|dst
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_char
op_star
id|dp
op_assign
id|dst
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|xp
suffix:semicolon
r_int
id|widgetnum
suffix:semicolon
r_char
id|pcibus
(braket
l_int|8
)braket
suffix:semicolon
id|vertex_hdl_t
id|nvtx
comma
id|svtx
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|f_c
comma
l_string|&quot;pcibr_bus_cnvlink&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_vertex_name_get
c_func
(paren
id|f_c
comma
id|dst
comma
id|MAXDEVNAME
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* dst example == /hw/module/001c02/Pbrick/xtalk/8/pci/direct */
multiline_comment|/* find the widget number */
id|xp
op_assign
id|strstr
c_func
(paren
id|dst
comma
l_string|&quot;/&quot;
id|EDGE_LBL_XTALK
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|widgetnum
op_assign
id|simple_strtoul
c_func
(paren
id|xp
op_plus
l_int|7
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|widgetnum
template_param
id|XBOW_PORT_F
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* remove &quot;/pci/direct&quot; from path */
id|cp
op_assign
id|strstr
c_func
(paren
id|dst
comma
l_string|&quot;/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/&quot;
id|EDGE_LBL_DIRECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|cp
op_assign
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* get the vertex for the widget */
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
l_int|NULL
comma
id|dp
comma
op_amp
id|svtx
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|xp
op_assign
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* remove &quot;/xtalk/...&quot; from path */
multiline_comment|/* dst example now == /hw/module/001c02/Pbrick */
multiline_comment|/* get the bus number */
id|strcat
c_func
(paren
id|dst
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|dst
comma
id|EDGE_LBL_BUS
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pcibus
comma
l_string|&quot;%d&quot;
comma
id|p_busnum
(braket
id|widgetnum
)braket
)paren
suffix:semicolon
multiline_comment|/* link to bus to widget */
id|rv
op_assign
id|hwgraph_path_add
c_func
(paren
l_int|NULL
comma
id|dp
comma
op_amp
id|nvtx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|rv
)paren
id|rv
op_assign
id|hwgraph_edge_add
c_func
(paren
id|nvtx
comma
id|svtx
comma
id|pcibus
)paren
suffix:semicolon
r_return
(paren
id|rv
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_attach: called every time the crosstalk&n; *      infrastructure is asked to initialize a widget&n; *      that matches the part number we handed to the&n; *      registration routine above.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_attach
id|pcibr_attach
c_func
(paren
id|vertex_hdl_t
id|xconn_vhdl
)paren
(brace
multiline_comment|/* REFERENCED */
id|graph_error_t
id|rc
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|xconn_vhdl
comma
l_string|&quot;pcibr_attach&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_piotrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|NULL
comma
l_int|0
comma
r_sizeof
(paren
id|bridge_t
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * Create the vertex for the PCI bus, which we&n;     * will also use to hold the pcibr_soft and&n;     * which will be the &quot;master&quot; vertex for all the&n;     * pciio connection points we will hang off it.&n;     * This needs to happen before we call nic_bridge_vertex_info&n;     * as we are some of the *_vmc functions need access to the edges.&n;     *&n;     * Opening this vertex will provide access to&n;     * the Bridge registers themselves.&n;     */
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|xconn_vhdl
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|pciio_provider_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_provider
)paren
suffix:semicolon
id|pciio_provider_startup
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_return
id|pcibr_attach2
c_func
(paren
id|xconn_vhdl
comma
id|bridge
comma
id|pcibr_vhdl
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_attach2
id|pcibr_attach2
c_func
(paren
id|vertex_hdl_t
id|xconn_vhdl
comma
id|bridge_t
op_star
id|bridge
comma
id|vertex_hdl_t
id|pcibr_vhdl
comma
r_int
id|busnum
comma
id|pcibr_soft_t
op_star
id|ret_softp
)paren
(brace
multiline_comment|/* REFERENCED */
id|vertex_hdl_t
id|ctlr_vhdl
suffix:semicolon
id|bridgereg_t
id|id
suffix:semicolon
r_int
id|rev
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|xwidget_info_t
id|info
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
r_int
id|slot
suffix:semicolon
r_int
id|ibit
suffix:semicolon
id|vertex_hdl_t
id|noslot_conn
suffix:semicolon
r_char
id|devnm
(braket
id|MAXDEVNAME
)braket
comma
op_star
id|s
suffix:semicolon
id|pcibr_hints_t
id|pcibr_hints
suffix:semicolon
r_uint64
id|int_enable
suffix:semicolon
id|picreg_t
id|int_enable_64
suffix:semicolon
r_int
id|rrb_fixed
op_assign
l_int|0
suffix:semicolon
macro_line|#if PCI_FBBE
r_int
id|fast_back_to_back_enable
suffix:semicolon
macro_line|#endif
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|iobrick_type_get_nasid
c_func
(paren
id|nasid_t
id|nasid
)paren
suffix:semicolon
r_int
id|iomoduleid_get
c_func
(paren
id|nasid_t
id|nasid
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: bridge=0x%p, busnum=%d&bslash;n&quot;
comma
id|bridge
comma
id|busnum
)paren
)paren
suffix:semicolon
id|ctlr_vhdl
op_assign
l_int|NULL
suffix:semicolon
id|ctlr_vhdl
op_assign
id|hwgraph_register
c_func
(paren
id|pcibr_vhdl
comma
id|EDGE_LBL_CONTROLLER
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
(paren
r_struct
id|file_operations
op_star
)paren
op_amp
id|pcibr_fops
comma
(paren
r_void
op_star
)paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ctlr_vhdl
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;     * Get the hint structure; if some NIC callback&n;     * marked this vertex as &quot;hands-off&quot; then we&n;     * just return here, before doing anything else.&n;     */
id|pcibr_hints
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints
op_logical_and
id|pcibr_hints-&gt;ph_hands_off
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* generic operations disabled */
id|id
op_assign
id|bridge-&gt;b_wid_id
suffix:semicolon
id|rev
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|hwgraph_info_add_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
(paren
id|arbitrary_info_t
)paren
id|rev
)paren
suffix:semicolon
multiline_comment|/*&n;     * allocate soft state structure, fill in some&n;     * fields, and hook it up to our vertex.&n;     */
id|pcibr_soft
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_soft
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_softp
)paren
op_star
id|ret_softp
op_assign
id|pcibr_soft
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
r_sizeof
op_star
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft_set
c_func
(paren
id|pcibr_vhdl
comma
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_conn
op_assign
id|xconn_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_base
op_assign
id|bridge
suffix:semicolon
id|pcibr_soft-&gt;bs_rev_num
op_assign
id|rev
suffix:semicolon
id|pcibr_soft-&gt;bs_intr_bits
op_assign
(paren
id|pcibr_intr_bits_f
op_star
)paren
id|pcibr_intr_bits
suffix:semicolon
id|pcibr_soft-&gt;bs_min_slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lowest possible slot# */
id|pcibr_soft-&gt;bs_max_slot
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* highest possible slot# */
id|pcibr_soft-&gt;bs_busnum
op_assign
id|busnum
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_type
op_assign
id|PCIBR_BRIDGETYPE_PIC
suffix:semicolon
r_switch
c_cond
(paren
id|pcibr_soft-&gt;bs_bridge_type
)paren
(brace
r_case
id|PCIBR_BRIDGETYPE_BRIDGE
suffix:colon
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|BRIDGE_INTERNAL_ATES
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* speed is not available in bridge */
r_break
suffix:semicolon
r_case
id|PCIBR_BRIDGETYPE_PIC
suffix:colon
id|pcibr_soft-&gt;bs_min_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_max_slot
op_assign
l_int|3
suffix:semicolon
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|XBRIDGE_INTERNAL_ATES
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_mode
op_assign
(paren
(paren
(paren
id|bridge-&gt;p_wid_stat_64
op_amp
id|PIC_STAT_PCIX_SPEED
)paren
op_rshift
l_int|33
)paren
op_or
(paren
(paren
id|bridge-&gt;p_wid_stat_64
op_amp
id|PIC_STAT_PCIX_ACTIVE
)paren
op_rshift
l_int|33
)paren
)paren
suffix:semicolon
multiline_comment|/* We have to clear PIC&squot;s write request buffer to avoid parity&n;&t; * errors.  See PV#854845.&n;&t; */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIC_WR_REQ_BUFSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bridge-&gt;p_wr_req_lower
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|bridge-&gt;p_wr_req_upper
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|bridge-&gt;p_wr_req_parity
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|PCIBR_BRIDGETYPE_XBRIDGE
suffix:colon
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|XBRIDGE_INTERNAL_ATES
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_mode
op_assign
(paren
(paren
id|bridge-&gt;b_wid_control
op_amp
id|BRIDGE_CTRL_PCI_SPEED
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: pcibr_soft=0x%x, mode=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|pcibr_soft-&gt;bs_bridge_mode
)paren
)paren
suffix:semicolon
id|pcibr_soft-&gt;bsi_err_intr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bridges up through REV C&n;     * are unable to set the direct&n;     * byteswappers to BYTE_STREAM.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_le
id|BRIDGE_PART_REV_C
)paren
(brace
id|pcibr_soft-&gt;bs_pio_end_io
op_assign
id|PCIIO_WORD_VALUES
suffix:semicolon
id|pcibr_soft-&gt;bs_pio_end_mem
op_assign
id|PCIIO_WORD_VALUES
suffix:semicolon
)brace
macro_line|#if PCIBR_SOFT_LIST
multiline_comment|/*&n;     * link all the pcibr_soft structs&n;     */
(brace
id|pcibr_list_p
id|self
suffix:semicolon
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|self
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|self
)paren
)paren
)paren
suffix:semicolon
id|self-&gt;bl_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|self-&gt;bl_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|self-&gt;bl_next
op_assign
id|pcibr_list
suffix:semicolon
id|pcibr_list
op_assign
id|self
suffix:semicolon
)brace
macro_line|#endif /* PCIBR_SOFT_LIST */
multiline_comment|/*&n;     * get the name of this bridge vertex and keep the info. Use this&n;     * only where it is really needed now: like error interrupts.&n;     */
id|s
op_assign
id|dev_to_name
c_func
(paren
id|pcibr_vhdl
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pcibr_soft-&gt;bs_name
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: %s ASIC: rev %s (code=0x%x)&bslash;n&quot;
comma
l_string|&quot;PIC&quot;
comma
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_A
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_B
)paren
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_C
)paren
ques
c_cond
l_string|&quot;C&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_D
)paren
ques
c_cond
l_string|&quot;D&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBRIDGE_PART_REV_A
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBRIDGE_PART_REV_B
)paren
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
(paren
id|IS_PIC_PART_REV_A
c_func
(paren
id|rev
)paren
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|rev
comma
id|pcibr_soft-&gt;bs_name
)paren
)paren
suffix:semicolon
id|info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_xid
op_assign
id|xwidget_info_id_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_master
op_assign
id|xwidget_info_master_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_mxid
op_assign
id|xwidget_info_masterid_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_first_slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|pcibr_soft-&gt;bs_last_slot
op_assign
id|pcibr_soft-&gt;bs_max_slot
suffix:semicolon
multiline_comment|/*&n;     * Bridge can only reset slots 0, 1, 2, and 3.  Ibrick internal&n;     * slots 4, 5, 6, and 7 must be reset as a group, so do not&n;     * reset them.&n;     */
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|3
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|bridge
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_bricktype
op_assign
id|iobrick_type_get_nasid
c_func
(paren
id|nasid
)paren
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;0x%p: Unknown bricktype : 0x%x&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|xconn_vhdl
comma
(paren
r_int
r_int
)paren
id|pcibr_soft-&gt;bs_bricktype
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_moduleid
op_assign
id|iomoduleid_get
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
)paren
(brace
r_case
id|MODULE_PXBRICK
suffix:colon
r_case
id|MODULE_IXBRICK
suffix:colon
id|pcibr_soft-&gt;bs_first_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If Bus 1 has IO9 then there are 4 devices in that bus.  Note&n;&t;     * we figure this out from klconfig since the kernel has yet to &n;&t;     * probe&n;&t;     */
r_if
c_cond
(paren
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
op_eq
l_int|1
)paren
(brace
id|lboard_t
op_star
id|brd
op_assign
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_while
c_loop
(paren
id|brd
)paren
(brace
r_if
c_cond
(paren
id|brd-&gt;brd_flags
op_amp
id|LOCAL_MASTER_IO6
)paren
(brace
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|3
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|3
suffix:semicolon
)brace
id|brd
op_assign
id|KLCF_NEXT
c_func
(paren
id|brd
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|MODULE_PBRICK
suffix:colon
id|pcibr_soft-&gt;bs_first_slot
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|2
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_IBRICK
suffix:colon
multiline_comment|/*&n;&t;     * Here&squot;s the current baseio layout for SN1 style systems:&n;&t;     *&n;&t;     *    0    1    2    3    4    5    6    7&t;&t;slot#&n;&t;     *&n;&t;     *    x    scsi x    x    ioc3 usb  x    x  &t;O300 Ibrick&n;&t;     *&n;             * x == never occupied&n;             * E == external (add-in) slot&n;&t;     *&n;&t;     */
id|pcibr_soft-&gt;bs_first_slot
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ibrick first slot == 1 */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xid
op_eq
l_int|0xe
)paren
(brace
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|2
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|6
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: %cbrick, slots %d-%d&bslash;n&quot;
comma
id|MODULE_GET_BTCHAR
c_func
(paren
id|pcibr_soft-&gt;bs_moduleid
)paren
comma
id|pcibr_soft-&gt;bs_first_slot
comma
id|pcibr_soft-&gt;bs_last_slot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Initialize bridge and bus locks&n;     */
id|spin_lock_init
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we have one, process the hints structure.&n;     */
r_if
c_cond
(paren
id|pcibr_hints
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_HINTS
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: pcibr_hints=0x%x&bslash;n&quot;
comma
id|pcibr_hints
)paren
)paren
suffix:semicolon
id|rrb_fixed
op_assign
id|pcibr_hints-&gt;ph_rrb_fixed
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_fixed
op_assign
id|rrb_fixed
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints-&gt;ph_intr_bits
)paren
(brace
id|pcibr_soft-&gt;bs_intr_bits
op_assign
id|pcibr_hints-&gt;ph_intr_bits
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
r_int
id|hslot
op_assign
id|pcibr_hints-&gt;ph_host_slot
(braket
id|slot
)braket
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hslot
OL
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|slot
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|hslot
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Set-up initial values for state fields&n;     */
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_devio.bssd_ref_cnt
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ibit
op_assign
l_int|0
suffix:semicolon
id|ibit
OL
l_int|8
suffix:semicolon
op_increment
id|ibit
)paren
(brace
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_xtalk_intr
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
op_assign
l_int|NULL
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_stat
op_assign
op_amp
(paren
id|bridge-&gt;b_int_status
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_ibit
op_assign
id|ibit
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_hdlrcnt
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * connect up our error handler.  PIC has 2 busses (thus resulting in 2&n;     * pcibr_soft structs under 1 widget), so only register a xwidget error&n;     * handler for PIC&squot;s bus0.  NOTE: for PIC pcibr_error_handler_wrapper()&n;     * is a wrapper routine we register that will call the real error handler&n;     * pcibr_error_handler() with the correct pcibr_soft struct.&n;     */
r_if
c_cond
(paren
id|busnum
op_eq
l_int|0
)paren
(brace
id|xwidget_error_register
c_func
(paren
id|xconn_vhdl
comma
id|pcibr_error_handler_wrapper
comma
id|pcibr_soft
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Initialize various Bridge registers.&n;     */
multiline_comment|/*&n;     * On pre-Rev.D bridges, set the PCI_RETRY_CNT&n;     * to zero to avoid dropping stores. (#475347)&n;     */
r_if
c_cond
(paren
id|rev
OL
id|BRIDGE_PART_REV_D
)paren
id|bridge-&gt;b_bus_timeout
op_and_assign
op_complement
id|BRIDGE_BUS_PCI_RETRY_MASK
suffix:semicolon
multiline_comment|/*&n;     * Clear all pending interrupts.&n;     */
id|bridge-&gt;b_int_rst_stat
op_assign
(paren
id|BRIDGE_IRR_ALL_CLR
)paren
suffix:semicolon
multiline_comment|/* Initialize some PIC specific registers. */
(brace
id|picreg_t
id|pic_ctrl_reg
op_assign
id|bridge-&gt;p_wid_control_64
suffix:semicolon
multiline_comment|/* Bridges Requester ID: bus = busnum, dev = 0, func = 0 */
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_BUS_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_BUS_NUM
c_func
(paren
id|busnum
)paren
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_DEV_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_FUN_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_NO_SNOOP
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_RELAX_ORDER
suffix:semicolon
multiline_comment|/* enable parity checking on PICs internal RAM */
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_RESP
suffix:semicolon
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_ATE
suffix:semicolon
multiline_comment|/* PIC BRINGUP WAR (PV# 862253): dont enable write request&n;&t; * parity checking.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV862253
comma
id|pcibr_soft
)paren
)paren
(brace
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_REQ
suffix:semicolon
)brace
id|bridge-&gt;p_wid_control_64
op_assign
id|pic_ctrl_reg
suffix:semicolon
)brace
id|bridge-&gt;b_int_device
op_assign
(paren
r_uint32
)paren
l_int|0x006db6db
suffix:semicolon
(brace
id|bridgereg_t
id|dirmap
suffix:semicolon
id|paddr_t
id|paddr
suffix:semicolon
id|iopaddr_t
id|xbase
suffix:semicolon
id|xwidgetnum_t
id|xport
suffix:semicolon
id|iopaddr_t
id|offset
suffix:semicolon
r_int
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
multiline_comment|/* Set the Bridge&squot;s 32-bit PCI to XTalk&n;&t; * Direct Map register to the most useful&n;&t; * value we can determine.  Note that we&n;&t; * must use a single xid for all of:&n;&t; *      direct-mapped 32-bit DMA accesses&n;&t; *      direct-mapped 64-bit DMA accesses&n;&t; *      DMA accesses through the PMU&n;&t; *      interrupts&n;&t; * This is the only way to guarantee that&n;&t; * completion interrupts will reach a CPU&n;&t; * after all DMA data has reached memory.&n;&t; * (Of course, there may be a few special&n;&t; * drivers/controlers that explicitly manage&n;&t; * this ordering problem.)&n;&t; */
id|cnodeid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default node id */
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|paddr
op_assign
id|NODE_OFFSET
c_func
(paren
id|nasid
)paren
op_plus
l_int|0
suffix:semicolon
multiline_comment|/* currently, we just assume that if we ask&n;&t; * for a DMA mapping to &quot;zero&quot; the XIO&n;&t; * host will transmute this into a request&n;&t; * for the lowest hunk of memory.&n;&t; */
id|xbase
op_assign
id|xtalk_dmatrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|paddr
comma
id|PAGE_SIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xbase
op_ne
id|XIO_NOWHERE
)paren
(brace
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xbase
)paren
)paren
(brace
id|xport
op_assign
id|XIO_PORT
c_func
(paren
id|xbase
)paren
suffix:semicolon
id|xbase
op_assign
id|XIO_ADDR
c_func
(paren
id|xbase
)paren
suffix:semicolon
)brace
r_else
id|xport
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
id|offset
op_assign
id|xbase
op_amp
(paren
(paren
l_int|1ull
op_lshift
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
)paren
op_minus
l_int|1ull
)paren
suffix:semicolon
id|xbase
op_rshift_assign
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
suffix:semicolon
id|dirmap
op_assign
id|xport
op_lshift
id|BRIDGE_DIRMAP_W_ID_SHFT
suffix:semicolon
r_if
c_cond
(paren
id|xbase
)paren
id|dirmap
op_or_assign
id|BRIDGE_DIRMAP_OFF
op_amp
id|xbase
suffix:semicolon
r_else
r_if
c_cond
(paren
id|offset
op_ge
(paren
l_int|512
op_lshift
l_int|20
)paren
)paren
id|dirmap
op_or_assign
id|BRIDGE_DIRMAP_ADD512
suffix:semicolon
id|bridge-&gt;b_dir_map
op_assign
id|dirmap
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set bridge&squot;s idea of page size according to the system&squot;s&n;&t; * idea of &quot;IO page size&quot;.  TBD: The idea of IO page size&n;&t; * should really go away.&n;&t; */
multiline_comment|/*&n;&t; * ensure that we write and read without any interruption.&n;&t; * The read following the write is required for the Bridge war&n;&t; */
macro_line|#if IOPGSIZE == 4096
id|bridge-&gt;p_wid_control_64
op_and_assign
op_complement
id|BRIDGE_CTRL_PAGE_SIZE
suffix:semicolon
macro_line|#elif IOPGSIZE == 16384
id|bridge-&gt;p_wid_control_64
op_or_assign
id|BRIDGE_CTRL_PAGE_SIZE
suffix:semicolon
macro_line|#else
op_lshift
template_param
suffix:semicolon
macro_line|#endif
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* inval addr bug war */
multiline_comment|/* Initialize internal mapping entries */
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|pcibr_soft-&gt;bs_int_ate_size
suffix:semicolon
id|entry
op_increment
)paren
(brace
id|bridge-&gt;b_int_ate_ram
(braket
id|entry
)braket
dot
id|wr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine if there&squot;s external mapping SSRAM on this&n;&t; * bridge.  Set up Bridge control register appropriately,&n;&t; * inititlize SSRAM, and set software up to manage RAM&n;&t; * entries as an allocatable resource.&n;&t; *&n;&t; * Currently, we just use the rm* routines to manage ATE&n;&t; * allocation.  We should probably replace this with a&n;&t; * Best Fit allocator.&n;&t; *&n;&t; * For now, if we have external SSRAM, avoid using&n;&t; * the internal ssram: we can&squot;t turn PREFETCH on&n;&t; * when we use the internal SSRAM; and besides,&n;&t; * this also guarantees that no allocation will&n;&t; * straddle the internal/external line, so we&n;&t; * can increment ATE write addresses rather than&n;&t; * recomparing against BRIDGE_INTERNAL_ATES every&n;&t; * time.&n;&t; */
id|num_entries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we always have 128 ATEs (512 for Xbridge) inside the chip&n;&t; * even if disabled for debugging.&n;&t; */
id|pcibr_soft-&gt;bs_int_ate_resource.start
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_int_ate_resource.end
op_assign
id|pcibr_soft-&gt;bs_int_ate_size
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|num_entries
OG
id|pcibr_soft-&gt;bs_int_ate_size
)paren
(brace
macro_line|#if PCIBR_ATE_NOTBOTH&t;&t;&t;/* for debug -- forces us to use external ates */
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: disabling internal ATEs.&bslash;n&quot;
)paren
suffix:semicolon
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft
comma
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_ext_ate_resource.start
op_assign
id|pcibr_soft-&gt;bs_int_ate_size
suffix:semicolon
id|pcibr_soft-&gt;bs_ext_ate_resource.end
op_assign
id|num_entries
suffix:semicolon
)brace
id|pcibr_soft-&gt;bs_allocated_ate_res
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
id|pcibr_soft-&gt;bs_int_ate_size
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pcibr_soft-&gt;bs_allocated_ate_res
comma
l_int|0x0
comma
id|pcibr_soft-&gt;bs_int_ate_size
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATE
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_attach2: %d ATEs, %d internal &amp; %d external&bslash;n&quot;
comma
id|num_entries
ques
c_cond
id|num_entries
suffix:colon
id|pcibr_soft-&gt;bs_int_ate_size
comma
id|pcibr_soft-&gt;bs_int_ate_size
comma
id|num_entries
ques
c_cond
id|num_entries
op_minus
id|pcibr_soft-&gt;bs_int_ate_size
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
(brace
id|bridgereg_t
id|dirmap
suffix:semicolon
id|iopaddr_t
id|xbase
suffix:semicolon
multiline_comment|/*&n;&t; * now figure the *real* xtalk base address&n;&t; * that dirmap sends us to.&n;&t; */
id|dirmap
op_assign
id|bridge-&gt;b_dir_map
suffix:semicolon
r_if
c_cond
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_OFF
)paren
id|xbase
op_assign
(paren
id|iopaddr_t
)paren
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_OFF
)paren
op_lshift
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_ADD512
)paren
id|xbase
op_assign
l_int|512
op_lshift
l_int|20
suffix:semicolon
r_else
id|xbase
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_dir_xbase
op_assign
id|xbase
suffix:semicolon
multiline_comment|/* it is entirely possible that we may, at this&n;&t; * point, have our dirmap pointing somewhere&n;&t; * other than our &quot;master&quot; port.&n;&t; */
id|pcibr_soft-&gt;bs_dir_xport
op_assign
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_W_ID
)paren
op_rshift
id|BRIDGE_DIRMAP_W_ID_SHFT
suffix:semicolon
)brace
multiline_comment|/* pcibr sources an error interrupt;&n;     * figure out where to send it.&n;     *&n;     * If any interrupts are enabled in bridge,&n;     * then the prom set us up and our interrupt&n;     * has already been reconnected in mlreset&n;     * above.&n;     *&n;     * Need to set the D_INTR_ISERR flag&n;     * in the dev_desc used for allocating the&n;     * error interrupt, so our interrupt will&n;     * be properly routed and prioritized.&n;     *&n;     * If our crosstalk provider wants to&n;     * fix widget error interrupts to specific&n;     * destinations, D_INTR_ISERR is how it&n;     * knows to do this.&n;     */
id|xtalk_intr
op_assign
id|xtalk_intr_alloc
c_func
(paren
id|xconn_vhdl
comma
(paren
id|device_desc_t
)paren
l_int|0
comma
id|pcibr_vhdl
)paren
suffix:semicolon
(brace
r_int
id|irq
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_bit
suffix:semicolon
r_int
id|cpu
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_cpuid
suffix:semicolon
id|intr_unreserve_level
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_bit
op_assign
id|SGI_PCIBR_ERROR
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
id|pcibr_soft-&gt;bsi_err_intr
op_assign
id|xtalk_intr
suffix:semicolon
multiline_comment|/*&n;     * On IP35 with XBridge, we do some extra checks in pcibr_setwidint&n;     * in order to work around some addressing limitations.  In order&n;     * for that fire wall to work properly, we need to make sure we&n;     * start from a known clean state.&n;     */
id|pcibr_clearwidint
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
(paren
id|intr_func_t
)paren
id|pcibr_error_intr_handler
comma
(paren
id|intr_arg_t
)paren
id|pcibr_soft
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setwidint
comma
(paren
r_void
op_star
)paren
id|bridge
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|SGI_PCIBR_ERROR
comma
(paren
r_void
op_star
)paren
id|pcibr_error_intr_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;PCIBR error&quot;
comma
(paren
id|intr_arg_t
)paren
id|pcibr_soft
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_setwidint: b_wid_int_upper=0x%x, b_wid_int_lower=0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_wid_int_upper
comma
id|bridge-&gt;b_wid_int_lower
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * now we can start handling error interrupts;&n;     * enable all of them.&n;     * NOTE: some PCI ints may already be enabled.&n;     */
id|int_enable_64
op_assign
id|bridge-&gt;p_int_enable_64
op_or
id|BRIDGE_ISR_ERRORS
suffix:semicolon
id|int_enable
op_assign
(paren
r_uint64
)paren
id|int_enable_64
suffix:semicolon
macro_line|#if BRIDGE_ERROR_INTR_WAR
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_eq
id|BRIDGE_PART_REV_A
)paren
(brace
multiline_comment|/*&n;&t; * We commonly get master timeouts when talking to ql.&n;&t; * We also see RESP_XTALK_ERROR and LLP_TX_RETRY interrupts.&n;&t; * Insure that these are all disabled for now.&n;&t; */
id|int_enable
op_and_assign
op_complement
(paren
id|BRIDGE_IMR_PCI_MST_TIMEOUT
op_or
id|BRIDGE_ISR_RESP_XTLK_ERR
op_or
id|BRIDGE_ISR_LLP_TX_RETRY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
id|BRIDGE_PART_REV_C
)paren
(brace
id|int_enable
op_and_assign
op_complement
id|BRIDGE_ISR_BAD_XRESP_PKT
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* BRIDGE_ERROR_INTR_WAR */
macro_line|#ifdef QL_SCSI_CTRL_WAR&t;&t;&t;/* for IP30 only */
multiline_comment|/* Really a QL rev A issue, but all newer hearts have newer QLs.&n;     * Forces all IO6/MSCSI to be new.&n;     */
r_if
c_cond
(paren
id|heart_rev
c_func
(paren
)paren
op_eq
id|HEART_REV_A
)paren
id|int_enable
op_and_assign
op_complement
id|BRIDGE_IMR_PCI_MST_TIMEOUT
suffix:semicolon
macro_line|#endif
macro_line|#ifdef BRIDGE1_TIMEOUT_WAR
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_eq
id|BRIDGE_PART_REV_A
)paren
(brace
multiline_comment|/*&n;&t; * Turn off these interrupts.  They can&squot;t be trusted in bridge 1&n;&t; */
id|int_enable
op_and_assign
op_complement
(paren
id|BRIDGE_IMR_XREAD_REQ_TIMEOUT
op_or
id|BRIDGE_IMR_UNEXP_RESP
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* PIC BRINGUP WAR (PV# 856864 &amp; 856865): allow the tnums that are&n;     * locked out to be freed up sooner (by timing out) so that the&n;     * read tnums are never completely used up.&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856864
comma
id|pcibr_soft
)paren
)paren
(brace
id|int_enable
op_and_assign
op_complement
id|PIC_ISR_PCIX_REQ_TOUT
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|BRIDGE_ISR_XREAD_REQ_TIMEOUT
suffix:semicolon
id|bridge-&gt;b_wid_req_timeout
op_assign
l_int|0x750
suffix:semicolon
)brace
multiline_comment|/*&n;     * PIC BRINGUP WAR (PV# 856866, 859504, 861476, 861478): Don&squot;t use&n;     * RRB0, RRB8, RRB1, and RRB9.  Assign them to DEVICE[2|3]--VCHAN3&n;     * so they are not used&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856866
comma
id|pcibr_soft
)paren
)paren
(brace
id|bridge-&gt;b_even_resp
op_or_assign
l_int|0x000f000f
suffix:semicolon
id|bridge-&gt;b_odd_resp
op_or_assign
l_int|0x000f000f
suffix:semicolon
)brace
id|bridge-&gt;p_int_enable_64
op_assign
(paren
id|picreg_t
)paren
id|int_enable
suffix:semicolon
id|bridge-&gt;b_int_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do not send &quot;clear interrupt&quot; packets */
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
multiline_comment|/*&n;     * Depending on the rev of bridge, disable certain features.&n;     * Easiest way seems to be to force the PCIBR_NOwhatever&n;     * flag to be on for all DMA calls, which overrides any&n;     * PCIBR_whatever flag or even the setting of whatever&n;     * from the PCIIO_DMA_class flags (or even from the other&n;     * PCIBR flags, since NO overrides YES).&n;     */
id|pcibr_soft-&gt;bs_dma_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PREFETCH:&n;     * Always completely disabled for REV.A;&n;     * at &quot;pcibr_prefetch_enable_rev&quot;, anyone&n;     * asking for PCIIO_PREFETCH gets it.&n;     * Between these two points, you have to ask&n;     * for PCIBR_PREFETCH, which promises that&n;     * your driver knows about known Bridge WARs.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
id|BRIDGE_PART_REV_B
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIBR_NOPREFETCH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
(paren
id|BRIDGE_WIDGET_PART_NUM
op_lshift
l_int|4
)paren
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIIO_NOPREFETCH
suffix:semicolon
multiline_comment|/* WRITE_GATHER: Disabled */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
(paren
id|BRIDGE_WIDGET_PART_NUM
op_lshift
l_int|4
)paren
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIBR_NOWRITE_GATHER
suffix:semicolon
multiline_comment|/* PIC only supports 64-bit direct mapping in PCI-X mode.  Since&n;     * all PCI-X devices that initiate memory transactions must be&n;     * capable of generating 64-bit addressed, we force 64-bit DMAs.&n;     */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIIO_DMA_A64
suffix:semicolon
)brace
(brace
id|iopaddr_t
id|prom_base_addr
op_assign
id|pcibr_soft-&gt;bs_xid
op_lshift
l_int|24
suffix:semicolon
r_int
id|prom_base_size
op_assign
l_int|0x1000000
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
multiline_comment|/* Allocate resource maps based on bus page size; for I/O and memory&n;     * space, free all pages except those in the base area and in the&n;     * range set by the PROM. &n;     *&n;     * PROM creates BAR addresses in this format: 0x0ws00000 where w is&n;     * the widget number and s is the device register offset for the slot.&n;     */
multiline_comment|/* Setup the Bus&squot;s PCI IO Root Resource. */
id|pcibr_soft-&gt;bs_io_win_root_resource.start
op_assign
id|PCIBR_BUS_IO_BASE
suffix:semicolon
id|pcibr_soft-&gt;bs_io_win_root_resource.end
op_assign
l_int|0xffffffff
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to allocate resource structure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Block off the range used by PROM. */
id|res-&gt;start
op_assign
id|prom_base_addr
suffix:semicolon
id|res-&gt;end
op_assign
id|prom_base_addr
op_plus
(paren
id|prom_base_size
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|request_resource
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_io_win_root_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to request_resource()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the Small Window Root Resource */
id|pcibr_soft-&gt;bs_swin_root_resource.start
op_assign
id|PAGE_SIZE
suffix:semicolon
id|pcibr_soft-&gt;bs_swin_root_resource.end
op_assign
l_int|0x000FFFFF
suffix:semicolon
multiline_comment|/* Setup the Bus&squot;s PCI Memory Root Resource */
id|pcibr_soft-&gt;bs_mem_win_root_resource.start
op_assign
l_int|0x200000
suffix:semicolon
id|pcibr_soft-&gt;bs_mem_win_root_resource.end
op_assign
l_int|0xffffffff
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to allocate resource structure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Block off the range used by PROM. */
id|res-&gt;start
op_assign
id|prom_base_addr
suffix:semicolon
id|res-&gt;end
op_assign
id|prom_base_addr
op_plus
(paren
id|prom_base_size
op_minus
l_int|1
)paren
suffix:semicolon
suffix:semicolon
id|status
op_assign
id|request_resource
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_mem_win_root_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to request_resource()&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* build &quot;no-slot&quot; connection point&n;     */
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|PCIIO_SLOT_NONE
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
id|noslot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
multiline_comment|/* Remember the no slot connection point info for tearing it&n;     * down during detach.&n;     */
id|pcibr_soft-&gt;bs_noslot_conn
op_assign
id|noslot_conn
suffix:semicolon
id|pcibr_soft-&gt;bs_noslot_info
op_assign
id|pcibr_info
suffix:semicolon
macro_line|#if PCI_FBBE
id|fast_back_to_back_enable
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#if PCI_FBBE
r_if
c_cond
(paren
id|fast_back_to_back_enable
)paren
(brace
multiline_comment|/*&n;&t; * All devices on the bus are capable of fast back to back, so&n;&t; * we need to set the fast back to back bit in all devices on&n;&t; * the bus that are capable of doing such accesses.&n;&t; */
)brace
macro_line|#endif
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Find out what is out there */
(paren
r_void
)paren
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Set up the address space for this slot in the PCI land */
(paren
r_void
)paren
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Setup the device register */
(paren
r_void
)paren
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_assign
id|NUM_RBAR
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_assign
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Setup the PCI-X Read Buffer Attribute Registers (RBARs) */
(paren
r_void
)paren
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up convenience links */
id|pcibr_bus_cnvlink
c_func
(paren
id|pcibr_soft-&gt;bs_vhdl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Setup host/guest relations */
(paren
r_void
)paren
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Handle initial RRB management for Bridge and Xbridge */
id|pcibr_initial_rrb
c_func
(paren
id|pcibr_vhdl
comma
id|pcibr_soft-&gt;bs_first_slot
comma
id|pcibr_soft-&gt;bs_last_slot
)paren
suffix:semicolon
(brace
multiline_comment|/* Before any drivers get called that may want to re-allocate&n;    * RRB&squot;s, let&squot;s get some special cases pre-allocated. Drivers&n;    * may override these pre-allocations, but by doing pre-allocations&n;    * now we&squot;re assured not to step all over what the driver intended.&n;    *&n;    * Note: Someday this should probably be moved over to pcibr_rrb.c&n;    */
multiline_comment|/*&n;     * Each Pbrick PCI bus only has slots 1 and 2.   Similarly for&n;     * widget 0xe on Ibricks.  Allocate RRB&squot;s accordingly.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
)paren
(brace
r_case
id|MODULE_PBRICK
suffix:colon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|2
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_IBRICK
suffix:colon
multiline_comment|/* port 0xe on the Ibrick only has slots 1 and 2 */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xid
op_eq
l_int|0xe
)paren
(brace
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|2
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate one RRB for the serial port */
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MODULE_PXBRICK
suffix:colon
r_case
id|MODULE_IXBRICK
suffix:colon
multiline_comment|/* &n;&t;&t; * If the IO9 is in the PXBrick (bus1, slot1) allocate&n;                 * RRBs to all the devices&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_slot
(braket
l_int|0
)braket
dot
id|bss_vendor_id
op_eq
l_int|0x10A9
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_slot
(braket
l_int|0
)braket
dot
id|bss_device_id
op_eq
l_int|0x100A
)paren
)paren
(brace
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|2
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|3
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
)brace
macro_line|#ifdef LATER
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|nicinfo
comma
id|XTALK_PCI_PART_NUM
)paren
)paren
(brace
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* OK Special RRB allocations are done. */
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Call the device attach */
(paren
r_void
)paren
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
id|pciio_device_attach
c_func
(paren
id|noslot_conn
comma
(paren
r_int
)paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_detach:&n; *&t;Detach the bridge device from the hwgraph after cleaning out all the &n; *&t;underlying vertices.&n; */
r_int
DECL|function|pcibr_detach
id|pcibr_detach
c_func
(paren
id|vertex_hdl_t
id|xconn
)paren
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|s
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DETACH
comma
id|xconn
comma
l_string|&quot;pcibr_detach&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the bridge vertex from its xtalk connection point */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xconn
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
l_int|1
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Disable the interrupts from the bridge */
id|bridge-&gt;p_int_enable_64
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Detach all the PCI devices talking to this bridge */
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
id|pcibr_slot_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
l_int|0
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_int
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Unregister the no-slot connection point */
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
(paren
id|pcibr_soft-&gt;bs_noslot_info-&gt;f_c
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
multiline_comment|/* Disconnect the error interrupt and free the xtalk resources &n;     * associated with it.&n;     */
id|xtalk_intr_disconnect
c_func
(paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
suffix:semicolon
id|xtalk_intr_free
c_func
(paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
suffix:semicolon
multiline_comment|/* Clear the software state maintained by the bridge driver for this&n;     * bridge.&n;     */
id|kfree
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Remove the Bridge revision labelled info */
(paren
r_void
)paren
id|hwgraph_info_remove_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove the character device associated with this bridge */
id|hwgraph_edge_remove
c_func
(paren
id|pcibr_vhdl
comma
id|EDGE_LBL_CONTROLLER
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove the PCI bridge vertex */
id|hwgraph_edge_remove
c_func
(paren
id|xconn
comma
id|EDGE_LBL_PCI
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pcibr_asic_rev
id|pcibr_asic_rev
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|vertex_hdl_t
id|pcibr_vhdl
suffix:semicolon
r_int
id|tmp_vhdl
suffix:semicolon
id|arbitrary_info_t
id|ainfo
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|pconn_vhdl
comma
id|EDGE_LBL_MASTER
comma
op_amp
id|pcibr_vhdl
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tmp_vhdl
op_assign
id|hwgraph_info_get_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
op_amp
id|ainfo
)paren
suffix:semicolon
multiline_comment|/*&n;     * Any hwgraph function that returns a vertex handle will implicity&n;     * increment that vertex&squot;s reference count.  The caller must explicity&n;     * decrement the vertex&squot;s referece count after the last reference to&n;     * that vertex.&n;     *&n;     * Decrement reference count incremented by call to hwgraph_traverse().&n;     *&n;     */
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_vhdl
op_ne
id|GRAPH_SUCCESS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
(paren
r_int
)paren
id|ainfo
suffix:semicolon
)brace
r_int
DECL|function|pcibr_write_gather_flush
id|pcibr_write_gather_flush
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_device_write_gather_flush
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    PIO MANAGEMENT&n; */
r_static
id|iopaddr_t
DECL|function|pcibr_addr_pci_to_xio
id|pcibr_addr_pci_to_xio
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|pciio_slot_t
id|slot
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|bar
suffix:semicolon
multiline_comment|/* which BASE reg on device is decoding */
id|iopaddr_t
id|xio_addr
op_assign
id|XIO_NOWHERE
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
multiline_comment|/* base of devio(x) mapped area on PCI */
id|iopaddr_t
id|limit
suffix:semicolon
multiline_comment|/* base of devio(x) mapped area on PCI */
id|pciio_space_t
id|wspace
suffix:semicolon
multiline_comment|/* which space device is decoding */
id|iopaddr_t
id|wbase
suffix:semicolon
multiline_comment|/* base of device decode on PCI */
r_int
id|wsize
suffix:semicolon
multiline_comment|/* size of device decode on PCI */
r_int
r_try
suffix:semicolon
multiline_comment|/* DevIO(x) window scanning order control */
r_int
id|maxtry
comma
id|halftry
suffix:semicolon
r_int
id|win
suffix:semicolon
multiline_comment|/* which DevIO(x) window is being used */
id|pciio_space_t
id|mspace
suffix:semicolon
multiline_comment|/* target space for devio(x) register */
id|iopaddr_t
id|mbase
suffix:semicolon
multiline_comment|/* base of devio(x) mapped area on PCI */
r_int
id|msize
suffix:semicolon
multiline_comment|/* size of devio(x) mapped area on PCI */
r_int
id|mmask
suffix:semicolon
multiline_comment|/* addr bits stored in Device(x) */
r_int
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slot
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Special case for dual-slot pci devices such as ioc3 on IP27&n;&t; * baseio.  In these cases, pconn_vhdl should never be for a pci&n;&t; * function on a subordiate PCI bus, so we can safely reset pciio_info&n;&t; * to be the info struct embedded in pcibr_info.  Failure to do this&n;&t; * results in using a bogus pciio_info_t for calculations done later&n;&t; * in this routine.&n;&t; */
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_NONE
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_CFG
)paren
(brace
multiline_comment|/*&n;&t; * Usually, the first mapping&n;&t; * established to a PCI device&n;&t; * is to its config space.&n;&t; *&n;&t; * In any case, we definitely&n;&t; * do NOT need to worry about&n;&t; * PCI BASE registers, and&n;&t; * MUST NOT attempt to point&n;&t; * the DevIO(x) window at&n;&t; * this access ...&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
op_le
id|BRIDGE_TYPE0_CFG_FUNC_OFF
)paren
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|PCIBR_TYPE0_CFG_DEV
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_ROM
)paren
(brace
multiline_comment|/* PIO to the Expansion Rom.&n;&t; * Driver is responsible for&n;&t; * enabling and disabling&n;&t; * decodes properly.&n;&t; */
id|wbase
op_assign
id|pciio_info-&gt;c_rbase
suffix:semicolon
id|wsize
op_assign
id|pciio_info-&gt;c_rsize
suffix:semicolon
multiline_comment|/*&n;&t; * While the driver should know better&n;&t; * than to attempt to map more space&n;&t; * than the device is decoding, he might&n;&t; * do it; better to bail out here.&n;&t; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
id|wsize
)paren
r_goto
id|done
suffix:semicolon
id|pci_addr
op_add_assign
id|wbase
suffix:semicolon
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
)brace
multiline_comment|/*&n;     * reduce window mappings to raw&n;     * space mappings (maybe allocating&n;     * windows), and try for DevIO(x)&n;     * usage (setting it if it is available).&n;     */
id|bar
op_assign
id|space
op_minus
id|PCIIO_SPACE_WIN0
suffix:semicolon
r_if
c_cond
(paren
id|bar
OL
l_int|6
)paren
(brace
id|wspace
op_assign
id|pciio_info-&gt;c_window
(braket
id|bar
)braket
dot
id|w_space
suffix:semicolon
r_if
c_cond
(paren
id|wspace
op_eq
id|PCIIO_SPACE_NONE
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* get PCI base and size */
id|wbase
op_assign
id|pciio_info-&gt;c_window
(braket
id|bar
)braket
dot
id|w_base
suffix:semicolon
id|wsize
op_assign
id|pciio_info-&gt;c_window
(braket
id|bar
)braket
dot
id|w_size
suffix:semicolon
multiline_comment|/*&n;&t; * While the driver should know better&n;&t; * than to attempt to map more space&n;&t; * than the device is decoding, he might&n;&t; * do it; better to bail out here.&n;&t; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
id|wsize
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* shift from window relative to&n;&t; * decoded space relative.&n;&t; */
id|pci_addr
op_add_assign
id|wbase
suffix:semicolon
id|space
op_assign
id|wspace
suffix:semicolon
)brace
r_else
id|bar
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Scan all the DevIO(x) windows twice looking for one&n;     * that can satisfy our request. The first time through,&n;     * only look at assigned windows; the second time, also&n;     * look at PCIIO_SPACE_NONE windows. Arrange the order&n;     * so we always look at our own window first.&n;     *&n;     * We will not attempt to satisfy a single request&n;     * by concatinating multiple windows.&n;     */
id|maxtry
op_assign
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
op_star
l_int|2
suffix:semicolon
id|halftry
op_assign
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
r_try
op_assign
l_int|0
suffix:semicolon
r_try
OL
id|maxtry
suffix:semicolon
op_increment
r_try
)paren
(brace
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|offset
suffix:semicolon
multiline_comment|/* calculate win based on slot, attempt, and max possible&n;&t;   devices on bus */
id|win
op_assign
(paren
r_try
op_plus
id|slot
)paren
op_mod
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* If this DevIO(x) mapping area can provide&n;&t; * a mapping to this address, use it.&n;&t; */
id|msize
op_assign
(paren
id|win
OL
l_int|2
)paren
ques
c_cond
l_int|0x200000
suffix:colon
l_int|0x100000
suffix:semicolon
id|mmask
op_assign
op_minus
id|msize
suffix:semicolon
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_IO
)paren
id|mmask
op_and_assign
l_int|0x3FFFFFFF
suffix:semicolon
id|offset
op_assign
id|pci_addr
op_amp
(paren
id|msize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If this window can&squot;t possibly handle that request,&n;&t; * go on to the next window.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|pci_addr
op_amp
(paren
id|msize
op_minus
l_int|1
)paren
)paren
op_plus
id|req_size
)paren
OG
id|msize
)paren
r_continue
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
suffix:semicolon
multiline_comment|/* Is this window &quot;nailed down&quot;?&n;&t; * If not, maybe we can use it.&n;&t; * (only check this the second time through)&n;&t; */
id|mspace
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_space
suffix:semicolon
r_if
c_cond
(paren
(paren
r_try
OG
id|halftry
)paren
op_logical_and
(paren
id|mspace
op_eq
id|PCIIO_SPACE_NONE
)paren
)paren
(brace
multiline_comment|/* If this is the primary DevIO(x) window&n;&t;     * for some other device, skip it.&n;&t;     */
r_if
c_cond
(paren
(paren
id|win
op_ne
id|slot
)paren
op_logical_and
(paren
id|PCIIO_VENDOR_ID_NONE
op_ne
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_vendor_id
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* It&squot;s a free window, and we fit in it.&n;&t;     * Set up Device(win) to our taste.&n;&t;     */
id|mbase
op_assign
id|pci_addr
op_amp
id|mmask
suffix:semicolon
multiline_comment|/* check that we would really get from&n;&t;     * here to there.&n;&t;     */
r_if
c_cond
(paren
(paren
id|mbase
op_or
id|offset
)paren
op_ne
id|pci_addr
)paren
r_continue
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_IO
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_IO_MEM
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_IO_MEM
suffix:semicolon
id|devreg
op_or_assign
(paren
id|mbase
op_rshift
l_int|20
)paren
op_amp
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
multiline_comment|/* default is WORD_VALUES.&n;&t;     * if you specify both,&n;&t;     * operation is undefined.&n;&t;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge-&gt;b_device
(braket
id|win
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
macro_line|#ifdef PCI_LATER
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_addr_pci_to_xio: Device(%d): %x&bslash;n&quot;
comma
id|win
comma
id|devreg
comma
id|device_bits
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_space
op_assign
id|space
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_base
op_assign
id|mbase
suffix:semicolon
id|xio_addr
op_assign
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|pcibr_soft
comma
id|win
)paren
op_plus
(paren
id|pci_addr
op_minus
id|mbase
)paren
suffix:semicolon
multiline_comment|/* Increment this DevIO&squot;s use count */
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_ref_cnt
op_increment
suffix:semicolon
multiline_comment|/* Save the DevIO register index used to access this BAR */
r_if
c_cond
(paren
id|bar
op_ne
op_minus
l_int|1
)paren
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_devio_index
op_assign
id|win
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_addr_pci_to_xio: map to space %s [0x%lx..0x%lx] &quot;
l_string|&quot;for slot %d allocates DevIO(%d) Device(%d) set to %lx&bslash;n&quot;
comma
id|pci_space
(braket
id|space
)braket
comma
id|pci_addr
comma
id|pci_addr
op_plus
id|req_size
op_minus
l_int|1
comma
id|slot
comma
id|win
comma
id|win
comma
id|devreg
)paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* endif DevIO(x) not pointed */
id|mbase
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_base
suffix:semicolon
multiline_comment|/* Now check for request incompat with DevIO(x)&n;&t; */
r_if
c_cond
(paren
(paren
id|mspace
op_ne
id|space
)paren
op_logical_or
(paren
id|pci_addr
OL
id|mbase
)paren
op_logical_or
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
(paren
id|mbase
op_plus
id|msize
)paren
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_logical_and
op_logical_neg
(paren
id|devreg
op_amp
id|BRIDGE_DEV_DEV_SWAP
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_logical_and
(paren
id|devreg
op_amp
id|BRIDGE_DEV_DEV_SWAP
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* DevIO(x) window is pointed at PCI space&n;&t; * that includes our target. Calculate the&n;&t; * final XIO address, release the lock and&n;&t; * return.&n;&t; */
id|xio_addr
op_assign
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|pcibr_soft
comma
id|win
)paren
op_plus
(paren
id|pci_addr
op_minus
id|mbase
)paren
suffix:semicolon
multiline_comment|/* Increment this DevIO&squot;s use count */
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_ref_cnt
op_increment
suffix:semicolon
multiline_comment|/* Save the DevIO register index used to access this BAR */
r_if
c_cond
(paren
id|bar
op_ne
op_minus
l_int|1
)paren
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_devio_index
op_assign
id|win
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_addr_pci_to_xio: map to space %s [0x%lx..0x%lx] &quot;
l_string|&quot;for slot %d uses DevIO(%d)&bslash;n&quot;
comma
id|pci_space
(braket
id|space
)braket
comma
id|pci_addr
comma
id|pci_addr
op_plus
id|req_size
op_minus
l_int|1
comma
id|slot
comma
id|win
)paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|space
)paren
(brace
multiline_comment|/*&n;&t; * Accesses to device decode&n;&t; * areas that do a not fit&n;&t; * within the DevIO(x) space are&n;&t; * modified to be accesses via&n;&t; * the direct mapping areas.&n;&t; *&n;&t; * If necessary, drivers can&n;&t; * explicitly ask for mappings&n;&t; * into these address spaces,&n;&t; * but this should never be needed.&n;&t; */
r_case
id|PCIIO_SPACE_MEM
suffix:colon
multiline_comment|/* &quot;mem space&quot; */
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
multiline_comment|/* &quot;mem, use 32-bit-wide bus&quot; */
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|pcibr_soft
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* PIC bus 0 */
id|base
op_assign
id|PICBRIDGE0_PCI_MEM32_BASE
suffix:semicolon
id|limit
op_assign
id|PICBRIDGE0_PCI_MEM32_LIMIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|pcibr_soft
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* PIC bus 1 */
id|base
op_assign
id|PICBRIDGE1_PCI_MEM32_BASE
suffix:semicolon
id|limit
op_assign
id|PICBRIDGE1_PCI_MEM32_LIMIT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bridge/Xbridge */
id|base
op_assign
id|BRIDGE_PCI_MEM32_BASE
suffix:semicolon
id|limit
op_assign
id|BRIDGE_PCI_MEM32_LIMIT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|base
op_plus
id|req_size
op_minus
l_int|1
)paren
op_le
id|limit
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|base
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM64
suffix:colon
multiline_comment|/* &quot;mem, use 64-bit-wide bus&quot; */
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|pcibr_soft
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* PIC bus 0 */
id|base
op_assign
id|PICBRIDGE0_PCI_MEM64_BASE
suffix:semicolon
id|limit
op_assign
id|PICBRIDGE0_PCI_MEM64_LIMIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|pcibr_soft
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* PIC bus 1 */
id|base
op_assign
id|PICBRIDGE1_PCI_MEM64_BASE
suffix:semicolon
id|limit
op_assign
id|PICBRIDGE1_PCI_MEM64_LIMIT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bridge/Xbridge */
id|base
op_assign
id|BRIDGE_PCI_MEM64_BASE
suffix:semicolon
id|limit
op_assign
id|BRIDGE_PCI_MEM64_LIMIT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|base
op_plus
id|req_size
op_minus
l_int|1
)paren
op_le
id|limit
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|base
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_IO
suffix:colon
multiline_comment|/* &quot;i/o space&quot; */
multiline_comment|/*&n;&t; * PIC bridges do not support big-window aliases into PCI I/O space&n;&t; */
id|xio_addr
op_assign
id|XIO_NOWHERE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check that &quot;Direct PIO&quot; byteswapping matches,&n;     * try to change it if it does not.&n;     */
r_if
c_cond
(paren
id|xio_addr
op_ne
id|XIO_NOWHERE
)paren
(brace
r_int
id|bst
suffix:semicolon
multiline_comment|/* nonzero to set bytestream */
r_int
op_star
id|bfp
suffix:semicolon
multiline_comment|/* addr of record of how swapper is set */
r_int
id|swb
suffix:semicolon
multiline_comment|/* which control bit to mung */
r_int
id|bfo
suffix:semicolon
multiline_comment|/* current swapper setting */
r_int
id|bfn
suffix:semicolon
multiline_comment|/* desired swapper setting */
id|bfp
op_assign
(paren
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
ques
c_cond
(paren
op_amp
id|pcibr_soft-&gt;bs_pio_end_io
)paren
suffix:colon
(paren
op_amp
id|pcibr_soft-&gt;bs_pio_end_mem
)paren
)paren
suffix:semicolon
id|bfo
op_assign
op_star
id|bfp
suffix:semicolon
id|bst
op_assign
id|flags
op_amp
id|PCIIO_BYTE_STREAM
suffix:semicolon
id|bfn
op_assign
id|bst
ques
c_cond
id|PCIIO_BYTE_STREAM
suffix:colon
id|PCIIO_WORD_VALUES
suffix:semicolon
r_if
c_cond
(paren
id|bfn
op_eq
id|bfo
)paren
(brace
multiline_comment|/* we already match. */
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bfo
op_ne
l_int|0
)paren
(brace
multiline_comment|/* we have a conflict. */
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_addr_pci_to_xio: swap conflict in %s, &quot;
l_string|&quot;was%s%s, want%s%s&bslash;n&quot;
comma
id|pci_space
(braket
id|space
)braket
comma
id|bfo
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfo
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_NOWHERE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* OK to make the change. */
id|picreg_t
id|octl
comma
id|nctl
suffix:semicolon
id|swb
op_assign
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
ques
c_cond
id|BRIDGE_CTRL_IO_SWAP
suffix:colon
id|BRIDGE_CTRL_MEM_SWAP
suffix:semicolon
id|octl
op_assign
id|bridge-&gt;p_wid_control_64
suffix:semicolon
id|nctl
op_assign
id|bst
ques
c_cond
id|octl
op_or
(paren
r_uint64
)paren
id|swb
suffix:colon
id|octl
op_amp
(paren
(paren
r_uint64
)paren
op_complement
id|swb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|octl
op_ne
id|nctl
)paren
multiline_comment|/* make the change if any */
id|bridge-&gt;b_wid_control
op_assign
id|nctl
suffix:semicolon
op_star
id|bfp
op_assign
id|bfn
suffix:semicolon
multiline_comment|/* record the assignment */
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_addr_pci_to_xio: swap for %s set to%s%s&bslash;n&quot;
comma
id|pci_space
(braket
id|space
)braket
comma
id|bfn
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|xio_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED6 */
id|pcibr_piomap_t
DECL|function|pcibr_piomap_alloc
id|pcibr_piomap_alloc
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|req_size_max
comma
r_int
id|flags
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pcibr_piomap_t
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap_t
id|maplist
suffix:semicolon
id|pcibr_piomap_t
id|pcibr_piomap
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|xtalk_piomap_t
id|xtalk_piomap
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* Make sure that the req sizes are non-zero */
r_if
c_cond
(paren
(paren
id|req_size
OL
l_int|1
)paren
op_logical_or
(paren
id|req_size_max
OL
l_int|1
)paren
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piomap_alloc: req_size | req_size_max &lt; 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Code to translate slot/space/addr&n;     * into xio_addr is common between&n;     * this routine and pcibr_piotrans_addr.&n;     */
id|xio_addr
op_assign
id|pcibr_addr_pci_to_xio
c_func
(paren
id|pconn_vhdl
comma
id|pciio_slot
comma
id|space
comma
id|pci_addr
comma
id|req_size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piomap_alloc: xio_addr == XIO_NOWHERE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check the piomap list to see if there is already an allocated&n;     * piomap entry but not in use. If so use that one. Otherwise&n;     * allocate a new piomap entry and add it to the piomap list&n;     */
id|mapptr
op_assign
op_amp
(paren
id|pcibr_info-&gt;f_piomap
)paren
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_piomap
op_assign
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap
op_ne
l_int|NULL
suffix:semicolon
id|pcibr_piomap
op_assign
id|pcibr_piomap-&gt;bp_next
)paren
(brace
r_if
c_cond
(paren
id|pcibr_piomap-&gt;bp_mapsz
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_piomap
)paren
id|mapptr
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|pcibr_piomap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_piomap
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_piomap
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piomap_alloc: malloc fails&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcibr_piomap
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pcibr_piomap
)paren
)paren
)paren
suffix:semicolon
)brace
id|pcibr_piomap-&gt;bp_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_piomap-&gt;bp_slot
op_assign
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
)paren
suffix:semicolon
id|pcibr_piomap-&gt;bp_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_piomap-&gt;bp_space
op_assign
id|space
suffix:semicolon
id|pcibr_piomap-&gt;bp_pciaddr
op_assign
id|pci_addr
suffix:semicolon
id|pcibr_piomap-&gt;bp_mapsz
op_assign
id|req_size
suffix:semicolon
id|pcibr_piomap-&gt;bp_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_piomap-&gt;bp_toc
(braket
l_int|0
)braket
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapptr
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|maplist
op_assign
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap-&gt;bp_next
op_assign
id|maplist
suffix:semicolon
op_star
id|mapptr
op_assign
id|pcibr_piomap
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_piomap
)paren
(brace
id|xtalk_piomap
op_assign
id|xtalk_piomap_alloc
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|xio_addr
comma
id|req_size
comma
id|req_size_max
comma
id|flags
op_amp
id|PIOMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_piomap
)paren
(brace
id|pcibr_piomap-&gt;bp_xtalk_addr
op_assign
id|xio_addr
suffix:semicolon
id|pcibr_piomap-&gt;bp_xtalk_pio
op_assign
id|xtalk_piomap
suffix:semicolon
)brace
r_else
(brace
id|pcibr_piomap-&gt;bp_mapsz
op_assign
l_int|0
suffix:semicolon
id|pcibr_piomap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piomap_alloc: map=0x%lx&bslash;n&quot;
comma
id|pcibr_piomap
)paren
)paren
suffix:semicolon
r_return
id|pcibr_piomap
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piomap_free
id|pcibr_piomap_free
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
)paren
(brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pcibr_piomap-&gt;bp_dev
comma
l_string|&quot;pcibr_piomap_free: map=0x%lx&bslash;n&quot;
comma
id|pcibr_piomap
)paren
)paren
suffix:semicolon
id|xtalk_piomap_free
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
)paren
suffix:semicolon
id|pcibr_piomap-&gt;bp_xtalk_pio
op_assign
l_int|0
suffix:semicolon
id|pcibr_piomap-&gt;bp_mapsz
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|caddr_t
DECL|function|pcibr_piomap_addr
id|pcibr_piomap_addr
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
)paren
(brace
id|caddr_t
id|addr
suffix:semicolon
id|addr
op_assign
id|xtalk_piomap_addr
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
comma
id|pcibr_piomap-&gt;bp_xtalk_addr
op_plus
id|pci_addr
op_minus
id|pcibr_piomap-&gt;bp_pciaddr
comma
id|req_size
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pcibr_piomap-&gt;bp_dev
comma
l_string|&quot;pcibr_piomap_addr: map=0x%lx, addr=0x%lx&bslash;n&quot;
comma
id|pcibr_piomap
comma
id|addr
)paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piomap_done
id|pcibr_piomap_done
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
)paren
(brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pcibr_piomap-&gt;bp_dev
comma
l_string|&quot;pcibr_piomap_done: map=0x%lx&bslash;n&quot;
comma
id|pcibr_piomap
)paren
)paren
suffix:semicolon
id|xtalk_piomap_done
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|caddr_t
DECL|function|pcibr_piotrans_addr
id|pcibr_piotrans_addr
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|caddr_t
id|addr
suffix:semicolon
id|xio_addr
op_assign
id|pcibr_addr_pci_to_xio
c_func
(paren
id|pconn_vhdl
comma
id|pciio_slot
comma
id|space
comma
id|pci_addr
comma
id|req_size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIODIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piotrans_addr: xio_addr == XIO_NOWHERE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|addr
op_assign
id|xtalk_piotrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|xio_addr
comma
id|req_size
comma
id|flags
op_amp
id|PIOMAP_FLAGS
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIODIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piotrans_addr: xio_addr=0x%lx, addr=0x%lx&bslash;n&quot;
comma
id|xio_addr
comma
id|addr
)paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * PIO Space allocation and management.&n; *      Allocate and Manage the PCI PIO space (mem and io space)&n; *      This routine is pretty simplistic at this time, and&n; *      does pretty trivial management of allocation and freeing.&n; *      The current scheme is prone for fragmentation.&n; *      Change the scheme to use bitmaps.&n; */
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_piospace_alloc
id|pcibr_piospace_alloc
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
r_int
id|req_size
comma
r_int
id|alignment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_piospace_t
id|piosp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|iopaddr_t
id|start_addr
suffix:semicolon
r_int
id|align_mask
suffix:semicolon
multiline_comment|/*&n;     * Check for proper alignment&n;     */
id|ASSERT
c_func
(paren
id|alignment
op_ge
id|PAGE_SIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|alignment
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|align_mask
op_assign
id|alignment
op_minus
l_int|1
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/*&n;     * First look if a previously allocated chunk exists.&n;     */
id|piosp
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
r_if
c_cond
(paren
id|piosp
)paren
(brace
multiline_comment|/*&n;&t; * Look through the list for a right sized free chunk.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|piosp-&gt;free
op_logical_and
(paren
id|piosp-&gt;space
op_eq
id|space
)paren
op_logical_and
(paren
id|piosp-&gt;count
op_ge
id|req_size
)paren
op_logical_and
op_logical_neg
(paren
id|piosp-&gt;start
op_amp
id|align_mask
)paren
)paren
(brace
id|piosp-&gt;free
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|piosp-&gt;start
suffix:semicolon
)brace
id|piosp
op_assign
id|piosp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|piosp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|piosp
)paren
suffix:semicolon
multiline_comment|/*&n;     * Allocate PCI bus address, usually for the Universe chip driver;&n;     * do not pass window info since the actual PCI bus address&n;     * space will never be freed.  The space may be reused after it&n;     * is logically released by pcibr_piospace_free().&n;     */
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|start_addr
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
l_int|NULL
comma
id|PCIIO_SPACE_IO
comma
l_int|0
comma
id|req_size
comma
id|alignment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
id|start_addr
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
l_int|NULL
comma
id|PCIIO_SPACE_MEM32
comma
l_int|0
comma
id|req_size
comma
id|alignment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piospace_alloc: unknown space %d&bslash;n&quot;
comma
id|space
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * If too big a request, reject it.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|start_addr
)paren
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piospace_alloc: request 0x%lx to big&bslash;n&quot;
comma
id|req_size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|piosp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|piosp
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|piosp
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piospace_alloc: malloc fails&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|piosp
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|piosp
)paren
)paren
)paren
suffix:semicolon
id|piosp-&gt;free
op_assign
l_int|0
suffix:semicolon
id|piosp-&gt;space
op_assign
id|space
suffix:semicolon
id|piosp-&gt;start
op_assign
id|start_addr
suffix:semicolon
id|piosp-&gt;count
op_assign
id|req_size
suffix:semicolon
id|piosp-&gt;next
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
id|pcibr_info-&gt;f_piospace
op_assign
id|piosp
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piospace_alloc: piosp=0x%lx&bslash;n&quot;
comma
id|piosp
)paren
)paren
suffix:semicolon
r_return
id|start_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piospace_free
id|pcibr_piospace_free
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pciaddr
comma
r_int
id|req_size
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_piospace_t
id|piosp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_char
id|name
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n;     * Look through the bridge data structures for the pciio_piospace_t&n;     * structure corresponding to  &squot;pciaddr&squot;&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|piosp
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
r_while
c_loop
(paren
id|piosp
)paren
(brace
multiline_comment|/*&n;&t; * Piospace free can only be for the complete&n;&t; * chunk and not parts of it..&n;&t; */
r_if
c_cond
(paren
id|piosp-&gt;start
op_eq
id|pciaddr
)paren
(brace
r_if
c_cond
(paren
id|piosp-&gt;count
op_eq
id|req_size
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;     * Improper size passed for freeing..&n;&t;     * Print a message and break;&n;&t;     */
id|hwgraph_vertex_name_get
c_func
(paren
id|pconn_vhdl
comma
id|name
comma
l_int|1024
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pcibr_piospace_free: error&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Device %s freeing size (0x%lx) different than allocated (0x%lx)&quot;
comma
id|name
comma
id|req_size
comma
id|piosp-&gt;count
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Freeing 0x%lx instead&quot;
comma
id|piosp-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|piosp
op_assign
id|piosp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|piosp
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pcibr_piospace_free: Address 0x%lx size 0x%lx - No match&bslash;n&quot;
comma
id|pciaddr
comma
id|req_size
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|piosp-&gt;free
op_assign
l_int|1
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_PIOMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_piospace_free: piosp=0x%lx&bslash;n&quot;
comma
id|piosp
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    DMA MANAGEMENT&n; *&n; *      The Bridge ASIC provides three methods of doing&n; *      DMA: via a &quot;direct map&quot; register available in&n; *      32-bit PCI space (which selects a contiguous 2G&n; *      address space on some other widget), via&n; *      &quot;direct&quot; addressing via 64-bit PCI space (all&n; *      destination information comes from the PCI&n; *      address, including transfer attributes), and via&n; *      a &quot;mapped&quot; region that allows a bunch of&n; *      different small mappings to be established with&n; *      the PMU.&n; *&n; *      For efficiency, we most prefer to use the 32-bit&n; *      direct mapping facility, since it requires no&n; *      resource allocations. The advantage of using the&n; *      PMU over the 64-bit direct is that single-cycle&n; *      PCI addressing can be used; the advantage of&n; *      using 64-bit direct over PMU addressing is that&n; *      we do not have to allocate entries in the PMU.&n; */
multiline_comment|/*&n; * Convert PCI-generic software flags and Bridge-specific software flags&n; * into Bridge-specific Direct Map attribute bits.&n; */
r_static
id|iopaddr_t
DECL|function|pcibr_flags_to_d64
id|pcibr_flags_to_d64
c_func
(paren
r_int
id|flags
comma
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|iopaddr_t
id|attributes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sanity check: Bridge only allows use of VCHAN1 via 64-bit addrs */
macro_line|#ifdef LATER
id|ASSERT_ALWAYS
c_func
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
op_logical_or
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Generic macro flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_DATA
)paren
(brace
multiline_comment|/* standard data channel */
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_BAR
suffix:semicolon
multiline_comment|/* no barrier bit */
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_CMD
)paren
(brace
multiline_comment|/* standard command channel */
id|attributes
op_or_assign
id|PCI64_ATTR_BAR
suffix:semicolon
multiline_comment|/* barrier bit on */
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* disable prefetch */
)brace
multiline_comment|/* Generic detail flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_PREFETCH
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* the swap bit is in the address attributes for xbridge */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_SWAP
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_SWAP
suffix:semicolon
multiline_comment|/* Provider-specific flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_VIRTUAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN0
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_VIRTUAL
suffix:semicolon
multiline_comment|/* PIC in PCI-X mode only supports barrier &amp; swap */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|attributes
op_and_assign
(paren
id|PCI64_ATTR_BAR
op_or
id|PCI64_ATTR_SWAP
)paren
suffix:semicolon
)brace
r_return
(paren
id|attributes
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|pcibr_dmamap_t
DECL|function|pcibr_dmamap_alloc
id|pcibr_dmamap_alloc
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
r_int
id|req_size_max
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|xtalk_dmamap_t
id|xtalk_dmamap
suffix:semicolon
id|pcibr_dmamap_t
id|pcibr_dmamap
suffix:semicolon
r_int
id|ate_count
suffix:semicolon
r_int
id|ate_index
suffix:semicolon
r_int
id|vchan
op_assign
id|VCHAN0
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* merge in forced flags */
id|flags
op_or_assign
id|pcibr_soft-&gt;bs_dma_flags
suffix:semicolon
multiline_comment|/*&n;     * On SNIA64, these maps are pre-allocated because pcibr_dmamap_alloc()&n;     * can be called within an interrupt thread.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_dmamap
op_assign
(paren
id|pcibr_dmamap_t
)paren
id|get_free_pciio_dmamap
c_func
(paren
id|pcibr_soft-&gt;bs_vhdl
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_dmamap
)paren
r_return
l_int|0
suffix:semicolon
id|xtalk_dmamap
op_assign
id|xtalk_dmamap_alloc
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|req_size_max
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xtalk_dmamap
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: xtalk_dmamap_alloc failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xio_port
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_dmamap-&gt;bd_slot
op_assign
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xtalk
op_assign
id|xtalk_dmamap
suffix:semicolon
id|pcibr_dmamap-&gt;bd_max_size
op_assign
id|req_size_max
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_port
op_assign
id|xio_port
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_D64_BITS
)paren
)paren
(brace
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
multiline_comment|/* Device is capable of A64 operations,&n;&t;     * and the attributes of the DMA are&n;&t;     * consistent with any previous DMA&n;&t;     * mappings using shared resources.&n;&t;     */
id|pci_addr
op_assign
id|pcibr_flags_to_d64
c_func
(paren
id|flags
comma
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
l_int|0
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|pci_addr
suffix:semicolon
multiline_comment|/* If in PCI mode, make sure we have an RRB (or two). &n;&t;     */
r_if
c_cond
(paren
id|IS_PCI
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|vchan
op_assign
id|VCHAN1
suffix:semicolon
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|pci_addr
op_amp
id|PCI64_ATTR_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|vchan
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: using direct64, map=0x%lx&bslash;n&quot;
comma
id|pcibr_dmamap
)paren
)paren
suffix:semicolon
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: unable to use direct64&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* PIC in PCI-X mode only supports 64-bit direct mapping so&n;&t; * don&squot;t fall thru and try 32-bit direct mapping or 32-bit&n;&t; * page mapping&n;&t; */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|flags
op_and_assign
op_complement
id|PCIIO_DMA_A64
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_FIXED
)paren
(brace
multiline_comment|/* warning: mappings may fail later,&n;&t; * if direct32 can&squot;t get to the address.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_D32_BITS
)paren
)paren
(brace
multiline_comment|/* User desires DIRECT A32 operations,&n;&t;     * and the attributes of the DMA are&n;&t;     * consistent with any previous DMA&n;&t;     * mappings using shared resources.&n;&t;     * Mapping calls may fail if target&n;&t;     * is outside the direct32 range.&n;&t;     */
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: using direct32, map=0x%lx&bslash;n&quot;
comma
id|pcibr_dmamap
)paren
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
id|pcibr_soft-&gt;bs_dir_xbase
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|PCI32_DIRECT_BASE
suffix:semicolon
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: unable to use direct32&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* If the user demands FIXED and we can&squot;t&n;&t; * give it to him, fail.&n;&t; */
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap
)paren
suffix:semicolon
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate Address Translation Entries from the mapping RAM.&n;     * Unless the PCIBR_NO_ATE_ROUNDUP flag is specified,&n;     * the maximum number of ATEs is based on the worst-case&n;     * scenario, where the requested target is in the&n;     * last byte of an ATE; thus, mapping IOPGSIZE+2&n;     * does end up requiring three ATEs.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_NO_ATE_ROUNDUP
)paren
)paren
(brace
id|ate_count
op_assign
id|IOPG
c_func
(paren
(paren
id|IOPGSIZE
op_minus
l_int|1
)paren
multiline_comment|/* worst case start offset */
op_plus
id|req_size_max
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
r_else
(brace
multiline_comment|/* assume requested target is page aligned */
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|req_size_max
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
id|ate_index
op_assign
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft
comma
id|ate_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate_index
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_PMU_BITS
)paren
)paren
(brace
id|bridge_ate_t
id|ate_proto
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: using PMU, ate_index=%d, &quot;
l_string|&quot;pcibr_dmamap=0x%lx&bslash;n&quot;
comma
id|ate_index
comma
id|pcibr_dmamap
)paren
)paren
suffix:semicolon
id|ate_proto
op_assign
id|pcibr_flags_to_ate
c_func
(paren
id|flags
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|PCI32_MAPPED_BASE
op_plus
id|IOPGSIZE
op_star
id|ate_index
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|ATE_SWAP_ON
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * If swap was set in bss_device in pcibr_endian_set()&n;&t;     * we need to change the address bit.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_SWAP_PMU
)paren
id|ATE_SWAP_ON
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
id|ATE_SWAP_OFF
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
l_int|0
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_ptr
op_assign
id|pcibr_ate_addr
c_func
(paren
id|pcibr_soft
comma
id|ate_index
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_index
op_assign
id|ate_index
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_count
op_assign
id|ate_count
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_proto
op_assign
id|ate_proto
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
)paren
(brace
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ate_proto
op_amp
id|ATE_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|vchan
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: PMU use failed, ate_index=%d&bslash;n&quot;
comma
id|ate_index
)paren
)paren
suffix:semicolon
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft
comma
id|ate_index
comma
id|ate_count
)paren
suffix:semicolon
)brace
multiline_comment|/* total failure: sorry, you just can&squot;t&n;     * get from here to there that way.&n;     */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmamap_alloc: complete failure.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap
)paren
suffix:semicolon
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_dmamap_free
id|pcibr_dmamap_free
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|PCIBR_SLOT_TO_DEVICE
c_func
(paren
id|pcibr_soft
comma
id|pcibr_dmamap-&gt;bd_slot
)paren
suffix:semicolon
r_int
id|flags
op_assign
id|pcibr_dmamap-&gt;bd_flags
suffix:semicolon
multiline_comment|/* Make sure that bss_ext_ates_active&n;     * is properly kept up to date.&n;     */
r_if
c_cond
(paren
id|PCIBR_DMAMAP_BUSY
op_amp
id|flags
)paren
r_if
c_cond
(paren
id|PCIBR_DMAMAP_SSRAM
op_amp
id|flags
)paren
id|atomic_dec
c_func
(paren
op_amp
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
)paren
)paren
suffix:semicolon
id|xtalk_dmamap_free
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
id|pcibr_release_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|BRIDGE_DEV_D64_BITS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_ate_count
)paren
(brace
id|pcibr_ate_free
c_func
(paren
id|pcibr_dmamap-&gt;bd_soft
comma
id|pcibr_dmamap-&gt;bd_ate_index
comma
id|pcibr_dmamap-&gt;bd_ate_count
)paren
suffix:semicolon
id|pcibr_release_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|BRIDGE_DEV_PMU_BITS
)paren
suffix:semicolon
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_free: pcibr_dmamap=0x%lx&bslash;n&quot;
comma
id|pcibr_dmamap
)paren
)paren
suffix:semicolon
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_addr_xio_to_pci: given a PIO range, hand&n; *      back the corresponding base PCI MEM address;&n; *      this is used to short-circuit DMA requests that&n; *      loop back onto this PCI bus.&n; */
r_static
id|iopaddr_t
DECL|function|pcibr_addr_xio_to_pci
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft_t
id|soft
comma
id|iopaddr_t
id|xio_addr
comma
r_int
id|req_size
)paren
(brace
id|iopaddr_t
id|xio_lim
op_assign
id|xio_addr
op_plus
id|req_size
op_minus
l_int|1
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|soft
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|PICBRIDGE0_PCI_MEM32_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|PICBRIDGE0_PCI_MEM32_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|PICBRIDGE0_PCI_MEM32_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|PICBRIDGE0_PCI_MEM64_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|PICBRIDGE0_PCI_MEM64_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|PICBRIDGE0_PCI_MEM64_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_PIC_BUSNUM_SOFT
c_func
(paren
id|soft
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|PICBRIDGE1_PCI_MEM32_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|PICBRIDGE1_PCI_MEM32_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|PICBRIDGE1_PCI_MEM32_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|PICBRIDGE1_PCI_MEM64_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|PICBRIDGE1_PCI_MEM64_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|PICBRIDGE1_PCI_MEM64_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;pcibr_addr_xio_to_pci(): unknown bridge type&quot;
)paren
suffix:semicolon
r_return
(paren
id|iopaddr_t
)paren
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|soft
comma
id|slot
)paren
)paren
op_logical_and
(paren
id|xio_lim
OL
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|soft
comma
id|slot
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|bridgereg_t
id|dev
suffix:semicolon
id|dev
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
suffix:semicolon
id|pci_addr
op_assign
id|dev
op_amp
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
id|pci_addr
op_lshift_assign
id|BRIDGE_DEV_OFF_ADDR_SHFT
suffix:semicolon
id|pci_addr
op_add_assign
id|xio_addr
op_minus
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|soft
comma
id|slot
)paren
suffix:semicolon
r_return
(paren
id|dev
op_amp
id|BRIDGE_DEV_DEV_IO_MEM
)paren
ques
c_cond
id|pci_addr
suffix:colon
id|PCI_NOWHERE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_dmamap_addr
id|pcibr_dmamap_addr
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
id|paddr_t
id|paddr
comma
r_int
id|req_size
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|pcibr_dmamap
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|req_size
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|req_size
op_le
id|pcibr_dmamap-&gt;bd_max_size
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
id|flags
op_assign
id|pcibr_dmamap-&gt;bd_flags
suffix:semicolon
id|xio_addr
op_assign
id|xtalk_dmamap_addr
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
comma
id|paddr
comma
id|req_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_dmamap-&gt;bd_xio_port
suffix:semicolon
multiline_comment|/* If this DMA is to an address that&n;     * refers back to this Bridge chip,&n;     * reduce it back to the correct&n;     * PCI MEM address.&n;     */
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|pci_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|req_size
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
multiline_comment|/* A64 DMA:&n;&t; * always use 64-bit direct mapping,&n;&t; * which always works.&n;&t; * Device(x) was set up during&n;&t; * dmamap allocation.&n;&t; */
multiline_comment|/* attributes are already bundled up into bd_pci_addr.&n;&t; */
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
op_or
id|xio_addr
suffix:semicolon
multiline_comment|/* Bridge Hardware WAR #482836:&n;&t; * If the transfer is not cache aligned&n;&t; * and the Bridge Rev is &lt;= B, force&n;&t; * prefetch to be off.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|pci_addr
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_addr: (direct64): wanted paddr [0x%lx..0x%lx] &quot;
l_string|&quot;XIO port 0x%x offset 0x%lx, returning PCI 0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
comma
id|xio_addr
comma
id|pci_addr
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_FIXED
)paren
(brace
multiline_comment|/* A32 direct DMA:&n;&t; * always use 32-bit direct mapping,&n;&t; * which may fail.&n;&t; * Device(x) was set up during&n;&t; * dmamap allocation.&n;&t; */
r_if
c_cond
(paren
id|xio_port
op_ne
id|pcibr_soft-&gt;bs_dir_xport
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wrong DIDN */
r_else
r_if
c_cond
(paren
id|xio_addr
OL
id|pcibr_dmamap-&gt;bd_xio_addr
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* out of range */
r_else
r_if
c_cond
(paren
(paren
id|xio_addr
op_plus
id|req_size
)paren
OG
(paren
id|pcibr_dmamap-&gt;bd_xio_addr
op_plus
id|BRIDGE_DMA_DIRECT_SIZE
)paren
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* out of range */
r_else
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_plus
id|xio_addr
op_minus
id|pcibr_dmamap-&gt;bd_xio_addr
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
op_or
id|PCIBR_DEBUG_DMADIR
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_addr (direct32): wanted paddr [0x%lx..0x%lx] &quot;
l_string|&quot;XIO port 0x%x offset 0x%lx, returning PCI 0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
comma
id|xio_addr
comma
id|pci_addr
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|iopaddr_t
id|offset
op_assign
id|IOPGOFF
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|bridge_ate_t
id|ate_proto
op_assign
id|pcibr_dmamap-&gt;bd_ate_proto
suffix:semicolon
r_int
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|offset
op_plus
id|req_size
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|ate_index
op_assign
id|pcibr_dmamap-&gt;bd_ate_index
suffix:semicolon
r_int
id|cmd_regs
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if PCIBR_FREEZE_TIME
r_int
id|ate_total
op_assign
id|ate_count
suffix:semicolon
r_int
id|freeze_time
suffix:semicolon
macro_line|#endif
id|bridge_ate_p
id|ate_ptr
op_assign
id|pcibr_dmamap-&gt;bd_ate_ptr
suffix:semicolon
id|bridge_ate_t
id|ate
suffix:semicolon
multiline_comment|/* Bridge Hardware WAR #482836:&n;&t; * If the transfer is not cache aligned&n;&t; * and the Bridge Rev is &lt;= B, force&n;&t; * prefetch to be off.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|ate_proto
op_and_assign
op_complement
id|ATE_PREF
suffix:semicolon
id|ate
op_assign
id|ate_proto
op_or
(paren
id|xio_port
op_lshift
id|ATE_TIDSHIFT
)paren
op_or
(paren
id|xio_addr
op_minus
id|offset
)paren
suffix:semicolon
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_plus
id|offset
suffix:semicolon
multiline_comment|/* Fill in our mapping registers&n;&t; * with the appropriate xtalk data,&n;&t; * and hand back the PCI address.&n;&t; */
id|ASSERT
c_func
(paren
id|ate_count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate_count
op_le
id|pcibr_dmamap-&gt;bd_ate_count
)paren
(brace
id|ATE_FREEZE
c_func
(paren
)paren
suffix:semicolon
id|ATE_WRITE
c_func
(paren
)paren
suffix:semicolon
id|ATE_THAW
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_addr (PMU) : wanted paddr &quot;
l_string|&quot;[0x%lx..0x%lx] returning PCI 0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|pci_addr
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The number of ATE&squot;s required is greater than the number&n;&t;&t; * allocated for this map. One way this can happen is if&n;&t;&t; * pcibr_dmamap_alloc() was called with the PCIBR_NO_ATE_ROUNDUP&n;&t;&t; * flag, and then when that map is used (right now), the&n;&t;&t; * target address tells us we really did need to roundup.&n;&t;&t; * The other possibility is that the map is just plain too&n;&t;&t; * small to handle the requested target area.&n;&t;&t; */
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_addr (PMU) : wanted paddr &quot;
l_string|&quot;[0x%lx..0x%lx] ate_count 0x%x bd_ate_count 0x%x &quot;
l_string|&quot;ATE&squot;s required &gt; number allocated&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|ate_count
comma
id|pcibr_dmamap-&gt;bd_ate_count
)paren
)paren
suffix:semicolon
id|pci_addr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|pci_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_dmamap_done
id|pcibr_dmamap_done
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
multiline_comment|/*&n;     * We could go through and invalidate ATEs here;&n;     * for performance reasons, we don&squot;t.&n;     * We also don&squot;t enforce the strict alternation&n;     * between _addr/_list and _done, but Hub does.&n;     */
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_BUSY
)paren
(brace
id|pcibr_dmamap-&gt;bd_flags
op_and_assign
op_complement
id|PCIBR_DMAMAP_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_SSRAM
)paren
id|atomic_dec
c_func
(paren
op_amp
(paren
id|pcibr_dmamap-&gt;bd_soft-&gt;bs_slot
(braket
id|pcibr_dmamap-&gt;bd_slot
)braket
dot
id|bss_ext_ates_active
)paren
)paren
suffix:semicolon
)brace
id|xtalk_dmamap_done
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMAMAP
comma
id|pcibr_dmamap-&gt;bd_dev
comma
l_string|&quot;pcibr_dmamap_done: pcibr_dmamap=0x%lx&bslash;n&quot;
comma
id|pcibr_dmamap
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For each bridge, the DIR_OFF value in the Direct Mapping Register&n; * determines the PCI to Crosstalk memory mapping to be used for all&n; * 32-bit Direct Mapping memory accesses. This mapping can be to any&n; * node in the system. This function will return that compact node id.&n; */
multiline_comment|/*ARGSUSED */
id|cnodeid_t
DECL|function|pcibr_get_dmatrans_node
id|pcibr_get_dmatrans_node
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_return
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|NASID_GET
c_func
(paren
id|pcibr_soft-&gt;bs_dir_xbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_dmatrans_addr
id|pcibr_dmatrans_addr
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|paddr_t
id|paddr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
r_int
id|vchan
op_assign
id|VCHAN0
suffix:semicolon
multiline_comment|/* merge in forced flags */
id|flags
op_or_assign
id|pcibr_soft-&gt;bs_dma_flags
suffix:semicolon
id|xio_addr
op_assign
id|xtalk_dmatrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|paddr
comma
id|req_size
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xio_addr
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr: wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xtalk_dmatrans_addr failed with 0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * find which XIO port this goes to.&n;     */
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr: wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xtalk_dmatrans_addr failed with XIO_NOWHERE&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
multiline_comment|/*&n;     * If this DMA comes back to us,&n;     * return the PCI MEM address on&n;     * which it would land, or NULL&n;     * if the target is something&n;     * on bridge other than PCI MEM.&n;     */
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|pci_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|req_size
)paren
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, pci_addr=0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
comma
id|pci_addr
)paren
)paren
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
multiline_comment|/* If the caller can use A64, try to&n;     * satisfy the request with the 64-bit&n;     * direct map. This can fail if the&n;     * configuration bits in Device(x)&n;     * conflict with our flags.&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
id|pci_addr
op_assign
id|slotp-&gt;bss_d64_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
)paren
id|flags
op_or_assign
id|PCIBR_VCHAN0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_addr
op_ne
id|PCIBR_D64_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d64_flags
)paren
)paren
(brace
id|pci_addr
op_or_assign
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
macro_line|#if HWG_PERF_CHECK
r_if
c_cond
(paren
id|xio_addr
op_ne
l_int|0x20000000
)paren
macro_line|#endif
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%x..0x%x], &quot;
l_string|&quot;xio_port=0x%x, direct64: pci_addr=0x%x&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
)paren
)paren
suffix:semicolon
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D64_BITS
)paren
)paren
(brace
id|pci_addr
op_assign
id|pcibr_flags_to_d64
c_func
(paren
id|flags
comma
id|pcibr_soft
)paren
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d64_base
op_assign
id|pci_addr
suffix:semicolon
id|pci_addr
op_or_assign
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
multiline_comment|/* If in PCI mode, make sure we have an RRB (or two).&n;&t;     */
r_if
c_cond
(paren
id|IS_PCI
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|pciio_slot
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|vchan
op_assign
id|VCHAN1
suffix:semicolon
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|pci_addr
op_amp
id|PCI64_ATTR_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|vchan
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, direct64: pci_addr=0x%lx, &quot;
l_string|&quot;new flags: 0x%x&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
comma
(paren
r_uint64
)paren
id|flags
)paren
)paren
suffix:semicolon
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, Unable to set direct64 Device(x) bits&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* PIC only supports 64-bit direct mapping in PCI-X mode */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* our flags conflict with Device(x). try direct32*/
id|flags
op_assign
id|flags
op_amp
op_complement
(paren
id|PCIIO_DMA_A64
op_or
id|PCIBR_VCHAN0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* BUS in PCI-X mode only supports 64-bit direct mapping */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Try to satisfy the request with the 32-bit direct&n;     * map. This can fail if the configuration bits in&n;     * Device(x) conflict with our flags, or if the&n;     * target address is outside where DIR_OFF points.&n;     */
(brace
r_int
id|map_size
op_assign
l_int|1ULL
op_lshift
l_int|31
suffix:semicolon
id|iopaddr_t
id|xio_base
op_assign
id|pcibr_soft-&gt;bs_dir_xbase
suffix:semicolon
id|iopaddr_t
id|offset
op_assign
id|xio_addr
op_minus
id|xio_base
suffix:semicolon
id|iopaddr_t
id|endoff
op_assign
id|req_size
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req_size
OG
id|map_size
)paren
op_logical_or
(paren
id|xio_addr
OL
id|xio_base
)paren
op_logical_or
(paren
id|xio_port
op_ne
id|pcibr_soft-&gt;bs_dir_xport
)paren
op_logical_or
(paren
id|endoff
OG
id|map_size
)paren
)paren
(brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, xio region outside direct32 target&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_addr
op_assign
id|slotp-&gt;bss_d32_base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_addr
op_ne
id|PCIBR_D32_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d32_flags
)paren
)paren
(brace
id|pci_addr
op_or_assign
id|offset
suffix:semicolon
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx],&quot;
l_string|&quot; xio_port=0x%x, direct32: pci_addr=0x%lx&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
)paren
)paren
suffix:semicolon
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D32_BITS
)paren
)paren
(brace
id|pci_addr
op_assign
id|PCI32_DIRECT_BASE
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|pci_addr
suffix:semicolon
id|pci_addr
op_or_assign
id|offset
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|pciio_slot
)paren
)paren
)paren
(brace
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|slotp-&gt;bss_device
op_amp
id|BRIDGE_DEV_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|vchan
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx],&quot;
l_string|&quot; xio_port=0x%x, direct32: pci_addr=0x%lx, &quot;
l_string|&quot;new flags: 0x%x&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
comma
(paren
r_uint64
)paren
id|flags
)paren
)paren
suffix:semicolon
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* our flags conflict with Device(x).&n;&t;     */
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, Unable to set direct32 Device(x) bits&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
)paren
)paren
suffix:semicolon
)brace
)brace
id|PCIBR_DEBUG
c_func
(paren
(paren
id|PCIBR_DEBUG_DMADIR
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_dmatrans_addr:  wanted paddr [0x%lx..0x%lx], &quot;
l_string|&quot;xio_port=0x%x, No acceptable PCI address found&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmamap_drain
id|pcibr_dmamap_drain
c_func
(paren
id|pcibr_dmamap_t
id|map
)paren
(brace
id|xtalk_dmamap_drain
c_func
(paren
id|map-&gt;bd_xtalk
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmaaddr_drain
id|pcibr_dmaaddr_drain
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|paddr_t
id|paddr
comma
r_int
id|bytes
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|xtalk_dmaaddr_drain
c_func
(paren
id|xconn_vhdl
comma
id|paddr
comma
id|bytes
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmalist_drain
id|pcibr_dmalist_drain
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|alenlist_t
id|list
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|xtalk_dmalist_drain
c_func
(paren
id|xconn_vhdl
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the starting PCIbus address out of the given DMA map.&n; * This function is supposed to be used by a close friend of PCI bridge&n; * since it relies on the fact that the starting address of the map is fixed at&n; * the allocation time in the current implementation of PCI bridge.&n; */
id|iopaddr_t
DECL|function|pcibr_dmamap_pciaddr_get
id|pcibr_dmamap_pciaddr_get
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
r_return
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    CONFIGURATION MANAGEMENT&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_provider_startup
id|pcibr_provider_startup
c_func
(paren
id|vertex_hdl_t
id|pcibr
)paren
(brace
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_provider_shutdown
id|pcibr_provider_shutdown
c_func
(paren
id|vertex_hdl_t
id|pcibr
)paren
(brace
)brace
r_int
DECL|function|pcibr_reset
id|pcibr_reset
c_func
(paren
id|vertex_hdl_t
id|conn
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pciio_endian_t
DECL|function|pcibr_endian_set
id|pcibr_endian_set
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;     * Bridge supports hardware swapping; so we can always&n;     * arrange for the caller&squot;s desired endianness.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
r_if
c_cond
(paren
id|device_end
op_ne
id|desired_end
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
multiline_comment|/* NOTE- if we ever put SWAP bits&n;     * onto the disabled list, we will&n;     * have to change the logic here.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pcibr_endian_set: Device(%d): %x&bslash;n&quot;
comma
id|pciio_slot
comma
id|devreg
)paren
suffix:semicolon
r_return
id|desired_end
suffix:semicolon
)brace
multiline_comment|/* This (re)sets the GBR and REALTIME bits and also keeps track of how&n; * many sets are outstanding. Reset succeeds only if the number of outstanding&n; * sets == 1.&n; */
r_int
DECL|function|pcibr_priority_bits_set
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|pciio_slot
comma
id|pciio_priority_t
id|device_prio
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
r_int
op_star
id|counter
suffix:semicolon
id|bridgereg_t
id|rtbits
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|rc
op_assign
id|PRIO_SUCCESS
suffix:semicolon
multiline_comment|/* in dual-slot configurations, the host and the&n;     * guest have separate DMA resources, so they&n;     * have separate requirements for priority bits.&n;     */
id|counter
op_assign
op_amp
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_pri_uctr
)paren
suffix:semicolon
multiline_comment|/*&n;     * Bridge supports PCI notions of LOW and HIGH priority&n;     * arbitration rings via a &quot;REAL_TIME&quot; bit in the per-device&n;     * Bridge register. The &quot;GBR&quot; bit controls access to the GBR&n;     * ring on the xbow. These two bits are (re)set together.&n;     *&n;     * XXX- Bug in Rev B Bridge Si:&n;     * Symptom: Prefetcher starts operating incorrectly. This happens&n;     * due to corruption of the address storage ram in the prefetcher&n;     * when a non-real time PCI request is pulled and a real-time one is&n;     * put in it&squot;s place. Workaround: Use only a single arbitration ring&n;     * on PCI bus. GBR and RR can still be uniquely used per&n;     * device. NETLIST MERGE DONE, WILL BE FIXED IN REV C.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_ne
id|BRIDGE_PART_REV_B
)paren
id|rtbits
op_or_assign
id|BRIDGE_DEV_RT
suffix:semicolon
multiline_comment|/* NOTE- if we ever put DEV_RT or DEV_GBR on&n;     * the disabled list, we will have to take&n;     * it into account here.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
r_if
c_cond
(paren
id|device_prio
op_eq
id|PCI_PRIO_HIGH
)paren
(brace
r_if
c_cond
(paren
(paren
op_increment
op_star
id|counter
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|rtbits
)paren
id|devreg
op_or_assign
id|rtbits
suffix:semicolon
r_else
id|rc
op_assign
id|PRIO_FAIL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|device_prio
op_eq
id|PCI_PRIO_LOW
)paren
(brace
r_if
c_cond
(paren
op_star
id|counter
op_le
l_int|0
)paren
id|rc
op_assign
id|PRIO_FAIL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_decrement
op_star
id|counter
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|rtbits
)paren
id|devreg
op_and_assign
op_complement
id|rtbits
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|pciio_priority_t
DECL|function|pcibr_priority_set
id|pcibr_priority_set
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|pciio_priority_t
id|device_prio
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
(paren
r_void
)paren
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|device_prio
)paren
suffix:semicolon
r_return
id|device_prio
suffix:semicolon
)brace
multiline_comment|/*&n; * Interfaces to allow special (e.g. SGI) drivers to set/clear&n; * Bridge-specific device flags.  Many flags are modified through&n; * PCI-generic interfaces; we don&squot;t allow them to be directly&n; * manipulated here.  Only flags that at this point seem pretty&n; * Bridge-specific can be set through these special interfaces.&n; * We may add more flags as the need arises, or remove flags and&n; * create PCI-generic interfaces as the need arises.&n; *&n; * Returns 0 on failure, 1 on success&n; */
r_int
DECL|function|pcibr_device_flags_set
id|pcibr_device_flags_set
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
id|pcibr_device_flags_t
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridgereg_t
id|set
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|clr
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|PCIBR_DEVICE_FLAGS
)paren
op_eq
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PMU_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PMU_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_DIR_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_DIR_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_64BIT
)paren
id|set
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NO64BIT
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|set
op_logical_or
id|clr
)paren
(brace
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
id|devreg
op_assign
(paren
id|devreg
op_amp
op_complement
id|clr
)paren
op_or
id|set
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pconn_vhdl
comma
l_string|&quot;pcibr_device_flags_set: Device(%d): 0x%x&bslash;n&quot;
comma
id|pciio_slot
comma
id|devreg
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PIC has 16 RBARs per bus; meaning it can have a total of 16 outstanding &n; * split transactions.  If the functions on the bus have requested a total &n; * of 16 or less, then we can give them what they requested (ie. 100%). &n; * Otherwise we have make sure each function can get at least one buffer&n; * and then divide the rest of the buffers up among the functions as ``A &n; * PERCENTAGE OF WHAT THEY REQUESTED&squot;&squot; (i.e. 0% - 100% of a function&squot;s&n; * pcix_type0_status.max_out_split).  This percentage does not include the&n; * one RBAR that all functions get by default.&n; */
r_int
DECL|function|pcibr_pcix_rbars_calc
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
multiline_comment|/* &squot;percent_allowed&squot; is the percentage of requested RBARs that functions&n;     * are allowed, ***less the 1 RBAR that all functions get by default***&n;     */
r_int
id|percent_allowed
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_pcix_num_funcs
)paren
(brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_pcix_num_funcs
OG
id|NUM_RBAR
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lx: Must oversubscribe Read Buffer Attribute Registers&quot;
l_string|&quot;(RBAR).  Bus has %d RBARs but %d funcs need them.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pcibr_soft-&gt;bs_vhdl
comma
id|NUM_RBAR
comma
id|pcibr_soft-&gt;bs_pcix_num_funcs
)paren
suffix:semicolon
id|percent_allowed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|percent_allowed
op_assign
(paren
(paren
(paren
id|NUM_RBAR
op_minus
id|pcibr_soft-&gt;bs_pcix_num_funcs
)paren
op_star
l_int|100
)paren
op_div
id|pcibr_soft-&gt;bs_pcix_split_tot
)paren
suffix:semicolon
multiline_comment|/* +1 to percentage to solve rounding errors that occur because&n;&t;     * we&squot;re not doing fractional math. (ie. ((3 * 66%) / 100) = 1)&n;&t;     * but should be &quot;2&quot; if doing true fractional math.  NOTE: Since&n;&t;     * the greatest number of outstanding transactions a function &n;&t;     * can request is 32, this &quot;+1&quot; will always work (i.e. we won&squot;t&n;&t;     * accidentally oversubscribe the RBARs because of this rounding&n;&t;     * of the percentage).&n;&t;     */
id|percent_allowed
op_assign
(paren
id|percent_allowed
OG
l_int|100
)paren
ques
c_cond
l_int|100
suffix:colon
id|percent_allowed
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|ENODEV
suffix:semicolon
)brace
r_return
id|percent_allowed
suffix:semicolon
)brace
DECL|variable|pcibr_provider
id|pciio_provider_t
id|pcibr_provider
op_assign
(brace
(paren
id|pciio_piomap_alloc_f
op_star
)paren
id|pcibr_piomap_alloc
comma
(paren
id|pciio_piomap_free_f
op_star
)paren
id|pcibr_piomap_free
comma
(paren
id|pciio_piomap_addr_f
op_star
)paren
id|pcibr_piomap_addr
comma
(paren
id|pciio_piomap_done_f
op_star
)paren
id|pcibr_piomap_done
comma
(paren
id|pciio_piotrans_addr_f
op_star
)paren
id|pcibr_piotrans_addr
comma
(paren
id|pciio_piospace_alloc_f
op_star
)paren
id|pcibr_piospace_alloc
comma
(paren
id|pciio_piospace_free_f
op_star
)paren
id|pcibr_piospace_free
comma
(paren
id|pciio_dmamap_alloc_f
op_star
)paren
id|pcibr_dmamap_alloc
comma
(paren
id|pciio_dmamap_free_f
op_star
)paren
id|pcibr_dmamap_free
comma
(paren
id|pciio_dmamap_addr_f
op_star
)paren
id|pcibr_dmamap_addr
comma
(paren
id|pciio_dmamap_done_f
op_star
)paren
id|pcibr_dmamap_done
comma
(paren
id|pciio_dmatrans_addr_f
op_star
)paren
id|pcibr_dmatrans_addr
comma
(paren
id|pciio_dmamap_drain_f
op_star
)paren
id|pcibr_dmamap_drain
comma
(paren
id|pciio_dmaaddr_drain_f
op_star
)paren
id|pcibr_dmaaddr_drain
comma
(paren
id|pciio_dmalist_drain_f
op_star
)paren
id|pcibr_dmalist_drain
comma
(paren
id|pciio_intr_alloc_f
op_star
)paren
id|pcibr_intr_alloc
comma
(paren
id|pciio_intr_free_f
op_star
)paren
id|pcibr_intr_free
comma
(paren
id|pciio_intr_connect_f
op_star
)paren
id|pcibr_intr_connect
comma
(paren
id|pciio_intr_disconnect_f
op_star
)paren
id|pcibr_intr_disconnect
comma
(paren
id|pciio_intr_cpu_get_f
op_star
)paren
id|pcibr_intr_cpu_get
comma
(paren
id|pciio_provider_startup_f
op_star
)paren
id|pcibr_provider_startup
comma
(paren
id|pciio_provider_shutdown_f
op_star
)paren
id|pcibr_provider_shutdown
comma
(paren
id|pciio_reset_f
op_star
)paren
id|pcibr_reset
comma
(paren
id|pciio_write_gather_flush_f
op_star
)paren
id|pcibr_write_gather_flush
comma
(paren
id|pciio_endian_set_f
op_star
)paren
id|pcibr_endian_set
comma
(paren
id|pciio_priority_set_f
op_star
)paren
id|pcibr_priority_set
comma
(paren
id|pciio_config_get_f
op_star
)paren
id|pcibr_config_get
comma
(paren
id|pciio_config_set_f
op_star
)paren
id|pcibr_config_set
comma
(paren
id|pciio_error_devenable_f
op_star
)paren
l_int|0
comma
(paren
id|pciio_error_extract_f
op_star
)paren
l_int|0
comma
(paren
id|pciio_driver_reg_callback_f
op_star
)paren
l_int|0
comma
(paren
id|pciio_driver_unreg_callback_f
op_star
)paren
l_int|0
comma
(paren
id|pciio_device_unregister_f
op_star
)paren
id|pcibr_device_unregister
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * pcibr_debug() is used to print pcibr debug messages to the console.  A&n; * user enables tracing by setting the following global variables:&n; *&n; *    pcibr_debug_mask &t;   -Bitmask of what to trace. see pcibr_private.h&n; *    pcibr_debug_module   -Module to trace.  &squot;all&squot; means trace all modules&n; *    pcibr_debug_widget   -Widget to trace. &squot;-1&squot; means trace all widgets&n; *    pcibr_debug_slot&t;   -Slot to trace.  &squot;-1&squot; means trace all slots&n; *&n; * &squot;type&squot; is the type of debugging that the current PCIBR_DEBUG macro is&n; * tracing.  &squot;vhdl&squot; (which can be NULL) is the vhdl associated with the&n; * debug statement.  If there is a &squot;vhdl&squot; associated with this debug&n; * statement, it is parsed to obtain the module, widget, and slot.  If the&n; * globals above match the PCIBR_DEBUG params, then the debug info in the&n; * parameter &squot;format&squot; is sent to the console.&n; */
r_void
DECL|function|pcibr_debug
id|pcibr_debug
c_func
(paren
r_uint32
id|type
comma
id|vertex_hdl_t
id|vhdl
comma
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
r_char
id|hwpath
(braket
id|MAXDEVNAME
)braket
op_assign
l_string|&quot;&bslash;0&quot;
suffix:semicolon
r_char
id|copy_of_hwpath
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_char
op_star
id|module
op_assign
l_string|&quot;all&quot;
suffix:semicolon
r_int
id|widget
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|slot
op_assign
op_minus
l_int|1
suffix:semicolon
id|va_list
id|ap
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_debug_mask
op_amp
id|type
)paren
(brace
r_if
c_cond
(paren
id|vhdl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hwgraph_vertex_name_get
c_func
(paren
id|vhdl
comma
id|hwpath
comma
id|MAXDEVNAME
)paren
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|module
comma
id|pcibr_debug_module
)paren
)paren
(brace
multiline_comment|/* use a copy */
(paren
r_void
)paren
id|strcpy
c_func
(paren
id|copy_of_hwpath
comma
id|hwpath
)paren
suffix:semicolon
id|cp
op_assign
id|strstr
c_func
(paren
id|copy_of_hwpath
comma
l_string|&quot;/&quot;
id|EDGE_LBL_MODULE
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;/&quot;
id|EDGE_LBL_MODULE
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|module
op_assign
id|strsep
c_func
(paren
op_amp
id|cp
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibr_debug_widget
op_ne
op_minus
l_int|1
)paren
(brace
id|cp
op_assign
id|strstr
c_func
(paren
id|hwpath
comma
l_string|&quot;/&quot;
id|EDGE_LBL_XTALK
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;/&quot;
id|EDGE_LBL_XTALK
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|widget
op_assign
id|simple_strtoul
c_func
(paren
id|cp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibr_debug_slot
op_ne
op_minus
l_int|1
)paren
(brace
id|cp
op_assign
id|strstr
c_func
(paren
id|hwpath
comma
l_string|&quot;/&quot;
id|EDGE_LBL_PCIX_0
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|cp
op_assign
id|strstr
c_func
(paren
id|hwpath
comma
l_string|&quot;/&quot;
id|EDGE_LBL_PCIX_1
l_string|&quot;/&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;/&quot;
id|EDGE_LBL_PCIX_0
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|slot
op_assign
id|simple_strtoul
c_func
(paren
id|cp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|vhdl
op_eq
l_int|NULL
)paren
op_logical_or
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|module
comma
id|pcibr_debug_module
)paren
op_logical_and
(paren
id|widget
op_eq
id|pcibr_debug_widget
)paren
op_logical_and
(paren
id|slot
op_eq
id|pcibr_debug_slot
)paren
)paren
)paren
(brace
macro_line|#ifdef LATER
id|printk
c_func
(paren
l_string|&quot;PCIBR_DEBUG&lt;%d&gt;&bslash;t: %s :&quot;
comma
id|cpuid
c_func
(paren
)paren
comma
id|hwpath
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;PCIBR_DEBUG&bslash;t: %s :&quot;
comma
id|hwpath
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;     * Kernel printk translates to this 3 line sequence.&n;&t;     * Since we have a variable length argument list, we&n;&t;     * need to call printk this way rather than directly&n;&t;     */
(brace
r_char
id|buffer
(braket
l_int|500
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|format
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|buffer
comma
l_int|500
comma
id|format
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|buffer
(braket
l_int|499
)braket
op_assign
(paren
r_char
)paren
l_int|0
suffix:semicolon
multiline_comment|/* just to be safe */
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|buffer
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_int
DECL|function|isIO9
id|isIO9
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|lboard_t
op_star
id|brd
op_assign
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_while
c_loop
(paren
id|brd
)paren
(brace
r_if
c_cond
(paren
id|brd-&gt;brd_flags
op_amp
id|LOCAL_MASTER_IO6
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|brd
op_assign
id|KLCF_NEXT
c_func
(paren
id|brd
)paren
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s dual ported, check the peer also */
id|nasid
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|xbow_peer
suffix:semicolon
r_if
c_cond
(paren
id|nasid
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|brd
op_assign
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_while
c_loop
(paren
id|brd
)paren
(brace
r_if
c_cond
(paren
id|brd-&gt;brd_flags
op_amp
id|LOCAL_MASTER_IO6
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|brd
op_assign
id|KLCF_NEXT
c_func
(paren
id|brd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
