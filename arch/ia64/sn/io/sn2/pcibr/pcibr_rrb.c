multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_void
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_rrb_free_all
c_func
(paren
id|pcibr_soft_t
comma
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_void
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|pcibr_wrb_flush
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|pcibr_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pcibr_rrb_check
c_func
(paren
id|vertex_hdl_t
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_void
id|pcibr_rrb_flush
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_void
id|pcibr_rrb_debug
c_func
(paren
r_char
op_star
comma
id|pcibr_soft_t
)paren
suffix:semicolon
multiline_comment|/*&n; * RRB Management&n; *&n; * All the do_pcibr_rrb_ routines manipulate the Read Response Buffer (rrb)&n; * registers within the Bridge.&t; Two 32 registers (b_rrb_map[2] also known&n; * as the b_even_resp &amp; b_odd_resp registers) are used to allocate the 16&n; * rrbs to devices.  The b_even_resp register represents even num devices,&n; * and b_odd_resp represent odd number devices.&t; Each rrb is represented by&n; * 4-bits within a register.&n; *   BRIDGE &amp; XBRIDGE:&t;1 enable bit, 1 virtual channel bit, 2 device bits&n; *   PIC:&t;&t;1 enable bit, 2 virtual channel bits, 1 device bit&n; * PIC has 4 devices per bus, and 4 virtual channels (1 normal &amp; 3 virtual)&n; * per device.&t;BRIDGE &amp; XBRIDGE have 8 devices per bus and 2 virtual&n; * channels (1 normal &amp; 1 virtual) per device.&t;See the BRIDGE and PIC ASIC&n; * Programmers Reference guides for more information.&n; */
DECL|macro|RRB_MASK
mdefine_line|#define RRB_MASK (0xf)&t;&t;&t;/* mask a single rrb within reg */
DECL|macro|RRB_SIZE
mdefine_line|#define RRB_SIZE (4)&t;&t;&t;/* sizeof rrb within reg (bits) */
DECL|macro|RRB_ENABLE_BIT
mdefine_line|#define RRB_ENABLE_BIT(bridge)&t;&t;(0x8)  /* [BRIDGE | PIC]_RRB_EN */
DECL|macro|NUM_PDEV_BITS
mdefine_line|#define NUM_PDEV_BITS(bridge)&t;&t;(1)
DECL|macro|NUM_VDEV_BITS
mdefine_line|#define NUM_VDEV_BITS(bridge)&t;&t;(2)
DECL|macro|NUMBER_VCHANNELS
mdefine_line|#define NUMBER_VCHANNELS(bridge)&t;(4)
DECL|macro|SLOT_2_PDEV
mdefine_line|#define SLOT_2_PDEV(bridge, slot)&t;((slot) &gt;&gt; 1)
DECL|macro|SLOT_2_RRB_REG
mdefine_line|#define SLOT_2_RRB_REG(bridge, slot)&t;((slot) &amp; 0x1)
multiline_comment|/* validate that the slot and virtual channel are valid for a given bridge */
DECL|macro|VALIDATE_SLOT_n_VCHAN
mdefine_line|#define VALIDATE_SLOT_n_VCHAN(bridge, s, v) &bslash;&n;    (((((s) != PCIIO_SLOT_NONE) &amp;&amp; ((s) &lt;= (pciio_slot_t)3)) &amp;&amp; (((v) &gt;= 0) &amp;&amp; ((v) &lt;= 3))) ? 1 : 0)
multiline_comment|/*  &n; * Count how many RRBs are marked valid for the specified PCI slot&n; * and virtual channel.&t; Return the count.&n; */
r_int
DECL|function|do_pcibr_rrb_count_valid
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|vchan
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
r_uint16
id|enable_bit
comma
id|vchan_bits
comma
id|pdev_bits
comma
id|rrb_bits
suffix:semicolon
r_int
id|rrb_index
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VALIDATE_SLOT_n_VCHAN
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;do_pcibr_rrb_count_valid() invalid slot/vchan [%d/%d]&bslash;n&quot;
comma
id|slot
comma
id|vchan
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|enable_bit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|vchan_bits
op_assign
id|vchan
op_lshift
id|NUM_PDEV_BITS
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|pdev_bits
op_assign
id|SLOT_2_PDEV
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|rrb_bits
op_assign
id|enable_bit
op_or
id|vchan_bits
op_or
id|pdev_bits
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
id|rrb_index
OL
l_int|8
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|RRB_MASK
)paren
op_eq
id|rrb_bits
)paren
id|cnt
op_increment
suffix:semicolon
id|tmp
op_assign
(paren
id|tmp
op_rshift
id|RRB_SIZE
)paren
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/*  &n; * Count how many RRBs are available to be allocated to the specified&n; * slot.  Return the count.&n; */
r_int
DECL|function|do_pcibr_rrb_count_avail
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
r_uint16
id|enable_bit
suffix:semicolon
r_int
id|rrb_index
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VALIDATE_SLOT_n_VCHAN
c_func
(paren
id|bridge
comma
id|slot
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;do_pcibr_rrb_count_avail() invalid slot/vchan&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|enable_bit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
id|rrb_index
OL
l_int|8
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|enable_bit
)paren
op_ne
id|enable_bit
)paren
id|cnt
op_increment
suffix:semicolon
id|tmp
op_assign
(paren
id|tmp
op_rshift
id|RRB_SIZE
)paren
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/*  &n; * Allocate some additional RRBs for the specified slot and the specified&n; * virtual channel.  Returns -1 if there were insufficient free RRBs to&n; * satisfy the request, or 0 if the request was fulfilled.&n; *&n; * Note that if a request can be partially filled, it will be, even if&n; * we return failure.&n; */
r_int
DECL|function|do_pcibr_rrb_alloc
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|vchan
comma
r_int
id|more
)paren
(brace
id|bridgereg_t
id|reg
comma
id|tmp
op_assign
(paren
id|bridgereg_t
)paren
l_int|0
suffix:semicolon
r_uint16
id|enable_bit
comma
id|vchan_bits
comma
id|pdev_bits
comma
id|rrb_bits
suffix:semicolon
r_int
id|rrb_index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VALIDATE_SLOT_n_VCHAN
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;do_pcibr_rrb_alloc() invalid slot/vchan&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|enable_bit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|vchan_bits
op_assign
id|vchan
op_lshift
id|NUM_PDEV_BITS
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|pdev_bits
op_assign
id|SLOT_2_PDEV
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|rrb_bits
op_assign
id|enable_bit
op_or
id|vchan_bits
op_or
id|pdev_bits
suffix:semicolon
id|reg
op_assign
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|rrb_index
OL
l_int|8
)paren
op_logical_and
(paren
id|more
OG
l_int|0
)paren
)paren
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|enable_bit
)paren
op_ne
id|enable_bit
)paren
(brace
multiline_comment|/* clear the rrb and OR in the new rrb into &squot;reg&squot; */
id|reg
op_assign
id|reg
op_amp
op_complement
(paren
id|RRB_MASK
op_lshift
(paren
id|RRB_SIZE
op_star
id|rrb_index
)paren
)paren
suffix:semicolon
id|reg
op_assign
id|reg
op_or
(paren
id|rrb_bits
op_lshift
(paren
id|RRB_SIZE
op_star
id|rrb_index
)paren
)paren
suffix:semicolon
id|more
op_decrement
suffix:semicolon
)brace
id|tmp
op_assign
(paren
id|tmp
op_rshift
id|RRB_SIZE
)paren
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
r_return
(paren
id|more
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*  &n; * Release some of the RRBs that have been allocated for the specified&n; * slot. Returns zero for success, or negative if it was unable to free&n; * that many RRBs.&n; *&n; * Note that if a request can be partially fulfilled, it will be, even&n; * if we return failure.&n; */
r_int
DECL|function|do_pcibr_rrb_free
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|vchan
comma
r_int
id|less
)paren
(brace
id|bridgereg_t
id|reg
comma
id|tmp
op_assign
(paren
id|bridgereg_t
)paren
l_int|0
comma
id|clr
op_assign
l_int|0
suffix:semicolon
r_uint16
id|enable_bit
comma
id|vchan_bits
comma
id|pdev_bits
comma
id|rrb_bits
suffix:semicolon
r_int
id|rrb_index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VALIDATE_SLOT_n_VCHAN
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;do_pcibr_rrb_free() invalid slot/vchan&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|enable_bit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|vchan_bits
op_assign
id|vchan
op_lshift
id|NUM_PDEV_BITS
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|pdev_bits
op_assign
id|SLOT_2_PDEV
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|rrb_bits
op_assign
id|enable_bit
op_or
id|vchan_bits
op_or
id|pdev_bits
suffix:semicolon
id|reg
op_assign
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|rrb_index
OL
l_int|8
)paren
op_logical_and
(paren
id|less
OG
l_int|0
)paren
)paren
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|RRB_MASK
)paren
op_eq
id|rrb_bits
)paren
(brace
multiline_comment|/*&n;&t;    * the old do_pcibr_rrb_free() code only clears the enable bit&n;&t;    * but I say we should clear the whole rrb (ie):&n;&t;    *&t;  reg = reg &amp; ~(RRB_MASK &lt;&lt; (RRB_SIZE * rrb_index));&n;&t;    * But to be compatible with old code we&squot;ll only clear enable.&n;&t;    */
id|reg
op_assign
id|reg
op_amp
op_complement
(paren
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
op_lshift
(paren
id|RRB_SIZE
op_star
id|rrb_index
)paren
)paren
suffix:semicolon
id|clr
op_assign
id|clr
op_or
(paren
id|enable_bit
op_lshift
(paren
id|RRB_SIZE
op_star
id|rrb_index
)paren
)paren
suffix:semicolon
id|less
op_decrement
suffix:semicolon
)brace
id|tmp
op_assign
(paren
id|tmp
op_rshift
id|RRB_SIZE
)paren
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
multiline_comment|/* call do_pcibr_rrb_clear() for all the rrbs we&squot;ve freed */
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
id|rrb_index
OL
l_int|8
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_int
id|evn_odd
op_assign
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clr
op_amp
(paren
id|enable_bit
op_lshift
(paren
id|RRB_SIZE
op_star
id|rrb_index
)paren
)paren
)paren
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
(paren
l_int|2
op_star
id|rrb_index
)paren
op_plus
id|evn_odd
)paren
suffix:semicolon
)brace
r_return
(paren
id|less
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*  &n; * free all the rrbs (both the normal and virtual channels) for the&n; * specified slot.&n; */
r_void
DECL|function|do_pcibr_rrb_free_all
id|do_pcibr_rrb_free_all
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
r_int
id|vchan
suffix:semicolon
r_int
id|vchan_total
op_assign
id|NUMBER_VCHANNELS
c_func
(paren
id|bridge
)paren
suffix:semicolon
multiline_comment|/* pretend we own all 8 rrbs and just ignore the return value */
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
(brace
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
comma
l_int|8
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wait for the the specified rrb to have no outstanding XIO pkts&n; * and for all data to be drained.  Mark the rrb as no longer being &n; * valid.&n; */
r_void
DECL|function|do_pcibr_rrb_clear
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrb
)paren
(brace
id|bridgereg_t
id|status
suffix:semicolon
multiline_comment|/* bridge_lock must be held;&n;     * this RRB must be disabled.&n;     */
multiline_comment|/* wait until RRB has no outstanduing XIO packets. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_INUSE
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
multiline_comment|/* if the RRB has data, drain it. */
r_if
c_cond
(paren
id|status
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
id|bridge-&gt;b_resp_clear
op_assign
id|BRIDGE_RRB_CLEAR
c_func
(paren
id|rrb
)paren
suffix:semicolon
multiline_comment|/* wait until RRB is no longer valid. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
)brace
)brace
multiline_comment|/* &n; * Flush the specified rrb by calling do_pcibr_rrb_clear().  This&n; * routine is just a wrapper to make sure the rrb is disabled &n; * before calling do_pcibr_rrb_clear().&n; */
r_void
DECL|function|do_pcibr_rrb_flush
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrbn
)paren
(brace
id|reg_p
id|rrbp
op_assign
op_amp
id|bridge-&gt;b_rrb_map
(braket
id|rrbn
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|bridgereg_t
id|rrbv
suffix:semicolon
r_int
id|shft
op_assign
(paren
id|RRB_SIZE
op_star
(paren
id|rrbn
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
r_int
r_int
id|ebit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
op_lshift
id|shft
suffix:semicolon
id|rrbv
op_assign
op_star
id|rrbp
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
(brace
op_star
id|rrbp
op_assign
id|rrbv
op_amp
op_complement
id|ebit
suffix:semicolon
)brace
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
id|rrbn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
(brace
op_star
id|rrbp
op_assign
id|rrbv
suffix:semicolon
)brace
)brace
r_void
DECL|function|do_pcibr_rrb_autoalloc
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|slot
comma
r_int
id|vchan
comma
r_int
id|more_rrbs
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|got
suffix:semicolon
r_for
c_loop
(paren
id|got
op_assign
l_int|0
suffix:semicolon
id|got
OL
id|more_rrbs
suffix:semicolon
op_increment
id|got
)paren
(brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_decrement
suffix:semicolon
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
comma
l_int|1
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
op_increment
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;do_pcibr_rrb_autoalloc: added %d (of %d requested) RRBs &quot;
l_string|&quot;to slot %d, vchan %d&bslash;n&quot;
comma
id|got
comma
id|more_rrbs
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|vchan
)paren
)paren
suffix:semicolon
id|pcibr_rrb_debug
c_func
(paren
l_string|&quot;do_pcibr_rrb_autoalloc&quot;
comma
id|pcibr_soft
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all the rrb&squot;s assigned to the specified connection point.&n; */
r_void
DECL|function|pcibr_rrb_flush
id|pcibr_rrb_flush
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|tmp
suffix:semicolon
r_uint16
id|enable_bit
comma
id|pdev_bits
comma
id|rrb_bits
comma
id|rrb_mask
suffix:semicolon
r_int
id|rrb_index
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|enable_bit
op_assign
id|RRB_ENABLE_BIT
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|pdev_bits
op_assign
id|SLOT_2_PDEV
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|rrb_bits
op_assign
id|enable_bit
op_or
id|pdev_bits
suffix:semicolon
id|rrb_mask
op_assign
id|enable_bit
op_or
(paren
(paren
id|NUM_PDEV_BITS
c_func
(paren
id|bridge
)paren
op_lshift
l_int|1
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
)braket
dot
id|reg
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rrb_index
op_assign
l_int|0
suffix:semicolon
id|rrb_index
OL
l_int|8
suffix:semicolon
id|rrb_index
op_increment
)paren
(brace
r_int
id|evn_odd
op_assign
id|SLOT_2_RRB_REG
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|rrb_mask
)paren
op_eq
id|rrb_bits
)paren
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge
comma
(paren
l_int|2
op_star
id|rrb_index
)paren
op_plus
id|evn_odd
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|tmp
op_rshift
id|RRB_SIZE
)paren
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to flush the write buffers for a specified&n; * device hanging off the bridge.&n; */
r_int
DECL|function|pcibr_wrb_flush
id|pcibr_wrb_flush
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_volatile
id|bridgereg_t
op_star
id|wrb_flush
suffix:semicolon
id|wrb_flush
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_while
c_loop
(paren
op_star
id|wrb_flush
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|io_get_sh_swapper
c_func
(paren
id|NASID_GET
c_func
(paren
id|bridge
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|BRIDGE_REG_GET32
c_func
(paren
(paren
id|wrb_flush
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_star
id|wrb_flush
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to request RRBs for a specified device&n; * hanging off a Bridge.  The driver requests the total number of&n; * RRBs it would like for the normal channel (vchan0) and for the&n; * &quot;virtual channel&quot; (vchan1).  The actual number allocated to each&n; * channel is returned.&n; *&n; * If we cannot allocate at least one RRB to a channel that needs&n; * at least one, return -1 (failure).  Otherwise, satisfy the request&n; * as best we can and return 0.&n; */
r_int
DECL|function|pcibr_rrb_alloc
id|pcibr_rrb_alloc
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|desired_vchan0
suffix:semicolon
r_int
id|desired_vchan1
suffix:semicolon
r_int
id|orig_vchan0
suffix:semicolon
r_int
id|orig_vchan1
suffix:semicolon
r_int
id|delta_vchan0
suffix:semicolon
r_int
id|delta_vchan1
suffix:semicolon
r_int
id|final_vchan0
suffix:semicolon
r_int
id|final_vchan1
suffix:semicolon
r_int
id|avail_rrbs
suffix:semicolon
r_int
id|res_rrbs
suffix:semicolon
r_int
id|vchan_total
suffix:semicolon
r_int
id|vchan
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;     * TBD: temper request with admin info about RRB allocation,&n;     * and according to demand from other devices on this Bridge.&n;     *&n;     * One way of doing this would be to allocate two RRBs&n;     * for each device on the bus, before any drivers start&n;     * asking for extras. This has the weakness that one&n;     * driver might not give back an &quot;extra&quot; RRB until after&n;     * another driver has already failed to get one that&n;     * it wanted.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|vchan_total
op_assign
id|NUMBER_VCHANNELS
c_func
(paren
id|bridge
)paren
suffix:semicolon
multiline_comment|/* Save the boot-time RRB configuration for this slot */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
(braket
id|VCHAN0
)braket
OL
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res_dflt
(braket
id|pciio_slot
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
)brace
multiline_comment|/* How many RRBs do we own? */
id|orig_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN0
)braket
suffix:semicolon
id|orig_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN1
)braket
suffix:semicolon
multiline_comment|/* How many RRBs do we want? */
id|desired_vchan0
op_assign
id|count_vchan0
ques
c_cond
op_star
id|count_vchan0
suffix:colon
id|orig_vchan0
suffix:semicolon
id|desired_vchan1
op_assign
id|count_vchan1
ques
c_cond
op_star
id|count_vchan1
suffix:colon
id|orig_vchan1
suffix:semicolon
multiline_comment|/* How many RRBs are free? */
id|avail_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
multiline_comment|/* Figure desired deltas */
id|delta_vchan0
op_assign
id|desired_vchan0
op_minus
id|orig_vchan0
suffix:semicolon
id|delta_vchan1
op_assign
id|desired_vchan1
op_minus
id|orig_vchan1
suffix:semicolon
multiline_comment|/* Trim back deltas to something&n;     * that we can actually meet, by&n;     * decreasing the ending allocation&n;     * for whichever channel wants&n;     * more RRBs. If both want the same&n;     * number, cut the second channel.&n;     * NOTE: do not change the allocation for&n;     * a channel that was passed as NULL.&n;     */
r_while
c_loop
(paren
(paren
id|delta_vchan0
op_plus
id|delta_vchan1
)paren
OG
id|avail_rrbs
)paren
(brace
r_if
c_cond
(paren
id|count_vchan0
op_logical_and
(paren
op_logical_neg
id|count_vchan1
op_logical_or
(paren
(paren
id|orig_vchan0
op_plus
id|delta_vchan0
)paren
OG
(paren
id|orig_vchan1
op_plus
id|delta_vchan1
)paren
)paren
)paren
)paren
id|delta_vchan0
op_decrement
suffix:semicolon
r_else
id|delta_vchan1
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Figure final RRB allocations&n;     */
id|final_vchan0
op_assign
id|orig_vchan0
op_plus
id|delta_vchan0
suffix:semicolon
id|final_vchan1
op_assign
id|orig_vchan1
op_plus
id|delta_vchan1
suffix:semicolon
multiline_comment|/* If either channel wants RRBs but our actions&n;     * would leave it with none, declare an error,&n;     * but DO NOT change any RRB allocations.&n;     */
r_if
c_cond
(paren
(paren
id|desired_vchan0
op_logical_and
op_logical_neg
id|final_vchan0
)paren
op_logical_or
(paren
id|desired_vchan1
op_logical_and
op_logical_neg
id|final_vchan1
)paren
)paren
(brace
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Commit the allocations: free, then alloc.&n;&t; */
r_if
c_cond
(paren
id|delta_vchan0
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|VCHAN0
comma
op_minus
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|VCHAN1
comma
op_minus
id|delta_vchan1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan0
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|VCHAN0
comma
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|VCHAN1
comma
id|delta_vchan1
)paren
suffix:semicolon
multiline_comment|/* Return final values to caller.&n;&t; */
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|final_vchan0
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|final_vchan1
suffix:semicolon
multiline_comment|/* prevent automatic changes to this slot&squot;s RRBs&n;&t; */
id|pcibr_soft-&gt;bs_rrb_fixed
op_or_assign
l_int|1
op_lshift
id|pciio_slot
suffix:semicolon
multiline_comment|/* Track the actual allocations, release&n;&t; * any further reservations, and update the&n;&t; * number of available RRBs.&n;&t; */
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN0
)braket
op_assign
id|final_vchan0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN1
)braket
op_assign
id|final_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_minus
id|delta_vchan0
op_minus
id|delta_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Reserve enough RRBs so this slot&squot;s RRB configuration can be&n;         * reset to its boot-time default following a hot-plug shut-down&n;         */
id|res_rrbs
op_assign
(paren
id|pcibr_soft-&gt;bs_rrb_res_dflt
(braket
id|pciio_slot
)braket
op_minus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
(brace
id|res_rrbs
op_add_assign
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
op_minus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|vchan
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res_rrbs
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_assign
id|res_rrbs
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_minus
id|res_rrbs
suffix:semicolon
)brace
id|pcibr_rrb_debug
c_func
(paren
l_string|&quot;pcibr_rrb_alloc&quot;
comma
id|pcibr_soft
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to check the current state&n; * of the RRB allocations.&n; *&n; *   pconn_vhdl is your PCI connection point (specifies which&n; *      PCI bus and which slot).&n; *&n; *   count_vchan0 points to where to return the number of RRBs&n; *      assigned to the primary DMA channel, used by all DMA&n; *      that does not explicitly ask for the alternate virtual&n; *      channel.&n; *&n; *   count_vchan1 points to where to return the number of RRBs&n; *      assigned to the secondary DMA channel, used when&n; *      PCIBR_VCHAN1 and PCIIO_DMA_A64 are specified.&n; *&n; *   count_reserved points to where to return the number of RRBs&n; *      that have been automatically reserved for your device at&n; *      startup, but which have not been assigned to a&n; *      channel. RRBs must be assigned to a channel to be used;&n; *      this can be done either with an explicit pcibr_rrb_alloc&n; *      call, or automatically by the infrastructure when a DMA&n; *      translation is constructed. Any call to pcibr_rrb_alloc&n; *      will release any unassigned reserved RRBs back to the&n; *      free pool.&n; *&n; *   count_pool points to where to return the number of RRBs&n; *      that are currently unassigned and unreserved. This&n; *      number can (and will) change as other drivers make calls&n; *      to pcibr_rrb_alloc, or automatically allocate RRBs for&n; *      DMA beyond their initial reservation.&n; *&n; * NULL may be passed for any of the return value pointers&n; * the caller is not interested in.&n; *&n; * The return value is &quot;0&quot; if all went well, or &quot;-1&quot; if&n; * there is a problem. Additionally, if the wrong vertex&n; * is passed in, one of the subsidiary support functions&n; * could panic with a &quot;bad pciio fingerprint.&quot;&n; */
r_int
DECL|function|pcibr_rrb_check
id|pcibr_rrb_check
c_func
(paren
id|vertex_hdl_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
comma
r_int
op_star
id|count_reserved
comma
r_int
op_star
id|count_pool
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
)paren
op_logical_and
(paren
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
)paren
op_logical_and
(paren
(paren
id|pciio_slot
op_assign
id|PCIBR_INFO_SLOT_GET_INT
c_func
(paren
id|pciio_info
)paren
)paren
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
)paren
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
(braket
id|VCHAN1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_reserved
)paren
op_star
id|count_reserved
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_pool
)paren
op_star
id|count_pool
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_initial_rrb_alloc&n; *&t;Allocate a default number of rrbs for this slot on &n; * &t;the two channels.  This is dictated by the rrb allocation&n; * &t;strategy routine defined per platform.&n; */
r_int
DECL|function|pcibr_slot_initial_rrb_alloc
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|vchan_total
suffix:semicolon
r_int
id|vchan
suffix:semicolon
r_int
id|chan
(braket
l_int|4
)braket
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* How many RRBs are on this slot? */
id|vchan_total
op_assign
id|NUMBER_VCHANNELS
c_func
(paren
id|bridge
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
id|chan
(braket
id|vchan
)braket
op_assign
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_initial_rrb_alloc: slot %d started with %d+%d+%d+%d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|chan
(braket
id|VCHAN0
)braket
comma
id|chan
(braket
id|VCHAN1
)braket
comma
id|chan
(braket
id|VCHAN2
)braket
comma
id|chan
(braket
id|VCHAN3
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_initial_rrb_alloc: slot %d started with %d+%d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|chan
(braket
id|VCHAN0
)braket
comma
id|chan
(braket
id|VCHAN1
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Do we really need any?&n;     */
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856866
comma
id|pcibr_soft
)paren
op_logical_and
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
(paren
id|slot
op_eq
l_int|2
op_logical_or
id|slot
op_eq
l_int|3
)paren
op_logical_and
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
op_logical_and
op_logical_neg
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
l_int|2
suffix:semicolon
id|vchan
op_increment
)paren
(brace
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
comma
id|vchan
comma
l_int|8
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
l_int|3
)braket
op_assign
id|chan
(braket
l_int|3
)braket
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
op_assign
id|chan
(braket
id|vchan
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|rrb_reserved_free
id|rrb_reserved_free
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|slot
)paren
(brace
r_int
id|res
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_add_assign
id|res
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pcibr_initial_rrb&n; *      Assign an equal total number of RRBs to all candidate slots, &n; *      where the total is the sum of the number of RRBs assigned to&n; *      the normal channel, the number of RRBs assigned to the virtual&n; *      channels, and the number of RRBs assigned as reserved. &n; *&n; *      A candidate slot is any existing (populated or empty) slot.&n; *      Empty SN1 slots need RRBs to support hot-plug operations.&n; */
r_int
DECL|function|pcibr_initial_rrb
id|pcibr_initial_rrb
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|first
comma
id|pciio_slot_t
id|last
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|rrb_total
suffix:semicolon
r_int
id|vchan_total
suffix:semicolon
r_int
id|vchan
suffix:semicolon
r_int
id|have
(braket
l_int|2
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|res
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|eo
suffix:semicolon
id|have
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|have
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|have
(braket
l_int|0
)braket
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|have
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_assign
id|have
(braket
l_int|1
)braket
(braket
l_int|1
)braket
op_assign
id|have
(braket
l_int|1
)braket
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|res
(braket
l_int|0
)braket
op_assign
id|res
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|vchan_total
op_assign
id|NUMBER_VCHANNELS
c_func
(paren
id|bridge
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Initial RRB management; give back RRBs in all non-existent slots */
(paren
r_void
)paren
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Base calculations only on existing slots */
r_if
c_cond
(paren
(paren
id|slot
op_ge
id|first
)paren
op_logical_and
(paren
id|slot
op_le
id|last
)paren
)paren
(brace
id|rrb_total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
id|rrb_total
op_add_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rrb_total
OL
l_int|3
)paren
id|have
(braket
id|slot
op_amp
l_int|1
)braket
(braket
id|rrb_total
)braket
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize even/odd slot available RRB counts */
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Calculate reserved RRBs for slots based on current RRB usage&n;     */
r_for
c_loop
(paren
id|eo
op_assign
l_int|0
suffix:semicolon
id|eo
OL
l_int|2
suffix:semicolon
id|eo
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|3
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_plus
l_int|2
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|1
)braket
op_plus
id|have
(braket
id|eo
)braket
(braket
l_int|2
)braket
)paren
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|3
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
l_int|2
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_plus
id|have
(braket
id|eo
)braket
(braket
l_int|1
)braket
)paren
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|1
suffix:semicolon
r_else
id|res
(braket
id|eo
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Assign reserved RRBs to existing slots */
r_for
c_loop
(paren
id|slot
op_assign
id|first
suffix:semicolon
id|slot
op_le
id|last
suffix:semicolon
op_increment
id|slot
)paren
(brace
r_int
id|r
suffix:semicolon
id|rrb_total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vchan
op_assign
l_int|0
suffix:semicolon
id|vchan
OL
id|vchan_total
suffix:semicolon
id|vchan
op_increment
)paren
id|rrb_total
op_add_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|vchan
)braket
suffix:semicolon
id|r
op_assign
id|res
(braket
id|slot
op_amp
l_int|1
)braket
op_minus
(paren
id|rrb_total
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
id|r
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|r
suffix:semicolon
)brace
)brace
id|pcibr_rrb_debug
c_func
(paren
l_string|&quot;pcibr_initial_rrb&quot;
comma
id|pcibr_soft
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dump the pcibr_soft_t RRB state variable&n; */
r_void
DECL|function|pcibr_rrb_debug
id|pcibr_rrb_debug
c_func
(paren
r_char
op_star
id|calling_func
comma
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
r_char
id|tmp_str
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_debug_mask
op_amp
id|PCIBR_DEBUG_RRB
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;%s: rrbs available, even=%d, odd=%d&bslash;n&quot;
comma
id|calling_func
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;&bslash;tslot&bslash;tvchan0&bslash;tvchan1&bslash;tvchan2&bslash;tvchan3&bslash;treserved&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;&bslash;tslot&bslash;tvchan0&bslash;tvchan1&bslash;treserved&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|slot
op_increment
)paren
(brace
multiline_comment|/*&n;             * The kernel only allows functions to have so many variable args,&n;             * attempting to call PCIBR_DEBUG_ALWAYS() with more than 5 printf&n;             * arguments fails so sprintf() it into a temporary string.&n;             */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;&bslash;t %d&bslash;t  %d&bslash;t  %d&bslash;t  %d&bslash;t  %d&bslash;t  %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN1
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN2
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN3
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;&bslash;t %d&bslash;t  %d&bslash;t  %d&bslash;t  %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN1
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RRB
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;%s&quot;
comma
id|tmp_str
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
eof
