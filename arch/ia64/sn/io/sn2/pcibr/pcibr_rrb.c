multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_void
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_int
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|pcibr_wrb_flush
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_rrb_alloc
c_func
(paren
id|devfs_handle_t
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pcibr_rrb_check
c_func
(paren
id|devfs_handle_t
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pcibr_alloc_all_rrbs
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_rrb_flush
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
multiline_comment|/* &n; *    RRB Management&n; */
DECL|macro|LSBIT
mdefine_line|#define LSBIT(word)&t;&t;((word) &amp;~ ((word)-1))
r_void
DECL|function|do_pcibr_rrb_clear
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrb
)paren
(brace
id|bridgereg_t
id|status
suffix:semicolon
multiline_comment|/* bridge_lock must be held;&n;     * this RRB must be disabled.&n;     */
multiline_comment|/* wait until RRB has no outstanduing XIO packets. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_INUSE
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
multiline_comment|/* if the RRB has data, drain it. */
r_if
c_cond
(paren
id|status
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
id|bridge-&gt;b_resp_clear
op_assign
id|BRIDGE_RRB_CLEAR
c_func
(paren
id|rrb
)paren
suffix:semicolon
multiline_comment|/* wait until RRB is no longer valid. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
)brace
)brace
r_void
DECL|function|do_pcibr_rrb_flush
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrbn
)paren
(brace
id|reg_p
id|rrbp
op_assign
op_amp
id|bridge-&gt;b_rrb_map
(braket
id|rrbn
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|bridgereg_t
id|rrbv
suffix:semicolon
r_int
id|shft
op_assign
l_int|4
op_star
(paren
id|rrbn
op_rshift
l_int|1
)paren
suffix:semicolon
r_int
id|ebit
op_assign
id|BRIDGE_RRB_EN
op_lshift
id|shft
suffix:semicolon
id|rrbv
op_assign
op_star
id|rrbp
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
op_star
id|rrbp
op_assign
id|rrbv
op_amp
op_complement
id|ebit
suffix:semicolon
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
id|rrbn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
op_star
id|rrbp
op_assign
id|rrbv
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_rrb_count_valid: count how many RRBs are&n; *      marked valid for the specified PCI slot on this&n; *      bridge.&n; *&n; *      NOTE: The &quot;slot&quot; parameter for all pcibr_rrb&n; *      management routines must include the &quot;virtual&quot;&n; *      bit; when manageing both the normal and the&n; *      virtual channel, separate calls to these&n; *      routines must be made. To denote the virtual&n; *      channel, add PCIBR_RRB_SLOT_VIRTUAL to the slot&n; *      number.&n; *&n; *      IMPL NOTE: The obvious algorithm is to iterate&n; *      through the RRB fields, incrementing a count if&n; *      the RRB is valid and matches the slot. However,&n; *      it is much simpler to use an algorithm derived&n; *      from the &quot;partitioned add&quot; idea. First, XOR in a&n; *      pattern such that the fields that match this&n; *      slot come up &quot;all ones&quot; and all other fields&n; *      have zeros in the mismatching bits. Then AND&n; *      together the bits in the field, so we end up&n; *      with one bit turned on for each field that&n; *      matched. Now we need to count these bits. This&n; *      can be done either with a series of shift/add&n; *      instructions or by using &quot;tmp % 15&quot;; I expect&n; *      that the cascaded shift/add will be faster.&n; */
r_int
DECL|function|do_pcibr_rrb_count_valid
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_xor_assign
l_int|0x11111111
op_star
(paren
l_int|7
op_minus
id|slot
op_div
l_int|2
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0xCCCCCCCC
op_amp
id|tmp
)paren
op_rshift
l_int|2
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x22222222
op_amp
id|tmp
)paren
op_rshift
l_int|1
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|4
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|16
suffix:semicolon
r_return
id|tmp
op_amp
l_int|15
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_count_avail: count how many RRBs are&n; *      available to be allocated for the specified slot.&n; *&n; *      IMPL NOTE: similar to the above, except we are&n; *      just counting how many fields have the valid bit&n; *      turned off.&n; */
r_int
DECL|function|do_pcibr_rrb_count_avail
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_assign
(paren
l_int|0x88888888
op_amp
op_complement
id|tmp
)paren
op_rshift
l_int|3
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|4
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|16
suffix:semicolon
r_return
id|tmp
op_amp
l_int|15
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_alloc: allocate some additional RRBs&n; *      for the specified slot. Returns -1 if there were&n; *      insufficient free RRBs to satisfy the request,&n; *      or 0 if the request was fulfilled.&n; *&n; *      Note that if a request can be partially filled,&n; *      it will be, even if we return failure.&n; *&n; *      IMPL NOTE: again we avoid iterating across all&n; *      the RRBs; instead, we form up a word containing&n; *      one bit for each free RRB, then peel the bits&n; *      off from the low end.&n; */
r_int
DECL|function|do_pcibr_rrb_alloc
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|more
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|reg
comma
id|tmp
comma
id|bit
suffix:semicolon
id|reg
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_assign
(paren
l_int|0x88888888
op_amp
op_complement
id|reg
)paren
op_rshift
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|more
op_decrement
OG
l_int|0
)paren
(brace
id|bit
op_assign
id|LSBIT
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
(brace
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_and_assign
op_complement
id|bit
suffix:semicolon
id|reg
op_assign
(paren
(paren
id|reg
op_amp
op_complement
(paren
id|bit
op_star
l_int|15
)paren
)paren
op_or
(paren
id|bit
op_star
(paren
l_int|8
op_plus
id|slot
op_div
l_int|2
)paren
)paren
)paren
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_free: release some of the RRBs that&n; *      have been allocated for the specified&n; *      slot. Returns zero for success, or negative if&n; *      it was unable to free that many RRBs.&n; *&n; *      IMPL NOTE: We form up a bit for each RRB&n; *      allocated to the slot, aligned with the VALID&n; *      bitfield this time; then we peel bits off one at&n; *      a time, releasing the corresponding RRB.&n; */
r_int
DECL|function|do_pcibr_rrb_free
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|less
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|reg
comma
id|tmp
comma
id|clr
comma
id|bit
suffix:semicolon
r_int
id|i
suffix:semicolon
id|clr
op_assign
l_int|0
suffix:semicolon
id|reg
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
multiline_comment|/* This needs to be done otherwise the rrb&squot;s on the virtual channel&n;     * for this slot won&squot;t be freed !!&n;     */
id|tmp
op_assign
id|reg
op_amp
l_int|0xbbbbbbbb
suffix:semicolon
id|tmp
op_xor_assign
(paren
l_int|0x11111111
op_star
(paren
l_int|7
op_minus
id|slot
op_div
l_int|2
)paren
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x33333333
op_amp
id|tmp
)paren
op_lshift
l_int|2
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x44444444
op_amp
id|tmp
)paren
op_lshift
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|less
op_decrement
OG
l_int|0
)paren
(brace
id|bit
op_assign
id|LSBIT
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
(brace
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_and_assign
op_complement
id|bit
suffix:semicolon
id|reg
op_and_assign
op_complement
id|bit
suffix:semicolon
id|clr
op_or_assign
id|bit
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|clr
op_amp
(paren
l_int|8
op_lshift
(paren
l_int|4
op_star
id|i
)paren
)paren
)paren
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
(paren
l_int|2
op_star
id|i
)paren
op_plus
(paren
id|slot
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_void
DECL|function|do_pcibr_rrb_autoalloc
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|slot
comma
r_int
id|more_rrbs
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|got
suffix:semicolon
r_for
c_loop
(paren
id|got
op_assign
l_int|0
suffix:semicolon
id|got
OL
id|more_rrbs
suffix:semicolon
op_increment
id|got
)paren
(brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
op_amp
l_int|7
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
op_amp
l_int|7
)braket
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_decrement
suffix:semicolon
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|slot
comma
l_int|1
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;do_pcibr_rrb_autoalloc: add one to slot %d%s&bslash;n&quot;
comma
id|slot
op_amp
l_int|7
comma
id|slot
op_amp
l_int|8
ques
c_cond
l_string|&quot;v&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_increment
suffix:semicolon
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %d+%d free RRBs. Allocation list:&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Device driver interface to flush the write buffers for a specified&n; * device hanging off the bridge.&n; */
r_int
DECL|function|pcibr_wrb_flush
id|pcibr_wrb_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_volatile
id|bridgereg_t
op_star
id|wrb_flush
suffix:semicolon
id|wrb_flush
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|wrb_flush
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to request RRBs for a specified device&n; * hanging off a Bridge.  The driver requests the total number of&n; * RRBs it would like for the normal channel (vchan0) and for the&n; * &quot;virtual channel&quot; (vchan1).  The actual number allocated to each&n; * channel is returned.&n; *&n; * If we cannot allocate at least one RRB to a channel that needs&n; * at least one, return -1 (failure).  Otherwise, satisfy the request&n; * as best we can and return 0.&n; */
r_int
DECL|function|pcibr_rrb_alloc
id|pcibr_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|desired_vchan0
suffix:semicolon
r_int
id|desired_vchan1
suffix:semicolon
r_int
id|orig_vchan0
suffix:semicolon
r_int
id|orig_vchan1
suffix:semicolon
r_int
id|delta_vchan0
suffix:semicolon
r_int
id|delta_vchan1
suffix:semicolon
r_int
id|final_vchan0
suffix:semicolon
r_int
id|final_vchan1
suffix:semicolon
r_int
id|avail_rrbs
suffix:semicolon
r_int
id|res_rrbs
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;     * TBD: temper request with admin info about RRB allocation,&n;     * and according to demand from other devices on this Bridge.&n;     *&n;     * One way of doing this would be to allocate two RRBs&n;     * for each device on the bus, before any drivers start&n;     * asking for extras. This has the weakness that one&n;     * driver might not give back an &quot;extra&quot; RRB until after&n;     * another driver has already failed to get one that&n;     * it wanted.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Save the boot-time RRB configuration for this slot */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
OL
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res_dflt
(braket
id|pciio_slot
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
)brace
multiline_comment|/* How many RRBs do we own? */
id|orig_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
id|orig_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
multiline_comment|/* How many RRBs do we want? */
id|desired_vchan0
op_assign
id|count_vchan0
ques
c_cond
op_star
id|count_vchan0
suffix:colon
id|orig_vchan0
suffix:semicolon
id|desired_vchan1
op_assign
id|count_vchan1
ques
c_cond
op_star
id|count_vchan1
suffix:colon
id|orig_vchan1
suffix:semicolon
multiline_comment|/* How many RRBs are free? */
id|avail_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
multiline_comment|/* Figure desired deltas */
id|delta_vchan0
op_assign
id|desired_vchan0
op_minus
id|orig_vchan0
suffix:semicolon
id|delta_vchan1
op_assign
id|desired_vchan1
op_minus
id|orig_vchan1
suffix:semicolon
multiline_comment|/* Trim back deltas to something&n;     * that we can actually meet, by&n;     * decreasing the ending allocation&n;     * for whichever channel wants&n;     * more RRBs. If both want the same&n;     * number, cut the second channel.&n;     * NOTE: do not change the allocation for&n;     * a channel that was passed as NULL.&n;     */
r_while
c_loop
(paren
(paren
id|delta_vchan0
op_plus
id|delta_vchan1
)paren
OG
id|avail_rrbs
)paren
(brace
r_if
c_cond
(paren
id|count_vchan0
op_logical_and
(paren
op_logical_neg
id|count_vchan1
op_logical_or
(paren
(paren
id|orig_vchan0
op_plus
id|delta_vchan0
)paren
OG
(paren
id|orig_vchan1
op_plus
id|delta_vchan1
)paren
)paren
)paren
)paren
id|delta_vchan0
op_decrement
suffix:semicolon
r_else
id|delta_vchan1
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Figure final RRB allocations&n;     */
id|final_vchan0
op_assign
id|orig_vchan0
op_plus
id|delta_vchan0
suffix:semicolon
id|final_vchan1
op_assign
id|orig_vchan1
op_plus
id|delta_vchan1
suffix:semicolon
multiline_comment|/* If either channel wants RRBs but our actions&n;     * would leave it with none, declare an error,&n;     * but DO NOT change any RRB allocations.&n;     */
r_if
c_cond
(paren
(paren
id|desired_vchan0
op_logical_and
op_logical_neg
id|final_vchan0
)paren
op_logical_or
(paren
id|desired_vchan1
op_logical_and
op_logical_neg
id|final_vchan1
)paren
)paren
(brace
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Commit the allocations: free, then alloc.&n;&t; */
r_if
c_cond
(paren
id|delta_vchan0
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
op_minus
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|PCIBR_RRB_SLOT_VIRTUAL
op_plus
id|pciio_slot
comma
op_minus
id|delta_vchan1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan0
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|PCIBR_RRB_SLOT_VIRTUAL
op_plus
id|pciio_slot
comma
id|delta_vchan1
)paren
suffix:semicolon
multiline_comment|/* Return final values to caller.&n;&t; */
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|final_vchan0
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|final_vchan1
suffix:semicolon
multiline_comment|/* prevent automatic changes to this slot&squot;s RRBs&n;&t; */
id|pcibr_soft-&gt;bs_rrb_fixed
op_or_assign
l_int|1
op_lshift
id|pciio_slot
suffix:semicolon
multiline_comment|/* Track the actual allocations, release&n;&t; * any further reservations, and update the&n;&t; * number of available RRBs.&n;&t; */
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
op_assign
id|final_vchan0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|final_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_minus
id|delta_vchan0
op_minus
id|delta_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Reserve enough RRBs so this slot&squot;s RRB configuration can be&n;         * reset to its boot-time default following a hot-plug shut-down&n;         */
id|res_rrbs
op_assign
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
)braket
op_minus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
)paren
op_plus
(paren
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_minus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
)paren
op_plus
(paren
id|pcibr_soft-&gt;bs_rrb_res_dflt
(braket
id|pciio_slot
)braket
op_minus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_rrbs
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_assign
id|res_rrbs
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_minus
id|res_rrbs
suffix:semicolon
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_rrb_alloc: slot %d set to %d+%d; %d+%d free&bslash;n&quot;
comma
id|pciio_slot
comma
id|final_vchan0
comma
id|final_vchan1
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pciio_slot
op_assign
l_int|0
suffix:semicolon
id|pciio_slot
OL
l_int|8
suffix:semicolon
op_increment
id|pciio_slot
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to check the current state&n; * of the RRB allocations.&n; *&n; *   pconn_vhdl is your PCI connection point (specifies which&n; *      PCI bus and which slot).&n; *&n; *   count_vchan0 points to where to return the number of RRBs&n; *      assigned to the primary DMA channel, used by all DMA&n; *      that does not explicitly ask for the alternate virtual&n; *      channel.&n; *&n; *   count_vchan1 points to where to return the number of RRBs&n; *      assigned to the secondary DMA channel, used when&n; *      PCIBR_VCHAN1 and PCIIO_DMA_A64 are specified.&n; *&n; *   count_reserved points to where to return the number of RRBs&n; *      that have been automatically reserved for your device at&n; *      startup, but which have not been assigned to a&n; *      channel. RRBs must be assigned to a channel to be used;&n; *      this can be done either with an explicit pcibr_rrb_alloc&n; *      call, or automatically by the infrastructure when a DMA&n; *      translation is constructed. Any call to pcibr_rrb_alloc&n; *      will release any unassigned reserved RRBs back to the&n; *      free pool.&n; *&n; *   count_pool points to where to return the number of RRBs&n; *      that are currently unassigned and unreserved. This&n; *      number can (and will) change as other drivers make calls&n; *      to pcibr_rrb_alloc, or automatically allocate RRBs for&n; *      DMA beyond their initial reservation.&n; *&n; * NULL may be passed for any of the return value pointers&n; * the caller is not interested in.&n; *&n; * The return value is &quot;0&quot; if all went well, or &quot;-1&quot; if&n; * there is a problem. Additionally, if the wrong vertex&n; * is passed in, one of the subsidiary support functions&n; * could panic with a &quot;bad pciio fingerprint.&quot;&n; */
r_int
DECL|function|pcibr_rrb_check
id|pcibr_rrb_check
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
comma
r_int
op_star
id|count_reserved
comma
r_int
op_star
id|count_pool
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
)paren
op_logical_and
(paren
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
)paren
op_logical_and
(paren
(paren
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
)paren
OL
l_int|8
)paren
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_reserved
)paren
op_star
id|count_reserved
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_pool
)paren
op_star
id|count_pool
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* pcibr_alloc_all_rrbs allocates all the rrbs available in the quantities&n; * requested for each of the devices.  The evn_odd argument indicates whether&n; * allocation is for the odd or even rrbs. The next group of four argument&n; * pairs indicate the amount of rrbs to be assigned to each device. The first&n; * argument of each pair indicate the total number of rrbs to allocate for that&n; * device. The second argument of each pair indicates how many rrb&squot;s from the&n; * first argument should be assigned to the virtual channel. The total of all&n; * of the first arguments should be &lt;= 8. The second argument should be &lt;= the&n; * first argument.&n; * if even_odd = 0 the devices in order are 0, 2, 4, 6 &n; * if even_odd = 1 the devices in order are 1, 3, 5, 7&n; * returns 0 if no errors else returns -1&n; */
r_int
DECL|function|pcibr_alloc_all_rrbs
id|pcibr_alloc_all_rrbs
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|even_odd
comma
r_int
id|dev_1_rrbs
comma
r_int
id|virt1
comma
r_int
id|dev_2_rrbs
comma
r_int
id|virt2
comma
r_int
id|dev_3_rrbs
comma
r_int
id|virt3
comma
r_int
id|dev_4_rrbs
comma
r_int
id|virt4
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
l_int|0
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|rrb_setting
op_assign
l_int|0
suffix:semicolon
r_int
id|rrb_shift
op_assign
l_int|7
suffix:semicolon
r_uint32
id|cur_rrb
suffix:semicolon
r_int
id|dev_rrbs
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|virt
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_traverse
c_func
(paren
id|vhdl
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
)paren
(brace
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft
)paren
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bridge
op_eq
l_int|NULL
)paren
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_piotrans_addr
(paren
id|vhdl
comma
l_int|NULL
comma
l_int|0
comma
r_sizeof
(paren
id|bridge_t
)paren
comma
l_int|0
)paren
suffix:semicolon
id|even_odd
op_and_assign
l_int|1
suffix:semicolon
id|dev_rrbs
(braket
l_int|0
)braket
op_assign
id|dev_1_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|1
)braket
op_assign
id|dev_2_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|2
)braket
op_assign
id|dev_3_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|3
)braket
op_assign
id|dev_4_rrbs
suffix:semicolon
id|virt
(braket
l_int|0
)braket
op_assign
id|virt1
suffix:semicolon
id|virt
(braket
l_int|1
)braket
op_assign
id|virt2
suffix:semicolon
id|virt
(braket
l_int|2
)braket
op_assign
id|virt3
suffix:semicolon
id|virt
(braket
l_int|3
)braket
op_assign
id|virt4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev_1_rrbs
op_plus
id|dev_2_rrbs
op_plus
id|dev_3_rrbs
op_plus
id|dev_4_rrbs
)paren
OG
l_int|8
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev_1_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_2_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_3_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_4_rrbs
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* walk through rrbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|virt
(braket
id|i
)braket
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|virt
(braket
id|i
)braket
suffix:semicolon
id|j
op_increment
)paren
(brace
id|cur_rrb
op_assign
id|i
op_or
l_int|0xc
suffix:semicolon
id|cur_rrb
op_assign
id|cur_rrb
op_lshift
(paren
id|rrb_shift
op_star
l_int|4
)paren
suffix:semicolon
id|rrb_shift
op_decrement
suffix:semicolon
id|rrb_setting
op_assign
id|rrb_setting
op_or
id|cur_rrb
suffix:semicolon
id|dev_rrbs
(braket
id|i
)braket
op_assign
id|dev_rrbs
(braket
id|i
)braket
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dev_rrbs
(braket
id|i
)braket
suffix:semicolon
id|j
op_increment
)paren
(brace
id|cur_rrb
op_assign
id|i
op_or
l_int|0x8
suffix:semicolon
id|cur_rrb
op_assign
id|cur_rrb
op_lshift
(paren
id|rrb_shift
op_star
l_int|4
)paren
suffix:semicolon
id|rrb_shift
op_decrement
suffix:semicolon
id|rrb_setting
op_assign
id|rrb_setting
op_or
id|cur_rrb
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibr_soft
)paren
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge-&gt;b_rrb_map
(braket
id|even_odd
)braket
dot
id|reg
op_assign
id|rrb_setting
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_fixed
op_or_assign
l_int|0x55
op_lshift
id|even_odd
suffix:semicolon
multiline_comment|/* since we&squot;ve &quot;FIXED&quot; the allocations&n;&t; * for these slots, we probably can dispense&n;&t; * with tracking avail/res/valid data, but&n;&t; * keeping it up to date helps debugging.&n;&t; */
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|even_odd
)braket
op_assign
l_int|8
op_minus
(paren
id|dev_1_rrbs
op_plus
id|dev_2_rrbs
op_plus
id|dev_3_rrbs
op_plus
id|dev_4_rrbs
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|0
)braket
op_assign
id|dev_1_rrbs
op_minus
id|virt1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|2
)braket
op_assign
id|dev_2_rrbs
op_minus
id|virt2
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|4
)braket
op_assign
id|dev_3_rrbs
op_minus
id|virt3
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|6
)braket
op_assign
id|dev_4_rrbs
op_minus
id|virt4
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|0
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|2
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt2
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|4
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt3
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|6
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt4
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_rrb_flush: chase down all the RRBs assigned&n; *      to the specified connection point, and flush&n; *      them.&n; */
r_void
DECL|function|pcibr_rrb_flush
id|pcibr_rrb_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|reg_p
id|rrbp
suffix:semicolon
r_int
id|rrbm
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rrbn
suffix:semicolon
r_int
id|sval
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|sval
op_assign
id|BRIDGE_RRB_EN
op_or
(paren
id|pciio_slot
op_rshift
l_int|1
)paren
suffix:semicolon
id|mask
op_assign
id|BRIDGE_RRB_EN
op_or
id|BRIDGE_RRB_PDEV
suffix:semicolon
id|rrbn
op_assign
id|pciio_slot
op_amp
l_int|1
suffix:semicolon
id|rrbp
op_assign
op_amp
id|bridge-&gt;b_rrb_map
(braket
id|rrbn
)braket
dot
id|reg
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|rrbm
op_assign
op_star
id|rrbp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|rrbm
op_amp
id|mask
)paren
op_eq
id|sval
)paren
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge
comma
id|rrbn
)paren
suffix:semicolon
id|rrbm
op_rshift_assign
l_int|4
suffix:semicolon
id|rrbn
op_add_assign
l_int|2
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_initial_rrb_alloc&n; *&t;Allocate a default number of rrbs for this slot on &n; * &t;the two channels.  This is dictated by the rrb allocation&n; * &t;strategy routine defined per platform.&n; */
r_int
DECL|function|pcibr_slot_initial_rrb_alloc
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|c0
comma
id|c1
comma
id|r
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* How may RRBs are on this slot?&n;     */
id|c0
op_assign
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|c1
op_assign
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge
comma
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)paren
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_slot_initial_rrb_alloc: slot %d started with %d+%d&bslash;n&quot;
comma
id|slot
comma
id|c0
comma
id|c1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Do we really need any?&n;     */
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
op_logical_and
op_logical_neg
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_if
c_cond
(paren
id|c0
OG
l_int|0
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
comma
id|c0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c1
OG
l_int|0
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
comma
id|c1
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_assign
l_int|0x1000
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
l_int|0x1000
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|c0
op_plus
id|c1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_assign
id|c0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|c1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|1
)paren
suffix:semicolon
id|r
op_assign
l_int|3
op_minus
(paren
id|c0
op_plus
id|c1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
id|r
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|r
suffix:semicolon
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_initial_rrb&n; *      Assign an equal total number of RRBs to all candidate slots, &n; *      where the total is the sum of the number of RRBs assigned to&n; *      the normal channel, the number of RRBs assigned to the virtual&n; *      channel, and the number of RRBs assigned as reserved. &n; *&n; *      A candidate slot is a populated slot on a non-SN1 system or &n; *      any existing (populated or empty) slot on an SN1 system.&n; *      Empty SN1 slots need RRBs to support hot-plug operations.&n; */
r_int
DECL|function|pcibr_initial_rrb
id|pcibr_initial_rrb
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|first
comma
id|pciio_slot_t
id|last
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|c0
comma
id|c1
suffix:semicolon
r_int
id|have
(braket
l_int|2
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|res
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|eo
suffix:semicolon
id|have
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|have
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|have
(braket
l_int|0
)braket
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|have
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_assign
id|have
(braket
l_int|1
)braket
(braket
l_int|1
)braket
op_assign
id|have
(braket
l_int|1
)braket
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|res
(braket
l_int|0
)braket
op_assign
id|res
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Initial RRB management; give back RRBs in all non-existent slots */
(paren
r_void
)paren
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Base calculations only on existing slots */
r_if
c_cond
(paren
(paren
id|slot
op_ge
id|first
)paren
op_logical_and
(paren
id|slot
op_le
id|last
)paren
)paren
(brace
id|c0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
suffix:semicolon
id|c1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c0
op_plus
id|c1
)paren
OL
l_int|3
)paren
id|have
(braket
id|slot
op_amp
l_int|1
)braket
(braket
id|c0
op_plus
id|c1
)braket
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize even/odd slot available RRB counts */
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Calculate reserved RRBs for slots based on current RRB usage&n;     */
r_for
c_loop
(paren
id|eo
op_assign
l_int|0
suffix:semicolon
id|eo
OL
l_int|2
suffix:semicolon
id|eo
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|3
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_plus
l_int|2
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|1
)braket
op_plus
id|have
(braket
id|eo
)braket
(braket
l_int|2
)braket
)paren
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|3
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
l_int|2
op_star
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_plus
id|have
(braket
id|eo
)braket
(braket
l_int|1
)braket
)paren
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|have
(braket
id|eo
)braket
(braket
l_int|0
)braket
op_le
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|eo
)braket
)paren
id|res
(braket
id|eo
)braket
op_assign
l_int|1
suffix:semicolon
r_else
id|res
(braket
id|eo
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Assign reserved RRBs to existing slots */
r_for
c_loop
(paren
id|slot
op_assign
id|first
suffix:semicolon
id|slot
op_le
id|last
suffix:semicolon
op_increment
id|slot
)paren
(brace
r_int
id|r
suffix:semicolon
id|c0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
suffix:semicolon
id|c1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
id|r
op_assign
id|res
(braket
id|slot
op_amp
l_int|1
)braket
op_minus
(paren
id|c0
op_plus
id|c1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
id|r
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|r
suffix:semicolon
)brace
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v RRB MANAGEMENT: %d+%d free&bslash;n&quot;
comma
id|pcibr_vhdl
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|first
suffix:semicolon
id|slot
op_le
id|last
suffix:semicolon
op_increment
id|slot
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tslot %d: %d+%d+%d&quot;
comma
id|slot
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
