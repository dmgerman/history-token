multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_freeblock_sub
c_func
(paren
id|iopaddr_t
op_star
comma
id|iopaddr_t
op_star
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
macro_line|#if 0
r_int
id|pcibr_slot_reset
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
macro_line|#endif
r_int
id|pcibr_slot_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_free
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_device_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_is_slot_sys_critical
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
comma
id|cfg_p
comma
r_int
r_int
op_star
)paren
suffix:semicolon
r_void
id|pcibr_device_info_free
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_uint64
id|do_pcibr_config_get
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef LATER
r_int
id|pcibr_slot_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
suffix:semicolon
r_int
id|pcibr_slot_pwr
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
r_int
comma
r_char
op_star
)paren
suffix:semicolon
r_int
id|pcibr_slot_startup
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_slot_req_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_shutdown
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_slot_req_t
)paren
suffix:semicolon
r_void
id|pcibr_slot_func_info_return
c_func
(paren
id|pcibr_info_h
id|pcibr_infoh
comma
r_int
id|func
comma
id|pcibr_slot_func_info_resp_t
id|funcp
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pcibr_slot_info_resp_t
id|respp
)paren
suffix:semicolon
r_int
id|pcibr_slot_query
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_slot_req_t
)paren
suffix:semicolon
macro_line|#endif&t;/* LATER */
r_extern
id|devfs_handle_t
id|baseio_pci_vhdl
suffix:semicolon
r_int
id|scsi_ctlr_nums_add
c_func
(paren
id|devfs_handle_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
multiline_comment|/* For now .... */
multiline_comment|/*&n; * PCI Hot-Plug Capability Flags&n; */
DECL|macro|D_PCI_HOT_PLUG_ATTACH
mdefine_line|#define D_PCI_HOT_PLUG_ATTACH  0x200  /* Driver supports PCI hot-plug attach */
DECL|macro|D_PCI_HOT_PLUG_DETACH
mdefine_line|#define D_PCI_HOT_PLUG_DETACH  0x400  /* Driver supports PCI hot-plug detach */
multiline_comment|/*==========================================================================&n; *&t;BRIDGE PCI SLOT RELATED IOCTLs&n; */
macro_line|#ifdef LATER
multiline_comment|/*&n; * pcibr_slot_startup&n; *&t;Software start-up the PCI slot.&n; */
r_int
DECL|function|pcibr_slot_startup
id|pcibr_slot_startup
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|reqp-&gt;req_slot
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|l1_msg
(braket
id|BRL1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|pcibr_slot_up_resp_s
id|tmp_up_resp
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
multiline_comment|/* Do not allow start-up of a slot in a shoehorn */
r_if
c_cond
(paren
id|nic_vertex_info_match
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|XTALK_PCI_PART_NUM
)paren
)paren
(brace
r_return
id|PCI_SLOT_IN_SHOEHORN
suffix:semicolon
)brace
multiline_comment|/* Check for the valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
multiline_comment|/* Acquire update access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_UPDATE
comma
id|PZERO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_STARTUP_CMPLT
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_UP
suffix:semicolon
r_goto
id|startup_unlock
suffix:semicolon
)brace
id|error
op_assign
id|pcibr_slot_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|D_PCI_HOT_PLUG_ATTACH
comma
id|l1_msg
comma
op_amp
id|tmp_up_resp.resp_sub_errno
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|tmp_up_resp.resp_l1_msg
comma
id|l1_msg
comma
id|L1_QSIZE
)paren
suffix:semicolon
id|tmp_up_resp.resp_l1_msg
(braket
id|L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
op_amp
id|tmp_up_resp
comma
id|reqp-&gt;req_respp.up
comma
id|reqp-&gt;req_size
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|startup_unlock
suffix:colon
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_shutdown&n; *&t;Software shut-down the PCI slot&n; */
r_int
DECL|function|pcibr_slot_shutdown
id|pcibr_slot_shutdown
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|reqp-&gt;req_slot
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|l1_msg
(braket
id|BRL1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|pcibr_slot_down_resp_s
id|tmp_down_resp
suffix:semicolon
id|pciio_slot_t
id|tmp_slot
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Check for valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
multiline_comment|/* Do not allow shut-down of a slot in a shoehorn */
r_if
c_cond
(paren
id|nic_vertex_info_match
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|XTALK_PCI_PART_NUM
)paren
)paren
(brace
r_return
id|PCI_SLOT_IN_SHOEHORN
suffix:semicolon
)brace
multiline_comment|/* Acquire update access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_UPDATE
comma
id|PZERO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_SHUTDOWN_CMPLT
)paren
op_logical_or
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_STATUS_MASK
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_DOWN
suffix:semicolon
multiline_comment|/*&n;         * RJR - Should we invoke an L1 slot power-down command just in case&n;         *       a previous shut-down failed to power-down the slot?&n;         */
r_goto
id|shutdown_unlock
suffix:semicolon
)brace
multiline_comment|/* Do not allow the last 33 MHz card to be removed */
r_if
c_cond
(paren
(paren
id|bridge-&gt;b_wid_control
op_amp
id|BRIDGE_CTRL_BUS_SPEED_MASK
)paren
op_eq
id|BRIDGE_CTRL_BUS_SPEED_33
)paren
(brace
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_first_slot
suffix:semicolon
id|tmp_slot
op_le
id|pcibr_soft-&gt;bs_last_slot
suffix:semicolon
id|tmp_slot
op_increment
)paren
r_if
c_cond
(paren
id|tmp_slot
op_ne
id|slot
)paren
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|tmp_slot
)braket
dot
id|slot_status
op_amp
id|SLOT_POWER_UP
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|PCI_EMPTY_33MHZ
suffix:semicolon
r_goto
id|shutdown_unlock
suffix:semicolon
)brace
)brace
id|error
op_assign
id|pcibr_slot_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|D_PCI_HOT_PLUG_DETACH
comma
id|l1_msg
comma
op_amp
id|tmp_down_resp.resp_sub_errno
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|tmp_down_resp.resp_l1_msg
comma
id|l1_msg
comma
id|L1_QSIZE
)paren
suffix:semicolon
id|tmp_down_resp.resp_l1_msg
(braket
id|L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
op_amp
id|tmp_down_resp
comma
id|reqp-&gt;req_respp.down
comma
id|reqp-&gt;req_size
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|shutdown_unlock
suffix:colon
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|pci_space_name
r_char
op_star
id|pci_space_name
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ROM&quot;
comma
l_string|&quot;IO&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;MEM&quot;
comma
l_string|&quot;MEM32&quot;
comma
l_string|&quot;MEM64&quot;
comma
l_string|&quot;CFG&quot;
comma
l_string|&quot;WIN0&quot;
comma
l_string|&quot;WIN1&quot;
comma
l_string|&quot;WIN2&quot;
comma
l_string|&quot;WIN3&quot;
comma
l_string|&quot;WIN4&quot;
comma
l_string|&quot;WIN5&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;BAD&quot;
)brace
suffix:semicolon
r_void
DECL|function|pcibr_slot_func_info_return
id|pcibr_slot_func_info_return
c_func
(paren
id|pcibr_info_h
id|pcibr_infoh
comma
r_int
id|func
comma
id|pcibr_slot_func_info_resp_t
id|funcp
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_int
id|win
suffix:semicolon
id|funcp-&gt;resp_f_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
(brace
r_return
suffix:semicolon
)brace
id|funcp-&gt;resp_f_status
op_or_assign
id|FUNC_IS_VALID
suffix:semicolon
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_slot_name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_vertex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_sys_critical_vertex
c_func
(paren
id|pcibr_info-&gt;f_vertex
)paren
)paren
(brace
id|funcp-&gt;resp_f_status
op_or_assign
id|FUNC_IS_SYS_CRITICAL
suffix:semicolon
)brace
id|funcp-&gt;resp_f_bus
op_assign
id|pcibr_info-&gt;f_bus
suffix:semicolon
id|funcp-&gt;resp_f_slot
op_assign
id|pcibr_info-&gt;f_slot
suffix:semicolon
id|funcp-&gt;resp_f_func
op_assign
id|pcibr_info-&gt;f_func
suffix:semicolon
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_master_name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_master
)paren
suffix:semicolon
id|funcp-&gt;resp_f_pops
op_assign
id|pcibr_info-&gt;f_pops
suffix:semicolon
id|funcp-&gt;resp_f_efunc
op_assign
id|pcibr_info-&gt;f_efunc
suffix:semicolon
id|funcp-&gt;resp_f_einfo
op_assign
id|pcibr_info-&gt;f_einfo
suffix:semicolon
id|funcp-&gt;resp_f_vendor
op_assign
id|pcibr_info-&gt;f_vendor
suffix:semicolon
id|funcp-&gt;resp_f_device
op_assign
id|pcibr_info-&gt;f_device
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|6
suffix:semicolon
id|win
op_increment
)paren
(brace
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_space
comma
l_string|&quot;%s&quot;
comma
id|pci_space_name
(braket
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
)braket
)paren
suffix:semicolon
)brace
id|funcp-&gt;resp_f_rbase
op_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
id|funcp-&gt;resp_f_rsize
op_assign
id|pcibr_info-&gt;f_rsize
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|4
suffix:semicolon
id|win
op_increment
)paren
(brace
id|funcp-&gt;resp_f_ibit
(braket
id|win
)braket
op_assign
id|pcibr_info-&gt;f_ibit
(braket
id|win
)braket
suffix:semicolon
)brace
id|funcp-&gt;resp_f_att_det_error
op_assign
id|pcibr_info-&gt;f_att_det_error
suffix:semicolon
)brace
r_int
DECL|function|pcibr_slot_info_return
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pcibr_slot_info_resp_t
id|respp
)paren
(brace
id|pcibr_soft_slot_t
id|pss
suffix:semicolon
r_int
id|func
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|reg_p
id|b_respp
suffix:semicolon
id|pcibr_slot_info_resp_t
id|slotp
suffix:semicolon
id|pcibr_slot_func_info_resp_t
id|funcp
suffix:semicolon
id|slotp
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
op_star
id|slotp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slotp
op_eq
l_int|NULL
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|pss
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|slotp-&gt;resp_has_host
op_assign
id|pss-&gt;has_host
suffix:semicolon
id|slotp-&gt;resp_host_slot
op_assign
id|pss-&gt;host_slot
suffix:semicolon
id|sprintf
c_func
(paren
id|slotp-&gt;resp_slot_conn_name
comma
l_string|&quot;%v&quot;
comma
id|pss-&gt;slot_conn
)paren
suffix:semicolon
id|slotp-&gt;resp_slot_status
op_assign
id|pss-&gt;slot_status
suffix:semicolon
id|slotp-&gt;resp_l1_bus_num
op_assign
id|io_path_map_widget
c_func
(paren
id|pcibr_soft-&gt;bs_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_sys_critical_vertex
c_func
(paren
id|pss-&gt;slot_conn
)paren
)paren
(brace
id|slotp-&gt;resp_slot_status
op_or_assign
id|SLOT_IS_SYS_CRITICAL
suffix:semicolon
)brace
id|slotp-&gt;resp_bss_ninfo
op_assign
id|pss-&gt;bss_ninfo
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|pss-&gt;bss_ninfo
suffix:semicolon
id|func
op_increment
)paren
(brace
id|funcp
op_assign
op_amp
(paren
id|slotp-&gt;resp_func
(braket
id|func
)braket
)paren
suffix:semicolon
id|pcibr_slot_func_info_return
c_func
(paren
id|pss-&gt;bss_infos
comma
id|func
comma
id|funcp
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|slotp-&gt;resp_bss_devio_bssd_space
comma
l_string|&quot;%s&quot;
comma
id|pci_space_name
(braket
id|pss-&gt;bss_devio.bssd_space
)braket
)paren
suffix:semicolon
id|slotp-&gt;resp_bss_devio_bssd_base
op_assign
id|pss-&gt;bss_devio.bssd_base
suffix:semicolon
id|slotp-&gt;resp_bss_device
op_assign
id|pss-&gt;bss_device
suffix:semicolon
id|slotp-&gt;resp_bss_pmu_uctr
op_assign
id|pss-&gt;bss_pmu_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d32_uctr
op_assign
id|pss-&gt;bss_d32_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d64_uctr
op_assign
id|pss-&gt;bss_d64_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d64_base
op_assign
id|pss-&gt;bss_d64_base
suffix:semicolon
id|slotp-&gt;resp_bss_d64_flags
op_assign
id|pss-&gt;bss_d64_flags
suffix:semicolon
id|slotp-&gt;resp_bss_d32_base
op_assign
id|pss-&gt;bss_d32_base
suffix:semicolon
id|slotp-&gt;resp_bss_d32_flags
op_assign
id|pss-&gt;bss_d32_flags
suffix:semicolon
id|slotp-&gt;resp_bss_ext_ates_active
op_assign
id|pss-&gt;bss_ext_ates_active
suffix:semicolon
id|slotp-&gt;resp_bss_cmd_pointer
op_assign
id|pss-&gt;bss_cmd_pointer
suffix:semicolon
id|slotp-&gt;resp_bss_cmd_shadow
op_assign
id|pss-&gt;bss_cmd_shadow
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid_v
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_res
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_amp
l_int|1
)paren
(brace
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_odd_resp
suffix:semicolon
)brace
r_else
(brace
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_even_resp
suffix:semicolon
)brace
id|slotp-&gt;resp_b_resp
op_assign
op_star
id|b_respp
suffix:semicolon
id|slotp-&gt;resp_b_wid_control
op_assign
id|bridge-&gt;b_wid_control
suffix:semicolon
id|slotp-&gt;resp_b_int_device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|slotp-&gt;resp_b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|slotp-&gt;resp_b_int_host
op_assign
id|bridge-&gt;b_int_addr
(braket
id|slot
)braket
dot
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
id|slotp
comma
id|respp
comma
r_sizeof
(paren
op_star
id|respp
)paren
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|slotp
comma
r_sizeof
(paren
op_star
id|slotp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_query&n; *&t;Return information about the PCI slot maintained by the infrastructure.&n; *&t;Information is requested in the request structure.&n; *&n; *      Information returned in the response structure:&n; *&t;&t;Slot hwgraph name&n; *&t;&t;Vendor/Device info&n; *&t;&t;Base register info&n; *&t;&t;Interrupt mapping from device pins to the bridge pins&n; *&t;&t;Devio register&n; *&t;&t;Software RRB info&n; *&t;&t;RRB register info&n; *&t;&t;Host/Gues info&n; *&t;&t;PCI Bus #,slot #, function #&n; *&t;&t;Slot provider hwgraph name&n; *&t;&t;Provider Functions&n; *&t;&t;Error handler&n; *&t;&t;DMA mapping usage counters&n; *&t;&t;DMA direct translation info&n; *&t;&t;External SSRAM workaround info&n; */
r_int
DECL|function|pcibr_slot_query
id|pcibr_slot_query
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|reqp-&gt;req_slot
suffix:semicolon
id|pciio_slot_t
id|tmp_slot
suffix:semicolon
id|pcibr_slot_info_resp_t
id|respp
op_assign
id|reqp-&gt;req_respp.query
suffix:semicolon
r_int
id|size
op_assign
id|reqp-&gt;req_size
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
multiline_comment|/* Make sure that we have a valid PCI slot number or PCIIO_SLOT_NONE */
r_if
c_cond
(paren
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
op_logical_and
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
)paren
(brace
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
)brace
multiline_comment|/* Do not allow a query of a slot in a shoehorn */
r_if
c_cond
(paren
id|nic_vertex_info_match
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|XTALK_PCI_PART_NUM
)paren
)paren
(brace
r_return
id|PCI_SLOT_IN_SHOEHORN
suffix:semicolon
)brace
multiline_comment|/* Return information for the requested PCI slot */
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
op_star
id|respp
)paren
)paren
(brace
r_return
id|PCI_RESP_AREA_TOO_SMALL
suffix:semicolon
)brace
multiline_comment|/* Acquire read access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_ACCESS
comma
id|PZERO
)paren
suffix:semicolon
id|error
op_assign
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|respp
)paren
suffix:semicolon
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Return information for all the slots */
r_for
c_loop
(paren
id|tmp_slot
op_assign
l_int|0
suffix:semicolon
id|tmp_slot
OL
l_int|8
suffix:semicolon
id|tmp_slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
op_star
id|respp
)paren
)paren
(brace
r_return
id|PCI_RESP_AREA_TOO_SMALL
suffix:semicolon
)brace
multiline_comment|/* Acquire read access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_ACCESS
comma
id|PZERO
)paren
suffix:semicolon
id|error
op_assign
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft
comma
id|tmp_slot
comma
id|respp
)paren
suffix:semicolon
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_increment
id|respp
suffix:semicolon
id|size
op_sub_assign
r_sizeof
(paren
op_star
id|respp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif&t;/* LATER */
multiline_comment|/* FIXME: there should be a better way to do this.&n; * pcibr_attach() needs PCI_ADDR_SPACE_LIMITS_STORE&n; */
multiline_comment|/* &n; * PCI_ADDR_SPACE_LIMITS_LOAD&n; *&t;Gets the current values of &n; *&t;&t;pci io base, &n; *&t;&t;pci io last,&n; *&t;&t;pci low memory base,&n; *&t;&t;pci low memory last,&n; *&t;&t;pci high memory base,&n; * &t;&t;pci high memory last&n; */
DECL|macro|PCI_ADDR_SPACE_LIMITS_LOAD
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_LOAD()&t;&t;&t;&bslash;&n;    pci_io_fb = pcibr_soft-&gt;bs_spinfo.pci_io_base;&t;&bslash;&n;    pci_io_fl = pcibr_soft-&gt;bs_spinfo.pci_io_last;&t;&bslash;&n;    pci_lo_fb = pcibr_soft-&gt;bs_spinfo.pci_swin_base;&t;&bslash;&n;    pci_lo_fl = pcibr_soft-&gt;bs_spinfo.pci_swin_last;&t;&bslash;&n;    pci_hi_fb = pcibr_soft-&gt;bs_spinfo.pci_mem_base;&t;&bslash;&n;    pci_hi_fl = pcibr_soft-&gt;bs_spinfo.pci_mem_last;
multiline_comment|/*&n; * PCI_ADDR_SPACE_LIMITS_STORE&n; *&t;Sets the current values of&n; *&t;&t;pci io base, &n; *&t;&t;pci io last,&n; *&t;&t;pci low memory base,&n; *&t;&t;pci low memory last,&n; *&t;&t;pci high memory base,&n; * &t;&t;pci high memory last&n; */
DECL|macro|PCI_ADDR_SPACE_LIMITS_STORE
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_STORE()&t;&t;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_io_base = pci_io_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_io_last = pci_io_fl;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_swin_base = pci_lo_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_swin_last = pci_lo_fl;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_mem_base = pci_hi_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_mem_last = pci_hi_fl;
DECL|macro|PCI_ADDR_SPACE_LIMITS_PRINT
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_PRINT()&t;&t;&t;&bslash;&n;    printf(&quot;+++++++++++++++++++++++&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;IO base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;SWIN base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;MEM base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;+++++++++++++++++++++++&bslash;n&quot;,&t;&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_io_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_io_last,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_swin_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_swin_last,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_mem_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_mem_last);
multiline_comment|/*&n; * pcibr_slot_info_init&n; *&t;Probe for this slot and see if it is populated.&n; *&t;If it is populated initialize the generic PCI infrastructural&n; * &t;information associated with this particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_init
id|pcibr_slot_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|idword
suffix:semicolon
r_int
id|pfail
suffix:semicolon
r_int
id|idwords
(braket
l_int|8
)braket
suffix:semicolon
id|pciio_vendor_id_t
id|vendor
suffix:semicolon
id|pciio_device_id_t
id|device
suffix:semicolon
r_int
id|htype
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|pci_io_fb
comma
id|pci_io_fl
suffix:semicolon
id|iopaddr_t
id|pci_lo_fb
comma
id|pci_lo_fl
suffix:semicolon
id|iopaddr_t
id|pci_hi_fb
comma
id|pci_hi_fl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pciio_function_t
id|rfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|conn_vhdl
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
multiline_comment|/* Get the basic software information required to proceed */
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* If we have a host slot (eg:- IOC3 has 2 PCI slots and the initialization&n;     * is done by the host slot then we are done.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for a slot with any system critical functions */
r_if
c_cond
(paren
id|pcibr_is_slot_sys_critical
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
r_return
id|EPERM
suffix:semicolon
multiline_comment|/* Load the current values of allocated PCI address spaces */
id|PCI_ADDR_SPACE_LIMITS_LOAD
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Try to read the device-id/vendor-id from the config space */
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idword
)paren
)paren
r_return
id|ENODEV
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|slotp-&gt;slot_status
op_or_assign
id|SLOT_POWER_UP
suffix:semicolon
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idword
suffix:semicolon
multiline_comment|/* If the vendor id is not valid then the slot is not populated&n;     * and we are done.&n;     */
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
r_return
id|ENODEV
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|nfunc
op_assign
l_int|1
suffix:semicolon
id|rfunc
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|pfail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: if a card claims to be multifunction&n;     * but only responds to config space 0, treat&n;     * it as a unifunction card.&n;     */
r_if
c_cond
(paren
id|htype
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* MULTIFUNCTION */
r_for
c_loop
(paren
id|func
op_assign
l_int|1
suffix:semicolon
id|func
OL
l_int|8
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idwords
(braket
id|func
)braket
)paren
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idwords
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nfunc
op_assign
id|func
op_plus
l_int|1
suffix:semicolon
id|rfunc
op_assign
l_int|0
suffix:semicolon
)brace
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
suffix:semicolon
)brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
id|nfunc
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
r_int
id|cmd_reg
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
r_if
c_cond
(paren
id|pfail
op_amp
(paren
l_int|1
op_lshift
id|func
)paren
)paren
r_continue
suffix:semicolon
id|idword
op_assign
id|idwords
(braket
id|func
)braket
suffix:semicolon
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|rfunc
op_assign
id|func
suffix:semicolon
)brace
id|htype
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|htype
op_ne
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s pcibr: pci slot %d func %d has strange header type 0x%x&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|htype
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s pcibr: pci slot %d func %d: vendor 0x%x device 0x%x&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
macro_line|#endif&t;
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
id|conn_vhdl
op_assign
id|pciio_device_info_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|slotp-&gt;slot_conn
op_assign
id|conn_vhdl
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|cmd_reg
op_assign
id|cfgw
(braket
(paren
id|PCI_CFG_COMMAND
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
suffix:semicolon
macro_line|#else
id|cmd_reg
op_assign
id|cfgw
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
suffix:semicolon
macro_line|#endif
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
op_increment
id|win
)paren
(brace
id|iopaddr_t
id|base
comma
id|mask
comma
id|code
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * GET THE BASE &amp; SIZE OF THIS WINDOW:&n;&t;     *&n;&t;     * The low two or four bits of the BASE register&n;&t;     * determines which address space we are in; the&n;&t;     * rest is a base address. BASE registers&n;&t;     * determine windows that are power-of-two sized&n;&t;     * and naturally aligned, so we can get the size&n;&t;     * of a window by writing all-ones to the&n;&t;     * register, reading it back, and seeing which&n;&t;     * bits are used for decode; the least&n;&t;     * significant nonzero bit is also the size of&n;&t;     * the window.&n;&t;     *&n;&t;     * WARNING: someone may already have allocated&n;&t;     * some PCI space to this window, and in fact&n;&t;     * PIO may be in process at this very moment&n;&t;     * from another processor (or even from this&n;&t;     * one, if we get interrupted)! So, if the BASE&n;&t;     * already has a nonzero address, be generous&n;&t;     * and use the LSBit of that address as the&n;&t;     * size; this could overstate the window size.&n;&t;     * Usually, when one card is set up, all are set&n;&t;     * up; so, since we don&squot;t bitch about&n;&t;     * overlapping windows, we are ok.&n;&t;     *&n;&t;     * UNFORTUNATELY, some cards do not clear their&n;&t;     * BASE registers on reset. I have two heuristics&n;&t;     * that can detect such cards: first, if the&n;&t;     * decode enable is turned off for the space&n;&t;     * that the window uses, we can disregard the&n;&t;     * initial value. second, if the address is&n;&t;     * outside the range that we use, we can disregard&n;&t;     * it as well.&n;&t;     *&n;&t;     * This is looking very PCI generic. Except for&n;&t;     * knowing how many slots and where their config&n;&t;     * spaces are, this window loop and the next one&n;&t;     * could probably be shared with other PCI host&n;&t;     * adapters. It would be interesting to see if&n;&t;     * this could be pushed up into pciio, when we&n;&t;     * start supporting more PCI providers.&n;&t;     */
macro_line|#ifdef LITTLE_ENDIAN
id|base
op_assign
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
suffix:semicolon
macro_line|#else
id|base
op_assign
id|wptr
(braket
id|win
)braket
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BA_IO_SPACE
)paren
(brace
multiline_comment|/* BASE is in I/O space. */
id|space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|mask
op_assign
op_minus
l_int|4
suffix:semicolon
id|code
op_assign
id|base
op_amp
l_int|3
suffix:semicolon
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_IO_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
)brace
r_else
(brace
multiline_comment|/* BASE is in MEM space. */
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|mask
op_assign
op_minus
l_int|16
suffix:semicolon
id|code
op_assign
id|base
op_amp
id|PCI_BA_MEM_LOCATION
suffix:semicolon
multiline_comment|/* extract BAR type */
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_MEM_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
r_else
r_if
c_cond
(paren
id|base
op_amp
l_int|0xC0000000
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
r_else
r_if
c_cond
(paren
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
op_logical_and
macro_line|#ifdef LITTLE_ENDIAN
(paren
id|wptr
(braket
(paren
(paren
(paren
id|win
op_plus
l_int|1
)paren
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_ne
l_int|0
)paren
)paren
(brace
macro_line|#else 
(paren
id|wptr
(braket
id|win
op_plus
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
(brace
macro_line|#endif /* LITTLE_ENDIAN */
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|0
)paren
(brace
multiline_comment|/* estimate size */
id|size
op_assign
id|base
op_amp
op_minus
id|base
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* calculate size */
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* turn on all bits */
id|size
op_assign
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
suffix:semicolon
multiline_comment|/* get stored bits */
macro_line|#else 
id|wptr
(braket
id|win
)braket
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* turn on all bits */
id|size
op_assign
id|wptr
(braket
id|win
)braket
suffix:semicolon
multiline_comment|/* get stored bits */
macro_line|#endif /* LITTLE_ENDIAN */
id|size
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* keep addr */
id|size
op_and_assign
op_minus
id|size
suffix:semicolon
multiline_comment|/* keep lsbit */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
op_assign
id|space
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * If this window already has PCI space&n;&t;     * allocated for it, &quot;subtract&quot; that space from&n;&t;     * our running freeblocks. Don&squot;t worry about&n;&t;     * overlaps in existing allocated windows; we&n;&t;     * may be overstating their sizes anyway.&n;&t;     */
r_if
c_cond
(paren
id|base
op_logical_and
id|size
)paren
(brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
(brace
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_io_fb
comma
op_amp
id|pci_io_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_lo_fb
comma
op_amp
id|pci_lo_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_hi_fb
comma
op_amp
id|pci_hi_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
)brace
)brace
macro_line|#if defined(IOC3_VENDOR_ID_NUM) &amp;&amp; defined(IOC3_DEVICE_ID_NUM)
multiline_comment|/*&n;&t;     * IOC3 BASE_ADDR* BUG WORKAROUND&n;&t;     *&n;&t;     &n;&t;     * If we write to BASE1 on the IOC3, the&n;&t;     * data in BASE0 is replaced. The&n;&t;     * original workaround was to remember&n;&t;     * the value of BASE0 and restore it&n;&t;     * when we ran off the end of the BASE&n;&t;     * registers; however, a later&n;&t;     * workaround was added (I think it was&n;&t;     * rev 1.44) to avoid setting up&n;&t;     * anything but BASE0, with the comment&n;&t;     * that writing all ones to BASE1 set&n;&t;     * the enable-parity-error test feature&n;&t;     * in IOC3&squot;s SCR bit 14.&n;&t;     *&n;&t;     * So, unless we defer doing any PCI&n;&t;     * space allocation until drivers&n;&t;     * attach, and set up a way for drivers&n;&t;     * (the IOC3 in paricular) to tell us&n;&t;     * generically to keep our hands off&n;&t;     * BASE registers, we gotta &quot;know&quot; about&n;&t;     * the IOC3 here.&n;&t;     *&n;&t;     * Too bad the PCI folks didn&squot;t reserve the&n;&t;     * all-zero value for &squot;no BASE here&squot; (it is a&n;&t;     * valid code for an uninitialized BASE in&n;&t;     * 32-bit PCI memory space).&n;&t;     */
r_if
c_cond
(paren
(paren
id|vendor
op_eq
id|IOC3_VENDOR_ID_NUM
)paren
op_logical_and
(paren
id|device
op_eq
id|IOC3_DEVICE_ID_NUM
)paren
)paren
r_break
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
(brace
id|win
op_increment
suffix:semicolon
multiline_comment|/* skip upper half */
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* which must be zero */
macro_line|#else 
id|wptr
(braket
id|win
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* which must be zero */
macro_line|#endif /* LITTLE_ENDIAN */
)brace
)brace
multiline_comment|/* next win */
)brace
multiline_comment|/* next func */
multiline_comment|/* Store back the values for allocated PCI address spaces */
id|PCI_ADDR_SPACE_LIMITS_STORE
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_info_free&n; *&t;Remove all the PCI infrastructural information associated&n; * &t;with a particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_free
id|pcibr_slot_info_free
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_device_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|DELA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|as_debug
r_int
id|as_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * pcibr_slot_addr_space_init&n; *&t;Reserve chunks of PCI address space as required by &n; * &t;the base registers in the card.&n; */
r_int
DECL|function|pcibr_slot_addr_space_init
id|pcibr_slot_addr_space_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|iopaddr_t
id|pci_io_fb
comma
id|pci_io_fl
suffix:semicolon
id|iopaddr_t
id|pci_lo_fb
comma
id|pci_lo_fl
suffix:semicolon
id|iopaddr_t
id|pci_hi_fb
comma
id|pci_hi_fl
suffix:semicolon
r_int
id|align
suffix:semicolon
id|iopaddr_t
id|mask
suffix:semicolon
r_int
id|nbars
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Get the current values for the allocated PCI address spaces */
id|PCI_ADDR_SPACE_LIMITS_LOAD
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as_debug
)paren
macro_line|#ifdef LATER
id|PCI_ADDR_SPACE_LIMITS_PRINT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate address space,&n;     * for windows that have not been&n;     * previously assigned.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
r_if
c_cond
(paren
id|nfunc
OL
l_int|1
)paren
r_return
id|EINVAL
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;     * Try to make the DevIO windows not&n;     * overlap by pushing the &quot;io&quot; and &quot;hi&quot;&n;     * allocation areas up to the next one&n;     * or two megabyte bound. This also&n;     * keeps them from being zero.&n;     *&n;     * DO NOT do this with &quot;pci_lo&quot; since&n;     * the entire &quot;lo&quot; area is only a&n;     * megabyte, total ...&n;     */
id|align
op_assign
(paren
id|slot
OL
l_int|2
)paren
ques
c_cond
l_int|0x200000
suffix:colon
l_int|0x100000
suffix:semicolon
id|mask
op_assign
op_minus
id|align
suffix:semicolon
id|pci_io_fb
op_assign
(paren
id|pci_io_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
id|pci_hi_fb
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfg_p
id|cfgw
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
id|cfg_p
id|pci_cfg_cmd_reg_p
suffix:semicolon
r_int
id|pci_cfg_cmd_reg
suffix:semicolon
r_int
id|pci_cfg_cmd_reg_add
op_assign
l_int|0
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
id|nbars
op_assign
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|nbars
suffix:semicolon
op_increment
id|win
)paren
(brace
id|space
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
suffix:semicolon
id|base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d is in %d[0x%x..0x%x], alloc by prom&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|space
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
multiline_comment|/* already allocated */
)brace
id|align
op_assign
id|size
suffix:semicolon
multiline_comment|/* ie. 0x00001000 */
r_if
c_cond
(paren
id|align
OL
id|_PAGESZ
)paren
id|align
op_assign
id|_PAGESZ
suffix:semicolon
multiline_comment|/* ie. 0x00004000 */
id|mask
op_assign
op_minus
id|align
suffix:semicolon
multiline_comment|/* ie. 0xFFFFC000 */
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|base
op_assign
(paren
id|pci_io_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_io_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_io_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
macro_line|#ifdef LITTLE_ENDIAN
r_if
c_cond
(paren
(paren
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
macro_line|#else
r_if
c_cond
(paren
(paren
id|wptr
(braket
id|win
)braket
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
macro_line|#endif  /* LITTLE_ENDIAN */
id|PCI_BA_MEM_1MEG
)paren
(brace
multiline_comment|/* allocate from 20-bit PCI space */
id|base
op_assign
(paren
id|pci_lo_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_lo_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_lo_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate from 32-bit or 64-bit PCI space */
id|base
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_hi_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_hi_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|base
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d window %d had bad space code %d&bslash;n&quot;
comma
id|slot
comma
id|win
comma
id|space
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
id|base
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;Setting base address 0x%p base 0x%x&bslash;n&quot;
comma
op_amp
(paren
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
)paren
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|wptr
(braket
id|win
)braket
op_assign
id|base
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d is in %d [0x%x..0x%x], alloc by pcibr&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|space
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d, unable to alloc 0x%x in 0x%p&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|size
comma
id|space
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* next base */
multiline_comment|/*&n;&t; * Allocate space for the EXPANSION ROM&n;&t; * NOTE: DO NOT DO THIS ON AN IOC3,&n;&t; * as it blows the system away.&n;&t; */
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_vendor_id
op_ne
id|IOC3_VENDOR_ID_NUM
)paren
op_logical_or
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device_id
op_ne
id|IOC3_DEVICE_ID_NUM
)paren
)paren
(brace
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_EXPANSION_ROM
op_div
l_int|4
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
l_int|1
)braket
op_assign
l_int|0xFFFFF000
suffix:semicolon
id|mask
op_assign
id|wptr
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#else
op_star
id|wptr
op_assign
l_int|0xFFFFF000
suffix:semicolon
id|mask
op_assign
op_star
id|wptr
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0xFFFFF000
)paren
(brace
id|size
op_assign
id|mask
op_amp
op_minus
id|mask
suffix:semicolon
id|align
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|align
OL
id|_PAGESZ
)paren
id|align
op_assign
id|_PAGESZ
suffix:semicolon
id|mask
op_assign
op_minus
id|align
suffix:semicolon
id|base
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_hi_fl
)paren
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|pci_hi_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
l_int|1
)braket
op_assign
id|base
suffix:semicolon
macro_line|#else
op_star
id|wptr
op_assign
id|base
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s/%d ROM in 0x%lx..0x%lx (alloc by pcibr)&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
id|pcibr_info-&gt;f_rbase
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_rsize
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * if necessary, update the board&squot;s&n;&t; * command register to enable decoding&n;&t; * in the windows we added.&n;&t; *&n;&t; * There are some bits we always want to&n;&t; * be sure are set.&n;&t; */
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_IO_SPACE
suffix:semicolon
multiline_comment|/*&n;&t; * The Adaptec 1160 FC Controller WAR #767995:&n;&t; * The part incorrectly ignores the upper 32 bits of a 64 bit&n;&t; * address when decoding references to it&squot;s registers so to&n;&t; * keep it from responding to a bus cycle that it shouldn&squot;t&n;&t; * we only use I/O space to get at it&squot;s registers.  Don&squot;t&n;&t; * enable memory space accesses on that PCI device.&n;&t; */
DECL|macro|FCADP_VENDID
mdefine_line|#define FCADP_VENDID 0x9004 /* Adaptec Vendor ID from fcadp.h */
DECL|macro|FCADP_DEVID
mdefine_line|#define FCADP_DEVID 0x1160  /* Adaptec 1160 Device ID from fcadp.h */
r_if
c_cond
(paren
(paren
id|pcibr_info-&gt;f_vendor
op_ne
id|FCADP_VENDID
)paren
op_logical_or
(paren
id|pcibr_info-&gt;f_device
op_ne
id|FCADP_DEVID
)paren
)paren
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_MEM_SPACE
suffix:semicolon
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_BUS_MASTER
suffix:semicolon
id|pci_cfg_cmd_reg_p
op_assign
id|cfgw
op_plus
id|PCI_CFG_COMMAND
op_div
l_int|4
suffix:semicolon
id|pci_cfg_cmd_reg
op_assign
op_star
id|pci_cfg_cmd_reg_p
suffix:semicolon
macro_line|#if PCI_FBBE&t;/* XXX- check here to see if dev can do fast-back-to-back */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|pci_cfg_cmd_reg
op_rshift
l_int|16
)paren
op_amp
id|PCI_STAT_F_BK_BK_CAP
)paren
)paren
id|fast_back_to_back_enable
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|pci_cfg_cmd_reg
op_and_assign
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|pci_cfg_cmd_reg_add
op_amp
op_complement
id|pci_cfg_cmd_reg
)paren
op_star
id|pci_cfg_cmd_reg_p
op_assign
id|pci_cfg_cmd_reg
op_or
id|pci_cfg_cmd_reg_add
suffix:semicolon
)brace
multiline_comment|/* next func */
multiline_comment|/* Now that we have allocated new chunks of PCI address spaces to this&n;     * card we need to update the bookkeeping values which indicate&n;     * the current PCI address space allocations.&n;     */
id|PCI_ADDR_SPACE_LIMITS_STORE
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_device_init&n; * &t;Setup the device register in the bridge for this PCI slot.&n; */
r_int
DECL|function|pcibr_slot_device_init
id|pcibr_slot_device_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/*&n;     * Adjustments to Device(x)&n;     * and init of bss_device shadow&n;     */
id|devreg
op_assign
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_PAGE_CHK_DIS
suffix:semicolon
id|devreg
op_or_assign
id|BRIDGE_DEV_COH
op_or
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): 0x%lx&bslash;n&quot;
comma
id|slot
comma
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: PCI space allocation done.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_guest_info_init&n; *&t;Setup the host/guest relations for a PCI slot.&n; */
r_int
DECL|function|pcibr_slot_guest_info_init
id|pcibr_slot_guest_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* create info and verticies for guest slots;&n;     * for compatibilitiy macros, create info&n;     * for even unpopulated slots (but do not&n;     * build verticies for them).&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OL
l_int|1
)paren
(brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
l_int|1
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slotp-&gt;slot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* generate host/guest relations&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_int
id|host
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_soft_slot_t
id|host_slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|host
)braket
suffix:semicolon
id|hwgraph_edge_add
c_func
(paren
id|slotp-&gt;slot_conn
comma
id|host_slotp-&gt;slot_conn
comma
id|EDGE_LBL_HOST
)paren
suffix:semicolon
multiline_comment|/* XXX- only gives us one guest edge per&n;&t; * host. If/when we have a host with more than&n;&t; * one guest, we will need to figure out how&n;&t; * the host finds all its guests, and sorts&n;&t; * out which one is which.&n;&t; */
id|hwgraph_edge_add
c_func
(paren
id|host_slotp-&gt;slot_conn
comma
id|slotp-&gt;slot_conn
comma
id|EDGE_LBL_GUEST
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_attach&n; *&t;This calls the associated driver attach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_attach
id|pcibr_slot_call_device_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|async_attach_t
id|aa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
comma
id|conn_vhdl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
id|EPERM
suffix:semicolon
)brace
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|aa
op_assign
id|async_attach_get_info
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
macro_line|#ifdef LATER
multiline_comment|/*&n;&t; * Activate if and when we support cdl.&n;&t; */
r_if
c_cond
(paren
id|aa
)paren
id|async_attach_add_info
c_func
(paren
id|conn_vhdl
comma
id|aa
)paren
suffix:semicolon
macro_line|#endif&t;/* LATER */
id|error_func
op_assign
id|pciio_device_attach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
)paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_INCMPLT
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_CMPLT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_detach&n; *&t;This calls the associated driver detach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_detach
id|pcibr_slot_call_device_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|conn_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
id|EPERM
suffix:semicolon
multiline_comment|/* Make sure that we do not detach a system critical function vertex */
r_if
c_cond
(paren
id|pcibr_is_slot_sys_critical
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
(brace
r_return
id|EPERM
suffix:semicolon
)brace
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
id|error_func
op_assign
id|pciio_device_detach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
)paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_INCMPLT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|conn_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
id|pcibr_device_unregister
c_func
(paren
id|conn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_CMPLT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef LATER
multiline_comment|/*&n; * pcibr_slot_attach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific initialization that needs to be done.&n; *&t;This is usually called when we want to initialize a new&n; * &t;PCI card on the bus.&n; */
r_int
DECL|function|pcibr_slot_attach
id|pcibr_slot_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|timespec_t
id|ts
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_POWER_UP
)paren
)paren
(brace
multiline_comment|/* Power-up the slot */
id|error
op_assign
id|pcibr_slot_pwr
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|L1_REQ_PCI_UP
comma
id|l1_msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_L1_ERR
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_POWER_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_POWER_UP
suffix:semicolon
)brace
macro_line|#ifdef LATER
multiline_comment|/*&n;         * Allow cards like the Alteon Gigabit Ethernet Adapter to complete&n;         * on-card initialization following the slot reset&n;         */
id|ts.tv_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 secs */
id|ts.tv_nsec
op_assign
l_int|500
op_star
(paren
l_int|1000
op_star
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 500 msecs */
id|nano_delay
c_func
(paren
op_amp
id|ts
)paren
suffix:semicolon
macro_line|#else
macro_line|#endif
macro_line|#if 0
multiline_comment|/* Reset the slot */
id|error
op_assign
id|pcibr_slot_reset
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_RESET_ERR
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Find out what is out there */
id|error
op_assign
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_INFO_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Set up the address space for this slot in the PCI land */
id|error
op_assign
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_ADDR_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Setup the device register */
id|error
op_assign
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_DEV_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Setup host/guest relations */
id|error
op_assign
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_GUEST_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Initial RRB management */
id|error
op_assign
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_RRB_ALLOC_ERR
suffix:semicolon
)brace
)brace
multiline_comment|/* Call the device attach */
id|error
op_assign
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EUNATCH
)paren
r_return
id|PCI_NO_DRIVER
suffix:semicolon
r_else
r_return
id|PCI_SLOT_DRV_ATTACH_ERR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* LATER */
multiline_comment|/*&n; * pcibr_slot_detach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific freeing that needs to be done.&n; */
r_int
DECL|function|pcibr_slot_detach
id|pcibr_slot_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* Call the device detach function */
id|error
op_assign
(paren
id|pcibr_slot_call_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_is_slot_sys_critical&n; *      Check slot for any functions that are system critical.&n; *      Return 1 if any are system critical or 0 otherwise.&n; *&n; *      This function will always return 0 when called by &n; *      pcibr_attach() because the system critical vertices &n; *      have not yet been set in the hwgraph.&n; */
r_int
DECL|function|pcibr_is_slot_sys_critical
id|pcibr_is_slot_sys_critical
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|devfs_handle_t
id|conn_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
id|boolean_t
id|is_sys_critical_vertex
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
r_if
c_cond
(paren
id|is_sys_critical_vertex
c_func
(paren
id|conn_vhdl
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%v is a system critical device vertex&bslash;n&quot;
comma
id|conn_vhdl
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%p is a system critical device vertex&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|conn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_probe_slot: read a config space word&n; * while trapping any errors; reutrn zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
r_int
DECL|function|pcibr_probe_slot
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|cfg_p
id|cfg
comma
r_int
op_star
id|valp
)paren
(brace
r_int
id|rv
suffix:semicolon
id|bridgereg_t
id|old_enable
comma
id|new_enable
suffix:semicolon
r_int
id|badaddr_val
c_func
(paren
r_volatile
r_void
op_star
comma
r_int
comma
r_volatile
r_void
op_star
)paren
suffix:semicolon
id|old_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|new_enable
op_assign
id|old_enable
op_amp
op_complement
id|BRIDGE_IMR_PCI_MST_TIMEOUT
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|new_enable
suffix:semicolon
multiline_comment|/*&n;&t; * The xbridge doesn&squot;t clear b_err_int_view unless&n;&t; * multi-err is cleared...&n;&t; */
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_if
c_cond
(paren
id|bridge-&gt;b_err_int_view
op_amp
id|BRIDGE_ISR_PCI_MST_TIMEOUT
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bridge-&gt;b_int_status
op_amp
id|BRIDGE_IRR_PCI_GRP
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_PCI_GRP_CLR
suffix:semicolon
(paren
r_void
)paren
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* flushbus */
)brace
id|rv
op_assign
id|badaddr_val
c_func
(paren
(paren
r_void
op_star
)paren
id|cfg
comma
l_int|4
comma
id|valp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The xbridge doesn&squot;t set master timeout in b_int_status&n;&t; * here.  Fortunately it&squot;s in error_interrupt_view.&n;&t; */
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_if
c_cond
(paren
id|bridge-&gt;b_err_int_view
op_amp
id|BRIDGE_ISR_PCI_MST_TIMEOUT
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
id|rv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unoccupied slot */
)brace
id|bridge-&gt;b_int_enable
op_assign
id|old_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
r_return
id|rv
suffix:semicolon
)brace
r_void
DECL|function|pcibr_device_info_free
id|pcibr_device_info_free
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
r_int
id|nfunc
op_assign
id|slotp-&gt;bss_ninfo
suffix:semicolon
r_int
id|bar
suffix:semicolon
r_int
id|devio_index
suffix:semicolon
r_int
id|s
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info
op_assign
id|slotp-&gt;bss_infos
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
id|bar
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_space
op_eq
id|PCIIO_SPACE_NONE
)paren
r_continue
suffix:semicolon
multiline_comment|/* Get index of the DevIO(x) register used to access this BAR */
id|devio_index
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_devio_index
suffix:semicolon
multiline_comment|/* On last use, clear the DevIO(x) used to access this BAR */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_ref_cnt
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_device
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|slotp-&gt;bss_infos
(braket
id|func
)braket
op_assign
l_int|0
suffix:semicolon
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|pciio_device_info_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the mapping usage counters */
id|slotp-&gt;bss_pmu_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d64_uctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the Direct translation info */
id|slotp-&gt;bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear out shadow info necessary for the external SSRAM workaround */
id|slotp-&gt;bss_ext_ates_active
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|slotp-&gt;bss_cmd_pointer
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_cmd_shadow
op_assign
l_int|0
suffix:semicolon
)brace
eof
