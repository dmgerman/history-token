multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
suffix:semicolon
r_static
r_int
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
comma
id|cfg_p
comma
r_int
r_int
op_star
)paren
suffix:semicolon
r_void
id|pcibr_device_info_free
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_win_info_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pciibr_bus_addr_free
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_win_info_t
)paren
suffix:semicolon
id|cfg_p
id|pcibr_find_capability
c_func
(paren
id|cfg_p
comma
r_int
)paren
suffix:semicolon
r_extern
r_uint64
id|do_pcibr_config_get
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_config_set
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
r_int
id|pcibr_slot_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pcibr_slot_info_resp_t
id|respp
)paren
suffix:semicolon
r_extern
id|vertex_hdl_t
id|baseio_pci_vhdl
suffix:semicolon
r_int
id|scsi_ctlr_nums_add
c_func
(paren
id|vertex_hdl_t
comma
id|vertex_hdl_t
)paren
suffix:semicolon
multiline_comment|/* For now .... */
multiline_comment|/*&n; * PCI Hot-Plug Capability Flags&n;&n; */
DECL|macro|D_PCI_HOT_PLUG_ATTACH
mdefine_line|#define D_PCI_HOT_PLUG_ATTACH  0x200  /* Driver supports PCI hot-plug attach */
DECL|macro|D_PCI_HOT_PLUG_DETACH
mdefine_line|#define D_PCI_HOT_PLUG_DETACH  0x400  /* Driver supports PCI hot-plug detach */
multiline_comment|/* &n; * PCI-X Max Outstanding Split Transactions translation array and Max Memory&n; * Read Byte Count translation array, as defined in the PCI-X Specification.&n; * Section 7.2.3 &amp; 7.2.4 of PCI-X Specification - rev 1.0&n; */
DECL|macro|MAX_SPLIT_TABLE
mdefine_line|#define MAX_SPLIT_TABLE 8
DECL|macro|MAX_READCNT_TABLE
mdefine_line|#define MAX_READCNT_TABLE 4
DECL|variable|max_splittrans_to_numbuf
r_int
id|max_splittrans_to_numbuf
(braket
id|MAX_SPLIT_TABLE
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|8
comma
l_int|12
comma
l_int|16
comma
l_int|32
)brace
suffix:semicolon
DECL|variable|max_readcount_to_bufsize
r_int
id|max_readcount_to_bufsize
(braket
id|MAX_READCNT_TABLE
)braket
op_assign
(brace
l_int|512
comma
l_int|1024
comma
l_int|2048
comma
l_int|4096
)brace
suffix:semicolon
multiline_comment|/*==========================================================================&n; *&t;BRIDGE PCI SLOT RELATED IOCTLs&n; */
multiline_comment|/*&n; * pcibr_slot_startup&n; *&t;Software start-up the PCI slot.&n; */
macro_line|#ifdef PIC_LATER
r_int
DECL|function|pcibr_slot_startup
id|pcibr_slot_startup
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|l1_msg
(braket
id|BRL1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|pcibr_slot_up_resp_s
id|tmp_up_resp
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
multiline_comment|/* req_slot is the &squot;external&squot; slot number, convert for internal use */
id|slot
op_assign
id|PCIBR_SLOT_TO_DEVICE
c_func
(paren
id|pcibr_soft
comma
id|reqp-&gt;req_slot
)paren
suffix:semicolon
multiline_comment|/* Check for the valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
macro_line|#ifdef PIC_LATER
multiline_comment|/* Acquire update access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_UPDATE
comma
id|PZERO
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_STARTUP_CMPLT
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_UP
suffix:semicolon
r_goto
id|startup_unlock
suffix:semicolon
)brace
id|error
op_assign
id|pcibr_slot_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|D_PCI_HOT_PLUG_ATTACH
comma
id|l1_msg
comma
op_amp
id|tmp_up_resp.resp_sub_errno
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|tmp_up_resp.resp_l1_msg
comma
id|l1_msg
comma
id|L1_QSIZE
)paren
suffix:semicolon
id|tmp_up_resp.resp_l1_msg
(braket
id|L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
op_amp
id|tmp_up_resp
comma
id|reqp-&gt;req_respp.up
comma
id|reqp-&gt;req_size
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|startup_unlock
suffix:colon
macro_line|#ifdef PIC_LATER
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
macro_line|#endif
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_shutdown&n; *&t;Software shut-down the PCI slot&n; */
r_int
DECL|function|pcibr_slot_shutdown
id|pcibr_slot_shutdown
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|l1_msg
(braket
id|BRL1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|pcibr_slot_down_resp_s
id|tmp_down_resp
suffix:semicolon
id|pciio_slot_t
id|tmp_slot
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
multiline_comment|/* req_slot is the &squot;external&squot; slot number, convert for internal use */
id|slot
op_assign
id|PCIBR_SLOT_TO_DEVICE
c_func
(paren
id|pcibr_soft
comma
id|reqp-&gt;req_slot
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Check for valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
macro_line|#ifdef PIC_LATER
multiline_comment|/* Acquire update access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_UPDATE
comma
id|PZERO
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_SHUTDOWN_CMPLT
)paren
op_logical_or
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|SLOT_STATUS_MASK
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_DOWN
suffix:semicolon
multiline_comment|/*&n;         * RJR - Should we invoke an L1 slot power-down command just in case&n;         *       a previous shut-down failed to power-down the slot?&n;         */
r_goto
id|shutdown_unlock
suffix:semicolon
)brace
multiline_comment|/* Do not allow a multi-function card to be hot-plug removed */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OG
l_int|1
)paren
(brace
id|tmp_down_resp.resp_sub_errno
op_assign
id|EPERM
suffix:semicolon
id|error
op_assign
id|PCI_MULTI_FUNC_ERR
suffix:semicolon
r_goto
id|shutdown_copyout
suffix:semicolon
)brace
multiline_comment|/* Do not allow the last 33 MHz card to be removed */
r_if
c_cond
(paren
(paren
id|bridge-&gt;b_wid_control
op_amp
id|BRIDGE_CTRL_BUS_SPEED_MASK
)paren
op_eq
id|BRIDGE_CTRL_BUS_SPEED_33
)paren
(brace
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_first_slot
suffix:semicolon
id|tmp_slot
op_le
id|pcibr_soft-&gt;bs_last_slot
suffix:semicolon
id|tmp_slot
op_increment
)paren
r_if
c_cond
(paren
id|tmp_slot
op_ne
id|slot
)paren
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|tmp_slot
)braket
dot
id|slot_status
op_amp
id|SLOT_POWER_UP
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|PCI_EMPTY_33MHZ
suffix:semicolon
r_goto
id|shutdown_unlock
suffix:semicolon
)brace
)brace
id|error
op_assign
id|pcibr_slot_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|D_PCI_HOT_PLUG_DETACH
comma
id|l1_msg
comma
op_amp
id|tmp_down_resp.resp_sub_errno
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|tmp_down_resp.resp_l1_msg
comma
id|l1_msg
comma
id|L1_QSIZE
)paren
suffix:semicolon
id|tmp_down_resp.resp_l1_msg
(braket
id|L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|shutdown_copyout
suffix:colon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
op_amp
id|tmp_down_resp
comma
id|reqp-&gt;req_respp.down
comma
id|reqp-&gt;req_size
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|shutdown_unlock
suffix:colon
macro_line|#ifdef PIC_LATER
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
macro_line|#endif
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif&t;/* PIC_LATER */
DECL|variable|pci_space_name
r_char
op_star
id|pci_space_name
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ROM&quot;
comma
l_string|&quot;IO&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;MEM&quot;
comma
l_string|&quot;MEM32&quot;
comma
l_string|&quot;MEM64&quot;
comma
l_string|&quot;CFG&quot;
comma
l_string|&quot;WIN0&quot;
comma
l_string|&quot;WIN1&quot;
comma
l_string|&quot;WIN2&quot;
comma
l_string|&quot;WIN3&quot;
comma
l_string|&quot;WIN4&quot;
comma
l_string|&quot;WIN5&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;BAD&quot;
)brace
suffix:semicolon
r_void
DECL|function|pcibr_slot_func_info_return
id|pcibr_slot_func_info_return
c_func
(paren
id|pcibr_info_h
id|pcibr_infoh
comma
r_int
id|func
comma
id|pcibr_slot_func_info_resp_t
id|funcp
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_int
id|win
suffix:semicolon
id|funcp-&gt;resp_f_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
(brace
r_return
suffix:semicolon
)brace
id|funcp-&gt;resp_f_status
op_or_assign
id|FUNC_IS_VALID
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_slot_name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_vertex
)paren
suffix:semicolon
macro_line|#endif
id|funcp-&gt;resp_f_bus
op_assign
id|pcibr_info-&gt;f_bus
suffix:semicolon
id|funcp-&gt;resp_f_slot
op_assign
id|PCIBR_INFO_SLOT_GET_EXT
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
id|funcp-&gt;resp_f_func
op_assign
id|pcibr_info-&gt;f_func
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_master_name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_master
)paren
suffix:semicolon
macro_line|#endif
id|funcp-&gt;resp_f_pops
op_assign
id|pcibr_info-&gt;f_pops
suffix:semicolon
id|funcp-&gt;resp_f_efunc
op_assign
id|pcibr_info-&gt;f_efunc
suffix:semicolon
id|funcp-&gt;resp_f_einfo
op_assign
id|pcibr_info-&gt;f_einfo
suffix:semicolon
id|funcp-&gt;resp_f_vendor
op_assign
id|pcibr_info-&gt;f_vendor
suffix:semicolon
id|funcp-&gt;resp_f_device
op_assign
id|pcibr_info-&gt;f_device
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|6
suffix:semicolon
id|win
op_increment
)paren
(brace
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
id|sprintf
c_func
(paren
id|funcp-&gt;resp_f_window
(braket
id|win
)braket
dot
id|resp_w_space
comma
l_string|&quot;%s&quot;
comma
id|pci_space_name
(braket
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
)braket
)paren
suffix:semicolon
)brace
id|funcp-&gt;resp_f_rbase
op_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
id|funcp-&gt;resp_f_rsize
op_assign
id|pcibr_info-&gt;f_rsize
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|4
suffix:semicolon
id|win
op_increment
)paren
(brace
id|funcp-&gt;resp_f_ibit
(braket
id|win
)braket
op_assign
id|pcibr_info-&gt;f_ibit
(braket
id|win
)braket
suffix:semicolon
)brace
id|funcp-&gt;resp_f_att_det_error
op_assign
id|pcibr_info-&gt;f_att_det_error
suffix:semicolon
)brace
r_int
DECL|function|pcibr_slot_info_return
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pcibr_slot_info_resp_t
id|respp
)paren
(brace
id|pcibr_soft_slot_t
id|pss
suffix:semicolon
r_int
id|func
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|reg_p
id|b_respp
suffix:semicolon
id|pcibr_slot_info_resp_t
id|slotp
suffix:semicolon
id|pcibr_slot_func_info_resp_t
id|funcp
suffix:semicolon
r_extern
r_void
id|snia_kmem_free
c_func
(paren
r_void
op_star
comma
r_int
)paren
suffix:semicolon
id|slotp
op_assign
id|snia_kmem_zalloc
c_func
(paren
r_sizeof
(paren
op_star
id|slotp
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slotp
op_eq
l_int|NULL
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|pss
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_bridge_mode
op_assign
id|pcibr_soft-&gt;bs_bridge_mode
suffix:semicolon
id|slotp-&gt;resp_bs_bridge_type
op_assign
id|pcibr_soft-&gt;bs_bridge_type
suffix:semicolon
id|slotp-&gt;resp_has_host
op_assign
id|pss-&gt;has_host
suffix:semicolon
id|slotp-&gt;resp_host_slot
op_assign
id|pss-&gt;host_slot
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|sprintf
c_func
(paren
id|slotp-&gt;resp_slot_conn_name
comma
l_string|&quot;%v&quot;
comma
id|pss-&gt;slot_conn
)paren
suffix:semicolon
macro_line|#else
id|sprintf
c_func
(paren
id|slotp-&gt;resp_slot_conn_name
comma
l_string|&quot;%p&quot;
comma
(paren
r_void
op_star
)paren
id|pss-&gt;slot_conn
)paren
suffix:semicolon
macro_line|#endif
id|slotp-&gt;resp_slot_status
op_assign
id|pss-&gt;slot_status
suffix:semicolon
id|slotp-&gt;resp_l1_bus_num
op_assign
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_soft-&gt;bs_vhdl
)paren
suffix:semicolon
id|slotp-&gt;resp_bss_ninfo
op_assign
id|pss-&gt;bss_ninfo
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|pss-&gt;bss_ninfo
suffix:semicolon
id|func
op_increment
)paren
(brace
id|funcp
op_assign
op_amp
(paren
id|slotp-&gt;resp_func
(braket
id|func
)braket
)paren
suffix:semicolon
id|pcibr_slot_func_info_return
c_func
(paren
id|pss-&gt;bss_infos
comma
id|func
comma
id|funcp
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|slotp-&gt;resp_bss_devio_bssd_space
comma
l_string|&quot;%s&quot;
comma
id|pci_space_name
(braket
id|pss-&gt;bss_devio.bssd_space
)braket
)paren
suffix:semicolon
id|slotp-&gt;resp_bss_devio_bssd_base
op_assign
id|pss-&gt;bss_devio.bssd_base
suffix:semicolon
id|slotp-&gt;resp_bss_device
op_assign
id|pss-&gt;bss_device
suffix:semicolon
id|slotp-&gt;resp_bss_pmu_uctr
op_assign
id|pss-&gt;bss_pmu_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d32_uctr
op_assign
id|pss-&gt;bss_d32_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d64_uctr
op_assign
id|pss-&gt;bss_d64_uctr
suffix:semicolon
id|slotp-&gt;resp_bss_d64_base
op_assign
id|pss-&gt;bss_d64_base
suffix:semicolon
id|slotp-&gt;resp_bss_d64_flags
op_assign
id|pss-&gt;bss_d64_flags
suffix:semicolon
id|slotp-&gt;resp_bss_d32_base
op_assign
id|pss-&gt;bss_d32_base
suffix:semicolon
id|slotp-&gt;resp_bss_d32_flags
op_assign
id|pss-&gt;bss_d32_flags
suffix:semicolon
id|slotp-&gt;resp_bss_ext_ates_active
op_assign
id|pss-&gt;bss_ext_ates_active
suffix:semicolon
id|slotp-&gt;resp_bss_cmd_pointer
op_assign
id|pss-&gt;bss_cmd_pointer
suffix:semicolon
id|slotp-&gt;resp_bss_cmd_shadow
op_assign
id|pss-&gt;bss_cmd_shadow
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid_v1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN1
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid_v2
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN2
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_valid_v3
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
(braket
id|VCHAN3
)braket
suffix:semicolon
id|slotp-&gt;resp_bs_rrb_res
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_amp
l_int|1
)paren
(brace
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_odd_resp
suffix:semicolon
)brace
r_else
(brace
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_even_resp
suffix:semicolon
)brace
id|slotp-&gt;resp_b_resp
op_assign
op_star
id|b_respp
suffix:semicolon
id|slotp-&gt;resp_b_int_device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|slotp-&gt;resp_p_int_enable
op_assign
id|bridge-&gt;p_int_enable_64
suffix:semicolon
id|slotp-&gt;resp_p_int_host
op_assign
id|bridge-&gt;p_int_addr_64
(braket
id|slot
)braket
suffix:semicolon
)brace
r_else
(brace
id|slotp-&gt;resp_b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|slotp-&gt;resp_b_int_host
op_assign
id|bridge-&gt;b_int_addr
(braket
id|slot
)braket
dot
id|addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
id|slotp
comma
id|respp
comma
r_sizeof
(paren
op_star
id|respp
)paren
)paren
)paren
(brace
r_return
id|EFAULT
suffix:semicolon
)brace
id|snia_kmem_free
c_func
(paren
id|slotp
comma
r_sizeof
(paren
op_star
id|slotp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_query&n; *&t;Return information about the PCI slot maintained by the infrastructure.&n; *&t;Information is requested in the request structure.&n; *&n; *      Information returned in the response structure:&n; *&t;&t;Slot hwgraph name&n; *&t;&t;Vendor/Device info&n; *&t;&t;Base register info&n; *&t;&t;Interrupt mapping from device pins to the bridge pins&n; *&t;&t;Devio register&n; *&t;&t;Software RRB info&n; *&t;&t;RRB register info&n; *&t;&t;Host/Gues info&n; *&t;&t;PCI Bus #,slot #, function #&n; *&t;&t;Slot provider hwgraph name&n; *&t;&t;Provider Functions&n; *&t;&t;Error handler&n; *&t;&t;DMA mapping usage counters&n; *&t;&t;DMA direct translation info&n; *&t;&t;External SSRAM workaround info&n; */
r_int
DECL|function|pcibr_slot_query
id|pcibr_slot_query
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pcibr_slot_req_t
id|reqp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pciio_slot_t
id|tmp_slot
suffix:semicolon
id|pcibr_slot_info_resp_t
id|respp
op_assign
id|reqp-&gt;req_respp.query
suffix:semicolon
r_int
id|size
op_assign
id|reqp-&gt;req_size
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
multiline_comment|/* req_slot is the &squot;external&squot; slot number, convert for internal use */
id|slot
op_assign
id|PCIBR_SLOT_TO_DEVICE
c_func
(paren
id|pcibr_soft
comma
id|reqp-&gt;req_slot
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_HOTPLUG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_query: pcibr_soft=0x%x, slot=%d, reqp=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|slot
comma
id|reqp
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure that we have a valid PCI slot number or PCIIO_SLOT_NONE */
r_if
c_cond
(paren
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
op_logical_and
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
)paren
(brace
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
)brace
multiline_comment|/* Return information for the requested PCI slot */
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
op_star
id|respp
)paren
)paren
(brace
r_return
id|PCI_RESP_AREA_TOO_SMALL
suffix:semicolon
)brace
macro_line|#ifdef PIC_LATER
multiline_comment|/* Acquire read access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_ACCESS
comma
id|PZERO
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|respp
)paren
suffix:semicolon
macro_line|#ifdef PIC_LATER
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
macro_line|#endif
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Return information for all the slots */
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|tmp_slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|tmp_slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
op_star
id|respp
)paren
)paren
(brace
r_return
id|PCI_RESP_AREA_TOO_SMALL
suffix:semicolon
)brace
macro_line|#ifdef PIC_LATER
multiline_comment|/* Acquire read access to the bus */
id|mrlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
comma
id|MR_ACCESS
comma
id|PZERO
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|pcibr_slot_info_return
c_func
(paren
id|pcibr_soft
comma
id|tmp_slot
comma
id|respp
)paren
suffix:semicolon
macro_line|#ifdef PCI_LATER
multiline_comment|/* Release the bus lock */
id|mrunlock
c_func
(paren
id|pcibr_soft-&gt;bs_bus_lock
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_increment
id|respp
suffix:semicolon
id|size
op_sub_assign
r_sizeof
(paren
op_star
id|respp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|macro|PROBE_LOCK
mdefine_line|#define PROBE_LOCK 0&t;/* FIXME: we&squot;re attempting to lock around accesses&n;&t;&t;&t; * to b_int_enable.   This hangs pcibr_probe_slot()&n;&t;&t;&t; */
multiline_comment|/*&n; * pcibr_slot_info_init&n; *&t;Probe for this slot and see if it is populated.&n; *&t;If it is populated initialize the generic PCI infrastructural&n; * &t;information associated with this particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_init
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|idword
suffix:semicolon
r_int
id|pfail
suffix:semicolon
r_int
id|idwords
(braket
l_int|8
)braket
suffix:semicolon
id|pciio_vendor_id_t
id|vendor
suffix:semicolon
id|pciio_device_id_t
id|device
suffix:semicolon
r_int
id|htype
suffix:semicolon
r_int
id|lt_time
suffix:semicolon
r_int
id|nbars
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|cfg_p
id|pcix_cap
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pciio_function_t
id|rfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|conn_vhdl
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
multiline_comment|/* Get the basic software information required to proceed */
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* If we have a host slot (eg:- IOC3 has 2 PCI slots and the initialization&n;     * is done by the host slot then we are done.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to read the device-id/vendor-id from the config space */
id|cfgw
op_assign
id|pcibr_slot_config_addr
c_func
(paren
id|bridge
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if PROBE_LOCK
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idword
)paren
)paren
r_return
id|ENODEV
suffix:semicolon
macro_line|#if PROBE_LOCK
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#endif
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|slotp-&gt;slot_status
op_or_assign
id|SLOT_POWER_UP
suffix:semicolon
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idword
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PROBE
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: slot=%d, vendor=0x%x, device=0x%x&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|vendor
comma
id|device
)paren
)paren
suffix:semicolon
multiline_comment|/* If the vendor id is not valid then the slot is not populated&n;     * and we are done.&n;     */
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
r_return
id|ENODEV
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|nfunc
op_assign
l_int|1
suffix:semicolon
id|rfunc
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|pfail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: if a card claims to be multifunction&n;     * but only responds to config space 0, treat&n;     * it as a unifunction card.&n;     */
r_if
c_cond
(paren
id|htype
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* MULTIFUNCTION */
r_for
c_loop
(paren
id|func
op_assign
l_int|1
suffix:semicolon
id|func
OL
l_int|8
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|bridge
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if PROBE_LOCK
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idwords
(braket
id|func
)braket
)paren
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if PROBE_LOCK
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#endif
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idwords
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nfunc
op_assign
id|func
op_plus
l_int|1
suffix:semicolon
id|rfunc
op_assign
l_int|0
suffix:semicolon
)brace
id|cfgw
op_assign
id|pcibr_slot_config_addr
c_func
(paren
id|bridge
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
)brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
id|nfunc
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
r_int
id|cmd_reg
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
r_if
c_cond
(paren
id|pfail
op_amp
(paren
l_int|1
op_lshift
id|func
)paren
)paren
r_continue
suffix:semicolon
id|idword
op_assign
id|idwords
(braket
id|func
)braket
suffix:semicolon
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|bridge
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|rfunc
op_assign
id|func
suffix:semicolon
)brace
id|htype
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|htype
op_ne
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s pcibr: pci slot %d func %d has strange header type 0x%x&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|htype
)paren
suffix:semicolon
id|nbars
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|nbars
op_assign
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: slot=%d, func=%d, cfgw=0x%x&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|cfgw
)paren
)paren
suffix:semicolon
macro_line|#ifdef PIC_LATER
multiline_comment|/*&n;         * Check for a Quad ATM PCI &quot;card&quot; and return all the PCI bus&n;         * memory and I/O space.  This will work-around an apparent&n;         * hardware problem with the Quad ATM XIO card handling large&n;         * PIO addresses.  Releasing all the space for use by the card&n;         * will lower the PIO addresses with the PCI bus address space.&n;         * This is OK since the PROM did not assign any BAR addresses. &n;         *&n;         * Only release all the PCI bus addresses once.&n;         *&n;         */
r_if
c_cond
(paren
(paren
id|vendor
op_eq
id|LINC_VENDOR_ID_NUM
)paren
op_logical_and
(paren
id|device
op_eq
id|LINC_DEVICE_ID_NUM
)paren
)paren
(brace
id|iopaddr_t
id|prom_base_addr
op_assign
id|pcibr_soft-&gt;bs_xid
op_lshift
l_int|24
suffix:semicolon
r_int
id|prom_base_size
op_assign
l_int|0x1000000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_bus_addr_status
op_amp
id|PCIBR_BUS_ADDR_MEM_FREED
)paren
)paren
(brace
id|pciio_device_win_populate
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_mem_win_map
comma
id|prom_base_addr
comma
id|prom_base_size
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_bus_addr_status
op_or_assign
id|PCIBR_BUS_ADDR_MEM_FREED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_bus_addr_status
op_amp
id|PCIBR_BUS_ADDR_IO_FREED
)paren
)paren
(brace
id|pciio_device_win_populate
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_io_win_map
comma
id|prom_base_addr
comma
id|prom_base_size
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_bus_addr_status
op_or_assign
id|PCIBR_BUS_ADDR_IO_FREED
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* PIC_LATER */
multiline_comment|/* &n;&t; * If the latency timer has already been set, by prom or by the&n;&t; * card itself, use that value.  Otherwise look at the device&squot;s&n;&t; * &squot;min_gnt&squot; and attempt to calculate a latency time. &n;&t; *&n;&t; * NOTE: For now if the device is on the &squot;real time&squot; arbitration&n;&t; * ring we don&squot;t set the latency timer.  &n;&t; *&n;&t; * WAR: SGI&squot;s IOC3 and RAD devices target abort if you write a &n;&t; * single byte into their config space.  So don&squot;t set the Latency&n;&t; * Timer for these devices&n;&t; */
id|lt_time
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_LATENCY_TIMER
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lt_time
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_amp
id|BRIDGE_DEV_RT
)paren
op_logical_and
(paren
id|device
op_eq
l_int|0x5
multiline_comment|/* RAD_DEV */
)paren
)paren
(brace
r_int
id|min_gnt
suffix:semicolon
r_int
id|min_gnt_mult
suffix:semicolon
multiline_comment|/* &squot;min_gnt&squot; indicates how long of a burst period a device&n;&t;     * needs in increments of 250ns.  But latency timer is in&n;&t;     * PCI clock cycles, so a conversion is needed.&n;&t;     */
id|min_gnt
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_MIN_GNT
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_133MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 250ns @ 133MHz in clocks */
r_else
r_if
c_cond
(paren
id|IS_100MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|24
suffix:semicolon
multiline_comment|/* 250ns @ 100MHz in clocks */
r_else
r_if
c_cond
(paren
id|IS_66MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* 250ns @ 66MHz, in clocks */
r_else
id|min_gnt_mult
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 250ns @ 33MHz, in clocks */
r_if
c_cond
(paren
(paren
id|min_gnt
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|min_gnt
op_star
id|min_gnt_mult
)paren
OL
l_int|256
)paren
)paren
id|lt_time
op_assign
(paren
id|min_gnt
op_star
id|min_gnt_mult
)paren
suffix:semicolon
r_else
id|lt_time
op_assign
l_int|4
op_star
id|min_gnt_mult
suffix:semicolon
multiline_comment|/* 1 micro second */
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_LATENCY_TIMER
comma
l_int|1
comma
id|lt_time
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: set Latency Timer for slot=%d, &quot;
l_string|&quot;func=%d, to 0x%x&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|lt_time
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* In our architecture the setting of the cacheline size isn&squot;t &n;&t; * beneficial for cards in PCI mode, but in PCI-X mode devices&n;&t; * can optionally use the cacheline size value for internal &n;&t; * device optimizations    (See 7.1.5 of the PCI-X v1.0 spec).&n;&t; * NOTE: cachline size is in doubleword increments&n;&t; */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_CACHE_LINE
comma
l_int|1
)paren
)paren
(brace
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_CACHE_LINE
comma
l_int|1
comma
l_int|0x20
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: set CacheLine for slot=%d, &quot;
l_string|&quot;func=%d, to 0x20&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the PCI-X capability if running in PCI-X mode.  If the func&n;&t;     * doesnt have a pcix capability, allocate a PCIIO_VENDOR_ID_NONE&n;&t;     * pcibr_info struct so the device driver for that function is not&n;&t;     * called.&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcix_cap
op_assign
id|pcibr_find_capability
c_func
(paren
id|cfgw
comma
id|PCI_CAP_PCIX
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
l_string|&quot;%v: Bus running in PCI-X mode, But card in slot %d, &quot;
l_string|&quot;func %d not PCI-X capable&bslash;n&quot;
comma
id|pcibr_vhdl
comma
id|slot
comma
id|func
)paren
suffix:semicolon
macro_line|#else
l_string|&quot;0x%lx: Bus running in PCI-X mode, But card in slot %d, &quot;
l_string|&quot;func %d not PCI-X capable&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pcibr_vhdl
comma
id|slot
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: PCI-X capability at 0x%x for &quot;
l_string|&quot;slot=%d, func=%d&bslash;n&quot;
comma
id|pcix_cap
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcix_cap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
multiline_comment|/* Keep a running total of the number of PIC-X functions on the bus&n;         * and the number of max outstanding split trasnactions that they&n;&t; * have requested.  NOTE: &quot;pcix_cap != NULL&quot; implies IS_PCIX()&n;&t; */
id|pcibr_info-&gt;f_pcix_cap
op_assign
(paren
id|cap_pcix_type0_t
op_star
)paren
id|pcix_cap
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_pcix_cap
)paren
(brace
r_int
id|max_out
suffix:semicolon
multiline_comment|/* max outstanding splittrans from status reg */
id|pcibr_soft-&gt;bs_pcix_num_funcs
op_increment
suffix:semicolon
id|max_out
op_assign
id|pcibr_info-&gt;f_pcix_cap-&gt;pcix_type0_status.max_out_split
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_split_tot
op_add_assign
id|max_splittrans_to_numbuf
(braket
id|max_out
)braket
suffix:semicolon
)brace
id|conn_vhdl
op_assign
id|pciio_device_info_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|slotp-&gt;slot_conn
op_assign
id|conn_vhdl
suffix:semicolon
id|cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|nbars
suffix:semicolon
op_increment
id|win
)paren
(brace
id|iopaddr_t
id|base
comma
id|mask
comma
id|code
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * GET THE BASE &amp; SIZE OF THIS WINDOW:&n;&t;     *&n;&t;     * The low two or four bits of the BASE register&n;&t;     * determines which address space we are in; the&n;&t;     * rest is a base address. BASE registers&n;&t;     * determine windows that are power-of-two sized&n;&t;     * and naturally aligned, so we can get the size&n;&t;     * of a window by writing all-ones to the&n;&t;     * register, reading it back, and seeing which&n;&t;     * bits are used for decode; the least&n;&t;     * significant nonzero bit is also the size of&n;&t;     * the window.&n;&t;     *&n;&t;     * WARNING: someone may already have allocated&n;&t;     * some PCI space to this window, and in fact&n;&t;     * PIO may be in process at this very moment&n;&t;     * from another processor (or even from this&n;&t;     * one, if we get interrupted)! So, if the BASE&n;&t;     * already has a nonzero address, be generous&n;&t;     * and use the LSBit of that address as the&n;&t;     * size; this could overstate the window size.&n;&t;     * Usually, when one card is set up, all are set&n;&t;     * up; so, since we don&squot;t bitch about&n;&t;     * overlapping windows, we are ok.&n;&t;     *&n;&t;     * UNFORTUNATELY, some cards do not clear their&n;&t;     * BASE registers on reset. I have two heuristics&n;&t;     * that can detect such cards: first, if the&n;&t;     * decode enable is turned off for the space&n;&t;     * that the window uses, we can disregard the&n;&t;     * initial value. second, if the address is&n;&t;     * outside the range that we use, we can disregard&n;&t;     * it as well.&n;&t;     *&n;&t;     * This is looking very PCI generic. Except for&n;&t;     * knowing how many slots and where their config&n;&t;     * spaces are, this window loop and the next one&n;&t;     * could probably be shared with other PCI host&n;&t;     * adapters. It would be interesting to see if&n;&t;     * this could be pushed up into pciio, when we&n;&t;     * start supporting more PCI providers.&n;&t;     */
id|base
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BA_IO_SPACE
)paren
(brace
multiline_comment|/* BASE is in I/O space. */
id|space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|mask
op_assign
op_minus
l_int|4
suffix:semicolon
id|code
op_assign
id|base
op_amp
l_int|3
suffix:semicolon
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_IO_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
)brace
r_else
(brace
multiline_comment|/* BASE is in MEM space. */
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|mask
op_assign
op_minus
l_int|16
suffix:semicolon
id|code
op_assign
id|base
op_amp
id|PCI_BA_MEM_LOCATION
suffix:semicolon
multiline_comment|/* extract BAR type */
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_MEM_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
r_else
r_if
c_cond
(paren
id|base
op_amp
l_int|0xC0000000
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
r_else
r_if
c_cond
(paren
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
op_logical_and
(paren
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
(paren
id|win
op_plus
l_int|1
)paren
op_star
l_int|4
)paren
comma
l_int|4
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|0
)paren
(brace
multiline_comment|/* estimate size */
id|size
op_assign
id|base
op_amp
op_minus
id|base
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* calculate size */
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
op_complement
l_int|0
)paren
suffix:semicolon
multiline_comment|/* write 1&squot;s */
id|size
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* read back */
id|size
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* keep addr */
id|size
op_and_assign
op_minus
id|size
suffix:semicolon
multiline_comment|/* keep lsbit */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
op_assign
id|space
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
(brace
id|win
op_increment
suffix:semicolon
multiline_comment|/* skip upper half */
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* must be zero */
)brace
)brace
multiline_comment|/* next win */
)brace
multiline_comment|/* next func */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_find_capability&n; *&t;Walk the list of capabilities (if it exists) looking for&n; *&t;the requested capability.  Return a cfg_p pointer to the&n; *&t;capability if found, else return NULL&n; */
id|cfg_p
DECL|function|pcibr_find_capability
id|pcibr_find_capability
c_func
(paren
id|cfg_p
id|cfgw
comma
r_int
id|capability
)paren
(brace
r_int
id|cap_nxt
suffix:semicolon
r_int
id|cap_id
suffix:semicolon
r_int
id|defend_against_circular_linkedlist
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check to see if there is a capabilities pointer in the cfg header */
r_if
c_cond
(paren
op_logical_neg
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_STATUS
comma
l_int|2
)paren
op_amp
id|PCI_STAT_CAP_LIST
)paren
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Read up the capabilities head pointer from the configuration header.&n;     * Capabilities are stored as a linked list in the lower 48 dwords of&n;     * config space and are dword aligned. (Note: spec states the least two&n;     * significant bits of the next pointer must be ignored,  so we mask&n;     * with 0xfc).&n;     */
id|cap_nxt
op_assign
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CAPABILITIES_PTR
comma
l_int|1
)paren
op_amp
l_int|0xfc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cap_nxt
op_logical_and
(paren
id|defend_against_circular_linkedlist
op_le
l_int|48
)paren
)paren
(brace
id|cap_id
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|cap_nxt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cap_id
op_eq
id|capability
)paren
(brace
r_return
(paren
(paren
id|cfg_p
)paren
(paren
(paren
r_char
op_star
)paren
id|cfgw
op_plus
id|cap_nxt
)paren
)paren
suffix:semicolon
)brace
id|cap_nxt
op_assign
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|cap_nxt
op_plus
l_int|1
comma
l_int|1
)paren
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|defend_against_circular_linkedlist
op_increment
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_info_free&n; *&t;Remove all the PCI infrastructural information associated&n; * &t;with a particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_free
id|pcibr_slot_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_device_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|DELA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_pcix_rbar_init&n; *&t;Allocate RBARs to the PCI-X functions on a given device&n; */
r_int
DECL|function|pcibr_slot_pcix_rbar_init
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_char
id|tmp_str
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
)paren
OL
l_int|1
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;pcibr_slot_pcix_rbar_init for slot %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;&bslash;tslot/func&bslash;trequested&bslash;tgiven&bslash;tinuse&bslash;tavail&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cap_pcix_type0_t
op_star
id|pcix_cap_p
suffix:semicolon
id|cap_pcix_stat_reg_t
op_star
id|pcix_statreg_p
suffix:semicolon
id|cap_pcix_cmd_reg_t
op_star
id|pcix_cmdreg_p
suffix:semicolon
r_int
id|num_rbar
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcix_cap_p
op_assign
id|pcibr_info-&gt;f_pcix_cap
)paren
)paren
r_continue
suffix:semicolon
id|pcix_statreg_p
op_assign
op_amp
id|pcix_cap_p-&gt;pcix_type0_status
suffix:semicolon
id|pcix_cmdreg_p
op_assign
op_amp
id|pcix_cap_p-&gt;pcix_type0_command
suffix:semicolon
multiline_comment|/* If there are enough RBARs to satify the number of &quot;max outstanding &n;&t; * transactions&quot; each function requested (bs_pcix_rbar_percent_allowed&n;&t; * is 100%), then give each function what it requested, otherwise give &n;&t; * the functions a &quot;percentage of what they requested&quot;.&n;&t; */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_ge
l_int|100
)paren
(brace
id|pcix_cmdreg_p-&gt;max_split
op_assign
id|pcix_statreg_p-&gt;max_out_split
suffix:semicolon
id|num_rbar
op_assign
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_add_assign
id|num_rbar
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_sub_assign
id|num_rbar
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_mem_read_cnt
op_assign
id|pcix_statreg_p-&gt;max_mem_read_cnt
suffix:semicolon
)brace
r_else
(brace
r_int
id|index
suffix:semicolon
multiline_comment|/* index into max_splittrans_to_numbuf table */
r_int
id|max_out
suffix:semicolon
multiline_comment|/* max outstanding transactions given to func */
multiline_comment|/* Calculate the percentage of RBARs this function can have.&n;&t;     * NOTE: Every function gets at least 1 RBAR (thus the &quot;+1&quot;).&n;&t;     * bs_pcix_rbar_percent_allowed is the percentage of what was&n;&t;     * requested less this 1 RBAR that all functions automatically &n;&t;     * gets&n;&t;     */
id|max_out
op_assign
(paren
(paren
id|max_splittrans_to_numbuf
(braket
id|pcix_statreg_p-&gt;max_out_split
)braket
op_star
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
)paren
op_div
l_int|100
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round down the newly caclulated max_out to a valid number in&n;&t;     * max_splittrans_to_numbuf[]&n;&t;     */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_SPLIT_TABLE
op_minus
l_int|1
suffix:semicolon
id|index
op_increment
)paren
r_if
c_cond
(paren
id|max_splittrans_to_numbuf
(braket
id|index
op_plus
l_int|1
)braket
OG
id|max_out
)paren
r_break
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_split
op_assign
id|index
suffix:semicolon
id|num_rbar
op_assign
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_add_assign
id|num_rbar
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_sub_assign
id|num_rbar
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_mem_read_cnt
op_assign
id|pcix_statreg_p-&gt;max_mem_read_cnt
suffix:semicolon
)brace
multiline_comment|/*&n;         * The kernel only allows functions to have so many variable args,&n;         * attempting to call PCIBR_DEBUG_ALWAYS() with more than 5 printf&n;         * arguments fails so sprintf() it into a temporary string.&n;         */
r_if
c_cond
(paren
id|pcibr_debug_mask
op_amp
id|PCIBR_DEBUG_RBAR
)paren
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;&bslash;t  %d/%d   &bslash;t    %d    &bslash;t  %d  &bslash;t  %d  &bslash;t  %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|max_splittrans_to_numbuf
(braket
id|pcix_statreg_p-&gt;max_out_split
)braket
comma
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
comma
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
comma
id|pcibr_soft-&gt;bs_pcix_rbar_avail
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;%s&quot;
comma
id|tmp_str
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|as_debug
r_int
id|as_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * pcibr_slot_addr_space_init&n; *&t;Reserve chunks of PCI address space as required by &n; * &t;the base registers in the card.&n; */
r_int
DECL|function|pcibr_slot_addr_space_init
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|iopaddr_t
id|mask
suffix:semicolon
r_int
id|nbars
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_int
id|win
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|align
suffix:semicolon
r_int
id|align_slot
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* allocate address space,&n;     * for windows that have not been&n;     * previously assigned.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
r_if
c_cond
(paren
id|nfunc
OL
l_int|1
)paren
r_return
id|EINVAL
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;     * Try to make the DevIO windows not&n;     * overlap by pushing the &quot;io&quot; and &quot;hi&quot;&n;     * allocation areas up to the next one&n;     * or two megabyte bound. This also&n;     * keeps them from being zero.&n;     *&n;     * DO NOT do this with &quot;pci_lo&quot; since&n;     * the entire &quot;lo&quot; area is only a&n;     * megabyte, total ...&n;     */
id|align_slot
op_assign
l_int|0x100000
suffix:semicolon
id|align
op_assign
id|align_slot
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfg_p
id|cfgw
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
macro_line|#ifdef PCI_LATER
r_char
id|tmp_str
(braket
l_int|256
)braket
suffix:semicolon
macro_line|#endif
r_int
id|pci_cfg_cmd_reg
suffix:semicolon
r_int
id|pci_cfg_cmd_reg_add
op_assign
l_int|0
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|bridge
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_int|0
)paren
id|nbars
op_assign
l_int|2
suffix:semicolon
r_else
id|nbars
op_assign
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|nbars
suffix:semicolon
op_increment
id|win
)paren
(brace
id|space
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
suffix:semicolon
id|base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
multiline_comment|/*&n;         &t; * The kernel only allows functions to have so many variable&n;                 * args attempting to call PCIBR_DEBUG_ALWAYS() with more than&n;         &t; * 5 printf arguments fails so sprintf() it into a temporary &n;&t;&t; * string (tmp_str).&n;         &t; */
macro_line|#if defined(SUPPORT_PRINTING_R_FORMAT)
r_if
c_cond
(paren
id|pcibr_debug_mask
op_amp
id|PCIBR_DEBUG_BAR
)paren
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, &quot;
l_string|&quot;func=%d win %d is in %r [0x%x..0x%x], allocated by &quot;
l_string|&quot;prom&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|space
comma
id|space_desc
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;%s&quot;
comma
id|tmp_str
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SUPPORT_PRINTING_R_FORMAT */
r_continue
suffix:semicolon
multiline_comment|/* already allocated */
)brace
id|align
op_assign
(paren
id|win
)paren
ques
c_cond
id|size
suffix:colon
id|align_slot
suffix:semicolon
r_if
c_cond
(paren
id|align
OL
id|_PAGESZ
)paren
id|align
op_assign
id|_PAGESZ
suffix:semicolon
multiline_comment|/* ie. 0x00004000 */
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_IO
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
r_if
c_cond
(paren
(paren
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
id|PCI_BA_MEM_1MEG
)paren
(brace
multiline_comment|/* allocate from 20-bit PCI space */
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_MEM
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate from 32-bit or 64-bit PCI space */
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_MEM32
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|base
op_assign
l_int|0
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, window %d &quot;
l_string|&quot;had bad space code %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|win
comma
id|space
)paren
)paren
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
id|base
)paren
suffix:semicolon
macro_line|#if defined(SUPPORT_PRINTING_R_FORMAT)
r_if
c_cond
(paren
id|pcibr_debug_mask
op_amp
id|PCIBR_DEBUG_BAR
)paren
(brace
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=&quot;
l_string|&quot;%d, win %d is in %r[0x%x..0x%x], &quot;
l_string|&quot;allocated by pcibr&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|space
comma
id|space_desc
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;%s&quot;
comma
id|tmp_str
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|tmp_str
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=&quot;
l_string|&quot;%d, win %d, unable to alloc 0x%x in %r&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|size
comma
id|space
comma
id|space_desc
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;%s&quot;
comma
id|tmp_str
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SUPPORT_PRINTING_R_FORMAT */
)brace
multiline_comment|/* next base */
multiline_comment|/*&n;&t; * Allocate space for the EXPANSION ROM&n;&t; */
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
(brace
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_EXPANSION_ROM
op_div
l_int|4
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
comma
l_int|0xFFFFF000
)paren
suffix:semicolon
id|mask
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
l_int|0xFFFFF000
)paren
(brace
id|size
op_assign
id|mask
op_amp
op_minus
id|mask
suffix:semicolon
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_rwindow
comma
id|PCIIO_SPACE_MEM32
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
r_else
(brace
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
comma
id|base
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=%d, &quot;
l_string|&quot;ROM in [0x%X..0x%X], allocated by pcibr&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|pcibr_info-&gt;f_rbase
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_rsize
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * if necessary, update the board&squot;s&n;&t; * command register to enable decoding&n;&t; * in the windows we added.&n;&t; *&n;&t; * There are some bits we always want to&n;&t; * be sure are set.&n;&t; */
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_IO_SPACE
suffix:semicolon
multiline_comment|/*&n;&t; * The Adaptec 1160 FC Controller WAR #767995:&n;&t; * The part incorrectly ignores the upper 32 bits of a 64 bit&n;&t; * address when decoding references to its registers so to&n;&t; * keep it from responding to a bus cycle that it shouldn&squot;t&n;&t; * we only use I/O space to get at it&squot;s registers.  Don&squot;t&n;&t; * enable memory space accesses on that PCI device.&n;&t; */
DECL|macro|FCADP_VENDID
mdefine_line|#define FCADP_VENDID 0x9004 /* Adaptec Vendor ID from fcadp.h */
DECL|macro|FCADP_DEVID
mdefine_line|#define FCADP_DEVID 0x1160  /* Adaptec 1160 Device ID from fcadp.h */
r_if
c_cond
(paren
(paren
id|pcibr_info-&gt;f_vendor
op_ne
id|FCADP_VENDID
)paren
op_logical_or
(paren
id|pcibr_info-&gt;f_device
op_ne
id|FCADP_DEVID
)paren
)paren
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_MEM_SPACE
suffix:semicolon
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_BUS_MASTER
suffix:semicolon
id|pci_cfg_cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
macro_line|#if PCI_FBBE&t;/* XXX- check here to see if dev can do fast-back-to-back */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|pci_cfg_cmd_reg
op_rshift
l_int|16
)paren
op_amp
id|PCI_STAT_F_BK_BK_CAP
)paren
)paren
id|fast_back_to_back_enable
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|pci_cfg_cmd_reg
op_and_assign
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|pci_cfg_cmd_reg_add
op_amp
op_complement
id|pci_cfg_cmd_reg
)paren
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
comma
id|pci_cfg_cmd_reg
op_or
id|pci_cfg_cmd_reg_add
)paren
suffix:semicolon
)brace
multiline_comment|/* next func */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_device_init&n; * &t;Setup the device register in the bridge for this PCI slot.&n; */
r_int
DECL|function|pcibr_slot_device_init
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/*&n;     * Adjustments to Device(x)&n;     * and init of bss_device shadow&n;     */
id|devreg
op_assign
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_PAGE_CHK_DIS
suffix:semicolon
multiline_comment|/*&n;     * PIC WAR. PV# 855271&n;     * Don&squot;t enable virtual channels in the PIC by default.&n;     * Can cause problems with 32-bit devices. (The bit is only intended&n;     * for 64-bit devices).  We set the bit in pcibr_try_set_device()&n;     * if we&squot;re 64-bit and requesting virtual channels.&n;     */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV855271
comma
id|pcibr_soft
)paren
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_COH
suffix:semicolon
r_else
id|devreg
op_or_assign
id|BRIDGE_DEV_COH
op_or
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
macro_line|#ifdef PIC_LATER
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_device_init: Device(%d): %R&bslash;n&quot;
comma
id|slot
comma
id|devreg
comma
id|device_bits
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_guest_info_init&n; *&t;Setup the host/guest relations for a PCI slot.&n; */
r_int
DECL|function|pcibr_slot_guest_info_init
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* create info and verticies for guest slots;&n;     * for compatibilitiy macros, create info&n;     * for even unpopulated slots (but do not&n;     * build verticies for them).&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OL
l_int|1
)paren
(brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
l_int|1
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slotp-&gt;slot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* generate host/guest relations&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_int
id|host
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_soft_slot_t
id|host_slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|host
)braket
suffix:semicolon
id|hwgraph_edge_add
c_func
(paren
id|slotp-&gt;slot_conn
comma
id|host_slotp-&gt;slot_conn
comma
id|EDGE_LBL_HOST
)paren
suffix:semicolon
multiline_comment|/* XXX- only gives us one guest edge per&n;&t; * host. If/when we have a host with more than&n;&t; * one guest, we will need to figure out how&n;&t; * the host finds all its guests, and sorts&n;&t; * out which one is which.&n;&t; */
id|hwgraph_edge_add
c_func
(paren
id|host_slotp-&gt;slot_conn
comma
id|slotp-&gt;slot_conn
comma
id|EDGE_LBL_GUEST
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_attach&n; *&t;This calls the associated driver attach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_attach
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
comma
id|conn_vhdl
suffix:semicolon
macro_line|#ifdef PIC_LATER
id|vertex_hdl_t
id|scsi_vhdl
suffix:semicolon
macro_line|#endif
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
macro_line|#ifdef PIC_LATER
r_int
id|hwg_err
suffix:semicolon
macro_line|#endif
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
id|EPERM
suffix:semicolon
)brace
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
id|error_func
op_assign
id|pciio_device_attach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
macro_line|#ifdef PIC_LATER
multiline_comment|/*&n;         * Try to assign well-known SCSI controller numbers for hot-plug&n;         * insert&n;         */
r_if
c_cond
(paren
id|drv_flags
)paren
(brace
id|hwg_err
op_assign
id|hwgraph_path_lookup
c_func
(paren
id|conn_vhdl
comma
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
op_amp
id|scsi_vhdl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwg_err
op_eq
id|GRAPH_SUCCESS
)paren
id|scsi_ctlr_nums_add
c_func
(paren
id|baseio_pci_vhdl
comma
id|scsi_vhdl
)paren
suffix:semicolon
multiline_comment|/* scsi_vhdl will be the final vertex in either the complete path&n;             * on success or a partial path on failure;  in either case,&n;             * unreference that vertex.&n;             */
id|hwgraph_vertex_unref
c_func
(paren
id|scsi_vhdl
)paren
suffix:semicolon
id|hwg_err
op_assign
id|hwgraph_path_lookup
c_func
(paren
id|conn_vhdl
comma
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/1&quot;
comma
op_amp
id|scsi_vhdl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwg_err
op_eq
id|GRAPH_SUCCESS
)paren
id|scsi_ctlr_nums_add
c_func
(paren
id|baseio_pci_vhdl
comma
id|scsi_vhdl
)paren
suffix:semicolon
multiline_comment|/* scsi_vhdl will be the final vertex in either the complete path&n;             * on success or a partial path on failure;  in either case,&n;             * unreference that vertex.&n;             */
id|hwgraph_vertex_unref
c_func
(paren
id|scsi_vhdl
)paren
suffix:semicolon
)brace
macro_line|#endif /* PIC_LATER */
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
op_logical_and
(paren
id|error
op_ne
id|EPERM
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_INCMPLT
suffix:semicolon
)brace
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_CMPLT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_detach&n; *&t;This calls the associated driver detach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_detach
id|pcibr_slot_call_device_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|conn_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
id|EPERM
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
id|pcibr_info-&gt;f_pcix_cap
)paren
(brace
r_int
id|max_out
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_num_funcs
op_decrement
suffix:semicolon
id|max_out
op_assign
id|pcibr_info-&gt;f_pcix_cap-&gt;pcix_type0_status.max_out_split
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_split_tot
op_sub_assign
id|max_splittrans_to_numbuf
(braket
id|max_out
)braket
suffix:semicolon
)brace
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
id|error_func
op_assign
id|pciio_device_detach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
op_logical_and
(paren
id|error
op_ne
id|EPERM
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_INCMPLT
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|conn_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
id|pcibr_device_unregister
c_func
(paren
id|conn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_CMPLT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_attach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific initialization that needs to be done.&n; *&t;This is usually called when we want to initialize a new&n; * &t;PCI card on the bus.&n; */
r_int
DECL|function|pcibr_slot_attach
id|pcibr_slot_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
macro_line|#ifdef PIC_LATER
id|timespec_t
id|ts
suffix:semicolon
macro_line|#endif
r_int
id|error
suffix:semicolon
multiline_comment|/* Do not allow a multi-function card to be hot-plug inserted */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|EPERM
suffix:semicolon
r_return
id|PCI_MULTI_FUNC_ERR
suffix:semicolon
)brace
multiline_comment|/* Call the device attach */
id|error
op_assign
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EUNATCH
)paren
r_return
id|PCI_NO_DRIVER
suffix:semicolon
r_else
r_return
id|PCI_SLOT_DRV_ATTACH_ERR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_detach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific freeing that needs to be done.&n; */
r_int
DECL|function|pcibr_slot_detach
id|pcibr_slot_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Call the device detach function */
id|error
op_assign
(paren
id|pcibr_slot_call_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_DRV_DETACH_ERR
suffix:semicolon
)brace
multiline_comment|/* Recalculate the RBARs for all the devices on the bus since we&squot;ve&n;     * just freed some up and some of the devices could use them.&n;     */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_int
id|tmp_slot
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_assign
id|NUM_RBAR
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_assign
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|tmp_slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|tmp_slot
)paren
(paren
r_void
)paren
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|tmp_slot
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_probe_slot_pic: read a config space word&n; * while trapping any errors; return zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
r_static
r_int
DECL|function|pcibr_probe_slot_pic
id|pcibr_probe_slot_pic
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|cfg_p
id|cfg
comma
r_int
op_star
id|valp
)paren
(brace
r_int
id|rv
suffix:semicolon
id|picreg_t
id|p_old_enable
op_assign
(paren
id|picreg_t
)paren
l_int|0
comma
id|p_new_enable
suffix:semicolon
r_extern
r_int
id|badaddr_val
c_func
(paren
r_volatile
r_void
op_star
comma
r_int
comma
r_volatile
r_void
op_star
)paren
suffix:semicolon
id|p_old_enable
op_assign
id|bridge-&gt;p_int_enable_64
suffix:semicolon
id|p_new_enable
op_assign
id|p_old_enable
op_amp
op_complement
(paren
id|BRIDGE_IMR_PCI_MST_TIMEOUT
op_or
id|PIC_ISR_PCIX_MTOUT
)paren
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_assign
id|p_new_enable
suffix:semicolon
r_if
c_cond
(paren
id|bridge-&gt;p_err_int_view_64
op_amp
(paren
id|BRIDGE_ISR_PCI_MST_TIMEOUT
op_or
id|PIC_ISR_PCIX_MTOUT
)paren
)paren
id|bridge-&gt;p_int_rst_stat_64
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
r_if
c_cond
(paren
id|bridge-&gt;p_int_status_64
op_amp
(paren
id|BRIDGE_IRR_PCI_GRP
op_or
id|PIC_PCIX_GRP_CLR
)paren
)paren
(brace
id|bridge-&gt;p_int_rst_stat_64
op_assign
(paren
id|BRIDGE_IRR_PCI_GRP_CLR
op_or
id|PIC_PCIX_GRP_CLR
)paren
suffix:semicolon
(paren
r_void
)paren
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* flushbus */
)brace
id|rv
op_assign
id|badaddr_val
c_func
(paren
(paren
r_void
op_star
)paren
id|cfg
comma
l_int|4
comma
id|valp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bridge-&gt;p_err_int_view_64
op_amp
(paren
id|BRIDGE_ISR_PCI_MST_TIMEOUT
op_or
id|PIC_ISR_PCIX_MTOUT
)paren
)paren
(brace
id|bridge-&gt;p_int_rst_stat_64
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
id|rv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unoccupied slot */
)brace
id|bridge-&gt;p_int_enable_64
op_assign
id|p_old_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_probe_slot: read a config space word&n; * while trapping any errors; return zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
r_static
r_int
DECL|function|pcibr_probe_slot
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|cfg_p
id|cfg
comma
r_int
op_star
id|valp
)paren
(brace
r_return
id|pcibr_probe_slot_pic
c_func
(paren
id|bridge
comma
id|cfg
comma
id|valp
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_device_info_free
id|pcibr_device_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|nfunc
op_assign
id|slotp-&gt;bss_ninfo
suffix:semicolon
r_int
id|bar
suffix:semicolon
r_int
id|devio_index
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|cmd_reg
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info
op_assign
id|slotp-&gt;bss_infos
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Disable memory and I/O BARs */
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|bridge
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
id|cmd_reg
op_and_assign
(paren
id|PCI_CMD_MEM_SPACE
op_or
id|PCI_CMD_IO_SPACE
)paren
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
comma
id|cmd_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
id|bar
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_space
op_eq
id|PCIIO_SPACE_NONE
)paren
r_continue
suffix:semicolon
multiline_comment|/* Free the PCI bus space */
id|pciibr_bus_addr_free
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
)paren
suffix:semicolon
multiline_comment|/* Get index of the DevIO(x) register used to access this BAR */
id|devio_index
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_devio_index
suffix:semicolon
multiline_comment|/* On last use, clear the DevIO(x) used to access this BAR */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_ref_cnt
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_device
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Free the Expansion ROM PCI bus space */
r_if
c_cond
(paren
id|pcibr_info-&gt;f_rbase
op_logical_and
id|pcibr_info-&gt;f_rsize
)paren
(brace
id|pciibr_bus_addr_free
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_rwindow
)paren
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|slotp-&gt;bss_infos
(braket
id|func
)braket
op_assign
l_int|0
suffix:semicolon
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|pciio_device_info_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the mapping usage counters */
id|slotp-&gt;bss_pmu_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d64_uctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the Direct translation info */
id|slotp-&gt;bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear out shadow info necessary for the external SSRAM workaround */
id|slotp-&gt;bss_ext_ates_active
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|slotp-&gt;bss_cmd_pointer
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_cmd_shadow
op_assign
l_int|0
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pcibr_bus_addr_alloc
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_win_info_t
id|win_info_p
comma
id|pciio_space_t
id|space
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|align
)paren
(brace
id|pciio_win_map_t
id|win_map_p
suffix:semicolon
r_struct
id|resource
op_star
id|root_resource
op_assign
l_int|NULL
suffix:semicolon
id|iopaddr_t
id|iopaddr
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_io_win_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_io_win_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_swin_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_swin_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_mem_win_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_mem_win_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|iopaddr
op_assign
id|pciio_device_win_alloc
c_func
(paren
id|root_resource
comma
id|win_info_p
ques
c_cond
op_amp
id|win_info_p-&gt;w_win_alloc
suffix:colon
l_int|NULL
comma
id|start
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_return
id|iopaddr
suffix:semicolon
)brace
r_void
DECL|function|pciibr_bus_addr_free
id|pciibr_bus_addr_free
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_win_info_t
id|win_info_p
)paren
(brace
id|pciio_device_win_free
c_func
(paren
op_amp
id|win_info_p-&gt;w_win_alloc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * given a vertex_hdl to the pcibr_vhdl, return the brick&squot;s bus number&n; * associated with that vertex_hdl.  The true mapping happens from the&n; * io_brick_tab[] array defined in ml/SN/iograph.c&n; */
r_int
DECL|function|pcibr_widget_to_bus
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|pcibr_soft-&gt;bs_xid
suffix:semicolon
r_int
id|bricktype
op_assign
id|pcibr_soft-&gt;bs_bricktype
suffix:semicolon
r_int
id|bus
op_assign
id|pcibr_soft-&gt;bs_busnum
suffix:semicolon
multiline_comment|/* &n;     * For PIC there are 2 busses per widget and pcibr_soft-&gt;bs_busnum&n;     * will be 0 or 1.  For [X]BRIDGE there is 1 bus per widget and &n;     * pcibr_soft-&gt;bs_busnum will always be zero.  So we add bs_busnum&n;     * to what io_brick_map_widget returns to get the bus number.&n;     */
r_if
c_cond
(paren
(paren
id|bus
op_add_assign
id|io_brick_map_widget
c_func
(paren
id|bricktype
comma
id|widget
)paren
)paren
OG
l_int|0
)paren
(brace
r_return
id|bus
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
eof
