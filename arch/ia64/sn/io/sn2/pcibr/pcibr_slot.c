multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
r_extern
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
r_char
op_star
id|pci_space
(braket
)braket
suffix:semicolon
r_int
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_call_device_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
suffix:semicolon
r_int
id|pcibr_slot_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
suffix:semicolon
r_static
r_int
id|pcibr_probe_slot
c_func
(paren
id|pcibr_soft_t
comma
id|cfg_p
comma
r_int
r_int
op_star
)paren
suffix:semicolon
r_static
r_int
id|pcibr_probe_work
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_void
op_star
id|addr
comma
r_int
id|len
comma
r_void
op_star
id|valp
)paren
suffix:semicolon
r_void
id|pcibr_device_info_free
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_win_info_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_bus_addr_free
c_func
(paren
id|pciio_win_info_t
)paren
suffix:semicolon
id|cfg_p
id|pcibr_find_capability
c_func
(paren
id|cfg_p
comma
r_int
)paren
suffix:semicolon
r_extern
r_uint64
id|do_pcibr_config_get
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|do_pcibr_config_set
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
r_int
id|pcibr_slot_pwr
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|up
comma
r_char
op_star
id|err_msg
)paren
suffix:semicolon
multiline_comment|/* &n; * PCI-X Max Outstanding Split Transactions translation array and Max Memory&n; * Read Byte Count translation array, as defined in the PCI-X Specification.&n; * Section 7.2.3 &amp; 7.2.4 of PCI-X Specification - rev 1.0&n; */
DECL|macro|MAX_SPLIT_TABLE
mdefine_line|#define MAX_SPLIT_TABLE 8
DECL|macro|MAX_READCNT_TABLE
mdefine_line|#define MAX_READCNT_TABLE 4
DECL|variable|max_splittrans_to_numbuf
r_int
id|max_splittrans_to_numbuf
(braket
id|MAX_SPLIT_TABLE
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|8
comma
l_int|12
comma
l_int|16
comma
l_int|32
)brace
suffix:semicolon
DECL|variable|max_readcount_to_bufsize
r_int
id|max_readcount_to_bufsize
(braket
id|MAX_READCNT_TABLE
)braket
op_assign
(brace
l_int|512
comma
l_int|1024
comma
l_int|2048
comma
l_int|4096
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_PCI_SGI
multiline_comment|/*&n; * PCI slot manipulation errors from the system controller, and their&n; * associated descriptions&n; */
DECL|macro|SYSCTL_REQERR_BASE
mdefine_line|#define SYSCTL_REQERR_BASE&t;(-106000)
DECL|macro|SYSCTL_PCI_ERROR_BASE
mdefine_line|#define SYSCTL_PCI_ERROR_BASE&t;(SYSCTL_REQERR_BASE - 100)
DECL|macro|SYSCTL_PCIX_ERROR_BASE
mdefine_line|#define SYSCTL_PCIX_ERROR_BASE&t;(SYSCTL_REQERR_BASE - 3000)
DECL|struct|sysctl_pci_error_s
r_struct
id|sysctl_pci_error_s
(brace
DECL|member|error
r_int
id|error
suffix:semicolon
DECL|member|msg
r_char
op_star
id|msg
suffix:semicolon
DECL|variable|sysctl_pci_errors
)brace
id|sysctl_pci_errors
(braket
)braket
op_assign
(brace
DECL|macro|SYSCTL_PCI_UNINITIALIZED
mdefine_line|#define SYSCTL_PCI_UNINITIALIZED&t;(SYSCTL_PCI_ERROR_BASE - 0)
(brace
id|SYSCTL_PCI_UNINITIALIZED
comma
l_string|&quot;module not initialized&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_UNSUPPORTED_BUS
mdefine_line|#define SYSCTL_PCI_UNSUPPORTED_BUS&t;(SYSCTL_PCI_ERROR_BASE - 1)
(brace
id|SYSCTL_PCI_UNSUPPORTED_BUS
comma
l_string|&quot;unsupported bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_UNSUPPORTED_SLOT
mdefine_line|#define SYSCTL_PCI_UNSUPPORTED_SLOT&t;(SYSCTL_PCI_ERROR_BASE - 2)
(brace
id|SYSCTL_PCI_UNSUPPORTED_SLOT
comma
l_string|&quot;unsupported slot&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_POWER_NOT_OKAY
mdefine_line|#define SYSCTL_PCI_POWER_NOT_OKAY&t;(SYSCTL_PCI_ERROR_BASE - 3)
(brace
id|SYSCTL_PCI_POWER_NOT_OKAY
comma
l_string|&quot;slot power not okay&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_CARD_NOT_PRESENT
mdefine_line|#define SYSCTL_PCI_CARD_NOT_PRESENT&t;(SYSCTL_PCI_ERROR_BASE - 4)
(brace
id|SYSCTL_PCI_CARD_NOT_PRESENT
comma
l_string|&quot;card not present&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_POWER_LIMIT
mdefine_line|#define SYSCTL_PCI_POWER_LIMIT&t;&t;(SYSCTL_PCI_ERROR_BASE - 5)
(brace
id|SYSCTL_PCI_POWER_LIMIT
comma
l_string|&quot;power limit reached - some cards not powered up&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_33MHZ_ON_66MHZ
mdefine_line|#define SYSCTL_PCI_33MHZ_ON_66MHZ&t;(SYSCTL_PCI_ERROR_BASE - 6)
(brace
id|SYSCTL_PCI_33MHZ_ON_66MHZ
comma
l_string|&quot;cannot add a 33 MHz card to an active 66 MHz bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_INVALID_ORDER
mdefine_line|#define SYSCTL_PCI_INVALID_ORDER&t;(SYSCTL_PCI_ERROR_BASE - 7)
(brace
id|SYSCTL_PCI_INVALID_ORDER
comma
l_string|&quot;invalid reset order&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_DOWN_33MHZ
mdefine_line|#define SYSCTL_PCI_DOWN_33MHZ&t;&t;(SYSCTL_PCI_ERROR_BASE - 8)
(brace
id|SYSCTL_PCI_DOWN_33MHZ
comma
l_string|&quot;cannot power down a 33 MHz card on an active bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_RESET_33MHZ
mdefine_line|#define SYSCTL_PCI_RESET_33MHZ&t;&t;(SYSCTL_PCI_ERROR_BASE - 9)
(brace
id|SYSCTL_PCI_RESET_33MHZ
comma
l_string|&quot;cannot reset a 33 MHz card on an active bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCI_SLOT_NOT_UP
mdefine_line|#define SYSCTL_PCI_SLOT_NOT_UP&t;&t;(SYSCTL_PCI_ERROR_BASE - 10)
(brace
id|SYSCTL_PCI_SLOT_NOT_UP
comma
l_string|&quot;cannot reset a slot that is not powered up&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_UNINITIALIZED
mdefine_line|#define SYSCTL_PCIX_UNINITIALIZED&t;(SYSCTL_PCIX_ERROR_BASE - 0)
(brace
id|SYSCTL_PCIX_UNINITIALIZED
comma
l_string|&quot;module not initialized&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_UNSUPPORTED_BUS
mdefine_line|#define SYSCTL_PCIX_UNSUPPORTED_BUS&t;(SYSCTL_PCIX_ERROR_BASE - 1)
(brace
id|SYSCTL_PCIX_UNSUPPORTED_BUS
comma
l_string|&quot;unsupported bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_UNSUPPORTED_SLOT
mdefine_line|#define SYSCTL_PCIX_UNSUPPORTED_SLOT&t;(SYSCTL_PCIX_ERROR_BASE - 2)
(brace
id|SYSCTL_PCIX_UNSUPPORTED_SLOT
comma
l_string|&quot;unsupported slot&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_POWER_NOT_OKAY
mdefine_line|#define SYSCTL_PCIX_POWER_NOT_OKAY&t;(SYSCTL_PCIX_ERROR_BASE - 3)
(brace
id|SYSCTL_PCIX_POWER_NOT_OKAY
comma
l_string|&quot;slot power not okay&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_CARD_NOT_PRESENT
mdefine_line|#define SYSCTL_PCIX_CARD_NOT_PRESENT&t;(SYSCTL_PCIX_ERROR_BASE - 4)
(brace
id|SYSCTL_PCIX_CARD_NOT_PRESENT
comma
l_string|&quot;card not present&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_POWER_LIMIT
mdefine_line|#define SYSCTL_PCIX_POWER_LIMIT&t;&t;(SYSCTL_PCIX_ERROR_BASE - 5)
(brace
id|SYSCTL_PCIX_POWER_LIMIT
comma
l_string|&quot;power limit reached - some cards not powered up&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_33MHZ_ON_66MHZ
mdefine_line|#define SYSCTL_PCIX_33MHZ_ON_66MHZ&t;(SYSCTL_PCIX_ERROR_BASE - 6)
(brace
id|SYSCTL_PCIX_33MHZ_ON_66MHZ
comma
l_string|&quot;cannot add a 33 MHz card to an active 66 MHz bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_PCI_ON_PCIX
mdefine_line|#define SYSCTL_PCIX_PCI_ON_PCIX&t;&t;(SYSCTL_PCIX_ERROR_BASE - 7)
(brace
id|SYSCTL_PCIX_PCI_ON_PCIX
comma
l_string|&quot;cannot add a PCI card to an active PCIX bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_ANYTHING_ON_133MHZ
mdefine_line|#define SYSCTL_PCIX_ANYTHING_ON_133MHZ&t;&t;(SYSCTL_PCIX_ERROR_BASE - 8)
(brace
id|SYSCTL_PCIX_ANYTHING_ON_133MHZ
comma
l_string|&quot;cannot add any card to an active 133MHz PCIX bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_X66MHZ_ON_X100MHZ
mdefine_line|#define SYSCTL_PCIX_X66MHZ_ON_X100MHZ&t;&t;(SYSCTL_PCIX_ERROR_BASE - 9)
(brace
id|SYSCTL_PCIX_X66MHZ_ON_X100MHZ
comma
l_string|&quot;cannot add a PCIX 66MHz card to an active 100MHz PCIX bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_INVALID_ORDER
mdefine_line|#define SYSCTL_PCIX_INVALID_ORDER&t;(SYSCTL_PCIX_ERROR_BASE - 10)
(brace
id|SYSCTL_PCIX_INVALID_ORDER
comma
l_string|&quot;invalid reset order&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_DOWN_33MHZ
mdefine_line|#define SYSCTL_PCIX_DOWN_33MHZ&t;&t;(SYSCTL_PCIX_ERROR_BASE - 11)
(brace
id|SYSCTL_PCIX_DOWN_33MHZ
comma
l_string|&quot;cannot power down a 33 MHz card on an active bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_RESET_33MHZ
mdefine_line|#define SYSCTL_PCIX_RESET_33MHZ&t;&t;(SYSCTL_PCIX_ERROR_BASE - 12)
(brace
id|SYSCTL_PCIX_RESET_33MHZ
comma
l_string|&quot;cannot reset a 33 MHz card on an active bus&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_SLOT_NOT_UP
mdefine_line|#define SYSCTL_PCIX_SLOT_NOT_UP&t;&t;(SYSCTL_PCIX_ERROR_BASE - 13)
(brace
id|SYSCTL_PCIX_SLOT_NOT_UP
comma
l_string|&quot;cannot reset a slot that is not powered up&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_INVALID_BUS_SETTING
mdefine_line|#define SYSCTL_PCIX_INVALID_BUS_SETTING&t;(SYSCTL_PCIX_ERROR_BASE - 14)
(brace
id|SYSCTL_PCIX_INVALID_BUS_SETTING
comma
l_string|&quot;invalid bus type/speed selection (PCIX&lt;66MHz, PCI&gt;66MHz)&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_INVALID_DEPENDENT_SLOT
mdefine_line|#define SYSCTL_PCIX_INVALID_DEPENDENT_SLOT (SYSCTL_PCIX_ERROR_BASE - 15)
(brace
id|SYSCTL_PCIX_INVALID_DEPENDENT_SLOT
comma
l_string|&quot;invalid dependent slot in PCI slot configuration&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_SHARED_IDSELECT
mdefine_line|#define SYSCTL_PCIX_SHARED_IDSELECT&t;(SYSCTL_PCIX_ERROR_BASE - 16)
(brace
id|SYSCTL_PCIX_SHARED_IDSELECT
comma
l_string|&quot;cannot enable two slots sharing the same IDSELECT&quot;
)brace
comma
DECL|macro|SYSCTL_PCIX_SLOT_DISABLED
mdefine_line|#define SYSCTL_PCIX_SLOT_DISABLED&t;(SYSCTL_PCIX_ERROR_BASE - 17)
(brace
id|SYSCTL_PCIX_SLOT_DISABLED
comma
l_string|&quot;slot is disabled&quot;
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* end sysctl_pci_errors[] */
multiline_comment|/*&n; * look up an error message for PCI operations that fail&n; */
r_static
r_void
DECL|function|sysctl_pci_error_lookup
id|sysctl_pci_error_lookup
c_func
(paren
r_int
id|error
comma
r_char
op_star
id|err_msg
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sysctl_pci_error_s
op_star
id|e
op_assign
id|sysctl_pci_errors
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|sysctl_pci_errors
)paren
op_div
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|i
op_increment
comma
id|e
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;error
op_eq
id|error
)paren
(brace
id|strcpy
c_func
(paren
id|err_msg
comma
id|e-&gt;msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sprintf
c_func
(paren
id|err_msg
comma
l_string|&quot;unrecognized PCI error type&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_attach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific initialization that needs to be done.&n; *&t;This is usually called when we want to initialize a new&n; * &t;PCI card on the bus.&n; */
r_int
DECL|function|pcibr_slot_attach
id|pcibr_slot_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|PCI_SLOT_POWER_ON
)paren
)paren
(brace
r_uint64
id|speed
suffix:semicolon
r_uint64
id|mode
suffix:semicolon
multiline_comment|/* Power-up the slot */
id|error
op_assign
id|pcibr_slot_pwr
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|PCI_REQ_SLOT_POWER_ON
comma
id|l1_msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_L1_ERR
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|PCI_SLOT_POWER_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|PCI_SLOT_POWER_ON
suffix:semicolon
)brace
multiline_comment|/* The speed/mode of the bus may have changed due to the hotplug */
id|speed
op_assign
id|pcireg_speed_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|mode
op_assign
id|pcireg_mode_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_mode
op_assign
(paren
(paren
id|speed
op_lshift
l_int|1
)paren
op_or
id|mode
)paren
suffix:semicolon
multiline_comment|/*&n;         * Allow cards like the Alteon Gigabit Ethernet Adapter to complete&n;         * on-card initialization following the slot reset&n;         */
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* Find out what is out there */
id|error
op_assign
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_INFO_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Set up the address space for this slot in the PCI land */
id|error
op_assign
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_ADDR_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Allocate the PCI-X Read Buffer Attribute Registers (RBARs)*/
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_int
id|tmp_slot
suffix:semicolon
multiline_comment|/* Recalculate the RBARs for all the devices on the bus.  Only&n;&t;     * return an error if we error for the given &squot;slot&squot;&n;&t;     */
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_assign
id|NUM_RBAR
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_assign
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|tmp_slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|tmp_slot
)paren
(brace
r_if
c_cond
(paren
id|tmp_slot
op_eq
id|slot
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip this &squot;slot&squot;, we do it below */
(paren
r_void
)paren
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|tmp_slot
)paren
suffix:semicolon
)brace
id|error
op_assign
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_RBAR_ALLOC_ERR
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup the device register */
id|error
op_assign
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_DEV_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Setup host/guest relations */
id|error
op_assign
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_GUEST_INIT_ERR
suffix:semicolon
)brace
multiline_comment|/* Initial RRB management */
id|error
op_assign
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_return
id|PCI_SLOT_RRB_ALLOC_ERR
suffix:semicolon
)brace
)brace
multiline_comment|/* Call the device attach */
id|error
op_assign
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EUNATCH
)paren
r_return
id|PCI_NO_DRIVER
suffix:semicolon
r_else
r_return
id|PCI_SLOT_DRV_ATTACH_ERR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_enable&n; *&t;Enable the PCI slot for a hot-plug insert.&n; */
r_int
DECL|function|pcibr_slot_enable
id|pcibr_slot_enable
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
r_struct
id|pcibr_slot_enable_req_s
op_star
id|req_p
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|req_p-&gt;req_device
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_HOTPLUG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_enable: pcibr_soft=0x%lx, slot=%d, req_p=0x%lx&bslash;n&quot;
comma
id|pcibr_soft
comma
id|slot
comma
id|req_p
)paren
)paren
suffix:semicolon
multiline_comment|/* Check for the valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|PCI_SLOT_ENABLE_CMPLT
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_UP
suffix:semicolon
r_goto
id|enable_unlock
suffix:semicolon
)brace
id|error
op_assign
id|pcibr_slot_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
l_int|0
comma
id|req_p-&gt;req_resp.resp_l1_msg
comma
op_amp
id|req_p-&gt;req_resp.resp_sub_errno
)paren
suffix:semicolon
id|req_p-&gt;req_resp.resp_l1_msg
(braket
id|PCI_L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|enable_unlock
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_disable&n; *&t;Disable the PCI slot for a hot-plug removal.&n; */
r_int
DECL|function|pcibr_slot_disable
id|pcibr_slot_disable
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
r_struct
id|pcibr_slot_disable_req_s
op_star
id|req_p
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|req_p-&gt;req_device
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|pciio_slot_t
id|tmp_slot
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
r_return
id|PCI_NOT_A_BRIDGE
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_HOTPLUG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_disable: pcibr_soft=0x%lx, slot=%d, req_p=0x%lx&bslash;n&quot;
comma
id|pcibr_soft
comma
id|slot
comma
id|req_p
)paren
)paren
suffix:semicolon
multiline_comment|/* Check for valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
id|PCI_NOT_A_SLOT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|PCI_SLOT_DISABLE_CMPLT
)paren
op_logical_or
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_amp
id|PCI_SLOT_STATUS_MASK
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|PCI_SLOT_ALREADY_DOWN
suffix:semicolon
multiline_comment|/*&n;         * RJR - Should we invoke an L1 slot power-down command just in case&n;         *       a previous shut-down failed to power-down the slot?&n;         */
r_goto
id|disable_unlock
suffix:semicolon
)brace
multiline_comment|/* Do not allow the last 33 MHz card to be removed */
r_if
c_cond
(paren
id|IS_33MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_first_slot
suffix:semicolon
id|tmp_slot
op_le
id|pcibr_soft-&gt;bs_last_slot
suffix:semicolon
id|tmp_slot
op_increment
)paren
r_if
c_cond
(paren
id|tmp_slot
op_ne
id|slot
)paren
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|tmp_slot
)braket
dot
id|slot_status
op_amp
id|PCI_SLOT_POWER_ON
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|PCI_EMPTY_33MHZ
suffix:semicolon
r_goto
id|disable_unlock
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|req_p-&gt;req_action
op_eq
id|PCI_REQ_SLOT_ELIGIBLE
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|pcibr_slot_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
l_int|1
comma
id|req_p-&gt;req_resp.resp_l1_msg
comma
op_amp
id|req_p-&gt;req_resp.resp_sub_errno
)paren
suffix:semicolon
id|req_p-&gt;req_resp.resp_l1_msg
(braket
id|PCI_L1_QSIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|disable_unlock
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_pwr&n; *      Power-up or power-down a PCI slot.  This routines makes calls to&n; *      the L1 system controller driver which requires &quot;external&quot; slot#.&n; */
r_int
DECL|function|pcibr_slot_pwr
id|pcibr_slot_pwr
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|up
comma
r_char
op_star
id|err_msg
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|u64
id|connection_type
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|pcibr_soft-&gt;bs_base
)paren
suffix:semicolon
id|connection_type
op_assign
id|SAL_SYSCTL_IO_XTALK
suffix:semicolon
id|rv
op_assign
(paren
r_int
)paren
id|ia64_sn_sysctl_iobrick_pci_op
(paren
id|nasid
comma
id|connection_type
comma
(paren
id|u64
)paren
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
(paren
id|up
ques
c_cond
id|SAL_SYSCTL_PCI_POWER_UP
suffix:colon
id|SAL_SYSCTL_PCI_POWER_DOWN
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
multiline_comment|/* everything&squot;s okay; no error message */
op_star
id|err_msg
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* there was a problem; look up an appropriate error message */
id|sysctl_pci_error_lookup
c_func
(paren
id|rv
comma
id|err_msg
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_PCI_SGI */
multiline_comment|/*&n; * pcibr_slot_info_init&n; *&t;Probe for this slot and see if it is populated.&n; *&t;If it is populated initialize the generic PCI infrastructural&n; * &t;information associated with this particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_init
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|idword
suffix:semicolon
r_int
id|pfail
suffix:semicolon
r_int
id|idwords
(braket
l_int|8
)braket
suffix:semicolon
id|pciio_vendor_id_t
id|vendor
suffix:semicolon
id|pciio_device_id_t
id|device
suffix:semicolon
r_int
id|htype
suffix:semicolon
r_int
id|lt_time
suffix:semicolon
r_int
id|nbars
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|cfg_p
id|pcix_cap
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pciio_function_t
id|rfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|conn_vhdl
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
r_uint64
id|device_reg
suffix:semicolon
multiline_comment|/* Get the basic software information required to proceed */
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* If we have a host slot (eg:- IOC3 has 2 PCI slots and the initialization&n;     * is done by the host slot then we are done.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to read the device-id/vendor-id from the config space */
id|cfgw
op_assign
id|pcibr_slot_config_addr
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|pcibr_soft
comma
id|cfgw
comma
op_amp
id|idword
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_PCI_SGI
id|slotp-&gt;slot_status
op_or_assign
id|SLOT_POWER_UP
suffix:semicolon
macro_line|#endif
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idword
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_PROBE
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: slot=%d, vendor=0x%x, device=0x%x&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|vendor
comma
id|device
)paren
)paren
suffix:semicolon
multiline_comment|/* If the vendor id is not valid then the slot is not populated&n;     * and we are done.&n;     */
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|nfunc
op_assign
l_int|1
suffix:semicolon
id|rfunc
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|pfail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: if a card claims to be multifunction&n;     * but only responds to config space 0, treat&n;     * it as a unifunction card.&n;     */
r_if
c_cond
(paren
id|htype
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* MULTIFUNCTION */
r_for
c_loop
(paren
id|func
op_assign
l_int|1
suffix:semicolon
id|func
OL
l_int|8
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|pcibr_soft
comma
id|cfgw
comma
op_amp
id|idwords
(braket
id|func
)braket
)paren
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idwords
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nfunc
op_assign
id|func
op_plus
l_int|1
suffix:semicolon
id|rfunc
op_assign
l_int|0
suffix:semicolon
)brace
id|cfgw
op_assign
id|pcibr_slot_config_addr
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
)brace
id|pcibr_infoh
op_assign
id|kmalloc
c_func
(paren
id|nfunc
op_star
r_sizeof
(paren
op_star
(paren
id|pcibr_infoh
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcibr_infoh
comma
l_int|0
comma
id|nfunc
op_star
r_sizeof
(paren
op_star
(paren
id|pcibr_infoh
)paren
)paren
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
id|nfunc
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
r_int
id|cmd_reg
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
r_if
c_cond
(paren
id|pfail
op_amp
(paren
l_int|1
op_lshift
id|func
)paren
)paren
r_continue
suffix:semicolon
id|idword
op_assign
id|idwords
(braket
id|func
)braket
suffix:semicolon
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|rfunc
op_assign
id|func
suffix:semicolon
)brace
id|htype
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|htype
op_ne
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s pcibr: pci slot %d func %d has strange header type 0x%x&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|htype
)paren
suffix:semicolon
id|nbars
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|nbars
op_assign
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: slot=%d, func=%d, cfgw=0x%lx&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|cfgw
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If the latency timer has already been set, by prom or by the&n;&t; * card itself, use that value.  Otherwise look at the device&squot;s&n;&t; * &squot;min_gnt&squot; and attempt to calculate a latency time. &n;&t; *&n;&t; * NOTE: For now if the device is on the &squot;real time&squot; arbitration&n;&t; * ring we don&squot;t set the latency timer.  &n;&t; *&n;&t; * WAR: SGI&squot;s IOC3 and RAD devices target abort if you write a &n;&t; * single byte into their config space.  So don&squot;t set the Latency&n;&t; * Timer for these devices&n;&t; */
id|lt_time
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_LATENCY_TIMER
comma
l_int|1
)paren
suffix:semicolon
id|device_reg
op_assign
id|pcireg_device_get
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lt_time
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|device_reg
op_amp
id|BRIDGE_DEV_RT
)paren
)paren
(brace
r_int
id|min_gnt
suffix:semicolon
r_int
id|min_gnt_mult
suffix:semicolon
multiline_comment|/* &squot;min_gnt&squot; indicates how long of a burst period a device&n;&t;     * needs in increments of 250ns.  But latency timer is in&n;&t;     * PCI clock cycles, so a conversion is needed.&n;&t;     */
id|min_gnt
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_MIN_GNT
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_133MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 250ns @ 133MHz in clocks */
r_else
r_if
c_cond
(paren
id|IS_100MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|24
suffix:semicolon
multiline_comment|/* 250ns @ 100MHz in clocks */
r_else
r_if
c_cond
(paren
id|IS_66MHZ
c_func
(paren
id|pcibr_soft
)paren
)paren
id|min_gnt_mult
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* 250ns @ 66MHz, in clocks */
r_else
id|min_gnt_mult
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 250ns @ 33MHz, in clocks */
r_if
c_cond
(paren
(paren
id|min_gnt
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|min_gnt
op_star
id|min_gnt_mult
)paren
OL
l_int|256
)paren
)paren
id|lt_time
op_assign
(paren
id|min_gnt
op_star
id|min_gnt_mult
)paren
suffix:semicolon
r_else
id|lt_time
op_assign
l_int|4
op_star
id|min_gnt_mult
suffix:semicolon
multiline_comment|/* 1 micro second */
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_LATENCY_TIMER
comma
l_int|1
comma
id|lt_time
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: set Latency Timer for slot=%d, &quot;
l_string|&quot;func=%d, to 0x%x&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|lt_time
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* In our architecture the setting of the cacheline size isn&squot;t &n;&t; * beneficial for cards in PCI mode, but in PCI-X mode devices&n;&t; * can optionally use the cacheline size value for internal &n;&t; * device optimizations    (See 7.1.5 of the PCI-X v1.0 spec).&n;&t; * NOTE: cachline size is in doubleword increments&n;&t; */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_CACHE_LINE
comma
l_int|1
)paren
)paren
(brace
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_CACHE_LINE
comma
l_int|1
comma
l_int|0x20
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: set CacheLine for slot=%d, &quot;
l_string|&quot;func=%d, to 0x20&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the PCI-X capability if running in PCI-X mode.  If the func&n;&t; * doesnt have a pcix capability, allocate a PCIIO_VENDOR_ID_NONE&n;&t; * pcibr_info struct so the device driver for that function is not&n;&t; * called.&n;&t; */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcix_cap
op_assign
id|pcibr_find_capability
c_func
(paren
id|cfgw
comma
id|PCI_CAP_PCIX
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Bus running in PCI-X mode, But card in slot %d, &quot;
l_string|&quot;func %d not PCI-X capable&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
)paren
suffix:semicolon
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_CONFIG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: PCI-X capability at 0x%lx for &quot;
l_string|&quot;slot=%d, func=%d&bslash;n&quot;
comma
id|pcix_cap
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcix_cap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
multiline_comment|/* Keep a running total of the number of PIC-X functions on the bus&n;         * and the number of max outstanding split trasnactions that they&n;&t; * have requested.  NOTE: &quot;pcix_cap != NULL&quot; implies IS_PCIX()&n;&t; */
id|pcibr_info-&gt;f_pcix_cap
op_assign
(paren
id|cap_pcix_type0_t
op_star
)paren
id|pcix_cap
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_pcix_cap
)paren
(brace
r_int
id|max_out
suffix:semicolon
multiline_comment|/* max outstanding splittrans from status reg */
id|pcibr_soft-&gt;bs_pcix_num_funcs
op_increment
suffix:semicolon
id|max_out
op_assign
id|pcibr_info-&gt;f_pcix_cap-&gt;pcix_type0_status.max_out_split
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_split_tot
op_add_assign
id|max_splittrans_to_numbuf
(braket
id|max_out
)braket
suffix:semicolon
)brace
id|conn_vhdl
op_assign
id|pciio_device_info_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|slotp-&gt;slot_conn
op_assign
id|conn_vhdl
suffix:semicolon
id|cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|nbars
suffix:semicolon
op_increment
id|win
)paren
(brace
id|iopaddr_t
id|base
comma
id|mask
comma
id|code
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * GET THE BASE &amp; SIZE OF THIS WINDOW:&n;&t;     *&n;&t;     * The low two or four bits of the BASE register&n;&t;     * determines which address space we are in; the&n;&t;     * rest is a base address. BASE registers&n;&t;     * determine windows that are power-of-two sized&n;&t;     * and naturally aligned, so we can get the size&n;&t;     * of a window by writing all-ones to the&n;&t;     * register, reading it back, and seeing which&n;&t;     * bits are used for decode; the least&n;&t;     * significant nonzero bit is also the size of&n;&t;     * the window.&n;&t;     *&n;&t;     * WARNING: someone may already have allocated&n;&t;     * some PCI space to this window, and in fact&n;&t;     * PIO may be in process at this very moment&n;&t;     * from another processor (or even from this&n;&t;     * one, if we get interrupted)! So, if the BASE&n;&t;     * already has a nonzero address, be generous&n;&t;     * and use the LSBit of that address as the&n;&t;     * size; this could overstate the window size.&n;&t;     * Usually, when one card is set up, all are set&n;&t;     * up; so, since we don&squot;t bitch about&n;&t;     * overlapping windows, we are ok.&n;&t;     *&n;&t;     * UNFORTUNATELY, some cards do not clear their&n;&t;     * BASE registers on reset. I have two heuristics&n;&t;     * that can detect such cards: first, if the&n;&t;     * decode enable is turned off for the space&n;&t;     * that the window uses, we can disregard the&n;&t;     * initial value. second, if the address is&n;&t;     * outside the range that we use, we can disregard&n;&t;     * it as well.&n;&t;     *&n;&t;     * This is looking very PCI generic. Except for&n;&t;     * knowing how many slots and where their config&n;&t;     * spaces are, this window loop and the next one&n;&t;     * could probably be shared with other PCI host&n;&t;     * adapters. It would be interesting to see if&n;&t;     * this could be pushed up into pciio, when we&n;&t;     * start supporting more PCI providers.&n;&t;     */
id|base
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BA_IO_SPACE
)paren
(brace
multiline_comment|/* BASE is in I/O space. */
id|space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|mask
op_assign
op_minus
l_int|4
suffix:semicolon
id|code
op_assign
id|base
op_amp
l_int|3
suffix:semicolon
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_IO_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
)brace
r_else
(brace
multiline_comment|/* BASE is in MEM space. */
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|mask
op_assign
op_minus
l_int|16
suffix:semicolon
id|code
op_assign
id|base
op_amp
id|PCI_BA_MEM_LOCATION
suffix:semicolon
multiline_comment|/* extract BAR type */
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_MEM_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
r_else
r_if
c_cond
(paren
id|base
op_amp
l_int|0xC0000000
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
r_else
r_if
c_cond
(paren
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
op_logical_and
(paren
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
(paren
id|win
op_plus
l_int|1
)paren
op_star
l_int|4
)paren
comma
l_int|4
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|0
)paren
(brace
multiline_comment|/* estimate size */
id|pciio_space_t
id|tmp_space
op_assign
id|space
suffix:semicolon
id|iopaddr_t
id|tmp_base
suffix:semicolon
id|size
op_assign
id|base
op_amp
op_minus
id|base
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reserve this space in the relavent address map.  Don&squot;t&n;&t;&t; * care about the return code from pcibr_bus_addr_alloc().&n;&t;&t; */
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM
op_logical_and
id|code
op_ne
id|PCI_BA_MEM_1MEG
)paren
(brace
id|tmp_space
op_assign
id|PCIIO_SPACE_MEM32
suffix:semicolon
)brace
id|tmp_base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|tmp_space
comma
id|base
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_info_init: slot=%d, func=%d win %d &quot;
l_string|&quot;reserving space %s [0x%lx..0x%lx], tmp_base 0x%lx&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|pci_space
(braket
id|tmp_space
)braket
comma
(paren
r_uint64
)paren
id|base
comma
(paren
r_uint64
)paren
(paren
id|base
op_plus
id|size
op_minus
l_int|1
)paren
comma
(paren
r_uint64
)paren
id|tmp_base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* calculate size */
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
op_complement
l_int|0
)paren
suffix:semicolon
multiline_comment|/* write 1&squot;s */
id|size
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* read back */
id|size
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* keep addr */
id|size
op_and_assign
op_minus
id|size
suffix:semicolon
multiline_comment|/* keep lsbit */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
op_assign
id|space
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
(brace
id|win
op_increment
suffix:semicolon
multiline_comment|/* skip upper half */
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* must be zero */
)brace
)brace
multiline_comment|/* next win */
)brace
multiline_comment|/* next func */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_find_capability&n; *&t;Walk the list of capabilities (if it exists) looking for&n; *&t;the requested capability.  Return a cfg_p pointer to the&n; *&t;capability if found, else return NULL&n; */
id|cfg_p
DECL|function|pcibr_find_capability
id|pcibr_find_capability
c_func
(paren
id|cfg_p
id|cfgw
comma
r_int
id|capability
)paren
(brace
r_int
id|cap_nxt
suffix:semicolon
r_int
id|cap_id
suffix:semicolon
r_int
id|defend_against_circular_linkedlist
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check to see if there is a capabilities pointer in the cfg header */
r_if
c_cond
(paren
op_logical_neg
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_STATUS
comma
l_int|2
)paren
op_amp
id|PCI_STAT_CAP_LIST
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Read up the capabilities head pointer from the configuration header.&n;     * Capabilities are stored as a linked list in the lower 48 dwords of&n;     * config space and are dword aligned. (Note: spec states the least two&n;     * significant bits of the next pointer must be ignored,  so we mask&n;     * with 0xfc).&n;     */
id|cap_nxt
op_assign
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CAPABILITIES_PTR
comma
l_int|1
)paren
op_amp
l_int|0xfc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cap_nxt
op_logical_and
(paren
id|defend_against_circular_linkedlist
op_le
l_int|48
)paren
)paren
(brace
id|cap_id
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|cap_nxt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cap_id
op_eq
id|capability
)paren
(brace
r_return
(paren
id|cfg_p
)paren
(paren
(paren
r_char
op_star
)paren
id|cfgw
op_plus
id|cap_nxt
)paren
suffix:semicolon
)brace
id|cap_nxt
op_assign
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|cap_nxt
op_plus
l_int|1
comma
l_int|1
)paren
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|defend_against_circular_linkedlist
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_info_free&n; *&t;Remove all the PCI infrastructural information associated&n; * &t;with a particular PCI device.&n; */
r_int
DECL|function|pcibr_slot_info_free
id|pcibr_slot_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_device_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|kfree
c_func
(paren
id|pcibr_infoh
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_pcix_rbar_init&n; *&t;Allocate RBARs to the PCI-X functions on a given device&n; */
r_int
DECL|function|pcibr_slot_pcix_rbar_init
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
)paren
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;pcibr_slot_pcix_rbar_init for slot %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;&bslash;tslot/func&bslash;trequested&bslash;tgiven&bslash;tinuse&bslash;tavail&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cap_pcix_type0_t
op_star
id|pcix_cap_p
suffix:semicolon
id|cap_pcix_stat_reg_t
op_star
id|pcix_statreg_p
suffix:semicolon
id|cap_pcix_cmd_reg_t
op_star
id|pcix_cmdreg_p
suffix:semicolon
r_int
id|num_rbar
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcix_cap_p
op_assign
id|pcibr_info-&gt;f_pcix_cap
)paren
)paren
r_continue
suffix:semicolon
id|pcix_statreg_p
op_assign
op_amp
id|pcix_cap_p-&gt;pcix_type0_status
suffix:semicolon
id|pcix_cmdreg_p
op_assign
op_amp
id|pcix_cap_p-&gt;pcix_type0_command
suffix:semicolon
multiline_comment|/* If there are enough RBARs to satify the number of &quot;max outstanding &n;&t; * transactions&quot; each function requested (bs_pcix_rbar_percent_allowed&n;&t; * is 100%), then give each function what it requested, otherwise give &n;&t; * the functions a &quot;percentage of what they requested&quot;.&n;&t; */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_ge
l_int|100
)paren
(brace
id|pcix_cmdreg_p-&gt;max_split
op_assign
id|pcix_statreg_p-&gt;max_out_split
suffix:semicolon
id|num_rbar
op_assign
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_add_assign
id|num_rbar
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_sub_assign
id|num_rbar
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_mem_read_cnt
op_assign
id|pcix_statreg_p-&gt;max_mem_read_cnt
suffix:semicolon
)brace
r_else
(brace
r_int
id|index
suffix:semicolon
multiline_comment|/* index into max_splittrans_to_numbuf table */
r_int
id|max_out
suffix:semicolon
multiline_comment|/* max outstanding transactions given to func */
multiline_comment|/* Calculate the percentage of RBARs this function can have.&n;&t;     * NOTE: Every function gets at least 1 RBAR (thus the &quot;+1&quot;).&n;&t;     * bs_pcix_rbar_percent_allowed is the percentage of what was&n;&t;     * requested less this 1 RBAR that all functions automatically &n;&t;     * gets&n;&t;     */
id|max_out
op_assign
(paren
(paren
id|max_splittrans_to_numbuf
(braket
id|pcix_statreg_p-&gt;max_out_split
)braket
op_star
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
)paren
op_div
l_int|100
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round down the newly caclulated max_out to a valid number in&n;&t;     * max_splittrans_to_numbuf[]&n;&t;     */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_SPLIT_TABLE
op_minus
l_int|1
suffix:semicolon
id|index
op_increment
)paren
r_if
c_cond
(paren
id|max_splittrans_to_numbuf
(braket
id|index
op_plus
l_int|1
)braket
OG
id|max_out
)paren
r_break
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_split
op_assign
id|index
suffix:semicolon
id|num_rbar
op_assign
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_add_assign
id|num_rbar
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_sub_assign
id|num_rbar
suffix:semicolon
id|pcix_cmdreg_p-&gt;max_mem_read_cnt
op_assign
id|pcix_statreg_p-&gt;max_mem_read_cnt
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_RBAR
comma
id|pcibr_soft-&gt;bs_vhdl
comma
l_string|&quot;&bslash;t  %d/%d   &bslash;t    %d    &bslash;t  %d  &bslash;t  %d  &bslash;t  %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|max_splittrans_to_numbuf
(braket
id|pcix_statreg_p-&gt;max_out_split
)braket
comma
id|max_splittrans_to_numbuf
(braket
id|pcix_cmdreg_p-&gt;max_split
)braket
comma
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
comma
id|pcibr_soft-&gt;bs_pcix_rbar_avail
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|as_debug
r_int
id|as_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * pcibr_slot_addr_space_init&n; *&t;Reserve chunks of PCI address space as required by &n; * &t;the base registers in the card.&n; */
r_int
DECL|function|pcibr_slot_addr_space_init
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|iopaddr_t
id|mask
suffix:semicolon
r_int
id|nbars
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_int
id|win
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|align
op_assign
l_int|0
suffix:semicolon
r_int
id|align_slot
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* allocate address space,&n;     * for windows that have not been&n;     * previously assigned.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
r_if
c_cond
(paren
id|nfunc
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;     * Try to make the DevIO windows not&n;     * overlap by pushing the &quot;io&quot; and &quot;hi&quot;&n;     * allocation areas up to the next one&n;     * or two megabyte bound. This also&n;     * keeps them from being zero.&n;     *&n;     * DO NOT do this with &quot;pci_lo&quot; since&n;     * the entire &quot;lo&quot; area is only a&n;     * megabyte, total ...&n;     */
id|align_slot
op_assign
(paren
id|slot
OL
l_int|2
)paren
ques
c_cond
l_int|0x200000
suffix:colon
l_int|0x100000
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfg_p
id|cfgw
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|pci_cfg_cmd_reg
suffix:semicolon
r_int
id|pci_cfg_cmd_reg_add
op_assign
l_int|0
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_int|0
)paren
id|nbars
op_assign
l_int|2
suffix:semicolon
r_else
id|nbars
op_assign
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|nbars
suffix:semicolon
op_increment
id|win
)paren
(brace
id|space
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
suffix:semicolon
id|base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, &quot;
l_string|&quot;func=%d win %d is in space %s [0x%lx..0x%lx], &quot;
l_string|&quot;allocated by prom&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|pci_space
(braket
id|space
)braket
comma
(paren
r_uint64
)paren
id|base
comma
(paren
r_uint64
)paren
(paren
id|base
op_plus
id|size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* already allocated */
)brace
id|align
op_assign
(paren
id|win
)paren
ques
c_cond
id|size
suffix:colon
id|align_slot
suffix:semicolon
r_if
c_cond
(paren
id|align
OL
id|PAGE_SIZE
)paren
id|align
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* ie. 0x00004000 */
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_IO
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
r_if
c_cond
(paren
(paren
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
)paren
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
id|PCI_BA_MEM_1MEG
)paren
(brace
multiline_comment|/* allocate from 20-bit PCI space */
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_MEM
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate from 32-bit or 64-bit PCI space */
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
comma
id|PCIIO_SPACE_MEM32
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|base
op_assign
l_int|0
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, window %d &quot;
l_string|&quot;had bad space code %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|win
comma
id|space
)paren
)paren
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
(paren
id|win
op_star
l_int|4
)paren
comma
l_int|4
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=%d. win %d &quot;
l_string|&quot;is in space %s [0x%lx..0x%lx], allocated by pcibr&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
id|pci_space
(braket
id|space
)braket
comma
(paren
r_uint64
)paren
id|base
comma
(paren
r_uint64
)paren
(paren
id|base
op_plus
id|size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=%d, win %d, &quot;
l_string|&quot;unable to alloc 0x%lx in space %s&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|win
comma
(paren
r_uint64
)paren
id|size
comma
id|pci_space
(braket
id|space
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* next base */
multiline_comment|/*&n;&t; * Allocate space for the EXPANSION ROM&n;&t; */
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
(brace
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_EXPANSION_ROM
op_div
l_int|4
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
comma
l_int|0xFFFFF000
)paren
suffix:semicolon
id|mask
op_assign
id|do_pcibr_config_get
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
l_int|0xFFFFF000
)paren
(brace
id|size
op_assign
id|mask
op_amp
op_minus
id|mask
suffix:semicolon
id|base
op_assign
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft
comma
op_amp
id|pcibr_info-&gt;f_rwindow
comma
id|PCIIO_SPACE_MEM32
comma
l_int|0
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|rc
op_assign
id|ENOSPC
suffix:semicolon
r_else
(brace
id|do_pcibr_config_set
c_func
(paren
id|wptr
comma
l_int|0
comma
l_int|4
comma
id|base
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_BAR
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_addr_space_init: slot=%d, func=%d, &quot;
l_string|&quot;ROM in [0x%X..0x%X], allocated by pcibr&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|pcibr_info-&gt;f_rbase
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_rsize
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * if necessary, update the board&squot;s&n;&t; * command register to enable decoding&n;&t; * in the windows we added.&n;&t; *&n;&t; * There are some bits we always want to&n;&t; * be sure are set.&n;&t; */
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_IO_SPACE
suffix:semicolon
multiline_comment|/*&n;&t; * The Adaptec 1160 FC Controller WAR #767995:&n;&t; * The part incorrectly ignores the upper 32 bits of a 64 bit&n;&t; * address when decoding references to its registers so to&n;&t; * keep it from responding to a bus cycle that it shouldn&squot;t&n;&t; * we only use I/O space to get at it&squot;s registers.  Don&squot;t&n;&t; * enable memory space accesses on that PCI device.&n;&t; */
DECL|macro|FCADP_VENDID
mdefine_line|#define FCADP_VENDID 0x9004 /* Adaptec Vendor ID from fcadp.h */
DECL|macro|FCADP_DEVID
mdefine_line|#define FCADP_DEVID 0x1160  /* Adaptec 1160 Device ID from fcadp.h */
r_if
c_cond
(paren
(paren
id|pcibr_info-&gt;f_vendor
op_ne
id|FCADP_VENDID
)paren
op_logical_or
(paren
id|pcibr_info-&gt;f_device
op_ne
id|FCADP_DEVID
)paren
)paren
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_MEM_SPACE
suffix:semicolon
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_BUS_MASTER
suffix:semicolon
id|pci_cfg_cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
id|pci_cfg_cmd_reg
op_and_assign
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|pci_cfg_cmd_reg_add
op_amp
op_complement
id|pci_cfg_cmd_reg
)paren
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
comma
id|pci_cfg_cmd_reg
op_or
id|pci_cfg_cmd_reg_add
)paren
suffix:semicolon
)brace
multiline_comment|/* next func */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_device_init&n; * &t;Setup the device register in the bridge for this PCI slot.&n; */
r_int
DECL|function|pcibr_slot_device_init
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_uint64
id|devreg
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;     * Adjustments to Device(x) and init of bss_device shadow&n;     */
id|devreg
op_assign
id|pcireg_device_get
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_PAGE_CHK_DIS
suffix:semicolon
multiline_comment|/*&n;     * Enable virtual channels by default (exception: see PIC WAR below)&n;     */
id|devreg
op_or_assign
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
multiline_comment|/*&n;     * PIC WAR. PV# 855271:  Disable virtual channels in the PIC since&n;     * it can cause problems with 32-bit devices.  We&squot;ll set the bit in&n;     * pcibr_try_set_device() iff we&squot;re 64-bit and requesting virtual &n;     * channels.&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV855271
comma
id|pcibr_soft
)paren
)paren
(brace
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
)brace
id|devreg
op_or_assign
id|BRIDGE_DEV_COH
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|pcireg_device_set
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|devreg
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DEVREG
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_device_init: Device(%d): 0x%x&bslash;n&quot;
comma
id|slot
comma
id|devreg
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_guest_info_init&n; *&t;Setup the host/guest relations for a PCI slot.&n; */
r_int
DECL|function|pcibr_slot_guest_info_init
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* create info and verticies for guest slots;&n;     * for compatibilitiy macros, create info&n;     * for even unpopulated slots (but do not&n;     * build verticies for them).&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OL
l_int|1
)paren
(brace
id|pcibr_infoh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_infoh
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcibr_infoh
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pcibr_infoh
)paren
)paren
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slotp-&gt;slot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* generate host/guest relations&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_int
id|host
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_soft_slot_t
id|host_slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|host
)braket
suffix:semicolon
id|hwgraph_edge_add
c_func
(paren
id|slotp-&gt;slot_conn
comma
id|host_slotp-&gt;slot_conn
comma
id|EDGE_LBL_HOST
)paren
suffix:semicolon
multiline_comment|/* XXX- only gives us one guest edge per&n;&t; * host. If/when we have a host with more than&n;&t; * one guest, we will need to figure out how&n;&t; * the host finds all its guests, and sorts&n;&t; * out which one is which.&n;&t; */
id|hwgraph_edge_add
c_func
(paren
id|host_slotp-&gt;slot_conn
comma
id|slotp-&gt;slot_conn
comma
id|EDGE_LBL_GUEST
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_attach&n; *&t;This calls the associated driver attach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_attach
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|xconn_vhdl
comma
id|conn_vhdl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
id|error_func
op_assign
id|pciio_device_attach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DEV_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_call_device_attach: slot=%d, func=%d &quot;
l_string|&quot;drv_flags=0x%x, pciio_device_attach returned %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|drv_flags
comma
id|error_func
)paren
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
macro_line|#ifdef CONFIG_HOTPLUG_PCI_SGI
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
op_logical_and
(paren
id|error
op_ne
id|EPERM
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_INCMPLT
suffix:semicolon
)brace
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_STARTUP_CMPLT
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_HOTPLUG_PCI_SGI */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_detach&n; *&t;This calls the associated driver detach routine for the PCI&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_detach
id|pcibr_slot_call_device_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|vertex_hdl_t
id|conn_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|error_func
suffix:semicolon
r_int
id|error_slot
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
id|ENODEV
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
op_logical_and
id|pcibr_info-&gt;f_pcix_cap
)paren
(brace
r_int
id|max_out
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_num_funcs
op_decrement
suffix:semicolon
id|max_out
op_assign
id|pcibr_info-&gt;f_pcix_cap-&gt;pcix_type0_status.max_out_split
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_split_tot
op_sub_assign
id|max_splittrans_to_numbuf
(braket
id|max_out
)braket
suffix:semicolon
)brace
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
id|error_func
op_assign
id|pciio_device_detach
c_func
(paren
id|conn_vhdl
comma
id|drv_flags
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_DEV_DETACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_slot_call_device_detach: slot=%d, func=%d &quot;
l_string|&quot;drv_flags=0x%x, pciio_device_detach returned %d&bslash;n&quot;
comma
id|PCIBR_DEVICE_TO_SLOT
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
comma
id|func
comma
id|drv_flags
comma
id|error_func
)paren
)paren
suffix:semicolon
id|pcibr_info-&gt;f_att_det_error
op_assign
id|error_func
suffix:semicolon
r_if
c_cond
(paren
id|error_func
)paren
id|error_slot
op_assign
id|error_func
suffix:semicolon
id|error
op_assign
id|error_slot
suffix:semicolon
)brace
multiline_comment|/* next func */
macro_line|#ifdef CONFIG_HOTPLUG_PCI_SGI
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_ne
id|ENODEV
)paren
op_logical_and
(paren
id|error
op_ne
id|EUNATCH
)paren
op_logical_and
(paren
id|error
op_ne
id|EPERM
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_INCMPLT
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|conn_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
id|pcibr_device_unregister
c_func
(paren
id|conn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_and_assign
op_complement
id|SLOT_STATUS_MASK
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|slot_status
op_or_assign
id|SLOT_SHUTDOWN_CMPLT
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_HOTPLUG_PCI_SGI */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_detach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific freeing that needs to be done.&n; */
r_int
DECL|function|pcibr_slot_detach
id|pcibr_slot_detach
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_int
id|drv_flags
comma
r_char
op_star
id|l1_msg
comma
r_int
op_star
id|sub_errorp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Call the device detach function */
id|error
op_assign
(paren
id|pcibr_slot_call_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
id|drv_flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|sub_errorp
)paren
op_star
id|sub_errorp
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|l1_msg
)paren
suffix:semicolon
r_return
id|PCI_SLOT_DRV_DETACH_ERR
suffix:semicolon
)brace
multiline_comment|/* Recalculate the RBARs for all the devices on the bus since we&squot;ve&n;     * just freed some up and some of the devices could use them.&n;     */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
r_int
id|tmp_slot
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_assign
id|NUM_RBAR
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_assign
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp_slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|tmp_slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|tmp_slot
)paren
(paren
r_void
)paren
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|tmp_slot
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_probe_slot_pic: read a config space word&n; * while trapping any errors; return zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
r_static
r_int
DECL|function|pcibr_probe_slot
id|pcibr_probe_slot
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|cfg_p
id|cfg
comma
r_int
op_star
id|valp
)paren
(brace
r_return
id|pcibr_probe_work
c_func
(paren
id|pcibr_soft
comma
(paren
r_void
op_star
)paren
id|cfg
comma
l_int|4
comma
(paren
r_void
op_star
)paren
id|valp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe an offset within a piomap with errors disabled.&n; * len must be 1, 2, 4, or 8.  &t;The probed address must be a multiple of&n; * len.&n; *&n; * Returns:&t;0&t;if the offset was probed and put valid data in valp&n; *&t;&t;-1&t;if there was a usage error such as improper alignment&n; *&t;&t;&t;or out of bounds offset/len combination.  In this&n; *&t;&t;&t;case, the map was not probed&n; *&t;&t;1 &t;if the offset was probed but resulted in an error&n; *&t;&t;&t;such as device not responding, bus error, etc.&n; */
r_int
DECL|function|pcibr_piomap_probe
id|pcibr_piomap_probe
c_func
(paren
id|pcibr_piomap_t
id|piomap
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_void
op_star
id|valp
)paren
(brace
r_if
c_cond
(paren
id|offset
op_plus
id|len
OG
id|piomap-&gt;bp_mapsz
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|pcibr_probe_work
c_func
(paren
id|piomap-&gt;bp_soft
comma
id|piomap-&gt;bp_kvaddr
op_plus
id|offset
comma
id|len
comma
id|valp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_probe_slot: read a config space word&n; * while trapping any errors; return zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
r_static
r_int
DECL|function|pcibr_probe_work
id|pcibr_probe_work
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_void
op_star
id|addr
comma
r_int
id|len
comma
r_void
op_star
id|valp
)paren
(brace
r_int
id|rv
suffix:semicolon
multiline_comment|/*&n;     * Sanity checks ...&n;     */
r_if
c_cond
(paren
id|len
op_ne
l_int|1
op_logical_and
id|len
op_ne
l_int|2
op_logical_and
id|len
op_ne
l_int|4
op_logical_and
id|len
op_ne
l_int|8
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalid len */
)brace
r_if
c_cond
(paren
(paren
r_uint64
)paren
id|addr
op_amp
(paren
id|len
op_minus
l_int|1
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalid alignment */
)brace
id|rv
op_assign
id|snia_badaddr_val
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
comma
id|len
comma
id|valp
)paren
suffix:semicolon
multiline_comment|/* Clear the int_view register incase it was set */
id|pcireg_intr_reset_set
c_func
(paren
id|pcibr_soft
comma
id|BRIDGE_IRR_MULTI_CLR
)paren
suffix:semicolon
r_return
(paren
id|rv
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* return 1 for snia_badaddr_val error, 0 if ok */
)brace
r_void
DECL|function|pcibr_device_info_free
id|pcibr_device_info_free
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|nfunc
op_assign
id|slotp-&gt;bss_ninfo
suffix:semicolon
r_int
id|bar
suffix:semicolon
r_int
id|devio_index
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|cmd_reg
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info
op_assign
id|slotp-&gt;bss_infos
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Disable memory and I/O BARs */
id|cfgw
op_assign
id|pcibr_func_config_addr
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|slot
comma
id|func
comma
l_int|0
)paren
suffix:semicolon
id|cmd_reg
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
)paren
suffix:semicolon
id|cmd_reg
op_and_assign
(paren
id|PCI_CMD_MEM_SPACE
op_or
id|PCI_CMD_IO_SPACE
)paren
suffix:semicolon
id|do_pcibr_config_set
c_func
(paren
id|cfgw
comma
id|PCI_CFG_COMMAND
comma
l_int|4
comma
id|cmd_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
id|bar
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_space
op_eq
id|PCIIO_SPACE_NONE
)paren
r_continue
suffix:semicolon
multiline_comment|/* Free the PCI bus space */
id|pcibr_bus_addr_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
)paren
suffix:semicolon
multiline_comment|/* Get index of the DevIO(x) register used to access this BAR */
id|devio_index
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_devio_index
suffix:semicolon
multiline_comment|/* On last use, clear the DevIO(x) used to access this BAR */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_ref_cnt
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_devio.bssd_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|devio_index
)braket
dot
id|bss_device
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Free the Expansion ROM PCI bus space */
r_if
c_cond
(paren
id|pcibr_info-&gt;f_rbase
op_logical_and
id|pcibr_info-&gt;f_rsize
)paren
(brace
id|pcibr_bus_addr_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_rwindow
)paren
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|slotp-&gt;bss_infos
(braket
id|func
)braket
op_assign
l_int|0
suffix:semicolon
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|pciio_device_info_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the mapping usage counters */
id|slotp-&gt;bss_pmu_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d64_uctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the Direct translation info */
id|slotp-&gt;bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
l_int|0
suffix:semicolon
)brace
id|iopaddr_t
DECL|function|pcibr_bus_addr_alloc
id|pcibr_bus_addr_alloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_win_info_t
id|win_info_p
comma
id|pciio_space_t
id|space
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|align
)paren
(brace
id|pciio_win_map_t
id|win_map_p
suffix:semicolon
r_struct
id|resource
op_star
id|root_resource
op_assign
l_int|NULL
suffix:semicolon
id|iopaddr_t
id|iopaddr
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_io_win_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_io_win_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_swin_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_swin_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
id|win_map_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_mem_win_map
suffix:semicolon
id|root_resource
op_assign
op_amp
id|pcibr_soft-&gt;bs_mem_win_root_resource
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|iopaddr
op_assign
id|pciio_device_win_alloc
c_func
(paren
id|root_resource
comma
id|win_info_p
ques
c_cond
op_amp
id|win_info_p-&gt;w_win_alloc
suffix:colon
l_int|NULL
comma
id|start
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_return
id|iopaddr
suffix:semicolon
)brace
r_void
DECL|function|pcibr_bus_addr_free
id|pcibr_bus_addr_free
c_func
(paren
id|pciio_win_info_t
id|win_info_p
)paren
(brace
id|pciio_device_win_free
c_func
(paren
op_amp
id|win_info_p-&gt;w_win_alloc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * given a vertex_hdl to the pcibr_vhdl, return the brick&squot;s bus number&n; * associated with that vertex_hdl.  The true mapping happens from the&n; * io_brick_tab[] array defined in ml/SN/iograph.c&n; */
r_int
DECL|function|pcibr_widget_to_bus
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|xwidgetnum_t
id|widget
op_assign
id|pcibr_soft-&gt;bs_xid
suffix:semicolon
r_int
id|bricktype
op_assign
id|pcibr_soft-&gt;bs_bricktype
suffix:semicolon
r_int
id|bus
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
op_assign
id|io_brick_map_widget
c_func
(paren
id|bricktype
comma
id|widget
)paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pcibr_widget_to_bus() bad bricktype %d&bslash;n&quot;
comma
id|bricktype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For PIC there are 2 busses per widget and pcibr_soft-&gt;bs_busnum&n;     * will be 0 or 1.  Add in the correct PIC bus offset.&n;     */
id|bus
op_add_assign
id|pcibr_soft-&gt;bs_busnum
suffix:semicolon
r_return
id|bus
suffix:semicolon
)brace
eof
