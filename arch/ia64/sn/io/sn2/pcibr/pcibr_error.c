multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_extern
r_int
id|hubii_check_widget_disabled
c_func
(paren
id|nasid_t
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    ERROR HANDLING&n; */
macro_line|#ifdef&t;DEBUG
macro_line|#ifdef&t;ERROR_DEBUG
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;100&t;/* Timeout with ERROR_DEBUG defined */
macro_line|#else
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;40&t;/* Timeout in debug mode  */
macro_line|#endif
macro_line|#else
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;1&t;/* Timeout in non-debug mode                            */
macro_line|#endif
multiline_comment|/* PIC has 64bit interrupt error registers, but BRIDGE has 32bit registers.&n; * Thus &squot;bridge_errors_to_dump needs&squot; to default to the larger of the two.&n; */
macro_line|#ifdef  DEBUG
macro_line|#ifdef ERROR_DEBUG
DECL|variable|bridge_errors_to_dump
r_uint64
id|bridge_errors_to_dump
op_assign
op_complement
id|BRIDGE_ISR_INT_MSK
suffix:semicolon
macro_line|#else
DECL|variable|bridge_errors_to_dump
r_uint64
id|bridge_errors_to_dump
op_assign
id|BRIDGE_ISR_ERROR_DUMP
suffix:semicolon
macro_line|#endif
macro_line|#else
DECL|variable|bridge_errors_to_dump
r_uint64
id|bridge_errors_to_dump
op_assign
id|BRIDGE_ISR_ERROR_FATAL
op_or
id|BRIDGE_ISR_PCIBUS_PIOERR
suffix:semicolon
macro_line|#endif
DECL|variable|pcibr_llp_control_war_cnt
r_int
id|pcibr_llp_control_war_cnt
suffix:semicolon
multiline_comment|/* PCIBR_LLP_CONTROL_WAR */
multiline_comment|/*&n; * register values&n; * map between numeric values and symbolic values&n; */
DECL|struct|reg_values
r_struct
id|reg_values
(brace
DECL|member|rv_value
r_int
r_int
r_int
id|rv_value
suffix:semicolon
DECL|member|rv_name
r_char
op_star
id|rv_name
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * register descriptors are used for formatted prints of register values&n; * rd_mask and rd_shift must be defined, other entries may be null&n; */
DECL|struct|reg_desc
r_struct
id|reg_desc
(brace
DECL|member|rd_mask
r_int
r_int
r_int
id|rd_mask
suffix:semicolon
multiline_comment|/* mask to extract field */
DECL|member|rd_shift
r_int
id|rd_shift
suffix:semicolon
multiline_comment|/* shift for extracted value, - &gt;&gt;, + &lt;&lt; */
DECL|member|rd_name
r_char
op_star
id|rd_name
suffix:semicolon
multiline_comment|/* field name */
DECL|member|rd_format
r_char
op_star
id|rd_format
suffix:semicolon
multiline_comment|/* format to print field */
DECL|member|rd_values
r_struct
id|reg_values
op_star
id|rd_values
suffix:semicolon
multiline_comment|/* symbolic names of values */
)brace
suffix:semicolon
multiline_comment|/* Crosstalk Packet Types */
DECL|variable|xtalk_cmd_pactyp
r_static
r_struct
id|reg_values
id|xtalk_cmd_pactyp
(braket
)braket
op_assign
(brace
(brace
l_int|0x0
comma
l_string|&quot;RdReq&quot;
)brace
comma
(brace
l_int|0x1
comma
l_string|&quot;RdResp&quot;
)brace
comma
(brace
l_int|0x2
comma
l_string|&quot;WrReqWithResp&quot;
)brace
comma
(brace
l_int|0x3
comma
l_string|&quot;WrResp&quot;
)brace
comma
(brace
l_int|0x4
comma
l_string|&quot;WrReqNoResp&quot;
)brace
comma
(brace
l_int|0x5
comma
l_string|&quot;Reserved(5)&quot;
)brace
comma
(brace
l_int|0x6
comma
l_string|&quot;FetchAndOp&quot;
)brace
comma
(brace
l_int|0x7
comma
l_string|&quot;Reserved(7)&quot;
)brace
comma
(brace
l_int|0x8
comma
l_string|&quot;StoreAndOp&quot;
)brace
comma
(brace
l_int|0x9
comma
l_string|&quot;Reserved(9)&quot;
)brace
comma
(brace
l_int|0xa
comma
l_string|&quot;Reserved(a)&quot;
)brace
comma
(brace
l_int|0xb
comma
l_string|&quot;Reserved(b)&quot;
)brace
comma
(brace
l_int|0xc
comma
l_string|&quot;Reserved(c)&quot;
)brace
comma
(brace
l_int|0xd
comma
l_string|&quot;Reserved(d)&quot;
)brace
comma
(brace
l_int|0xe
comma
l_string|&quot;SpecialReq&quot;
)brace
comma
(brace
l_int|0xf
comma
l_string|&quot;SpecialResp&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|xtalk_cmd_bits
r_static
r_struct
id|reg_desc
id|xtalk_cmd_bits
(braket
)braket
op_assign
(brace
(brace
id|WIDGET_DIDN
comma
op_minus
l_int|28
comma
l_string|&quot;DIDN&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_SIDN
comma
op_minus
l_int|24
comma
l_string|&quot;SIDN&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_PACTYP
comma
op_minus
l_int|20
comma
l_string|&quot;PACTYP&quot;
comma
l_int|0
comma
id|xtalk_cmd_pactyp
)brace
comma
(brace
id|WIDGET_TNUM
comma
op_minus
l_int|15
comma
l_string|&quot;TNUM&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_COHERENT
comma
l_int|0
comma
l_string|&quot;COHERENT&quot;
)brace
comma
(brace
id|WIDGET_DS
comma
l_int|0
comma
l_string|&quot;DS&quot;
)brace
comma
(brace
id|WIDGET_GBR
comma
l_int|0
comma
l_string|&quot;GBR&quot;
)brace
comma
(brace
id|WIDGET_VBPM
comma
l_int|0
comma
l_string|&quot;VBPM&quot;
)brace
comma
(brace
id|WIDGET_ERROR
comma
l_int|0
comma
l_string|&quot;ERROR&quot;
)brace
comma
(brace
id|WIDGET_BARRIER
comma
l_int|0
comma
l_string|&quot;BARRIER&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|F
mdefine_line|#define F(s,n)          { 1l&lt;&lt;(s),-(s), n }
DECL|variable|space_v
r_static
r_struct
id|reg_values
id|space_v
(braket
)braket
op_assign
(brace
(brace
id|PCIIO_SPACE_NONE
comma
l_string|&quot;none&quot;
)brace
comma
(brace
id|PCIIO_SPACE_ROM
comma
l_string|&quot;ROM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_IO
comma
l_string|&quot;I/O&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM
comma
l_string|&quot;MEM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM32
comma
l_string|&quot;MEM(32)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM64
comma
l_string|&quot;MEM(64)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_CFG
comma
l_string|&quot;CFG&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
comma
l_string|&quot;WIN(0)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|1
)paren
comma
l_string|&quot;WIN(1)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|2
)paren
comma
l_string|&quot;WIN(2)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|3
)paren
comma
l_string|&quot;WIN(3)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|4
)paren
comma
l_string|&quot;WIN(4)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|5
)paren
comma
l_string|&quot;WIN(5)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_BAD
comma
l_string|&quot;BAD&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|space_desc
r_static
r_struct
id|reg_desc
id|space_desc
(braket
)braket
op_assign
(brace
(brace
l_int|0xFF
comma
l_int|0
comma
l_string|&quot;space&quot;
comma
l_int|0
comma
id|space_v
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|device_desc
mdefine_line|#define&t;device_desc&t;device_bits
DECL|variable|device_bits
r_static
r_struct
id|reg_desc
id|device_bits
(braket
)braket
op_assign
(brace
(brace
id|BRIDGE_DEV_ERR_LOCK_EN
comma
l_int|0
comma
l_string|&quot;ERR_LOCK_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PAGE_CHK_DIS
comma
l_int|0
comma
l_string|&quot;PAGE_CHK_DIS&quot;
)brace
comma
(brace
id|BRIDGE_DEV_FORCE_PCI_PAR
comma
l_int|0
comma
l_string|&quot;FORCE_PCI_PAR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_VIRTUAL_EN
comma
l_int|0
comma
l_string|&quot;VIRTUAL_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PMU_WRGA_EN
comma
l_int|0
comma
l_string|&quot;PMU_WRGA_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DIR_WRGA_EN
comma
l_int|0
comma
l_string|&quot;DIR_WRGA_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_SIZE
comma
l_int|0
comma
l_string|&quot;DEV_SIZE&quot;
)brace
comma
(brace
id|BRIDGE_DEV_RT
comma
l_int|0
comma
l_string|&quot;RT&quot;
)brace
comma
(brace
id|BRIDGE_DEV_SWAP_PMU
comma
l_int|0
comma
l_string|&quot;SWAP_PMU&quot;
)brace
comma
(brace
id|BRIDGE_DEV_SWAP_DIR
comma
l_int|0
comma
l_string|&quot;SWAP_DIR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PREF
comma
l_int|0
comma
l_string|&quot;PREF&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PRECISE
comma
l_int|0
comma
l_string|&quot;PRECISE&quot;
)brace
comma
(brace
id|BRIDGE_DEV_COH
comma
l_int|0
comma
l_string|&quot;COH&quot;
)brace
comma
(brace
id|BRIDGE_DEV_BARRIER
comma
l_int|0
comma
l_string|&quot;BARRIER&quot;
)brace
comma
(brace
id|BRIDGE_DEV_GBR
comma
l_int|0
comma
l_string|&quot;GBR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_SWAP
comma
l_int|0
comma
l_string|&quot;DEV_SWAP&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_IO_MEM
comma
l_int|0
comma
l_string|&quot;DEV_IO_MEM&quot;
)brace
comma
(brace
id|BRIDGE_DEV_OFF_MASK
comma
id|BRIDGE_DEV_OFF_ADDR_SHFT
comma
l_string|&quot;DEV_OFF&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pcibr_isr_errs
r_static
r_char
op_star
id|pcibr_isr_errs
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;08: Reserved Bit 08&quot;
comma
l_string|&quot;09: PCI to Crosstalk read request timeout&quot;
comma
l_string|&quot;10: PCI retry operation count exhausted.&quot;
comma
l_string|&quot;11: PCI bus device select timeout&quot;
comma
l_string|&quot;12: PCI device reported parity error&quot;
comma
l_string|&quot;13: PCI Address/Cmd parity error &quot;
comma
l_string|&quot;14: PCI Bridge detected parity error&quot;
comma
l_string|&quot;15: PCI abort condition&quot;
comma
l_string|&quot;16: Reserved Bit 16&quot;
comma
l_string|&quot;17: LLP Transmitter Retry count wrapped&quot;
comma
multiline_comment|/* PIC ONLY */
l_string|&quot;18: LLP Transmitter side required Retry&quot;
comma
multiline_comment|/* PIC ONLY */
l_string|&quot;19: LLP Receiver retry count wrapped&quot;
comma
multiline_comment|/* PIC ONLY */
l_string|&quot;20: LLP Receiver check bit error&quot;
comma
multiline_comment|/* PIC ONLY */
l_string|&quot;21: LLP Receiver sequence number error&quot;
comma
multiline_comment|/* PIC ONLY */
l_string|&quot;22: Request packet overflow&quot;
comma
l_string|&quot;23: Request operation not supported by bridge&quot;
comma
l_string|&quot;24: Request packet has invalid address for bridge widget&quot;
comma
l_string|&quot;25: Incoming request xtalk command word error bit set or invalid sideband&quot;
comma
l_string|&quot;26: Incoming response xtalk command word error bit set or invalid sideband&quot;
comma
l_string|&quot;27: Framing error, request cmd data size does not match actual&quot;
comma
l_string|&quot;28: Framing error, response cmd data size does not match actual&quot;
comma
l_string|&quot;29: Unexpected response arrived&quot;
comma
l_string|&quot;30: PMU Access Fault&quot;
comma
l_string|&quot;31: Reserved Bit 31&quot;
comma
l_string|&quot;32: PCI-X address or attribute cycle parity error&quot;
comma
l_string|&quot;33: PCI-X data cycle parity error&quot;
comma
l_string|&quot;34: PCI-X master timeout (ie. master abort)&quot;
comma
l_string|&quot;35: PCI-X pio retry counter exhausted&quot;
comma
l_string|&quot;36: PCI-X SERR&quot;
comma
l_string|&quot;37: PCI-X PERR&quot;
comma
l_string|&quot;38: PCI-X target abort&quot;
comma
l_string|&quot;39: PCI-X read request timeout&quot;
comma
l_string|&quot;40: PCI / PCI-X device requestin arbitration error&quot;
comma
l_string|&quot;41: internal RAM parity error&quot;
comma
l_string|&quot;42: PCI-X unexpected completion cycle to master&quot;
comma
l_string|&quot;43: PCI-X split completion timeout&quot;
comma
l_string|&quot;44: PCI-X split completion error message&quot;
comma
l_string|&quot;45: PCI-X split completion message parity error&quot;
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * print_register() allows formatted printing of bit fields.  individual&n; * bit fields are described by a struct reg_desc, multiple bit fields within&n; * a single word can be described by multiple reg_desc structures.&n; * %r outputs a string of the format &quot;&lt;bit field descriptions&gt;&quot;&n; * %R outputs a string of the format &quot;0x%x&lt;bit field descriptions&gt;&quot;&n; *&n; * The fields in a reg_desc are:&n; *&t;unsigned long long rd_mask; An appropriate mask to isolate the bit field&n; *&t;&t;&t;&t;within a word, and&squot;ed with val&n; *&n; *&t;int rd_shift;&t;&t;A shift amount to be done to the isolated&n; *&t;&t;&t;&t;bit field.  done before printing the isolate&n; *&t;&t;&t;&t;bit field with rd_format and before searching&n; *&t;&t;&t;&t;for symbolic value names in rd_values&n; *&n; *&t;char *rd_name;&t;&t;If non-null, a bit field name to label any&n; *&t;&t;&t;&t;out from rd_format or searching rd_values.&n; *&t;&t;&t;&t;if neither rd_format or rd_values is non-null&n; *&t;&t;&t;&t;rd_name is printed only if the isolated&n; *&t;&t;&t;&t;bit field is non-null.&n; *&n; *&t;char *rd_format;&t;If non-null, the shifted bit field value&n; *&t;&t;&t;&t;is printed using this format.&n; *&n; *&t;struct reg_values *rd_values;&t;If non-null, a pointer to a table&n; *&t;&t;&t;&t;matching numeric values with symbolic names.&n; *&t;&t;&t;&t;rd_values are searched and the symbolic&n; *&t;&t;&t;&t;value is printed if a match is found, if no&n; *&t;&t;&t;&t;match is found &quot;???&quot; is printed.&n; *&t;&t;&t;&t;&n; */
r_static
r_void
DECL|function|print_register
id|print_register
c_func
(paren
r_int
r_int
r_int
id|reg
comma
r_struct
id|reg_desc
op_star
id|addr
)paren
(brace
r_register
r_struct
id|reg_desc
op_star
id|rd
suffix:semicolon
r_register
r_struct
id|reg_values
op_star
id|rv
suffix:semicolon
r_int
r_int
r_int
id|field
suffix:semicolon
r_int
id|any
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|any
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rd
op_assign
id|addr
suffix:semicolon
id|rd-&gt;rd_mask
suffix:semicolon
id|rd
op_increment
)paren
(brace
id|field
op_assign
id|reg
op_amp
id|rd-&gt;rd_mask
suffix:semicolon
id|field
op_assign
(paren
id|rd-&gt;rd_shift
OG
l_int|0
)paren
ques
c_cond
id|field
op_lshift
id|rd-&gt;rd_shift
suffix:colon
id|field
op_rshift
op_minus
id|rd-&gt;rd_shift
suffix:semicolon
r_if
c_cond
(paren
id|any
op_logical_and
(paren
id|rd-&gt;rd_format
op_logical_or
id|rd-&gt;rd_values
op_logical_or
(paren
id|rd-&gt;rd_name
op_logical_and
id|field
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rd-&gt;rd_name
)paren
(brace
r_if
c_cond
(paren
id|rd-&gt;rd_format
op_logical_or
id|rd-&gt;rd_values
op_logical_or
id|field
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|rd-&gt;rd_name
)paren
suffix:semicolon
id|any
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rd-&gt;rd_format
op_logical_or
id|rd-&gt;rd_values
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|any
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* You can have any format so long as it is %x */
r_if
c_cond
(paren
id|rd-&gt;rd_format
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%llx&quot;
comma
id|field
)paren
suffix:semicolon
id|any
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rd-&gt;rd_values
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rd-&gt;rd_values
)paren
(brace
id|any
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|rv
op_assign
id|rd-&gt;rd_values
suffix:semicolon
id|rv-&gt;rv_name
suffix:semicolon
id|rv
op_increment
)paren
(brace
r_if
c_cond
(paren
id|field
op_eq
id|rv-&gt;rv_value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|rv-&gt;rv_name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rv-&gt;rv_name
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;???&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|BEM_ADD_STR
mdefine_line|#define BEM_ADD_STR(s)  printk(&quot;%s&quot;, (s))
DECL|macro|BEM_ADD_VAR
mdefine_line|#define BEM_ADD_VAR(v)  printk(&quot;&bslash;t%20s: 0x%llx&bslash;n&quot;, #v, ((unsigned long long)v))
DECL|macro|BEM_ADD_REG
mdefine_line|#define BEM_ADD_REG(r)  printk(&quot;&bslash;t%20s: &quot;, #r); print_register((r), r ## _desc)
DECL|macro|BEM_ADD_NSPC
mdefine_line|#define BEM_ADD_NSPC(n,s)       printk(&quot;&bslash;t%20s: &quot;, n); print_register(s, space_desc)
DECL|macro|BEM_ADD_SPC
mdefine_line|#define BEM_ADD_SPC(s)          BEM_ADD_NSPC(#s, s)
multiline_comment|/*&n; * display memory directory state&n; */
r_static
r_void
DECL|function|pcibr_show_dir_state
id|pcibr_show_dir_state
c_func
(paren
id|paddr_t
id|paddr
comma
r_char
op_star
id|prefix
)paren
(brace
macro_line|#ifdef LATER
r_int
id|state
suffix:semicolon
r_uint64
id|vec_ptr
suffix:semicolon
id|hubreg_t
id|elo
suffix:semicolon
r_extern
r_char
op_star
id|dir_state_str
(braket
)braket
suffix:semicolon
r_extern
r_void
id|get_dir_ent
c_func
(paren
id|paddr_t
comma
r_int
op_star
comma
r_uint64
op_star
comma
id|hubreg_t
op_star
)paren
suffix:semicolon
id|get_dir_ent
c_func
(paren
id|paddr
comma
op_amp
id|state
comma
op_amp
id|vec_ptr
comma
op_amp
id|elo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%saddr 0x%lx: state 0x%x owner 0x%lx (%s)&bslash;n&quot;
comma
id|prefix
comma
id|paddr
comma
id|state
comma
id|vec_ptr
comma
id|dir_state_str
(braket
id|state
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|print_bridge_errcmd
id|print_bridge_errcmd
c_func
(paren
r_uint32
id|cmdword
comma
r_char
op_star
id|errtype
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t    Bridge %s Error Command Word Register &quot;
comma
id|errtype
)paren
suffix:semicolon
id|print_register
c_func
(paren
id|cmdword
comma
id|xtalk_cmd_bits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Dump relevant error information for Bridge error interrupts.&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_error_dump
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_uint64
id|int_status
suffix:semicolon
id|picreg_t
id|int_status_64
suffix:semicolon
r_uint64
id|mult_int
suffix:semicolon
id|picreg_t
id|mult_int_64
suffix:semicolon
r_uint64
id|bit
suffix:semicolon
r_int
id|number_bits
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|reg_desc
suffix:semicolon
id|paddr_t
id|addr
op_assign
(paren
id|paddr_t
)paren
l_int|0
suffix:semicolon
id|int_status_64
op_assign
(paren
id|bridge-&gt;p_int_status_64
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
suffix:semicolon
id|int_status
op_assign
(paren
r_uint64
)paren
id|int_status_64
suffix:semicolon
id|number_bits
op_assign
id|PCIBR_ISR_MAX_ERRS_PIC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|int_status
)paren
(brace
multiline_comment|/* No error bits set */
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if dumping the same error information multiple times */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_errinfo.bserr_intstat
op_eq
id|int_status
)paren
r_return
suffix:semicolon
id|pcibr_soft-&gt;bs_errinfo.bserr_intstat
op_assign
id|int_status
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;PCI BRIDGE ERROR: int_status is 0x%lx for %s&bslash;n&quot;
l_string|&quot;    Dumping relevant %s registers for each bit set...&bslash;n&quot;
comma
id|int_status
comma
id|pcibr_soft-&gt;bs_name
comma
l_string|&quot;PIC&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PCIBR_ISR_ERR_START
suffix:semicolon
id|i
OL
id|number_bits
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bit
op_assign
l_int|1ull
op_lshift
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * A number of int_status bits are only defined for Bridge.&n;&t; * Ignore them in the case of an XBridge or PIC.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|bit
op_eq
id|BRIDGE_ISR_MULTI_ERR
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_SSRAM_PERR
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_GIO_B_ENBL_ERR
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* A number of int_status bits are only valid for PIC&squot;s bus0 */
r_if
c_cond
(paren
(paren
(paren
id|pcibr_soft-&gt;bs_busnum
op_ne
l_int|0
)paren
)paren
op_logical_and
(paren
(paren
id|bit
op_eq
id|BRIDGE_ISR_UNSUPPORTED_XOP
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_LLP_REC_SNERR
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_LLP_REC_CBERR
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_LLP_RCTY
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_LLP_TX_RETRY
)paren
op_logical_or
(paren
id|bit
op_eq
id|BRIDGE_ISR_LLP_TCTY
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_status
op_amp
id|bit
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|pcibr_isr_errs
(braket
id|i
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit
)paren
(brace
r_case
id|PIC_ISR_INT_RAM_PERR
suffix:colon
multiline_comment|/* bit41&t;INT_RAM_PERR */
multiline_comment|/* XXX: should breakdown meaning of bits in reg */
id|printk
c_func
(paren
l_string|&quot;&bslash;t&t;Internal RAM Parity Error: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_ate_parity_err_64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIC_ISR_PCIX_ARB_ERR
suffix:colon
multiline_comment|/* bit40&t;PCI_X_ARB_ERR */
multiline_comment|/* XXX: should breakdown meaning of bits in reg */
id|printk
c_func
(paren
l_string|&quot;&bslash;t&t;Arbitration Reg: 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_arb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIC_ISR_PCIX_REQ_TOUT
suffix:colon
multiline_comment|/* bit39&t;PCI_X_REQ_TOUT */
multiline_comment|/* XXX: should breakdown meaning of attribute bit */
id|printk
c_func
(paren
l_string|&quot;&bslash;t&t;   PCI-X DMA Request Error Address Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t&t;   PCI-X DMA Request Error Attribute Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_pcix_dma_req_err_addr_64
comma
id|bridge-&gt;p_pcix_dma_req_err_attr_64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIC_ISR_PCIX_SPLIT_MSG_PE
suffix:colon
multiline_comment|/* bit45&t;PCI_X_SPLIT_MES_PE */
r_case
id|PIC_ISR_PCIX_SPLIT_EMSG
suffix:colon
multiline_comment|/* bit44&t;PCI_X_SPLIT_EMESS */
r_case
id|PIC_ISR_PCIX_SPLIT_TO
suffix:colon
multiline_comment|/* bit43&t;PCI_X_SPLIT_TO */
multiline_comment|/* XXX: should breakdown meaning of attribute bit */
id|printk
c_func
(paren
l_string|&quot;&bslash;t&t;   PCI-X Split Request Address Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t&t;   PCI-X Split Request Attribute Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_pcix_pio_split_addr_64
comma
id|bridge-&gt;p_pcix_pio_split_attr_64
)paren
suffix:semicolon
multiline_comment|/* FALL THRU */
r_case
id|PIC_ISR_PCIX_UNEX_COMP
suffix:colon
multiline_comment|/* bit42&t;PCI_X_UNEX_COMP */
r_case
id|PIC_ISR_PCIX_TABORT
suffix:colon
multiline_comment|/* bit38&t;PCI_X_TABORT */
r_case
id|PIC_ISR_PCIX_PERR
suffix:colon
multiline_comment|/* bit37&t;PCI_X_PERR */
r_case
id|PIC_ISR_PCIX_SERR
suffix:colon
multiline_comment|/* bit36&t;PCI_X_SERR */
r_case
id|PIC_ISR_PCIX_MRETRY
suffix:colon
multiline_comment|/* bit35&t;PCI_X_MRETRY */
r_case
id|PIC_ISR_PCIX_MTOUT
suffix:colon
multiline_comment|/* bit34&t;PCI_X_MTOUT */
r_case
id|PIC_ISR_PCIX_DA_PARITY
suffix:colon
multiline_comment|/* bit33&t;PCI_X_DA_PARITY */
r_case
id|PIC_ISR_PCIX_AD_PARITY
suffix:colon
multiline_comment|/* bit32&t;PCI_X_AD_PARITY */
multiline_comment|/* XXX: should breakdown meaning of attribute bit */
id|printk
c_func
(paren
l_string|&quot;&bslash;t&t;   PCI-X Bus Error Address Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t&t;   PCI-X Bus Error Attribute Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t&t;   PCI-X Bus Error Data Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_pcix_bus_err_addr_64
comma
id|bridge-&gt;p_pcix_bus_err_attr_64
comma
id|bridge-&gt;p_pcix_bus_err_data_64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_PAGE_FAULT
suffix:colon
multiline_comment|/* bit30&t;PMU_PAGE_FAULT */
id|reg_desc
op_assign
l_string|&quot;Map Fault Address&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t    %s Register: 0x%x&bslash;n&quot;
comma
id|reg_desc
comma
id|bridge-&gt;b_ram_perr_or_map_fault
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_UNEXP_RESP
suffix:colon
multiline_comment|/* bit29&t;UNEXPECTED_RESP */
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_aux_err
comma
l_string|&quot;Aux &quot;
)paren
suffix:semicolon
multiline_comment|/* PIC in PCI-X mode, dump the PCIX DMA Request registers */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
multiline_comment|/* XXX: should breakdown meaning of attr bit */
id|printk
c_func
(paren
l_string|&quot;&bslash;t    PCI-X DMA Request Error Addr Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    PCI-X DMA Request Error Attr Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_pcix_dma_req_err_addr_64
comma
id|bridge-&gt;p_pcix_dma_req_err_attr_64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_BAD_XRESP_PKT
suffix:colon
multiline_comment|/* bit28&t;BAD_RESP_PACKET */
r_case
id|BRIDGE_ISR_RESP_XTLK_ERR
suffix:colon
multiline_comment|/* bit26&t;RESP_XTALK_ERROR */
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_aux_err
comma
l_string|&quot;Aux &quot;
)paren
suffix:semicolon
multiline_comment|/* XXX: should breakdown meaning of attribute bit */
id|printk
c_func
(paren
l_string|&quot;&bslash;t    PCI-X DMA Request Error Addr Reg: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    PCI-X DMA Request Error Attribute Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_pcix_dma_req_err_addr_64
comma
id|bridge-&gt;p_pcix_dma_req_err_attr_64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_eq
id|BRIDGE_ISR_RESP_XTLK_ERR
)paren
(brace
multiline_comment|/* display memory directory associated with cacheline */
id|pcibr_show_dir_state
c_func
(paren
id|addr
comma
l_string|&quot;&bslash;t    &quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_BAD_XREQ_PKT
suffix:colon
multiline_comment|/* bit27&t;BAD_XREQ_PACKET */
r_case
id|BRIDGE_ISR_REQ_XTLK_ERR
suffix:colon
multiline_comment|/* bit25&t;REQ_XTALK_ERROR */
r_case
id|BRIDGE_ISR_INVLD_ADDR
suffix:colon
multiline_comment|/* bit24&t;INVALID_ADDRESS */
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_err_cmdword
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t    Bridge Error Upper Address Register: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    Bridge Error Lower Address Register: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    Bridge Error Address: 0x%lx&bslash;n&quot;
comma
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_upper
comma
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_lower
comma
(paren
(paren
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_upper
op_lshift
l_int|32
)paren
op_or
id|bridge-&gt;b_wid_err_lower
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_UNSUPPORTED_XOP
suffix:colon
multiline_comment|/* bit23&t;UNSUPPORTED_XOP */
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_aux_err
comma
l_string|&quot;Aux &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t    Address Holding Link Side Error Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_addr_lkerr_64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_XREQ_FIFO_OFLOW
suffix:colon
multiline_comment|/* bit22&t;XREQ_FIFO_OFLOW */
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_aux_err
comma
l_string|&quot;Aux &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t    Address Holding Link Side Error Reg: 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;p_addr_lkerr_64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_PCI_ABORT
suffix:colon
multiline_comment|/* bit15&t;PCI_ABORT */
r_case
id|BRIDGE_ISR_PCI_PARITY
suffix:colon
multiline_comment|/* bit14&t;PCI_PARITY */
r_case
id|BRIDGE_ISR_PCI_SERR
suffix:colon
multiline_comment|/* bit13&t;PCI_SERR */
r_case
id|BRIDGE_ISR_PCI_PERR
suffix:colon
multiline_comment|/* bit12&t;PCI_PERR */
r_case
id|BRIDGE_ISR_PCI_MST_TIMEOUT
suffix:colon
multiline_comment|/* bit11&t;PCI_MASTER_TOUT */
r_case
id|BRIDGE_ISR_PCI_RETRY_CNT
suffix:colon
multiline_comment|/* bit10&t;PCI_RETRY_CNT */
r_case
id|BRIDGE_ISR_GIO_B_ENBL_ERR
suffix:colon
multiline_comment|/* bit08&t;GIO BENABLE_ERR */
id|printk
c_func
(paren
l_string|&quot;&bslash;t    PCI Error Upper Address Register: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    PCI Error Lower Address Register: 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;t    PCI Error Address: 0x%lx&bslash;n&quot;
comma
(paren
r_uint64
)paren
id|bridge-&gt;b_pci_err_upper
comma
(paren
r_uint64
)paren
id|bridge-&gt;b_pci_err_lower
comma
(paren
(paren
(paren
r_uint64
)paren
id|bridge-&gt;b_pci_err_upper
op_lshift
l_int|32
)paren
op_or
id|bridge-&gt;b_pci_err_lower
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRIDGE_ISR_XREAD_REQ_TIMEOUT
suffix:colon
multiline_comment|/* bit09&t;XREAD_REQ_TOUT */
id|addr
op_assign
(paren
(paren
(paren
r_uint64
)paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_amp
l_int|0xFFFF
)paren
op_lshift
l_int|32
)paren
op_or
id|bridge-&gt;b_wid_resp_lower
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t    Bridge Response Buf Error Upper Addr Reg: 0x%x&bslash;n&quot;
l_string|&quot;&bslash;t    Bridge Response Buf Error Lower Addr Reg: 0x%x&bslash;n&quot;
l_string|&quot;&bslash;t    dev-num %d buff-num %d addr 0x%lx&bslash;n&quot;
comma
id|bridge-&gt;b_wid_resp_upper
comma
id|bridge-&gt;b_wid_resp_lower
comma
(paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_rshift
l_int|20
)paren
op_amp
l_int|0x3
)paren
comma
(paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_rshift
l_int|16
)paren
op_amp
l_int|0xF
)paren
comma
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|mult_int_64
op_assign
(paren
id|bridge-&gt;p_mult_int_64
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
suffix:semicolon
id|mult_int
op_assign
(paren
r_uint64
)paren
id|mult_int_64
suffix:semicolon
id|number_bits
op_assign
id|PCIBR_ISR_MAX_ERRS_PIC
suffix:semicolon
r_if
c_cond
(paren
id|mult_int
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    %s Multiple Interrupt Register is 0x%lx&bslash;n&quot;
comma
l_string|&quot;PIC&quot;
comma
id|mult_int
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PCIBR_ISR_ERR_START
suffix:semicolon
id|i
OL
id|number_bits
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mult_int
op_amp
(paren
l_int|1ull
op_lshift
id|i
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|pcibr_isr_errs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* pcibr_pioerr_check():&n; *&t;Check to see if this pcibr has a PCI PIO&n; *&t;TIMEOUT error; if so, bump the timeout-count&n; *&t;on any piomaps that could cover the address.&n; */
r_static
r_void
DECL|function|pcibr_pioerr_check
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft_t
id|soft
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_uint64
id|int_status
suffix:semicolon
id|picreg_t
id|int_status_64
suffix:semicolon
id|bridgereg_t
id|pci_err_lower
suffix:semicolon
id|bridgereg_t
id|pci_err_upper
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_piomap_t
id|map
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|win
suffix:semicolon
r_int
id|func
suffix:semicolon
id|bridge
op_assign
id|soft-&gt;bs_base
suffix:semicolon
id|int_status_64
op_assign
(paren
id|bridge-&gt;p_int_status_64
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
suffix:semicolon
id|int_status
op_assign
(paren
r_uint64
)paren
id|int_status_64
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
(brace
id|pci_err_lower
op_assign
id|bridge-&gt;b_pci_err_lower
suffix:semicolon
id|pci_err_upper
op_assign
id|bridge-&gt;b_pci_err_upper
suffix:semicolon
id|pci_addr
op_assign
id|pci_err_upper
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
suffix:semicolon
id|pci_addr
op_assign
(paren
id|pci_addr
op_lshift
l_int|32
)paren
op_or
id|pci_err_lower
suffix:semicolon
id|slot
op_assign
id|PCIBR_NUM_SLOTS
c_func
(paren
id|soft
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|nfunc
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|pcibr_info-&gt;f_piomap
suffix:semicolon
id|map
op_ne
l_int|NULL
suffix:semicolon
id|map
op_assign
id|map-&gt;bp_next
)paren
(brace
id|base
op_assign
id|map-&gt;bp_pciaddr
suffix:semicolon
id|size
op_assign
id|map-&gt;bp_mapsz
suffix:semicolon
id|win
op_assign
id|map-&gt;bp_space
op_minus
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win
OL
l_int|6
)paren
id|base
op_add_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_window
(braket
id|win
)braket
dot
id|bssw_base
suffix:semicolon
r_else
r_if
c_cond
(paren
id|map-&gt;bp_space
op_eq
id|PCIIO_SPACE_ROM
)paren
id|base
op_add_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_addr
op_ge
id|base
)paren
op_logical_and
(paren
id|pci_addr
OL
(paren
id|base
op_plus
id|size
)paren
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|map-&gt;bp_toc
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * PCI Bridge Error interrupt handler.&n; *      This gets invoked, whenever a PCI bridge sends an error interrupt.&n; *      Primarily this servers two purposes.&n; *              - If an error can be handled (typically a PIO read/write&n; *                error, we try to do it silently.&n; *              - If an error cannot be handled, we die violently.&n; *      Interrupt due to PIO errors:&n; *              - Bridge sends an interrupt, whenever a PCI operation&n; *                done by the bridge as the master fails. Operations could&n; *                be either a PIO read or a PIO write.&n; *                PIO Read operation also triggers a bus error, and it&squot;s&n; *                We primarily ignore this interrupt in that context..&n; *                For PIO write errors, this is the only indication.&n; *                and we have to handle with the info from here.&n; *&n; *                So, there is no way to distinguish if an interrupt is&n; *                due to read or write error!.&n; */
r_void
DECL|function|pcibr_error_intr_handler
id|pcibr_error_intr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_uint64
id|int_status
suffix:semicolon
r_uint64
id|err_status
suffix:semicolon
id|picreg_t
id|int_status_64
suffix:semicolon
r_int
id|number_bits
suffix:semicolon
r_int
id|i
suffix:semicolon
r_uint64
id|disable_errintr_mask
op_assign
l_int|0
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
macro_line|#if PCIBR_SOFT_LIST
multiline_comment|/*&n;     * Defensive code for linked pcibr_soft structs&n;     */
(brace
r_extern
id|pcibr_list_p
id|pcibr_list
suffix:semicolon
id|pcibr_list_p
id|entry
suffix:semicolon
id|entry
op_assign
id|pcibr_list
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|PRINT_PANIC
c_func
(paren
l_string|&quot;pcibr_error_intr_handler:&bslash;tmy parameter (0x%p) is not a pcibr_soft!&quot;
comma
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|intr_arg_t
)paren
id|entry-&gt;bl_soft
op_eq
id|arg
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|entry-&gt;bl_next
suffix:semicolon
)brace
)brace
macro_line|#endif /* PCIBR_SOFT_LIST */
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|arg
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/*&n;     * pcibr_error_intr_handler gets invoked whenever bridge encounters&n;     * an error situation, and the interrupt for that error is enabled.&n;     * This routine decides if the error is fatal or not, and takes&n;     * action accordingly.&n;     *&n;     * In the case of PIO read/write timeouts, there is no way&n;     * to know if it was a read or write request that timed out.&n;     * If the error was due to a &quot;read&quot;, a bus error will also occur&n;     * and the bus error handling code takes care of it. &n;     * If the error is due to a &quot;write&quot;, the error is currently logged &n;     * by this routine. For SN1 and SN0, if fire-and-forget mode is &n;     * disabled, a write error response xtalk packet will be sent to &n;     * the II, which will cause an II error interrupt. No write error &n;     * recovery actions of any kind currently take place at the pcibr &n;     * layer! (e.g., no panic on unrecovered write error)&n;     *&n;     * Prior to reading the Bridge int_status register we need to ensure&n;     * that there are no error bits set in the lower layers (hubii)&n;     * that have disabled PIO access to the widget. If so, there is nothing&n;     * we can do until the bits clear, so we setup a timeout and try again&n;     * later.&n;     */
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|bridge
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hubii_check_widget_disabled
c_func
(paren
id|nasid
comma
id|pcibr_soft-&gt;bs_xid
)paren
)paren
(brace
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wq
)paren
suffix:semicolon
id|sleep_on_timeout
c_func
(paren
op_amp
id|wq
comma
id|BRIDGE_PIOERR_TIMEOUT
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* sleep */
id|pcibr_soft-&gt;bs_errinfo.bserr_toutcnt
op_increment
suffix:semicolon
multiline_comment|/* Let&squot;s go recursive */
r_return
id|pcibr_error_intr_handler
c_func
(paren
id|irq
comma
id|arg
comma
id|ep
)paren
suffix:semicolon
)brace
id|int_status_64
op_assign
(paren
id|bridge-&gt;p_int_status_64
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
suffix:semicolon
id|int_status
op_assign
(paren
r_uint64
)paren
id|int_status_64
suffix:semicolon
id|number_bits
op_assign
id|PCIBR_ISR_MAX_ERRS_PIC
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ERROR
comma
id|pcibr_soft-&gt;bs_conn
comma
l_string|&quot;pcibr_error_intr_handler: int_status=0x%x&bslash;n&quot;
comma
id|int_status
)paren
)paren
suffix:semicolon
multiline_comment|/* int_status is which bits we have to clear;&n;     * err_status is the bits we haven&squot;t handled yet.&n;     */
id|err_status
op_assign
id|int_status
op_amp
op_complement
id|BRIDGE_ISR_MULTI_ERR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|int_status
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
)paren
(brace
multiline_comment|/*&n;&t; * No error bit set!!.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we have a PCIBUS_PIOERR, hand it to the logger.&n;     */
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
(brace
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err_status
)paren
(brace
r_struct
id|bs_errintr_stat_s
op_star
id|bs_estat
op_assign
id|pcibr_soft-&gt;bs_errintr_stat
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PCIBR_ISR_ERR_START
suffix:semicolon
id|i
OL
id|number_bits
suffix:semicolon
id|i
op_increment
comma
id|bs_estat
op_increment
)paren
(brace
r_if
c_cond
(paren
id|err_status
op_amp
(paren
l_int|1ull
op_lshift
id|i
)paren
)paren
(brace
r_uint32
id|errrate
op_assign
l_int|0
suffix:semicolon
r_uint32
id|errcount
op_assign
l_int|0
suffix:semicolon
r_uint32
id|errinterval
op_assign
l_int|0
comma
id|current_tick
op_assign
l_int|0
suffix:semicolon
r_int
id|llp_tx_retry_errors
op_assign
l_int|0
suffix:semicolon
r_int
id|is_llp_tx_retry_intr
op_assign
l_int|0
suffix:semicolon
id|bs_estat-&gt;bs_errcount_total
op_increment
suffix:semicolon
id|current_tick
op_assign
id|jiffies
suffix:semicolon
id|errinterval
op_assign
(paren
id|current_tick
op_minus
id|bs_estat-&gt;bs_lasterr_timestamp
)paren
suffix:semicolon
id|errcount
op_assign
(paren
id|bs_estat-&gt;bs_errcount_total
op_minus
id|bs_estat-&gt;bs_lasterr_snapshot
)paren
suffix:semicolon
multiline_comment|/* LLP interrrupt errors are only valid on BUS0 of the PIC */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_busnum
op_eq
l_int|0
)paren
id|is_llp_tx_retry_intr
op_assign
(paren
id|BRIDGE_ISR_LLP_TX_RETRY
op_eq
(paren
l_int|1ull
op_lshift
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Check for the divide by zero condition while&n;&t;&t; * calculating the error rates.&n;&t;&t; */
r_if
c_cond
(paren
id|errinterval
)paren
(brace
id|errrate
op_assign
id|errcount
op_div
id|errinterval
suffix:semicolon
multiline_comment|/* If able to calculate error rate&n;&t;&t;     * on a LLP transmitter retry interrupt, check&n;&t;&t;     * if the error rate is nonzero and we have seen&n;&t;&t;     * a certain minimum number of errors.&n;&t;&t;     *&n;&t;&t;     * NOTE : errcount is being compared to&n;&t;&t;     * PCIBR_ERRTIME_THRESHOLD to make sure that we are not&n;&t;&t;     * seeing cases like x error interrupts per y ticks for&n;&t;&t;     * very low x ,y (x &gt; y ) which could result in a&n;&t;&t;     * rate &gt; 100/tick.&n;&t;&t;     */
r_if
c_cond
(paren
id|is_llp_tx_retry_intr
op_logical_and
id|errrate
op_logical_and
(paren
id|errcount
op_ge
id|PCIBR_ERRTIME_THRESHOLD
)paren
)paren
(brace
id|llp_tx_retry_errors
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|errrate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Since we are not able to calculate the&n;&t;&t;     * error rate check if we exceeded a certain&n;&t;&t;     * minimum number of errors for LLP transmitter&n;&t;&t;     * retries. Note that this can only happen&n;&t;&t;     * within the first tick after the last snapshot.&n;&t;&t;     */
r_if
c_cond
(paren
id|is_llp_tx_retry_intr
op_logical_and
(paren
id|errcount
op_ge
id|PCIBR_ERRINTR_DISABLE_LEVEL
)paren
)paren
(brace
id|llp_tx_retry_errors
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If a non-zero error rate (which is equivalent to&n;&t;&t; * to 100 errors/tick at least) for the LLP transmitter&n;&t;&t; * retry interrupt was seen, check if we should print&n;&t;&t; * a warning message.&n;&t;&t; */
r_if
c_cond
(paren
id|llp_tx_retry_errors
)paren
(brace
r_static
r_uint32
id|last_printed_rate
suffix:semicolon
r_if
c_cond
(paren
id|errrate
OG
id|last_printed_rate
)paren
(brace
id|last_printed_rate
op_assign
id|errrate
suffix:semicolon
multiline_comment|/* Print the warning only if the error rate&n;&t;&t;&t; * for the transmitter retry interrupt&n;&t;&t;&t; * exceeded the previously printed rate.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s, Excessive error interrupts : %d/tick&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|errrate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;     * Update snapshot, and time&n;&t;&t;     */
id|bs_estat-&gt;bs_lasterr_timestamp
op_assign
id|current_tick
suffix:semicolon
id|bs_estat-&gt;bs_lasterr_snapshot
op_assign
id|bs_estat-&gt;bs_errcount_total
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the error rate is high enough, print the error rate.&n;&t;&t; */
r_if
c_cond
(paren
id|errinterval
OG
id|PCIBR_ERRTIME_THRESHOLD
)paren
(brace
r_if
c_cond
(paren
id|errrate
OG
id|PCIBR_ERRRATE_THRESHOLD
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: %s, Error rate %d/tick&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|errrate
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Update snapshot, and time&n;&t;&t;&t; */
id|bs_estat-&gt;bs_lasterr_timestamp
op_assign
id|current_tick
suffix:semicolon
id|bs_estat-&gt;bs_lasterr_snapshot
op_assign
id|bs_estat-&gt;bs_errcount_total
suffix:semicolon
)brace
)brace
multiline_comment|/* PIC BRINGUP WAR (PV# 856155):&n;&t;&t; * Dont disable PCI_X_ARB_ERR interrupts, we need the&n;&t;&t; * interrupt inorder to clear the DEV_BROKE bits in&n;&t;&t; * b_arb register to re-enable the device.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|err_status
op_amp
id|PIC_ISR_PCIX_ARB_ERR
)paren
op_logical_and
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856155
comma
id|pcibr_soft
)paren
)paren
(brace
r_if
c_cond
(paren
id|bs_estat-&gt;bs_errcount_total
OG
id|PCIBR_ERRINTR_DISABLE_LEVEL
)paren
(brace
multiline_comment|/*&n;&t;&t;     * We have seen a fairly large number of errors of&n;&t;&t;     * this type. Let&squot;s disable the interrupt. But flash&n;&t;&t;     * a message about the interrupt being disabled.&n;&t;&t;     */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s Disabling error interrupt type %s. Error count %d&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|bs_estat-&gt;bs_errcount_total
)paren
suffix:semicolon
id|disable_errintr_mask
op_or_assign
(paren
l_int|1ull
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* PIC: WAR for PV 856155 end-of-if */
)brace
)brace
)brace
r_if
c_cond
(paren
id|disable_errintr_mask
)paren
(brace
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * Disable some high frequency errors as they&n;&t; * could eat up too much cpu time.&n;&t; */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge-&gt;p_int_enable_64
op_and_assign
(paren
id|picreg_t
)paren
(paren
op_complement
id|disable_errintr_mask
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we leave the PROM cacheable, T5 might&n;     * try to do a cache line sized writeback to it,&n;     * which will cause a BRIDGE_ISR_INVLD_ADDR.&n;     */
r_if
c_cond
(paren
(paren
id|err_status
op_amp
id|BRIDGE_ISR_INVLD_ADDR
)paren
op_logical_and
(paren
l_int|0x00000000
op_eq
id|bridge-&gt;b_wid_err_upper
)paren
op_logical_and
(paren
l_int|0x00C00000
op_eq
(paren
l_int|0xFFC00000
op_amp
id|bridge-&gt;b_wid_err_lower
)paren
)paren
op_logical_and
(paren
l_int|0x00402000
op_eq
(paren
l_int|0x00F07F00
op_amp
id|bridge-&gt;b_wid_err_cmdword
)paren
)paren
)paren
(brace
id|err_status
op_and_assign
op_complement
id|BRIDGE_ISR_INVLD_ADDR
suffix:semicolon
)brace
multiline_comment|/*&n;     * The bridge bug (PCIBR_LLP_CONTROL_WAR), where the llp_config or control registers&n;     * need to be read back after being written, affects an MP&n;     * system since there could be small windows between writing&n;     * the register and reading it back on one cpu while another&n;     * cpu is fielding an interrupt. If we run into this scenario,&n;     * workaround the problem by ignoring the error. (bug 454474)&n;     * pcibr_llp_control_war_cnt keeps an approximate number of&n;     * times we saw this problem on a system.&n;     */
r_if
c_cond
(paren
(paren
id|err_status
op_amp
id|BRIDGE_ISR_INVLD_ADDR
)paren
op_logical_and
(paren
(paren
(paren
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_upper
op_lshift
l_int|32
)paren
op_or
(paren
id|bridge-&gt;b_wid_err_lower
)paren
)paren
op_eq
(paren
id|BRIDGE_INT_RST_STAT
op_amp
l_int|0xff0
)paren
)paren
)paren
(brace
id|pcibr_llp_control_war_cnt
op_increment
suffix:semicolon
id|err_status
op_and_assign
op_complement
id|BRIDGE_ISR_INVLD_ADDR
suffix:semicolon
)brace
id|bridge_errors_to_dump
op_or_assign
id|BRIDGE_ISR_PCIBUS_PIOERR
suffix:semicolon
multiline_comment|/* Dump/Log Bridge error interrupt info */
r_if
c_cond
(paren
id|err_status
op_amp
id|bridge_errors_to_dump
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BRIDGE ERR_STATUS 0x%lx&bslash;n&quot;
comma
id|err_status
)paren
suffix:semicolon
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
)brace
multiline_comment|/* PIC BRINGUP WAR (PV# 867308):&n;     * Make BRIDGE_ISR_LLP_REC_SNERR &amp; BRIDGE_ISR_LLP_REC_CBERR fatal errors&n;     * so we know we&squot;ve hit the problem defined in PV 867308 that we believe&n;     * has only been seen in simulation&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV867308
comma
id|pcibr_soft
)paren
op_logical_and
(paren
id|err_status
op_amp
(paren
id|BRIDGE_ISR_LLP_REC_SNERR
op_or
id|BRIDGE_ISR_LLP_REC_CBERR
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BRIDGE ERR_STATUS 0x%lx&bslash;n&quot;
comma
id|err_status
)paren
suffix:semicolon
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|PRINT_PANIC
c_func
(paren
l_string|&quot;PCI Bridge Error interrupt killed the system&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err_status
op_amp
id|BRIDGE_ISR_ERROR_FATAL
)paren
(brace
id|PRINT_PANIC
c_func
(paren
l_string|&quot;PCI Bridge Error interrupt killed the system&quot;
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED */
)brace
multiline_comment|/*&n;     * We can&squot;t return without re-enabling the interrupt, since&n;     * it would cause problems for devices like IOC3 (Lost&n;     * interrupts ?.). So, just cleanup the interrupt, and&n;     * use saved values later..&n;     * &n;     * PIC doesn&squot;t require groups of interrupts to be cleared...&n;     */
id|bridge-&gt;p_int_rst_stat_64
op_assign
(paren
id|picreg_t
)paren
(paren
id|int_status
op_or
id|BRIDGE_IRR_MULTI_CLR
)paren
suffix:semicolon
multiline_comment|/* PIC BRINGUP WAR (PV# 856155):&n;     * On a PCI_X_ARB_ERR error interrupt clear the DEV_BROKE bits from&n;     * the b_arb register to re-enable the device.&n;     */
r_if
c_cond
(paren
(paren
id|err_status
op_amp
id|PIC_ISR_PCIX_ARB_ERR
)paren
op_logical_and
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856155
comma
id|pcibr_soft
)paren
)paren
(brace
id|bridge-&gt;b_arb
op_or_assign
(paren
l_int|0xf
op_lshift
l_int|20
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero out bserr_intstat field */
id|pcibr_soft-&gt;bs_errinfo.bserr_intstat
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_error_cleanup
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|ASSERT
c_func
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
suffix:semicolon
id|error_code
op_assign
id|error_code
suffix:semicolon
id|bridge-&gt;p_int_rst_stat_64
op_assign
id|BRIDGE_IRR_PCI_GRP_CLR
op_or
id|PIC_PCIX_GRP_CLR
op_or
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
(paren
r_void
)paren
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* flushbus */
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_device_disable
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|devnum
)paren
(brace
multiline_comment|/*&n;     * XXX&n;     * Device failed to handle error. Take steps to&n;     * disable this device ? HOW TO DO IT ?&n;     *&n;     * If there are any Read response buffers associated&n;     * with this device, it&squot;s time to get them back!!&n;     *&n;     * We can disassociate any interrupt level associated&n;     * with this device, and disable that interrupt level&n;     *&n;     * For now it&squot;s just a place holder&n;     */
)brace
multiline_comment|/*&n; * pcibr_pioerror&n; *      Handle PIO error that happened at the bridge pointed by pcibr_soft.&n; *&n; *      Queries the Bus interface attached to see if the device driver&n; *      mapping the device-number that caused error can handle the&n; *      situation. If so, it will clean up any error, and return&n; *      indicating the error was handled. If the device driver is unable&n; *      to handle the error, it expects the bus-interface to disable that&n; *      device, and takes any steps needed here to take away any resources&n; *      associated with this device.&n; */
multiline_comment|/* BEM_ADD_IOE doesn&squot;t dump the whole ioerror, it just&n; * decodes the PCI specific portions -- we count on our&n; * callers to dump the raw IOE data.&n; */
DECL|macro|BEM_ADD_IOE
mdefine_line|#define BEM_ADD_IOE(ioe)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (IOERROR_FIELDVALID(ioe, busspace)) {&t;&t;&t;&bslash;&n;&t;&t;iopaddr_t&t;&t;spc;&t;&t;&t;&t;&bslash;&n;&t;&t;iopaddr_t&t;&t;win;&t;&t;&t;&t;&bslash;&n;&t;&t;short&t;&t;&t;widdev;&t;&t;&t;&t;&bslash;&n;&t;&t;iopaddr_t&t;&t;busaddr;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;IOERROR_GETVALUE(spc, ioe, busspace);&t;&t;&t;&bslash;&n;&t;&t;win = spc - PCIIO_SPACE_WIN(0);&t;&t;&t;&t;&bslash;&n;&t;&t;IOERROR_GETVALUE(busaddr, ioe, busaddr);&t;&t;&bslash;&n;&t;&t;IOERROR_GETVALUE(widdev, ioe, widgetdev);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;switch (spc) {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_CFG:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI Slot %d Func %d CFG space Offset 0x%lx&bslash;n&quot;,&bslash;&n;&t;&t;&t;    &t;pciio_widgetdev_slot_get(widdev),&t;&bslash;&n;&t;    &t;&t;&t;pciio_widgetdev_func_get(widdev),&t;&bslash;&n;&t;&t;&t;&t;busaddr);&t;&t;&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_IO:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI I/O space  Offset 0x%lx&bslash;n&quot;, busaddr);&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM32:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM64:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI MEM space Offset 0x%lx&bslash;n&quot;, busaddr);&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;default:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    if (win &lt; 6) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI Slot %d Func %d Window %ld Offset 0x%lx&bslash;n&quot;,&bslash;&n;&t;    &t;&t;&t;pciio_widgetdev_slot_get(widdev),&t;&bslash;&n;&t;    &t;&t;&t;pciio_widgetdev_func_get(widdev),&t;&bslash;&n;&t;&t;&t;    &t;win,&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;    &t;busaddr);&t;&t;&t;&t;&bslash;&n;&t;&t;    }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_pioerror
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
r_int
id|retval
op_assign
id|IOERROR_HANDLED
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|iopaddr_t
id|bad_xaddr
suffix:semicolon
id|pciio_space_t
id|raw_space
suffix:semicolon
multiline_comment|/* raw PCI space */
id|iopaddr_t
id|raw_paddr
suffix:semicolon
multiline_comment|/* raw PCI address */
id|pciio_space_t
id|space
suffix:semicolon
multiline_comment|/* final PCI space */
id|pciio_slot_t
id|slot
suffix:semicolon
multiline_comment|/* final PCI slot, if appropriate */
id|pciio_function_t
id|func
suffix:semicolon
multiline_comment|/* final PCI func, if appropriate */
id|iopaddr_t
id|offset
suffix:semicolon
multiline_comment|/* final PCI offset */
r_int
id|cs
comma
id|cw
comma
id|cf
suffix:semicolon
id|pciio_space_t
id|wx
suffix:semicolon
id|iopaddr_t
id|wb
suffix:semicolon
r_int
id|ws
suffix:semicolon
id|iopaddr_t
id|wl
suffix:semicolon
multiline_comment|/*&n;     * We expect to have an &quot;xtalkaddr&quot; coming in,&n;     * and need to construct the slot/space/offset.&n;     */
id|IOERROR_GETVALUE
c_func
(paren
id|bad_xaddr
comma
id|ioe
comma
id|xtalkaddr
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ERROR_HDLR
comma
id|pcibr_soft-&gt;bs_conn
comma
l_string|&quot;pcibr_pioerror: pcibr_soft=0x%x, bad_xaddr=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|bad_xaddr
)paren
)paren
suffix:semicolon
id|slot
op_assign
id|PCIIO_SLOT_NONE
suffix:semicolon
id|func
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|raw_paddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|PCIBR_BUS_TYPE0_CFG_DEV0
c_func
(paren
id|pcibr_soft
)paren
)paren
op_logical_and
(paren
id|bad_xaddr
OL
id|PCIBR_TYPE1_CFG
c_func
(paren
id|pcibr_soft
)paren
)paren
)paren
(brace
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|PCIBR_BUS_TYPE0_CFG_DEV0
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|slot
op_assign
id|raw_paddr
op_div
id|BRIDGE_TYPE0_CFG_SLOT_OFF
suffix:semicolon
id|raw_paddr
op_assign
id|raw_paddr
op_mod
id|BRIDGE_TYPE0_CFG_SLOT_OFF
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_CFG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|PCIBR_TYPE1_CFG
c_func
(paren
id|pcibr_soft
)paren
)paren
op_logical_and
(paren
id|bad_xaddr
OL
(paren
id|PCIBR_TYPE1_CFG
c_func
(paren
id|pcibr_soft
)paren
op_plus
l_int|0x1000
)paren
)paren
)paren
(brace
multiline_comment|/* Type 1 config space:&n;&t; * slot and function numbers not known.&n;&t; * Perhaps we can read them back?&n;&t; */
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|PCIBR_TYPE1_CFG
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_CFG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|PCIBR_BRIDGE_DEVIO0
c_func
(paren
id|pcibr_soft
)paren
)paren
op_logical_and
(paren
id|bad_xaddr
OL
id|PCIBR_BRIDGE_DEVIO
c_func
(paren
id|pcibr_soft
comma
id|BRIDGE_DEV_CNT
)paren
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|PCIBR_BRIDGE_DEVIO0
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|x
op_assign
id|raw_paddr
op_div
id|BRIDGE_DEVIO_OFF
suffix:semicolon
id|raw_paddr
op_mod_assign
id|BRIDGE_DEVIO_OFF
suffix:semicolon
multiline_comment|/* first two devio windows are double-sized */
r_if
c_cond
(paren
(paren
id|x
op_eq
l_int|1
)paren
op_logical_or
(paren
id|x
op_eq
l_int|3
)paren
)paren
id|raw_paddr
op_add_assign
id|BRIDGE_DEVIO_OFF
suffix:semicolon
r_if
c_cond
(paren
id|x
OG
l_int|0
)paren
id|x
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|x
OG
l_int|1
)paren
id|x
op_decrement
suffix:semicolon
multiline_comment|/* x is which devio reg; no guarantee&n;&t; * PCI slot x will be responding.&n;&t; * still need to figure out who decodes&n;&t; * space/offset on the bus.&n;&t; */
id|raw_space
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_devio.bssd_space
suffix:semicolon
r_if
c_cond
(paren
id|raw_space
op_eq
id|PCIIO_SPACE_NONE
)paren
(brace
multiline_comment|/* Someone got an error because they&n;&t;     * accessed the PCI bus via a DevIO(x)&n;&t;     * window that pcibr has not yet assigned&n;&t;     * to any specific PCI address. It is&n;&t;     * quite possible that the Device(x)&n;&t;     * register has been changed since they&n;&t;     * made their access, but we will give it&n;&t;     * our best decode shot.&n;&t;     */
id|raw_space
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_DEV_IO_MEM
ques
c_cond
id|PCIIO_SPACE_MEM
suffix:colon
id|PCIIO_SPACE_IO
suffix:semicolon
id|raw_paddr
op_add_assign
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_OFF_MASK
)paren
op_lshift
id|BRIDGE_DEV_OFF_ADDR_SHFT
suffix:semicolon
)brace
r_else
id|raw_paddr
op_add_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_devio.bssd_base
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_MEM32_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_MEM32_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_MEM32
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_MEM32_BASE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_MEM64_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_MEM64_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_MEM64
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_MEM64_BASE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_IO_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_IO_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_IO_BASE
suffix:semicolon
)brace
id|space
op_assign
id|raw_space
suffix:semicolon
id|offset
op_assign
id|raw_paddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
op_logical_and
(paren
id|space
op_ne
id|PCIIO_SPACE_NONE
)paren
)paren
(brace
multiline_comment|/* we&squot;ve got a space/offset but not which&n;&t; * PCI slot decodes it. Check through our&n;&t; * notions of which devices decode where.&n;&t; *&n;&t; * Yes, this &quot;duplicates&quot; some logic in&n;&t; * pcibr_addr_toslot; the difference is,&n;&t; * this code knows which space we are in,&n;&t; * and can really really tell what is&n;&t; * going on (no guessing).&n;&t; */
r_for
c_loop
(paren
id|cs
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
(paren
id|cs
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
id|cs
op_increment
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|cf
op_assign
l_int|0
suffix:semicolon
(paren
id|cf
OL
id|nf
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
id|cf
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|cf
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|cw
op_assign
l_int|0
suffix:semicolon
(paren
id|cw
OL
l_int|6
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
op_increment
id|cw
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|wx
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_space
)paren
op_ne
id|PCIIO_SPACE_NONE
)paren
op_logical_and
(paren
(paren
id|wb
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_base
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|ws
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_size
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|wl
op_assign
id|wb
op_plus
id|ws
)paren
OG
id|wb
)paren
op_logical_and
(paren
(paren
id|wb
op_le
id|offset
)paren
op_logical_and
(paren
id|wl
OG
id|offset
)paren
)paren
)paren
(brace
multiline_comment|/* MEM, MEM32 and MEM64 need to&n;&t;&t;&t; * compare as equal ...&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|space
)paren
op_logical_or
(paren
(paren
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
op_logical_and
(paren
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM
)paren
op_logical_or
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
)paren
)paren
(brace
id|slot
op_assign
id|cs
suffix:semicolon
id|func
op_assign
id|cf
suffix:semicolon
id|space
op_assign
id|PCIIO_SPACE_WIN
c_func
(paren
id|cw
)paren
suffix:semicolon
id|offset
op_sub_assign
id|wb
suffix:semicolon
)brace
multiline_comment|/* endif window space match */
)brace
multiline_comment|/* endif window valid and addr match */
)brace
multiline_comment|/* next window unless slot set */
)brace
multiline_comment|/* next func unless slot set */
)brace
multiline_comment|/* next slot unless slot set */
multiline_comment|/* XXX- if slot is still -1, no PCI devices are&n;&t; * decoding here using their standard PCI BASE&n;&t; * registers. This would be a really good place&n;&t; * to cross-coordinate with the pciio PCI&n;&t; * address space allocation routines, to find&n;&t; * out if this address is &quot;allocated&quot; by any of&n;&t; * our subsidiary devices.&n;&t; */
)brace
multiline_comment|/* Scan all piomap records on this PCI bus to update&n;     * the TimeOut Counters on all matching maps. If we&n;     * don&squot;t already know the slot number, take it from&n;     * the first matching piomap. Note that we have to&n;     * compare maps against raw_space and raw_paddr&n;     * since space and offset could already be&n;     * window-relative.&n;     *&n;     * There is a chance that one CPU could update&n;     * through this path, and another CPU could also&n;     * update due to an interrupt. Closing this hole&n;     * would only result in the possibility of some&n;     * errors never getting logged at all, and since the&n;     * use for bp_toc is as a logical test rather than a&n;     * strict count, the excess counts are not a&n;     * problem.&n;     */
r_for
c_loop
(paren
id|cs
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|cs
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|cs
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|cf
op_assign
l_int|0
suffix:semicolon
id|cf
OL
id|nf
suffix:semicolon
id|cf
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|cf
)braket
suffix:semicolon
id|pcibr_piomap_t
id|map
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|pcibr_info-&gt;f_piomap
suffix:semicolon
id|map
op_ne
l_int|NULL
suffix:semicolon
id|map
op_assign
id|map-&gt;bp_next
)paren
(brace
id|wx
op_assign
id|map-&gt;bp_space
suffix:semicolon
id|wb
op_assign
id|map-&gt;bp_pciaddr
suffix:semicolon
id|ws
op_assign
id|map-&gt;bp_mapsz
suffix:semicolon
id|cw
op_assign
id|wx
op_minus
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cw
OL
l_int|6
)paren
(brace
id|wb
op_add_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_base
suffix:semicolon
id|wx
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_space
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wx
op_eq
id|PCIIO_SPACE_ROM
)paren
(brace
id|wb
op_add_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
id|wx
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
id|wx
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|wl
op_assign
id|wb
op_plus
id|ws
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|raw_space
)paren
op_logical_and
(paren
id|raw_paddr
op_ge
id|wb
)paren
op_logical_and
(paren
id|raw_paddr
OL
id|wl
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|map-&gt;bp_toc
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
(brace
id|slot
op_assign
id|cs
suffix:semicolon
id|space
op_assign
id|map-&gt;bp_space
suffix:semicolon
r_if
c_cond
(paren
id|cw
OL
l_int|6
)paren
id|offset
op_sub_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_base
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ERROR_HDLR
comma
id|pcibr_soft-&gt;bs_conn
comma
l_string|&quot;pcibr_pioerror: offset=0x%x, slot=0x%x, func=0x%x&bslash;n&quot;
comma
id|offset
comma
id|slot
comma
id|func
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_NONE
)paren
(brace
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
r_if
c_cond
(paren
id|func
op_ne
id|PCIIO_FUNC_NONE
)paren
(brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
id|func
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busspace
comma
id|space
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busaddr
comma
id|offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
(brace
multiline_comment|/*&n;&t; * During probing, we don&squot;t really care what the&n;&t; * error is. Clean up the error in Bridge, notify&n;&t; * subsidiary devices, and return success.&n;&t; */
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft
comma
id|error_code
)paren
suffix:semicolon
multiline_comment|/* if appropriate, give the error handler for this slot&n;&t; * a shot at this probe access as well.&n;&t; */
r_return
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
ques
c_cond
id|IOERROR_HANDLED
suffix:colon
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we don&squot;t know what &quot;PCI SPACE&quot; the access&n;     * was targeting, we may have problems at the&n;     * Bridge itself. Don&squot;t touch any bridge registers,&n;     * and do complain loudly.&n;     */
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XIO Bus Error at %s&bslash;n&quot;
l_string|&quot;&bslash;taccess to XIO bus offset 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;tdoes not correspond to any PCI address&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|bad_xaddr
)paren
suffix:semicolon
multiline_comment|/* caller will dump contents of ioe struct */
r_return
id|IOERROR_XTALKLEVEL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Actual PCI Error handling situation.&n;     * Typically happens when a user level process accesses&n;     * PCI space, and it causes some error.&n;     *&n;     * Due to PCI Bridge implementation, we get two indication&n;     * for a read error: an interrupt and a Bus error.&n;     * We like to handle read error in the bus error context.&n;     * But the interrupt comes and goes before bus error&n;     * could make much progress. (NOTE: interrupd does&n;     * come in _after_ bus error processing starts. But it&squot;s&n;     * completed by the time bus error code reaches PCI PIO&n;     * error handling.&n;     * Similarly write error results in just an interrupt,&n;     * and error handling has to be done at interrupt level.&n;     * There is no way to distinguish at interrupt time, if an&n;     * error interrupt is due to read/write error..&n;     */
multiline_comment|/* We know the xtalk addr, the raw PCI bus space,&n;     * the raw PCI bus address, the decoded PCI bus&n;     * space, the offset within that space, and the&n;     * decoded PCI slot (which may be &quot;PCIIO_SLOT_NONE&quot; if no slot&n;     * is known to be involved).&n;     */
multiline_comment|/*&n;     * Hand the error off to the handler registered&n;     * for the slot that should have decoded the error,&n;     * or to generic PCI handling (if pciio decides that&n;     * such is appropriate).&n;     */
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
multiline_comment|/* Generate a generic message for IOERROR_UNHANDLED&n;&t; * since the subsidiary handlers were silent, and&n;&t; * did no recovery.&n;&t; */
r_if
c_cond
(paren
id|retval
op_eq
id|IOERROR_UNHANDLED
)paren
(brace
id|retval
op_assign
id|IOERROR_PANIC
suffix:semicolon
multiline_comment|/* we may or may not want to print some of this,&n;&t;     * depending on debug level and which error code.&n;&t;     */
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;PIO Error on PCI Bus %s&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
multiline_comment|/* this decodes part of the ioe; our caller&n;&t;     * will dump the raw details in DEBUG and&n;&t;     * kdebug kernels.&n;&t;     */
id|BEM_ADD_IOE
c_func
(paren
id|ioe
)paren
suffix:semicolon
)brace
macro_line|#if defined(FORCE_ERRORS)
r_if
c_cond
(paren
l_int|0
)paren
(brace
macro_line|#elif !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
multiline_comment|/*&n;&t;     * Dump raw data from Bridge/PCI layer.&n;&t;     */
id|BEM_ADD_STR
c_func
(paren
l_string|&quot;Raw info from Bridge/PCI layer:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bridge-&gt;p_int_status_64
op_amp
(paren
id|picreg_t
)paren
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|BEM_ADD_SPC
c_func
(paren
id|raw_space
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|raw_paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
(brace
r_int
id|widdev
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|widdev
comma
id|ioe
comma
id|widgetdev
)paren
suffix:semicolon
id|slot
op_assign
id|pciio_widgetdev_slot_get
c_func
(paren
id|widdev
)paren
suffix:semicolon
id|func
op_assign
id|pciio_widgetdev_func_get
c_func
(paren
id|widdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|bridgereg_t
id|device
op_assign
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|slot
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|func
)paren
suffix:semicolon
id|BEM_ADD_REG
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
)brace
macro_line|#if !DEBUG || defined(FORCE_ERRORS)
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Since error could not be handled at lower level,&n;&t; * error data logged has not  been cleared.&n;&t; * Clean up errors, and&n;&t; * re-enable bridge to interrupt on error conditions.&n;&t; * NOTE: Wheather we get the interrupt on PCI_ABORT or not is&n;&t; * dependent on INT_ENABLE register. This write just makes sure&n;&t; * that if the interrupt was enabled, we do get the interrupt.&n;&t; *&n;&t; * CAUTION: Resetting bit BRIDGE_IRR_PCI_GRP_CLR, acknowledges&n;&t; *      a group of interrupts. If while handling this error,&n;&t; *      some other error has occurred, that would be&n;&t; *      implicitly cleared by this write.&n;&t; *      Need a way to ensure we don&squot;t inadvertently clear some&n;&t; *      other errors.&n;&t; */
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
(brace
r_int
id|widdev
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|widdev
comma
id|ioe
comma
id|widgetdev
)paren
suffix:semicolon
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|widdev
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVUSERERROR
)paren
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft
comma
id|error_code
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * bridge_dmaerror&n; *      Some error was identified in a DMA transaction.&n; *      This routine will identify the &lt;device, address&gt; that caused the error,&n; *      and try to invoke the appropriate bus service to handle this.&n; */
r_int
DECL|function|pcibr_dmard_error
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|vertex_hdl_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|bus_lowaddr
comma
id|bus_uppraddr
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|bufnum
suffix:semicolon
multiline_comment|/*&n;     * In case of DMA errors, bridge should have logged the&n;     * address that caused the error.&n;     * Look up the address, in the bridge error registers, and&n;     * take appropriate action&n;     */
(brace
r_int
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioe
comma
id|widgetnum
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmp
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bridge
)paren
suffix:semicolon
multiline_comment|/*&n;     * read error log registers&n;     */
id|bus_lowaddr
op_assign
id|bridge-&gt;b_wid_resp_lower
suffix:semicolon
id|bus_uppraddr
op_assign
id|bridge-&gt;b_wid_resp_upper
suffix:semicolon
id|bufnum
op_assign
id|BRIDGE_RESP_ERRUPPR_BUFNUM
c_func
(paren
id|bus_uppraddr
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|BRIDGE_RESP_ERRUPPR_DEVICE
c_func
(paren
id|bus_uppraddr
)paren
comma
l_int|0
)paren
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busaddr
comma
(paren
id|bus_lowaddr
op_or
(paren
(paren
id|iopaddr_t
)paren
(paren
id|bus_uppraddr
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
)paren
op_lshift
l_int|32
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * need to ensure that the xtalk address in ioe&n;     * maps to PCI error address read from bridge.&n;     * How to convert PCI address back to Xtalk address ?&n;     * (better idea: convert XTalk address to PCI address&n;     * and then do the compare!)&n;     */
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioe
comma
id|widgetdev
)paren
suffix:semicolon
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Re-enable bridge to interrupt on BRIDGE_IRR_RESP_BUF_GRP_CLR&n;     * NOTE: Wheather we get the interrupt on BRIDGE_IRR_RESP_BUF_GRP_CLR or&n;     * not is dependent on INT_ENABLE register. This write just makes sure&n;     * that if the interrupt was enabled, we do get the interrupt.&n;     */
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_RESP_BUF_GRP_CLR
suffix:semicolon
multiline_comment|/*&n;     * Also, release the &quot;bufnum&quot; back to buffer pool that could be re-used.&n;     * This is done by &quot;disabling&quot; the buffer for a moment, then restoring&n;     * the original assignment.&n;     */
(brace
id|reg_p
id|regp
suffix:semicolon
id|bridgereg_t
id|regv
suffix:semicolon
id|bridgereg_t
id|mask
suffix:semicolon
id|regp
op_assign
(paren
id|bufnum
op_amp
l_int|1
)paren
ques
c_cond
op_amp
id|bridge-&gt;b_odd_resp
suffix:colon
op_amp
id|bridge-&gt;b_even_resp
suffix:semicolon
id|mask
op_assign
l_int|0xF
op_lshift
(paren
(paren
id|bufnum
op_rshift
l_int|1
)paren
op_star
l_int|4
)paren
suffix:semicolon
id|regv
op_assign
op_star
id|regp
suffix:semicolon
op_star
id|regp
op_assign
id|regv
op_amp
op_complement
id|mask
suffix:semicolon
op_star
id|regp
op_assign
id|regv
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_dmawr_error:&n; *      Handle a dma write error caused by a device attached to this bridge.&n; *&n; *      ioe has the widgetnum, widgetdev, and memaddr fields updated&n; *      But we don&squot;t know the PCI address that corresponds to &quot;memaddr&quot;&n; *      nor do we know which device driver is generating this address.&n; *&n; *      There is no easy way to find out the PCI address(es) that map&n; *      to a specific system memory address. Bus handling code is also&n; *      of not much help, since they don&squot;t keep track of the DMA mapping&n; *      that have been handed out.&n; *      So it&squot;s a dead-end at this time.&n; *&n; *      If translation is available, we could invoke the error handling&n; *      interface of the device driver.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_dmawr_error
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|vertex_hdl_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioe
comma
id|widgetdev
)paren
suffix:semicolon
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Bridge error handler.&n; *      Interface to handle all errors that involve bridge in some way.&n; *&n; *      This normally gets called from xtalk error handler.&n; *      ioe has different set of fields set depending on the error that&n; *      was encountered. So, we have a bit field indicating which of the&n; *      fields are valid.&n; *&n; * NOTE: This routine could be operating in interrupt context. So,&n; *      don&squot;t try to sleep here (till interrupt threads work!!)&n; */
r_int
DECL|function|pcibr_error_handler
id|pcibr_error_handler
c_func
(paren
id|error_handler_arg_t
id|einfo
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_int
id|retval
op_assign
id|IOERROR_BADERRORCODE
suffix:semicolon
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|einfo
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ERROR_HDLR
comma
id|pcibr_soft-&gt;bs_conn
comma
l_string|&quot;pcibr_error_handler: pcibr_soft=0x%x, error_code=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|error_code
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: pcibr_error_handler&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|pcibr_soft
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
id|retval
op_assign
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_READ
)paren
(brace
multiline_comment|/*&n;&t;     * DMA read error occurs when a device attached to the bridge&n;&t;     * tries to read some data from system memory, and this&n;&t;     * either results in a timeout or access error.&n;&t;     * First case is indicated by the bit &quot;XREAD_REQ_TOUT&quot;&n;&t;     * and second case by &quot;RESP_XTALK_ERROR&quot; bit in bridge error&n;&t;     * interrupt status register.&n;&t;     *&n;&t;     * pcibr_error_intr_handler would get invoked first, and it has&n;&t;     * the responsibility of calling pcibr_error_handler with&n;&t;     * suitable parameters.&n;&t;     */
id|retval
op_assign
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|MODE_DEVERROR
comma
id|ioe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_WRITE
)paren
(brace
multiline_comment|/*&n;&t;     * A device attached to this bridge has been generating&n;&t;     * bad DMA writes. Find out the device attached, and&n;&t;     * slap on it&squot;s wrist.&n;&t;     */
id|retval
op_assign
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|MODE_DEVERROR
comma
id|ioe
)paren
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * PIC has 2 busses under a single widget so pcibr_attach2 registers this&n; * wrapper function rather than pcibr_error_handler() for PIC.  It&squot;s upto&n; * this wrapper to call pcibr_error_handler() with the correct pcibr_soft&n; * struct (ie. the pcibr_soft struct for the bus that saw the error).&n; *&n; * NOTE: this wrapper function is only registered for PIC ASICs and will&n; * only be called for a PIC&n; */
r_int
DECL|function|pcibr_error_handler_wrapper
id|pcibr_error_handler_wrapper
c_func
(paren
id|error_handler_arg_t
id|einfo
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|einfo
suffix:semicolon
r_int
id|pio_retval
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|dma_retval
op_assign
op_minus
l_int|1
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ERROR_HDLR
comma
id|pcibr_soft-&gt;bs_conn
comma
l_string|&quot;pcibr_error_handler_wrapper: pcibr_soft=0x%x, &quot;
l_string|&quot;error_code=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|error_code
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * It is possible that both a IOECODE_PIO and a IOECODE_DMA, and both&n;     * IOECODE_READ and IOECODE_WRITE could be set in error_code so we must&n;     * process all.  Since we are a wrapper for pcibr_error_handler(), and&n;     * will be calling it several times within this routine, we turn off the&n;     * error_code bits we don&squot;t want it to be processing during that call.&n;     */
multiline_comment|/* &n;     * If the error was a result of a PIO, we tell what bus on the PIC saw&n;     * the error from the PIO address.&n;     */
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
(brace
id|iopaddr_t
id|bad_xaddr
suffix:semicolon
multiline_comment|/*&n;&t; * PIC bus0 PIO space 0x000000 - 0x7fffff or 0x40000000 - 0xbfffffff&n;&t; *     bus1 PIO space 0x800000 - 0xffffff or 0xc0000000 - 0x13fffffff&n;&t; */
id|IOERROR_GETVALUE
c_func
(paren
id|bad_xaddr
comma
id|ioe
comma
id|xtalkaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_le
l_int|0x7fffff
)paren
op_logical_or
(paren
(paren
id|bad_xaddr
op_ge
l_int|0x40000000
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
l_int|0xbfffffff
)paren
)paren
)paren
(brace
multiline_comment|/* bus 0 saw the error */
id|pio_retval
op_assign
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
(paren
id|error_code
op_amp
op_complement
id|IOECODE_DMA
)paren
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|bad_xaddr
op_ge
l_int|0x800000
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
l_int|0xffffff
)paren
)paren
op_logical_or
(paren
(paren
id|bad_xaddr
op_ge
l_int|0xc0000000
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
l_int|0x13fffffff
)paren
)paren
)paren
(brace
multiline_comment|/* bus 1 saw the error */
id|pcibr_soft
op_assign
id|pcibr_soft-&gt;bs_peers_soft
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pcibr_error_handler: &quot;
l_string|&quot;bs_peers_soft==NULL. bad_xaddr= 0x%x mode= 0x%x&bslash;n&quot;
comma
id|bad_xaddr
comma
id|mode
)paren
suffix:semicolon
macro_line|#endif
id|pio_retval
op_assign
id|IOERROR_HANDLED
suffix:semicolon
)brace
r_else
id|pio_retval
op_assign
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
(paren
id|error_code
op_amp
op_complement
id|IOECODE_DMA
)paren
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pcibr_error_handler_wrapper(): IOECODE_PIO: &quot;
l_string|&quot;saw an invalid pio address: 0x%lx&bslash;n&quot;
comma
id|bad_xaddr
)paren
suffix:semicolon
id|pio_retval
op_assign
id|IOERROR_UNHANDLED
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * If the error was a result of a DMA Write, we tell what bus on the PIC&n;     * saw the error by looking at tnum.&n;     */
r_if
c_cond
(paren
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
op_logical_and
(paren
id|error_code
op_amp
id|IOECODE_WRITE
)paren
)paren
(brace
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;         * For DMA writes [X]Bridge encodes the TNUM field of a Xtalk&n;         * packet like this:&n;         *              bits  value&n;         *              4:3   10b&n;         *              2:0   device number&n;         *&n;         * BUT PIC needs the bus number so it does this:&n;         *              bits  value&n;         *              4:3   10b&n;         *              2     busnumber&n;         *              1:0   device number&n;&t; *&n;&t; * Pull out the bus number from `tnum&squot; and reset the `widgetdev&squot;&n;&t; * since when hubiio_crb_error_handler() set `widgetdev&squot; it had&n;&t; * no idea if it was a PIC or a BRIDGE ASIC so it set it based&n;&t; * off bits 2:0&n;&t; */
id|IOERROR_GETVALUE
c_func
(paren
id|tmp
comma
id|ioe
comma
id|tnum
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
(paren
id|tmp
op_amp
l_int|0x3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* bus 0 saw the error. */
id|dma_retval
op_assign
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
(paren
id|error_code
op_amp
op_complement
(paren
id|IOECODE_PIO
op_or
id|IOECODE_READ
)paren
)paren
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* bus 1 saw the error */
id|pcibr_soft
op_assign
id|pcibr_soft-&gt;bs_peers_soft
suffix:semicolon
id|dma_retval
op_assign
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
(paren
id|error_code
op_amp
op_complement
(paren
id|IOECODE_PIO
op_or
id|IOECODE_READ
)paren
)paren
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * If the error was a result of a DMA READ, XXX ???&n;     */
r_if
c_cond
(paren
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
op_logical_and
(paren
id|error_code
op_amp
id|IOECODE_READ
)paren
)paren
(brace
multiline_comment|/*&n;&t; * A DMA Read error will result in a BRIDGE_ISR_RESP_XTLK_ERR&n;&t; * or BRIDGE_ISR_BAD_XRESP_PKT bridge error interrupt which &n;&t; * are fatal interrupts (ie. BRIDGE_ISR_ERROR_FATAL) causing&n;&t; * pcibr_error_intr_handler() to panic the system.  So is the&n;&t; * error handler even going to get called???  It appears that&n;&t; * the pcibr_dmard_error() attempts to clear the interrupts&n;&t; * so pcibr_error_intr_handler() won&squot;t see them, but there&n;&t; * appears to be nothing to prevent pcibr_error_intr_handler()&n;&t; * from running before pcibr_dmard_error() has a chance to&n;&t; * clear the interrupt.&n;&t; *&n;&t; * Since we&squot;ll be panicing anyways, don&squot;t bother handling the&n;&t; * error for now until we can fix this race condition mentioned&n;&t; * above.&n;&t; */
id|dma_retval
op_assign
id|IOERROR_UNHANDLED
suffix:semicolon
)brace
multiline_comment|/* XXX: pcibr_error_handler() should probably do the same thing, it over-&n;     * write it&squot;s return value as it processes the different &quot;error_code&quot;s.&n;     */
r_if
c_cond
(paren
(paren
id|pio_retval
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|dma_retval
op_eq
op_minus
l_int|1
)paren
)paren
(brace
r_return
id|IOERROR_BADERRORCODE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dma_retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
r_return
id|dma_retval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pio_retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
r_return
id|pio_retval
suffix:semicolon
)brace
r_else
(brace
r_return
id|IOERROR_HANDLED
suffix:semicolon
)brace
)brace
eof
