multiline_comment|/* $Id: shuberror.c,v 1.1 2002/02/28 17:31:25 marcelo Exp $&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000,2002-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/ioerror_handling.h&gt;
macro_line|#include &lt;asm/sn/ioerror.h&gt;
macro_line|#include &lt;asm/sn/sn2/shubio.h&gt;
macro_line|#include &lt;asm/sn/bte.h&gt;
r_extern
r_void
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
suffix:semicolon
r_int
id|hubiio_crb_error_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
suffix:semicolon
r_int
id|hubiio_prb_error_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
suffix:semicolon
r_extern
r_void
id|bte_crb_error_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
r_int
id|btenum
comma
r_int
id|crbnum
comma
id|ioerror_t
op_star
id|ioe
comma
r_int
id|bteop
)paren
suffix:semicolon
r_void
id|print_crb_fields
c_func
(paren
r_int
id|crb_num
comma
id|ii_icrb0_a_u_t
id|icrba
comma
id|ii_icrb0_b_u_t
id|icrbb
comma
id|ii_icrb0_c_u_t
id|icrbc
comma
id|ii_icrb0_d_u_t
id|icrbd
comma
id|ii_icrb0_e_u_t
id|icrbe
)paren
suffix:semicolon
r_extern
r_int
id|maxcpus
suffix:semicolon
r_extern
id|error_return_code_t
id|error_state_set
c_func
(paren
id|vertex_hdl_t
id|v
comma
id|error_state_t
id|new_state
)paren
suffix:semicolon
DECL|macro|HUB_ERROR_PERIOD
mdefine_line|#define HUB_ERROR_PERIOD        (120 * HZ)      /* 2 minutes */
r_void
DECL|function|hub_error_clear
id|hub_error_clear
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|i
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
multiline_comment|/*&n;     * Make sure spurious write response errors are cleared&n;     * (values are from hub_set_prb())&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|HUB_WIDGET_ID_MAX
op_minus
id|HUB_WIDGET_ID_MIN
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear out some fields */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_xtalkctr
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* approx. PIO credits for the widget */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IECLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hub_error_init&n; * Purpose&t;: initialize the error handling requirements for a given hub.&n; * Parameters&t;: cnode, the compact nodeid.&n; * Assumptions&t;: Called only once per hub, either by a local cpu. Or by a &n; *&t;&t;&t;remote cpu, when this hub is headless.(cpuless)&n; * Returns&t;: None&n; */
r_void
DECL|function|hub_error_init
id|hub_error_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hub_error_clear
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now setup the hub ii error interrupt handler.&n;     */
id|hubii_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hubii_eint_init&n; * Parameters&t;: cnode&n; * Purpose&t;: to initialize the hub iio error interrupt.&n; * Assumptions&t;: Called once per hub, by the cpu which will ultimately&n; *&t;&t;&t;handle this interrupt.&n; * Returns&t;: None.&n; */
r_void
DECL|function|hubii_eint_init
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|bit
comma
id|rv
suffix:semicolon
id|ii_iidsr_u_t
id|hubio_eint
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|cpuid_t
id|intr_cpu
suffix:semicolon
id|vertex_hdl_t
id|hub_v
suffix:semicolon
r_int
id|bit_pos_to_irq
c_func
(paren
r_int
id|bit
)paren
suffix:semicolon
id|ii_ilcsr_u_t
id|ilcsr
suffix:semicolon
id|hub_v
op_assign
(paren
id|vertex_hdl_t
)paren
id|cnodeid_to_vertex
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo-&gt;h_cnodeid
op_eq
id|cnode
)paren
suffix:semicolon
id|ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ilcsr.ii_ilcsr_fld_s.i_llp_stat
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * HUB II link is not up.  Disable LLP. Clear old errors.&n;&t; * Enable interrupts to handle BTE errors.&n;&t; */
id|ilcsr.ii_ilcsr_fld_s.i_llp_en
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
comma
id|ilcsr.ii_ilcsr_regval
)paren
suffix:semicolon
)brace
multiline_comment|/* Select a possible interrupt target where there is a free interrupt&n;     * bit and also reserve the interrupt bit for this IO error interrupt&n;     */
id|intr_cpu
op_assign
id|intr_heuristic
c_func
(paren
id|hub_v
comma
l_int|0
comma
id|SGI_II_ERROR
comma
l_int|0
comma
id|hub_v
comma
l_string|&quot;HUB IO error interrupt&quot;
comma
op_amp
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_cpu
op_eq
id|CPU_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hubii_eint_init: intr_reserve_level failed, cnode %d&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rv
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpu
comma
id|SGI_II_ERROR
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|SGI_II_ERROR
comma
id|hubii_eint_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;SN_hub_error&quot;
comma
(paren
r_void
op_star
)paren
id|hub_v
)paren
suffix:semicolon
id|irq_desc
c_func
(paren
id|bit
)paren
op_member_access_from_pointer
id|status
op_or_assign
id|SN2_IRQ_PER_HUB
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_ge
l_int|0
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_regval
op_assign
l_int|0
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_enable
op_assign
l_int|1
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_level
op_assign
id|bit
suffix:semicolon
multiline_comment|/* Take the least significant bits*/
id|hubio_eint.ii_iidsr_fld_s.i_node
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_pi_id
op_assign
id|cpuid_to_subnode
c_func
(paren
id|intr_cpu
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|hubio_eint.ii_iidsr_regval
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hubii_eint_handler
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|vertex_hdl_t
id|hub_v
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|ii_wstat_u_t
id|wstat
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
id|ii_ilcsr_u_t
id|ilcsr
suffix:semicolon
multiline_comment|/* two levels of casting avoids compiler warning.!! */
id|hub_v
op_assign
(paren
id|vertex_hdl_t
)paren
(paren
r_int
)paren
(paren
id|arg
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICMR
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|idsr
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* ICMR bit is set .. we are getting into &quot;Spurious Interrupts condition. */
id|printk
c_func
(paren
l_string|&quot;Cnode %d II has seen the ICMR condition&bslash;n&quot;
comma
id|hinfo-&gt;h_cnodeid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;***** Please file PV with the above messages *****&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* panic(&quot;We have to panic to prevent further unknown states ..&bslash;n&quot;); */
)brace
macro_line|#endif
multiline_comment|/* &n;     * Identify the reason for error. &n;     */
id|wstat.ii_wstat_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_WSTAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_crazy
)paren
(brace
r_char
op_star
id|reason
suffix:semicolon
multiline_comment|/*&n;&t; * We can do a couple of things here. &n;&t; * Look at the fields TX_MX_RTY/XT_TAIL_TO/XT_CRD_TO to check&n;&t; * which of these caused the CRAZY bit to be set. &n;&t; * You may be able to check if the Link is up really.&n;&t; */
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_tx_mx_rty
)paren
id|reason
op_assign
l_string|&quot;Micro Packet Retry Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_tail_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Tail Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_crd_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Credit Timeout&quot;
suffix:semicolon
r_else
(brace
id|hubreg_t
id|hubii_imem
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if widget 0 has been marked as shutdown, or&n;&t;&t; * if BTE 0/1 has been marked.&n;&t;&t; */
id|hubii_imem
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_W0ESD
)paren
id|reason
op_assign
l_string|&quot;Hub Widget 0 has been Shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B0ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 0 has been shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B1ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 1 has been shutdown&quot;
suffix:semicolon
r_else
id|reason
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: we may never be able to print this, if the II talking&n;&t; * to Xbow which hosts the console is dead. &n;&t; */
id|ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ilcsr.ii_ilcsr_fld_s.i_llp_en
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Link is enabled */
id|printk
c_func
(paren
l_string|&quot;Hub %d, cnode %d to Xtalk Link failed (II_ECRAZY) Reason: %s&quot;
comma
id|hinfo-&gt;h_nasid
comma
id|hinfo-&gt;h_cnodeid
comma
id|reason
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Before processing any interrupt related information, clear all&n;     * error indication and reenable interrupts.  This will prevent&n;     * lost interrupts due to the interrupt handler scanning past a PRB/CRB&n;     * which has not errorred yet and then the PRB/CRB goes into error.&n;     * Note, PRB errors are cleared individually.&n;     */
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IECLR
comma
l_int|0xff0000
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
)paren
op_amp
op_complement
id|IIO_IIDSR_SENT_MASK
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|idsr
)paren
suffix:semicolon
multiline_comment|/* &n;     * It&squot;s a toss as to which one among PRB/CRB to check first. &n;     * Current decision is based on the severity of the errors. &n;     * IO CRB errors tend to be more severe than PRB errors.&n;     *&n;     * It is possible for BTE errors to have been handled already, so we&n;     * may not see any errors handled here. &n;     */
(paren
r_void
)paren
id|hubiio_crb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
(paren
r_void
)paren
id|hubiio_prb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the hub CRB &quot;crbnum&quot; which encountered an error.&n; * Assumption is, error handling was successfully done,&n; * and we now want to return the CRB back to Hub for normal usage.&n; *&n; * In order to free the CRB, all that&squot;s needed is to de-allocate it&n; *&n; * Assumption:&n; *      No other processor is mucking around with the hub control register.&n; *      So, upper layer has to single thread this.&n; */
r_void
DECL|function|hubiio_crb_free
id|hubiio_crb_free
c_func
(paren
id|hubinfo_t
id|hinfo
comma
r_int
id|crbnum
)paren
(brace
id|ii_icrb0_b_u_t
id|icrbb
suffix:semicolon
multiline_comment|/*&n;&t;* The hardware does NOT clear the mark bit, so it must get cleared&n;&t;* here to be sure the error is not processed twice.&n;&t;*/
id|icrbb.ii_icrb0_b_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICRB_B
c_func
(paren
id|crbnum
)paren
)paren
suffix:semicolon
id|icrbb.b_mark
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICRB_B
c_func
(paren
id|crbnum
)paren
comma
id|icrbb.ii_icrb0_b_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Deallocate the register.&n;&t;*/
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICDR
comma
(paren
id|IIO_ICDR_PND
op_or
id|crbnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Wait till hub indicates it&squot;s done.&n;&t;*/
r_while
c_loop
(paren
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICDR
)paren
op_amp
id|IIO_ICDR_PND
)paren
id|us_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Array of error names  that get logged in CRBs&n; */
DECL|variable|hubiio_crb_errors
r_char
op_star
id|hubiio_crb_errors
(braket
)braket
op_assign
(brace
l_string|&quot;Directory Error&quot;
comma
l_string|&quot;CRB Poison Error&quot;
comma
l_string|&quot;I/O Write Error&quot;
comma
l_string|&quot;I/O Access Error&quot;
comma
l_string|&quot;I/O Partial Write Error&quot;
comma
l_string|&quot;I/O Partial Read Error&quot;
comma
l_string|&quot;I/O Timeout Error&quot;
comma
l_string|&quot;Xtalk Error Packet&quot;
)brace
suffix:semicolon
r_void
DECL|function|print_crb_fields
id|print_crb_fields
c_func
(paren
r_int
id|crb_num
comma
id|ii_icrb0_a_u_t
id|icrba
comma
id|ii_icrb0_b_u_t
id|icrbb
comma
id|ii_icrb0_c_u_t
id|icrbc
comma
id|ii_icrb0_d_u_t
id|icrbd
comma
id|ii_icrb0_e_u_t
id|icrbe
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CRB %d regA&bslash;n&bslash;t&quot;
l_string|&quot;a_iow 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;valid0x%x&bslash;n&bslash;t&quot;
l_string|&quot;Address0x%lx&bslash;n&bslash;t&quot;
l_string|&quot;a_tnum 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;a_sidn 0x%x&bslash;n&quot;
comma
id|crb_num
comma
id|icrba.a_iow
comma
id|icrba.a_valid
comma
id|icrba.a_addr
comma
id|icrba.a_tnum
comma
id|icrba.a_sidn
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CRB %d regB&bslash;n&bslash;t&quot;
l_string|&quot;b_imsgtype 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_imsg 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_use_old 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_initiator 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_exc 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_ackcnt 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_resp 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_ack 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_hold 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_wb 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_intvn 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_stall_ib 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_stall_int 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_stall_bte_0 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_stall_bte_1 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tb_error 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_lnetuce 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_mark 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;b_xerr 0x%x&bslash;n&quot;
comma
id|crb_num
comma
id|icrbb.b_imsgtype
comma
id|icrbb.b_imsg
comma
id|icrbb.b_use_old
comma
id|icrbb.b_initiator
comma
id|icrbb.b_exc
comma
id|icrbb.b_ackcnt
comma
id|icrbb.b_resp
comma
id|icrbb.b_ack
comma
id|icrbb.b_hold
comma
id|icrbb.b_wb
comma
id|icrbb.b_intvn
comma
id|icrbb.b_stall_ib
comma
id|icrbb.b_stall_int
comma
id|icrbb.b_stall_bte_0
comma
id|icrbb.b_stall_bte_1
comma
id|icrbb.b_error
comma
id|icrbb.b_lnetuce
comma
id|icrbb.b_mark
comma
id|icrbb.b_xerr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CRB %d regC&bslash;n&bslash;t&quot;
l_string|&quot;c_source 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_xtsize 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_cohtrans 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_btenum 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_gbr 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_doresp 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_barrop 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;c_suppl 0x%x&bslash;n&quot;
comma
id|crb_num
comma
id|icrbc.c_source
comma
id|icrbc.c_xtsize
comma
id|icrbc.c_cohtrans
comma
id|icrbc.c_btenum
comma
id|icrbc.c_gbr
comma
id|icrbc.c_doresp
comma
id|icrbc.c_barrop
comma
id|icrbc.c_suppl
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CRB %d regD&bslash;n&bslash;t&quot;
l_string|&quot;d_bteaddr 0x%lx&bslash;n&bslash;t&quot;
l_string|&quot;d_bteop 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;d_pripsc 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;d_pricnt 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;d_sleep 0x%x&bslash;n&bslash;t&quot;
comma
id|crb_num
comma
id|icrbd.d_bteaddr
comma
id|icrbd.d_bteop
comma
id|icrbd.d_pripsc
comma
id|icrbd.d_pricnt
comma
id|icrbd.d_sleep
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CRB %d regE&bslash;n&bslash;t&quot;
l_string|&quot;icrbe_timeout 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;icrbe_context 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;icrbe_toutvld 0x%x&bslash;n&bslash;t&quot;
l_string|&quot;icrbe_ctxtvld 0x%x&bslash;n&bslash;t&quot;
comma
id|crb_num
comma
id|icrbe.icrbe_timeout
comma
id|icrbe.icrbe_context
comma
id|icrbe.icrbe_toutvld
comma
id|icrbe.icrbe_ctxtvld
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hubiio_crb_error_handler&n; *&n; *&t;This routine gets invoked when a hub gets an error &n; *&t;interrupt. So, the routine is running in interrupt context&n; *&t;at error interrupt level.&n; * Action:&n; *&t;It&squot;s responsible for identifying ALL the CRBs that are marked&n; *&t;with error, and process them. &n; *&t;&n; * &t;If you find the CRB that&squot;s marked with error, map this to the&n; *&t;reason it caused error, and invoke appropriate error handler.&n; *&n; *&t;XXX Be aware of the information in the context register.&n; *&n; * NOTE:&n; *&t;Use REMOTE_HUB_* macro instead of LOCAL_HUB_* so that the interrupt&n; *&t;handler can be run on any node. (not necessarily the node &n; *&t;corresponding to the hub that encountered error).&n; */
r_int
DECL|function|hubiio_crb_error_handler
id|hubiio_crb_error_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|ii_icrb0_a_u_t
id|icrba
suffix:semicolon
multiline_comment|/* II CRB Register A */
id|ii_icrb0_b_u_t
id|icrbb
suffix:semicolon
multiline_comment|/* II CRB Register B */
id|ii_icrb0_c_u_t
id|icrbc
suffix:semicolon
multiline_comment|/* II CRB Register C */
id|ii_icrb0_d_u_t
id|icrbd
suffix:semicolon
multiline_comment|/* II CRB Register D */
id|ii_icrb0_e_u_t
id|icrbe
suffix:semicolon
multiline_comment|/* II CRB Register D */
r_int
id|i
suffix:semicolon
r_int
id|num_errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Num of errors handled */
id|ioerror_t
id|ioerror
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
id|cnode
op_assign
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX - Add locking for any recovery actions&n;&t; */
multiline_comment|/*&n;&t; * Scan through all CRBs in the Hub, and handle the errors&n;&t; * in any of the CRBs marked.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IIO_NUM_CRBS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check this crb entry to see if it is in error. */
id|icrbb.ii_icrb0_b_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_B
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icrbb.b_mark
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|icrba.ii_icrb0_a_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_A
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|IOERROR_INIT
c_func
(paren
op_amp
id|ioerror
)paren
suffix:semicolon
multiline_comment|/* read other CRB error registers. */
id|icrbc.ii_icrb0_c_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_C
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|icrbd.ii_icrb0_d_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_D
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|icrbe.ii_icrb0_e_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_E
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|errortype
comma
id|icrbb.b_ecode
)paren
suffix:semicolon
multiline_comment|/* Check if this error is due to BTE operation,&n;&t;&t;* and handle it separately.&n;&t;&t;*/
r_if
c_cond
(paren
id|icrbd.d_bteop
op_logical_or
(paren
(paren
id|icrbb.b_initiator
op_eq
id|IIO_ICRB_INIT_BTE0
op_logical_or
id|icrbb.b_initiator
op_eq
id|IIO_ICRB_INIT_BTE1
)paren
op_logical_and
(paren
id|icrbb.b_imsgtype
op_eq
id|IIO_ICRB_IMSGT_BTE
op_logical_or
id|icrbb.b_imsgtype
op_eq
id|IIO_ICRB_IMSGT_SN1NET
)paren
)paren
)paren
(brace
r_int
id|bte_num
suffix:semicolon
r_if
c_cond
(paren
id|icrbd.d_bteop
)paren
id|bte_num
op_assign
id|icrbc.c_btenum
suffix:semicolon
r_else
multiline_comment|/* b_initiator bit 2 gives BTE number */
id|bte_num
op_assign
(paren
id|icrbb.b_initiator
op_amp
l_int|0x4
)paren
op_rshift
l_int|2
suffix:semicolon
id|hubiio_crb_free
c_func
(paren
id|hinfo
comma
id|i
)paren
suffix:semicolon
id|bte_crb_error_handler
c_func
(paren
id|hub_v
comma
id|bte_num
comma
id|i
comma
op_amp
id|ioerror
comma
id|icrbd.d_bteop
)paren
suffix:semicolon
id|num_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * XXX&n;&t;&t; * Assuming the only other error that would reach here is&n;&t;&t; * crosstalk errors. &n;&t;&t; * If CRB times out on a message from Xtalk, it changes &n;&t;&t; * the message type to CRB. &n;&t;&t; *&n;&t;&t; * If we get here due to other errors (SN0net/CRB)&n;&t;&t; * what&squot;s the action ?&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Pick out the useful fields in CRB, and&n;&t;&t; * tuck them away into ioerror structure.&n;&t;&t; */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|xtalkaddr
comma
id|icrba.a_addr
op_lshift
id|IIO_ICRB_ADDR_SHFT
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|widgetnum
comma
id|icrba.a_sidn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icrba.a_iow
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX We shouldn&squot;t really have BRIDGE-specific code&n;&t;&t;&t; * here, but alas....&n;&t;&t;&t; *&n;&t;&t;&t; * The BRIDGE (or XBRIDGE) sets the upper bit of TNUM&n;&t;&t;&t; * to indicate a WRITE operation.  It sets the next&n;&t;&t;&t; * bit to indicate an INTERRUPT operation.  The bottom&n;&t;&t;&t; * 3 bits of TNUM indicate which device was responsible.&n;&t;&t;&t; */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|widgetdev
comma
id|TNUM_TO_WIDGET_DEV
c_func
(paren
id|icrba.a_tnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;* The encoding of TNUM (see comments above) is&n;&t;&t;&t;* different for PIC. So we&squot;ll save TNUM here and&n;&t;&t;&t;* deal with the differences later when we can&n;&t;&t;&t;* determine if we&squot;re using a Bridge or the PIC.&n;&t;&t;&t;*&n;&t;&t;&t;* XXX:  We may be able to remove saving the widgetdev&n;&t;&t;&t;* above and just sort it out of TNUM later.&n;&t;&t;&t;*/
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|tnum
comma
id|icrba.a_tnum
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icrbb.b_error
)paren
(brace
multiline_comment|/*&n;&t;&t;     * CRB &squot;i&squot; has some error. Identify the type of error,&n;&t;&t;     * and try to handle it.&n;&t;&t;     *&n;&t;&t;     */
r_switch
c_cond
(paren
id|icrbb.b_ecode
)paren
(brace
r_case
id|IIO_ICRB_ECODE_PERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_WERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_AERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_PWERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_TOUT
suffix:colon
r_case
id|IIO_ICRB_ECODE_XTERR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Shub II CRB %d: error %s on hub cnodeid: %d&quot;
comma
id|i
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;     * Any sort of write error is mostly due&n;&t;&t;&t;     * bad programming (Note it&squot;s not a timeout.)&n;&t;&t;&t;     * So, invoke hub_iio_error_handler with&n;&t;&t;&t;     * appropriate information.&n;&t;&t;&t;     */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|errortype
comma
id|icrbb.b_ecode
)paren
suffix:semicolon
multiline_comment|/* Go through the error bit lookup phase */
r_if
c_cond
(paren
id|error_state_set
c_func
(paren
id|hub_v
comma
id|ERROR_STATE_LOOKUP
)paren
op_eq
id|ERROR_RETURN_CODE_CANNOT_SET_STATE
)paren
r_return
id|IOERROR_UNHANDLED
suffix:semicolon
id|rc
op_assign
id|hub_ioerror_handler
c_func
(paren
id|hub_v
comma
id|DMA_WRITE_ERROR
comma
id|MODE_DEVERROR
comma
op_amp
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|IOERROR_HANDLED
)paren
(brace
id|rc
op_assign
id|hub_ioerror_handler
c_func
(paren
id|hub_v
comma
id|DMA_WRITE_ERROR
comma
id|MODE_DEVREENABLE
comma
op_amp
id|ioerror
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to handle %s on hub %d&quot;
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/* panic; */
)brace
multiline_comment|/* Go to Next error */
id|print_crb_fields
c_func
(paren
id|i
comma
id|icrba
comma
id|icrbb
comma
id|icrbc
comma
id|icrbd
comma
id|icrbe
)paren
suffix:semicolon
id|hubiio_crb_free
c_func
(paren
id|hinfo
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|IIO_ICRB_ECODE_PRERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_DERR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Shub II CRB %d: error %s on hub : %d&quot;
comma
id|i
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/* panic */
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Shub II CRB error (code : %d) on hub : %d&quot;
comma
id|icrbb.b_ecode
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/* panic */
)brace
)brace
multiline_comment|/*&n;&t;&t; * Error is not indicated via the errcode field&n;&t;&t; * Check other error indications in this register.&n;&t;&t; */
r_if
c_cond
(paren
id|icrbb.b_xerr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Shub II CRB %d: Xtalk Packet with error bit set to hub %d&quot;
comma
id|i
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/* panic */
)brace
r_if
c_cond
(paren
id|icrbb.b_lnetuce
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Shub II CRB %d: Uncorrectable data error detected on data &quot;
l_string|&quot; from NUMAlink to node %d&quot;
comma
id|i
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/* panic */
)brace
id|print_crb_fields
c_func
(paren
id|i
comma
id|icrba
comma
id|icrbb
comma
id|icrbc
comma
id|icrbd
comma
id|icrbe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icrbb.b_error
)paren
(brace
multiline_comment|/* &n;&t;&t; * CRB &squot;i&squot; has some error. Identify the type of error,&n;&t;&t; * and try to handle it.&n;&t;&t; */
r_switch
c_cond
(paren
id|icrbb.b_ecode
)paren
(brace
r_case
id|IIO_ICRB_ECODE_PERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_WERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_AERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_PWERR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s on hub cnodeid: %d&quot;
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Any sort of write error is mostly due&n;&t;&t;&t; * bad programming (Note it&squot;s not a timeout.)&n;&t;&t;&t; * So, invoke hub_iio_error_handler with&n;&t;&t;&t; * appropriate information.&n;&t;&t;&t; */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|errortype
comma
id|icrbb.b_ecode
)paren
suffix:semicolon
id|rc
op_assign
id|hub_ioerror_handler
c_func
(paren
id|hub_v
comma
id|DMA_WRITE_ERROR
comma
id|MODE_DEVERROR
comma
op_amp
id|ioerror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|IOERROR_HANDLED
)paren
(brace
id|rc
op_assign
id|hub_ioerror_handler
c_func
(paren
id|hub_v
comma
id|DMA_WRITE_ERROR
comma
id|MODE_DEVREENABLE
comma
op_amp
id|ioerror
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|IOERROR_HANDLED
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;Unable to handle %s on hub %d&quot;
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
)brace
multiline_comment|/* Go to Next error */
id|hubiio_crb_free
c_func
(paren
id|hinfo
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|IIO_ICRB_ECODE_PRERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_TOUT
suffix:colon
r_case
id|IIO_ICRB_ECODE_XTERR
suffix:colon
r_case
id|IIO_ICRB_ECODE_DERR
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Fatal %s on hub : %d&quot;
comma
id|hubiio_crb_errors
(braket
id|icrbb.b_ecode
)braket
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Fatal error (code : %d) on hub : %d&quot;
comma
id|icrbb.b_ecode
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
)brace
)brace
multiline_comment|/* if (icrbb.b_error) */
multiline_comment|/*&n;&t;&t; * Error is not indicated via the errcode field &n;&t;&t; * Check other error indications in this register.&n;&t;&t; */
r_if
c_cond
(paren
id|icrbb.b_xerr
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Xtalk Packet with error bit set to hub %d&quot;
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
)brace
r_if
c_cond
(paren
id|icrbb.b_lnetuce
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Uncorrectable data error detected on data &quot;
l_string|&quot; from Craylink to node %d&quot;
comma
id|cnode
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
)brace
)brace
r_return
id|num_errors
suffix:semicolon
)brace
multiline_comment|/*&n; * hubii_check_widget_disabled&n; *&n; *&t;Check if PIO access to the specified widget is disabled due&n; *&t;to any II errors that are currently set.&n; *&n; *&t;The specific error bits checked are:&n; *&t;&t;IPRBx register: SPUR_RD (51)&n; *&t;&t;&t;&t;SPUR_WR (50)&n; *&t;&t;&t;&t;RD_TO (49)&n; *&t;&t;&t;&t;ERROR (48)&n; *&n; *&t;&t;WSTAT register: CRAZY (32)&n; */
r_int
DECL|function|hubii_check_widget_disabled
id|hubii_check_widget_disabled
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|wnum
)paren
(brace
id|iprb_t
id|iprb
suffix:semicolon
id|ii_wstat_u_t
id|wstat
suffix:semicolon
id|iprb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB
c_func
(paren
id|wnum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iprb.iprb_regval
op_amp
(paren
id|IIO_PRB_SPUR_RD
op_or
id|IIO_PRB_SPUR_WR
op_or
id|IIO_PRB_RD_TO
op_or
id|IIO_PRB_ERROR
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;II error, IPRB%x=0x%lx&bslash;n&quot;
comma
id|wnum
comma
id|iprb.iprb_regval
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|wstat.ii_wstat_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_WSTAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wstat.ii_wstat_regval
op_amp
id|IIO_WSTAT_ECRAZY
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;II error, WSTAT=0x%lx&bslash;n&quot;
comma
id|wstat.ii_wstat_regval
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
multiline_comment|/*&n; * hubii_prb_handler&n; *      Handle the error reported in the PRB for wiget number wnum.&n; *      This typically happens on a PIO write error.&n; *      There is nothing much we can do in this interrupt context for&n; *      PIO write errors. For e.g. QL scsi controller has the&n; *      habit of flaking out on PIO writes.&n; *      Print a message and try to continue for now&n; *      Cleanup involes freeing the PRB register&n; */
r_static
r_void
DECL|function|hubii_prb_handler
id|hubii_prb_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
comma
r_int
id|wnum
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/*&n;         * Clear error bit by writing to IECLR register.&n;         */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IECLR
comma
(paren
l_int|1
op_lshift
id|wnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * PIO Write to Widget &squot;i&squot; got into an error.&n;         * Invoke hubiio_error_handler with this information.&n;         */
id|printk
c_func
(paren
l_string|&quot;Hub nasid %d got a PIO Write error from widget %d, &quot;
l_string|&quot;cleaning up and continuing&quot;
comma
id|nasid
comma
id|wnum
)paren
suffix:semicolon
multiline_comment|/*&n;         * XXX&n;         * It may be necessary to adjust IO PRB counter&n;         * to account for any lost credits.&n;         */
)brace
r_int
DECL|function|hubiio_prb_error_handler
id|hubiio_prb_error_handler
c_func
(paren
id|vertex_hdl_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
(brace
r_int
id|wnum
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|num_errors
op_assign
l_int|0
suffix:semicolon
id|iprb_t
id|iprb
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/*&n;         * Check if IPRB0 has any error first.&n;         */
id|iprb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iprb.iprb_error
)paren
(brace
id|num_errors
op_increment
suffix:semicolon
id|hubii_prb_handler
c_func
(paren
id|hub_v
comma
id|hinfo
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Look through PRBs 8 - F to see if any of them has error bit set.&n;         * If true, invoke hub iio error handler for this widget.&n;         */
r_for
c_loop
(paren
id|wnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|wnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|wnum
op_increment
)paren
(brace
id|iprb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB
c_func
(paren
id|wnum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iprb.iprb_error
)paren
r_continue
suffix:semicolon
id|num_errors
op_increment
suffix:semicolon
id|hubii_prb_handler
c_func
(paren
id|hub_v
comma
id|hinfo
comma
id|wnum
)paren
suffix:semicolon
)brace
r_return
id|num_errors
suffix:semicolon
)brace
eof
