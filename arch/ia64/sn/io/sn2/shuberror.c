multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000,2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/ioerror.h&gt;
macro_line|#include &lt;asm/sn/sn2/shubio.h&gt;
macro_line|#include &lt;asm/sn/bte.h&gt;
r_extern
r_void
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
suffix:semicolon
r_int
id|hubiio_crb_error_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
suffix:semicolon
r_int
id|hubiio_prb_error_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
suffix:semicolon
r_extern
r_void
id|bte_crb_error_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
r_int
id|btenum
comma
r_int
id|crbnum
comma
id|ioerror_t
op_star
id|ioe
)paren
suffix:semicolon
r_extern
r_int
id|maxcpus
suffix:semicolon
DECL|macro|HUB_ERROR_PERIOD
mdefine_line|#define HUB_ERROR_PERIOD        (120 * HZ)      /* 2 minutes */
r_void
DECL|function|hub_error_clear
id|hub_error_clear
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|i
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
multiline_comment|/*&n;     * Make sure spurious write response errors are cleared&n;     * (values are from hub_set_prb())&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|HUB_WIDGET_ID_MAX
op_minus
id|HUB_WIDGET_ID_MIN
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear out some fields */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_xtalkctr
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* approx. PIO credits for the widget */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IO_ERR_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
comma
(paren
id|idsr
op_amp
op_complement
(paren
id|IIO_IIDSR_SENT_MASK
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hub_error_init&n; * Purpose&t;: initialize the error handling requirements for a given hub.&n; * Parameters&t;: cnode, the compact nodeid.&n; * Assumptions&t;: Called only once per hub, either by a local cpu. Or by a &n; *&t;&t;&t;remote cpu, when this hub is headless.(cpuless)&n; * Returns&t;: None&n; */
r_void
DECL|function|hub_error_init
id|hub_error_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hub_error_clear
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now setup the hub ii error interrupt handler.&n;     */
id|hubii_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hubii_eint_init&n; * Parameters&t;: cnode&n; * Purpose&t;: to initialize the hub iio error interrupt.&n; * Assumptions&t;: Called once per hub, by the cpu which will ultimately&n; *&t;&t;&t;handle this interrupt.&n; * Returns&t;: None.&n; */
r_void
DECL|function|hubii_eint_init
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|bit
comma
id|rv
suffix:semicolon
id|ii_iidsr_u_t
id|hubio_eint
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|cpuid_t
id|intr_cpu
suffix:semicolon
id|devfs_handle_t
id|hub_v
suffix:semicolon
id|ii_ilcsr_u_t
id|ilcsr
suffix:semicolon
r_int
id|bit_pos_to_irq
c_func
(paren
r_int
id|bit
)paren
suffix:semicolon
r_int
id|synergy_intr_connect
c_func
(paren
r_int
id|bit
comma
r_int
id|cpuid
)paren
suffix:semicolon
id|hub_v
op_assign
(paren
id|devfs_handle_t
)paren
id|cnodeid_to_vertex
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo-&gt;h_cnodeid
op_eq
id|cnode
)paren
suffix:semicolon
id|ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ilcsr.ii_ilcsr_fld_s.i_llp_stat
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* &n;&t; * HUB II link is not up. &n;&t; * Just disable LLP, and don&squot;t connect any interrupts.&n;&t; */
id|ilcsr.ii_ilcsr_fld_s.i_llp_en
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
comma
id|ilcsr.ii_ilcsr_regval
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Select a possible interrupt target where there is a free interrupt&n;     * bit and also reserve the interrupt bit for this IO error interrupt&n;     */
id|intr_cpu
op_assign
id|intr_heuristic
c_func
(paren
id|hub_v
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|hub_v
comma
l_string|&quot;HUB IO error interrupt&quot;
comma
op_amp
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_cpu
op_eq
id|CPU_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hubii_eint_init: intr_reserve_level failed, cnode %d&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rv
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpu
comma
id|bit
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|bit
op_plus
(paren
id|intr_cpu
op_lshift
l_int|8
)paren
comma
id|hubii_eint_handler
comma
l_int|0
comma
l_string|&quot;SN hub error&quot;
comma
(paren
r_void
op_star
)paren
id|hub_v
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_ge
l_int|0
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_regval
op_assign
l_int|0
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_enable
op_assign
l_int|1
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_level
op_assign
id|bit
suffix:semicolon
multiline_comment|/* Take the least significant bits*/
id|hubio_eint.ii_iidsr_fld_s.i_node
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_pi_id
op_assign
id|cpuid_to_subnode
c_func
(paren
id|intr_cpu
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|hubio_eint.ii_iidsr_regval
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hubii_eint_handler
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|devfs_handle_t
id|hub_v
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|ii_wstat_u_t
id|wstat
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
multiline_comment|/* two levels of casting avoids compiler warning.!! */
id|hub_v
op_assign
(paren
id|devfs_handle_t
)paren
(paren
r_int
)paren
(paren
id|arg
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
multiline_comment|/* &n;     * Identify the reason for error. &n;     */
id|wstat.ii_wstat_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_WSTAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_crazy
)paren
(brace
r_char
op_star
id|reason
suffix:semicolon
multiline_comment|/*&n;&t; * We can do a couple of things here. &n;&t; * Look at the fields TX_MX_RTY/XT_TAIL_TO/XT_CRD_TO to check&n;&t; * which of these caused the CRAZY bit to be set. &n;&t; * You may be able to check if the Link is up really.&n;&t; */
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_tx_mx_rty
)paren
id|reason
op_assign
l_string|&quot;Micro Packet Retry Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_tail_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Tail Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_crd_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Credit Timeout&quot;
suffix:semicolon
r_else
(brace
id|hubreg_t
id|hubii_imem
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if widget 0 has been marked as shutdown, or&n;&t;&t; * if BTE 0/1 has been marked.&n;&t;&t; */
id|hubii_imem
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_W0ESD
)paren
id|reason
op_assign
l_string|&quot;Hub Widget 0 has been Shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B0ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 0 has been shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B1ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 1 has been shutdown&quot;
suffix:semicolon
r_else
id|reason
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: we may never be able to print this, if the II talking&n;&t; * to Xbow which hosts the console is dead. &n;&t; */
id|printk
c_func
(paren
l_string|&quot;Hub %d to Xtalk Link failed (II_ECRAZY) Reason: %s&quot;
comma
id|hinfo-&gt;h_cnodeid
comma
id|reason
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;     * It&squot;s a toss as to which one among PRB/CRB to check first. &n;     * Current decision is based on the severity of the errors. &n;     * IO CRB errors tend to be more severe than PRB errors.&n;     *&n;     * It is possible for BTE errors to have been handled already, so we&n;     * may not see any errors handled here. &n;     */
(paren
r_void
)paren
id|hubiio_crb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
(paren
r_void
)paren
id|hubiio_prb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we reach here, it indicates crb/prb handlers successfully&n;     * handled the error. So, re-enable II to send more interrupt&n;     * and return.&n;     */
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IECLR
comma
l_int|0xffffff
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
)paren
op_amp
op_complement
id|IIO_IIDSR_SENT_MASK
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|idsr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the hub CRB &quot;crbnum&quot; which encountered an error.&n; * Assumption is, error handling was successfully done,&n; * and we now want to return the CRB back to Hub for normal usage.&n; *&n; * In order to free the CRB, all that&squot;s needed is to de-allocate it&n; *&n; * Assumption:&n; *      No other processor is mucking around with the hub control register.&n; *      So, upper layer has to single thread this.&n; */
r_void
DECL|function|hubiio_crb_free
id|hubiio_crb_free
c_func
(paren
id|hubinfo_t
id|hinfo
comma
r_int
id|crbnum
)paren
(brace
id|ii_icrb0_a_u_t
id|icrba
suffix:semicolon
multiline_comment|/*&n;&t;* The hardware does NOT clear the mark bit, so it must get cleared&n;&t;* here to be sure the error is not processed twice.&n;&t;*/
id|icrba.ii_icrb0_a_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICRB_A
c_func
(paren
id|crbnum
)paren
)paren
suffix:semicolon
id|icrba.a_valid
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICRB_A
c_func
(paren
id|crbnum
)paren
comma
id|icrba.ii_icrb0_a_regval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Deallocate the register.&n;&t;*/
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICDR
comma
(paren
id|IIO_ICDR_PND
op_or
id|crbnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Wait till hub indicates it&squot;s done.&n;&t;*/
r_while
c_loop
(paren
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ICDR
)paren
op_amp
id|IIO_ICDR_PND
)paren
id|us_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Array of error names  that get logged in CRBs&n; */
DECL|variable|hubiio_crb_errors
r_char
op_star
id|hubiio_crb_errors
(braket
)braket
op_assign
(brace
l_string|&quot;Directory Error&quot;
comma
l_string|&quot;CRB Poison Error&quot;
comma
l_string|&quot;I/O Write Error&quot;
comma
l_string|&quot;I/O Access Error&quot;
comma
l_string|&quot;I/O Partial Write Error&quot;
comma
l_string|&quot;I/O Partial Read Error&quot;
comma
l_string|&quot;I/O Timeout Error&quot;
comma
l_string|&quot;Xtalk Error Packet&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * hubiio_crb_error_handler&n; *&n; *&t;This routine gets invoked when a hub gets an error &n; *&t;interrupt. So, the routine is running in interrupt context&n; *&t;at error interrupt level.&n; * Action:&n; *&t;It&squot;s responsible for identifying ALL the CRBs that are marked&n; *&t;with error, and process them. &n; *&t;&n; * &t;If you find the CRB that&squot;s marked with error, map this to the&n; *&t;reason it caused error, and invoke appropriate error handler.&n; *&n; *&t;XXX Be aware of the information in the context register.&n; *&n; * NOTE:&n; *&t;Use REMOTE_HUB_* macro instead of LOCAL_HUB_* so that the interrupt&n; *&t;handler can be run on any node. (not necessarily the node &n; *&t;corresponding to the hub that encountered error).&n; */
r_int
DECL|function|hubiio_crb_error_handler
id|hubiio_crb_error_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|ii_icrb0_a_u_t
id|icrba
suffix:semicolon
multiline_comment|/* II CRB Register A */
id|ii_icrb0_b_u_t
id|icrbb
suffix:semicolon
multiline_comment|/* II CRB Register B */
id|ii_icrb0_c_u_t
id|icrbc
suffix:semicolon
multiline_comment|/* II CRB Register C */
id|ii_icrb0_d_u_t
id|icrbd
suffix:semicolon
multiline_comment|/* II CRB Register D */
r_int
id|i
suffix:semicolon
r_int
id|num_errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Num of errors handled */
id|ioerror_t
id|ioerror
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
id|cnode
op_assign
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan through all CRBs in the Hub, and handle the errors&n;&t; * in any of the CRBs marked.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IIO_NUM_CRBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|icrba.ii_icrb0_a_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_A
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|IOERROR_INIT
c_func
(paren
op_amp
id|ioerror
)paren
suffix:semicolon
multiline_comment|/* read other CRB error registers. */
id|icrbb.ii_icrb0_b_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_B
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|icrbc.ii_icrb0_c_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_C
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|icrbd.ii_icrb0_d_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_ICRB_D
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|errortype
comma
id|icrbb.b_ecode
)paren
suffix:semicolon
multiline_comment|/* Check if this error is due to BTE operation,&n;&t;&t;* and handle it separately.&n;&t;&t;*/
r_if
c_cond
(paren
id|icrbd.d_bteop
op_logical_or
(paren
(paren
id|icrbb.b_initiator
op_eq
id|IIO_ICRB_INIT_BTE0
op_logical_or
id|icrbb.b_initiator
op_eq
id|IIO_ICRB_INIT_BTE1
)paren
op_logical_and
(paren
id|icrbb.b_imsgtype
op_eq
id|IIO_ICRB_IMSGT_BTE
op_logical_or
id|icrbb.b_imsgtype
op_eq
id|IIO_ICRB_IMSGT_SN1NET
)paren
)paren
)paren
(brace
r_int
id|bte_num
suffix:semicolon
r_if
c_cond
(paren
id|icrbd.d_bteop
)paren
id|bte_num
op_assign
id|icrbc.c_btenum
suffix:semicolon
r_else
multiline_comment|/* b_initiator bit 2 gives BTE number */
id|bte_num
op_assign
(paren
id|icrbb.b_initiator
op_amp
l_int|0x4
)paren
op_rshift
l_int|2
suffix:semicolon
id|bte_crb_error_handler
c_func
(paren
id|hub_v
comma
id|bte_num
comma
id|i
comma
op_amp
id|ioerror
)paren
suffix:semicolon
id|hubiio_crb_free
c_func
(paren
id|hinfo
comma
id|i
)paren
suffix:semicolon
id|num_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * XXX&n;&t;&t; * Assuming the only other error that would reach here is&n;&t;&t; * crosstalk errors. &n;&t;&t; * If CRB times out on a message from Xtalk, it changes &n;&t;&t; * the message type to CRB. &n;&t;&t; *&n;&t;&t; * If we get here due to other errors (SN0net/CRB)&n;&t;&t; * what&squot;s the action ?&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Pick out the useful fields in CRB, and&n;&t;&t; * tuck them away into ioerror structure.&n;&t;&t; */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|xtalkaddr
comma
id|icrba.a_addr
op_lshift
id|IIO_ICRB_ADDR_SHFT
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|widgetnum
comma
id|icrba.a_sidn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icrba.a_iow
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX We shouldn&squot;t really have BRIDGE-specific code&n;&t;&t;&t; * here, but alas....&n;&t;&t;&t; *&n;&t;&t;&t; * The BRIDGE (or XBRIDGE) sets the upper bit of TNUM&n;&t;&t;&t; * to indicate a WRITE operation.  It sets the next&n;&t;&t;&t; * bit to indicate an INTERRUPT operation.  The bottom&n;&t;&t;&t; * 3 bits of TNUM indicate which device was responsible.&n;&t;&t;&t; */
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioerror
comma
id|widgetdev
comma
id|TNUM_TO_WIDGET_DEV
c_func
(paren
id|icrba.a_tnum
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|num_errors
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
multiline_comment|/*&n; * hubii_prb_handler&n; *      Handle the error reported in the PRB for wiget number wnum.&n; *      This typically happens on a PIO write error.&n; *      There is nothing much we can do in this interrupt context for&n; *      PIO write errors. For e.g. QL scsi controller has the&n; *      habit of flaking out on PIO writes.&n; *      Print a message and try to continue for now&n; *      Cleanup involes freeing the PRB register&n; */
r_static
r_void
DECL|function|hubii_prb_handler
id|hubii_prb_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
comma
r_int
id|wnum
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/*&n;         * Clear error bit by writing to IECLR register.&n;         */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IO_ERR_CLR
comma
(paren
l_int|1
op_lshift
id|wnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * PIO Write to Widget &squot;i&squot; got into an error.&n;         * Invoke hubiio_error_handler with this information.&n;         */
id|printk
c_func
(paren
l_string|&quot;Hub nasid %d got a PIO Write error from widget %d, cleaning up and continuing&quot;
comma
id|nasid
comma
id|wnum
)paren
suffix:semicolon
multiline_comment|/*&n;         * XXX&n;         * It may be necessary to adjust IO PRB counter&n;         * to account for any lost credits.&n;         */
)brace
r_int
DECL|function|hubiio_prb_error_handler
id|hubiio_prb_error_handler
c_func
(paren
id|devfs_handle_t
id|hub_v
comma
id|hubinfo_t
id|hinfo
)paren
(brace
r_int
id|wnum
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|num_errors
op_assign
l_int|0
suffix:semicolon
id|iprb_t
id|iprb
suffix:semicolon
id|nasid
op_assign
id|hinfo-&gt;h_nasid
suffix:semicolon
multiline_comment|/*&n;         * Check if IPRB0 has any error first.&n;         */
id|iprb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iprb.iprb_error
)paren
(brace
id|num_errors
op_increment
suffix:semicolon
id|hubii_prb_handler
c_func
(paren
id|hub_v
comma
id|hinfo
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Look through PRBs 8 - F to see if any of them has error bit set.&n;         * If true, invoke hub iio error handler for this widget.&n;         */
r_for
c_loop
(paren
id|wnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|wnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|wnum
op_increment
)paren
(brace
id|iprb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB
c_func
(paren
id|wnum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iprb.iprb_error
)paren
r_continue
suffix:semicolon
id|num_errors
op_increment
suffix:semicolon
id|hubii_prb_handler
c_func
(paren
id|hub_v
comma
id|hinfo
comma
id|wnum
)paren
suffix:semicolon
)brace
r_return
id|num_errors
suffix:semicolon
)brace
eof
