multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/pci/pic.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
r_extern
r_struct
id|file_operations
id|pcibr_fops
suffix:semicolon
r_extern
id|pcibr_list_p
id|pcibr_list
suffix:semicolon
r_static
r_int
id|pic_attach2
c_func
(paren
id|vertex_hdl_t
comma
r_void
op_star
comma
id|vertex_hdl_t
comma
r_int
comma
id|pcibr_soft_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|isIO9
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
r_extern
r_char
op_star
id|dev_to_name
c_func
(paren
id|vertex_hdl_t
id|dev
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_widget_to_bus
c_func
(paren
id|vertex_hdl_t
id|pcibr_vhdl
)paren
suffix:semicolon
r_extern
id|pcibr_hints_t
id|pcibr_hints_get
c_func
(paren
id|vertex_hdl_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
comma
r_int
id|nslots
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_error_handler_wrapper
c_func
(paren
id|error_handler_arg_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_error_intr_handler
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_directmap_init
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_info_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_device_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_extern
id|pcibr_info_t
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_initial_rrb
c_func
(paren
id|vertex_hdl_t
comma
id|pciio_slot_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_void
id|xwidget_error_register
c_func
(paren
id|vertex_hdl_t
comma
id|error_handler_f
op_star
comma
id|error_handler_arg_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_clearwidint
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
multiline_comment|/*&n; * copy xwidget_info_t from conn_v to peer_conn_v&n; */
r_static
r_int
DECL|function|pic_bus1_widget_info_dup
id|pic_bus1_widget_info_dup
c_func
(paren
id|vertex_hdl_t
id|conn_v
comma
id|vertex_hdl_t
id|peer_conn_v
comma
id|cnodeid_t
id|xbow_peer
comma
r_char
op_star
id|peer_path
)paren
(brace
id|xwidget_info_t
id|widget_info
comma
id|peer_widget_info
suffix:semicolon
id|vertex_hdl_t
id|peer_hubv
suffix:semicolon
id|hubinfo_t
id|peer_hub_info
suffix:semicolon
multiline_comment|/* get the peer hub&squot;s widgetid */
id|peer_hubv
op_assign
id|NODEPDA
c_func
(paren
id|xbow_peer
)paren
op_member_access_from_pointer
id|node_vertex
suffix:semicolon
id|peer_hub_info
op_assign
l_int|NULL
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|peer_hubv
comma
op_amp
id|peer_hub_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peer_hub_info
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_info_get_LBL
c_func
(paren
id|conn_v
comma
id|INFO_LBL_XWIDGET
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|widget_info
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
id|peer_widget_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|peer_widget_info
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|peer_widget_info
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|peer_widget_info
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|peer_widget_info
)paren
)paren
)paren
suffix:semicolon
id|peer_widget_info-&gt;w_fingerprint
op_assign
id|widget_info_fingerprint
suffix:semicolon
id|peer_widget_info-&gt;w_vertex
op_assign
id|peer_conn_v
suffix:semicolon
id|peer_widget_info-&gt;w_id
op_assign
id|widget_info-&gt;w_id
suffix:semicolon
id|peer_widget_info-&gt;w_master
op_assign
id|peer_hubv
suffix:semicolon
id|peer_widget_info-&gt;w_masterid
op_assign
id|peer_hub_info-&gt;h_widgetid
suffix:semicolon
multiline_comment|/* structure copy */
id|peer_widget_info-&gt;w_hwid
op_assign
id|widget_info-&gt;w_hwid
suffix:semicolon
id|peer_widget_info-&gt;w_efunc
op_assign
l_int|0
suffix:semicolon
id|peer_widget_info-&gt;w_einfo
op_assign
l_int|0
suffix:semicolon
id|peer_widget_info-&gt;w_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|peer_path
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|peer_widget_info-&gt;w_name
)paren
(brace
id|kfree
c_func
(paren
id|peer_widget_info
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|peer_widget_info-&gt;w_name
comma
id|peer_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_info_add_LBL
c_func
(paren
id|peer_conn_v
comma
id|INFO_LBL_XWIDGET
comma
(paren
id|arbitrary_info_t
)paren
id|peer_widget_info
)paren
op_ne
id|GRAPH_SUCCESS
)paren
(brace
id|kfree
c_func
(paren
id|peer_widget_info-&gt;w_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|peer_widget_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xwidget_info_set
c_func
(paren
id|peer_conn_v
comma
id|peer_widget_info
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;pic_bus1_widget_info_dup: &quot;
l_string|&quot;cannot get INFO_LBL_XWIDGET from 0x%lx&bslash;n&quot;
comma
(paren
r_uint64
)paren
id|conn_v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * If this PIC is attached to two Cbricks (&quot;dual-ported&quot;) then&n; * attach each bus to opposite Cbricks.&n; *&n; * If successful, return a new vertex suitable for attaching the PIC bus.&n; * If not successful, return zero and both buses will attach to the&n; * vertex passed into pic_attach().&n; */
r_static
id|vertex_hdl_t
DECL|function|pic_bus1_redist
id|pic_bus1_redist
c_func
(paren
id|nasid_t
id|nasid
comma
id|vertex_hdl_t
id|conn_v
)paren
(brace
id|cnodeid_t
id|cnode
op_assign
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|cnodeid_t
id|xbow_peer
op_assign
op_minus
l_int|1
suffix:semicolon
r_char
id|pathname
(braket
l_int|256
)braket
comma
id|peer_path
(braket
l_int|256
)braket
comma
id|tmpbuf
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|vertex_hdl_t
id|peer_conn_v
comma
id|hubv
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|slabid_t
id|slab
suffix:semicolon
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|xbow_peer
op_ge
l_int|0
)paren
(brace
multiline_comment|/* if dual-ported */
multiline_comment|/* create a path for this widget on the peer Cbrick */
multiline_comment|/* pcibr widget hw/module/001c11/slab/0/Pbrick/xtalk/12 */
multiline_comment|/* sprintf(pathname, &quot;%v&quot;, conn_v); */
id|xbow_peer
op_assign
id|nasid_to_cnodeid
c_func
(paren
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|xbow_peer
)paren
suffix:semicolon
id|pos
op_assign
id|hwgfs_generate_path
c_func
(paren
id|conn_v
comma
id|tmpbuf
comma
l_int|256
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pathname
comma
op_amp
id|tmpbuf
(braket
id|pos
)braket
)paren
suffix:semicolon
id|p
op_assign
id|pathname
op_plus
id|strlen
c_func
(paren
l_string|&quot;hw/module/001c01/slab/0/&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmpbuf
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|tmpbuf
comma
id|geo_module
c_func
(paren
(paren
id|NODEPDA
c_func
(paren
id|xbow_peer
)paren
)paren
op_member_access_from_pointer
id|geoid
)paren
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
id|slab
op_assign
id|geo_slab
c_func
(paren
(paren
id|NODEPDA
c_func
(paren
id|xbow_peer
)paren
)paren
op_member_access_from_pointer
id|geoid
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|peer_path
comma
l_string|&quot;module/%s/slab/%d/%s&quot;
comma
id|tmpbuf
comma
(paren
r_int
)paren
id|slab
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Look for vertex for this widget on the peer Cbrick.&n;&t;&t; * Expect GRAPH_NOT_FOUND.&n;&t;&t; */
id|rc
op_assign
id|hwgraph_traverse
c_func
(paren
id|hwgraph_root
comma
id|peer_path
comma
op_amp
id|peer_conn_v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|rc
)paren
id|printk
c_func
(paren
l_string|&quot;pic_attach: found unexpected vertex: 0x%lx&bslash;n&quot;
comma
(paren
r_uint64
)paren
id|peer_conn_v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|GRAPH_NOT_FOUND
op_ne
id|rc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pic_attach: hwgraph_traverse unexpectedly&quot;
l_string|&quot; returned 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* try to add the widget vertex to the peer Cbrick */
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|hwgraph_root
comma
id|peer_path
comma
op_amp
id|peer_conn_v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|rc
)paren
id|printk
c_func
(paren
l_string|&quot;pic_attach: hwgraph_path_add&quot;
l_string|&quot; failed with 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_else
(brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|conn_v
comma
l_string|&quot;pic_bus1_redist: added vertex %v&bslash;n&quot;
comma
id|peer_conn_v
)paren
)paren
suffix:semicolon
multiline_comment|/* Now hang appropiate stuff off of the new&n;&t;&t;&t;     * vertex.&t;We bail out if we cannot add something.&n;&t;&t;&t;     * In that case, we don&squot;t remove the newly added&n;&t;&t;&t;     * vertex but that should be safe and we don&squot;t&n;&t;&t;&t;     * really expect the additions to fail anyway.&n;&t;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|pic_bus1_widget_info_dup
c_func
(paren
id|conn_v
comma
id|peer_conn_v
comma
id|xbow_peer
comma
id|peer_path
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|hubv
op_assign
id|cnodeid_to_vertex
c_func
(paren
id|xbow_peer
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hubv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
id|device_master_set
c_func
(paren
id|peer_conn_v
comma
id|hubv
)paren
suffix:semicolon
id|xtalk_provider_register
c_func
(paren
id|hubv
comma
op_amp
id|hub_provider
)paren
suffix:semicolon
id|xtalk_provider_startup
c_func
(paren
id|hubv
)paren
suffix:semicolon
r_return
id|peer_conn_v
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * PIC has two buses under a single widget.  pic_attach() calls pic_attach2()&n; * to attach each of those buses.&n; */
r_int
DECL|function|pic_attach
id|pic_attach
c_func
(paren
id|vertex_hdl_t
id|conn_v
)paren
(brace
r_int
id|rc
suffix:semicolon
r_void
op_star
id|bridge0
comma
op_star
id|bridge1
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
id|vertex_hdl_t
id|pcibr_vhdl0
comma
id|pcibr_vhdl1
op_assign
(paren
id|vertex_hdl_t
)paren
l_int|0
suffix:semicolon
id|pcibr_soft_t
id|bus0_soft
comma
id|bus1_soft
op_assign
(paren
id|pcibr_soft_t
)paren
l_int|0
suffix:semicolon
id|vertex_hdl_t
id|conn_v0
comma
id|conn_v1
comma
id|peer_conn_v
suffix:semicolon
r_int
id|bricktype
suffix:semicolon
r_int
id|iobrick_type_get_nasid
c_func
(paren
id|nasid_t
id|nasid
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|conn_v
comma
l_string|&quot;pic_attach()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|bridge0
op_assign
id|pcibr_bridge_ptr_get
c_func
(paren
id|conn_v
comma
l_int|0
)paren
suffix:semicolon
id|bridge1
op_assign
id|pcibr_bridge_ptr_get
c_func
(paren
id|conn_v
comma
l_int|1
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|conn_v
comma
l_string|&quot;pic_attach: bridge0=0x%lx, bridge1=0x%lx&bslash;n&quot;
comma
id|bridge0
comma
id|bridge1
)paren
)paren
suffix:semicolon
id|conn_v0
op_assign
id|conn_v1
op_assign
id|conn_v
suffix:semicolon
multiline_comment|/* If dual-ported then split the two PIC buses across both Cbricks */
id|peer_conn_v
op_assign
id|pic_bus1_redist
c_func
(paren
id|NASID_GET
c_func
(paren
id|bridge0
)paren
comma
id|conn_v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peer_conn_v
)paren
id|conn_v1
op_assign
id|peer_conn_v
suffix:semicolon
multiline_comment|/*&n;&t; * Create the vertex for the PCI buses, which we&n;&t; * will also use to hold the pcibr_soft and&n;&t; * which will be the &quot;master&quot; vertex for all the&n;&t; * pciio connection points we will hang off it.&n;&t; * This needs to happen before we call nic_bridge_vertex_info&n;&t; * as we are some of the *_vmc functions need access to the edges.&n;&t; *&n;&t; * Opening this vertex will provide access to&n;&t; * the Bridge registers themselves.&n;&t; */
id|bricktype
op_assign
id|iobrick_type_get_nasid
c_func
(paren
id|NASID_GET
c_func
(paren
id|bridge0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bricktype
op_eq
id|MODULE_CGBRICK
)paren
(brace
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|conn_v0
comma
id|EDGE_LBL_AGP_0
comma
op_amp
id|pcibr_vhdl0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|conn_v1
comma
id|EDGE_LBL_AGP_1
comma
op_amp
id|pcibr_vhdl1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|conn_v0
comma
id|EDGE_LBL_PCIX_0
comma
op_amp
id|pcibr_vhdl0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|conn_v1
comma
id|EDGE_LBL_PCIX_1
comma
op_amp
id|pcibr_vhdl1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|conn_v
comma
l_string|&quot;pic_attach: pcibr_vhdl0=0x%lx, pcibr_vhdl1=0x%lx&bslash;n&quot;
comma
id|pcibr_vhdl0
comma
id|pcibr_vhdl1
)paren
)paren
suffix:semicolon
multiline_comment|/* register pci provider array */
id|pciio_provider_register
c_func
(paren
id|pcibr_vhdl0
comma
op_amp
id|pci_pic_provider
)paren
suffix:semicolon
id|pciio_provider_register
c_func
(paren
id|pcibr_vhdl1
comma
op_amp
id|pci_pic_provider
)paren
suffix:semicolon
id|pciio_provider_startup
c_func
(paren
id|pcibr_vhdl0
)paren
suffix:semicolon
id|pciio_provider_startup
c_func
(paren
id|pcibr_vhdl1
)paren
suffix:semicolon
id|pic_attach2
c_func
(paren
id|conn_v0
comma
id|bridge0
comma
id|pcibr_vhdl0
comma
l_int|0
comma
op_amp
id|bus0_soft
)paren
suffix:semicolon
id|pic_attach2
c_func
(paren
id|conn_v1
comma
id|bridge1
comma
id|pcibr_vhdl1
comma
l_int|1
comma
op_amp
id|bus1_soft
)paren
suffix:semicolon
(brace
multiline_comment|/* If we&squot;re dual-ported finish duplicating the peer info structure.&n;&t;     * The error handler and arg are done in pic_attach2().&n;&t;     */
id|xwidget_info_t
id|info0
comma
id|info1
suffix:semicolon
r_if
c_cond
(paren
id|conn_v0
op_ne
id|conn_v1
)paren
(brace
multiline_comment|/* dual ported */
id|info0
op_assign
id|xwidget_info_get
c_func
(paren
id|conn_v0
)paren
suffix:semicolon
id|info1
op_assign
id|xwidget_info_get
c_func
(paren
id|conn_v1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info1-&gt;w_efunc
op_eq
(paren
id|error_handler_f
op_star
)paren
l_int|NULL
)paren
id|info1-&gt;w_efunc
op_assign
id|info0-&gt;w_efunc
suffix:semicolon
r_if
c_cond
(paren
id|info1-&gt;w_einfo
op_eq
(paren
id|error_handler_arg_t
)paren
l_int|0
)paren
id|info1-&gt;w_einfo
op_assign
id|bus1_soft
suffix:semicolon
)brace
)brace
multiline_comment|/* save a pointer to the PIC&squot;s other bus&squot;s soft struct */
id|bus0_soft-&gt;bs_peers_soft
op_assign
id|bus1_soft
suffix:semicolon
id|bus1_soft-&gt;bs_peers_soft
op_assign
id|bus0_soft
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|conn_v
comma
l_string|&quot;pic_attach: bus0_soft=0x%lx, bus1_soft=0x%lx&bslash;n&quot;
comma
id|bus0_soft
comma
id|bus1_soft
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * PIC has two buses under a single widget.  pic_attach() calls pic_attach2()&n; * to attach each of those buses.&n; */
r_static
r_int
DECL|function|pic_attach2
id|pic_attach2
c_func
(paren
id|vertex_hdl_t
id|xconn_vhdl
comma
r_void
op_star
id|bridge
comma
id|vertex_hdl_t
id|pcibr_vhdl
comma
r_int
id|busnum
comma
id|pcibr_soft_t
op_star
id|ret_softp
)paren
(brace
id|vertex_hdl_t
id|ctlr_vhdl
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|xwidget_info_t
id|info
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
id|pcibr_list_p
id|self
suffix:semicolon
r_int
id|entry
comma
id|slot
comma
id|ibit
comma
id|i
suffix:semicolon
id|vertex_hdl_t
id|noslot_conn
suffix:semicolon
r_char
id|devnm
(braket
id|MAXDEVNAME
)braket
comma
op_star
id|s
suffix:semicolon
id|pcibr_hints_t
id|pcibr_hints
suffix:semicolon
id|picreg_t
id|id
suffix:semicolon
id|picreg_t
id|int_enable
suffix:semicolon
id|picreg_t
id|pic_ctrl_reg
suffix:semicolon
r_int
id|iobrick_type_get_nasid
c_func
(paren
id|nasid_t
id|nasid
)paren
suffix:semicolon
r_int
id|iomoduleid_get
c_func
(paren
id|nasid_t
id|nasid
)paren
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pic_attach2: bridge=0x%lx, busnum=%d&bslash;n&quot;
comma
id|bridge
comma
id|busnum
)paren
)paren
suffix:semicolon
id|ctlr_vhdl
op_assign
l_int|NULL
suffix:semicolon
id|ctlr_vhdl
op_assign
id|hwgraph_register
c_func
(paren
id|pcibr_vhdl
comma
id|EDGE_LBL_CONTROLLER
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
(paren
r_struct
id|file_operations
op_star
)paren
op_amp
id|pcibr_fops
comma
(paren
r_void
op_star
)paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ctlr_vhdl
op_ne
l_int|NULL
)paren
suffix:semicolon
id|id
op_assign
id|pcireg_bridge_id_get
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|hwgraph_info_add_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
(paren
id|arbitrary_info_t
)paren
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Get the hint structure; if some NIC callback marked this vertex as&n;     * &quot;hands-off&quot; then we just return here, before doing anything else.&n;     */
id|pcibr_hints
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints
op_logical_and
id|pcibr_hints-&gt;ph_hands_off
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* allocate soft structure to hang off the vertex.  Link the new soft&n;     * structure to the pcibr_list linked list&n;     */
id|pcibr_soft
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|pcibr_soft
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|self
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
)paren
(brace
id|kfree
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|pcibr_soft
)paren
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
op_star
(paren
id|self
)paren
)paren
)paren
suffix:semicolon
id|self-&gt;bl_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|self-&gt;bl_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|self-&gt;bl_next
op_assign
id|pcibr_list
suffix:semicolon
id|pcibr_list
op_assign
id|self
suffix:semicolon
r_if
c_cond
(paren
id|ret_softp
)paren
op_star
id|ret_softp
op_assign
id|pcibr_soft
suffix:semicolon
id|memset
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
r_sizeof
op_star
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft_set
c_func
(paren
id|pcibr_vhdl
comma
id|pcibr_soft
)paren
suffix:semicolon
id|s
op_assign
id|dev_to_name
c_func
(paren
id|pcibr_vhdl
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft-&gt;bs_name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strcpy
c_func
(paren
id|pcibr_soft-&gt;bs_name
comma
id|s
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_conn
op_assign
id|xconn_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_base
op_assign
(paren
r_void
op_star
)paren
id|bridge
suffix:semicolon
id|pcibr_soft-&gt;bs_rev_num
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_intr_bits
op_assign
(paren
id|pcibr_intr_bits_f
op_star
)paren
id|pcibr_intr_bits
suffix:semicolon
id|pcibr_soft-&gt;bsi_err_intr
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_min_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_max_slot
op_assign
l_int|3
suffix:semicolon
id|pcibr_soft-&gt;bs_busnum
op_assign
id|busnum
suffix:semicolon
id|pcibr_soft-&gt;bs_bridge_type
op_assign
id|PCIBR_BRIDGETYPE_PIC
suffix:semicolon
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|PIC_INTERNAL_ATES
suffix:semicolon
multiline_comment|/* Make sure this is called after setting the bs_base and bs_bridge_type */
id|pcibr_soft-&gt;bs_bridge_mode
op_assign
(paren
id|pcireg_speed_get
c_func
(paren
id|pcibr_soft
)paren
op_lshift
l_int|1
)paren
op_or
id|pcireg_mode_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_xid
op_assign
id|xwidget_info_id_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_master
op_assign
id|xwidget_info_master_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_mxid
op_assign
id|xwidget_info_masterid_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pcibr_soft-&gt;bs_asic_name
comma
l_string|&quot;PIC&quot;
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pic_attach2: pcibr_soft=0x%lx, mode=0x%x&bslash;n&quot;
comma
id|pcibr_soft
comma
id|pcibr_soft-&gt;bs_bridge_mode
)paren
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pic_attach2: %s ASIC: rev %s (code=0x%x)&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_asic_name
comma
(paren
id|IS_PIC_PART_REV_A
c_func
(paren
id|pcibr_soft-&gt;bs_rev_num
)paren
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
(paren
id|IS_PIC_PART_REV_B
c_func
(paren
id|pcibr_soft-&gt;bs_rev_num
)paren
)paren
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
(paren
id|IS_PIC_PART_REV_C
c_func
(paren
id|pcibr_soft-&gt;bs_rev_num
)paren
)paren
ques
c_cond
l_string|&quot;C&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|pcibr_soft-&gt;bs_rev_num
)paren
)paren
suffix:semicolon
multiline_comment|/* PV854845: Must clear write request buffer to avoid parity errors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIC_WR_REQ_BUFSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
(paren
id|pic_t
op_star
)paren
id|bridge
)paren
op_member_access_from_pointer
id|p_wr_req_lower
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|pic_t
op_star
)paren
id|bridge
)paren
op_member_access_from_pointer
id|p_wr_req_upper
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|pic_t
op_star
)paren
id|bridge
)paren
op_member_access_from_pointer
id|p_wr_req_parity
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_soft-&gt;bs_nasid
op_assign
id|NASID_GET
c_func
(paren
id|bridge
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_bricktype
op_assign
id|iobrick_type_get_nasid
c_func
(paren
id|pcibr_soft-&gt;bs_nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: bricktype was unknown by L1 (ret val = 0x%x)&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_soft-&gt;bs_bricktype
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_moduleid
op_assign
id|iomoduleid_get
c_func
(paren
id|pcibr_soft-&gt;bs_nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
)paren
(brace
r_case
id|MODULE_PXBRICK
suffix:colon
r_case
id|MODULE_IXBRICK
suffix:colon
r_case
id|MODULE_OPUSBRICK
suffix:colon
id|pcibr_soft-&gt;bs_first_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Bus 1 of IXBrick has a IO9, so there are 4 devices, not 2 */
r_if
c_cond
(paren
(paren
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
op_eq
l_int|1
)paren
op_logical_and
id|isIO9
c_func
(paren
id|pcibr_soft-&gt;bs_nasid
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|3
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|3
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MODULE_CGBRICK
suffix:colon
id|pcibr_soft-&gt;bs_first_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_last_slot
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_last_reset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unknown bricktype: 0x%x&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_soft-&gt;bs_bricktype
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_ATTACH
comma
id|pcibr_vhdl
comma
l_string|&quot;pic_attach2: bricktype=%d, brickbus=%d, &quot;
l_string|&quot;slots %d-%d&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_bricktype
comma
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
comma
id|pcibr_soft-&gt;bs_first_slot
comma
id|pcibr_soft-&gt;bs_last_slot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Initialize bridge and bus locks&n;     */
id|spin_lock_init
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we have one, process the hints structure.&n;     */
r_if
c_cond
(paren
id|pcibr_hints
)paren
(brace
r_int
id|rrb_fixed
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_HINTS
comma
id|pcibr_vhdl
comma
l_string|&quot;pic_attach2: pcibr_hints=0x%lx&bslash;n&quot;
comma
id|pcibr_hints
)paren
)paren
suffix:semicolon
id|rrb_fixed
op_assign
id|pcibr_hints-&gt;ph_rrb_fixed
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_fixed
op_assign
id|rrb_fixed
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints-&gt;ph_intr_bits
)paren
id|pcibr_soft-&gt;bs_intr_bits
op_assign
id|pcibr_hints-&gt;ph_intr_bits
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
r_int
id|hslot
op_assign
id|pcibr_hints-&gt;ph_host_slot
(braket
id|slot
)braket
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hslot
OL
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|slot
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|hslot
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Set-up initial values for state fields&n;     */
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_devio.bssd_ref_cnt
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid_dflt
(braket
id|slot
)braket
(braket
id|VCHAN0
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ibit
op_assign
l_int|0
suffix:semicolon
id|ibit
OL
l_int|8
suffix:semicolon
op_increment
id|ibit
)paren
(brace
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_xtalk_intr
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_list
op_assign
l_int|NULL
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_ibit
op_assign
id|ibit
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_hdlrcnt
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_shared
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_wrap.iw_connected
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * connect up our error handler.  PIC has 2 busses (thus resulting in 2&n;     * pcibr_soft structs under 1 widget), so only register a xwidget error&n;     * handler for PIC&squot;s bus0.  NOTE: for PIC pcibr_error_handler_wrapper()&n;     * is a wrapper routine we register that will call the real error handler&n;     * pcibr_error_handler() with the correct pcibr_soft struct.&n;     */
r_if
c_cond
(paren
id|busnum
op_eq
l_int|0
)paren
(brace
id|xwidget_error_register
c_func
(paren
id|xconn_vhdl
comma
id|pcibr_error_handler_wrapper
comma
id|pcibr_soft
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Clear all pending interrupts.  Assume all interrupts are from slot 3&n;     * until otherise setup.&n;     */
id|pcireg_intr_reset_set
c_func
(paren
id|pcibr_soft
comma
id|PIC_IRR_ALL_CLR
)paren
suffix:semicolon
id|pcireg_intr_device_set
c_func
(paren
id|pcibr_soft
comma
l_int|0x006db6db
)paren
suffix:semicolon
multiline_comment|/* Setup the mapping register used for direct mapping */
id|pcibr_directmap_init
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/*&n;     * Initialize the PICs control register.&n;     */
id|pic_ctrl_reg
op_assign
id|pcireg_control_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Bridges Requester ID: bus = busnum, dev = 0, func = 0 */
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_BUS_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_BUS_NUM
c_func
(paren
id|busnum
)paren
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_DEV_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_FUN_NUM_MASK
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_NO_SNOOP
suffix:semicolon
id|pic_ctrl_reg
op_and_assign
op_complement
id|PIC_CTRL_RELAX_ORDER
suffix:semicolon
multiline_comment|/* enable parity checking on PICs internal RAM */
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_RESP
suffix:semicolon
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_ATE
suffix:semicolon
multiline_comment|/* PIC BRINGUP WAR (PV# 862253): dont enable write request parity */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV862253
comma
id|pcibr_soft
)paren
)paren
(brace
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAR_EN_REQ
suffix:semicolon
)brace
id|pic_ctrl_reg
op_or_assign
id|PIC_CTRL_PAGE_SIZE
suffix:semicolon
id|pcireg_control_set
c_func
(paren
id|pcibr_soft
comma
id|pic_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Initialize internal mapping entries (ie. the ATEs) */
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|pcibr_soft-&gt;bs_int_ate_size
suffix:semicolon
id|entry
op_increment
)paren
id|pcireg_int_ate_set
c_func
(paren
id|pcibr_soft
comma
id|entry
comma
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_int_ate_resource.start
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_int_ate_resource.end
op_assign
id|pcibr_soft-&gt;bs_int_ate_size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Setup the PICs error interrupt handler. */
id|xtalk_intr
op_assign
id|xtalk_intr_alloc
c_func
(paren
id|xconn_vhdl
comma
(paren
id|device_desc_t
)paren
l_int|0
comma
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
id|irq
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_bit
suffix:semicolon
id|cpu
op_assign
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_cpuid
suffix:semicolon
id|intr_unreserve_level
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
(paren
(paren
id|hub_intr_t
)paren
id|xtalk_intr
)paren
op_member_access_from_pointer
id|i_bit
op_assign
id|SGI_PCIBR_ERROR
suffix:semicolon
id|xtalk_intr-&gt;xi_vector
op_assign
id|SGI_PCIBR_ERROR
suffix:semicolon
id|pcibr_soft-&gt;bsi_err_intr
op_assign
id|xtalk_intr
suffix:semicolon
multiline_comment|/*&n;     * On IP35 with XBridge, we do some extra checks in pcibr_setwidint&n;     * in order to work around some addressing limitations.  In order&n;     * for that fire wall to work properly, we need to make sure we&n;     * start from a known clean state.&n;     */
id|pcibr_clearwidint
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
(paren
id|intr_func_t
)paren
id|pcibr_error_intr_handler
comma
(paren
id|intr_arg_t
)paren
id|pcibr_soft
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setwidint
comma
(paren
r_void
op_star
)paren
id|pcibr_soft
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|SGI_PCIBR_ERROR
comma
(paren
r_void
op_star
)paren
id|pcibr_error_intr_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;PCIBR error&quot;
comma
(paren
id|intr_arg_t
)paren
id|pcibr_soft
)paren
suffix:semicolon
id|PCIBR_DEBUG_ALWAYS
c_func
(paren
(paren
id|PCIBR_DEBUG_INTR_ALLOC
comma
id|pcibr_vhdl
comma
l_string|&quot;pcibr_setwidint: target_id=0x%lx, int_addr=0x%lx&bslash;n&quot;
comma
id|pcireg_intr_dst_target_id_get
c_func
(paren
id|pcibr_soft
)paren
comma
id|pcireg_intr_dst_addr_get
c_func
(paren
id|pcibr_soft
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* now we can start handling error interrupts */
id|int_enable
op_assign
id|pcireg_intr_enable_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|int_enable
op_or_assign
id|PIC_ISR_ERRORS
suffix:semicolon
multiline_comment|/* PIC BRINGUP WAR (PV# 856864 &amp; 856865): allow the tnums that are&n;     * locked out to be freed up sooner (by timing out) so that the&n;     * read tnums are never completely used up.&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856864
comma
id|pcibr_soft
)paren
)paren
(brace
id|int_enable
op_and_assign
op_complement
id|PIC_ISR_PCIX_REQ_TOUT
suffix:semicolon
id|int_enable
op_and_assign
op_complement
id|PIC_ISR_XREAD_REQ_TIMEOUT
suffix:semicolon
id|pcireg_req_timeout_set
c_func
(paren
id|pcibr_soft
comma
l_int|0x750
)paren
suffix:semicolon
)brace
id|pcireg_intr_enable_set
c_func
(paren
id|pcibr_soft
comma
id|int_enable
)paren
suffix:semicolon
id|pcireg_intr_mode_set
c_func
(paren
id|pcibr_soft
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* dont send &squot;clear interrupt&squot; pkts */
id|pcireg_tflush_get
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
multiline_comment|/*&n;     * PIC BRINGUP WAR (PV# 856866, 859504, 861476, 861478): Don&squot;t use&n;     * RRB0, RRB8, RRB1, and RRB9.  Assign them to DEVICE[2|3]--VCHAN3&n;     * so they are not used.  This works since there is currently no&n;     * API to penable VCHAN3.&n;     */
r_if
c_cond
(paren
id|PCIBR_WAR_ENABLED
c_func
(paren
id|PV856866
comma
id|pcibr_soft
)paren
)paren
(brace
id|pcireg_rrb_bit_set
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
l_int|0x000f000f
)paren
suffix:semicolon
multiline_comment|/* even rrb reg */
id|pcireg_rrb_bit_set
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
l_int|0x000f000f
)paren
suffix:semicolon
multiline_comment|/* odd rrb reg */
)brace
multiline_comment|/* PIC only supports 64-bit direct mapping in PCI-X mode.  Since&n;     * all PCI-X devices that initiate memory transactions must be&n;     * capable of generating 64-bit addressed, we force 64-bit DMAs.&n;     */
id|pcibr_soft-&gt;bs_dma_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIIO_DMA_A64
suffix:semicolon
)brace
(brace
id|iopaddr_t
id|prom_base_addr
op_assign
id|pcibr_soft-&gt;bs_xid
op_lshift
l_int|24
suffix:semicolon
r_int
id|prom_base_size
op_assign
l_int|0x1000000
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
multiline_comment|/* Allocate resource maps based on bus page size; for I/O and memory&n;     * space, free all pages except those in the base area and in the&n;     * range set by the PROM.&n;     *&n;     * PROM creates BAR addresses in this format: 0x0ws00000 where w is&n;     * the widget number and s is the device register offset for the slot.&n;     */
multiline_comment|/* Setup the Bus&squot;s PCI IO Root Resource. */
id|pcibr_soft-&gt;bs_io_win_root_resource.start
op_assign
id|PCIBR_BUS_IO_BASE
suffix:semicolon
id|pcibr_soft-&gt;bs_io_win_root_resource.end
op_assign
l_int|0xffffffff
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to allocate resource structure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Block off the range used by PROM. */
id|res-&gt;start
op_assign
id|prom_base_addr
suffix:semicolon
id|res-&gt;end
op_assign
id|prom_base_addr
op_plus
(paren
id|prom_base_size
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|request_resource
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_io_win_root_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to request_resource()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the Small Window Root Resource */
id|pcibr_soft-&gt;bs_swin_root_resource.start
op_assign
id|PAGE_SIZE
suffix:semicolon
id|pcibr_soft-&gt;bs_swin_root_resource.end
op_assign
l_int|0x000FFFFF
suffix:semicolon
multiline_comment|/* Setup the Bus&squot;s PCI Memory Root Resource */
id|pcibr_soft-&gt;bs_mem_win_root_resource.start
op_assign
l_int|0x200000
suffix:semicolon
id|pcibr_soft-&gt;bs_mem_win_root_resource.end
op_assign
l_int|0xffffffff
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to allocate resource structure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Block off the range used by PROM. */
id|res-&gt;start
op_assign
id|prom_base_addr
suffix:semicolon
id|res-&gt;end
op_assign
id|prom_base_addr
op_plus
(paren
id|prom_base_size
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|request_resource
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_mem_win_root_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|panic
c_func
(paren
l_string|&quot;PCIBR:Unable to request_resource()&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* build &quot;no-slot&quot; connection point */
id|pcibr_info
op_assign
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft
comma
id|PCIIO_SLOT_NONE
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
id|noslot_conn
op_assign
id|pciio_device_info_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
multiline_comment|/* Store no slot connection point info for tearing it down during detach. */
id|pcibr_soft-&gt;bs_noslot_conn
op_assign
id|noslot_conn
suffix:semicolon
id|pcibr_soft-&gt;bs_noslot_info
op_assign
id|pcibr_info
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Find out what is out there */
(paren
r_void
)paren
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Set up the address space for this slot in the PCI land */
(paren
r_void
)paren
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Setup the device register */
(paren
r_void
)paren
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibr_soft
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_pcix_rbar_inuse
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_avail
op_assign
id|NUM_RBAR
suffix:semicolon
id|pcibr_soft-&gt;bs_pcix_rbar_percent_allowed
op_assign
id|pcibr_pcix_rbars_calc
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Setup the PCI-X Read Buffer Attribute Registers (RBARs) */
(paren
r_void
)paren
id|pcibr_slot_pcix_rbar_init
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Setup host/guest relations */
(paren
r_void
)paren
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle initial RRB management */
id|pcibr_initial_rrb
c_func
(paren
id|pcibr_vhdl
comma
id|pcibr_soft-&gt;bs_first_slot
comma
id|pcibr_soft-&gt;bs_last_slot
)paren
suffix:semicolon
multiline_comment|/* Before any drivers get called that may want to re-allocate RRB&squot;s,&n;    * let&squot;s get some special cases pre-allocated. Drivers may override&n;    * these pre-allocations, but by doing pre-allocations now we&squot;re&n;    * assured not to step all over what the driver intended.&n;    */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|pcibr_soft-&gt;bs_bricktype
)paren
(brace
r_case
id|MODULE_PXBRICK
suffix:colon
r_case
id|MODULE_IXBRICK
suffix:colon
r_case
id|MODULE_OPUSBRICK
suffix:colon
multiline_comment|/*&n;&t;&t; * If IO9 in bus 1, allocate RRBs to all the IO9 devices&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pcibr_widget_to_bus
c_func
(paren
id|pcibr_vhdl
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_slot
(braket
l_int|0
)braket
dot
id|bss_vendor_id
op_eq
l_int|0x10A9
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_slot
(braket
l_int|0
)braket
dot
id|bss_device_id
op_eq
l_int|0x100A
)paren
)paren
(brace
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|2
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|3
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
id|VCHAN0
comma
l_int|4
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MODULE_CGBRICK
suffix:colon
id|pcibr_rrb_alloc_init
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|VCHAN0
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
)brace
r_for
c_loop
(paren
id|slot
op_assign
id|pcibr_soft-&gt;bs_min_slot
suffix:semicolon
id|slot
OL
id|PCIBR_NUM_SLOTS
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
op_increment
id|slot
)paren
(brace
multiline_comment|/* Call the device attach */
(paren
r_void
)paren
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
)brace
id|pciio_device_attach
c_func
(paren
id|noslot_conn
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci provider functions&n; *&n; * mostly in pcibr.c but if any are needed here then&n; * this might be a way to get them here.&n; */
DECL|variable|pci_pic_provider
id|pciio_provider_t
id|pci_pic_provider
op_assign
(brace
id|PCIIO_ASIC_TYPE_PIC
comma
(paren
id|pciio_piomap_alloc_f
op_star
)paren
id|pcibr_piomap_alloc
comma
(paren
id|pciio_piomap_free_f
op_star
)paren
id|pcibr_piomap_free
comma
(paren
id|pciio_piomap_addr_f
op_star
)paren
id|pcibr_piomap_addr
comma
(paren
id|pciio_piomap_done_f
op_star
)paren
id|pcibr_piomap_done
comma
(paren
id|pciio_piotrans_addr_f
op_star
)paren
id|pcibr_piotrans_addr
comma
(paren
id|pciio_piospace_alloc_f
op_star
)paren
id|pcibr_piospace_alloc
comma
(paren
id|pciio_piospace_free_f
op_star
)paren
id|pcibr_piospace_free
comma
(paren
id|pciio_dmamap_alloc_f
op_star
)paren
id|pcibr_dmamap_alloc
comma
(paren
id|pciio_dmamap_free_f
op_star
)paren
id|pcibr_dmamap_free
comma
(paren
id|pciio_dmamap_addr_f
op_star
)paren
id|pcibr_dmamap_addr
comma
(paren
id|pciio_dmamap_done_f
op_star
)paren
id|pcibr_dmamap_done
comma
(paren
id|pciio_dmatrans_addr_f
op_star
)paren
id|pcibr_dmatrans_addr
comma
(paren
id|pciio_dmamap_drain_f
op_star
)paren
id|pcibr_dmamap_drain
comma
(paren
id|pciio_dmaaddr_drain_f
op_star
)paren
id|pcibr_dmaaddr_drain
comma
(paren
id|pciio_intr_alloc_f
op_star
)paren
id|pcibr_intr_alloc
comma
(paren
id|pciio_intr_free_f
op_star
)paren
id|pcibr_intr_free
comma
(paren
id|pciio_intr_connect_f
op_star
)paren
id|pcibr_intr_connect
comma
(paren
id|pciio_intr_disconnect_f
op_star
)paren
id|pcibr_intr_disconnect
comma
(paren
id|pciio_intr_cpu_get_f
op_star
)paren
id|pcibr_intr_cpu_get
comma
(paren
id|pciio_provider_startup_f
op_star
)paren
id|pcibr_provider_startup
comma
(paren
id|pciio_provider_shutdown_f
op_star
)paren
id|pcibr_provider_shutdown
comma
(paren
id|pciio_reset_f
op_star
)paren
id|pcibr_reset
comma
(paren
id|pciio_endian_set_f
op_star
)paren
id|pcibr_endian_set
comma
(paren
id|pciio_config_get_f
op_star
)paren
id|pcibr_config_get
comma
(paren
id|pciio_config_set_f
op_star
)paren
id|pcibr_config_set
comma
(paren
id|pciio_error_extract_f
op_star
)paren
id|pcibr_error_extract
comma
(paren
id|pciio_driver_reg_callback_f
op_star
)paren
id|pcibr_driver_reg_callback
comma
(paren
id|pciio_driver_unreg_callback_f
op_star
)paren
id|pcibr_driver_unreg_callback
comma
(paren
id|pciio_device_unregister_f
op_star
)paren
id|pcibr_device_unregister
comma
)brace
suffix:semicolon
eof
