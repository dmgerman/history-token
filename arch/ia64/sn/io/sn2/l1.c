multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All rights reserved.&n; */
multiline_comment|/* In general, this file is organized in a hierarchy from lower-level&n; * to higher-level layers, as follows:&n; *&n; *&t;UART routines&n; *&t;Bedrock/L1 &quot;PPP-like&quot; protocol implementation&n; *&t;System controller &quot;message&quot; interface (allows multiplexing&n; *&t;&t;of various kinds of requests and responses with&n; *&t;&t;console I/O)&n; *&t;Console interface:&n; *&t;  &quot;l1_cons&quot;, the glue that allows the L1 to act&n; *&t;&t;as the system console for the stdio libraries&n; *&n; * Routines making use of the system controller &quot;message&quot;-style interface&n; * can be found in l1_command.c.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/router.h&gt;
macro_line|#include &lt;asm/sn/module.h&gt;
macro_line|#include &lt;asm/sn/ksys/l1.h&gt;
macro_line|#include &lt;asm/sn/nodepda.h&gt;
macro_line|#include &lt;asm/sn/clksupport.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/uart16550.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
DECL|macro|UART_BAUD_RATE
mdefine_line|#define UART_BAUD_RATE          57600
DECL|variable|L1_connected
r_static
r_int
id|L1_connected
suffix:semicolon
multiline_comment|/* non-zero when interrupts are enabled */
r_int
DECL|function|get_L1_baud
id|get_L1_baud
c_func
(paren
r_void
)paren
(brace
r_return
id|UART_BAUD_RATE
suffix:semicolon
)brace
multiline_comment|/* Return the current interrupt level */
r_int
DECL|function|l1_get_intr_value
id|l1_get_intr_value
c_func
(paren
r_void
)paren
(brace
id|cpuid_t
id|intr_cpuid
suffix:semicolon
id|nasid_t
id|console_nasid
suffix:semicolon
r_int
id|major
comma
id|minor
suffix:semicolon
r_extern
id|nasid_t
id|get_console_nasid
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* if it is an old prom, run in poll mode */
id|major
op_assign
id|sn_sal_rev_major
c_func
(paren
)paren
suffix:semicolon
id|minor
op_assign
id|sn_sal_rev_minor
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|major
OL
l_int|1
)paren
op_logical_or
(paren
(paren
id|major
op_eq
l_int|1
)paren
op_logical_and
(paren
id|minor
OL
l_int|10
)paren
)paren
)paren
(brace
multiline_comment|/* before version 1.10 doesn&squot;t work */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|console_nasid
op_assign
id|get_console_nasid
c_func
(paren
)paren
suffix:semicolon
id|intr_cpuid
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|console_nasid
)paren
)paren
op_member_access_from_pointer
id|node_first_cpu
suffix:semicolon
r_return
id|CPU_VECTOR_TO_IRQ
c_func
(paren
id|intr_cpuid
comma
id|SGI_UART_VECTOR
)paren
suffix:semicolon
)brace
multiline_comment|/* Disconnect the callup functions - throw away interrupts */
r_void
DECL|function|l1_unconnect_intr
id|l1_unconnect_intr
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/* Set up uart interrupt handling for this node&squot;s uart */
r_int
DECL|function|l1_connect_intr
id|l1_connect_intr
c_func
(paren
r_void
op_star
id|intr_func
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|cpuid_t
id|intr_cpuid
suffix:semicolon
id|nasid_t
id|console_nasid
suffix:semicolon
r_int
r_int
id|console_irq
suffix:semicolon
r_int
id|result
suffix:semicolon
r_extern
r_int
id|intr_connect_level
c_func
(paren
id|cpuid_t
comma
r_int
comma
id|ilvl_t
comma
id|intr_func_t
)paren
suffix:semicolon
r_extern
id|nasid_t
id|get_console_nasid
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* don&squot;t call to connect multiple times - we DON&squot;T support changing the handler */
r_if
c_cond
(paren
op_logical_neg
id|L1_connected
)paren
(brace
id|L1_connected
op_increment
suffix:semicolon
id|console_nasid
op_assign
id|get_console_nasid
c_func
(paren
)paren
suffix:semicolon
id|intr_cpuid
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|console_nasid
)paren
)paren
op_member_access_from_pointer
id|node_first_cpu
suffix:semicolon
id|console_irq
op_assign
id|CPU_VECTOR_TO_IRQ
c_func
(paren
id|intr_cpuid
comma
id|SGI_UART_VECTOR
)paren
suffix:semicolon
id|result
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpuid
comma
id|SGI_UART_VECTOR
comma
l_int|0
multiline_comment|/*not used*/
comma
l_int|0
multiline_comment|/*not used*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|SGI_UART_VECTOR
)paren
(brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;L1 console driver : intr_connect_level failed %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;L1 console driver : intr_connect_level returns wrong bit %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|result
op_assign
id|request_irq
c_func
(paren
id|console_irq
comma
id|intr_func
comma
id|SA_INTERRUPT
comma
l_string|&quot;SGI L1 console driver&quot;
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;L1 console driver : request_irq failed %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ask SAL to turn on interrupts in the UART itself */
id|ia64_sn_console_intr_enable
c_func
(paren
id|SAL_CONSOLE_INTR_RECV
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* These are functions to use from serial_in/out when in protocol&n; * mode to send and receive uart control regs. These are external&n; * interfaces into the protocol driver.&n; */
r_void
DECL|function|l1_control_out
id|l1_control_out
c_func
(paren
r_int
id|offset
comma
r_int
id|value
)paren
(brace
multiline_comment|/* quietly ignore unless simulator */
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
r_if
c_cond
(paren
id|master_node_bedrock_address
op_ne
(paren
id|u64
)paren
l_int|0
)paren
(brace
id|writeb
c_func
(paren
id|value
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|offset
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Console input exported interface. Return a register value.  */
r_int
DECL|function|l1_control_in_polled
id|l1_control_in_polled
c_func
(paren
r_int
id|offset
)paren
(brace
r_static
r_int
id|l1_control_in_local
c_func
(paren
r_int
)paren
suffix:semicolon
r_return
id|l1_control_in_local
c_func
(paren
id|offset
)paren
suffix:semicolon
)brace
r_int
DECL|function|l1_control_in
id|l1_control_in
c_func
(paren
r_int
id|offset
)paren
(brace
r_static
r_int
id|l1_control_in_local
c_func
(paren
r_int
)paren
suffix:semicolon
r_return
id|l1_control_in_local
c_func
(paren
id|offset
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|l1_control_in_local
id|l1_control_in_local
c_func
(paren
r_int
id|offset
)paren
(brace
r_int
id|sal_call_status
op_assign
l_int|0
comma
id|input
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
id|ret
op_assign
id|readb
c_func
(paren
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|offset
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_eq
id|REG_LSR
)paren
(brace
id|ret
op_assign
(paren
id|LSR_XHRE
op_or
id|LSR_XSRE
)paren
suffix:semicolon
multiline_comment|/* can send anytime */
id|sal_call_status
op_assign
id|ia64_sn_console_check
c_func
(paren
op_amp
id|input
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sal_call_status
op_logical_and
id|input
)paren
(brace
multiline_comment|/* input pending */
id|ret
op_or_assign
id|LSR_RCA
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Console input exported interface. Return a character (if one is available)&n; */
r_int
DECL|function|l1_serial_in_polled
id|l1_serial_in_polled
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|l1_serial_in_local
c_func
(paren
r_void
)paren
suffix:semicolon
r_return
id|l1_serial_in_local
c_func
(paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|l1_serial_in
id|l1_serial_in
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|l1_serial_in_local
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
r_return
id|readb
c_func
(paren
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_return
id|l1_serial_in_local
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|l1_serial_in_local
id|l1_serial_in_local
c_func
(paren
r_void
)paren
(brace
r_int
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
r_return
id|readb
c_func
(paren
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ia64_sn_console_getc
c_func
(paren
op_amp
id|ch
)paren
)paren
)paren
r_return
id|ch
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Console output exported interface. Write message to the console.  */
r_int
DECL|function|l1_serial_out
id|l1_serial_out
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|len
)paren
(brace
r_int
id|tmp
suffix:semicolon
multiline_comment|/* Ignore empty messages */
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|len
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_EARLY_PRINTK)
multiline_comment|/* Need to setup SAL calls so the PROM calls will work */
(brace
r_static
r_int
id|inited
suffix:semicolon
r_void
id|early_sn_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inited
)paren
(brace
id|inited
op_assign
l_int|1
suffix:semicolon
id|early_sn_setup
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
r_void
id|early_sn_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|counter
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|master_node_bedrock_address
)paren
id|early_sn_setup
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master_node_bedrock_address
op_ne
(paren
id|u64
)paren
l_int|0
)paren
(brace
macro_line|#ifdef FLAG_DIRECT_CONSOLE_WRITES
multiline_comment|/* This is an easy way to pre-pend the output to know whether the output&n;&t;&t;&t; * was done via sal or directly */
id|writeb
c_func
(paren
l_char|&squot;[&squot;
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot;+&squot;
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot;]&squot;
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot; &squot;
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
macro_line|#endif&t;/* FLAG_DIRECT_CONSOLE_WRITES */
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
id|writeb
c_func
(paren
op_star
id|str
comma
(paren
r_int
r_int
)paren
id|master_node_bedrock_address
op_plus
(paren
id|REG_DAT
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Attempt to write things out thru the sal */
r_if
c_cond
(paren
id|L1_connected
)paren
id|tmp
op_assign
id|ia64_sn_console_xmit_chars
c_func
(paren
id|str
comma
id|len
)paren
suffix:semicolon
r_else
id|tmp
op_assign
id|ia64_sn_console_putb
c_func
(paren
id|str
comma
id|len
)paren
suffix:semicolon
r_return
(paren
(paren
id|tmp
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|tmp
)paren
suffix:semicolon
)brace
eof
