multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992-1997, 2000-2002 Silicon Graphics, Inc.  All rights reserved.&n; */
multiline_comment|/* In general, this file is organized in a hierarchy from lower-level&n; * to higher-level layers, as follows:&n; *&n; *&t;UART routines&n; *&t;Bedrock/L1 &quot;PPP-like&quot; protocol implementation&n; *&t;System controller &quot;message&quot; interface (allows multiplexing&n; *&t;&t;of various kinds of requests and responses with&n; *&t;&t;console I/O)&n; *&t;Console interface:&n; *&t;  &quot;l1_cons&quot;, the glue that allows the L1 to act&n; *&t;&t;as the system console for the stdio libraries&n; *&n; * Routines making use of the system controller &quot;message&quot;-style interface&n; * can be found in l1_command.c.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/router.h&gt;
macro_line|#include &lt;asm/sn/module.h&gt;
macro_line|#include &lt;asm/sn/ksys/l1.h&gt;
macro_line|#include &lt;asm/sn/nodepda.h&gt;
macro_line|#include &lt;asm/sn/clksupport.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/uart16550.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
multiline_comment|/* Make all console writes atomic */
DECL|macro|SYNC_CONSOLE_WRITE
mdefine_line|#define SYNC_CONSOLE_WRITE&t;1
multiline_comment|/*********************************************************************&n; * Hardware-level (UART) driver routines.&n; */
multiline_comment|/* macros for reading/writing registers */
DECL|macro|LD
mdefine_line|#define LD(x)&t;&t;&t;(*(volatile uint64_t *)(x))
DECL|macro|SD
mdefine_line|#define SD(x, v)        &t;(LD(x) = (uint64_t) (v))
multiline_comment|/* location of uart receive/xmit data register */
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
DECL|macro|L1_UART_BASE
mdefine_line|#define L1_UART_BASE(n)&t;&t;((ulong)REMOTE_HSPEC_ADDR((n), 0x00000080))
DECL|macro|LOCK_HUB
mdefine_line|#define LOCK_HUB&t;&t;REMOTE_HUB_ADDR
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
DECL|macro|L1_UART_BASE
mdefine_line|#define L1_UART_BASE(n)&t;&t;((ulong)REMOTE_HUB((n), SH_JUNK_BUS_UART0))
DECL|macro|LOCK_HUB
mdefine_line|#define LOCK_HUB&t;&t;REMOTE_HUB
DECL|typedef|rtc_time_t
r_typedef
id|u64
id|rtc_time_t
suffix:semicolon
macro_line|#endif
DECL|macro|ADDR_L1_REG
mdefine_line|#define ADDR_L1_REG(n, r)&t;( L1_UART_BASE(n) | ( (r) &lt;&lt; 3 ) )
DECL|macro|READ_L1_UART_REG
mdefine_line|#define READ_L1_UART_REG(n, r)&t;( LD(ADDR_L1_REG((n), (r))) )
DECL|macro|WRITE_L1_UART_REG
mdefine_line|#define WRITE_L1_UART_REG(n, r, v) ( SD(ADDR_L1_REG((n), (r)), (v)) )
multiline_comment|/* upper layer interface calling methods */
DECL|macro|SERIAL_INTERRUPT_MODE
mdefine_line|#define SERIAL_INTERRUPT_MODE&t;0
DECL|macro|SERIAL_POLLED_MODE
mdefine_line|#define SERIAL_POLLED_MODE&t;1
multiline_comment|/* UART-related #defines */
DECL|macro|UART_BAUD_RATE
mdefine_line|#define UART_BAUD_RATE&t;&t;57600
DECL|macro|UART_FIFO_DEPTH
mdefine_line|#define UART_FIFO_DEPTH&t;&t;16
DECL|macro|UART_DELAY_SPAN
mdefine_line|#define UART_DELAY_SPAN&t;&t;10
DECL|macro|UART_PUTC_TIMEOUT
mdefine_line|#define UART_PUTC_TIMEOUT&t;50000
DECL|macro|UART_INIT_TIMEOUT
mdefine_line|#define UART_INIT_TIMEOUT&t;100000
multiline_comment|/* error codes */
DECL|macro|UART_SUCCESS
mdefine_line|#define UART_SUCCESS&t;&t;  0
DECL|macro|UART_TIMEOUT
mdefine_line|#define UART_TIMEOUT&t;&t;(-1)
DECL|macro|UART_LINK
mdefine_line|#define UART_LINK&t;&t;(-2)
DECL|macro|UART_NO_CHAR
mdefine_line|#define UART_NO_CHAR&t;&t;(-3)
DECL|macro|UART_VECTOR
mdefine_line|#define UART_VECTOR&t;&t;(-4)
DECL|macro|UART_DELAY
mdefine_line|#define UART_DELAY(x)&t;&t;udelay(x)
multiline_comment|/* Some debug counters */
DECL|macro|L1C_INTERRUPTS
mdefine_line|#define L1C_INTERRUPTS&t;&t;0
DECL|macro|L1C_OUR_R_INTERRUPTS
mdefine_line|#define L1C_OUR_R_INTERRUPTS&t;1
DECL|macro|L1C_OUR_X_INTERRUPTS
mdefine_line|#define L1C_OUR_X_INTERRUPTS&t;2
DECL|macro|L1C_SEND_CALLUPS
mdefine_line|#define L1C_SEND_CALLUPS&t;3
DECL|macro|L1C_RECEIVE_CALLUPS
mdefine_line|#define L1C_RECEIVE_CALLUPS&t;4
DECL|macro|L1C_SET_BAUD
mdefine_line|#define L1C_SET_BAUD&t;&t;5
DECL|macro|L1C_ALREADY_LOCKED
mdefine_line|#define L1C_ALREADY_LOCKED&t;L1C_SET_BAUD
DECL|macro|L1C_R_IRQ
mdefine_line|#define L1C_R_IRQ&t;&t;6
DECL|macro|L1C_R_IRQ_RET
mdefine_line|#define L1C_R_IRQ_RET&t;&t;7
DECL|macro|L1C_LOCK_TIMEOUTS
mdefine_line|#define L1C_LOCK_TIMEOUTS&t;8
DECL|macro|L1C_LOCK_COUNTER
mdefine_line|#define L1C_LOCK_COUNTER&t;9
DECL|macro|L1C_UNLOCK_COUNTER
mdefine_line|#define L1C_UNLOCK_COUNTER&t;10
DECL|macro|L1C_REC_STALLS
mdefine_line|#define L1C_REC_STALLS&t;&t;11
DECL|macro|L1C_CONNECT_CALLS
mdefine_line|#define L1C_CONNECT_CALLS&t;12
DECL|macro|L1C_SIZE
mdefine_line|#define L1C_SIZE&t;&t;L1C_CONNECT_CALLS&t;/* Set to the last one */
DECL|variable|L1_collectibles
r_uint64
id|L1_collectibles
(braket
id|L1C_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Some macros for handling Endian-ness&n; */
DECL|macro|COPY_INT_TO_BUFFER
mdefine_line|#define COPY_INT_TO_BUFFER(_b, _i, _n)&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_b[_i++] = (_n &gt;&gt; 24) &amp; 0xff;&t;&bslash;&n;&t;&t;_b[_i++] = (_n &gt;&gt; 16) &amp; 0xff;&t;&bslash;&n;&t;&t;_b[_i++] = (_n &gt;&gt;  8) &amp; 0xff;&t;&bslash;&n;&t;&t;_b[_i++] =  _n        &amp; 0xff;&t;&bslash;&n;&t;}
DECL|macro|COPY_BUFFER_TO_INT
mdefine_line|#define COPY_BUFFER_TO_INT(_b, _i, _n)&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_n  = (_b[_i++] &lt;&lt; 24) &amp; 0xff;&t;&bslash;&n;&t;&t;_n |= (_b[_i++] &lt;&lt; 16) &amp; 0xff;&t;&bslash;&n;&t;&t;_n |= (_b[_i++] &lt;&lt;  8) &amp; 0xff;&t;&bslash;&n;&t;&t;_n |=  _b[_i++]        &amp; 0xff;&t;&bslash;&n;&t;}
DECL|macro|COPY_BUFFER_TO_BUFFER
mdefine_line|#define COPY_BUFFER_TO_BUFFER(_b, _i, _bn)&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&bslash;&n;&t;    char *_xyz = (char *)_bn;&t;&t;&bslash;&n;&t;    _xyz[3] = _b[_i++];&t;&t;&t;&bslash;&n;&t;    _xyz[2] = _b[_i++];&t;&t;&t;&bslash;&n;&t;    _xyz[1] = _b[_i++];&t;&t;&t;&bslash;&n;&t;    _xyz[0] = _b[_i++];&t;&t;&t;&bslash;&n;&t;}
r_void
id|snia_kmem_free
c_func
(paren
r_void
op_star
id|where
comma
r_int
id|size
)paren
suffix:semicolon
DECL|macro|ALREADY_LOCKED
mdefine_line|#define ALREADY_LOCKED&t;&t;1
DECL|macro|NOT_LOCKED
mdefine_line|#define NOT_LOCKED&t;&t;0
r_static
r_int
id|early_l1_serial_out
c_func
(paren
id|nasid_t
comma
r_char
op_star
comma
r_int
comma
r_int
multiline_comment|/* defines above*/
)paren
suffix:semicolon
DECL|macro|BCOPY
mdefine_line|#define BCOPY(x,y,z)&t;memcpy(y,x,z)
DECL|variable|L1_interrupts_connected
r_uint8
id|L1_interrupts_connected
suffix:semicolon
multiline_comment|/* Non-zero when we are in interrupt mode */
multiline_comment|/*&n; * Console locking defines and functions.&n; *&n; */
DECL|variable|L1_cons_is_inited
r_uint8
id|L1_cons_is_inited
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* non-zero when console is init&squot;d */
DECL|variable|Master_console_nasid
id|nasid_t
id|Master_console_nasid
op_assign
(paren
id|nasid_t
)paren
op_minus
l_int|1
suffix:semicolon
r_extern
id|nasid_t
id|console_nasid
suffix:semicolon
id|u64
id|ia64_sn_get_console_nasid
c_func
(paren
r_void
)paren
suffix:semicolon
r_inline
id|nasid_t
DECL|function|get_master_nasid
id|get_master_nasid
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
id|nasid_t
id|nasid
op_assign
id|Master_console_nasid
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
(paren
id|nasid_t
)paren
op_minus
l_int|1
)paren
(brace
id|nasid
op_assign
(paren
id|nasid_t
)paren
id|ia64_sn_get_console_nasid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nasid
OL
l_int|0
)paren
op_logical_or
(paren
id|nasid
op_ge
id|MAX_NASIDS
)paren
)paren
(brace
multiline_comment|/* Out of bounds, use local */
id|console_nasid
op_assign
id|nasid
op_assign
id|get_nasid
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Got a valid nasid, set the console_nasid */
r_char
id|xx
(braket
l_int|100
)braket
suffix:semicolon
multiline_comment|/* zzzzzz - force nasid to 0 for now */
id|sprintf
c_func
(paren
id|xx
comma
l_string|&quot;Master console is set to nasid %d (%d)&bslash;n&quot;
comma
l_int|0
comma
(paren
r_int
)paren
id|nasid
)paren
suffix:semicolon
id|nasid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end zzzzzz */
id|xx
(braket
l_int|99
)braket
op_assign
(paren
r_char
)paren
l_int|0
suffix:semicolon
id|early_l1_serial_out
c_func
(paren
id|nasid
comma
id|xx
comma
id|strlen
c_func
(paren
id|xx
)paren
comma
id|NOT_LOCKED
)paren
suffix:semicolon
id|Master_console_nasid
op_assign
id|console_nasid
op_assign
id|nasid
suffix:semicolon
)brace
)brace
r_return
id|nasid
suffix:semicolon
macro_line|#else
r_return
(paren
id|nasid_t
)paren
l_int|0
suffix:semicolon
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
)brace
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
DECL|macro|HUB_LOCK
mdefine_line|#define HUB_LOCK&t;&t;16
DECL|macro|PRIMARY_LOCK_TIMEOUT
mdefine_line|#define PRIMARY_LOCK_TIMEOUT    10000000
DECL|macro|HUB_LOCK_REG
mdefine_line|#define HUB_LOCK_REG(n)         LOCK_HUB(n, MD_PERF_CNT0)
DECL|macro|SET_BITS
mdefine_line|#define SET_BITS(reg, bits)     SD(reg, LD(reg) |  (bits))
DECL|macro|CLR_BITS
mdefine_line|#define CLR_BITS(reg, bits)     SD(reg, LD(reg) &amp; ~(bits))
DECL|macro|TST_BITS
mdefine_line|#define TST_BITS(reg, bits)     ((LD(reg) &amp; (bits)) != 0)
DECL|macro|HUB_TEST_AND_SET
mdefine_line|#define HUB_TEST_AND_SET(n)&t;LD(LOCK_HUB(n,LB_SCRATCH_REG3_RZ))
DECL|macro|HUB_CLEAR
mdefine_line|#define HUB_CLEAR(n)&t;&t;SD(LOCK_HUB(n,LB_SCRATCH_REG3),0)
DECL|macro|RTC_TIME_MAX
mdefine_line|#define RTC_TIME_MAX&t;&t;((rtc_time_t) ~0ULL)
multiline_comment|/*&n; * primary_lock&n; *&n; *   Allows CPU&squot;s 0-3  to mutually exclude the hub from one another by&n; *   obtaining a blocking lock.  Does nothing if only one CPU is active.&n; *&n; *   This lock should be held just long enough to set or clear a global&n; *   lock bit.  After a relatively short timeout period, this routine&n; *   figures something is wrong, and steals the lock. It does not set&n; *   any other CPU to &quot;dead&quot;.&n; */
r_inline
r_void
DECL|function|primary_lock
id|primary_lock
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|rtc_time_t
id|expire
suffix:semicolon
id|expire
op_assign
id|rtc_time
c_func
(paren
)paren
op_plus
id|PRIMARY_LOCK_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|HUB_TEST_AND_SET
c_func
(paren
id|nasid
)paren
)paren
(brace
r_if
c_cond
(paren
id|rtc_time
c_func
(paren
)paren
OG
id|expire
)paren
(brace
id|HUB_CLEAR
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * primary_unlock (internal)&n; *&n; *   Counterpart to primary_lock&n; */
r_inline
r_void
DECL|function|primary_unlock
id|primary_unlock
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|HUB_CLEAR
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_unlock&n; *&n; *   Counterpart to hub_lock_timeout and hub_lock&n; */
r_inline
r_void
DECL|function|hub_unlock
id|hub_unlock
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|level
)paren
(brace
r_uint64
id|mask
op_assign
l_int|1ULL
op_lshift
id|level
suffix:semicolon
id|primary_lock
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|CLR_BITS
c_func
(paren
id|HUB_LOCK_REG
c_func
(paren
id|nasid
)paren
comma
id|mask
)paren
suffix:semicolon
id|primary_unlock
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hub_lock_timeout&n; *&n; *   Uses primary_lock to implement multiple lock levels.&n; *&n; *   There are 20 lock levels from 0 to 19 (limited by the number of bits&n; *   in HUB_LOCK_REG).  To prevent deadlock, multiple locks should be&n; *   obtained in order of increasingly higher level, and released in the&n; *   reverse order.&n; *&n; *   A timeout value of 0 may be used for no timeout.&n; *&n; *   Returns 0 if successful, -1 if lock times out.&n; */
r_inline
r_int
DECL|function|hub_lock_timeout
id|hub_lock_timeout
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|level
comma
id|rtc_time_t
id|timeout
)paren
(brace
r_uint64
id|mask
op_assign
l_int|1ULL
op_lshift
id|level
suffix:semicolon
id|rtc_time_t
id|expire
op_assign
(paren
id|timeout
ques
c_cond
id|rtc_time
c_func
(paren
)paren
op_plus
id|timeout
suffix:colon
id|RTC_TIME_MAX
)paren
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_while
c_loop
(paren
id|TST_BITS
c_func
(paren
id|HUB_LOCK_REG
c_func
(paren
id|nasid
)paren
comma
id|mask
)paren
)paren
(brace
r_if
c_cond
(paren
id|rtc_time
c_func
(paren
)paren
OG
id|expire
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|primary_lock
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TST_BITS
c_func
(paren
id|HUB_LOCK_REG
c_func
(paren
id|nasid
)paren
comma
id|mask
)paren
)paren
(brace
id|SET_BITS
c_func
(paren
id|HUB_LOCK_REG
c_func
(paren
id|nasid
)paren
comma
id|mask
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|primary_unlock
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LOCK_TIMEOUT
mdefine_line|#define LOCK_TIMEOUT&t;(0x1500000 * 1) /* 0x1500000 is ~30 sec */
r_void
DECL|function|lock_console
id|lock_console
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* If we already have it locked, just return */
id|L1_collectibles
(braket
id|L1C_LOCK_COUNTER
)braket
op_increment
suffix:semicolon
id|ret
op_assign
id|hub_lock_timeout
c_func
(paren
id|nasid
comma
id|HUB_LOCK
comma
(paren
id|rtc_time_t
)paren
id|LOCK_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|L1_collectibles
(braket
id|L1C_LOCK_TIMEOUTS
)braket
op_increment
suffix:semicolon
multiline_comment|/* timeout */
id|hub_unlock
c_func
(paren
id|nasid
comma
id|HUB_LOCK
)paren
suffix:semicolon
multiline_comment|/* If the 2nd lock fails, just pile ahead.... */
id|hub_lock_timeout
c_func
(paren
id|nasid
comma
id|HUB_LOCK
comma
(paren
id|rtc_time_t
)paren
id|LOCK_TIMEOUT
)paren
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_LOCK_TIMEOUTS
)braket
op_increment
suffix:semicolon
)brace
)brace
r_inline
r_void
DECL|function|unlock_console
id|unlock_console
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
id|L1_collectibles
(braket
id|L1C_UNLOCK_COUNTER
)braket
op_increment
suffix:semicolon
id|hub_unlock
c_func
(paren
id|nasid
comma
id|HUB_LOCK
)paren
suffix:semicolon
)brace
macro_line|#else /* SN2 */
DECL|function|lock_console
r_inline
r_void
id|lock_console
c_func
(paren
id|nasid_t
id|n
)paren
(brace
)brace
DECL|function|unlock_console
r_inline
r_void
id|unlock_console
c_func
(paren
id|nasid_t
id|n
)paren
(brace
)brace
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
r_int
DECL|function|get_L1_baud
id|get_L1_baud
c_func
(paren
r_void
)paren
(brace
r_return
id|UART_BAUD_RATE
suffix:semicolon
)brace
multiline_comment|/* uart driver functions */
r_static
r_inline
r_void
DECL|function|uart_delay
id|uart_delay
c_func
(paren
id|rtc_time_t
id|delay_span
)paren
(brace
id|UART_DELAY
c_func
(paren
id|delay_span
)paren
suffix:semicolon
)brace
DECL|macro|UART_PUTC_READY
mdefine_line|#define UART_PUTC_READY(n)      (READ_L1_UART_REG((n), REG_LSR) &amp; LSR_XHRE)
r_static
r_int
DECL|function|uart_putc
id|uart_putc
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
id|WRITE_L1_UART_REG
c_func
(paren
id|sc-&gt;nasid
comma
id|REG_DAT
comma
id|sc-&gt;send
(braket
id|sc-&gt;sent
)braket
)paren
suffix:semicolon
r_return
id|UART_SUCCESS
suffix:semicolon
)brace
r_static
r_int
DECL|function|uart_getc
id|uart_getc
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
id|u_char
id|lsr_reg
op_assign
l_int|0
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lsr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LSR
)paren
)paren
op_amp
(paren
id|LSR_RCA
op_or
id|LSR_PARERR
op_or
id|LSR_FRMERR
)paren
)paren
(brace
r_if
c_cond
(paren
id|lsr_reg
op_amp
id|LSR_RCA
)paren
(brace
r_return
(paren
id|u_char
)paren
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_DAT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lsr_reg
op_amp
(paren
id|LSR_PARERR
op_or
id|LSR_FRMERR
)paren
)paren
(brace
r_return
id|UART_LINK
suffix:semicolon
)brace
)brace
r_return
id|UART_NO_CHAR
suffix:semicolon
)brace
DECL|macro|PROM_SER_CLK_SPEED
mdefine_line|#define PROM_SER_CLK_SPEED&t;12000000
DECL|macro|PROM_SER_DIVISOR
mdefine_line|#define PROM_SER_DIVISOR(x)&t;(PROM_SER_CLK_SPEED / ((x) * 16))
r_static
r_void
DECL|function|uart_init
id|uart_init
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|baud
)paren
(brace
id|rtc_time_t
id|expire
suffix:semicolon
r_int
id|clkdiv
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|clkdiv
op_assign
id|PROM_SER_DIVISOR
c_func
(paren
id|baud
)paren
suffix:semicolon
id|expire
op_assign
id|rtc_time
c_func
(paren
)paren
op_plus
id|UART_INIT_TIMEOUT
suffix:semicolon
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
multiline_comment|/* make sure the transmit FIFO is empty */
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LSR
)paren
op_amp
id|LSR_XSRE
)paren
)paren
(brace
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_time
c_func
(paren
)paren
OG
id|expire
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/* Setup for the proper baud rate */
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
comma
id|LCR_DLAB
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_DLH
comma
(paren
id|clkdiv
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_DLL
comma
id|clkdiv
op_amp
l_int|0xff
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* set operating parameters and set DLAB to 0 */
multiline_comment|/* 8bit, one stop, clear request to send, auto flow control */
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
comma
id|LCR_BITS8
op_or
id|LCR_STOP1
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_MCR
comma
id|MCR_RTS
op_or
id|MCR_AFE
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_ICR
comma
l_int|0x0
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* enable FIFO mode and reset both FIFOs, trigger on 1 */
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_FCR
comma
id|FCR_FIFOEN
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_FCR
comma
id|FCR_FIFOEN
op_or
id|FCR_RxFIFO
op_or
id|FCR_TxFIFO
op_or
id|RxLVL0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|unlock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
multiline_comment|/* This requires the console lock */
macro_line|#if&t;defined(CONFIG_IA64_SGI_SN1)
r_static
r_void
DECL|function|uart_intr_enable
id|uart_intr_enable
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|u_char
id|mask
)paren
(brace
id|u_char
id|lcr_reg
comma
id|icr_reg
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/* make sure that the DLAB bit in the LCR register is 0&n;     */
id|lcr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
)paren
suffix:semicolon
id|lcr_reg
op_and_assign
op_complement
(paren
id|LCR_DLAB
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
comma
id|lcr_reg
)paren
suffix:semicolon
multiline_comment|/* enable indicated interrupts&n;     */
id|icr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_ICR
)paren
suffix:semicolon
id|icr_reg
op_or_assign
id|mask
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_ICR
comma
id|icr_reg
multiline_comment|/*(ICR_RIEN | ICR_TIEN)*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|unlock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
multiline_comment|/* This requires the console lock */
r_static
r_void
DECL|function|uart_intr_disable
id|uart_intr_disable
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|u_char
id|mask
)paren
(brace
id|u_char
id|lcr_reg
comma
id|icr_reg
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
multiline_comment|/* make sure that the DLAB bit in the LCR register is 0&n;     */
id|lcr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
)paren
suffix:semicolon
id|lcr_reg
op_and_assign
op_complement
(paren
id|LCR_DLAB
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_LCR
comma
id|lcr_reg
)paren
suffix:semicolon
multiline_comment|/* enable indicated interrupts&n;     */
id|icr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_ICR
)paren
suffix:semicolon
id|icr_reg
op_and_assign
id|mask
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|REG_ICR
comma
id|icr_reg
multiline_comment|/*(ICR_RIEN | ICR_TIEN)*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|unlock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
DECL|macro|uart_enable_xmit_intr
mdefine_line|#define uart_enable_xmit_intr(sc) &bslash;&n;&t;uart_intr_enable((sc), ICR_TIEN)
DECL|macro|uart_disable_xmit_intr
mdefine_line|#define uart_disable_xmit_intr(sc) &bslash;&n;        uart_intr_disable((sc), ~(ICR_TIEN))
DECL|macro|uart_enable_recv_intr
mdefine_line|#define uart_enable_recv_intr(sc) &bslash;&n;        uart_intr_enable((sc), ICR_RIEN)
DECL|macro|uart_disable_recv_intr
mdefine_line|#define uart_disable_recv_intr(sc) &bslash;&n;        uart_intr_disable((sc), ~(ICR_RIEN))
multiline_comment|/*********************************************************************&n; * Routines for accessing a remote (router) UART&n; */
DECL|macro|READ_RTR_L1_UART_REG
mdefine_line|#define READ_RTR_L1_UART_REG(p, n, r, v)&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if( vector_read_node( (p), (n), 0,&t;&t;&bslash;&n;&t;&t;&t;      RR_JBUS1(r), (v) ) ) {&t;&bslash;&n;&t;    return UART_VECTOR;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;    }
DECL|macro|WRITE_RTR_L1_UART_REG
mdefine_line|#define WRITE_RTR_L1_UART_REG(p, n, r, v)&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if( vector_write_node( (p), (n), 0,&t;&t;&bslash;&n;&t;&t;&t;       RR_JBUS1(r), (v) ) ) {&t;&bslash;&n;&t;    return UART_VECTOR;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;    }
DECL|macro|RTR_UART_PUTC_TIMEOUT
mdefine_line|#define RTR_UART_PUTC_TIMEOUT&t;UART_PUTC_TIMEOUT*10
DECL|macro|RTR_UART_DELAY_SPAN
mdefine_line|#define RTR_UART_DELAY_SPAN&t;UART_DELAY_SPAN
DECL|macro|RTR_UART_INIT_TIMEOUT
mdefine_line|#define RTR_UART_INIT_TIMEOUT&t;UART_INIT_TIMEOUT*10
r_static
r_int
DECL|function|rtr_uart_putc
id|rtr_uart_putc
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_uint64
id|regval
comma
id|c
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
id|net_vec_t
id|path
op_assign
id|sc-&gt;uart
suffix:semicolon
id|rtc_time_t
id|expire
op_assign
id|rtc_time
c_func
(paren
)paren
op_plus
id|RTR_UART_PUTC_TIMEOUT
suffix:semicolon
id|c
op_assign
(paren
id|sc-&gt;send
(braket
id|sc-&gt;sent
)braket
op_amp
l_int|0xffULL
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Check for &quot;tx hold reg empty&quot; bit. */
id|READ_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_LSR
comma
op_amp
id|regval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regval
op_amp
id|LSR_XHRE
)paren
(brace
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_DAT
comma
id|c
)paren
suffix:semicolon
r_return
id|UART_SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtc_time
c_func
(paren
)paren
op_ge
id|expire
)paren
(brace
r_return
id|UART_TIMEOUT
suffix:semicolon
)brace
id|uart_delay
c_func
(paren
id|RTR_UART_DELAY_SPAN
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|rtr_uart_getc
id|rtr_uart_getc
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_uint64
id|regval
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
id|net_vec_t
id|path
op_assign
id|sc-&gt;uart
suffix:semicolon
id|READ_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_LSR
comma
op_amp
id|regval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regval
op_amp
(paren
id|LSR_RCA
op_or
id|LSR_PARERR
op_or
id|LSR_FRMERR
)paren
)paren
(brace
r_if
c_cond
(paren
id|regval
op_amp
id|LSR_RCA
)paren
(brace
id|READ_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_DAT
comma
op_amp
id|regval
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
id|regval
suffix:semicolon
)brace
r_else
(brace
r_return
id|UART_LINK
suffix:semicolon
)brace
)brace
r_return
id|UART_NO_CHAR
suffix:semicolon
)brace
r_static
r_int
DECL|function|rtr_uart_init
id|rtr_uart_init
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|baud
)paren
(brace
id|rtc_time_t
id|expire
suffix:semicolon
r_int
id|clkdiv
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|net_vec_t
id|path
suffix:semicolon
r_uint64
id|regval
suffix:semicolon
id|clkdiv
op_assign
id|PROM_SER_DIVISOR
c_func
(paren
id|baud
)paren
suffix:semicolon
id|expire
op_assign
id|rtc_time
c_func
(paren
)paren
op_plus
id|RTR_UART_INIT_TIMEOUT
suffix:semicolon
id|nasid
op_assign
id|sc-&gt;nasid
suffix:semicolon
id|path
op_assign
id|sc-&gt;uart
suffix:semicolon
multiline_comment|/* make sure the transmit FIFO is empty */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|READ_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_LSR
comma
op_amp
id|regval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regval
op_amp
id|LSR_XSRE
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtc_time
c_func
(paren
)paren
OG
id|expire
)paren
(brace
r_break
suffix:semicolon
)brace
id|uart_delay
c_func
(paren
id|RTR_UART_DELAY_SPAN
)paren
suffix:semicolon
)brace
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_LCR
comma
id|LCR_DLAB
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_DLH
comma
(paren
id|clkdiv
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_DLL
comma
id|clkdiv
op_amp
l_int|0xff
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* set operating parameters and set DLAB to 0 */
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_LCR
comma
id|LCR_BITS8
op_or
id|LCR_STOP1
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_MCR
comma
id|MCR_RTS
op_or
id|MCR_AFE
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_ICR
comma
l_int|0x0
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
multiline_comment|/* enable FIFO mode and reset both FIFOs */
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_FCR
comma
id|FCR_FIFOEN
)paren
suffix:semicolon
id|uart_delay
c_func
(paren
id|UART_DELAY_SPAN
)paren
suffix:semicolon
id|WRITE_RTR_L1_UART_REG
c_func
(paren
id|path
comma
id|nasid
comma
id|REG_FCR
comma
id|FCR_FIFOEN
op_or
id|FCR_RxFIFO
op_or
id|FCR_TxFIFO
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; * locking macros &n; */
DECL|macro|L1SC_SEND_LOCK
mdefine_line|#define L1SC_SEND_LOCK(l,p)   { if ((l)-&gt;uart == BRL1_LOCALHUB_UART) spin_lock_irqsave(&amp;((l)-&gt;send_lock),p); }
DECL|macro|L1SC_SEND_UNLOCK
mdefine_line|#define L1SC_SEND_UNLOCK(l,p) { if ((l)-&gt;uart == BRL1_LOCALHUB_UART) spin_unlock_irqrestore(&amp;((l)-&gt;send_lock), p); }
DECL|macro|L1SC_RECV_LOCK
mdefine_line|#define L1SC_RECV_LOCK(l,p)   { if ((l)-&gt;uart == BRL1_LOCALHUB_UART) spin_lock_irqsave(&amp;((l)-&gt;recv_lock), p); } 
DECL|macro|L1SC_RECV_UNLOCK
mdefine_line|#define L1SC_RECV_UNLOCK(l,p) { if ((l)-&gt;uart == BRL1_LOCALHUB_UART) spin_unlock_irqrestore(&amp;((l)-&gt;recv_lock), p); }
multiline_comment|/*********************************************************************&n; * subchannel manipulation &n; *&n; * The SUBCH_[UN]LOCK macros are used to arbitrate subchannel&n; * allocation.  SUBCH_DATA_[UN]LOCK control access to data structures&n; * associated with particular subchannels (e.g., receive queues).&n; *&n; */
DECL|macro|SUBCH_LOCK
mdefine_line|#define SUBCH_LOCK(sc, p)&t;&t;spin_lock_irqsave( &amp;((sc)-&gt;subch_lock), p )
DECL|macro|SUBCH_UNLOCK
mdefine_line|#define SUBCH_UNLOCK(sc, p)&t;&t;spin_unlock_irqrestore( &amp;((sc)-&gt;subch_lock), p )
DECL|macro|SUBCH_DATA_LOCK
mdefine_line|#define SUBCH_DATA_LOCK(sbch, p) &t;spin_lock_irqsave( &amp;((sbch)-&gt;data_lock), p )
DECL|macro|SUBCH_DATA_UNLOCK
mdefine_line|#define SUBCH_DATA_UNLOCK(sbch, p)&t;spin_unlock_irqrestore( &amp;((sbch)-&gt;data_lock), p )
multiline_comment|/*&n; * set a function to be called for subchannel ch in the event of&n; * a transmission low-water interrupt from the uart&n; */
r_void
DECL|function|subch_set_tx_notify
id|subch_set_tx_notify
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
id|brl1_notif_t
id|func
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|L1SC_SEND_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
r_if
c_cond
(paren
id|func
op_logical_and
op_logical_neg
id|sc-&gt;send_in_use
)paren
id|uart_enable_xmit_intr
c_func
(paren
id|sc
)paren
suffix:semicolon
macro_line|#endif
id|sc-&gt;subch
(braket
id|ch
)braket
dot
id|tx_notify
op_assign
id|func
suffix:semicolon
id|L1SC_SEND_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set a function to be called for subchannel ch when data is received&n; */
r_void
DECL|function|subch_set_rx_notify
id|subch_set_rx_notify
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
id|brl1_notif_t
id|func
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
id|sc-&gt;subch
(braket
id|ch
)braket
dot
id|rx_notify
op_assign
id|func
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; * Queue manipulation macros&n; *&n; *&n; */
DECL|macro|NEXT
mdefine_line|#define NEXT(p)         (((p) + 1) &amp; (BRL1_QSIZE-1)) /* assume power of 2 */
DECL|macro|cq_init
mdefine_line|#define cq_init(q)      bzero((q), sizeof (*(q)))
DECL|macro|cq_empty
mdefine_line|#define cq_empty(q)     ((q)-&gt;ipos == (q)-&gt;opos)
DECL|macro|cq_full
mdefine_line|#define cq_full(q)      (NEXT((q)-&gt;ipos) == (q)-&gt;opos)
DECL|macro|cq_used
mdefine_line|#define cq_used(q)      ((q)-&gt;opos &lt;= (q)-&gt;ipos ?                       &bslash;&n;                         (q)-&gt;ipos - (q)-&gt;opos :                        &bslash;&n;                         BRL1_QSIZE + (q)-&gt;ipos - (q)-&gt;opos)
DECL|macro|cq_room
mdefine_line|#define cq_room(q)      ((q)-&gt;opos &lt;= (q)-&gt;ipos ?                       &bslash;&n;                         BRL1_QSIZE - 1 + (q)-&gt;opos - (q)-&gt;ipos :       &bslash;&n;                         (q)-&gt;opos - (q)-&gt;ipos - 1)
DECL|macro|cq_add
mdefine_line|#define cq_add(q, c)    ((q)-&gt;buf[(q)-&gt;ipos] = (u_char) (c),            &bslash;&n;                         (q)-&gt;ipos = NEXT((q)-&gt;ipos))
DECL|macro|cq_rem
mdefine_line|#define cq_rem(q, c)    ((c) = (q)-&gt;buf[(q)-&gt;opos],                     &bslash;&n;                         (q)-&gt;opos = NEXT((q)-&gt;opos))
DECL|macro|cq_discard
mdefine_line|#define cq_discard(q)&t;((q)-&gt;opos = NEXT((q)-&gt;opos))
DECL|macro|cq_tent_full
mdefine_line|#define cq_tent_full(q)&t;(NEXT((q)-&gt;tent_next) == (q)-&gt;opos)
DECL|macro|cq_tent_len
mdefine_line|#define cq_tent_len(q)&t;((q)-&gt;ipos &lt;= (q)-&gt;tent_next ?&t;&t;&t;&bslash;&n;&t;&t;&t; (q)-&gt;tent_next - (q)-&gt;ipos :&t;&t;&t;&bslash;&n;&t;&t;&t; BRL1_QSIZE + (q)-&gt;tent_next - (q)-&gt;ipos)
DECL|macro|cq_tent_add
mdefine_line|#define cq_tent_add(q, c)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;((q)-&gt;buf[(q)-&gt;tent_next] = (u_char) (c),&t;&bslash;&n;&t;&t;&t; (q)-&gt;tent_next = NEXT((q)-&gt;tent_next))
DECL|macro|cq_commit_tent
mdefine_line|#define cq_commit_tent(q)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;((q)-&gt;ipos = (q)-&gt;tent_next)
DECL|macro|cq_discard_tent
mdefine_line|#define cq_discard_tent(q)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;((q)-&gt;tent_next = (q)-&gt;ipos)
multiline_comment|/*********************************************************************&n; * CRC-16 (for checking bedrock/L1 packets).&n; *&n; * These are based on RFC 1662 (&quot;PPP in HDLC-like framing&quot;).&n; */
DECL|variable|fcstab
r_static
r_int
r_int
id|fcstab
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|macro|INIT_CRC
mdefine_line|#define INIT_CRC&t;0xFFFF&t;/* initial CRC value&t;  */
DECL|macro|GOOD_CRC
mdefine_line|#define&t;GOOD_CRC&t;0xF0B8&t;/* &quot;good&quot; final CRC value */
DECL|function|crc16_calc
r_static
r_int
r_int
id|crc16_calc
c_func
(paren
r_int
r_int
id|crc
comma
id|u_char
id|c
)paren
(brace
r_return
(paren
id|crc
op_rshift
l_int|8
)paren
op_xor
id|fcstab
(braket
(paren
id|crc
op_xor
id|c
)paren
op_amp
l_int|0xff
)braket
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * The following functions implement the PPP-like bedrock/L1 protocol&n; * layer.&n; *&n; */
DECL|macro|BRL1_FLAG_CH
mdefine_line|#define BRL1_FLAG_CH&t;0x7e
DECL|macro|BRL1_ESC_CH
mdefine_line|#define BRL1_ESC_CH&t;0x7d
DECL|macro|BRL1_XOR_CH
mdefine_line|#define BRL1_XOR_CH&t;0x20
multiline_comment|/* L1&lt;-&gt;Bedrock packet types */
DECL|macro|BRL1_REQUEST
mdefine_line|#define BRL1_REQUEST    0x00
DECL|macro|BRL1_RESPONSE
mdefine_line|#define BRL1_RESPONSE   0x20
DECL|macro|BRL1_EVENT
mdefine_line|#define BRL1_EVENT      0x40
DECL|macro|BRL1_PKT_TYPE_MASK
mdefine_line|#define BRL1_PKT_TYPE_MASK      0xE0
DECL|macro|BRL1_SUBCH_MASK
mdefine_line|#define BRL1_SUBCH_MASK         0x1F
DECL|macro|PKT_TYPE
mdefine_line|#define PKT_TYPE(tsb)   ((tsb) &amp; BRL1_PKT_TYPE_MASK)
DECL|macro|SUBCH
mdefine_line|#define SUBCH(tsb)&t;((tsb) &amp; BRL1_SUBCH_MASK)
multiline_comment|/* timeouts */
DECL|macro|BRL1_INIT_TIMEOUT
mdefine_line|#define BRL1_INIT_TIMEOUT&t;500000
multiline_comment|/*&n; * brl1_discard_packet is a dummy &quot;receive callback&quot; used to get rid&n; * of packets we don&squot;t want&n; */
DECL|function|brl1_discard_packet
r_void
id|brl1_discard_packet
c_func
(paren
r_int
id|dummy0
comma
r_void
op_star
id|dummy1
comma
r_struct
id|pt_regs
op_star
id|dummy2
comma
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
id|sc-&gt;subch
(braket
id|ch
)braket
suffix:semicolon
id|sc_cq_t
op_star
id|q
op_assign
id|subch-&gt;iqp
suffix:semicolon
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
id|q-&gt;opos
op_assign
id|q-&gt;ipos
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|subch-&gt;packet_arrived
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * brl1_send_chars sends the send buffer in the l1sc_t structure&n; * out through the uart.  Assumes that the caller has locked the&n; * UART (or send buffer in the kernel).&n; *&n; * This routine doesn&squot;t block-- if you want it to, call it in&n; * a loop.&n; */
r_static
r_int
DECL|function|brl1_send_chars
id|brl1_send_chars
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
multiline_comment|/* We track the depth of the C brick&squot;s UART&squot;s&n;     * fifo in software, and only check if the UART is accepting&n;     * characters when our count indicates that the fifo should&n;     * be full.&n;     *&n;     * For remote (router) UARTs, we check with the UART before sending every&n;     * character.&n;     */
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sc-&gt;fifo_space
)paren
op_logical_and
id|UART_PUTC_READY
c_func
(paren
id|sc-&gt;nasid
)paren
)paren
(brace
id|sc-&gt;fifo_space
op_assign
id|UART_FIFO_DEPTH
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|sc-&gt;sent
OL
id|sc-&gt;send_len
)paren
op_logical_and
(paren
id|sc-&gt;fifo_space
)paren
)paren
(brace
id|uart_putc
c_func
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;fifo_space
op_decrement
suffix:semicolon
id|sc-&gt;sent
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* remote (router) UARTs */
r_int
id|result
suffix:semicolon
r_int
id|tries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sc-&gt;sent
OL
id|sc-&gt;send_len
)paren
(brace
id|result
op_assign
id|sc
op_member_access_from_pointer
id|putc_f
c_func
(paren
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
(paren
id|sc-&gt;sent
)paren
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|UART_TIMEOUT
)paren
(brace
id|tries
op_increment
suffix:semicolon
multiline_comment|/* send this character in TIMEOUT_RETRIES... */
r_if
c_cond
(paren
id|tries
OL
l_int|30
multiline_comment|/* TIMEOUT_RETRIES */
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* ...or else... */
r_else
(brace
multiline_comment|/* ...drop the packet. */
id|sc-&gt;sent
op_assign
id|sc-&gt;send_len
suffix:semicolon
r_return
id|sc-&gt;send_len
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
)brace
)brace
r_return
id|sc-&gt;sent
suffix:semicolon
)brace
multiline_comment|/* brl1_send formats up a packet and (at least begins to) send it&n; * to the uart.  If the send buffer is in use when this routine obtains&n; * the lock, it will behave differently depending on the &quot;wait&quot; parameter.&n; * For wait == 0 (most I/O), it will return 0 (as in &quot;zero bytes sent&quot;),&n; * hopefully encouraging the caller to back off (unlock any high-level &n; * spinlocks) and allow the buffer some time to drain.  For wait==1 (high-&n; * priority I/O along the lines of kernel error messages), we will flush&n; * the current contents of the send buffer and beat on the uart&n; * until our message has been completely transmitted.&n; */
r_static
r_int
DECL|function|brl1_send
id|brl1_send
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_char
op_star
id|msg
comma
r_int
id|len
comma
id|u_char
id|type_and_subch
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|pkt_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|crc
op_assign
id|INIT_CRC
suffix:semicolon
r_char
op_star
id|send_ptr
op_assign
id|sc-&gt;send
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;send_in_use
op_logical_and
op_logical_neg
(paren
id|wait
)paren
)paren
(brace
multiline_comment|/* We are in the middle of sending, but can wait until done */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sc-&gt;send_in_use
)paren
(brace
multiline_comment|/* buffer&squot;s in use, but we&squot;re synchronous I/O, so we&squot;re going&n;&t; * to send whatever&squot;s in there right now and take the buffer&n;&t; */
r_int
id|counter
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|sc-&gt;nasid
)paren
suffix:semicolon
id|L1SC_SEND_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sc-&gt;sent
OL
id|sc-&gt;send_len
)paren
(brace
id|brl1_send_chars
c_func
(paren
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|0xfffff
)paren
(brace
r_char
op_star
id|str
op_assign
l_string|&quot;Looping waiting for uart to clear (1)&bslash;n&quot;
suffix:semicolon
id|early_l1_serial_out
c_func
(paren
id|sc-&gt;nasid
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
comma
id|ALREADY_LOCKED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|sc-&gt;nasid
)paren
suffix:semicolon
id|L1SC_SEND_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|sc-&gt;send_in_use
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|send_ptr
op_increment
op_assign
id|BRL1_FLAG_CH
suffix:semicolon
op_star
id|send_ptr
op_increment
op_assign
id|type_and_subch
suffix:semicolon
id|pkt_len
op_add_assign
l_int|2
suffix:semicolon
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|crc
comma
id|type_and_subch
)paren
suffix:semicolon
multiline_comment|/* limit number of characters accepted to max payload size */
r_if
c_cond
(paren
id|len
OG
(paren
id|BRL1_QSIZE
op_minus
l_int|1
)paren
)paren
(brace
id|len
op_assign
(paren
id|BRL1_QSIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* copy in the message buffer (inserting PPP &n;     * framing info where necessary)&n;     */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|len
suffix:semicolon
id|index
op_increment
)paren
(brace
r_switch
c_cond
(paren
op_star
id|msg
)paren
(brace
r_case
id|BRL1_FLAG_CH
suffix:colon
op_star
id|send_ptr
op_increment
op_assign
id|BRL1_ESC_CH
suffix:semicolon
op_star
id|send_ptr
op_increment
op_assign
(paren
op_star
id|msg
)paren
op_xor
id|BRL1_XOR_CH
suffix:semicolon
id|pkt_len
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRL1_ESC_CH
suffix:colon
op_star
id|send_ptr
op_increment
op_assign
id|BRL1_ESC_CH
suffix:semicolon
op_star
id|send_ptr
op_increment
op_assign
(paren
op_star
id|msg
)paren
op_xor
id|BRL1_XOR_CH
suffix:semicolon
id|pkt_len
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|send_ptr
op_increment
op_assign
op_star
id|msg
suffix:semicolon
id|pkt_len
op_increment
suffix:semicolon
)brace
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|crc
comma
op_star
id|msg
)paren
suffix:semicolon
id|msg
op_increment
suffix:semicolon
)brace
id|crc
op_xor_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
r_sizeof
(paren
id|crc
)paren
suffix:semicolon
id|index
op_increment
)paren
(brace
r_char
id|crc_char
op_assign
(paren
r_char
)paren
(paren
id|crc
op_amp
l_int|0x00FF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|crc_char
op_eq
id|BRL1_ESC_CH
)paren
op_logical_or
(paren
id|crc_char
op_eq
id|BRL1_FLAG_CH
)paren
)paren
(brace
op_star
id|send_ptr
op_increment
op_assign
id|BRL1_ESC_CH
suffix:semicolon
id|pkt_len
op_increment
suffix:semicolon
id|crc_char
op_xor_assign
id|BRL1_XOR_CH
suffix:semicolon
)brace
op_star
id|send_ptr
op_increment
op_assign
id|crc_char
suffix:semicolon
id|pkt_len
op_increment
suffix:semicolon
id|crc
op_rshift_assign
l_int|8
suffix:semicolon
)brace
op_star
id|send_ptr
op_increment
op_assign
id|BRL1_FLAG_CH
suffix:semicolon
id|pkt_len
op_increment
suffix:semicolon
id|sc-&gt;send_len
op_assign
id|pkt_len
suffix:semicolon
id|sc-&gt;sent
op_assign
l_int|0
suffix:semicolon
(brace
r_int
id|counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|brl1_send_chars
c_func
(paren
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|0xfffff
)paren
(brace
r_char
op_star
id|str
op_assign
l_string|&quot;Looping waiting for uart to clear (2)&bslash;n&quot;
suffix:semicolon
id|early_l1_serial_out
c_func
(paren
id|sc-&gt;nasid
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
comma
id|ALREADY_LOCKED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|sc-&gt;sent
OL
id|sc-&gt;send_len
)paren
op_logical_and
id|wait
)paren
(brace
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|unlock_console
c_func
(paren
id|sc-&gt;nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;sent
op_eq
id|sc-&gt;send_len
)paren
(brace
multiline_comment|/* success! release the send buffer and call the callup */
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
id|brl1_notif_t
id|callup
suffix:semicolon
macro_line|#endif
id|sc-&gt;send_in_use
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* call any upper layer that&squot;s asked for notification */
macro_line|#if&t;defined(XX_SYNC_CONSOLE_WRITE)
multiline_comment|/*&n;&t; * This is probably not a good idea - since the l1_ write func can be called multiple&n;&t; * time within the callup function.&n;&t; */
id|callup
op_assign
id|subch-&gt;tx_notify
suffix:semicolon
r_if
c_cond
(paren
id|callup
op_logical_and
(paren
id|SUBCH
c_func
(paren
id|type_and_subch
)paren
op_eq
id|SC_CONS_SYSTEM
)paren
)paren
(brace
id|L1_collectibles
(braket
id|L1C_SEND_CALLUPS
)braket
op_increment
suffix:semicolon
(paren
op_star
id|callup
)paren
(paren
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|type_and_subch
)paren
)braket
dot
id|irq_frame.bf_irq
comma
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|type_and_subch
)paren
)braket
dot
id|irq_frame.bf_dev_id
comma
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|type_and_subch
)paren
)braket
dot
id|irq_frame.bf_regs
comma
id|sc
comma
id|SUBCH
c_func
(paren
id|type_and_subch
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SYNC_CONSOLE_WRITE */
)brace
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
r_else
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
multiline_comment|/* enable low-water interrupts so buffer will be drained */
id|uart_enable_xmit_intr
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
macro_line|#endif
id|L1SC_SEND_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* brl1_send_cont is intended to be called as an interrupt service&n; * routine.  It sends until the UART won&squot;t accept any more characters,&n; * or until an error is encountered (in which case we surrender the&n; * send buffer and give up trying to send the packet).  Once the&n; * last character in the packet has been sent, this routine releases&n; * the send buffer and calls any previously-registered &quot;low-water&quot;&n; * output routines.&n; */
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
r_int
DECL|function|brl1_send_cont
id|brl1_send_cont
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|brl1_notif_t
id|callups
(braket
id|BRL1_NUM_SUBCHANS
)braket
suffix:semicolon
id|brl1_notif_t
op_star
id|callup
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
r_int
id|index
suffix:semicolon
multiline_comment|/*&n;     * I&squot;m not sure how I think this is to be handled - whether the lock is held&n;     * over the interrupt - but it seems like it is a bad idea....&n;     */
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|lock_console
c_func
(paren
id|sc-&gt;nasid
)paren
suffix:semicolon
id|L1SC_SEND_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|brl1_send_chars
c_func
(paren
id|sc
)paren
suffix:semicolon
id|done
op_assign
(paren
id|sc-&gt;sent
op_eq
id|sc-&gt;send_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
(brace
id|sc-&gt;send_in_use
op_assign
l_int|0
suffix:semicolon
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
id|uart_disable_xmit_intr
c_func
(paren
id|sc
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
id|unlock_console
c_func
(paren
id|sc-&gt;nasid
)paren
suffix:semicolon
multiline_comment|/* Release the lock */
id|L1SC_SEND_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SYNC_CONSOLE_WRITE */
multiline_comment|/* internal function -- used by brl1_receive to read a character &n; * from the uart and check whether errors occurred in the process.&n; */
r_static
r_int
DECL|function|read_uart
id|read_uart
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
op_star
id|c
comma
r_int
op_star
id|result
)paren
(brace
op_star
id|c
op_assign
id|sc
op_member_access_from_pointer
id|getc_f
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* no character is available */
r_if
c_cond
(paren
op_star
id|c
op_eq
id|UART_NO_CHAR
)paren
(brace
op_star
id|result
op_assign
id|BRL1_NO_MESSAGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* some error in UART */
r_if
c_cond
(paren
op_star
id|c
OL
l_int|0
)paren
(brace
op_star
id|result
op_assign
id|BRL1_LINK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* everything&squot;s fine */
op_star
id|result
op_assign
id|BRL1_VALID
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * brl1_receive&n; *&n; * This function reads a Bedrock-L1 protocol packet into the l1sc_t&n; * response buffer.&n; *&n; * The operation of this function can be expressed as a finite state&n; * machine:&n; *&n;&n;START STATE&t;&t;&t;INPUT&t;&t;TRANSITION&n;==========================================================&n;BRL1_IDLE (reset or error)&t;flag&t;&t;BRL1_FLAG&n;&t;&t;&t;&t;other&t;&t;BRL1_IDLE@&n;&n;BRL1_FLAG (saw a flag (0x7e))&t;flag&t;&t;BRL1_FLAG&n;&t;&t;&t;&t;escape&t;&t;BRL1_IDLE@&n;&t;&t;&t;&t;header byte&t;BRL1_HDR&n;&t;&t;&t;&t;other&t;&t;BRL1_IDLE@&n;&n;BRL1_HDR (saw a type/subch byte)(see below)&t;BRL1_BODY&n;&t;&t;&t;&t;&t;&t;BRL1_HDR&n;&n;BRL1_BODY (reading packet body)&t;flag&t;&t;BRL1_FLAG&n;&t;&t;&t;&t;escape&t;&t;BRL1_ESC&n;&t;&t;&t;&t;other&t;&t;BRL1_BODY&n;&n;BRL1_ESC (saw an escape (0x7d))&t;flag&t;&t;BRL1_FLAG@&n;&t;&t;&t;&t;escape&t;&t;BRL1_IDLE@&n;&t;&t;&t;&t;other&t;&t;BRL1_BODY&n;==========================================================&n;&n;&quot;@&quot; denotes an error transition.&n;&n; * The BRL1_HDR state is a transient state which doesn&squot;t read input,&n; * but just provides a way in to code which decides to whom an&n; * incoming packet should be directed.&n; *&n; * brl1_receive can be used to poll for input from the L1, or as &n; * an interrupt service routine.  It reads as much data as is&n; * ready from the junk bus UART and places into the appropriate&n; * input queues according to subchannel.  The header byte is&n; * stripped from console-type data, but is retained for message-&n; * type data (L1 responses).  A length byte will also be&n; * prepended to message-type packets.&n; *&n; * This routine is non-blocking; if the caller needs to block&n; * for input, it must call brl1_receive in a loop.&n; *&n; * brl1_receive returns when there is no more input, the queue&n; * for the current incoming message is full, or there is an&n; * error (parity error, bad header, bad CRC, etc.).&n; */
DECL|macro|STATE_SET
mdefine_line|#define STATE_SET(l,s)&t;&t;((l)-&gt;brl1_state = (s))
DECL|macro|STATE_GET
mdefine_line|#define STATE_GET(l)&t;&t;((l)-&gt;brl1_state)
DECL|macro|LAST_HDR_SET
mdefine_line|#define LAST_HDR_SET(l,h)&t;((l)-&gt;brl1_last_hdr = (h))
DECL|macro|LAST_HDR_GET
mdefine_line|#define LAST_HDR_GET(l)&t;&t;((l)-&gt;brl1_last_hdr)
DECL|macro|VALID_HDR
mdefine_line|#define VALID_HDR(c)&t;&t;&t;&t;&bslash;&n;    ( SUBCH((c)) &lt;= SC_CONS_SYSTEM&t;&t;&bslash;&n;&t;? PKT_TYPE((c)) == BRL1_REQUEST&t;&t;&bslash;&n;&t;: ( PKT_TYPE((c)) == BRL1_RESPONSE ||&t;&bslash;&n;&t;    PKT_TYPE((c)) == BRL1_EVENT ) )
DECL|macro|IS_TTY_PKT
mdefine_line|#define IS_TTY_PKT(l)&t;&t;( SUBCH(LAST_HDR_GET(l)) &lt;= SC_CONS_SYSTEM ? 1 : 0 )
r_int
DECL|function|brl1_receive
id|brl1_receive
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|mode
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* value to be returned by brl1_receive */
r_int
id|c
suffix:semicolon
multiline_comment|/* most-recently-read character&t;     &t;*/
r_int
id|done
suffix:semicolon
multiline_comment|/* set done to break out of recv loop&t;*/
r_int
r_int
id|pl
op_assign
l_int|0
comma
id|cpl
op_assign
l_int|0
suffix:semicolon
id|sc_cq_t
op_star
id|q
suffix:semicolon
multiline_comment|/* pointer to queue we&squot;re working with&t;*/
id|result
op_assign
id|BRL1_NO_MESSAGE
suffix:semicolon
id|L1SC_RECV_LOCK
c_func
(paren
id|sc
comma
id|cpl
)paren
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_switch
c_cond
(paren
id|STATE_GET
c_func
(paren
id|sc
)paren
)paren
(brace
r_case
id|BRL1_IDLE
suffix:colon
multiline_comment|/* Initial or error state.  Waiting for a flag character&n;             * to resynchronize with the L1.&n;             */
r_if
c_cond
(paren
op_logical_neg
id|read_uart
c_func
(paren
id|sc
comma
op_amp
id|c
comma
op_amp
id|result
)paren
)paren
(brace
multiline_comment|/* error reading uart */
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_FLAG_CH
)paren
(brace
multiline_comment|/* saw a flag character */
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_FLAG
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BRL1_FLAG
suffix:colon
multiline_comment|/* One or more flag characters have been read; look for&n;&t;     * the beginning of a packet (header byte).&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|read_uart
c_func
(paren
id|sc
comma
op_amp
id|c
comma
op_amp
id|result
)paren
)paren
(brace
multiline_comment|/* error reading uart */
r_if
c_cond
(paren
id|c
op_ne
id|UART_NO_CHAR
)paren
(brace
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_IDLE
)paren
suffix:semicolon
)brace
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_FLAG_CH
)paren
(brace
multiline_comment|/* multiple flags are OK */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|VALID_HDR
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* if c isn&squot;t a flag it should have been&n;&t;&t; * a valid header, so we have an error&n;&t;&t; */
id|result
op_assign
id|BRL1_PROTOCOL
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_IDLE
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* we have a valid header byte */
id|LAST_HDR_SET
c_func
(paren
id|sc
comma
id|c
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_HDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRL1_HDR
suffix:colon
multiline_comment|/* A header byte has been read. Do some bookkeeping. */
id|q
op_assign
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|iqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_TTY_PKT
c_func
(paren
id|sc
)paren
)paren
(brace
multiline_comment|/* if this is an event or command response rather&n;&t;&t; * than console I/O, we need to reserve a couple&n;&t;&t; * of extra spaces in the queue for the header&n;&t;&t; * byte and a length byte; if we can&squot;t, stay in&n;&t;&t; * the BRL1_HDR state.&n;&t;&t; */
r_if
c_cond
(paren
id|cq_room
c_func
(paren
id|q
)paren
OL
l_int|2
)paren
(brace
id|result
op_assign
id|BRL1_FULL_Q
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cq_tent_add
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reserve length byte */
id|cq_tent_add
c_func
(paren
id|q
comma
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
suffix:semicolon
multiline_comment|/* record header byte  */
)brace
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_BODY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRL1_BODY
suffix:colon
multiline_comment|/* A header byte has been read.  We are now attempting&n;&t;     * to receive the packet body.&n;&t;     */
id|q
op_assign
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|iqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* if the queue we want to write into is full, don&squot;t read from&n;&t;     * the uart (this provides backpressure to the L1 side)&n;&t;     */
r_if
c_cond
(paren
id|cq_tent_full
c_func
(paren
id|q
)paren
)paren
(brace
id|result
op_assign
id|BRL1_FULL_Q
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_uart
c_func
(paren
id|sc
comma
op_amp
id|c
comma
op_amp
id|result
)paren
)paren
(brace
multiline_comment|/* error reading uart */
r_if
c_cond
(paren
id|c
op_ne
id|UART_NO_CHAR
)paren
(brace
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_IDLE
)paren
suffix:semicolon
)brace
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_ESC_CH
)paren
(brace
multiline_comment|/* prepare to unescape the next character */
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_ESC
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_FLAG_CH
)paren
(brace
multiline_comment|/* flag signifies the end of a packet */
r_int
r_int
id|crc
suffix:semicolon
multiline_comment|/* holds the crc as we calculate it */
r_int
id|i
suffix:semicolon
multiline_comment|/* index variable */
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
multiline_comment|/* subchannel for received packet */
id|brl1_notif_t
id|callup
suffix:semicolon
multiline_comment|/* &quot;data ready&quot; callup */
multiline_comment|/* whatever else may happen, we&squot;ve seen a flag and we&squot;re&n;&t;&t; * starting a new packet&n;&t;&t; */
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_FLAG
)paren
suffix:semicolon
multiline_comment|/* if the packet body has less than 2 characters,&n;&t;&t; * it can&squot;t be a well-formed packet.  Discard it.&n;&t;&t; */
r_if
c_cond
(paren
id|cq_tent_len
c_func
(paren
id|q
)paren
OL
multiline_comment|/* 2 + possible length byte */
(paren
l_int|2
op_plus
(paren
id|IS_TTY_PKT
c_func
(paren
id|sc
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
)paren
(brace
id|result
op_assign
id|BRL1_PROTOCOL
suffix:semicolon
id|cq_discard_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_FLAG
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* check CRC */
multiline_comment|/* accumulate CRC, starting with the header byte and&n;&t;&t; * ending with the transmitted CRC.  This should&n;&t;&t; * result in a known good value.&n;&t;&t; */
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|INIT_CRC
comma
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|q-&gt;ipos
op_plus
(paren
id|IS_TTY_PKT
c_func
(paren
id|sc
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|2
)paren
)paren
op_mod
id|BRL1_QSIZE
suffix:semicolon
id|i
op_ne
id|q-&gt;tent_next
suffix:semicolon
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|BRL1_QSIZE
)paren
(brace
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|crc
comma
id|q-&gt;buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* verify the caclulated crc against the &quot;good&quot; crc value;&n;&t;&t; * if we fail, discard the bad packet and return an error.&n;&t;&t; */
r_if
c_cond
(paren
id|crc
op_ne
(paren
r_int
r_int
)paren
id|GOOD_CRC
)paren
(brace
id|result
op_assign
id|BRL1_CRC
suffix:semicolon
id|cq_discard_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_FLAG
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* so the crc check was ok.  Now we discard the CRC&n;&t;&t; * from the end of the received bytes.&n;&t;&t; */
id|q-&gt;tent_next
op_add_assign
(paren
id|BRL1_QSIZE
op_minus
l_int|2
)paren
suffix:semicolon
id|q-&gt;tent_next
op_mod_assign
id|BRL1_QSIZE
suffix:semicolon
multiline_comment|/* get the subchannel and lock it */
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
)paren
suffix:semicolon
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
multiline_comment|/* if this isn&squot;t a console packet, we need to record&n;&t;&t; * a length byte&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|IS_TTY_PKT
c_func
(paren
id|sc
)paren
)paren
(brace
id|q-&gt;buf
(braket
id|q-&gt;ipos
)braket
op_assign
id|cq_tent_len
c_func
(paren
id|q
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* record packet for posterity */
id|cq_commit_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|result
op_assign
id|BRL1_VALID
suffix:semicolon
multiline_comment|/* notify subchannel owner that there&squot;s something&n;&t;&t; * on the queue for them&n;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
(paren
id|subch-&gt;packet_arrived
)paren
)paren
suffix:semicolon
id|callup
op_assign
id|subch-&gt;rx_notify
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|callup
op_logical_and
(paren
id|mode
op_eq
id|SERIAL_INTERRUPT_MODE
)paren
)paren
(brace
id|L1SC_RECV_UNLOCK
c_func
(paren
id|sc
comma
id|cpl
)paren
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_RECEIVE_CALLUPS
)braket
op_increment
suffix:semicolon
(paren
op_star
id|callup
)paren
(paren
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|irq_frame.bf_irq
comma
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|irq_frame.bf_dev_id
comma
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|irq_frame.bf_regs
comma
id|sc
comma
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)paren
suffix:semicolon
id|L1SC_RECV_LOCK
c_func
(paren
id|sc
comma
id|cpl
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
multiline_comment|/* go back for more! */
)brace
multiline_comment|/* none of the special cases applied; we&squot;ve got a normal&n;&t;     * body character&n;&t;     */
id|cq_tent_add
c_func
(paren
id|q
comma
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRL1_ESC
suffix:colon
multiline_comment|/* saw an escape character.  The next character will need&n;&t;     * to be unescaped.&n;&t;     */
id|q
op_assign
id|sc-&gt;subch
(braket
id|SUBCH
c_func
(paren
id|LAST_HDR_GET
c_func
(paren
id|sc
)paren
)paren
)braket
dot
id|iqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* if the queue we want to write into is full, don&squot;t read from&n;&t;     * the uart (this provides backpressure to the L1 side)&n;&t;     */
r_if
c_cond
(paren
id|cq_tent_full
c_func
(paren
id|q
)paren
)paren
(brace
id|result
op_assign
id|BRL1_FULL_Q
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_uart
c_func
(paren
id|sc
comma
op_amp
id|c
comma
op_amp
id|result
)paren
)paren
(brace
multiline_comment|/* error reading uart */
r_if
c_cond
(paren
id|c
op_ne
id|UART_NO_CHAR
)paren
(brace
id|cq_discard_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_IDLE
)paren
suffix:semicolon
)brace
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_FLAG_CH
)paren
(brace
multiline_comment|/* flag after escape is an error */
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_FLAG
)paren
suffix:semicolon
id|cq_discard_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|result
op_assign
id|BRL1_PROTOCOL
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|BRL1_ESC_CH
)paren
(brace
multiline_comment|/* two consecutive escapes is an error */
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_IDLE
)paren
suffix:semicolon
id|cq_discard_tent
c_func
(paren
id|q
)paren
suffix:semicolon
id|result
op_assign
id|BRL1_PROTOCOL
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* otherwise, we&squot;ve got a character that needs&n;&t;     * to be unescaped&n;&t;     */
id|cq_tent_add
c_func
(paren
id|q
comma
(paren
id|c
op_xor
id|BRL1_XOR_CH
)paren
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|sc
comma
id|BRL1_BODY
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end of switch( STATE_GET(sc) ) */
)brace
multiline_comment|/* end of while(!done) */
id|L1SC_RECV_UNLOCK
c_func
(paren
id|sc
comma
id|cpl
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* brl1_init initializes the Bedrock/L1 protocol layer.  This includes&n; * zeroing out the send and receive state information.&n; */
r_void
DECL|function|brl1_init
id|brl1_init
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|nasid_t
id|nasid
comma
id|net_vec_t
id|uart
)paren
(brace
r_int
id|i
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
id|bzero
c_func
(paren
id|sc
comma
r_sizeof
(paren
op_star
id|sc
)paren
)paren
suffix:semicolon
id|sc-&gt;nasid
op_assign
id|nasid
suffix:semicolon
id|sc-&gt;uart
op_assign
id|uart
suffix:semicolon
id|sc-&gt;getc_f
op_assign
(paren
id|uart
op_eq
id|BRL1_LOCALHUB_UART
ques
c_cond
id|uart_getc
suffix:colon
id|rtr_uart_getc
)paren
suffix:semicolon
id|sc-&gt;putc_f
op_assign
(paren
id|uart
op_eq
id|BRL1_LOCALHUB_UART
ques
c_cond
id|uart_putc
suffix:colon
id|rtr_uart_putc
)paren
suffix:semicolon
id|sc-&gt;sol
op_assign
l_int|1
suffix:semicolon
id|subch
op_assign
id|sc-&gt;subch
suffix:semicolon
multiline_comment|/* initialize L1 subchannels&n;     */
multiline_comment|/* assign processor TTY channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPUS_PER_NODE
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|subch-&gt;data_lock
)paren
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
comma
op_amp
(paren
id|subch-&gt;data_lock
)paren
comma
id|SV_MON_SPIN
op_or
id|SV_ORDER_FIFO
multiline_comment|/* | SV_INTS */
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* (for now, drop elscuart packets in the kernel) */
id|subch-&gt;rx_notify
op_assign
id|brl1_discard_packet
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
multiline_comment|/* assign system TTY channel (first free subchannel after each&n;     * processor&squot;s individual TTY channel has been assigned)&n;     */
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|subch-&gt;data_lock
)paren
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
comma
op_amp
id|subch-&gt;data_lock
comma
id|SV_MON_SPIN
op_or
id|SV_ORDER_FIFO
multiline_comment|/* | SV_INTS */
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
(brace
id|subch-&gt;iqp
op_assign
id|snia_kmem_zalloc_node
c_func
(paren
r_sizeof
(paren
id|sc_cq_t
)paren
comma
id|KM_NOSLEEP
comma
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
id|cq_init
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we shouldn&squot;t be getting console input from remote UARTs */
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|brl1_discard_packet
suffix:semicolon
)brace
id|subch
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* &quot;reserved&quot; subchannels (0x05-0x0F); for now, throw away&n;     * incoming packets&n;     */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|0x10
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_FREE
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|brl1_discard_packet
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
multiline_comment|/* remaining subchannels are free */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|BRL1_NUM_SUBCHANS
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_FREE
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|brl1_discard_packet
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
multiline_comment|/* initialize synchronization structures&n;     */
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|sc-&gt;subch_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|sc-&gt;send_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|sc-&gt;recv_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
(brace
id|uart_init
c_func
(paren
id|sc
comma
id|UART_BAUD_RATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtr_uart_init
c_func
(paren
id|sc
comma
id|UART_BAUD_RATE
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up remaining fields using L1 command functions-- elsc_module_get&n;     * to read the module id, elsc_debug_get to see whether or not we&squot;re&n;     * in verbose mode.&n;     */
(brace
r_extern
r_int
id|elsc_module_get
c_func
(paren
id|l1sc_t
op_star
)paren
suffix:semicolon
id|sc-&gt;modid
op_assign
id|elsc_module_get
c_func
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;modid
op_assign
(paren
id|sc-&gt;modid
OL
l_int|0
ques
c_cond
id|INVALID_MODULE
suffix:colon
id|sc-&gt;modid
)paren
suffix:semicolon
id|sc-&gt;verbose
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*********************************************************************&n; * These are interrupt-related functions used in the kernel to service&n; * the L1.&n; */
multiline_comment|/*&n; * brl1_intrd is the function which is called on a console interrupt.&n; */
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
r_static
r_void
DECL|function|brl1_intrd
id|brl1_intrd
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|stuff
)paren
(brace
id|u_char
id|isr_reg
suffix:semicolon
id|l1sc_t
op_star
id|sc
op_assign
id|get_elsc
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_INTERRUPTS
)braket
op_increment
suffix:semicolon
id|isr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|sc-&gt;nasid
comma
id|REG_ISR
)paren
suffix:semicolon
multiline_comment|/* Save for callup args in console */
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
dot
id|irq_frame.bf_irq
op_assign
id|irq
suffix:semicolon
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
dot
id|irq_frame.bf_dev_id
op_assign
id|dev_id
suffix:semicolon
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
dot
id|irq_frame.bf_regs
op_assign
id|stuff
suffix:semicolon
macro_line|#if&t;defined(SYNC_CONSOLE_WRITE)
r_while
c_loop
(paren
id|isr_reg
op_amp
id|ISR_RxRDY
)paren
macro_line|#else
r_while
c_loop
(paren
id|isr_reg
op_amp
(paren
id|ISR_RxRDY
op_or
id|ISR_TxRDY
)paren
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
id|isr_reg
op_amp
id|ISR_RxRDY
)paren
(brace
id|L1_collectibles
(braket
id|L1C_OUR_R_INTERRUPTS
)braket
op_increment
suffix:semicolon
id|ret
op_assign
id|brl1_receive
c_func
(paren
id|sc
comma
id|SERIAL_INTERRUPT_MODE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_ne
id|BRL1_VALID
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_NO_MESSAGE
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_PROTOCOL
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_CRC
)paren
)paren
id|L1_collectibles
(braket
id|L1C_REC_STALLS
)braket
op_assign
id|ret
suffix:semicolon
)brace
macro_line|#if&t;!defined(SYNC_CONSOLE_WRITE)
r_if
c_cond
(paren
(paren
id|isr_reg
op_amp
id|ISR_TxRDY
)paren
op_logical_or
(paren
id|sc-&gt;send_in_use
op_logical_and
id|UART_PUTC_READY
c_func
(paren
id|sc-&gt;nasid
)paren
)paren
)paren
(brace
id|L1_collectibles
(braket
id|L1C_OUR_X_INTERRUPTS
)braket
op_increment
suffix:semicolon
id|brl1_send_cont
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SYNC_CONSOLE_WRITE */
id|isr_reg
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|sc-&gt;nasid
comma
id|REG_ISR
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
multiline_comment|/*&n; * Install a callback function for the system console subchannel &n; * to allow an upper layer to be notified when the send buffer &n; * has been emptied.&n; */
r_static
r_inline
r_void
DECL|function|l1_tx_notif
id|l1_tx_notif
c_func
(paren
id|brl1_notif_t
id|func
)paren
(brace
id|subch_set_tx_notify
c_func
(paren
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|get_master_nasid
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
comma
id|SC_CONS_SYSTEM
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Install a callback function for the system console subchannel&n; * to allow an upper layer to be notified when a packet has been&n; * received.&n; */
r_static
r_inline
r_void
DECL|function|l1_rx_notif
id|l1_rx_notif
c_func
(paren
id|brl1_notif_t
id|func
)paren
(brace
id|subch_set_rx_notify
c_func
(paren
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|get_master_nasid
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
comma
id|SC_CONS_SYSTEM
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/* brl1_intr is called directly from the uart interrupt; after it runs, the&n; * interrupt &quot;daemon&quot; xthread is signalled to continue.&n; */
r_void
DECL|function|brl1_intr
id|brl1_intr
c_func
(paren
r_void
)paren
(brace
)brace
DECL|macro|BRL1_INTERRUPT_LEVEL
mdefine_line|#define BRL1_INTERRUPT_LEVEL&t;65&t;/* linux request_irq() value */
multiline_comment|/* Return the current interrupt level */
singleline_comment|//#define CONSOLE_POLLING_ALSO
r_int
DECL|function|l1_get_intr_value
id|l1_get_intr_value
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef&t;CONSOLE_POLLING_ALSO
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|BRL1_INTERRUPT_LEVEL
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Disconnect the callup functions - throw away interrupts */
r_void
DECL|function|l1_unconnect_intr
id|l1_unconnect_intr
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* UnRegister the upper-level callup functions */
id|l1_rx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
l_int|NULL
)paren
suffix:semicolon
id|l1_tx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* We do NOT unregister the interrupts */
)brace
multiline_comment|/* Set up uart interrupt handling for this node&squot;s uart */
r_void
DECL|function|l1_connect_intr
id|l1_connect_intr
c_func
(paren
r_void
op_star
id|rx_notify
comma
r_void
op_star
id|tx_notify
)paren
(brace
id|l1sc_t
op_star
id|sc
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
r_int
id|tmp
suffix:semicolon
macro_line|#endif
id|nodepda_t
op_star
id|console_nodepda
suffix:semicolon
r_int
id|intr_connect_level
c_func
(paren
id|cpuid_t
comma
r_int
comma
id|ilvl_t
comma
id|intr_func_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L1_interrupts_connected
)paren
(brace
multiline_comment|/* Interrupts are connected, so just register the callups */
id|l1_rx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
id|rx_notify
)paren
suffix:semicolon
id|l1_tx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
id|tx_notify
)paren
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_CONNECT_CALLS
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|L1_interrupts_connected
op_assign
l_int|1
suffix:semicolon
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
id|console_nodepda
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
suffix:semicolon
id|sc
op_assign
op_amp
id|console_nodepda-&gt;module-&gt;elsc
suffix:semicolon
id|sc-&gt;intr_cpu
op_assign
id|console_nodepda-&gt;node_first_cpu
suffix:semicolon
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
r_if
c_cond
(paren
id|intr_connect_level
c_func
(paren
id|sc-&gt;intr_cpu
comma
id|UART_INTR
comma
id|INTPEND0_MAXMASK
comma
(paren
id|intr_func_t
)paren
id|brl1_intr
)paren
)paren
(brace
id|L1_interrupts_connected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FAILS !! */
)brace
r_else
(brace
r_void
id|synergy_intr_connect
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
id|synergy_intr_connect
c_func
(paren
id|UART_INTR
comma
id|sc-&gt;intr_cpu
)paren
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_R_IRQ
)braket
op_increment
suffix:semicolon
id|tmp
op_assign
id|request_irq
c_func
(paren
id|BRL1_INTERRUPT_LEVEL
comma
id|brl1_intrd
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;l1_protocol_driver&quot;
comma
(paren
r_void
op_star
)paren
id|sc
)paren
suffix:semicolon
id|L1_collectibles
(braket
id|L1C_R_IRQ_RET
)braket
op_assign
(paren
r_uint64
)paren
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|L1_interrupts_connected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FAILS !! */
)brace
r_else
(brace
multiline_comment|/* Register the upper-level callup functions */
id|l1_rx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
id|rx_notify
)paren
suffix:semicolon
id|l1_tx_notif
c_func
(paren
(paren
id|brl1_notif_t
)paren
id|tx_notify
)paren
suffix:semicolon
multiline_comment|/* Set the uarts the way we like it */
id|uart_enable_recv_intr
c_func
(paren
id|sc
)paren
suffix:semicolon
id|uart_disable_xmit_intr
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_IA64_SGI_SN1 */
)brace
multiline_comment|/* Set the line speed */
r_void
DECL|function|l1_set_baud
id|l1_set_baud
c_func
(paren
r_int
id|baud
)paren
(brace
macro_line|#if 0
id|nasid_t
id|nasid
suffix:semicolon
r_static
r_void
id|uart_init
c_func
(paren
id|l1sc_t
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
id|L1_collectibles
(braket
id|L1C_SET_BAUD
)braket
op_increment
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|L1_cons_is_inited
)paren
(brace
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module
op_ne
(paren
id|module_t
op_star
)paren
l_int|0
)paren
id|uart_init
c_func
(paren
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
comma
id|baud
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* These are functions to use from serial_in/out when in protocol&n; * mode to send and receive uart control regs. These are external&n; * interfaces into the protocol driver.&n; */
r_void
DECL|function|l1_control_out
id|l1_control_out
c_func
(paren
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
id|WRITE_L1_UART_REG
c_func
(paren
id|nasid
comma
id|offset
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/* Console input exported interface. Return a register value.  */
r_int
DECL|function|l1_control_in_polled
id|l1_control_in_polled
c_func
(paren
r_int
id|offset
)paren
(brace
r_static
r_int
id|l1_control_in_local
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_return
id|l1_control_in_local
c_func
(paren
id|offset
comma
id|SERIAL_POLLED_MODE
)paren
suffix:semicolon
)brace
r_int
DECL|function|l1_control_in
id|l1_control_in
c_func
(paren
r_int
id|offset
)paren
(brace
r_static
r_int
id|l1_control_in_local
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_return
id|l1_control_in_local
c_func
(paren
id|offset
comma
id|SERIAL_INTERRUPT_MODE
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|l1_control_in_local
id|l1_control_in_local
c_func
(paren
r_int
id|offset
comma
r_int
id|mode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|ret
comma
id|input
suffix:semicolon
r_static
r_int
id|l1_poll
c_func
(paren
id|l1sc_t
op_star
comma
r_int
)paren
suffix:semicolon
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|READ_L1_UART_REG
c_func
(paren
id|nasid
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|REG_LSR
)paren
(brace
id|ret
op_or_assign
(paren
id|LSR_XHRE
op_or
id|LSR_XSRE
)paren
suffix:semicolon
multiline_comment|/* can send anytime */
r_if
c_cond
(paren
id|L1_cons_is_inited
)paren
(brace
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module
op_ne
(paren
id|module_t
op_star
)paren
l_int|0
)paren
(brace
id|input
op_assign
id|l1_poll
c_func
(paren
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input
)paren
(brace
id|ret
op_or_assign
id|LSR_RCA
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Console input exported interface. Return a character (if one is available)&n; */
r_int
DECL|function|l1_serial_in_polled
id|l1_serial_in_polled
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|l1_serial_in_local
c_func
(paren
r_int
id|mode
)paren
suffix:semicolon
r_return
id|l1_serial_in_local
c_func
(paren
id|SERIAL_POLLED_MODE
)paren
suffix:semicolon
)brace
r_int
DECL|function|l1_serial_in
id|l1_serial_in
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|l1_serial_in_local
c_func
(paren
r_int
id|mode
)paren
suffix:semicolon
r_return
id|l1_serial_in_local
c_func
(paren
id|SERIAL_INTERRUPT_MODE
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|l1_serial_in_local
id|l1_serial_in_local
c_func
(paren
r_int
id|mode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|l1sc_t
op_star
id|sc
suffix:semicolon
r_int
id|value
suffix:semicolon
r_static
r_int
id|l1_getc
c_func
(paren
id|l1sc_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
id|l1sc_t
op_star
id|early_sc_init
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
id|sc
op_assign
id|early_sc_init
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L1_cons_is_inited
)paren
(brace
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module
op_ne
(paren
id|module_t
op_star
)paren
l_int|0
)paren
(brace
id|sc
op_assign
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
suffix:semicolon
)brace
)brace
id|value
op_assign
id|l1_getc
c_func
(paren
id|sc
comma
id|mode
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* Console output exported interface. Write message to the console.  */
r_int
DECL|function|l1_serial_out
id|l1_serial_out
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|len
)paren
(brace
id|nasid_t
id|nasid
op_assign
id|get_master_nasid
c_func
(paren
)paren
suffix:semicolon
r_int
id|l1_write
c_func
(paren
id|l1sc_t
op_star
comma
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L1_cons_is_inited
)paren
(brace
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module
op_ne
(paren
id|module_t
op_star
)paren
l_int|0
)paren
r_return
id|l1_write
c_func
(paren
op_amp
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
)paren
op_member_access_from_pointer
id|module-&gt;elsc
comma
id|str
comma
id|len
comma
macro_line|#if&t;defined(SYNC_CONSOLE_WRITE)
l_int|1
macro_line|#else
op_logical_neg
id|L1_interrupts_connected
macro_line|#endif
)paren
suffix:semicolon
)brace
r_return
id|early_l1_serial_out
c_func
(paren
id|nasid
comma
id|str
comma
id|len
comma
id|NOT_LOCKED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * These are the &squot;early&squot; functions - when we need to do things before we have&n; * all the structs setup.&n; */
DECL|variable|Early_console
r_static
id|l1sc_t
id|Early_console
suffix:semicolon
multiline_comment|/* fake l1sc_t */
DECL|variable|Early_console_inited
r_static
r_int
id|Early_console_inited
op_assign
l_int|0
suffix:semicolon
r_static
r_void
DECL|function|early_brl1_init
id|early_brl1_init
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|nasid_t
id|nasid
comma
id|net_vec_t
id|uart
)paren
(brace
r_int
id|i
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
id|bzero
c_func
(paren
id|sc
comma
r_sizeof
(paren
op_star
id|sc
)paren
)paren
suffix:semicolon
id|sc-&gt;nasid
op_assign
id|nasid
suffix:semicolon
id|sc-&gt;uart
op_assign
id|uart
suffix:semicolon
id|sc-&gt;getc_f
op_assign
(paren
id|uart
op_eq
id|BRL1_LOCALHUB_UART
ques
c_cond
id|uart_getc
suffix:colon
id|rtr_uart_getc
)paren
suffix:semicolon
id|sc-&gt;putc_f
op_assign
(paren
id|uart
op_eq
id|BRL1_LOCALHUB_UART
ques
c_cond
id|uart_putc
suffix:colon
id|rtr_uart_putc
)paren
suffix:semicolon
id|sc-&gt;sol
op_assign
l_int|1
suffix:semicolon
id|subch
op_assign
id|sc-&gt;subch
suffix:semicolon
multiline_comment|/* initialize L1 subchannels&n;     */
multiline_comment|/* assign processor TTY channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPUS_PER_NODE
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
multiline_comment|/* assign system TTY channel (first free subchannel after each&n;     * processor&squot;s individual TTY channel has been assigned)&n;     */
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
(brace
r_static
id|sc_cq_t
id|x_iqp
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|x_iqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
id|cq_init
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we shouldn&squot;t be getting console input from remote UARTs */
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
id|subch
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* &quot;reserved&quot; subchannels (0x05-0x0F); for now, throw away&n;     * incoming packets&n;     */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|0x10
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_FREE
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
multiline_comment|/* remaining subchannels are free */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|BRL1_NUM_SUBCHANS
suffix:semicolon
id|i
op_increment
comma
id|subch
op_increment
)paren
(brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_FREE
suffix:semicolon
id|subch-&gt;packet_arrived
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
)brace
)brace
r_static
r_inline
id|l1sc_t
op_star
DECL|function|early_sc_init
id|early_sc_init
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
multiline_comment|/* This is for early I/O */
r_if
c_cond
(paren
id|Early_console_inited
op_eq
l_int|0
)paren
(brace
id|early_brl1_init
c_func
(paren
op_amp
id|Early_console
comma
id|nasid
comma
id|BRL1_LOCALHUB_UART
)paren
suffix:semicolon
id|Early_console_inited
op_assign
l_int|1
suffix:semicolon
)brace
r_return
op_amp
id|Early_console
suffix:semicolon
)brace
DECL|macro|PUTCHAR
mdefine_line|#define PUTCHAR(ch) &bslash;&n;    { &bslash;&n;        while( (!(READ_L1_UART_REG( nasid, REG_LSR ) &amp; LSR_XHRE)) || &bslash;&n;                (!(READ_L1_UART_REG( nasid, REG_MSR ) &amp; MSR_CTS)) ); &bslash;&n;        WRITE_L1_UART_REG( nasid, REG_DAT, (ch) ); &bslash;&n;    }
r_static
r_int
DECL|function|early_l1_serial_out
id|early_l1_serial_out
c_func
(paren
id|nasid_t
id|nasid
comma
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
id|lock_state
)paren
(brace
r_int
id|ret
comma
id|sent
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|msg
op_assign
id|str
suffix:semicolon
r_static
r_int
id|early_l1_send
c_func
(paren
id|nasid_t
id|nasid
comma
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
id|lock_state
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sent
OL
id|len
)paren
(brace
id|ret
op_assign
id|early_l1_send
c_func
(paren
id|nasid
comma
id|msg
comma
id|len
op_minus
id|sent
comma
id|lock_state
)paren
suffix:semicolon
id|sent
op_add_assign
id|ret
suffix:semicolon
id|msg
op_add_assign
id|ret
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|early_l1_send
id|early_l1_send
c_func
(paren
id|nasid_t
id|nasid
comma
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
id|lock_state
)paren
(brace
r_int
id|sent
suffix:semicolon
r_char
id|crc_char
suffix:semicolon
r_int
r_int
id|crc
op_assign
id|INIT_CRC
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
(paren
id|BRL1_QSIZE
op_minus
l_int|1
)paren
)paren
(brace
id|len
op_assign
(paren
id|BRL1_QSIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|sent
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|lock_state
op_eq
id|NOT_LOCKED
)paren
id|lock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|PUTCHAR
c_func
(paren
id|BRL1_FLAG_CH
)paren
suffix:semicolon
id|PUTCHAR
c_func
(paren
id|BRL1_EVENT
op_or
id|SC_CONS_SYSTEM
)paren
suffix:semicolon
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|crc
comma
(paren
id|BRL1_EVENT
op_or
id|SC_CONS_SYSTEM
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|str
op_eq
id|BRL1_FLAG_CH
)paren
op_logical_or
(paren
op_star
id|str
op_eq
id|BRL1_ESC_CH
)paren
)paren
(brace
id|PUTCHAR
c_func
(paren
id|BRL1_ESC_CH
)paren
suffix:semicolon
id|PUTCHAR
c_func
(paren
(paren
op_star
id|str
)paren
op_xor
id|BRL1_XOR_CH
)paren
suffix:semicolon
)brace
r_else
(brace
id|PUTCHAR
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|crc16_calc
c_func
(paren
id|crc
comma
op_star
id|str
)paren
suffix:semicolon
id|str
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
id|crc
op_xor_assign
l_int|0xffff
suffix:semicolon
id|crc_char
op_assign
id|crc
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|crc_char
op_eq
id|BRL1_ESC_CH
)paren
op_logical_or
(paren
id|crc_char
op_eq
id|BRL1_FLAG_CH
)paren
)paren
(brace
id|crc_char
op_xor_assign
id|BRL1_XOR_CH
suffix:semicolon
id|PUTCHAR
c_func
(paren
id|BRL1_ESC_CH
)paren
suffix:semicolon
)brace
id|PUTCHAR
c_func
(paren
id|crc_char
)paren
suffix:semicolon
id|crc_char
op_assign
(paren
id|crc
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|crc_char
op_eq
id|BRL1_ESC_CH
)paren
op_logical_or
(paren
id|crc_char
op_eq
id|BRL1_FLAG_CH
)paren
)paren
(brace
id|crc_char
op_xor_assign
id|BRL1_XOR_CH
suffix:semicolon
id|PUTCHAR
c_func
(paren
id|BRL1_ESC_CH
)paren
suffix:semicolon
)brace
id|PUTCHAR
c_func
(paren
id|crc_char
)paren
suffix:semicolon
id|PUTCHAR
c_func
(paren
id|BRL1_FLAG_CH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_state
op_eq
id|NOT_LOCKED
)paren
id|unlock_console
c_func
(paren
id|nasid
)paren
suffix:semicolon
r_return
id|sent
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; * l1_cons functions&n; *&n; * These allow the L1 to act as the system console.  They&squot;re intended&n; * to abstract away most of the br/l1 internal details from the&n; * _L1_cons_* functions (in the prom-- see &quot;l1_console.c&quot;) and&n; * l1_* functions (in the kernel-- see &quot;sio_l1.c&quot;) that they support.&n; *&n; */
r_static
r_int
DECL|function|l1_poll
id|l1_poll
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|mode
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* in case this gets called before the l1sc_t structure for the module_t&n;     * struct for this node is initialized (i.e., if we&squot;re called with a&n;     * zero l1sc_t pointer)...&n;     */
r_if
c_cond
(paren
op_logical_neg
id|sc
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
dot
id|packet_arrived
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|ret
op_assign
id|brl1_receive
c_func
(paren
id|sc
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_ne
id|BRL1_VALID
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_NO_MESSAGE
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_PROTOCOL
)paren
op_logical_and
(paren
id|ret
op_ne
id|BRL1_CRC
)paren
)paren
id|L1_collectibles
(braket
id|L1C_REC_STALLS
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
dot
id|packet_arrived
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* pull a character off of the system console queue (if one is available)&n; */
r_static
r_int
DECL|function|l1_getc
id|l1_getc
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|mode
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
r_int
id|c
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|SC_CONS_SYSTEM
)braket
)paren
suffix:semicolon
id|sc_cq_t
op_star
id|q
op_assign
id|subch-&gt;iqp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l1_poll
c_func
(paren
id|sc
comma
id|mode
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cq_empty
c_func
(paren
id|q
)paren
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
comma
l_int|0
)paren
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cq_rem
c_func
(paren
id|q
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cq_empty
c_func
(paren
id|q
)paren
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
comma
l_int|0
)paren
suffix:semicolon
)brace
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a message to the L1 on the system console subchannel.&n; *&n; * Danger: don&squot;t use a non-zero value for the wait parameter unless you&squot;re&n; * someone important (like a kernel error message).&n; */
r_int
DECL|function|l1_write
id|l1_write
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_char
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|wait
)paren
(brace
r_int
id|sent
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_while
c_loop
(paren
id|sent
OL
id|len
)paren
(brace
id|ret
op_assign
id|brl1_send
c_func
(paren
id|sc
comma
id|msg
comma
id|len
op_minus
id|sent
comma
(paren
id|SC_CONS_SYSTEM
op_or
id|BRL1_EVENT
)paren
comma
id|wait
)paren
suffix:semicolon
id|sent
op_add_assign
id|ret
suffix:semicolon
id|msg
op_add_assign
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|brl1_send
c_func
(paren
id|sc
comma
id|msg
comma
id|len
comma
(paren
id|SC_CONS_SYSTEM
op_or
id|BRL1_EVENT
)paren
comma
id|wait
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* initialize the system console subchannel&n; */
r_void
DECL|function|l1_init
id|l1_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* All we do now is remember that we have been called */
id|L1_cons_is_inited
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; * The following functions and definitions implement the &quot;message&quot;-&n; * style interface to the L1 system controller.&n; *&n; * Note that throughout this file, &quot;sc&quot; generally stands for &quot;system&n; * controller&quot;, while &quot;subchannels&quot; tend to be represented by&n; * variables with names like subch or ch.&n; *&n; */
macro_line|#ifdef L1_DEBUG
DECL|macro|L1_DBG_PRF
mdefine_line|#define L1_DBG_PRF(x) printf x
macro_line|#else
DECL|macro|L1_DBG_PRF
mdefine_line|#define L1_DBG_PRF(x)
macro_line|#endif
multiline_comment|/*&n; * sc_data_ready is called to signal threads that are blocked on l1 input.&n; */
r_void
DECL|function|sc_data_ready
id|sc_data_ready
c_func
(paren
r_int
id|dummy0
comma
r_void
op_star
id|dummy1
comma
r_struct
id|pt_regs
op_star
id|dummy2
comma
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
id|sv_signal
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
)paren
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
)brace
multiline_comment|/* sc_open reserves a subchannel to send a request to the L1 (the&n; * L1&squot;s response will arrive on the same channel).  The number&n; * returned by sc_open is the system controller subchannel&n; * acquired.&n; */
r_int
DECL|function|sc_open
id|sc_open
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|uint
id|target
)paren
(brace
multiline_comment|/* The kernel version implements a locking scheme to arbitrate&n;     * subchannel assignment.&n;     */
r_int
id|ch
suffix:semicolon
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
id|SUBCH_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
multiline_comment|/* Look for a free subchannel. Subchannels 0-15 are reserved&n;     * for other purposes.&n;     */
r_for
c_loop
(paren
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|BRL1_CMD_SUBCH
)braket
)paren
comma
id|ch
op_assign
id|BRL1_CMD_SUBCH
suffix:semicolon
id|ch
OL
id|BRL1_NUM_SUBCHANS
suffix:semicolon
id|subch
op_increment
comma
id|ch
op_increment
)paren
(brace
r_if
c_cond
(paren
id|subch-&gt;use
op_eq
id|BRL1_SUBCH_FREE
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ch
op_eq
id|BRL1_NUM_SUBCHANS
)paren
(brace
multiline_comment|/* there were no subchannels available! */
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_NSUBCH
suffix:semicolon
)brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
comma
l_int|0
)paren
suffix:semicolon
id|subch-&gt;target
op_assign
id|target
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|subch-&gt;data_lock
)paren
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
comma
op_amp
(paren
id|subch-&gt;data_lock
)paren
comma
id|SV_MON_SPIN
op_or
id|SV_ORDER_FIFO
multiline_comment|/* | SV_INTS */
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|sc_data_ready
suffix:semicolon
id|subch-&gt;iqp
op_assign
id|snia_kmem_zalloc_node
c_func
(paren
r_sizeof
(paren
id|sc_cq_t
)paren
comma
id|KM_NOSLEEP
comma
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|sc-&gt;nasid
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
id|cq_init
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/* sc_close frees a Bedrock&lt;-&gt;L1 subchannel.&n; */
r_int
DECL|function|sc_close
id|sc_close
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
)paren
(brace
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
id|SUBCH_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subch-&gt;use
op_ne
id|BRL1_SUBCH_RSVD
)paren
(brace
multiline_comment|/* we&squot;re trying to close a subchannel that&squot;s not open */
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_NOPEN
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
comma
l_int|0
)paren
suffix:semicolon
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_FREE
suffix:semicolon
id|sv_broadcast
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
)paren
suffix:semicolon
id|sv_destroy
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
)paren
suffix:semicolon
id|spin_lock_destroy
c_func
(paren
op_amp
(paren
id|subch-&gt;data_lock
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|subch-&gt;iqp
op_logical_and
(paren
id|subch-&gt;iqp
op_ne
op_amp
id|sc-&gt;garbage_q
)paren
)paren
suffix:semicolon
id|snia_kmem_free
c_func
(paren
id|subch-&gt;iqp
comma
r_sizeof
(paren
id|sc_cq_t
)paren
)paren
suffix:semicolon
id|subch-&gt;iqp
op_assign
op_amp
id|sc-&gt;garbage_q
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|brl1_discard_packet
suffix:semicolon
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* sc_construct_msg builds a bedrock-to-L1 request in the supplied&n; * buffer.  Returns the length of the message.  The&n; * safest course when passing a buffer to be filled in is to use&n; * BRL1_QSIZE as the buffer size.&n; *&n; * Command arguments are passed as type/argument pairs, i.e., to&n; * pass the number 5 as an argument to an L1 command, call&n; * sc_construct_msg as follows:&n; *&n; *    char msg[BRL1_QSIZE];&n; *    msg_len = sc_construct_msg( msg,&n; *&t;&t;&t;&t;  BRL1_QSIZE,&n; *&t;&t;&t;&t;  target_component,&n; *                                L1_ADDR_TASK_BOGUSTASK,&n; *                                L1_BOGUSTASK_REQ_BOGUSREQ,&n; *                                2,&n; *                                L1_ARG_INT, 5 );&n; *&n; * To pass an additional ASCII argument, you&squot;d do the following:&n; *&n; *    char *str;&n; *    ... str points to a null-terminated ascii string ...&n; *    msg_len = sc_construct_msg( msg,&n; *                                BRL1_QSIZE,&n; *&t;&t;&t;&t;  target_component,&n; *                                L1_ADDR_TASK_BOGUSTASK,&n; *                                L1_BOGUSTASK_REQ_BOGUSREQ,&n; *                                4,&n; *                                L1_ARG_INT, 5,&n; *                                L1_ARG_ASCII, str );&n; *&n; * Finally, arbitrary data of unknown type is passed using the argtype&n; * code L1_ARG_UNKNOWN, a data length, and a buffer pointer, e.g.&n; *&n; *    msg_len = sc_construct_msg( msg,&n; *                                BRL1_QSIZE,&n; *&t;&t;&t;&t;  target_component,&n; *                                L1_ADDR_TASK_BOGUSTASK,&n; *                                L1_BOGUSTASK_REQ_BOGUSREQ,&n; *                                3,&n; *                                L1_ARG_UNKNOWN, 32, bufptr );&n; *&n; * ...passes 32 bytes of data starting at bufptr.  Note that no string or&n; * &quot;unknown&quot;-type argument should be long enough to overflow the message&n; * buffer.&n; *&n; * To construct a message for an L1 command that requires no arguments,&n; * you&squot;d use the following:&n; *&n; *    msg_len = sc_construct_msg( msg,&n; *                                BRL1_QSIZE,&n; *&t;&t;&t;&t;  target_component,&n; *                                L1_ADDR_TASK_BOGUSTASK,&n; *                                L1_BOGUSTASK_REQ_BOGUSREQ,&n; *                                0 );&n; *&n; * The final 0 means &quot;no varargs&quot;.  Notice that this parameter is used to hold&n; * the number of additional arguments to sc_construct_msg, _not_ the actual&n; * number of arguments used by the L1 command (so 2 per L1_ARG_[INT,ASCII]&n; * type argument, and 3 per L1_ARG_UNKOWN type argument).  A call to construct&n; * an L1 command which required three integer arguments and two arguments of&n; * some arbitrary (unknown) type would pass 12 as the value for this parameter.&n; *&n; * ENDIANNESS WARNING: The following code does a lot of copying back-and-forth&n; * between byte arrays and four-byte big-endian integers.  Depending on the&n; * system controller connection and endianness of future architectures, some&n; * rewriting might be necessary.&n; */
r_int
DECL|function|sc_construct_msg
id|sc_construct_msg
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
multiline_comment|/* system controller struct */
r_int
id|ch
comma
multiline_comment|/* subchannel for this message */
r_char
op_star
id|msg
comma
multiline_comment|/* message buffer */
r_int
id|msg_len
comma
multiline_comment|/* size of message buffer */
id|l1addr_t
id|addr_task
comma
multiline_comment|/* target system controller task */
r_int
id|req_code
comma
multiline_comment|/* 16-bit request code */
r_int
id|req_nargs
comma
multiline_comment|/* # of arguments (varargs) passed */
dot
dot
dot
)paren
multiline_comment|/* any additional parameters */
(brace
r_uint32
id|buf32
suffix:semicolon
multiline_comment|/* 32-bit buffer used to bounce things around */
r_void
op_star
id|bufptr
suffix:semicolon
multiline_comment|/* used to hold command argument addresses */
id|va_list
id|al
suffix:semicolon
multiline_comment|/* variable argument list */
r_int
id|index
suffix:semicolon
multiline_comment|/* current index into msg buffer */
r_int
id|argno
suffix:semicolon
multiline_comment|/* current position in varargs list */
r_int
id|l1_argno
suffix:semicolon
multiline_comment|/* running total of arguments to l1 */
r_int
id|l1_arg_t
suffix:semicolon
multiline_comment|/* argument type/length */
r_int
id|l1_argno_byte
suffix:semicolon
multiline_comment|/* offset of argument count byte */
id|index
op_assign
id|argno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set up destination address */
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
r_sizeof
(paren
id|buf32
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|L1_ADDRESS_TO_TASK
c_func
(paren
op_amp
id|buf32
comma
id|sc-&gt;subch
(braket
id|ch
)braket
dot
id|target
comma
id|addr_task
)paren
suffix:semicolon
id|COPY_INT_TO_BUFFER
c_func
(paren
id|msg
comma
id|index
comma
id|buf32
)paren
suffix:semicolon
multiline_comment|/* copy request code */
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
l_int|2
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg
(braket
id|index
op_increment
)braket
op_assign
(paren
(paren
id|req_code
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|msg
(braket
id|index
op_increment
)braket
op_assign
(paren
id|req_code
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req_nargs
)paren
(brace
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/* reserve a byte for the argument count */
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
l_int|1
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|l1_argno_byte
op_assign
id|index
op_increment
suffix:semicolon
id|l1_argno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy additional arguments */
id|va_start
c_func
(paren
id|al
comma
id|req_nargs
)paren
suffix:semicolon
r_while
c_loop
(paren
id|argno
OL
id|req_nargs
)paren
(brace
id|l1_argno
op_increment
suffix:semicolon
id|l1_arg_t
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|l1_arg_t
)paren
(brace
r_case
id|L1_ARG_INT
suffix:colon
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
(paren
r_sizeof
(paren
id|buf32
)paren
op_plus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg
(braket
id|index
op_increment
)braket
op_assign
id|L1_ARG_INT
suffix:semicolon
id|buf32
op_assign
(paren
r_int
)paren
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
id|COPY_INT_TO_BUFFER
c_func
(paren
id|msg
comma
id|index
comma
id|buf32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L1_ARG_ASCII
suffix:colon
id|bufptr
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_char
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
(paren
id|strlen
c_func
(paren
id|bufptr
)paren
op_plus
l_int|2
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg
(braket
id|index
op_increment
)braket
op_assign
id|L1_ARG_ASCII
suffix:semicolon
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|msg
(braket
id|index
)braket
)paren
comma
(paren
r_char
op_star
)paren
id|bufptr
)paren
suffix:semicolon
id|index
op_add_assign
(paren
id|strlen
c_func
(paren
id|bufptr
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* include terminating null */
r_break
suffix:semicolon
r_case
id|L1_ARG_UNKNOWN
suffix:colon
(brace
r_int
id|arglen
suffix:semicolon
id|arglen
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
id|bufptr
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_void
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg_len
op_sub_assign
(paren
id|arglen
op_plus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg
(braket
id|index
op_increment
)braket
op_assign
id|L1_ARG_UNKNOWN
op_or
id|arglen
suffix:semicolon
id|BCOPY
c_func
(paren
id|bufptr
comma
op_amp
(paren
id|msg
(braket
id|index
)braket
)paren
comma
id|arglen
)paren
suffix:semicolon
id|index
op_add_assign
id|arglen
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* unhandled argument type */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
id|msg
(braket
id|l1_argno_byte
)braket
op_assign
id|l1_argno
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/* sc_interpret_resp verifies an L1 response to a bedrock request, and&n; * breaks the response data up into the constituent parts.  If the&n; * response message indicates error, or if a mismatch is found in the&n; * expected number and type of arguments, an error is returned.  The&n; * arguments to this function work very much like the arguments to&n; * sc_construct_msg, above, except that L1_ARG_INTs must be followed&n; * by a _pointer_ to an integer that can be filled in by this function.&n; */
r_int
DECL|function|sc_interpret_resp
id|sc_interpret_resp
c_func
(paren
r_char
op_star
id|resp
comma
multiline_comment|/* buffer received from L1 */
r_int
id|resp_nargs
comma
multiline_comment|/* number of _varargs_ passed in */
dot
dot
dot
)paren
(brace
r_uint32
id|buf32
suffix:semicolon
multiline_comment|/* 32-bit buffer used to bounce things around */
r_void
op_star
id|bufptr
suffix:semicolon
multiline_comment|/* used to hold response field addresses */
id|va_list
id|al
suffix:semicolon
multiline_comment|/* variable argument list */
r_int
id|index
suffix:semicolon
multiline_comment|/* current index into response buffer */
r_int
id|argno
suffix:semicolon
multiline_comment|/* current position in varargs list */
r_int
id|l1_fldno
suffix:semicolon
multiline_comment|/* number of resp fields received from l1 */
r_int
id|l1_fld_t
suffix:semicolon
multiline_comment|/* field type/length */
id|index
op_assign
id|argno
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(L1_DEBUG)
DECL|macro|DUMP_RESP
mdefine_line|#define DUMP_RESP&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;int ix;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;        char outbuf[512];&t;&t;&t;&t;&t;&t;  &bslash;&n;        sprintf( outbuf, &quot;sc_interpret_resp error line %d: &quot;, __LINE__ ); &bslash;&n;&t;for( ix = 0; ix &lt; 16; ix++ ) {&t;&t;&t;&t;&t;  &bslash;&n;&t;    sprintf( &amp;outbuf[strlen(outbuf)], &quot;%x &quot;, resp[ix] );&t;  &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;printk( &quot;%s&bslash;n&quot;, outbuf );&t;&t;&t;&t;&t;  &bslash;&n;    }
macro_line|#else
mdefine_line|#define DUMP_RESP
macro_line|#endif /* L1_DEBUG */
multiline_comment|/* check response code */
id|COPY_BUFFER_TO_INT
c_func
(paren
id|resp
comma
id|index
comma
id|buf32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf32
op_ne
id|L1_RESP_OK
)paren
(brace
id|DUMP_RESP
suffix:semicolon
r_return
id|buf32
suffix:semicolon
)brace
multiline_comment|/* get number of response fields */
id|l1_fldno
op_assign
id|resp
(braket
id|index
op_increment
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|al
comma
id|resp_nargs
)paren
suffix:semicolon
multiline_comment|/* copy out response fields */
r_while
c_loop
(paren
id|argno
OL
id|resp_nargs
)paren
(brace
id|l1_fldno
op_decrement
suffix:semicolon
id|l1_fld_t
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_int
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|l1_fld_t
)paren
(brace
r_case
id|L1_ARG_INT
suffix:colon
r_if
c_cond
(paren
id|resp
(braket
id|index
op_increment
)braket
op_ne
id|L1_ARG_INT
)paren
(brace
multiline_comment|/* type mismatch */
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
id|DUMP_RESP
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bufptr
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_int
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
id|COPY_BUFFER_TO_BUFFER
c_func
(paren
id|resp
comma
id|index
comma
id|bufptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L1_ARG_ASCII
suffix:colon
r_if
c_cond
(paren
id|resp
(braket
id|index
op_increment
)braket
op_ne
id|L1_ARG_ASCII
)paren
(brace
multiline_comment|/* type mismatch */
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
id|DUMP_RESP
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bufptr
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_char
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|bufptr
comma
(paren
r_char
op_star
)paren
op_amp
(paren
id|resp
(braket
id|index
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* include terminating null */
id|index
op_add_assign
(paren
id|strlen
c_func
(paren
op_amp
(paren
id|resp
(braket
id|index
)braket
)paren
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|l1_fld_t
op_amp
id|L1_ARG_UNKNOWN
)paren
op_eq
id|L1_ARG_UNKNOWN
)paren
(brace
r_int
op_star
id|arglen
suffix:semicolon
id|arglen
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_int
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
id|bufptr
op_assign
id|va_arg
c_func
(paren
id|al
comma
r_void
op_star
)paren
suffix:semicolon
id|argno
op_increment
suffix:semicolon
op_star
id|arglen
op_assign
(paren
(paren
id|resp
(braket
id|index
op_increment
)braket
op_amp
op_complement
id|L1_ARG_UNKNOWN
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|BCOPY
c_func
(paren
op_amp
(paren
id|resp
(braket
id|index
)braket
)paren
comma
id|bufptr
comma
op_star
id|arglen
)paren
suffix:semicolon
id|index
op_add_assign
(paren
op_star
id|arglen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* unhandled type */
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
id|DUMP_RESP
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|va_end
c_func
(paren
id|al
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|l1_fldno
op_ne
l_int|0
)paren
op_logical_or
(paren
id|argno
op_ne
id|resp_nargs
)paren
)paren
(brace
multiline_comment|/* wrong number of arguments */
id|DUMP_RESP
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* sc_send takes as arguments a system controller struct, a&n; * buffer which contains a Bedrock&lt;-&gt;L1 &quot;request&quot; message,&n; * the message length, and the subchannel (presumably obtained&n; * from an earlier invocation of sc_open) over which the&n; * message is to be sent.  The final argument (&quot;wait&quot;) indicates&n; * whether the send is to be performed synchronously or not.&n; *&n; * sc_send returns either zero or an error value.  Synchronous sends &n; * (wait != 0) will not return until the data has actually been sent&n; * to the UART.  Synchronous sends generally receive privileged&n; * treatment.  The intent is that they be used sparingly, for such&n; * purposes as kernel printf&squot;s (the &quot;ducons&quot; routines).  Run-of-the-mill&n; * console output and L1 requests should NOT use a non-zero value&n; * for wait.&n; */
r_int
DECL|function|sc_send
id|sc_send
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
r_char
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|wait
)paren
(brace
r_char
id|type_and_subch
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
OL
l_int|0
)paren
op_logical_or
(paren
id|ch
op_ge
id|BRL1_NUM_SUBCHANS
)paren
)paren
(brace
r_return
id|SC_BADSUBCH
suffix:semicolon
)brace
multiline_comment|/* Verify that this is an open subchannel&n;     */
r_if
c_cond
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
dot
id|use
op_eq
id|BRL1_SUBCH_FREE
)paren
(brace
r_return
id|SC_NOPEN
suffix:semicolon
)brace
id|type_and_subch
op_assign
(paren
id|BRL1_REQUEST
op_or
(paren
(paren
id|u_char
)paren
id|ch
)paren
)paren
suffix:semicolon
id|result
op_assign
id|brl1_send
c_func
(paren
id|sc
comma
id|msg
comma
id|len
comma
id|type_and_subch
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* If we sent as much as we asked to, return &quot;ok&quot;. */
r_if
c_cond
(paren
id|result
op_eq
id|len
)paren
(brace
r_return
id|SC_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Or, if we sent less, than either the UART is busy or&n;     * we&squot;re trying to send too large a packet anyway.&n;     */
r_else
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|result
OL
id|len
)paren
(brace
r_return
id|SC_BUSY
suffix:semicolon
)brace
multiline_comment|/* Or, if something else went wrong (result &lt; 0), then&n;     * return that error value.&n;     */
r_else
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* subch_pull_msg pulls a message off the receive queue for subch&n; * and places it the buffer pointed to by msg.  This routine should only&n; * be called when the caller already knows a message is available on the&n; * receive queue (and, in the kernel, only when the subchannel data lock&n; * is held by the caller).&n; */
r_static
r_void
DECL|function|subch_pull_msg
id|subch_pull_msg
c_func
(paren
id|brl1_sch_t
op_star
id|subch
comma
r_char
op_star
id|msg
comma
r_int
op_star
id|len
)paren
(brace
id|sc_cq_t
op_star
id|q
suffix:semicolon
multiline_comment|/* receive queue */
r_int
id|before_wrap
comma
multiline_comment|/* packet may be split into two different       */
id|after_wrap
suffix:semicolon
multiline_comment|/*   pieces to accommodate queue wraparound      */
multiline_comment|/* pull message off the receive queue */
id|q
op_assign
id|subch-&gt;iqp
suffix:semicolon
id|cq_rem
c_func
(paren
id|q
comma
op_star
id|len
)paren
suffix:semicolon
multiline_comment|/* remove length byte and store */
id|cq_discard
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* remove type/subch byte and discard */
r_if
c_cond
(paren
op_star
id|len
OG
l_int|0
)paren
(paren
op_star
id|len
)paren
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t count type/subch byte in length returned */
r_if
c_cond
(paren
(paren
id|q-&gt;opos
op_plus
(paren
op_star
id|len
)paren
)paren
OG
id|BRL1_QSIZE
)paren
(brace
id|before_wrap
op_assign
id|BRL1_QSIZE
op_minus
id|q-&gt;opos
suffix:semicolon
id|after_wrap
op_assign
(paren
op_star
id|len
)paren
op_minus
id|before_wrap
suffix:semicolon
)brace
r_else
(brace
id|before_wrap
op_assign
(paren
op_star
id|len
)paren
suffix:semicolon
id|after_wrap
op_assign
l_int|0
suffix:semicolon
)brace
id|BCOPY
c_func
(paren
id|q-&gt;buf
op_plus
id|q-&gt;opos
comma
id|msg
comma
id|before_wrap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|after_wrap
)paren
(brace
id|BCOPY
c_func
(paren
id|q-&gt;buf
comma
id|msg
op_plus
id|before_wrap
comma
id|after_wrap
)paren
suffix:semicolon
id|q-&gt;opos
op_assign
id|after_wrap
suffix:semicolon
)brace
r_else
(brace
id|q-&gt;opos
op_assign
(paren
(paren
id|q-&gt;opos
op_plus
id|before_wrap
)paren
op_amp
(paren
id|BRL1_QSIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|subch-&gt;packet_arrived
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* sc_recv_poll can be called as a blocking or non-blocking function;&n; * it attempts to pull a message off of the subchannel specified&n; * in the argument list (ch).&n; *&n; * The &quot;block&quot; argument, if non-zero, is interpreted as a timeout&n; * delay (to avoid permanent waiting).&n; */
r_int
DECL|function|sc_recv_poll
id|sc_recv_poll
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
r_char
op_star
id|msg
comma
r_int
op_star
id|len
comma
r_uint64
id|block
)paren
(brace
r_int
id|is_msg
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
id|rtc_time_t
id|exp_time
op_assign
id|rtc_time
c_func
(paren
)paren
op_plus
id|block
suffix:semicolon
multiline_comment|/* sanity check-- make sure this is an open subchannel */
r_if
c_cond
(paren
id|subch-&gt;use
op_eq
id|BRL1_SUBCH_FREE
)paren
(brace
r_return
id|SC_NOPEN
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* kick the next lower layer and see if it pulls anything in&n;         */
id|brl1_receive
c_func
(paren
id|sc
comma
id|SERIAL_POLLED_MODE
)paren
suffix:semicolon
id|is_msg
op_assign
id|atomic_read
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block
op_logical_and
op_logical_neg
id|is_msg
op_logical_and
(paren
id|rtc_time
c_func
(paren
)paren
OL
id|exp_time
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_msg
)paren
(brace
multiline_comment|/* no message and we didn&squot;t care to wait for one */
r_return
id|SC_NMSG
suffix:semicolon
)brace
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
id|subch_pull_msg
c_func
(paren
id|subch
comma
id|msg
comma
id|len
)paren
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Like sc_recv_poll, sc_recv_intr can be called in either a blocking&n; * or non-blocking mode.  Rather than polling until an appointed timeout,&n; * however, sc_recv_intr sleeps on a syncrhonization variable until a&n; * signal from the lower layer tells us that a packet has arrived.&n; *&n; * sc_recv_intr can&squot;t be used with remote (router) L1s.&n; */
r_int
DECL|function|sc_recv_intr
id|sc_recv_intr
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
r_char
op_star
id|msg
comma
r_int
op_star
id|len
comma
r_uint64
id|block
)paren
(brace
r_int
id|is_msg
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
r_do
(brace
id|SUBCH_DATA_LOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
id|is_msg
op_assign
id|atomic_read
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_msg
op_logical_and
id|block
)paren
(brace
multiline_comment|/* wake me when you&squot;ve got something */
id|subch-&gt;rx_notify
op_assign
id|sc_data_ready
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subch-&gt;use
op_eq
id|BRL1_SUBCH_FREE
)paren
(brace
multiline_comment|/* oops-- somebody closed our subchannel while we were&n;&t;&t; * sleeping!&n;&t;&t; */
multiline_comment|/* no need to unlock since the channel&squot;s closed anyhow */
r_return
id|SC_NOPEN
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|is_msg
op_logical_and
id|block
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_msg
)paren
(brace
multiline_comment|/* no message and we didn&squot;t care to wait for one */
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_NMSG
suffix:semicolon
)brace
id|subch_pull_msg
c_func
(paren
id|subch
comma
id|msg
comma
id|len
)paren
suffix:semicolon
id|SUBCH_DATA_UNLOCK
c_func
(paren
id|subch
comma
id|pl
)paren
suffix:semicolon
r_return
id|SC_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* sc_command implements a (blocking) combination of sc_send and sc_recv.&n; * It is intended to be the SN1 equivalent of SN0&squot;s &quot;elsc_command&quot;, which&n; * issued a system controller command and then waited for a response from&n; * the system controller before returning.&n; *&n; * cmd points to the outgoing command; resp points to the buffer in&n; * which the response is to be stored.  Both buffers are assumed to&n; * be the same length; if there is any doubt as to whether the&n; * response buffer is long enough to hold the L1&squot;s response, then&n; * make it BRL1_QSIZE bytes-- no Bedrock&lt;-&gt;L1 message can be any&n; * bigger.&n; *&n; * Be careful using the same buffer for both cmd and resp; it could get&n; * hairy if there were ever an L1 command request that spanned multiple&n; * packets.  (On the other hand, that would require some additional&n; * rewriting of the L1 command interface anyway.)&n; */
DECL|macro|__RETRIES
mdefine_line|#define __RETRIES&t;50
DECL|macro|__WAIT_SEND
mdefine_line|#define __WAIT_SEND&t;1&t;
singleline_comment|// ( sc-&gt;uart != BRL1_LOCALHUB_UART )
DECL|macro|__WAIT_RECV
mdefine_line|#define __WAIT_RECV&t;10000000
r_int
DECL|function|sc_command
id|sc_command
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
r_char
op_star
id|cmd
comma
r_char
op_star
id|resp
comma
r_int
op_star
id|len
)paren
(brace
macro_line|#ifndef CONFIG_SERIAL_SGI_L1_PROTOCOL
r_return
id|SC_NMSG
suffix:semicolon
macro_line|#else
r_int
id|result
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|SC_NMSG
suffix:semicolon
id|retries
op_assign
id|__RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|result
op_assign
id|sc_send
c_func
(paren
id|sc
comma
id|ch
comma
id|cmd
comma
op_star
id|len
comma
id|__WAIT_SEND
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
id|SC_BUSY
)paren
(brace
id|retries
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retries
op_le
l_int|0
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
id|uart_delay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|result
suffix:semicolon
)brace
)brace
multiline_comment|/* block on sc_recv_* */
r_if
c_cond
(paren
(paren
id|sc-&gt;uart
op_eq
id|BRL1_LOCALHUB_UART
)paren
op_logical_and
id|L1_interrupts_connected
)paren
(brace
r_return
id|sc_recv_intr
c_func
(paren
id|sc
comma
id|ch
comma
id|resp
comma
id|len
comma
id|__WAIT_RECV
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|sc_recv_poll
c_func
(paren
id|sc
comma
id|ch
comma
id|resp
comma
id|len
comma
id|__WAIT_RECV
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
multiline_comment|/* sc_command_kern is a knuckle-dragging, no-patience version of sc_command&n; * used in situations where the kernel has a command that shouldn&squot;t be&n; * delayed until the send buffer clears.  sc_command should be used instead&n; * under most circumstances.&n; */
r_int
DECL|function|sc_command_kern
id|sc_command_kern
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
comma
r_char
op_star
id|cmd
comma
r_char
op_star
id|resp
comma
r_int
op_star
id|len
)paren
(brace
macro_line|#ifndef CONFIG_SERIAL_SGI_L1_PROTOCOL
r_return
id|SC_NMSG
suffix:semicolon
macro_line|#else
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
r_return
id|SC_NMSG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|sc_send
c_func
(paren
id|sc
comma
id|ch
comma
id|cmd
comma
op_star
id|len
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
r_return
id|sc_recv_poll
c_func
(paren
id|sc
comma
id|ch
comma
id|resp
comma
id|len
comma
id|__WAIT_RECV
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_SGI_L1_PROTOCOL */
)brace
multiline_comment|/* sc_poll checks the queue corresponding to the given&n; * subchannel to see if there&squot;s anything available.  If&n; * not, it kicks the brl1 layer and then checks again.&n; *&n; * Returns 1 if input is available on the given queue,&n; * 0 otherwise.&n; */
r_int
DECL|function|sc_poll
id|sc_poll
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
)paren
(brace
id|brl1_sch_t
op_star
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|ch
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|brl1_receive
c_func
(paren
id|sc
comma
id|SERIAL_POLLED_MODE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* for now, sc_init just calls brl1_init */
r_void
DECL|function|sc_init
id|sc_init
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|nasid_t
id|nasid
comma
id|net_vec_t
id|uart
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|brl1_init
c_func
(paren
id|sc
comma
id|nasid
comma
id|uart
)paren
suffix:semicolon
)brace
multiline_comment|/* sc_dispatch_env_event handles events sent from the system control&n; * network&squot;s environmental monitor tasks.&n; */
macro_line|#if&t;defined(LINUX_KERNEL_THREADS)
r_static
r_void
DECL|function|sc_dispatch_env_event
id|sc_dispatch_env_event
c_func
(paren
id|uint
id|code
comma
r_int
id|argc
comma
r_char
op_star
id|args
comma
r_int
id|maxlen
)paren
(brace
r_int
id|j
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_uint32
id|ESPcode
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
multiline_comment|/* for now, all codes do the same thing: grab two arguments&n;&t; * and print a cmn_err_tag message */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* check number of arguments */
r_if
c_cond
(paren
id|argc
op_ne
l_int|2
)paren
(brace
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;sc_dispatch_env_event: &quot;
l_string|&quot;expected 2 arguments, got %d&bslash;n&quot;
comma
id|argc
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get ESP code (integer argument) */
r_if
c_cond
(paren
id|args
(braket
id|i
op_increment
)braket
op_ne
id|L1_ARG_INT
)paren
(brace
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;sc_dispatch_env_event: &quot;
l_string|&quot;expected integer argument&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* WARNING: highly endian */
id|COPY_BUFFER_TO_INT
c_func
(paren
id|args
comma
id|i
comma
id|ESPcode
)paren
suffix:semicolon
multiline_comment|/* verify string argument */
r_if
c_cond
(paren
id|args
(braket
id|i
op_increment
)braket
op_ne
id|L1_ARG_ASCII
)paren
(brace
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;sc_dispatch_env_event: &quot;
l_string|&quot;expected an ASCII string&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|maxlen
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|args
(braket
id|j
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* found string termination */
)brace
r_if
c_cond
(paren
id|j
op_eq
id|maxlen
)paren
(brace
id|j
op_decrement
suffix:semicolon
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;sc_dispatch_env_event: &quot;
l_string|&quot;message too long-- truncating&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* strip out trailing cr/lf */
r_for
c_loop
(paren
suffix:semicolon
id|j
OG
l_int|1
op_logical_and
(paren
(paren
id|args
(braket
id|j
op_minus
l_int|1
)braket
op_eq
l_int|0xd
)paren
op_logical_or
(paren
id|args
(braket
id|j
op_minus
l_int|1
)braket
op_eq
l_int|0xa
)paren
)paren
suffix:semicolon
id|j
op_decrement
)paren
(brace
suffix:semicolon
)brace
id|args
(braket
id|j
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* strip out leading cr/lf */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|j
op_logical_and
(paren
(paren
id|args
(braket
id|i
)braket
op_eq
l_int|0xd
)paren
op_logical_or
(paren
id|args
(braket
id|i
)braket
op_eq
l_int|0xa
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* sc_event waits for events to arrive from the system controller, and&n; * prints appropriate messages to the syslog.&n; */
r_static
r_void
DECL|function|sc_event
id|sc_event
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|ch
)paren
(brace
r_char
id|event
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|event_len
suffix:semicolon
r_uint32
id|ev_src
suffix:semicolon
r_uint32
id|ev_code
suffix:semicolon
r_int
id|ev_argc
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|bzero
c_func
(paren
id|event
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wait for an event &n;&t; */
id|result
op_assign
id|sc_recv_intr
c_func
(paren
id|sc
comma
id|ch
comma
id|event
comma
op_amp
id|event_len
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|SC_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error receiving sysctl event on nasid %d&bslash;n&quot;
comma
id|sc-&gt;nasid
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;     * an event arrived; break it down into useful pieces&n;&t;     */
macro_line|#if defined(L1_DEBUG) &amp;&amp; 0
r_int
id|ix
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Event packet received:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
l_int|64
suffix:semicolon
id|ix
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%x%x &quot;
comma
(paren
(paren
id|event
(braket
id|ix
)braket
op_rshift
l_int|4
)paren
op_amp
(paren
(paren
r_uint64
)paren
l_int|0xf
)paren
)paren
comma
(paren
id|event
(braket
id|ix
)braket
op_amp
(paren
(paren
r_uint64
)paren
l_int|0xf
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ix
op_mod
l_int|16
)paren
op_eq
l_int|0xf
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* L1_DEBUG */
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get event source */
id|COPY_BUFFER_TO_INT
c_func
(paren
id|event
comma
id|i
comma
id|ev_src
)paren
suffix:semicolon
id|COPY_BUFFER_TO_INT
c_func
(paren
id|event
comma
id|i
comma
id|ev_code
)paren
suffix:semicolon
multiline_comment|/* get arg count */
id|ev_argc
op_assign
(paren
id|event
(braket
id|i
op_increment
)braket
op_amp
l_int|0xffUL
)paren
suffix:semicolon
multiline_comment|/* dispatch events by task */
r_switch
c_cond
(paren
(paren
id|ev_src
op_amp
id|L1_ADDR_TASK_MASK
)paren
op_rshift
id|L1_ADDR_TASK_SHFT
)paren
(brace
r_case
id|L1_ADDR_TASK_ENV
suffix:colon
multiline_comment|/* environmental monitor event */
id|sc_dispatch_env_event
c_func
(paren
id|ev_code
comma
id|ev_argc
comma
op_amp
(paren
id|event
(braket
id|i
)braket
)paren
comma
id|BRL1_QSIZE
op_minus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unhandled task type */
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;Unhandled event type received from system &quot;
l_string|&quot;controllers: source task %x&bslash;n&quot;
comma
(paren
id|ev_src
op_amp
id|L1_ADDR_TASK_MASK
)paren
op_rshift
id|L1_ADDR_TASK_SHFT
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* sc_listen sets up a service thread to listen for incoming events.&n; */
r_void
DECL|function|sc_listen
id|sc_listen
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|pl
op_assign
l_int|0
suffix:semicolon
id|brl1_sch_t
op_star
id|subch
suffix:semicolon
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|ch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_extern
r_int
id|msc_shutdown_pri
suffix:semicolon
multiline_comment|/* grab the designated &quot;event subchannel&quot; */
id|SUBCH_LOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|subch
op_assign
op_amp
(paren
id|sc-&gt;subch
(braket
id|BRL1_EVENT_SUBCH
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subch-&gt;use
op_ne
id|BRL1_SUBCH_FREE
)paren
(brace
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sysctl event subchannel in use! &quot;
l_string|&quot;Not monitoring sysctl events.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|subch-&gt;use
op_assign
id|BRL1_SUBCH_RSVD
suffix:semicolon
id|SUBCH_UNLOCK
c_func
(paren
id|sc
comma
id|pl
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|subch-&gt;packet_arrived
comma
l_int|0
)paren
suffix:semicolon
id|subch-&gt;target
op_assign
id|BRL1_LOCALHUB_UART
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|subch-&gt;data_lock
)paren
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
(paren
id|subch-&gt;arrive_sv
)paren
comma
op_amp
(paren
id|subch-&gt;data_lock
)paren
comma
id|SV_MON_SPIN
op_or
id|SV_ORDER_FIFO
multiline_comment|/* | SV_INTS */
)paren
suffix:semicolon
id|subch-&gt;tx_notify
op_assign
l_int|NULL
suffix:semicolon
id|subch-&gt;rx_notify
op_assign
id|sc_data_ready
suffix:semicolon
id|subch-&gt;iqp
op_assign
id|snia_kmem_zalloc_node
c_func
(paren
r_sizeof
(paren
id|sc_cq_t
)paren
comma
id|KM_NOSLEEP
comma
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|sc-&gt;nasid
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
id|cq_init
c_func
(paren
id|subch-&gt;iqp
)paren
suffix:semicolon
multiline_comment|/* set up a thread to listen for events */
id|sthread_create
c_func
(paren
l_string|&quot;sysctl event handler&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|msc_shutdown_pri
comma
id|KT_PS
comma
(paren
id|st_func_t
op_star
)paren
id|sc_event
comma
(paren
r_void
op_star
)paren
id|sc
comma
(paren
r_void
op_star
)paren
(paren
r_uint64
)paren
id|BRL1_EVENT_SUBCH
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* signal the L1 to begin sending events */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|ch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|ch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_EVENT_SUBCH
comma
l_int|2
comma
id|L1_ARG_INT
comma
id|BRL1_EVENT_SUBCH
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|ch
)paren
suffix:semicolon
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;Failure in sc_construct_msg (%d)&bslash;n&quot;
comma
id|len
)paren
)paren
suffix:semicolon
r_goto
id|err_return
suffix:semicolon
)brace
id|result
op_assign
id|sc_command_kern
c_func
(paren
id|sc
comma
id|ch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|ch
)paren
suffix:semicolon
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;Failure in sc_command_kern (%d)&bslash;n&quot;
comma
id|result
)paren
)paren
suffix:semicolon
r_goto
id|err_return
suffix:semicolon
)brace
id|sc_close
c_func
(paren
id|sc
comma
id|ch
)paren
suffix:semicolon
id|result
op_assign
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|L1_DBG_PRF
c_func
(paren
(paren
l_string|&quot;Failure in sc_interpret_resp (%d)&bslash;n&quot;
comma
id|result
)paren
)paren
suffix:semicolon
r_goto
id|err_return
suffix:semicolon
)brace
multiline_comment|/* everything went fine; just return */
r_return
suffix:semicolon
id|err_return
suffix:colon
multiline_comment|/* there was a problem; complain */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;failed to set sysctl event-monitoring subchannel.  &quot;
l_string|&quot;Sysctl events will not be monitored.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* LINUX_KERNEL_THREADS */
eof
