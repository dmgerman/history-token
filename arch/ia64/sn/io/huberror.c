multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Alan Mayer&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/nodemask.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/synergy.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
r_extern
r_void
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
suffix:semicolon
r_extern
r_void
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
suffix:semicolon
r_extern
r_void
id|snia_error_intr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
suffix:semicolon
r_extern
r_int
id|maxcpus
suffix:semicolon
DECL|macro|HUB_ERROR_PERIOD
mdefine_line|#define HUB_ERROR_PERIOD        (120 * HZ)      /* 2 minutes */
r_void
DECL|function|hub_error_clear
id|hub_error_clear
c_func
(paren
id|nasid_t
id|nasid
)paren
(brace
r_int
id|i
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
r_int
id|sn
suffix:semicolon
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_PEND
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS0_A_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS0_B_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_SPURIOUS_HDR_0
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_SPURIOUS_HDR_1
comma
l_int|0
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_DIR_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_MEM_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_MISC1_ERROR_CLR
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|MD_PROTOCOL_ERR_CLR
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure spurious write response errors are cleared&n;     * (values are from hub_set_prb())&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|HUB_WIDGET_ID_MAX
op_minus
id|HUB_WIDGET_ID_MIN
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iprb_t
id|prb
suffix:semicolon
id|prb.iprb_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear out some fields */
id|prb.iprb_ovflow
op_assign
l_int|1
suffix:semicolon
id|prb.iprb_bnakctr
op_assign
l_int|0
suffix:semicolon
id|prb.iprb_anakctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * PIO reads in fire-and-forget mode on bedrock 1.0 don&squot;t&n;&t; * frob the credit count properly, making the responses appear&n;&t; * spurious.  So don&squot;t use fire-and-forget mode.  Bug 761802.&n;&t; */
id|prb.iprb_ff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable fire-and-forget mode by default */
id|prb.iprb_xtalkctr
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* approx. PIO credits for the widget */
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IOPRB_0
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|hubreg_t
)paren
)paren
comma
id|prb.iprb_regval
)paren
suffix:semicolon
)brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IO_ERR_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|IIO_IIDSR
comma
(paren
id|idsr
op_amp
op_complement
(paren
id|IIO_IIDSR_SENT_MASK
)paren
)paren
)paren
suffix:semicolon
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|NI_PORT_ERROR_CLEAR
)paren
suffix:semicolon
multiline_comment|/* No need to clear NI_PORT_HEADER regs; they are continually overwritten*/
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|LB_ERROR_MASK_CLR
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|LB_ERROR_HDR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear XB error regs, in order */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|XB_FIRST_ERROR_CLEAR
op_minus
id|XB_POQ0_ERROR_CLEAR
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|hubreg_t
)paren
)paren
(brace
id|REMOTE_HUB_S
c_func
(paren
id|nasid
comma
id|XB_POQ0_ERROR_CLEAR
op_plus
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function&t;: hub_error_init&n; * Purpose&t;: initialize the error handling requirements for a given hub.&n; * Parameters&t;: cnode, the compact nodeid.&n; * Assumptions&t;: Called only once per hub, either by a local cpu. Or by a &n; *&t;&t;&t;remote cpu, when this hub is headless.(cpuless)&n; * Returns&t;: None&n; */
r_void
DECL|function|hub_error_init
id|hub_error_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
id|nasid
op_assign
id|cnodeid_to_nasid
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hub_error_clear
c_func
(paren
id|nasid
)paren
suffix:semicolon
macro_line|#ifdef ajm
r_if
c_cond
(paren
id|cnode
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * Allocate log for storing the node specific error info&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kl_error_log
(braket
id|i
)braket
op_assign
id|kmem_zalloc_node
c_func
(paren
r_sizeof
(paren
id|sn0_error_log_t
)paren
comma
id|KM_NOSLEEP
comma
id|i
)paren
suffix:semicolon
id|hub_err_count
(braket
id|i
)braket
op_assign
id|kmem_zalloc_node
c_func
(paren
r_sizeof
(paren
id|hub_errcnt_t
)paren
comma
id|VM_DIRECT
op_or
id|KM_NOSLEEP
comma
id|i
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|kl_error_log
(braket
id|i
)braket
op_logical_and
id|hub_err_count
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Assumption: There will be only one cpu who will initialize&n;     * a hub. we need to setup the ii and each pi error interrupts.&n;     * The SN1 hub (bedrock) has two PI, one for up to two processors.&n;     */
r_if
c_cond
(paren
id|cpuid_to_cnodeid
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_eq
id|cnode
)paren
(brace
r_int
id|generic_intr_mask
op_assign
id|PI_ERR_GENERIC
suffix:semicolon
multiline_comment|/* These interrupts are sent to only 1 CPU per NODE */
id|ASSERT_ALWAYS
c_func
(paren
id|kl_error_log
(braket
id|cnode
)braket
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hub_err_count
(braket
id|cnode
)braket
)paren
suffix:semicolon
id|MD_ERR_LOG_INIT
c_func
(paren
id|kl_error_log
(braket
id|cnode
)braket
)paren
suffix:semicolon
multiline_comment|/* One for each CPU */
id|recover_error_init
c_func
(paren
id|RECOVER_ERROR_TABLE
c_func
(paren
id|cnode
comma
l_int|0
)paren
)paren
suffix:semicolon
id|recover_error_init
c_func
(paren
id|RECOVER_ERROR_TABLE
c_func
(paren
id|cnode
comma
l_int|1
)paren
)paren
suffix:semicolon
id|recover_error_init
c_func
(paren
id|RECOVER_ERROR_TABLE
c_func
(paren
id|cnode
comma
l_int|2
)paren
)paren
suffix:semicolon
id|recover_error_init
c_func
(paren
id|RECOVER_ERROR_TABLE
c_func
(paren
id|cnode
comma
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup error intr masks.&n;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
r_int
id|cpuA_present
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CPU_ENABLE_A
)paren
suffix:semicolon
r_int
id|cpuB_present
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CPU_ENABLE_B
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuA_present
)paren
(brace
r_if
c_cond
(paren
id|cpuB_present
)paren
(brace
multiline_comment|/* A &amp;&amp; B */
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_A
comma
(paren
id|PI_FATAL_ERR_CPU_B
op_or
id|PI_MISC_ERR_CPU_A
op_or
id|generic_intr_mask
)paren
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_B
comma
(paren
id|PI_FATAL_ERR_CPU_A
op_or
id|PI_MISC_ERR_CPU_B
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A &amp;&amp; !B */
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_A
comma
(paren
id|PI_FATAL_ERR_CPU_A
op_or
id|PI_MISC_ERR_CPU_A
op_or
id|generic_intr_mask
)paren
)paren
suffix:semicolon
)brace
id|generic_intr_mask
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cpuB_present
)paren
(brace
multiline_comment|/* !A &amp;&amp; B */
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_B
comma
(paren
id|PI_FATAL_ERR_CPU_B
op_or
id|PI_MISC_ERR_CPU_B
op_or
id|generic_intr_mask
)paren
)paren
suffix:semicolon
id|generic_intr_mask
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* !A &amp;&amp; !B */
multiline_comment|/* nothing to set up */
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Turn off UNCAC_UNCORR interrupt in the masks. Anyone interested&n;&t; * in these errors will peek at the int pend register to see if its&n;&t; * set.&n;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|misc
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_A
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_A
comma
(paren
id|misc
op_amp
op_complement
id|PI_ERR_UNCAC_UNCORR_A
)paren
)paren
suffix:semicolon
id|misc
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_B
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_B
comma
(paren
id|misc
op_amp
op_complement
id|PI_ERR_UNCAC_UNCORR_B
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * enable all error indicators to turn on, in case of errors.&n;&t; *&n;&t; * This is not good on single cpu node boards.&n;&t; **** LOCAL_HUB_S(PI_SYSAD_ERRCHK_EN, PI_SYSAD_CHECK_ALL);&n;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS1_A_CLR
comma
l_int|0
)paren
suffix:semicolon
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STATUS1_B_CLR
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up stack for each present processor */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
r_if
c_cond
(paren
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CPU_PRESENT_A
)paren
)paren
(brace
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_cur_addr
(braket
l_int|0
)braket
op_assign
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_last_addr
(braket
l_int|0
)braket
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_A
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CPU_PRESENT_B
)paren
)paren
(brace
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_cur_addr
(braket
l_int|1
)braket
op_assign
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_last_addr
(braket
l_int|1
)braket
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_B
)paren
suffix:semicolon
)brace
)brace
id|PI_SPOOL_SIZE_BYTES
op_assign
id|ERR_STACK_SIZE_BYTES
c_func
(paren
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|PI_ERR_STACK_SIZE
)paren
)paren
suffix:semicolon
macro_line|#ifdef BRINGUP
multiline_comment|/* BRINGUP: The following code looks like a check to make sure&n;the prom set up the error spool correctly for 2 processors.  I&n;don&squot;t think it is needed.  */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
r_if
c_cond
(paren
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_CPU_PRESENT_B
)paren
)paren
(brace
id|__psunsigned_t
id|addr_a
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_A
)paren
suffix:semicolon
id|__psunsigned_t
id|addr_b
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_B
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_a
op_amp
op_complement
l_int|0xff
)paren
op_eq
(paren
id|addr_b
op_amp
op_complement
l_int|0xff
)paren
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_B
comma
id|addr_b
op_plus
id|PI_SPOOL_SIZE_BYTES
)paren
suffix:semicolon
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_cur_addr
(braket
l_int|1
)braket
op_assign
id|SN0_ERROR_LOG
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|el_spool_last_addr
(braket
l_int|1
)braket
op_assign
id|REMOTE_HUB_PI_L
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_STACK_ADDR_B
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* BRINGUP */
multiline_comment|/* programming our own hub. Enable error_int_pend intr.&n;&t; * If both present, CPU A takes CPU b&squot;s error interrupts and any&n;&t; * generic ones. CPU B takes CPU A error ints.&n;&t; */
r_if
c_cond
(paren
id|cause_intr_connect
(paren
id|SRB_ERR_IDX
comma
(paren
id|intr_func_t
)paren
(paren
id|hubpi_eint_handler
)paren
comma
id|SR_ALL_MASK
op_or
id|SR_IE
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|ERR_WARN
comma
l_string|&quot;hub_error_init: cause_intr_connect failed on %d&quot;
comma
id|cnode
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* programming remote hub. The only valid reason that this&n;&t; * is called will be on headless hubs. No interrupts &n;&t; */
r_for
c_loop
(paren
id|sn
op_assign
l_int|0
suffix:semicolon
id|sn
OL
id|NUM_SUBNODES
suffix:semicolon
id|sn
op_increment
)paren
(brace
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_A
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* not necessary */
id|REMOTE_HUB_PI_S
c_func
(paren
id|nasid
comma
id|sn
comma
id|PI_ERR_INT_MASK_B
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* not necessary */
)brace
)brace
macro_line|#endif /* ajm */
multiline_comment|/*&n;     * Now setup the hub ii and ni error interrupt handler.&n;     */
id|hubii_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubni_eint_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
macro_line|#ifdef ajm
multiline_comment|/*** XXX FIXME XXX resolve the following***/
multiline_comment|/* INT_PEND1 bits set up for one hub only:&n;     *&t;SHUTDOWN_INTR&n;     *&t;MD_COR_ERR_INTR&n;     *  COR_ERR_INTR_A and COR_ERR_INTR_B should be sent to the&n;     *  appropriate CPU only.&n;     */
r_if
c_cond
(paren
id|cnode
op_eq
l_int|0
)paren
(brace
id|error_consistency_check.eps_state
op_assign
l_int|0
suffix:semicolon
id|error_consistency_check.eps_cpuid
op_assign
op_minus
l_int|1
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|error_consistency_check.eps_lock
comma
l_string|&quot;error_dump_lock&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|nodepda-&gt;huberror_ticks
op_assign
id|HUB_ERROR_PERIOD
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Function&t;: hubii_eint_init&n; * Parameters&t;: cnode&n; * Purpose&t;: to initialize the hub iio error interrupt.&n; * Assumptions&t;: Called once per hub, by the cpu which will ultimately&n; *&t;&t;&t;handle this interrupt.&n; * Returns&t;: None.&n; */
r_void
DECL|function|hubii_eint_init
id|hubii_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|bit
comma
id|rv
suffix:semicolon
id|ii_iidsr_u_t
id|hubio_eint
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|cpuid_t
id|intr_cpu
suffix:semicolon
id|devfs_handle_t
id|hub_v
suffix:semicolon
id|ii_ilcsr_u_t
id|ilcsr
suffix:semicolon
id|hub_v
op_assign
(paren
id|devfs_handle_t
)paren
id|cnodeid_to_vertex
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hinfo-&gt;h_cnodeid
op_eq
id|cnode
)paren
suffix:semicolon
id|ilcsr.ii_ilcsr_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ilcsr.ii_ilcsr_fld_s.i_llp_stat
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* &n;&t; * HUB II link is not up. &n;&t; * Just disable LLP, and don&squot;t connect any interrupts.&n;&t; */
id|ilcsr.ii_ilcsr_fld_s.i_llp_en
op_assign
l_int|0
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_ILCSR
comma
id|ilcsr.ii_ilcsr_regval
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Select a possible interrupt target where there is a free interrupt&n;     * bit and also reserve the interrupt bit for this IO error interrupt&n;     */
id|intr_cpu
op_assign
id|intr_heuristic
c_func
(paren
id|hub_v
comma
l_int|0
comma
id|INTRCONNECT_ANYBIT
comma
id|II_ERRORINT
comma
id|hub_v
comma
l_string|&quot;HUB IO error interrupt&quot;
comma
op_amp
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_cpu
op_eq
id|CPU_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hubii_eint_init: intr_reserve_level failed, cnode %d&quot;
comma
id|cnode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rv
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpu
comma
id|bit
comma
l_int|0
comma
(paren
id|intr_func_t
)paren
(paren
l_int|NULL
)paren
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|hub_v
comma
l_int|NULL
)paren
suffix:semicolon
id|synergy_intr_connect
c_func
(paren
id|bit
comma
id|intr_cpu
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|bit_pos_to_irq
c_func
(paren
id|bit
)paren
op_plus
(paren
id|intr_cpu
op_lshift
l_int|8
)paren
comma
id|hubii_eint_handler
comma
l_int|0
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|hub_v
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rv
op_ge
l_int|0
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_regval
op_assign
l_int|0
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_enable
op_assign
l_int|1
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_level
op_assign
id|bit
suffix:semicolon
multiline_comment|/* Take the least significant bits*/
id|hubio_eint.ii_iidsr_fld_s.i_node
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|hubio_eint.ii_iidsr_fld_s.i_pi_id
op_assign
id|cpuid_to_subnode
c_func
(paren
id|intr_cpu
)paren
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|hubio_eint.ii_iidsr_regval
)paren
suffix:semicolon
)brace
r_void
DECL|function|hubni_eint_init
id|hubni_eint_init
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|intr_bit
suffix:semicolon
id|cpuid_t
id|targ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targ
op_assign
id|cnodeid_to_cpuid
c_func
(paren
id|cnode
)paren
)paren
op_eq
id|CPU_NONE
)paren
r_return
suffix:semicolon
multiline_comment|/* The prom chooses which cpu gets these interrupts, but we&n;&t;*  don&squot;t know which one it chose.  We will register all of the &n;&t;*  cpus to be sure.  This only costs us an irqaction per cpu.&n;&t;*/
r_for
c_loop
(paren
suffix:semicolon
id|targ
OL
id|CPUS_PER_NODE
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_enabled
c_func
(paren
id|targ
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* connect the INTEND1 bits. */
r_for
c_loop
(paren
id|intr_bit
op_assign
id|XB_ERROR
suffix:semicolon
id|intr_bit
op_le
id|MSC_PANIC_INTR
suffix:semicolon
id|intr_bit
op_increment
)paren
(brace
id|intr_connect_level
c_func
(paren
id|targ
comma
id|intr_bit
comma
id|II_ERRORINT
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|request_irq
c_func
(paren
id|SGI_HUB_ERROR_IRQ
op_plus
(paren
id|targ
op_lshift
l_int|8
)paren
comma
id|snia_error_intr_handler
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* synergy masks are initialized in the prom to enable all interrupts. */
multiline_comment|/* We&squot;ll just leave them that way, here, for these interrupts. */
)brace
)brace
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|hubii_eint_handler
id|hubii_eint_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ep
)paren
(brace
id|devfs_handle_t
id|hub_v
suffix:semicolon
id|hubinfo_t
id|hinfo
suffix:semicolon
id|ii_wstat_u_t
id|wstat
suffix:semicolon
id|hubreg_t
id|idsr
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Hubii interrupt&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef ajm
multiline_comment|/*&n;     * If the NI has a problem, everyone has a problem.  We shouldn&squot;t&n;     * even attempt to handle other errors when an NI error is present.&n;     */
r_if
c_cond
(paren
id|check_ni_errors
c_func
(paren
)paren
)paren
(brace
id|hubni_error_handler
c_func
(paren
l_string|&quot;II interrupt&quot;
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/* two levels of casting avoids compiler warning.!! */
id|hub_v
op_assign
(paren
id|devfs_handle_t
)paren
(paren
r_int
)paren
(paren
id|arg
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hub_v
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hub_v
comma
op_amp
id|hinfo
)paren
suffix:semicolon
multiline_comment|/* &n;     * Identify the reason for error. &n;     */
id|wstat.ii_wstat_regval
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_WSTAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_crazy
)paren
(brace
r_char
op_star
id|reason
suffix:semicolon
multiline_comment|/*&n;&t; * We can do a couple of things here. &n;&t; * Look at the fields TX_MX_RTY/XT_TAIL_TO/XT_CRD_TO to check&n;&t; * which of these caused the CRAZY bit to be set. &n;&t; * You may be able to check if the Link is up really.&n;&t; */
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_tx_mx_rty
)paren
id|reason
op_assign
l_string|&quot;Micro Packet Retry Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_tail_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Tail Timeout&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|wstat.ii_wstat_fld_s.w_xt_crd_to
)paren
id|reason
op_assign
l_string|&quot;Crosstalk Credit Timeout&quot;
suffix:semicolon
r_else
(brace
id|hubreg_t
id|hubii_imem
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if widget 0 has been marked as shutdown, or&n;&t;&t; * if BTE 0/1 has been marked.&n;&t;&t; */
id|hubii_imem
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_W0ESD
)paren
id|reason
op_assign
l_string|&quot;Hub Widget 0 has been Shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B0ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 0 has been shutdown&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hubii_imem
op_amp
id|IIO_IMEM_B1ESD
)paren
id|reason
op_assign
l_string|&quot;BTE 1 has been shutdown&quot;
suffix:semicolon
r_else
id|reason
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: we may never be able to print this, if the II talking&n;&t; * to Xbow which hosts the console is dead. &n;&t; */
id|printk
c_func
(paren
l_string|&quot;Hub %d to Xtalk Link failed (II_ECRAZY) Reason: %s&quot;
comma
id|hinfo-&gt;h_cnodeid
comma
id|reason
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;     * It&squot;s a toss as to which one among PRB/CRB to check first. &n;     * Current decision is based on the severity of the errors. &n;     * IO CRB errors tend to be more severe than PRB errors.&n;     *&n;     * It is possible for BTE errors to have been handled already, so we&n;     * may not see any errors handled here. &n;     */
(paren
r_void
)paren
id|hubiio_crb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
(paren
r_void
)paren
id|hubiio_prb_error_handler
c_func
(paren
id|hub_v
comma
id|hinfo
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we reach here, it indicates crb/prb handlers successfully&n;     * handled the error. So, re-enable II to send more interrupt&n;     * and return.&n;     */
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IECLR
comma
l_int|0xffffff
)paren
suffix:semicolon
id|idsr
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
)paren
op_amp
op_complement
id|IIO_IIDSR_SENT_MASK
suffix:semicolon
id|REMOTE_HUB_S
c_func
(paren
id|hinfo-&gt;h_nasid
comma
id|IIO_IIDSR
comma
id|idsr
)paren
suffix:semicolon
macro_line|#endif /* ajm */
)brace
eof
