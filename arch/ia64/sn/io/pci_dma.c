multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Leo Dagum&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#ifndef LANGUAGE_C 
DECL|macro|LANGUAGE_C
mdefine_line|#define LANGUAGE_C 99
macro_line|#endif
macro_line|#ifndef _LANGUAGE_C
DECL|macro|_LANGUAGE_C
mdefine_line|#define _LANGUAGE_C 99
macro_line|#endif
macro_line|#ifndef CONFIG_IA64_SGI_IO
DECL|macro|CONFIG_IA64_SGI_IO
mdefine_line|#define CONFIG_IA64_SGI_IO 99
macro_line|#endif
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/iobus.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/alenlist.h&gt;
multiline_comment|/*&n; * this is REALLY ugly, blame it on gcc&squot;s lame inlining that we&n; * have to put procedures in header files&n; */
macro_line|#if LANGUAGE_C == 99
DECL|macro|LANGUAGE_C
macro_line|#undef LANGUAGE_C
macro_line|#endif
macro_line|#if _LANGUAGE_C == 99
DECL|macro|_LANGUAGE_C
macro_line|#undef _LANGUAGE_C
macro_line|#endif
macro_line|#if CONFIG_IA64_SGI_IO == 99
DECL|macro|CONFIG_IA64_SGI_IO
macro_line|#undef CONFIG_IA64_SGI_IO
macro_line|#endif
multiline_comment|/*&n; * sn1 platform specific pci_alloc_consistent()&n; *&n; * this interface is meant for &quot;command&quot; streams, i.e. called only&n; * once for initializing a device, so we don&squot;t want prefetching or&n; * write gathering turned on, hence the PCIIO_DMA_CMD flag&n; */
r_void
op_star
DECL|function|sn1_pci_alloc_consistent
id|sn1_pci_alloc_consistent
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
r_int
id|gfp
op_assign
id|GFP_ATOMIC
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|paddr_t
id|temp_ptr
suffix:semicolon
op_star
id|dma_handle
op_assign
(paren
id|dma_addr_t
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * get vertex for the device&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|gfp
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|temp_ptr
op_assign
(paren
id|paddr_t
)paren
id|__pa
c_func
(paren
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIA64
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This device supports 64bits DMA addresses.&n;&t;&t; */
op_star
id|dma_handle
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|size
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
op_or
id|PCIIO_DMA_A64
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Devices that supports 32 Bits upto 63 Bits DMA Address gets&n;&t; * 32 Bits DMA addresses.&n;&t; *&n;&t; * First try to get 32 Bit Direct Map Support.&n;&t; */
r_if
c_cond
(paren
id|IS_PCI32G
c_func
(paren
id|hwdev
)paren
)paren
(brace
op_star
id|dma_handle
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|size
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_handle
)paren
(brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We need to map this request by using ATEs.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;sn1_pci_alloc_consistent: 32Bits DMA Page Map support not available yet!&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|IS_PCI32L
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * SNIA64 cannot support DMA Addresses smaller than 32 bits.&n;&t;&t; */
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|sn1_pci_free_consistent
id|sn1_pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On sn1 we use the alt_address entry of the scatterlist to store&n; * the physical address corresponding to the given virtual address&n; */
r_int
DECL|function|sn1_pci_map_sg
id|sn1_pci_map_sg
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
id|paddr_t
id|temp_ptr
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle 64 bit cards.&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|sg-&gt;orig_address
op_assign
id|sg-&gt;address
suffix:semicolon
id|dma_addr
op_assign
l_int|0
suffix:semicolon
id|temp_ptr
op_assign
(paren
id|paddr_t
)paren
id|__pa
c_func
(paren
id|sg-&gt;address
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle the most common case 64Bit cards.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_PCIA64
c_func
(paren
id|hwdev
)paren
)paren
(brace
id|dma_addr
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|sg-&gt;length
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
op_or
id|PCIIO_DMA_A64
)paren
suffix:semicolon
id|sg-&gt;address
op_assign
(paren
r_char
op_star
)paren
id|dma_addr
suffix:semicolon
multiline_comment|/* printk(&quot;pci_map_sg: 64Bits hwdev %p DMA Address 0x%p alt_address 0x%p orig_address 0x%p length 0x%x&bslash;n&quot;, hwdev, sg-&gt;address, sg-&gt;alt_address, sg-&gt;orig_address, sg-&gt;length); */
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Handle 32Bits and greater cards.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_PCI32G
c_func
(paren
id|hwdev
)paren
)paren
(brace
id|dma_addr
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|sg-&gt;length
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
)paren
(brace
id|sg-&gt;address
op_assign
(paren
r_char
op_star
)paren
id|dma_addr
suffix:semicolon
multiline_comment|/* printk(&quot;pci_map_single: 32Bit direct pciio_dmatrans_addr pcidev %p returns dma_addr 0x%lx&bslash;n&quot;, hwdev, dma_addr); */
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We need to map this request by using ATEs.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;pci_map_single: 32Bits DMA Page Map support not available yet!&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|nents
suffix:semicolon
)brace
multiline_comment|/*&n; * Unmap a set of streaming mode DMA translations.&n; * Again, cpu read rules concerning calls here are the same as for&n; * pci_unmap_single() above.&n; */
r_void
DECL|function|sn1_pci_unmap_sg
id|sn1_pci_unmap_sg
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
r_if
c_cond
(paren
id|sg-&gt;orig_address
op_ne
id|sg-&gt;address
)paren
(brace
multiline_comment|/* phys_to_virt((dma_addr_t)sg-&gt;address | ~0x80000000); */
id|sg-&gt;address
op_assign
id|sg-&gt;orig_address
suffix:semicolon
id|sg-&gt;orig_address
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We map this to the one step pciio_dmamap_trans interface rather than&n; * the two step pciio_dmamap_alloc/pciio_dmamap_addr because we have&n; * no way of saving the dmamap handle from the alloc to later free&n; * (which is pretty much unacceptable).&n; *&n; * TODO: simplify our interface;&n; *       get rid of dev_desc and vhdl (seems redundant given a pci_dev);&n; *       figure out how to save dmamap handle so can use two step.&n; */
DECL|function|sn1_pci_map_single
id|dma_addr_t
id|sn1_pci_map_single
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
id|paddr_t
id|temp_ptr
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCI32L
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * SNIA64 cannot support DMA Addresses smaller than 32 bits.&n;&t;&t; */
r_return
(paren
(paren
id|dma_addr_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * find vertex for the device&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
multiline_comment|/* printk(&quot;pci_map_single: Called vhdl = 0x%p ptr = 0x%p size = %d&bslash;n&quot;, vhdl, ptr, size); */
multiline_comment|/*&n;&t; * Call our dmamap interface&n;&t; */
id|dma_addr
op_assign
l_int|0
suffix:semicolon
id|temp_ptr
op_assign
(paren
id|paddr_t
)paren
id|__pa
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIA64
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This device supports 64bits DMA addresses.&n;&t;&t; */
id|dma_addr
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|size
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
op_or
id|PCIIO_DMA_A64
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;pci_map_single: 64Bit pciio_dmatrans_addr pcidev %p returns dma_addr 0x%lx&bslash;n&quot;, hwdev, dma_addr); */
r_return
(paren
id|dma_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Devices that supports 32 Bits upto 63 Bits DMA Address gets&n;&t; * 32 Bits DMA addresses.&n;&t; *&n;&t; * First try to get 32 Bit Direct Map Support.&n;&t; */
r_if
c_cond
(paren
id|IS_PCI32G
c_func
(paren
id|hwdev
)paren
)paren
(brace
id|dma_addr
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|temp_ptr
comma
id|size
comma
id|PCIBR_BARRIER
op_or
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
)paren
(brace
multiline_comment|/* printk(&quot;pci_map_single: 32Bit direct pciio_dmatrans_addr pcidev %p returns dma_addr 0x%lx&bslash;n&quot;, hwdev, dma_addr); */
r_return
(paren
id|dma_addr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We need to map this request by using ATEs.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;pci_map_single: 32Bits DMA Page Map support not available yet!&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|IS_PCI32L
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * SNIA64 cannot support DMA Addresses smaller than 32 bits.&n;&t;&t; */
r_return
(paren
(paren
id|dma_addr_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
id|dma_addr_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|sn1_pci_unmap_single
id|sn1_pci_unmap_single
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Nothing to do */
)brace
r_void
DECL|function|sn1_pci_dma_sync_single
id|sn1_pci_dma_sync_single
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Nothing to do */
)brace
r_void
DECL|function|sn1_pci_dma_sync_sg
id|sn1_pci_dma_sync_sg
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Nothing to do */
)brace
r_int
r_int
DECL|function|sn1_dma_address
id|sn1_dma_address
(paren
r_struct
id|scatterlist
op_star
id|sg
)paren
(brace
r_return
(paren
id|sg-&gt;address
)paren
suffix:semicolon
)brace
eof
