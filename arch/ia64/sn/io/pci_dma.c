multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000,2002 Silicon Graphics, Inc. All rights reserved.&n; *&n; * Routines for PCI DMA mapping.  See Documentation/DMA-mapping.txt for&n; * a description of how these routines should be used.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/driver.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/alenlist.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/nag.h&gt;
multiline_comment|/*&n; * For ATE allocations&n; */
id|pciio_dmamap_t
id|get_free_pciio_dmamap
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_static
r_struct
id|sn_dma_maps_s
op_star
id|find_sn_dma_map
c_func
(paren
id|dma_addr_t
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/*&n; * Toplogy stuff&n; */
r_extern
id|devfs_handle_t
id|busnum_to_pcibr_vhdl
(braket
)braket
suffix:semicolon
r_extern
id|nasid_t
id|busnum_to_nid
(braket
)braket
suffix:semicolon
r_extern
r_void
op_star
id|busnum_to_atedmamaps
(braket
)braket
suffix:semicolon
multiline_comment|/**&n; * get_free_pciio_dmamap - find and allocate an ATE&n; * @pci_bus: PCI bus to get an entry for&n; *&n; * Finds and allocates an ATE on the PCI bus specified&n; * by @pci_bus.&n; */
id|pciio_dmamap_t
DECL|function|get_free_pciio_dmamap
id|get_free_pciio_dmamap
c_func
(paren
id|devfs_handle_t
id|pci_bus
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Darn, we need to get the maps allocated for this bus.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PCI_XWIDGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|busnum_to_pcibr_vhdl
(braket
id|i
)braket
op_eq
id|pci_bus
)paren
(brace
id|sn_dma_map
op_assign
id|busnum_to_atedmamaps
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now get a free dmamap entry from this list.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ATE_MAPS
suffix:semicolon
id|i
op_increment
comma
id|sn_dma_map
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sn_dma_map-&gt;dma_addr
)paren
(brace
id|sn_dma_map-&gt;dma_addr
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * free_pciio_dmamap - free an ATE&n; * @dma_map: ATE to free&n; *&n; * Frees the ATE specified by @dma_map.&n; */
r_void
DECL|function|free_pciio_dmamap
id|free_pciio_dmamap
c_func
(paren
id|pcibr_dmamap_t
id|dma_map
)paren
(brace
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
suffix:semicolon
id|sn_dma_map
op_assign
(paren
r_struct
id|sn_dma_maps_s
op_star
)paren
id|dma_map
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * find_sn_dma_map - find an ATE associated with @dma_addr and @busnum&n; * @dma_addr: DMA address to look for&n; * @busnum: PCI bus to look on&n; *&n; * Finds the ATE associated with @dma_addr and @busnum.&n; */
r_static
r_struct
id|sn_dma_maps_s
op_star
DECL|function|find_sn_dma_map
id|find_sn_dma_map
c_func
(paren
id|dma_addr_t
id|dma_addr
comma
r_int
r_char
id|busnum
)paren
(brace
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sn_dma_map
op_assign
id|busnum_to_atedmamaps
(braket
id|busnum
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ATE_MAPS
suffix:semicolon
id|i
op_increment
comma
id|sn_dma_map
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sn_dma_map-&gt;dma_addr
op_eq
id|dma_addr
)paren
(brace
r_return
id|sn_dma_map
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_dma_sync - try to flush DMA buffers into the coherence domain&n; * @hwdev: device to flush&n; *&n; * This routine flushes all DMA buffers for the device into the II of&n; * the destination hub.&n; *&n; * NOTE!: this does not mean that the data is in the &quot;coherence domain&quot;,&n; * but it is very close.  In other words, this routine *does not work*&n; * as advertised due to hardware bugs.  That said, it should be good enough for&n; * most situations.&n; */
r_void
DECL|function|sn_dma_sync
id|sn_dma_sync
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
)paren
(brace
macro_line|#ifdef SN_DMA_SYNC
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_volatile
r_int
r_int
id|dummy
suffix:semicolon
multiline_comment|/*&n;&t; * A DMA sync is supposed to ensure that &n;&t; * all the DMA from a particular device&n;&t; * is complete and coherent.  We&n;&t; * try to do this by&n;&t; *&t;1. flushing the write wuffers from Bridge&n;&t; *&t;2. flushing the Xbow port.&n;&t; * Unfortunately, this only gets the DMA transactions &squot;very close&squot; to&n;&t; * the coherence domain, but not quite in it.&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|dummy
op_assign
(paren
r_volatile
r_int
r_int
)paren
op_star
id|device_sysdata-&gt;dma_buf_sync
suffix:semicolon
multiline_comment|/*&n;&t; * For the Xbow port flush, we may be denied the request because &n;&t; * someone else may be flushing the port .. try again.&n;&t; */
r_while
c_loop
(paren
(paren
r_volatile
r_int
r_int
)paren
op_star
id|device_sysdata-&gt;xbow_buf_sync
)paren
(brace
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/**&n; * sn_pci_alloc_consistent - allocate memory for coherent DMA&n; * @hwdev: device to allocate for&n; * @size: size of the region&n; * @dma_handle: DMA (bus) address&n; *&n; * pci_alloc_consistent() returns a pointer to a memory region suitable for&n; * coherent DMA traffic to/from a PCI device.  On SN platforms, this means&n; * that @dma_handle will have the %PCIIO_DMA_CMD flag set.&n; *&n; * This interface is usually used for &quot;command&quot; streams (e.g. the command&n; * queue for a SCSI controller).  See Documentation/DMA-mapping.txt for&n; * more information.  Note that this routine will always put a 32 bit&n; * DMA address into @dma_handle.  This is because most devices&n; * that are capable of 64 bit PCI DMA transactions can&squot;t do 64 bit _coherent_&n; * DMAs, and unfortunately this interface has to cater to the LCD.  Oh well.&n; *&n; * Also known as platform_pci_alloc_consistent() by the IA64 machvec code.&n; */
r_void
op_star
DECL|function|sn_pci_alloc_consistent
id|sn_pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_void
op_star
id|cpuaddr
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
id|pciio_dmamap_t
id|dma_map
op_assign
l_int|0
suffix:semicolon
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
suffix:semicolon
op_star
id|dma_handle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We can&squot;t easily support &lt; 32 bit devices */
r_if
c_cond
(paren
id|IS_PCI32L
c_func
(paren
id|hwdev
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Get hwgraph vertex for the device&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the memory.  FIXME: if we&squot;re allocating for&n;&t; * two devices on the same bus, we should at least try to&n;&t; * allocate memory in the same 2 GB window to avoid using&n;&t; * ATEs for the translation.  See the comment above about the&n;&t; * 32 bit requirement for this function.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpuaddr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cpuaddr
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* have to zero it out */
multiline_comment|/* physical addr. of the memory we just got */
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|cpuaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This will try to use a Direct Map register to do the&n;&t; * 32 bit DMA mapping, but it may not succeed if another&n;&t; * device on the same bus is already mapped with different&n;&t; * attributes or to a different memory region.&n;&t; */
macro_line|#ifdef CONFIG_IA64_SGI_SN1
op_star
id|dma_handle
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|size
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
op_star
id|dma_handle
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|size
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
multiline_comment|/*&n;&t; * It is a 32 bit card and we cannot do direct mapping,&n;&t; * so we try to use an ATE.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|dma_handle
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|size
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|size
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_CMD
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dma_map
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_pci_alloc_consistent: Unable to &quot;
l_string|&quot;allocate anymore 32 bit page map entries.&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|dma_handle
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmamap_addr
c_func
(paren
id|dma_map
comma
id|phys_addr
comma
id|size
)paren
suffix:semicolon
id|sn_dma_map
op_assign
(paren
r_struct
id|sn_dma_maps_s
op_star
)paren
id|dma_map
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
op_star
id|dma_handle
suffix:semicolon
)brace
r_return
id|cpuaddr
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_free_consistent - free memory associated with coherent DMAable region&n; * @hwdev: device to free for&n; * @size: size to free&n; * @vaddr: kernel virtual address to free&n; * @dma_handle: DMA address associated with this region&n; *&n; * Frees the memory allocated by pci_alloc_consistent().  Also known&n; * as platform_pci_free_consistent() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_free_consistent
id|sn_pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Get the sn_dma_map entry.&n;&t; */
r_if
c_cond
(paren
id|IS_PCI32_MAPPED
c_func
(paren
id|dma_handle
)paren
)paren
id|sn_dma_map
op_assign
id|find_sn_dma_map
c_func
(paren
id|dma_handle
comma
id|hwdev-&gt;bus-&gt;number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and free it if necessary...&n;&t; */
r_if
c_cond
(paren
id|sn_dma_map
)paren
(brace
id|pciio_dmamap_done
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|pciio_dmamap_free
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
(paren
id|dma_addr_t
)paren
l_int|NULL
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_map_sg - map a scatter-gather list for DMA&n; * @hwdev: device to map for&n; * @sg: scatterlist to map&n; * @nents: number of entries&n; * @direction: direction of the DMA transaction&n; *&n; * Maps each entry of @sg for DMA.  Also known as platform_pci_map_sg by the&n; * IA64 machvec code.&n; */
r_int
DECL|function|sn_pci_map_sg
id|sn_pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|pciio_dmamap_t
id|dma_map
suffix:semicolon
multiline_comment|/* can&squot;t go anywhere w/o a direction in life */
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the hwgraph vertex for the device&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
multiline_comment|/*&n;&t; * Setup a DMA address for each entry in the&n;&t; * scatterlist.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
multiline_comment|/* this catches incorrectly written drivers that&n;                   attempt to map scatterlists that they have&n;                   previously mapped.  we print a warning and&n;                   continue, but the driver should be fixed */
r_switch
c_cond
(paren
(paren
(paren
id|u64
)paren
id|sg-&gt;dma_address
)paren
op_rshift
l_int|60
)paren
(brace
r_case
l_int|0xa
suffix:colon
r_case
l_int|0xb
suffix:colon
macro_line|#ifdef DEBUG
multiline_comment|/* This needs to be cleaned up at some point. */
id|NAG
c_func
(paren
l_string|&quot;A PCI driver (for device at%8s) has attempted to &quot;
l_string|&quot;map a scatterlist that was previously mapped at &quot;
l_string|&quot;%p - this is currently being worked around.&bslash;n&quot;
comma
id|hwdev-&gt;slot_name
comma
(paren
r_void
op_star
)paren
id|sg-&gt;dma_address
)paren
suffix:semicolon
id|phys_addr
op_assign
(paren
id|u64
)paren
id|sg-&gt;dma_address
op_amp
id|TO_PHYS_MASK
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
multiline_comment|/* not previously mapped, get the phys. addr */
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|sg-&gt;dma_address
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sg-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|dma_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle the most common case: 64 bit cards.  This&n;&t;&t; * call should always succeed.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_PCIA64
c_func
(paren
id|hwdev
)paren
)paren
(brace
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|sg-&gt;length
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
op_or
id|PCIIO_DMA_A64
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
(paren
r_char
op_star
)paren
id|dma_addr
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Handle 32-63 bit cards via direct mapping&n;&t;&t; */
r_if
c_cond
(paren
id|IS_PCI32G
c_func
(paren
id|hwdev
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|sg-&gt;length
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|sg-&gt;length
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * See if we got a direct map entry&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dma_addr
)paren
(brace
id|sg-&gt;dma_address
op_assign
(paren
r_char
op_star
)paren
id|dma_addr
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * It is a 32 bit card and we cannot do direct mapping,&n;&t;&t; * so we use an ATE.&n;&t;&t; */
id|dma_map
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|sg-&gt;length
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|sg-&gt;length
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dma_map
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_pci_map_sg: Unable to allocate &quot;
l_string|&quot;anymore 32 bit page map entries.&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|dma_addr
op_assign
id|pciio_dmamap_addr
c_func
(paren
id|dma_map
comma
id|phys_addr
comma
id|sg-&gt;length
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
(paren
r_char
op_star
)paren
id|dma_addr
suffix:semicolon
id|sg-&gt;page
op_assign
(paren
r_struct
id|page
op_star
)paren
id|dma_map
suffix:semicolon
)brace
r_return
id|nents
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_unmap_sg - unmap a scatter-gather list&n; * @hwdev: device to unmap&n; * @sg: scatterlist to unmap&n; * @nents: number of scatterlist entries&n; * @direction: DMA direction&n; *&n; * Unmap a set of streaming mode DMA translations.  Again, cpu read rules&n; * concerning calls here are the same as for pci_unmap_single() below.  Also&n; * known as sn_pci_unmap_sg() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_unmap_sg
id|sn_pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
suffix:semicolon
multiline_comment|/* can&squot;t go anywhere w/o a direction in life */
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
r_if
c_cond
(paren
id|sg-&gt;page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We maintain the DMA Map pointer in sg-&gt;page if &n;&t;&t;&t; * it is ever allocated.&n;&t;&t;&t; */
id|sg-&gt;dma_address
op_assign
l_int|0
suffix:semicolon
id|sn_dma_map
op_assign
(paren
r_struct
id|sn_dma_maps_s
op_star
)paren
id|sg-&gt;page
suffix:semicolon
id|pciio_dmamap_done
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|pciio_dmamap_free
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
l_int|0
suffix:semicolon
id|sg-&gt;page
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * sn_pci_map_single - map a single region for DMA&n; * @hwdev: device to map for&n; * @ptr: kernel virtual address of the region to map&n; * @size: size of the region&n; * @direction: DMA direction&n; *&n; * Map the region pointed to by @ptr for DMA and return the&n; * DMA address.   Also known as platform_pci_map_single() by&n; * the IA64 machvec code.&n; *&n; * We map this to the one step pciio_dmamap_trans interface rather than&n; * the two step pciio_dmamap_alloc/pciio_dmamap_addr because we have&n; * no way of saving the dmamap handle from the alloc to later free&n; * (which is pretty much unacceptable).&n; *&n; * TODO: simplify our interface;&n; *       get rid of dev_desc and vhdl (seems redundant given a pci_dev);&n; *       figure out how to save dmamap handle so can use two step.&n; */
id|dma_addr_t
DECL|function|sn_pci_map_single
id|sn_pci_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|sn_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|pciio_dmamap_t
id|dma_map
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* SN cannot support DMA addresses smaller than 32 bits. */
r_if
c_cond
(paren
id|IS_PCI32L
c_func
(paren
id|hwdev
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * find vertex for the device&n;&t; */
id|device_sysdata
op_assign
(paren
r_struct
id|sn_device_sysdata
op_star
)paren
id|hwdev-&gt;sysdata
suffix:semicolon
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
multiline_comment|/*&n;&t; * Call our dmamap interface&n;&t; */
id|dma_addr
op_assign
l_int|0
suffix:semicolon
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIA64
c_func
(paren
id|hwdev
)paren
)paren
(brace
multiline_comment|/* This device supports 64 bit DMA addresses. */
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|size
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
op_or
id|PCIIO_DMA_A64
)paren
suffix:semicolon
r_return
id|dma_addr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Devices that support 32 bit to 63 bit DMA addresses get&n;&t; * 32 bit DMA addresses.&n;&t; *&n;&t; * First try to get a 32 bit direct map register.&n;&t; */
r_if
c_cond
(paren
id|IS_PCI32G
c_func
(paren
id|hwdev
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|size
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
id|dma_addr
op_assign
id|pciio_dmatrans_addr
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|phys_addr
comma
id|size
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
r_if
c_cond
(paren
id|dma_addr
)paren
r_return
id|dma_addr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It&squot;s a 32 bit card and we cannot do direct mapping so&n;&t; * let&squot;s use the PMU instead.&n;&t; */
id|dma_map
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_SGI_SN1
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|size
comma
id|PCIIO_BYTE_STREAM
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_IA64_SGI_SN2)
id|dma_map
op_assign
id|pciio_dmamap_alloc
c_func
(paren
id|vhdl
comma
l_int|NULL
comma
id|size
comma
(paren
(paren
id|IS_PIC_DEVICE
c_func
(paren
id|hwdev
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_BYTE_STREAM
)paren
op_or
id|PCIIO_DMA_DATA
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unsupported platform
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dma_map
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pci_map_single: Unable to allocate anymore &quot;
l_string|&quot;32 bit page map entries.&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|dma_addr
op_assign
(paren
id|dma_addr_t
)paren
id|pciio_dmamap_addr
c_func
(paren
id|dma_map
comma
id|phys_addr
comma
id|size
)paren
suffix:semicolon
id|sn_dma_map
op_assign
(paren
r_struct
id|sn_dma_maps_s
op_star
)paren
id|dma_map
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
id|dma_addr
suffix:semicolon
r_return
(paren
(paren
id|dma_addr_t
)paren
id|dma_addr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_unmap_single - unmap a region used for DMA&n; * @hwdev: device to unmap&n; * @dma_addr: DMA address to unmap&n; * @size: size of region&n; * @direction: DMA direction&n; *&n; * Unmaps the region pointed to by @dma_addr.  Also known as&n; * platform_pci_unmap_single() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_unmap_single
id|sn_pci_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|sn_dma_maps_s
op_star
id|sn_dma_map
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the sn_dma_map entry.&n;&t; */
r_if
c_cond
(paren
id|IS_PCI32_MAPPED
c_func
(paren
id|dma_addr
)paren
)paren
id|sn_dma_map
op_assign
id|find_sn_dma_map
c_func
(paren
id|dma_addr
comma
id|hwdev-&gt;bus-&gt;number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and free it if necessary...&n;&t; */
r_if
c_cond
(paren
id|sn_dma_map
)paren
(brace
id|pciio_dmamap_done
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|pciio_dmamap_free
c_func
(paren
(paren
id|pciio_dmamap_t
)paren
id|sn_dma_map
)paren
suffix:semicolon
id|sn_dma_map-&gt;dma_addr
op_assign
(paren
id|dma_addr_t
)paren
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * sn_pci_dma_sync_single - make sure all DMAs have completed&n; * @hwdev: device to sync&n; * @dma_handle: DMA address to sync&n; * @size: size of region&n; * @direction: DMA direction&n; *&n; * This routine is supposed to sync the DMA region specified&n; * by @dma_handle into the &squot;coherence domain&squot;.  See sn_dma_sync()&n; * above for more information.   Also known as&n; * platform_pci_dma_sync_single() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_dma_sync_single
id|sn_pci_dma_sync_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|sn_dma_sync
c_func
(paren
id|hwdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_dma_sync_sg - make sure all DMAs have completed&n; * @hwdev: device to sync&n; * @sg: scatterlist to sync&n; * @nents: number of entries in the scatterlist&n; * @direction: DMA direction&n; *&n; * This routine is supposed to sync the DMA regions specified&n; * by @sg into the &squot;coherence domain&squot;.  See sn_dma_sync()&n; * above for more information.   Also known as&n; * platform_pci_dma_sync_sg() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_dma_sync_sg
id|sn_pci_dma_sync_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|sn_dma_sync
c_func
(paren
id|hwdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_dma_address - get the DMA address for the first entry of a scatterlist&n; * @sg: sg to look at&n; *&n; * Gets the DMA address for the scatterlist @sg.  Also known as&n; * platform_dma_address() by the IA64 machvec code.&n; */
r_int
r_int
DECL|function|sn_dma_address
id|sn_dma_address
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;dma_address
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_dma_supported - test a DMA mask&n; * @hwdev: device to test&n; * @mask: DMA mask to test&n; *&n; * Return whether the given PCI device DMA address mask can be supported&n; * properly.  For example, if your device can only drive the low 24-bits&n; * during PCI bus mastering, then you would pass 0x00ffffff as the mask to&n; * this function.  Of course, SN only supports devices that have 32 or more&n; * address bits when using the PMU.  We could theoretically support &lt;32 bit&n; * cards using direct mapping, but we&squot;ll worry about that later--on the off&n; * chance that someone actually wants to use such a card.&n; */
r_int
DECL|function|sn_pci_dma_supported
id|sn_pci_dma_supported
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|u64
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OL
l_int|0xffffffff
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sn_pci_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_unmap_single
)paren
suffix:semicolon
DECL|variable|sn_pci_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_map_single
)paren
suffix:semicolon
DECL|variable|sn_pci_dma_sync_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_dma_sync_single
)paren
suffix:semicolon
DECL|variable|sn_pci_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_map_sg
)paren
suffix:semicolon
DECL|variable|sn_pci_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_unmap_sg
)paren
suffix:semicolon
DECL|variable|sn_pci_alloc_consistent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_alloc_consistent
)paren
suffix:semicolon
DECL|variable|sn_pci_free_consistent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_free_consistent
)paren
suffix:semicolon
DECL|variable|sn_dma_address
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_address
)paren
suffix:semicolon
DECL|variable|sn_pci_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_dma_supported
)paren
suffix:semicolon
eof
