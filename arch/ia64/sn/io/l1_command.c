multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 - 2001 Silicon Graphics, Inc.&n; * All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/router.h&gt;
macro_line|#include &lt;asm/sn/module.h&gt;
macro_line|#include &lt;asm/sn/ksys/l1.h&gt;
macro_line|#include &lt;asm/sn/nodepda.h&gt;
macro_line|#include &lt;asm/sn/clksupport.h&gt;
DECL|macro|ELSC_TIMEOUT
mdefine_line|#define ELSC_TIMEOUT&t;1000000&t;&t;/* ELSC response timeout (usec) */
DECL|macro|LOCK_TIMEOUT
mdefine_line|#define LOCK_TIMEOUT&t;5000000&t;&t;/* Hub lock timeout (usec) */
DECL|macro|LD
mdefine_line|#define LD(x)&t;&t;(*(volatile uint64_t *)(x))
DECL|macro|SD
mdefine_line|#define SD(x, v)&t;(LD(x) = (uint64_t) (v))
DECL|macro|hub_cpu_get
mdefine_line|#define hub_cpu_get()&t;0
DECL|macro|LBYTE
mdefine_line|#define LBYTE(caddr)&t;(*(char *) caddr)
r_extern
r_char
op_star
id|bcopy
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dest
comma
r_int
id|count
)paren
suffix:semicolon
DECL|macro|LDEBUG
mdefine_line|#define LDEBUG&t;&t;0
multiline_comment|/*&n; * ELSC data is in NVRAM page 7 at the following offsets.&n; */
DECL|macro|NVRAM_MAGIC_AD
mdefine_line|#define NVRAM_MAGIC_AD&t;0x700&t;&t;/* magic number used for init */
DECL|macro|NVRAM_PASS_WD
mdefine_line|#define NVRAM_PASS_WD&t;0x701&t;&t;/* password (4 bytes in length) */
DECL|macro|NVRAM_DBG1
mdefine_line|#define NVRAM_DBG1&t;0x705&t;&t;/* virtual XOR debug switches */
DECL|macro|NVRAM_DBG2
mdefine_line|#define NVRAM_DBG2&t;0x706&t;&t;/* physical XOR debug switches */
DECL|macro|NVRAM_CFG
mdefine_line|#define NVRAM_CFG&t;0x707&t;&t;/* ELSC Configuration info */
DECL|macro|NVRAM_MODULE
mdefine_line|#define NVRAM_MODULE&t;0x708&t;&t;/* system module number */
DECL|macro|NVRAM_BIST_FLG
mdefine_line|#define NVRAM_BIST_FLG&t;0x709&t;&t;/* BIST flags (2 bits per nodeboard) */
DECL|macro|NVRAM_PARTITION
mdefine_line|#define NVRAM_PARTITION 0x70a&t;&t;/* module&squot;s partition id */
DECL|macro|NVRAM_DOMAIN
mdefine_line|#define&t;NVRAM_DOMAIN&t;0x70b&t;&t;/* module&squot;s domain id */
DECL|macro|NVRAM_CLUSTER
mdefine_line|#define&t;NVRAM_CLUSTER&t;0x70c&t;&t;/* module&squot;s cluster id */
DECL|macro|NVRAM_CELL
mdefine_line|#define&t;NVRAM_CELL&t;0x70d&t;&t;/* module&squot;s cellid */
DECL|macro|NVRAM_MAGIC_NO
mdefine_line|#define NVRAM_MAGIC_NO&t;0x37&t;&t;/* value of magic number */
DECL|macro|NVRAM_SIZE
mdefine_line|#define NVRAM_SIZE&t;16&t;&t;/* 16 bytes in nvram */
multiline_comment|/*&n; * Declare a static ELSC NVRAM buffer to hold all data read from&n; * and written to NVRAM.  This nvram &quot;cache&quot; will be used only during the&n; * IP27prom execution.&n; */
DECL|variable|elsc_nvram_buffer
r_static
r_char
id|elsc_nvram_buffer
(braket
id|NVRAM_SIZE
)braket
suffix:semicolon
DECL|macro|SC_COMMAND
mdefine_line|#define SC_COMMAND sc_command
multiline_comment|/*&n; * elsc_init&n; *&n; *   Initialize ELSC structure&n; */
DECL|function|elsc_init
r_void
id|elsc_init
c_func
(paren
id|elsc_t
op_star
id|e
comma
id|nasid_t
id|nasid
)paren
(brace
id|sc_init
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|nasid
comma
id|BRL1_LOCALHUB_UART
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_errmsg&n; *&n; *   Given a negative error code,&n; *   returns a corresponding static error string.&n; */
DECL|function|elsc_errmsg
r_char
op_star
id|elsc_errmsg
c_func
(paren
r_int
id|code
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|ELSC_ERROR_CMD_SEND
suffix:colon
r_return
l_string|&quot;Command send error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_CMD_CHECKSUM
suffix:colon
r_return
l_string|&quot;Command packet checksum error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_CMD_UNKNOWN
suffix:colon
r_return
l_string|&quot;Unknown command&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_CMD_ARGS
suffix:colon
r_return
l_string|&quot;Invalid command argument(s)&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_CMD_PERM
suffix:colon
r_return
l_string|&quot;Permission denied&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_RESP_TIMEOUT
suffix:colon
r_return
l_string|&quot;System controller response timeout&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_RESP_CHECKSUM
suffix:colon
r_return
l_string|&quot;Response packet checksum error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_RESP_FORMAT
suffix:colon
r_return
l_string|&quot;Response format error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_RESP_DIR
suffix:colon
r_return
l_string|&quot;Response direction error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_MSG_LOST
suffix:colon
r_return
l_string|&quot;Message lost because queue is full&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_LOCK_TIMEOUT
suffix:colon
r_return
l_string|&quot;Timed out getting ELSC lock&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_DATA_SEND
suffix:colon
r_return
l_string|&quot;Error sending data&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_NIC
suffix:colon
r_return
l_string|&quot;NIC protocol error&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_NVMAGIC
suffix:colon
r_return
l_string|&quot;Bad magic number in NVRAM&quot;
suffix:semicolon
r_case
id|ELSC_ERROR_MODULE
suffix:colon
r_return
l_string|&quot;Module location protocol error&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;Unknown error&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * elsc_nvram_init&n; *&n; *   Initializes reads and writes to NVRAM.  This will perform a single&n; *   read to NVRAM, getting all data at once.  When the PROM tries to&n; *   read NVRAM, it returns the data from the buffer being read.  If the&n; *   PROM tries to write out to NVRAM, the write is done, and the internal&n; *   buffer is updated.&n; */
DECL|function|elsc_nvram_init
r_void
id|elsc_nvram_init
c_func
(paren
id|nasid_t
id|nasid
comma
id|uchar_t
op_star
id|elsc_nvram_data
)paren
(brace
multiline_comment|/* This might require implementation of multiple-packet request/responses&n;     * if it&squot;s to provide the same behavior that was available in SN0.&n;     */
id|nasid
op_assign
id|nasid
suffix:semicolon
id|elsc_nvram_data
op_assign
id|elsc_nvram_data
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_nvram_copy&n; *&n; *   Copies the content of a buffer into the static buffer in this library.&n; */
DECL|function|elsc_nvram_copy
r_void
id|elsc_nvram_copy
c_func
(paren
id|uchar_t
op_star
id|elsc_nvram_data
)paren
(brace
id|memcpy
c_func
(paren
id|elsc_nvram_buffer
comma
id|elsc_nvram_data
comma
id|NVRAM_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_nvram_write&n; *&n; *   Copies bytes from &squot;buf&squot; into NVRAM, starting at NVRAM address&n; *   &squot;addr&squot; which must be between 0 and 2047.&n; *&n; *   If &squot;len&squot; is non-negative, the routine copies &squot;len&squot; bytes.&n; *&n; *   If &squot;len&squot; is negative, the routine treats the data as a string and&n; *   copies bytes up to and including a NUL-terminating zero, but not&n; *   to exceed &squot;-len&squot; bytes.&n; */
DECL|function|elsc_nvram_write
r_int
id|elsc_nvram_write
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|addr
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
multiline_comment|/* Here again, we might need to work out the details of a&n;     * multiple-packet protocol.&n;     */
multiline_comment|/* For now, pretend it worked. */
id|e
op_assign
id|e
suffix:semicolon
id|addr
op_assign
id|addr
suffix:semicolon
id|buf
op_assign
id|buf
suffix:semicolon
r_return
(paren
id|len
OL
l_int|0
ques
c_cond
op_minus
id|len
suffix:colon
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_nvram_read&n; *&n; *   Copies bytes from NVRAM into &squot;buf&squot;, starting at NVRAM address&n; *   &squot;addr&squot; which must be between 0 and 2047.&n; *&n; *   If &squot;len&squot; is non-negative, the routine copies &squot;len&squot; bytes.&n; *&n; *   If &squot;len&squot; is negative, the routine treats the data as a string and&n; *   copies bytes up to and including a NUL-terminating zero, but not&n; *   to exceed &squot;-len&squot; bytes.  NOTE:  This method is no longer supported.&n; *   It was never used in the first place.&n; */
DECL|function|elsc_nvram_read
r_int
id|elsc_nvram_read
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|addr
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
multiline_comment|/* multiple packets? */
id|e
op_assign
id|e
suffix:semicolon
id|addr
op_assign
id|addr
suffix:semicolon
id|buf
op_assign
id|buf
suffix:semicolon
id|len
op_assign
id|len
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Command Set&n; */
DECL|function|elsc_version
r_int
id|elsc_version
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_char
op_star
id|result
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|major
comma
multiline_comment|/* major rev number */
id|minor
comma
multiline_comment|/* minor rev number */
id|bugfix
suffix:semicolon
multiline_comment|/* bugfix rev number */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_FW_REV
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|6
comma
id|L1_ARG_INT
comma
op_amp
id|major
comma
id|L1_ARG_INT
comma
op_amp
id|minor
comma
id|L1_ARG_INT
comma
op_amp
id|bugfix
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|result
comma
l_string|&quot;%d.%d.%d&quot;
comma
id|major
comma
id|minor
comma
id|bugfix
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_debug_set
r_int
id|elsc_debug_set
c_func
(paren
id|elsc_t
op_star
id|e
comma
id|u_char
id|byte1
comma
id|u_char
id|byte2
)paren
(brace
multiline_comment|/* shush compiler */
id|e
op_assign
id|e
suffix:semicolon
id|byte1
op_assign
id|byte1
suffix:semicolon
id|byte2
op_assign
id|byte2
suffix:semicolon
multiline_comment|/* fill in a buffer with the opcode &amp; params; call sc_command */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_debug_get
r_int
id|elsc_debug_get
c_func
(paren
id|elsc_t
op_star
id|e
comma
id|u_char
op_star
id|byte1
comma
id|u_char
op_star
id|byte2
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|dbg_sw
suffix:semicolon
multiline_comment|/* holds debug switch settings */
r_int
id|len
suffix:semicolon
multiline_comment|/* number of msg buffer bytes used */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_RDBG
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_INT
comma
op_amp
id|dbg_sw
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
multiline_comment|/* copy out debug switch settings (last two bytes of the&n;     * integer response)&n;     */
op_star
id|byte1
op_assign
(paren
(paren
id|dbg_sw
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
op_star
id|byte2
op_assign
(paren
id|dbg_sw
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_rack_bay_get fills in the two int * arguments with the&n; * rack number and bay number of the L1 being addressed&n; */
DECL|function|elsc_rack_bay_get
r_int
id|elsc_rack_bay_get
c_func
(paren
id|elsc_t
op_star
id|e
comma
id|uint
op_star
id|rack
comma
id|uint
op_star
id|bay
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
r_uint32
id|buf32
suffix:semicolon
multiline_comment|/* used to copy 32-bit rack/bay out of msg */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_RRACK
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_INT
comma
op_amp
id|buf32
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
multiline_comment|/* extract rack/bay info&n;     *&n;     * note that the 32-bit value returned by the L1 actually&n;     * only uses the low-order sixteen bits for rack and bay&n;     * information.  A &quot;normal&quot; L1 address puts rack and bay&n;     * information in bit positions 12 through 28.  So if&n;     * we initially shift the value returned 12 bits to the left,&n;     * we can use the L1 addressing #define&squot;s to extract the&n;     * values we need (see ksys/l1.h for a complete list of the&n;     * various fields of an L1 address).&n;     */
id|buf32
op_lshift_assign
id|L1_ADDR_BAY_SHFT
suffix:semicolon
op_star
id|rack
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_RACK_MASK
)paren
op_rshift
id|L1_ADDR_RACK_SHFT
suffix:semicolon
op_star
id|bay
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_BAY_MASK
)paren
op_rshift
id|L1_ADDR_BAY_SHFT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* elsc_rack_bay_type_get fills in the three int * arguments with the&n; * rack number, bay number and brick type of the L1 being addressed.  Note&n; * that if the L1 operation fails and this function returns an error value, &n; * garbage may be written to brick_type.&n; */
DECL|function|elsc_rack_bay_type_get
r_int
id|elsc_rack_bay_type_get
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|uint
op_star
id|rack
comma
id|uint
op_star
id|bay
comma
id|uint
op_star
id|brick_type
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
r_uint32
id|buf32
suffix:semicolon
multiline_comment|/* used to copy 32-bit rack &amp; bay out of msg */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_RRBT
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|4
comma
id|L1_ARG_INT
comma
op_amp
id|buf32
comma
id|L1_ARG_INT
comma
id|brick_type
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
multiline_comment|/* extract rack/bay info&n;     *&n;     * note that the 32-bit value returned by the L1 actually&n;     * only uses the low-order sixteen bits for rack and bay&n;     * information.  A &quot;normal&quot; L1 address puts rack and bay&n;     * information in bit positions 12 through 28.  So if&n;     * we initially shift the value returned 12 bits to the left,&n;     * we can use the L1 addressing #define&squot;s to extract the&n;     * values we need (see ksys/l1.h for a complete list of the&n;     * various fields of an L1 address).&n;     */
id|buf32
op_lshift_assign
id|L1_ADDR_BAY_SHFT
suffix:semicolon
op_star
id|rack
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_RACK_MASK
)paren
op_rshift
id|L1_ADDR_RACK_SHFT
suffix:semicolon
op_star
id|bay
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_BAY_MASK
)paren
op_rshift
id|L1_ADDR_BAY_SHFT
suffix:semicolon
multiline_comment|/* convert brick_type to lower case */
op_star
id|brick_type
op_assign
op_star
id|brick_type
op_minus
l_char|&squot;A&squot;
op_plus
l_char|&squot;a&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_module_get
r_int
id|elsc_module_get
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
r_extern
r_char
id|brick_types
(braket
)braket
suffix:semicolon
id|uint
id|rnum
comma
id|rack
comma
id|bay
comma
id|bricktype
comma
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* construct module ID from rack and slot info */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|elsc_rack_bay_type_get
c_func
(paren
id|e
comma
op_amp
id|rnum
comma
op_amp
id|bay
comma
op_amp
id|bricktype
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* report unset location info. with a special, otherwise invalid modid */
r_if
c_cond
(paren
id|rnum
op_eq
l_int|0
op_logical_and
id|bay
op_eq
l_int|0
)paren
r_return
id|MODULE_NOT_SET
suffix:semicolon
r_if
c_cond
(paren
id|bay
OG
id|MODULE_BPOS_MASK
op_rshift
id|MODULE_BPOS_SHFT
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
multiline_comment|/* Build a moduleid_t-compatible rack number */
id|rack
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|100
suffix:semicolon
multiline_comment|/* rack class (CPU/IO) */
r_if
c_cond
(paren
id|t
OG
id|RACK_CLASS_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_CLASS_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_CLASS
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|rnum
op_mod_assign
l_int|100
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|10
suffix:semicolon
multiline_comment|/* rack group */
r_if
c_cond
(paren
id|t
OG
id|RACK_GROUP_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_GROUP_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_GROUP
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|t
op_assign
id|rnum
op_mod
l_int|10
suffix:semicolon
multiline_comment|/* rack number (one-based) */
r_if
c_cond
(paren
id|t
op_minus
l_int|1
OG
id|RACK_NUM_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_NUM_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_NUM
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_BRICK_TYPES
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
id|brick_types
(braket
id|t
)braket
op_eq
id|bricktype
)paren
(brace
r_return
id|RBT_TO_MODULE
c_func
(paren
id|rack
comma
id|bay
comma
id|t
)paren
suffix:semicolon
)brace
)brace
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
)brace
DECL|function|elsc_partition_set
r_int
id|elsc_partition_set
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|partition
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_PARTITION_SET
comma
l_int|2
comma
id|L1_ARG_INT
comma
id|partition
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_partition_get
r_int
id|elsc_partition_get
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
r_uint32
id|partition_id
suffix:semicolon
multiline_comment|/* used to copy partition id out of msg */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_PARTITION_GET
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_INT
comma
op_amp
id|partition_id
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
id|partition_id
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_cons_subch selects the &quot;active&quot; console subchannel for this node&n; * (i.e., the one that will currently receive input)&n; */
DECL|function|elsc_cons_subch
r_int
id|elsc_cons_subch
c_func
(paren
id|elsc_t
op_star
id|e
comma
id|uint
id|ch
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_CONS_SUBCH
comma
l_int|2
comma
id|L1_ARG_INT
comma
id|ch
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_cons_node should only be executed by one node.  It declares to&n; * the system controller that the node from which it is called will be&n; * the owner of the system console.&n; */
DECL|function|elsc_cons_node
r_int
id|elsc_cons_node
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_CONS_NODE
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* elsc_display_line writes up to 12 characters to either the top or bottom&n; * line of the L1 display.  line points to a buffer containing the message&n; * to be displayed.  The zero-based line number is specified by lnum (so&n; * lnum == 0 specifies the top line and lnum == 1 specifies the bottom).&n; * Lines longer than 12 characters, or line numbers not less than&n; * L1_DISPLAY_LINES, cause elsc_display_line to return an error.&n; */
DECL|function|elsc_display_line
r_int
id|elsc_display_line
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_char
op_star
id|line
comma
r_int
id|lnum
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* number of msg buffer bytes used */
multiline_comment|/* argument sanity checking */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lnum
OL
id|L1_DISPLAY_LINES
)paren
)paren
(brace
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|strlen
c_func
(paren
id|line
)paren
op_le
id|L1_DISPLAY_LINE_LENGTH
)paren
)paren
(brace
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
(paren
id|L1_REQ_DISP1
op_plus
id|lnum
)paren
comma
l_int|2
comma
id|L1_ARG_ASCII
comma
id|line
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
(paren
id|l1sc_t
op_star
)paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* elsc_display_mesg silently drops message characters beyond the 12th.&n; */
DECL|function|elsc_display_mesg
r_int
id|elsc_display_mesg
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_char
op_star
id|chr
)paren
(brace
r_char
id|line
(braket
id|L1_DISPLAY_LINE_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|numlines
comma
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
id|numlines
op_assign
(paren
id|strlen
c_func
(paren
id|chr
)paren
op_plus
id|L1_DISPLAY_LINE_LENGTH
op_minus
l_int|1
)paren
op_div
id|L1_DISPLAY_LINE_LENGTH
suffix:semicolon
r_if
c_cond
(paren
id|numlines
OG
id|L1_DISPLAY_LINES
)paren
(brace
id|numlines
op_assign
id|L1_DISPLAY_LINES
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numlines
suffix:semicolon
id|i
op_increment
)paren
(brace
id|strncpy
c_func
(paren
id|line
comma
id|chr
comma
id|L1_DISPLAY_LINE_LENGTH
)paren
suffix:semicolon
id|line
(braket
id|L1_DISPLAY_LINE_LENGTH
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* generally we want to leave the first line of the L1 display&n;&t; * alone (so the L1 can manipulate it).  If you need to be able&n;&t; * to display to both lines (for debugging purposes), define&n;&t; * L1_DISP_2LINES in irix/kern/ksys/l1.h, or add -DL1_DISP_2LINES&n;&t; * to your &squot;defs file.&n;&t; */
macro_line|#if defined(L1_DISP_2LINES)
r_if
c_cond
(paren
(paren
id|result
op_assign
id|elsc_display_line
c_func
(paren
id|e
comma
id|line
comma
id|i
)paren
)paren
OL
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|result
op_assign
id|elsc_display_line
c_func
(paren
id|e
comma
id|line
comma
id|i
op_plus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
macro_line|#endif
r_return
id|result
suffix:semicolon
)brace
id|chr
op_add_assign
id|L1_DISPLAY_LINE_LENGTH
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_password_set
r_int
id|elsc_password_set
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_char
op_star
id|password
)paren
(brace
multiline_comment|/* shush compiler */
id|e
op_assign
id|e
suffix:semicolon
id|password
op_assign
id|password
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_password_get
r_int
id|elsc_password_get
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_char
op_star
id|password
)paren
(brace
multiline_comment|/* shush compiler */
id|e
op_assign
id|e
suffix:semicolon
id|password
op_assign
id|password
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sc_portspeed_get&n; *&n; * retrieve the current portspeed setting for the bedrock II&n; */
DECL|function|sc_portspeed_get
r_int
id|sc_portspeed_get
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|portspeed_a
comma
id|portspeed_b
suffix:semicolon
multiline_comment|/* ioport clock rates */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_PORTSPEED
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|4
comma
id|L1_ARG_INT
comma
op_amp
id|portspeed_a
comma
id|L1_ARG_INT
comma
op_amp
id|portspeed_b
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
multiline_comment|/* for the c-brick, we ignore the portspeed_b value */
r_return
(paren
id|portspeed_a
ques
c_cond
l_int|600
suffix:colon
l_int|400
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_power_query&n; *&n; *   To be used after system reset, this command returns 1 if the reset&n; *   was the result of a power-on, 0 otherwise.&n; *&n; *   The power query status is cleared to 0 after it is read.&n; */
DECL|function|elsc_power_query
r_int
id|elsc_power_query
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
id|e
op_assign
id|e
suffix:semicolon
multiline_comment|/* shush the compiler */
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|elsc_rpwr_query
r_int
id|elsc_rpwr_query
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|is_master
)paren
(brace
multiline_comment|/* shush the compiler */
id|e
op_assign
id|e
suffix:semicolon
id|is_master
op_assign
id|is_master
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * elsc_power_down&n; *&n; *   Sets up system to shut down in &quot;sec&quot; seconds (or modifies the&n; *   shutdown time if one is already in effect).  Use 0 to power&n; *   down immediately.&n; */
DECL|function|elsc_power_down
r_int
id|elsc_power_down
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|sec
)paren
(brace
multiline_comment|/* shush compiler */
id|e
op_assign
id|e
suffix:semicolon
id|sec
op_assign
id|sec
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_system_reset
r_int
id|elsc_system_reset
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* number of msg buffer bytes used */
r_int
id|result
suffix:semicolon
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|e
comma
id|L1_ADDR_LOCAL
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_RESET
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|sc_command
c_func
(paren
id|e
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|SC_NMSG
)paren
(brace
multiline_comment|/* timeout is OK.  We&squot;ve sent the reset.  Now it&squot;s just&n;&t;     * a matter of time...&n;&t;     */
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|e
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|elsc_power_cycle
r_int
id|elsc_power_cycle
c_func
(paren
id|elsc_t
op_star
id|e
)paren
(brace
multiline_comment|/* shush compiler */
id|e
op_assign
id|e
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call sc_command */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * L1 Support for reading &n; * cbrick uid.&n; */
DECL|function|elsc_nic_get
r_int
id|elsc_nic_get
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_uint64
op_star
id|nic
comma
r_int
id|verbose
)paren
(brace
multiline_comment|/* this parameter included only for SN0 compatibility */
id|verbose
op_assign
id|verbose
suffix:semicolon
multiline_comment|/* We don&squot;t go straight to the bedrock/L1 protocol on this one, but let&n;     * the eeprom layer prepare the eeprom data as we would like it to&n;     * appear to the caller&n;     */
r_return
id|cbrick_uid_get
c_func
(paren
id|e-&gt;nasid
comma
id|nic
)paren
suffix:semicolon
)brace
DECL|function|_elsc_hbt
r_int
id|_elsc_hbt
c_func
(paren
id|elsc_t
op_star
id|e
comma
r_int
id|ival
comma
r_int
id|rdly
)paren
(brace
id|e
op_assign
id|e
suffix:semicolon
id|ival
op_assign
id|ival
suffix:semicolon
id|rdly
op_assign
id|rdly
suffix:semicolon
multiline_comment|/* fill in buffer with the opcode &amp; params; call elsc_command */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* send a command string to an L1 */
DECL|function|sc_command_interp
r_int
id|sc_command_interp
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|l1addr_t
id|compt
comma
id|l1addr_t
id|rack
comma
id|l1addr_t
id|bay
comma
r_char
op_star
id|cmd
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
id|l1addr_t
id|target
suffix:semicolon
multiline_comment|/* target system controller for command */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|L1_BUILD_ADDR
c_func
(paren
op_amp
id|target
comma
id|compt
comma
id|rack
comma
id|bay
comma
l_int|0
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_CMD
comma
id|L1_REQ_EXEC_CMD
comma
l_int|2
comma
id|L1_ARG_ASCII
comma
id|cmd
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sc_power_down&n; *&n; * Shuts down the c-brick associated with sc, and any attached I/O bricks&n; * or other c-bricks (won&squot;t go through r-bricks).&n; */
DECL|function|sc_power_down
r_int
id|sc_power_down
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_return
id|sc_command_interp
c_func
(paren
id|sc
comma
id|L1_ADDR_TYPE_L1
comma
id|L1_ADDR_RACK_LOCAL
comma
id|L1_ADDR_BAY_LOCAL
comma
l_string|&quot;* pwr d&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sc_power_down_all&n; *&n; * Works similarly to sc_power_down, except that the request is sent to the&n; * closest L2 and EVERYBODY gets turned off.&n; */
DECL|function|sc_power_down_all
r_int
id|sc_power_down_all
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
r_if
c_cond
(paren
id|nodepda-&gt;num_routers
OG
l_int|0
)paren
(brace
r_return
id|sc_command_interp
c_func
(paren
id|sc
comma
id|L1_ADDR_TYPE_L2
comma
id|L1_ADDR_RACK_LOCAL
comma
id|L1_ADDR_BAY_LOCAL
comma
l_string|&quot;* pwr d&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|sc_power_down
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Routines for reading the R-brick&squot;s L1&n; */
DECL|function|router_module_get
r_int
id|router_module_get
c_func
(paren
id|nasid_t
id|nasid
comma
id|net_vec_t
id|path
)paren
(brace
id|uint
id|rnum
comma
id|rack
comma
id|bay
comma
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|l1sc_t
id|sc
suffix:semicolon
multiline_comment|/* prepare l1sc_t struct */
id|sc_init
c_func
(paren
op_amp
id|sc
comma
id|nasid
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* construct module ID from rack and slot info */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|elsc_rack_bay_get
c_func
(paren
op_amp
id|sc
comma
op_amp
id|rnum
comma
op_amp
id|bay
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* report unset location info. with a special, otherwise invalid modid */
r_if
c_cond
(paren
id|rnum
op_eq
l_int|0
op_logical_and
id|bay
op_eq
l_int|0
)paren
r_return
id|MODULE_NOT_SET
suffix:semicolon
r_if
c_cond
(paren
id|bay
OG
id|MODULE_BPOS_MASK
op_rshift
id|MODULE_BPOS_SHFT
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
multiline_comment|/* Build a moduleid_t-compatible rack number */
id|rack
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|100
suffix:semicolon
multiline_comment|/* rack class (CPU/IO) */
r_if
c_cond
(paren
id|t
OG
id|RACK_CLASS_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_CLASS_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_CLASS
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|rnum
op_mod_assign
l_int|100
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|10
suffix:semicolon
multiline_comment|/* rack group */
r_if
c_cond
(paren
id|t
OG
id|RACK_GROUP_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_GROUP_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_GROUP
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|t
op_assign
id|rnum
op_mod
l_int|10
suffix:semicolon
multiline_comment|/* rack number (one-based) */
r_if
c_cond
(paren
id|t
op_minus
l_int|1
OG
id|RACK_NUM_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_NUM_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_NUM
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|ret
op_assign
id|RBT_TO_MODULE
c_func
(paren
id|rack
comma
id|bay
comma
id|MODULE_RBRICK
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * iobrick routines&n; */
multiline_comment|/* iobrick_rack_bay_type_get fills in the three int * arguments with the&n; * rack number, bay number and brick type of the L1 being addressed.  Note&n; * that if the L1 operation fails and this function returns an error value, &n; * garbage may be written to brick_type.&n; */
DECL|function|iobrick_rack_bay_type_get
r_int
id|iobrick_rack_bay_type_get
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
id|uint
op_star
id|rack
comma
id|uint
op_star
id|bay
comma
id|uint
op_star
id|brick_type
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
r_uint32
id|buf32
suffix:semicolon
multiline_comment|/* used to copy 32-bit rack &amp; bay out of msg */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCALIO
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_RRBT
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|4
comma
id|L1_ARG_INT
comma
op_amp
id|buf32
comma
id|L1_ARG_INT
comma
id|brick_type
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
multiline_comment|/* extract rack/bay info&n;     *&n;     * note that the 32-bit value returned by the L1 actually&n;     * only uses the low-order sixteen bits for rack and bay&n;     * information.  A &quot;normal&quot; L1 address puts rack and bay&n;     * information in bit positions 12 through 28.  So if&n;     * we initially shift the value returned 12 bits to the left,&n;     * we can use the L1 addressing #define&squot;s to extract the&n;     * values we need (see ksys/l1.h for a complete list of the&n;     * various fields of an L1 address).&n;     */
id|buf32
op_lshift_assign
id|L1_ADDR_BAY_SHFT
suffix:semicolon
op_star
id|rack
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_RACK_MASK
)paren
op_rshift
id|L1_ADDR_RACK_SHFT
suffix:semicolon
op_star
id|bay
op_assign
(paren
id|buf32
op_amp
id|L1_ADDR_BAY_MASK
)paren
op_rshift
id|L1_ADDR_BAY_SHFT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|iobrick_module_get
r_int
id|iobrick_module_get
c_func
(paren
id|l1sc_t
op_star
id|sc
)paren
(brace
id|uint
id|rnum
comma
id|rack
comma
id|bay
comma
id|brick_type
comma
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* construct module ID from rack and slot info */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|iobrick_rack_bay_type_get
c_func
(paren
id|sc
comma
op_amp
id|rnum
comma
op_amp
id|bay
comma
op_amp
id|brick_type
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|bay
OG
id|MODULE_BPOS_MASK
op_rshift
id|MODULE_BPOS_SHFT
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
multiline_comment|/* Build a moduleid_t-compatible rack number */
id|rack
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|100
suffix:semicolon
multiline_comment|/* rack class (CPU/IO) */
r_if
c_cond
(paren
id|t
OG
id|RACK_CLASS_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_CLASS_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_CLASS
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|rnum
op_mod_assign
l_int|100
suffix:semicolon
id|t
op_assign
id|rnum
op_div
l_int|10
suffix:semicolon
multiline_comment|/* rack group */
r_if
c_cond
(paren
id|t
OG
id|RACK_GROUP_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_GROUP_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_GROUP
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
id|t
op_assign
id|rnum
op_mod
l_int|10
suffix:semicolon
multiline_comment|/* rack number (one-based) */
r_if
c_cond
(paren
id|t
op_minus
l_int|1
OG
id|RACK_NUM_MASK
c_func
(paren
id|rack
)paren
op_rshift
id|RACK_NUM_SHFT
c_func
(paren
id|rack
)paren
)paren
r_return
id|ELSC_ERROR_MODULE
suffix:semicolon
id|RACK_ADD_NUM
c_func
(paren
id|rack
comma
id|t
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|brick_type
)paren
(brace
r_case
l_char|&squot;I&squot;
suffix:colon
id|brick_type
op_assign
id|MODULE_IBRICK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
id|brick_type
op_assign
id|MODULE_PBRICK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
id|brick_type
op_assign
id|MODULE_XBRICK
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|RBT_TO_MODULE
c_func
(paren
id|rack
comma
id|bay
comma
id|brick_type
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* iobrick_get_sys_snum asks the attached iobrick for the system&n; * serial number.  This function will only be relevant to the master&n; * cbrick (the one attached to the bootmaster ibrick); other nodes&n; * may call the function, but the value returned to the master node&n; * will be the one used as the system serial number by the kernel.&n; */
r_int
DECL|function|iobrick_get_sys_snum
id|iobrick_get_sys_snum
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_char
op_star
id|snum_str
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
multiline_comment|/* L1 request/response info */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCALIO
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_SYS_SERIAL
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|sc_command
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_return
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|2
comma
id|L1_ARG_ASCII
comma
id|snum_str
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following functions apply (or cut off) power to the specified&n; * pci bus or slot.&n; */
r_int
DECL|function|iobrick_pci_pwr
id|iobrick_pci_pwr
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|bus
comma
r_int
id|slot
comma
r_int
id|req_code
)paren
(brace
macro_line|#if 0 /* The &quot;bedrock request&quot; method of performing this function&n;       * seems to be broken in the L1, so for now use the command-&n;       * interpreter method&n;       */
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCALIO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|req_code
comma
l_int|4
comma
id|L1_ARG_INT
comma
id|bus
comma
id|L1_ARG_INT
comma
id|slot
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_char
id|cmd
(braket
l_int|64
)braket
suffix:semicolon
r_char
op_star
id|fxn
suffix:semicolon
r_switch
c_cond
(paren
id|req_code
)paren
(brace
r_case
id|L1_REQ_PCI_UP
suffix:colon
id|fxn
op_assign
l_string|&quot;u&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L1_REQ_PCI_DOWN
suffix:colon
id|fxn
op_assign
l_string|&quot;d&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L1_REQ_PCI_RESET
suffix:colon
id|fxn
op_assign
l_string|&quot;rst&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slot
op_eq
op_minus
l_int|1
)paren
(brace
id|sprintf
c_func
(paren
id|cmd
comma
l_string|&quot;pci %d %s&quot;
comma
id|bus
comma
id|fxn
)paren
suffix:semicolon
)brace
r_else
id|sprintf
c_func
(paren
id|cmd
comma
l_string|&quot;pci %d %d %s&quot;
comma
id|bus
comma
id|slot
comma
id|fxn
)paren
suffix:semicolon
r_return
id|sc_command_interp
c_func
(paren
id|sc
comma
id|L1_ADDR_TYPE_IOBRICK
comma
id|L1_ADDR_RACK_LOCAL
comma
id|L1_ADDR_BAY_LOCAL
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|iobrick_pci_slot_pwr
id|iobrick_pci_slot_pwr
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|bus
comma
r_int
id|slot
comma
r_int
id|up
)paren
(brace
r_return
id|iobrick_pci_pwr
c_func
(paren
id|sc
comma
id|bus
comma
id|slot
comma
id|up
)paren
suffix:semicolon
)brace
r_int
DECL|function|iobrick_pci_bus_pwr
id|iobrick_pci_bus_pwr
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|bus
comma
r_int
id|up
)paren
(brace
r_return
id|iobrick_pci_pwr
c_func
(paren
id|sc
comma
id|bus
comma
op_minus
l_int|1
comma
id|up
)paren
suffix:semicolon
)brace
r_int
DECL|function|iobrick_pci_slot_rst
id|iobrick_pci_slot_rst
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|bus
comma
r_int
id|slot
)paren
(brace
r_return
id|iobrick_pci_pwr
c_func
(paren
id|sc
comma
id|bus
comma
id|slot
comma
id|L1_REQ_PCI_RESET
)paren
suffix:semicolon
)brace
r_int
DECL|function|iobrick_pci_bus_rst
id|iobrick_pci_bus_rst
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_int
id|bus
)paren
(brace
r_return
id|iobrick_pci_pwr
c_func
(paren
id|sc
comma
id|bus
comma
op_minus
l_int|1
comma
id|L1_REQ_PCI_RESET
)paren
suffix:semicolon
)brace
multiline_comment|/* get the L1 firmware version for an iobrick */
r_int
DECL|function|iobrick_sc_version
id|iobrick_sc_version
c_func
(paren
id|l1sc_t
op_star
id|sc
comma
r_char
op_star
id|result
)paren
(brace
r_char
id|msg
(braket
id|BRL1_QSIZE
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* length of message being sent */
r_int
id|subch
suffix:semicolon
multiline_comment|/* system controller subchannel used */
r_int
id|major
comma
multiline_comment|/* major rev number */
id|minor
comma
multiline_comment|/* minor rev number */
id|bugfix
suffix:semicolon
multiline_comment|/* bugfix rev number */
multiline_comment|/* fill in msg with the opcode &amp; params */
id|bzero
c_func
(paren
id|msg
comma
id|BRL1_QSIZE
)paren
suffix:semicolon
id|subch
op_assign
id|sc_open
c_func
(paren
id|sc
comma
id|L1_ADDR_LOCALIO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|sc_construct_msg
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|BRL1_QSIZE
comma
id|L1_ADDR_TASK_GENERAL
comma
id|L1_REQ_FW_REV
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_ARGS
suffix:semicolon
)brace
multiline_comment|/* send the request to the L1 */
r_if
c_cond
(paren
id|SC_COMMAND
c_func
(paren
id|sc
comma
id|subch
comma
id|msg
comma
id|msg
comma
op_amp
id|len
)paren
OL
l_int|0
)paren
(brace
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
r_return
id|ELSC_ERROR_CMD_SEND
suffix:semicolon
)brace
multiline_comment|/* free up subchannel */
id|sc_close
c_func
(paren
id|sc
comma
id|subch
)paren
suffix:semicolon
multiline_comment|/* check response */
r_if
c_cond
(paren
id|sc_interpret_resp
c_func
(paren
id|msg
comma
l_int|6
comma
id|L1_ARG_INT
comma
op_amp
id|major
comma
id|L1_ARG_INT
comma
op_amp
id|minor
comma
id|L1_ARG_INT
comma
op_amp
id|bugfix
)paren
OL
l_int|0
)paren
(brace
r_return
id|ELSC_ERROR_RESP_FORMAT
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|result
comma
l_string|&quot;%d.%d.%d&quot;
comma
id|major
comma
id|minor
comma
id|bugfix
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
