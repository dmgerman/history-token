multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2001 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/hack.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk_private.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
multiline_comment|/* #define DEBUG&t;&t;1 */
multiline_comment|/* #define XBOW_DEBUG&t;1 */
multiline_comment|/*&n; * Files needed to get the device driver entry points&n; */
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xswitch.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
DECL|macro|NEW
mdefine_line|#define NEW(ptr)&t;(ptr = kmalloc(sizeof (*(ptr)), GFP_KERNEL))
DECL|macro|DEL
mdefine_line|#define DEL(ptr)&t;(kfree(ptr))
DECL|variable|xbow_devflag
r_int
id|xbow_devflag
op_assign
id|D_MP
suffix:semicolon
multiline_comment|/*&n; * This file supports the Xbow chip.  Main functions: initializtion,&n; * error handling, and GBR.&n; */
multiline_comment|/*&n; * each vertex corresponding to an xbow chip&n; * has a &quot;fastinfo&quot; pointer pointing at one&n; * of these things.&n; */
DECL|typedef|xbow_soft_t
r_typedef
r_struct
id|xbow_soft_s
op_star
id|xbow_soft_t
suffix:semicolon
DECL|struct|xbow_soft_s
r_struct
id|xbow_soft_s
(brace
DECL|member|conn
id|devfs_handle_t
id|conn
suffix:semicolon
multiline_comment|/* our connection point */
DECL|member|vhdl
id|devfs_handle_t
id|vhdl
suffix:semicolon
multiline_comment|/* xbow&squot;s private vertex */
DECL|member|busv
id|devfs_handle_t
id|busv
suffix:semicolon
multiline_comment|/* the xswitch vertex */
DECL|member|base
id|xbow_t
op_star
id|base
suffix:semicolon
multiline_comment|/* PIO pointer to crossbow chip */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* hwgraph name */
DECL|member|xbow_perfcnt
id|xbow_perf_t
id|xbow_perfcnt
(braket
id|XBOW_PERF_COUNTERS
)braket
suffix:semicolon
DECL|member|xbow_perflink
id|xbow_perf_link_t
id|xbow_perflink
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
DECL|member|xbow_link_status
id|xbow_link_status_t
id|xbow_link_status
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
DECL|member|xbow_perf_lock
id|spinlock_t
id|xbow_perf_lock
suffix:semicolon
DECL|member|link_monitor
r_int
id|link_monitor
suffix:semicolon
DECL|member|wpio
id|widget_cfg_t
op_star
id|wpio
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* cached PIO pointer */
multiline_comment|/* Bandwidth allocation state. Bandwidth values are for the&n;     * destination port since contention happens there.&n;     * Implicit mapping from xbow ports (8..f) -&gt; (0..7) array indices.&n;     */
DECL|member|xbow_bw_alloc_lock
id|spinlock_t
id|xbow_bw_alloc_lock
suffix:semicolon
multiline_comment|/* bw allocation lock */
DECL|member|bw_hiwm
r_int
r_int
r_int
id|bw_hiwm
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* hiwater mark values */
DECL|member|bw_cur_used
r_int
r_int
r_int
id|bw_cur_used
(braket
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
multiline_comment|/* bw used currently */
)brace
suffix:semicolon
DECL|macro|xbow_soft_set
mdefine_line|#define xbow_soft_set(v,i)&t;hwgraph_fastinfo_set((v), (arbitrary_info_t)(i))
DECL|macro|xbow_soft_get
mdefine_line|#define xbow_soft_get(v)&t;((xbow_soft_t)hwgraph_fastinfo_get((v)))
multiline_comment|/*&n; * Function Table of Contents&n; */
r_void
id|xbow_mlreset
c_func
(paren
id|xbow_t
op_star
)paren
suffix:semicolon
r_void
id|xbow_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|xbow_attach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xbow_open
c_func
(paren
id|devfs_handle_t
op_star
comma
r_int
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|xbow_close
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|xbow_map
c_func
(paren
id|devfs_handle_t
comma
id|vhandl_t
op_star
comma
id|off_t
comma
r_int
comma
id|uint
)paren
suffix:semicolon
r_int
id|xbow_unmap
c_func
(paren
id|devfs_handle_t
comma
id|vhandl_t
op_star
)paren
suffix:semicolon
r_int
id|xbow_ioctl
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_void
op_star
comma
r_int
comma
r_struct
id|cred
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|xbow_widget_present
c_func
(paren
id|xbow_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|xbow_link_alive
c_func
(paren
id|xbow_t
op_star
comma
r_int
)paren
suffix:semicolon
id|devfs_handle_t
id|xbow_widget_lookup
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef LATER
r_static
r_void
id|xbow_setwidint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_static
r_void
id|xbow_errintr_handler
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
macro_line|#endif
r_void
id|xbow_intr_preset
c_func
(paren
r_void
op_star
comma
r_int
comma
id|xwidgetnum_t
comma
id|iopaddr_t
comma
id|xtalk_intr_vector_t
)paren
suffix:semicolon
r_void
id|xbow_update_perf_counters
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_get_perf_counters
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xbow_enable_perf_counter
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_get_llp_status
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|xbow_update_llp_status
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xbow_disable_llp_monitor
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xbow_enable_llp_monitor
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|xbow_prio_bw_alloc
c_func
(paren
id|devfs_handle_t
comma
id|xwidgetnum_t
comma
id|xwidgetnum_t
comma
r_int
r_int
r_int
comma
r_int
r_int
r_int
)paren
suffix:semicolon
DECL|variable|xbow_reset_link
id|xswitch_reset_link_f
id|xbow_reset_link
suffix:semicolon
r_void
id|idbg_xbowregs
c_func
(paren
r_int64
)paren
suffix:semicolon
DECL|variable|xbow_provider
id|xswitch_provider_t
id|xbow_provider
op_assign
(brace
id|xbow_reset_link
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *    xbow_mlreset: called at mlreset time if the&n; *      platform specific code determines that there is&n; *      a crossbow in a critical path that must be&n; *      functional before the driver would normally get&n; *      the device properly set up.&n; *&n; *      what do we need to do, that the boot prom can&n; *      not be counted on to have already done, that is&n; *      generic across all platforms using crossbows?&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|xbow_mlreset
id|xbow_mlreset
c_func
(paren
id|xbow_t
op_star
id|xbow
)paren
(brace
)brace
multiline_comment|/*&n; *    xbow_init: called with the rest of the device&n; *      driver XXX_init routines. This platform *might*&n; *      have a Crossbow chip, or even several, but it&n; *      might have none. Register with the crosstalk&n; *      generic provider so when we encounter the chip&n; *      the right magic happens.&n; */
r_void
DECL|function|xbow_init
id|xbow_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow_init&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|xwidget_driver_register
c_func
(paren
id|XXBOW_WIDGET_PART_NUM
comma
l_int|0
comma
multiline_comment|/* XXBOW_WIDGET_MFGR_NUM, */
l_string|&quot;xbow_&quot;
comma
id|CDL_PRI_HI
)paren
suffix:semicolon
multiline_comment|/* attach before friends */
id|xwidget_driver_register
c_func
(paren
id|XBOW_WIDGET_PART_NUM
comma
id|XBOW_WIDGET_MFGR_NUM
comma
l_string|&quot;xbow_&quot;
comma
id|CDL_PRI_HI
)paren
suffix:semicolon
multiline_comment|/* attach before friends */
)brace
macro_line|#ifdef XBRIDGE_REGS_SIM
multiline_comment|/*    xbow_set_simulated_regs: sets xbow regs as needed&n; *&t;for powering through the boot&n; */
r_void
DECL|function|xbow_set_simulated_regs
id|xbow_set_simulated_regs
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
multiline_comment|/*&n;     * turn on link&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
op_assign
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:semicolon
multiline_comment|/*&n;     * and give it a live widget too&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_aux_status
op_assign
id|XB_AUX_STAT_PRESENT
suffix:semicolon
multiline_comment|/*&n;     * zero the link control reg&n;     */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
l_int|0x0
suffix:semicolon
)brace
macro_line|#endif /* XBRIDGE_REGS_SIM */
multiline_comment|/*&n; *    xbow_attach: the crosstalk provider has&n; *      determined that there is a crossbow widget&n; *      present, and has handed us the connection&n; *      point for that vertex.&n; *&n; *      We not only add our own vertex, but add&n; *      some &quot;xtalk switch&quot; data to the switch&n; *      vertex (at the connect point&squot;s parent) if&n; *      it does not have any.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_attach
id|xbow_attach
c_func
(paren
id|devfs_handle_t
id|conn
)paren
(brace
multiline_comment|/*REFERENCED */
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|devfs_handle_t
id|busv
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbow_soft_t
id|soft
suffix:semicolon
r_int
id|port
suffix:semicolon
id|xswitch_info_t
id|info
suffix:semicolon
macro_line|#ifdef LATER
id|xtalk_intr_t
id|intr_hdl
suffix:semicolon
id|device_desc_t
id|dev_desc
suffix:semicolon
macro_line|#endif
r_char
id|devnm
(braket
id|MAXDEVNAME
)braket
comma
op_star
id|s
suffix:semicolon
id|xbowreg_t
id|id
suffix:semicolon
r_int
id|rev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|xbow_num
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT
id|printk
c_func
(paren
l_string|&quot;%v: xbow_attach&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;0x%x: xbow_attach&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;     * Get a PIO pointer to the base of the crossbow&n;     * chip.&n;     */
macro_line|#ifdef XBRIDGE_REGS_SIM
id|printk
c_func
(paren
l_string|&quot;xbow_attach: XBRIDGE_REGS_SIM FIXME: allocating %ld bytes for xbow_s&bslash;n&quot;
comma
r_sizeof
(paren
id|xbow_t
)paren
)paren
suffix:semicolon
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|xbow_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;     * turn on ports e and f like in a real live ibrick&n;     */
id|xbow_set_simulated_regs
c_func
(paren
id|xbow
comma
l_int|0xe
)paren
suffix:semicolon
id|xbow_set_simulated_regs
c_func
(paren
id|xbow
comma
l_int|0xf
)paren
suffix:semicolon
macro_line|#else
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xtalk_piotrans_addr
c_func
(paren
id|conn
comma
l_int|0
comma
l_int|0
comma
r_sizeof
(paren
id|xbow_t
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* XBRIDGE_REGS_SIM */
multiline_comment|/*&n;     * Locate the &quot;switch&quot; vertex: it is the parent&n;     * of our connection point.&n;     */
id|busv
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|conn
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printk
c_func
(paren
l_string|&quot;xbow_attach: Bus Vertex 0x%p, conn 0x%p, xbow register 0x%p wid= 0x%x&bslash;n&quot;
comma
id|busv
comma
id|conn
comma
id|xbow
comma
op_star
(paren
r_volatile
id|u32
op_star
)paren
id|xbow
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|busv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
multiline_comment|/*&n;     * Create our private vertex, and connect our&n;     * driver information to it. This makes it possible&n;     * for diagnostic drivers to open the crossbow&n;     * vertex for access to registers.&n;     */
multiline_comment|/*&n;     * We need to teach xbow drivers to provide the right set of&n;     * file ops.&n;     */
id|vhdl
op_assign
l_int|NULL
suffix:semicolon
id|vhdl
op_assign
id|hwgraph_register
c_func
(paren
id|conn
comma
id|EDGE_LBL_XBOW
comma
l_int|0
comma
id|DEVFS_FL_AUTO_DEVNUM
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* &amp;hcl_fops */
(paren
r_void
op_star
)paren
op_amp
id|vhdl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vhdl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;xbow_attach: Unable to create char device for xbow conn %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|conn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate the soft state structure and attach&n;     * it to the xbow&squot;s vertex&n;     */
id|NEW
c_func
(paren
id|soft
)paren
suffix:semicolon
id|soft-&gt;conn
op_assign
id|conn
suffix:semicolon
id|soft-&gt;vhdl
op_assign
id|vhdl
suffix:semicolon
id|soft-&gt;busv
op_assign
id|busv
suffix:semicolon
id|soft-&gt;base
op_assign
id|xbow
suffix:semicolon
multiline_comment|/* does the universe really need another macro?  */
multiline_comment|/* xbow_soft_set(vhdl, (arbitrary_info_t) soft); */
id|hwgraph_fastinfo_set
c_func
(paren
id|vhdl
comma
(paren
id|arbitrary_info_t
)paren
id|soft
)paren
suffix:semicolon
DECL|macro|XBOW_NUM_SUFFIX_FORMAT
mdefine_line|#define XBOW_NUM_SUFFIX_FORMAT&t;&quot;[xbow# %d]&quot;
multiline_comment|/* Add xbow number as a suffix to the hwgraph name of the xbow.&n;     * This is helpful while looking at the error/warning messages.&n;     */
id|xbow_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * get the name of this xbow vertex and keep the info.&n;     * This is needed during errors and interrupts, but as&n;     * long as we have it, we can use it elsewhere.&n;     */
id|s
op_assign
id|dev_to_name
c_func
(paren
id|vhdl
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|soft-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
id|strlen
c_func
(paren
id|XBOW_NUM_SUFFIX_FORMAT
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|soft-&gt;name
comma
l_string|&quot;%s&quot;
id|XBOW_NUM_SUFFIX_FORMAT
comma
id|s
comma
id|xbow_num
)paren
suffix:semicolon
macro_line|#ifdef XBRIDGE_REGS_SIM
multiline_comment|/* my o200/ibrick has id=0x2d002049, but XXBOW_WIDGET_PART_NUM is defined&n;     * as 0xd000, so I&squot;m using that for the partnum bitfield.&n;     */
id|printk
c_func
(paren
l_string|&quot;xbow_attach: XBRIDGE_REGS_SIM FIXME: need xb_wid_id value!!&bslash;n&quot;
)paren
suffix:semicolon
id|id
op_assign
l_int|0x2d000049
suffix:semicolon
macro_line|#else
id|id
op_assign
id|xbow-&gt;xb_wid_id
suffix:semicolon
macro_line|#endif /* XBRIDGE_REGS_SIM */
id|rev
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
multiline_comment|/*&n;     * Print the revision if DEBUG, or SHOW_REVS and kdebug,&n;     * or the xbow is downrev.&n;     *&n;     * If xbow is downrev, make it a WARNING that the&n;     * Crossbow is DOWNREV: these chips are not good&n;     * to have around, and the operator should be told.&n;     */
macro_line|#ifdef&t;LATER
macro_line|#if !DEBUG
r_if
c_cond
(paren
macro_line|#if SHOW_REVS
(paren
id|kdebug
)paren
op_logical_or
macro_line|#endif&t;/* SHOW_REVS */
(paren
id|rev
OL
id|XBOW_REV_1_1
)paren
)paren
macro_line|#endif&t;/* !DEBUG  */
id|printk
c_func
(paren
l_string|&quot;%sCrossbow ASIC: rev %s (code=%d) at %s%s&quot;
comma
(paren
id|rev
OL
id|XBOW_REV_1_1
)paren
ques
c_cond
l_string|&quot;DOWNREV &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|rev
op_eq
id|XBOW_REV_1_0
)paren
ques
c_cond
l_string|&quot;1.0&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBOW_REV_1_1
)paren
ques
c_cond
l_string|&quot;1.1&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBOW_REV_1_2
)paren
ques
c_cond
l_string|&quot;1.2&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBOW_REV_1_3
)paren
ques
c_cond
l_string|&quot;1.3&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBOW_REV_2_0
)paren
ques
c_cond
l_string|&quot;2.0&quot;
suffix:colon
(paren
id|rev
op_eq
id|XXBOW_PART_REV_1_0
)paren
ques
c_cond
l_string|&quot;Xbridge 1.0&quot;
suffix:colon
(paren
id|rev
op_eq
id|XXBOW_PART_REV_2_0
)paren
ques
c_cond
l_string|&quot;Xbridge 2.0&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|rev
comma
id|soft-&gt;name
comma
(paren
id|rev
OL
id|XBOW_REV_1_1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* LATER */
id|mutex_spinlock_init
c_func
(paren
op_amp
id|soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
id|soft-&gt;xbow_perfcnt
(braket
l_int|0
)braket
dot
id|xp_perf_reg
op_assign
op_amp
id|xbow-&gt;xb_perf_ctr_a
suffix:semicolon
id|soft-&gt;xbow_perfcnt
(braket
l_int|1
)braket
dot
id|xp_perf_reg
op_assign
op_amp
id|xbow-&gt;xb_perf_ctr_b
suffix:semicolon
multiline_comment|/* Initialization for GBR bw allocation */
id|mutex_spinlock_init
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
)paren
suffix:semicolon
DECL|macro|XBOW_8_BIT_PORT_BW_MAX
mdefine_line|#define&t;XBOW_8_BIT_PORT_BW_MAX&t;&t;(400 * 1000 * 1000)&t;/* 400 MB/s */
DECL|macro|XBOW_16_BIT_PORT_BW_MAX
mdefine_line|#define XBOW_16_BIT_PORT_BW_MAX&t;&t;(800 * 1000 * 1000)&t;/* 800 MB/s */
multiline_comment|/* Set bandwidth hiwatermark and current values */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|soft-&gt;bw_hiwm
(braket
id|i
)braket
op_assign
id|XBOW_16_BIT_PORT_BW_MAX
suffix:semicolon
multiline_comment|/* for now */
id|soft-&gt;bw_cur_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Enable xbow error interrupts&n;     */
id|xbow-&gt;xb_wid_control
op_assign
(paren
id|XB_WID_CTRL_REG_ACC_IE
op_or
id|XB_WID_CTRL_XTALK_IE
)paren
suffix:semicolon
multiline_comment|/*&n;     * take a census of the widgets present,&n;     * leaving notes at the switch vertex.&n;     */
id|info
op_assign
id|xswitch_info_new
c_func
(paren
id|busv
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|MAX_PORT_NUM
op_minus
id|MAX_XBOW_PORTS
suffix:semicolon
id|port
OL
id|MAX_PORT_NUM
suffix:semicolon
op_increment
id|port
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xbow_link_alive
c_func
(paren
id|xbow
comma
id|port
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d is not alive&bslash;n&quot;
comma
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xbow_widget_present
c_func
(paren
id|xbow
comma
id|port
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d is alive but no widget is present&bslash;n&quot;
comma
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
macro_line|#if DEBUG &amp;&amp; XBOW_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;0x%p link %d has a widget&bslash;n&quot;
comma
id|busv
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
id|xswitch_info_link_is_ok
c_func
(paren
id|info
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn some error interrupts on&n;&t; * and turn others off. The PROM has&n;&t; * some things turned on we don&squot;t&n;&t; * want to see (bandwidth allocation&n;&t; * errors for instance); so if it&n;&t; * is not listed here, it is not on.&n;&t; */
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
(paren
(paren
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
multiline_comment|/*&n;&t; * Turn off these bits; they are non-fatal,&n;&t; * but we might want to save some statistics&n;&t; * on the frequency of these errors.&n;&t; * XXX FIXME XXX&n;&t; */
op_amp
op_complement
id|XB_CTRL_RCV_CNT_OFLOW_IE
op_amp
op_complement
id|XB_CTRL_XMT_CNT_OFLOW_IE
op_amp
op_complement
id|XB_CTRL_BNDWDTH_ALLOC_IE
op_amp
op_complement
id|XB_CTRL_RCV_IE
)paren
multiline_comment|/*&n;&t; * These are the ones we want to turn on.&n;&t; */
op_or
(paren
id|XB_CTRL_ILLEGAL_DST_IE
op_or
id|XB_CTRL_OALLOC_IBUF_IE
op_or
id|XB_CTRL_XMT_MAX_RTRY_IE
op_or
id|XB_CTRL_MAXREQ_TOUT_IE
op_or
id|XB_CTRL_XMT_RTRY_IE
op_or
id|XB_CTRL_SRC_TOUT_IE
)paren
)paren
suffix:semicolon
)brace
id|xswitch_provider_register
c_func
(paren
id|busv
comma
op_amp
id|xbow_provider
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* attach successful */
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_open
id|xbow_open
c_func
(paren
id|devfs_handle_t
op_star
id|devp
comma
r_int
id|oflag
comma
r_int
id|otyp
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_close
id|xbow_close
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|oflag
comma
r_int
id|otyp
comma
id|cred_t
op_star
id|crp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_map
id|xbow_map
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|vhandl_t
op_star
id|vt
comma
id|off_t
id|off
comma
r_int
id|len
comma
id|uint
id|prot
)paren
(brace
id|devfs_handle_t
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xbow_soft_t
id|soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|soft
)paren
suffix:semicolon
id|len
op_assign
id|ctob
c_func
(paren
id|btoc
c_func
(paren
id|len
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX- this ignores the offset!!! */
id|error
op_assign
id|v_mapphys
c_func
(paren
id|vt
comma
(paren
r_void
op_star
)paren
id|soft-&gt;base
comma
id|len
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|xbow_unmap
id|xbow_unmap
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|vhandl_t
op_star
id|vt
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This contains special-case code for grio. There are plans to make&n; * this general sometime in the future, but till then this should&n; * be good enough.&n; */
id|xwidgetnum_t
DECL|function|xbow_widget_num_get
id|xbow_widget_num_get
c_func
(paren
id|devfs_handle_t
id|dev
)paren
(brace
id|devfs_handle_t
id|tdev
suffix:semicolon
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|xwidget_info_t
id|xwidget_info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|dev
comma
id|devname
comma
id|MAXDEVNAME
)paren
suffix:semicolon
multiline_comment|/* If this is a pci controller vertex, traverse up using&n;&t; * the &quot;..&quot; links to get to the widget.&n;&t; */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|devname
comma
id|EDGE_LBL_PCI
)paren
op_logical_and
id|strstr
c_func
(paren
id|devname
comma
id|EDGE_LBL_CONTROLLER
)paren
)paren
(brace
id|tdev
op_assign
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hwgraph_edge_get
c_func
(paren
id|tdev
comma
id|HWGRAPH_EDGELBL_DOTDOT
comma
op_amp
id|tdev
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xwidget_info
op_assign
id|xwidget_info_chk
c_func
(paren
id|tdev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_return
(paren
id|xwidget_info_id_get
c_func
(paren
id|xwidget_info
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
)brace
r_return
id|XWIDGET_NONE
suffix:semicolon
)brace
r_int
DECL|function|xbow_ioctl
id|xbow_ioctl
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|flag
comma
r_struct
id|cred
op_star
id|cr
comma
r_int
op_star
id|rvalp
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined (DEBUG)
r_int
id|rc
suffix:semicolon
id|devfs_handle_t
id|conn
suffix:semicolon
r_struct
id|xwidget_info_s
op_star
id|xwidget_info
suffix:semicolon
id|xbow_soft_t
id|xbow_soft
suffix:semicolon
macro_line|#endif
op_star
id|rvalp
op_assign
l_int|0
suffix:semicolon
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#if defined (DEBUG)
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|conn
op_assign
id|xbow_soft-&gt;conn
suffix:semicolon
id|xwidget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|conn
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|xwidget_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|rc
op_assign
id|xwidget_hwid_is_xswitch
c_func
(paren
op_amp
id|xwidget_info-&gt;w_hwid
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|rc
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#ifdef LATER
r_case
id|XBOWIOC_PERF_ENABLE
suffix:colon
r_case
id|XBOWIOC_PERF_DISABLE
suffix:colon
(brace
r_struct
id|xbow_perfarg_t
id|xbow_perf_en
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_CAP_CRABLE
c_func
(paren
id|cr
comma
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FWRITE
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COPYIN
c_func
(paren
id|arg
comma
op_amp
id|xbow_perf_en
comma
r_sizeof
(paren
id|xbow_perf_en
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_assign
id|xbow_enable_perf_counter
c_func
(paren
id|vhdl
comma
id|xbow_perf_en.link
comma
(paren
id|cmd
op_eq
id|XBOWIOC_PERF_DISABLE
)paren
ques
c_cond
l_int|0
suffix:colon
id|xbow_perf_en.mode
comma
id|xbow_perf_en.counter
)paren
)paren
(brace
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef LATER
r_case
id|XBOWIOC_PERF_GET
suffix:colon
(brace
id|xbow_perf_link_t
op_star
id|xbow_perf_cnt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FREAD
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xbow_perf_cnt
op_assign
id|xbow_get_perf_counters
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|xbow_perf_cnt
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
(paren
r_void
op_star
)paren
id|xbow_perf_cnt
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|MAX_XBOW_PORTS
op_star
r_sizeof
(paren
id|xbow_perf_link_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|XBOWIOC_LLP_ERROR_ENABLE
suffix:colon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xbow_enable_llp_monitor
c_func
(paren
id|vhdl
)paren
)paren
op_ne
l_int|0
)paren
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XBOWIOC_LLP_ERROR_DISABLE
suffix:colon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xbow_disable_llp_monitor
c_func
(paren
id|vhdl
)paren
)paren
op_ne
l_int|0
)paren
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LATER
r_case
id|XBOWIOC_LLP_ERROR_GET
suffix:colon
(brace
id|xbow_link_status_t
op_star
id|xbow_llp_status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FREAD
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xbow_llp_status
op_assign
id|xbow_get_llp_status
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|xbow_llp_status
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COPYOUT
c_func
(paren
(paren
r_void
op_star
)paren
id|xbow_llp_status
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|MAX_XBOW_PORTS
op_star
r_sizeof
(paren
id|xbow_link_status_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef LATER
r_case
id|GIOCSETBW
suffix:colon
(brace
id|grio_ioctl_info_t
id|info
suffix:semicolon
id|xwidgetnum_t
id|src_widgetnum
comma
id|dest_widgetnum
suffix:semicolon
r_if
c_cond
(paren
id|COPYIN
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|grio_ioctl_info_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow:: prev_vhdl: %d next_vhdl: %d reqbw: %lld&bslash;n&quot;
comma
id|info.prev_vhdl
comma
id|info.next_vhdl
comma
id|info.reqbw
)paren
suffix:semicolon
macro_line|#endif /* GRIO_DEBUG */
id|src_widgetnum
op_assign
id|xbow_widget_num_get
c_func
(paren
id|info.prev_vhdl
)paren
suffix:semicolon
id|dest_widgetnum
op_assign
id|xbow_widget_num_get
c_func
(paren
id|info.next_vhdl
)paren
suffix:semicolon
multiline_comment|/* Bandwidth allocation is bi-directional. Since bandwidth&n;&t;     * reservations have already been done at an earlier stage,&n;&t;     * we cannot fail here for lack of bandwidth.&n;&t;     */
id|xbow_prio_bw_alloc
c_func
(paren
id|dev
comma
id|src_widgetnum
comma
id|dest_widgetnum
comma
l_int|0
comma
id|info.reqbw
)paren
suffix:semicolon
id|xbow_prio_bw_alloc
c_func
(paren
id|dev
comma
id|dest_widgetnum
comma
id|src_widgetnum
comma
l_int|0
comma
id|info.reqbw
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|GIOCRELEASEBW
suffix:colon
(brace
id|grio_ioctl_info_t
id|info
suffix:semicolon
id|xwidgetnum_t
id|src_widgetnum
comma
id|dest_widgetnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COPYIN
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|grio_ioctl_info_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow:: prev_vhdl: %d next_vhdl: %d reqbw: %lld&bslash;n&quot;
comma
id|info.prev_vhdl
comma
id|info.next_vhdl
comma
id|info.reqbw
)paren
suffix:semicolon
macro_line|#endif /* GRIO_DEBUG */
id|src_widgetnum
op_assign
id|xbow_widget_num_get
c_func
(paren
id|info.prev_vhdl
)paren
suffix:semicolon
id|dest_widgetnum
op_assign
id|xbow_widget_num_get
c_func
(paren
id|info.next_vhdl
)paren
suffix:semicolon
multiline_comment|/* Bandwidth reservation is bi-directional. Hence, remove&n;&t;     * bandwidth reservations for both directions.&n;&t;     */
id|xbow_prio_bw_alloc
c_func
(paren
id|dev
comma
id|src_widgetnum
comma
id|dest_widgetnum
comma
id|info.reqbw
comma
(paren
op_minus
l_int|1
op_star
id|info.reqbw
)paren
)paren
suffix:semicolon
id|xbow_prio_bw_alloc
c_func
(paren
id|dev
comma
id|dest_widgetnum
comma
id|src_widgetnum
comma
id|info.reqbw
comma
(paren
op_minus
l_int|1
op_star
id|info.reqbw
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_widget_present: See if a device is present&n; * on the specified port of this crossbow.&n; */
r_int
DECL|function|xbow_widget_present
id|xbow_widget_present
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_eq
l_int|14
)paren
op_logical_or
(paren
id|port
op_eq
l_int|15
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_aux_status
op_amp
id|XB_AUX_STAT_PRESENT
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|xbow_link_alive
id|xbow_link_alive
c_func
(paren
id|xbow_t
op_star
id|xbow
comma
r_int
id|port
)paren
(brace
id|xbwX_stat_t
id|xbow_linkstat
suffix:semicolon
id|xbow_linkstat.linkstatus
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
suffix:semicolon
r_return
(paren
id|xbow_linkstat.link_alive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_widget_lookup&n; *      Lookup the edges connected to the xbow specified, and&n; *      retrieve the handle corresponding to the widgetnum&n; *      specified.&n; *      If not found, return 0.&n; */
id|devfs_handle_t
DECL|function|xbow_widget_lookup
id|xbow_widget_lookup
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|widgetnum
)paren
(brace
id|xswitch_info_t
id|xswitch_info
suffix:semicolon
id|devfs_handle_t
id|conn
suffix:semicolon
id|xswitch_info
op_assign
id|xswitch_info_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|conn
op_assign
id|xswitch_info_vhdl_get
c_func
(paren
id|xswitch_info
comma
id|widgetnum
)paren
suffix:semicolon
r_return
id|conn
suffix:semicolon
)brace
multiline_comment|/*&n; * xbow_setwidint: called when xtalk&n; * is establishing or migrating our&n; * interrupt service.&n; */
macro_line|#ifdef LATER
r_static
r_void
DECL|function|xbow_setwidint
id|xbow_setwidint
c_func
(paren
id|xtalk_intr_t
id|intr
)paren
(brace
id|xwidgetnum_t
id|targ
op_assign
id|xtalk_intr_target_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xbow_intr_preset
c_func
(paren
(paren
r_void
op_star
)paren
id|xbow
comma
l_int|0
comma
id|targ
comma
id|addr
comma
id|vect
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* LATER */
multiline_comment|/*&n; * xbow_intr_preset: called during mlreset time&n; * if the platform specific code needs to route&n; * an xbow interrupt before the xtalk infrastructure&n; * is available for use.&n; *&n; * Also called from xbow_setwidint, so we don&squot;t&n; * replicate the guts of the routine.&n; *&n; * XXX- probably should be renamed xbow_wid_intr_set or&n; * something to reduce confusion.&n; */
multiline_comment|/*ARGSUSED3 */
r_void
DECL|function|xbow_intr_preset
id|xbow_intr_preset
c_func
(paren
r_void
op_star
id|which_widget
comma
r_int
id|which_widget_intr
comma
id|xwidgetnum_t
id|targ
comma
id|iopaddr_t
id|addr
comma
id|xtalk_intr_vector_t
id|vect
)paren
(brace
id|xbow_t
op_star
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|which_widget
suffix:semicolon
id|xbow-&gt;xb_wid_int_upper
op_assign
(paren
(paren
l_int|0xFF000000
op_amp
(paren
id|vect
op_lshift
l_int|24
)paren
)paren
op_or
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|xbow-&gt;xb_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|macro|XEM_ADD_STR
mdefine_line|#define&t;XEM_ADD_STR(s)&t;&t;printk(&quot;%s&quot;, (s))
DECL|macro|XEM_ADD_NVAR
mdefine_line|#define&t;XEM_ADD_NVAR(n,v)&t;printk(&quot;&bslash;t%20s: 0x%x&bslash;n&quot;, (n), (v))
DECL|macro|XEM_ADD_VAR
mdefine_line|#define&t;XEM_ADD_VAR(v)&t;&t;XEM_ADD_NVAR(#v,(v))
DECL|macro|XEM_ADD_IOEF
mdefine_line|#define XEM_ADD_IOEF(n) &t;if (IOERROR_FIELDVALID(ioe,n))&t;&t;    &bslash;&n;&t;&t;&t;&t;    XEM_ADD_NVAR(&quot;ioe.&quot; #n,&t;&t;    &bslash;&n;&t;&t;&t;&t;&t;&t; IOERROR_GETVALUE(ioe,n))
macro_line|#ifdef LATER
r_static
r_void
DECL|function|xem_add_ioe
id|xem_add_ioe
c_func
(paren
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|XEM_ADD_IOEF
c_func
(paren
id|errortype
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|widgetnum
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|widgetdev
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|srccpu
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|srcnode
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|errnode
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|sysioaddr
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|xtalkaddr
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|busspace
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|busaddr
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|memaddr
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|epc
)paren
suffix:semicolon
id|XEM_ADD_IOEF
c_func
(paren
id|ef
)paren
suffix:semicolon
)brace
DECL|macro|XEM_ADD_IOE
mdefine_line|#define XEM_ADD_IOE()&t;(xem_add_ioe(ioe))
macro_line|#endif&t;/* LATER */
DECL|variable|xbow_xmit_retry_errors
r_int
id|xbow_xmit_retry_errors
op_assign
l_int|0
suffix:semicolon
r_int
DECL|function|xbow_xmit_retry_error
id|xbow_xmit_retry_error
c_func
(paren
id|xbow_soft_t
id|soft
comma
r_int
id|port
)paren
(brace
id|xswitch_info_t
id|info
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|widget_cfg_t
op_star
id|wid
suffix:semicolon
id|widgetreg_t
id|id
suffix:semicolon
r_int
id|part
suffix:semicolon
r_int
id|mfgr
suffix:semicolon
id|wid
op_assign
id|soft-&gt;wpio
(braket
id|port
op_minus
id|BASE_XBOW_PORT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wid
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If we can&squot;t track down a PIO&n;&t; * pointer to our widget yet,&n;&t; * leave our caller knowing that&n;&t; * we are interested in this&n;&t; * interrupt if it occurs in&n;&t; * the future.&n;&t; */
id|info
op_assign
id|xswitch_info_get
c_func
(paren
id|soft-&gt;busv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
l_int|1
suffix:semicolon
id|vhdl
op_assign
id|xswitch_info_vhdl_get
c_func
(paren
id|info
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
r_return
l_int|1
suffix:semicolon
id|wid
op_assign
(paren
id|widget_cfg_t
op_star
)paren
id|xtalk_piotrans_addr
(paren
id|vhdl
comma
l_int|0
comma
l_int|0
comma
r_sizeof
op_star
id|wid
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wid
)paren
r_return
l_int|1
suffix:semicolon
id|soft-&gt;wpio
(braket
id|port
op_minus
id|BASE_XBOW_PORT
)braket
op_assign
id|wid
suffix:semicolon
)brace
id|id
op_assign
id|wid-&gt;w_id
suffix:semicolon
id|part
op_assign
id|XWIDGET_PART_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|mfgr
op_assign
id|XWIDGET_MFG_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
multiline_comment|/* If this thing is not a Bridge,&n;     * do not activate the WAR, and&n;     * tell our caller we do not need&n;     * to be called again.&n;     */
r_if
c_cond
(paren
(paren
id|part
op_ne
id|BRIDGE_WIDGET_PART_NUM
)paren
op_logical_or
(paren
id|mfgr
op_ne
id|BRIDGE_WIDGET_MFGR_NUM
)paren
)paren
(brace
multiline_comment|/* FIXME: add Xbridge to the WAR.&n;&t;&t; * Shouldn&squot;t hurt anything.  Later need to&n;&t;&t; * check if we can remove this.&n;                 */
r_if
c_cond
(paren
(paren
id|part
op_ne
id|XBRIDGE_WIDGET_PART_NUM
)paren
op_logical_or
(paren
id|mfgr
op_ne
id|XBRIDGE_WIDGET_MFGR_NUM
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* count how many times we&n;     * have picked up after&n;     * LLP Transmit problems.&n;     */
id|xbow_xmit_retry_errors
op_increment
suffix:semicolon
multiline_comment|/* rewrite the control register&n;     * to fix things up.&n;     */
id|wid-&gt;w_control
op_assign
id|wid-&gt;w_control
suffix:semicolon
id|wid-&gt;w_control
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|xbow_update_perf_counters
id|xbow_update_perf_counters
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_t
op_star
id|xbow_perf
op_assign
id|xbow_soft-&gt;xbow_perfcnt
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_plink
op_assign
id|xbow_soft-&gt;xbow_perflink
suffix:semicolon
id|xbow_perfcount_t
id|perf_reg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|link
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XBOW_PERF_COUNTERS
suffix:semicolon
id|i
op_increment
comma
id|xbow_perf
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xbow_perf-&gt;xp_mode
op_eq
id|XBOW_MONITOR_NONE
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
id|perf_reg.xb_counter_val
op_assign
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
suffix:semicolon
id|link
op_assign
id|perf_reg.xb_perf.link_select
suffix:semicolon
(paren
id|xbow_plink
op_plus
id|link
)paren
op_member_access_from_pointer
id|xlp_cumulative
(braket
id|xbow_perf-&gt;xp_curmode
)braket
op_add_assign
(paren
(paren
id|perf_reg.xb_perf.count
op_minus
id|xbow_perf-&gt;xp_current
)paren
op_amp
id|XBOW_COUNTER_MASK
)paren
suffix:semicolon
id|xbow_perf-&gt;xp_current
op_assign
id|perf_reg.xb_perf.count
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* Do port /mode multiplexing here */
macro_line|#ifdef LATER
(paren
r_void
)paren
id|timeout
c_func
(paren
id|xbow_update_perf_counters
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|vhdl
comma
id|XBOW_PERF_TIMEOUT
)paren
suffix:semicolon
macro_line|#endif
)brace
id|xbow_perf_link_t
op_star
DECL|function|xbow_get_perf_counters
id|xbow_get_perf_counters
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_link_t
op_star
id|xbow_perf_link
op_assign
id|xbow_soft-&gt;xbow_perflink
suffix:semicolon
r_return
id|xbow_perf_link
suffix:semicolon
)brace
r_int
DECL|function|xbow_enable_perf_counter
id|xbow_enable_perf_counter
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|link
comma
r_int
id|mode
comma
r_int
id|counter
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_perf_t
op_star
id|xbow_perf
op_assign
id|xbow_soft-&gt;xbow_perfcnt
suffix:semicolon
id|xbow_linkctrl_t
id|xbow_link_ctrl
suffix:semicolon
id|xbow_t
op_star
id|xbow
op_assign
id|xbow_soft-&gt;base
suffix:semicolon
id|xbow_perfcount_t
id|perf_reg
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
id|link
op_sub_assign
id|BASE_XBOW_PORT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|link
OL
l_int|0
)paren
op_logical_or
(paren
id|link
op_ge
id|MAX_XBOW_PORTS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
OL
id|XBOW_MONITOR_NONE
)paren
op_logical_or
(paren
id|mode
OG
id|XBOW_MONITOR_DEST_LINK
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|counter
OL
l_int|0
)paren
op_logical_or
(paren
id|counter
op_ge
id|XBOW_PERF_COUNTERS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xbow_perf
op_plus
id|counter
)paren
op_member_access_from_pointer
id|xp_mode
op_logical_and
id|mode
)paren
(brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XBOW_PERF_COUNTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|counter
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|xbow_perf
op_plus
id|i
)paren
op_member_access_from_pointer
id|xp_link
op_eq
id|link
)paren
op_logical_and
(paren
(paren
id|xbow_perf
op_plus
id|i
)paren
op_member_access_from_pointer
id|xp_mode
)paren
)paren
(brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|xbow_perf
op_add_assign
id|counter
suffix:semicolon
id|xbow_perf-&gt;xp_curlink
op_assign
id|xbow_perf-&gt;xp_link
op_assign
id|link
suffix:semicolon
id|xbow_perf-&gt;xp_curmode
op_assign
id|xbow_perf-&gt;xp_mode
op_assign
id|mode
suffix:semicolon
id|xbow_link_ctrl.xbl_ctrlword
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_control
suffix:semicolon
id|xbow_link_ctrl.xb_linkcontrol.perf_mode
op_assign
id|mode
suffix:semicolon
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_control
op_assign
id|xbow_link_ctrl.xbl_ctrlword
suffix:semicolon
id|perf_reg.xb_counter_val
op_assign
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
suffix:semicolon
id|perf_reg.xb_perf.link_select
op_assign
id|link
suffix:semicolon
op_star
(paren
id|xbowreg_t
op_star
)paren
id|xbow_perf-&gt;xp_perf_reg
op_assign
id|perf_reg.xb_counter_val
suffix:semicolon
id|xbow_perf-&gt;xp_current
op_assign
id|perf_reg.xb_perf.count
suffix:semicolon
macro_line|#ifdef LATER
(paren
r_void
)paren
id|timeout
c_func
(paren
id|xbow_update_perf_counters
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|vhdl
comma
id|XBOW_PERF_TIMEOUT
)paren
suffix:semicolon
macro_line|#endif
id|mutex_spinunlock
c_func
(paren
op_amp
id|xbow_soft-&gt;xbow_perf_lock
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xbow_link_status_t
op_star
DECL|function|xbow_get_llp_status
id|xbow_get_llp_status
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_llp_status
op_assign
id|xbow_soft-&gt;xbow_link_status
suffix:semicolon
r_return
id|xbow_llp_status
suffix:semicolon
)brace
r_void
DECL|function|xbow_update_llp_status
id|xbow_update_llp_status
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow_link_status_t
op_star
id|xbow_llp_status
op_assign
id|xbow_soft-&gt;xbow_link_status
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbwX_stat_t
id|lnk_sts
suffix:semicolon
id|xbow_aux_link_status_t
id|aux_sts
suffix:semicolon
r_int
id|link
suffix:semicolon
id|devfs_handle_t
id|xwidget_vhdl
suffix:semicolon
r_char
op_star
id|xwidget_name
suffix:semicolon
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|xbow_soft-&gt;base
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|link
op_increment
comma
id|xbow_llp_status
op_increment
)paren
(brace
multiline_comment|/* Get the widget name corresponding the current link.&n;&t; * Note : 0 &lt;= link &lt; MAX_XBOW_PORTS(8).&n;&t; * &t;  BASE_XBOW_PORT(0x8) &lt;= xwidget number &lt; MAX_PORT_NUM (0x10)&n;&t; */
id|xwidget_vhdl
op_assign
id|xbow_widget_lookup
c_func
(paren
id|xbow_soft-&gt;busv
comma
id|link
op_plus
id|BASE_XBOW_PORT
)paren
suffix:semicolon
id|xwidget_name
op_assign
id|xwidget_name_get
c_func
(paren
id|xwidget_vhdl
)paren
suffix:semicolon
id|aux_sts.aux_linkstatus
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_aux_status
suffix:semicolon
id|lnk_sts.linkstatus
op_assign
id|xbow-&gt;xb_link_raw
(braket
id|link
)braket
dot
id|link_status_clr
suffix:semicolon
r_if
c_cond
(paren
id|lnk_sts.link_alive
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|xbow_llp_status-&gt;rx_err_count
op_add_assign
id|aux_sts.xb_aux_linkstatus.rx_err_cnt
suffix:semicolon
id|xbow_llp_status-&gt;tx_retry_count
op_add_assign
id|aux_sts.xb_aux_linkstatus.tx_retry_cnt
suffix:semicolon
r_if
c_cond
(paren
id|lnk_sts.linkstatus
op_amp
op_complement
(paren
id|XB_STAT_RCV_ERR
op_or
id|XB_STAT_XMT_RTRY_ERR
op_or
id|XB_STAT_LINKALIVE
)paren
)paren
(brace
macro_line|#ifdef&t;LATER
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;link %d[%s]: bad status 0x%x&bslash;n&quot;
comma
id|link
comma
id|xwidget_name
comma
id|lnk_sts.linkstatus
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef LATER
r_if
c_cond
(paren
id|xbow_soft-&gt;link_monitor
)paren
(paren
r_void
)paren
id|timeout
c_func
(paren
id|xbow_update_llp_status
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|vhdl
comma
id|XBOW_STATS_TIMEOUT
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|xbow_disable_llp_monitor
id|xbow_disable_llp_monitor
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_int
id|port
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|MAX_XBOW_PORTS
suffix:semicolon
id|port
op_increment
)paren
(brace
id|xbow_soft-&gt;xbow_link_status
(braket
id|port
)braket
dot
id|rx_err_count
op_assign
l_int|0
suffix:semicolon
id|xbow_soft-&gt;xbow_link_status
(braket
id|port
)braket
dot
id|tx_retry_count
op_assign
l_int|0
suffix:semicolon
)brace
id|xbow_soft-&gt;link_monitor
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xbow_enable_llp_monitor
id|xbow_enable_llp_monitor
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
id|xbow_soft_t
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
macro_line|#ifdef LATER
(paren
r_void
)paren
id|timeout
c_func
(paren
id|xbow_update_llp_status
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|vhdl
comma
id|XBOW_STATS_TIMEOUT
)paren
suffix:semicolon
macro_line|#endif
id|xbow_soft-&gt;link_monitor
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xbow_reset_link
id|xbow_reset_link
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
id|xwidget_info_t
id|widget_info
suffix:semicolon
id|xwidgetnum_t
id|port
suffix:semicolon
id|xbow_t
op_star
id|xbow
suffix:semicolon
id|xbowreg_t
id|ctrl
suffix:semicolon
id|xbwX_stat_t
id|stat
suffix:semicolon
r_int
id|itick
suffix:semicolon
r_int
id|dtick
suffix:semicolon
r_static
r_int
id|ticks_per_ms
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ticks_per_ms
)paren
(brace
id|itick
op_assign
id|get_timestamp
c_func
(paren
)paren
suffix:semicolon
id|us_delay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ticks_per_ms
op_assign
id|get_timestamp
c_func
(paren
)paren
op_minus
id|itick
suffix:semicolon
)brace
id|widget_info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|port
op_assign
id|xwidget_info_id_get
c_func
(paren
id|widget_info
)paren
suffix:semicolon
macro_line|#ifdef XBOW_K1PTR&t;&t;&t;/* defined if we only have one xbow ... */
id|xbow
op_assign
id|XBOW_K1PTR
suffix:semicolon
macro_line|#else
(brace
id|devfs_handle_t
id|xbow_vhdl
suffix:semicolon
id|xbow_soft_t
id|xbow_soft
suffix:semicolon
id|hwgraph_traverse
c_func
(paren
id|xconn_vhdl
comma
l_string|&quot;.master/xtalk/0/xbow&quot;
comma
op_amp
id|xbow_vhdl
)paren
suffix:semicolon
id|xbow_soft
op_assign
id|xbow_soft_get
c_func
(paren
id|xbow_vhdl
)paren
suffix:semicolon
id|xbow
op_assign
id|xbow_soft-&gt;base
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;     * This requires three PIOs (reset the link, check for the&n;     * reset, restore the control register for the link) plus&n;     * 10us to wait for the reset. We allow up to 1ms for the&n;     * widget to come out of reset before giving up and&n;     * returning a failure.&n;     */
id|ctrl
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
suffix:semicolon
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_reset
op_assign
l_int|0
suffix:semicolon
id|itick
op_assign
id|get_timestamp
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|stat.linkstatus
op_assign
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_status
suffix:semicolon
r_if
c_cond
(paren
id|stat.link_alive
)paren
r_break
suffix:semicolon
id|dtick
op_assign
id|get_timestamp
c_func
(paren
)paren
op_minus
id|itick
suffix:semicolon
r_if
c_cond
(paren
id|dtick
OG
id|ticks_per_ms
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* never came out of reset */
)brace
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* don&squot;t beat on link_status */
)brace
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|port
)paren
dot
id|link_control
op_assign
id|ctrl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dump xbow registers.&n; * input parameter is either a pointer to&n; * the xbow chip or the vertex handle for&n; * an xbow vertex.&n; */
r_void
DECL|function|idbg_xbowregs
id|idbg_xbowregs
c_func
(paren
r_int64
id|regs
)paren
(brace
id|xbow_t
op_star
id|xbow
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xb_linkregs_t
op_star
id|link
suffix:semicolon
macro_line|#ifdef LATER
r_if
c_cond
(paren
id|dev_is_vertex
c_func
(paren
(paren
id|devfs_handle_t
)paren
id|regs
)paren
)paren
(brace
id|devfs_handle_t
id|vhdl
op_assign
(paren
id|devfs_handle_t
)paren
id|regs
suffix:semicolon
id|xbow_soft_t
id|soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|xbow
op_assign
id|soft-&gt;base
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|xbow
op_assign
(paren
id|xbow_t
op_star
)paren
id|regs
suffix:semicolon
)brace
macro_line|#ifdef LATER
id|qprintf
c_func
(paren
l_string|&quot;Printing xbow registers starting at 0x%x&bslash;n&quot;
comma
id|xbow
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;wid %x status %x erruppr %x errlower %x control %x timeout %x&bslash;n&quot;
comma
id|xbow-&gt;xb_wid_id
comma
id|xbow-&gt;xb_wid_stat
comma
id|xbow-&gt;xb_wid_err_upper
comma
id|xbow-&gt;xb_wid_err_lower
comma
id|xbow-&gt;xb_wid_control
comma
id|xbow-&gt;xb_wid_req_timeout
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;intr uppr %x lower %x errcmd %x llp ctrl %x arb_reload %x&bslash;n&quot;
comma
id|xbow-&gt;xb_wid_int_upper
comma
id|xbow-&gt;xb_wid_int_lower
comma
id|xbow-&gt;xb_wid_err_cmdword
comma
id|xbow-&gt;xb_wid_llp
comma
id|xbow-&gt;xb_wid_arb_reload
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
op_le
l_int|0xf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|link
op_assign
op_amp
id|xbow
op_member_access_from_pointer
id|xb_link
c_func
(paren
id|i
)paren
suffix:semicolon
macro_line|#ifdef LATER
id|qprintf
c_func
(paren
l_string|&quot;Link %d registers&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tctrl %x stat %x arbuppr %x arblowr %x auxstat %x&bslash;n&quot;
comma
id|link-&gt;link_control
comma
id|link-&gt;link_status
comma
id|link-&gt;link_arb_upper
comma
id|link-&gt;link_arb_lower
comma
id|link-&gt;link_aux_status
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|macro|XBOW_ARB_RELOAD_TICKS
mdefine_line|#define XBOW_ARB_RELOAD_TICKS&t;&t;25
multiline_comment|/* granularity: 4 MB/s, max: 124 MB/s */
DECL|macro|GRANULARITY
mdefine_line|#define GRANULARITY&t;&t;&t;((100 * 1000000) / XBOW_ARB_RELOAD_TICKS)
DECL|macro|XBOW_BYTES_TO_GBR
mdefine_line|#define XBOW_BYTES_TO_GBR(BYTES_per_s)&t;(int) (BYTES_per_s / GRANULARITY)
DECL|macro|XBOW_GBR_TO_BYTES
mdefine_line|#define XBOW_GBR_TO_BYTES(cnt)&t;&t;(bandwidth_t) ((cnt) * GRANULARITY)
DECL|macro|CEILING_BYTES_TO_GBR
mdefine_line|#define CEILING_BYTES_TO_GBR(gbr, bytes_per_sec)&t;&bslash;&n;&t;&t;&t;((XBOW_GBR_TO_BYTES(gbr) &lt; bytes_per_sec) ? gbr+1 : gbr)
DECL|macro|XBOW_ARB_GBR_MAX
mdefine_line|#define XBOW_ARB_GBR_MAX&t;&t;31
DECL|macro|ABS
mdefine_line|#define ABS(x)&t;&t;&t;&t;((x &gt; 0) ? (x) : (-1 * x))
multiline_comment|/* absolute value */
r_int
DECL|function|xbow_bytes_to_gbr
id|xbow_bytes_to_gbr
c_func
(paren
id|bandwidth_t
id|old_bytes_per_sec
comma
id|bandwidth_t
id|bytes_per_sec
)paren
(brace
r_int
id|gbr_granted
suffix:semicolon
r_int
id|new_total_gbr
suffix:semicolon
r_int
id|change_gbr
suffix:semicolon
id|bandwidth_t
id|new_total_bw
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow_bytes_to_gbr: old_bytes_per_sec %lld bytes_per_sec %lld&bslash;n&quot;
comma
id|old_bytes_per_sec
comma
id|bytes_per_sec
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
id|gbr_granted
op_assign
id|CEILING_BYTES_TO_GBR
c_func
(paren
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|old_bytes_per_sec
)paren
)paren
comma
id|old_bytes_per_sec
)paren
suffix:semicolon
id|new_total_bw
op_assign
id|old_bytes_per_sec
op_plus
id|bytes_per_sec
suffix:semicolon
id|new_total_gbr
op_assign
id|CEILING_BYTES_TO_GBR
c_func
(paren
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|new_total_bw
)paren
)paren
comma
id|new_total_bw
)paren
suffix:semicolon
id|change_gbr
op_assign
id|new_total_gbr
op_minus
id|gbr_granted
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow_bytes_to_gbr: gbr_granted %d new_total_gbr %d change_gbr %d&bslash;n&quot;
comma
id|gbr_granted
comma
id|new_total_gbr
comma
id|change_gbr
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
r_return
(paren
id|change_gbr
)paren
suffix:semicolon
)brace
multiline_comment|/* Conversion from GBR to bytes */
id|bandwidth_t
DECL|function|xbow_gbr_to_bytes
id|xbow_gbr_to_bytes
c_func
(paren
r_int
id|gbr
)paren
(brace
r_return
(paren
id|XBOW_GBR_TO_BYTES
c_func
(paren
id|gbr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Given the vhdl for the desired xbow, the src and dest. widget ids&n; * and the req_bw value, this xbow driver entry point accesses the&n; * xbow registers and allocates the desired bandwidth if available.&n; *&n; * If bandwidth allocation is successful, return success else return failure.&n; */
r_int
DECL|function|xbow_prio_bw_alloc
id|xbow_prio_bw_alloc
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|xwidgetnum_t
id|src_wid
comma
id|xwidgetnum_t
id|dest_wid
comma
r_int
r_int
r_int
id|old_alloc_bw
comma
r_int
r_int
r_int
id|req_bw
)paren
(brace
id|xbow_soft_t
id|soft
op_assign
id|xbow_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_volatile
id|xbowreg_t
op_star
id|xreg
suffix:semicolon
id|xbowreg_t
id|mask
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|bandwidth_t
id|old_bw_BYTES
comma
id|req_bw_BYTES
suffix:semicolon
id|xbowreg_t
id|old_xreg
suffix:semicolon
r_int
id|old_bw_GBR
comma
id|req_bw_GBR
comma
id|new_bw_GBR
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;xbow_prio_bw_alloc: vhdl %d src_wid %d dest_wid %d req_bw %lld&bslash;n&quot;
comma
(paren
r_int
)paren
id|vhdl
comma
(paren
r_int
)paren
id|src_wid
comma
(paren
r_int
)paren
id|dest_wid
comma
id|req_bw
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|XBOW_WIDGET_IS_VALID
c_func
(paren
id|src_wid
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XBOW_WIDGET_IS_VALID
c_func
(paren
id|dest_wid
)paren
)paren
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
)paren
suffix:semicolon
multiline_comment|/* Get pointer to the correct register */
id|xreg
op_assign
id|XBOW_PRIO_ARBREG_PTR
c_func
(paren
id|soft-&gt;base
comma
id|dest_wid
comma
id|src_wid
)paren
suffix:semicolon
multiline_comment|/* Get mask for GBR count value */
id|mask
op_assign
id|XB_ARB_GBR_MSK
op_lshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
suffix:semicolon
id|req_bw_GBR
op_assign
id|xbow_bytes_to_gbr
c_func
(paren
id|old_alloc_bw
comma
id|req_bw
)paren
suffix:semicolon
id|req_bw_BYTES
op_assign
(paren
id|req_bw_GBR
OL
l_int|0
)paren
ques
c_cond
(paren
op_minus
l_int|1
op_star
id|xbow_gbr_to_bytes
c_func
(paren
id|ABS
c_func
(paren
id|req_bw_GBR
)paren
)paren
)paren
suffix:colon
id|xbow_gbr_to_bytes
c_func
(paren
id|req_bw_GBR
)paren
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|printf
c_func
(paren
l_string|&quot;req_bw %lld req_bw_BYTES %lld req_bw_GBR %d&bslash;n&quot;
comma
id|req_bw
comma
id|req_bw_BYTES
comma
id|req_bw_GBR
)paren
suffix:semicolon
macro_line|#endif&t;/* GRIO_DEBUG */
id|old_bw_BYTES
op_assign
id|soft-&gt;bw_cur_used
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
suffix:semicolon
id|old_xreg
op_assign
op_star
id|xreg
suffix:semicolon
id|old_bw_GBR
op_assign
(paren
(paren
(paren
op_star
id|xreg
)paren
op_amp
id|mask
)paren
op_rshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
)paren
suffix:semicolon
macro_line|#ifdef GRIO_DEBUG
id|ASSERT
c_func
(paren
id|XBOW_BYTES_TO_GBR
c_func
(paren
id|old_bw_BYTES
)paren
op_eq
id|old_bw_GBR
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;old_bw_BYTES %lld old_bw_GBR %d&bslash;n&quot;
comma
id|old_bw_BYTES
comma
id|old_bw_GBR
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;req_bw_BYTES %lld old_bw_BYTES %lld soft-&gt;bw_hiwm %lld&bslash;n&quot;
comma
id|req_bw_BYTES
comma
id|old_bw_BYTES
comma
id|soft-&gt;bw_hiwm
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* GRIO_DEBUG */
multiline_comment|/* Accept the request only if we don&squot;t exceed the destination&n;     * port HIWATER_MARK *AND* the max. link GBR arbitration count&n;     */
r_if
c_cond
(paren
(paren
(paren
id|old_bw_BYTES
op_plus
id|req_bw_BYTES
)paren
op_le
id|soft-&gt;bw_hiwm
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
)paren
op_logical_and
(paren
id|req_bw_GBR
op_plus
id|old_bw_GBR
op_le
id|XBOW_ARB_GBR_MAX
)paren
)paren
(brace
id|new_bw_GBR
op_assign
(paren
id|old_bw_GBR
op_plus
id|req_bw_GBR
)paren
suffix:semicolon
multiline_comment|/* Set this in the xbow link register */
op_star
id|xreg
op_assign
(paren
id|old_xreg
op_amp
op_complement
id|mask
)paren
op_or
"&bslash;"
(paren
id|new_bw_GBR
op_lshift
id|XB_ARB_GBR_SHFT
c_func
(paren
id|src_wid
)paren
op_amp
id|mask
)paren
suffix:semicolon
id|soft-&gt;bw_cur_used
(braket
(paren
r_int
)paren
id|dest_wid
op_minus
id|MAX_XBOW_PORTS
)braket
op_assign
id|xbow_gbr_to_bytes
c_func
(paren
id|new_bw_GBR
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
l_int|1
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|soft-&gt;xbow_bw_alloc_lock
comma
id|s
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
eof
