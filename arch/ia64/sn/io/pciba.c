multiline_comment|/*&n; * arch/ia64/sn/io/pciba.c&n; *&n; * IRIX PCIBA-inspired user mode PCI interface&n; *&n; * requires: devfs&n; *&n; * device nodes show up in /dev/pci/BB/SS.F (where BB is the bus the&n; * device is on, SS is the slot the device is in, and F is the&n; * device&squot;s function on a multi-function card).&n; *&n; * when compiled into the kernel, it will only be initialized by the&n; * sgi sn1 specific initialization code.  in this case, device nodes&n; * are under /dev/hw/..../&n; *&n; * This file is subject to the terms and conditions of the GNU General&n; * Public License.  See the file &quot;COPYING&quot; in the main directory of&n; * this archive for more details.&n; *&n; * Copyright (C) 2001-2002 Silicon Graphics, Inc.  All rights reserved.&n; *&n; * 03262001 - Initial version by Chad Talbott&n; */
multiline_comment|/* jesse&squot;s beefs:&n;&n;   register_pci_device should be documented&n;   &n;   grossness with do_swap should be documented&n;   &n;   big, gross union&squot;ized node_data should be replaced with independent&n;   structures&n;&n;   replace global list of nodes with global lists of resources.  could&n;   use object oriented approach of allocating and cleaning up&n;   resources.&n;   &n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifndef CONFIG_DEVFS_FS
macro_line|#  error PCIBA requires devfs
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/raw.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/sn/pci/pciba.h&gt;
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;User mode PCI interface&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Chad Talbott&quot;
)paren
suffix:semicolon
DECL|macro|DEBUG_PCIBA
macro_line|#undef DEBUG_PCIBA
multiline_comment|/* #define DEBUG_PCIBA */
DECL|macro|TRACE_PCIBA
macro_line|#undef TRACE_PCIBA
multiline_comment|/* #define TRACE_PCIBA */
macro_line|#if defined(DEBUG_PCIBA)
DECL|macro|DPRINTF
macro_line|#  define DPRINTF(x...) printk(KERN_DEBUG x)
macro_line|#else
DECL|macro|DPRINTF
macro_line|#  define DPRINTF(x...)
macro_line|#endif
macro_line|#if defined(TRACE_PCIBA)
macro_line|#  if defined(__GNUC__)
DECL|macro|TRACE
macro_line|#    define TRACE()&t;printk(KERN_DEBUG &quot;%s:%d:%s&bslash;n&quot;, &bslash;&n;&t;&t;&t;       __FILE__, __LINE__, __FUNCTION__)
macro_line|#  else
DECL|macro|TRACE
macro_line|#    define TRACE()&t;printk(KERN_DEBUG &quot;%s:%d&bslash;n&quot;, __LINE__, __FILE__)
macro_line|#  endif
macro_line|#else
DECL|macro|TRACE
macro_line|#  define TRACE()
macro_line|#endif
DECL|enumerator|failure
DECL|enumerator|success
DECL|typedef|status
r_typedef
r_enum
(brace
id|failure
comma
id|success
)brace
id|status
suffix:semicolon
DECL|enumerator|false
DECL|enumerator|true
DECL|typedef|boolean
r_typedef
r_enum
(brace
l_bool|false
comma
l_bool|true
)brace
id|boolean
suffix:semicolon
multiline_comment|/* major data structures:&n;&n;   struct node_data -&n;   &n;   &t;one for each file registered with devfs.  contains everything&n;   &t;that any file&squot;s fops would need to know about.&n;&n;   struct dma_allocation -&n;&n;   &t;a single DMA allocation.  only the &squot;dma&squot; nodes care about&n;   &t;these.  they are there primarily to allow the driver to look&n;   &t;up the kernel virtual address of dma buffers allocated by&n;   &t;pci_alloc_consistent, as the application is only given the&n;   &t;physical address (to program the device&squot;s dma, presumably) and&n;   &t;cannot supply the kernel virtual address when freeing the&n;   &t;buffer.&n;&n;&t;it&squot;s also useful to maintain a list of buffers allocated&n;&t;through a specific node to allow some sanity checking by this&n;&t;driver.  this prevents (for example) a broken application from&n;&t;freeing buffers that it didn&squot;t allocate, or buffers allocated&n;&t;on another node.&n;   &n;   global_node_list -&n;&n;   &t;a list of all nodes allocated.  this allows the driver to free&n;   &t;all the memory it has &squot;kmalloc&squot;d in case of an error, or on&n;   &t;module removal.&n;&n;   global_dma_list -&n;&n;        a list of all dma buffers allocated by this driver.  this&n;&t;allows the driver to &squot;pci_free_consistent&squot; all buffers on&n;&t;module removal or error.&n;&n;*/
DECL|struct|node_data
r_struct
id|node_data
(brace
multiline_comment|/* flat list of all the device nodes.  makes it easy to free&n;&t;   them all when we&squot;re unregistered */
DECL|member|global_node_list
r_struct
id|list_head
id|global_node_list
suffix:semicolon
DECL|member|devfs_handle
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|member|cleanup
r_void
(paren
op_star
id|cleanup
)paren
(paren
r_struct
id|node_data
op_star
)paren
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|dma_allocs
r_struct
id|list_head
id|dma_allocs
suffix:semicolon
DECL|member|mmapped
id|boolean
id|mmapped
suffix:semicolon
DECL|member|dma
)brace
id|dma
suffix:semicolon
r_struct
(brace
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|saved_rom_base_reg
id|u32
id|saved_rom_base_reg
suffix:semicolon
DECL|member|mmapped
id|boolean
id|mmapped
suffix:semicolon
DECL|member|rom
)brace
id|rom
suffix:semicolon
r_struct
(brace
DECL|member|res
r_struct
id|resource
op_star
id|res
suffix:semicolon
DECL|member|base
)brace
id|base
suffix:semicolon
r_struct
(brace
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|config
)brace
id|config
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|dma_allocation
r_struct
id|dma_allocation
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|handle
id|dma_addr_t
id|handle
suffix:semicolon
DECL|member|va
r_void
op_star
id|va
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|global_node_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|global_dma_list
)paren
suffix:semicolon
multiline_comment|/* module entry points */
r_int
id|__init
id|pciba_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|__exit
id|pciba_exit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|status
id|__init
id|register_with_devfs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|unregister_with_devfs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|status
id|__init
id|register_pci_device
c_func
(paren
id|devfs_handle_t
id|device_dir_handle
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* file operations */
r_static
r_int
id|generic_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|rom_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_int
id|rom_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|base_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_int
id|config_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|dma_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|dma_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
multiline_comment|/* support routines */
r_static
r_int
id|mmap_pci_address
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|pci_va
)paren
suffix:semicolon
r_static
r_int
id|mmap_kernel_address
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_void
op_star
id|kernel_va
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PCIBA
r_static
r_void
id|dump_nodes
c_func
(paren
r_struct
id|list_head
op_star
id|nodes
)paren
suffix:semicolon
r_static
r_void
id|dump_allocations
c_func
(paren
r_struct
id|list_head
op_star
id|dalp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* file operations for each type of node */
DECL|variable|rom_fops
r_static
r_struct
id|file_operations
id|rom_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|mmap
suffix:colon
id|rom_mmap
comma
id|open
suffix:colon
id|generic_open
comma
id|release
suffix:colon
id|rom_release
)brace
suffix:semicolon
DECL|variable|base_fops
r_static
r_struct
id|file_operations
id|base_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|mmap
suffix:colon
id|base_mmap
comma
id|open
suffix:colon
id|generic_open
)brace
suffix:semicolon
DECL|variable|config_fops
r_static
r_struct
id|file_operations
id|config_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|ioctl
suffix:colon
id|config_ioctl
comma
id|open
suffix:colon
id|generic_open
)brace
suffix:semicolon
DECL|variable|dma_fops
r_static
r_struct
id|file_operations
id|dma_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|ioctl
suffix:colon
id|dma_ioctl
comma
id|mmap
suffix:colon
id|dma_mmap
comma
id|open
suffix:colon
id|generic_open
)brace
suffix:semicolon
DECL|variable|pciba_init
id|module_init
c_func
(paren
id|pciba_init
)paren
suffix:semicolon
DECL|variable|pciba_exit
id|module_exit
c_func
(paren
id|pciba_exit
)paren
suffix:semicolon
r_int
id|__init
DECL|function|pciba_init
id|pciba_init
c_func
(paren
r_void
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_with_devfs
c_func
(paren
)paren
op_eq
id|failure
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* failure */
id|printk
c_func
(paren
l_string|&quot;PCIBA (a user mode PCI interface) initialized.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
r_void
id|__exit
DECL|function|pciba_exit
id|pciba_exit
c_func
(paren
r_void
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: should also free all that memory that we allocated&n;           ;) */
id|unregister_with_devfs
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|# if 0
r_static
r_void
id|__exit
id|free_nodes
c_func
(paren
r_void
)paren
(brace
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|nd
comma
op_amp
id|node_list
)paren
(brace
id|kfree
c_func
(paren
id|list_entry
c_func
(paren
id|nd
comma
r_struct
id|nd
comma
id|node_list
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|variable|pciba_devfs_handle
r_static
id|devfs_handle_t
id|pciba_devfs_handle
suffix:semicolon
r_extern
id|devfs_handle_t
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
suffix:semicolon
r_static
id|status
id|__init
DECL|function|register_with_devfs
id|register_with_devfs
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|devfs_handle_t
id|device_dir_handle
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: don&squot;t forget /dev/.../pci/mem &amp; /dev/.../pci/io */
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|device_dir_handle
op_assign
id|devfn_to_vertex
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_dir_handle
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
r_if
c_cond
(paren
id|register_pci_device
c_func
(paren
id|device_dir_handle
comma
id|dev
)paren
op_eq
id|failure
)paren
(brace
id|devfs_unregister
c_func
(paren
id|pciba_devfs_handle
)paren
suffix:semicolon
r_return
id|failure
suffix:semicolon
)brace
)brace
r_return
id|success
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|unregister_with_devfs
id|unregister_with_devfs
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|lhp
suffix:semicolon
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lhp
comma
op_amp
id|global_node_list
)paren
(brace
id|nd
op_assign
id|list_entry
c_func
(paren
id|lhp
comma
r_struct
id|node_data
comma
id|global_node_list
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|nd-&gt;devfs_handle
)paren
suffix:semicolon
)brace
)brace
DECL|function|new_node
r_struct
id|node_data
op_star
id|new_node
c_func
(paren
r_void
)paren
(brace
r_struct
id|node_data
op_star
id|node
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|node
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|node_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|node-&gt;global_node_list
comma
op_amp
id|global_node_list
)paren
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
DECL|function|dma_cleanup
r_void
id|dma_cleanup
c_func
(paren
r_struct
id|node_data
op_star
id|dma_node
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: should free these allocations */
macro_line|#ifdef DEBUG_PCIBA
id|dump_allocations
c_func
(paren
op_amp
id|dma_node-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
macro_line|#endif
id|devfs_unregister
c_func
(paren
id|dma_node-&gt;devfs_handle
)paren
suffix:semicolon
)brace
DECL|function|init_dma_node
r_void
id|init_dma_node
c_func
(paren
r_struct
id|node_data
op_star
id|node
comma
r_struct
id|pci_dev
op_star
id|dev
comma
id|devfs_handle_t
id|dh
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|node-&gt;devfs_handle
op_assign
id|dh
suffix:semicolon
id|node-&gt;u.dma.dev
op_assign
id|dev
suffix:semicolon
id|node-&gt;cleanup
op_assign
id|dma_cleanup
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|node-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
)brace
DECL|function|rom_cleanup
r_void
id|rom_cleanup
c_func
(paren
r_struct
id|node_data
op_star
id|rom_node
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rom_node-&gt;u.rom.mmapped
)paren
id|pci_write_config_dword
c_func
(paren
id|rom_node-&gt;u.rom.dev
comma
id|PCI_ROM_ADDRESS
comma
id|rom_node-&gt;u.rom.saved_rom_base_reg
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|rom_node-&gt;devfs_handle
)paren
suffix:semicolon
)brace
DECL|function|init_rom_node
r_void
id|init_rom_node
c_func
(paren
r_struct
id|node_data
op_star
id|node
comma
r_struct
id|pci_dev
op_star
id|dev
comma
id|devfs_handle_t
id|dh
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|node-&gt;devfs_handle
op_assign
id|dh
suffix:semicolon
id|node-&gt;u.rom.dev
op_assign
id|dev
suffix:semicolon
id|node-&gt;cleanup
op_assign
id|rom_cleanup
suffix:semicolon
id|node-&gt;u.rom.mmapped
op_assign
l_bool|false
suffix:semicolon
)brace
r_static
id|status
id|__init
DECL|function|register_pci_device
id|register_pci_device
c_func
(paren
id|devfs_handle_t
id|device_dir_handle
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
r_char
id|devfs_path
(braket
l_int|20
)braket
suffix:semicolon
id|devfs_handle_t
id|node_devfs_handle
suffix:semicolon
r_int
id|ri
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* register nodes for all the device&squot;s base address registers */
r_for
c_loop
(paren
id|ri
op_assign
l_int|0
suffix:semicolon
id|ri
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|ri
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_resource_len
c_func
(paren
id|dev
comma
id|ri
)paren
op_ne
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|devfs_path
comma
l_string|&quot;base/%d&quot;
comma
id|ri
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
id|devfs_path
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|base_fops
comma
op_amp
id|dev-&gt;resource
(braket
id|ri
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
)brace
)brace
multiline_comment|/* register a node corresponding to the first MEM resource on&n;           the device */
r_for
c_loop
(paren
id|ri
op_assign
l_int|0
suffix:semicolon
id|ri
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|ri
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|ri
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
op_logical_and
id|pci_resource_len
c_func
(paren
id|dev
comma
id|ri
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
l_string|&quot;mem&quot;
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|base_fops
comma
op_amp
id|dev-&gt;resource
(braket
id|ri
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* also register a node corresponding to the first IO resource&n;           on the device */
r_for
c_loop
(paren
id|ri
op_assign
l_int|0
suffix:semicolon
id|ri
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|ri
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|ri
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
op_logical_and
id|pci_resource_len
c_func
(paren
id|dev
comma
id|ri
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
l_string|&quot;io&quot;
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|base_fops
comma
op_amp
id|dev-&gt;resource
(braket
id|ri
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* register a node corresponding to the device&squot;s ROM resource,&n;           if present */
r_if
c_cond
(paren
id|pci_resource_len
c_func
(paren
id|dev
comma
id|PCI_ROM_RESOURCE
)paren
op_ne
l_int|0
)paren
(brace
id|nd
op_assign
id|new_node
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
id|node_devfs_handle
op_assign
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
l_string|&quot;rom&quot;
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
comma
op_amp
id|rom_fops
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node_devfs_handle
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
id|init_rom_node
c_func
(paren
id|nd
comma
id|dev
comma
id|node_devfs_handle
)paren
suffix:semicolon
)brace
multiline_comment|/* register a node that allows ioctl&squot;s to read and write to&n;           the device&squot;s config space */
r_if
c_cond
(paren
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
l_string|&quot;config&quot;
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|config_fops
comma
id|dev
)paren
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
multiline_comment|/* finally, register a node that allows ioctl&squot;s to allocate&n;           and free DMA buffers, as well as memory map those&n;           buffers. */
id|nd
op_assign
id|new_node
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
id|node_devfs_handle
op_assign
id|devfs_register
c_func
(paren
id|device_dir_handle
comma
l_string|&quot;dma&quot;
comma
id|DEVFS_FL_NONE
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|dma_fops
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node_devfs_handle
op_eq
l_int|NULL
)paren
r_return
id|failure
suffix:semicolon
id|init_dma_node
c_func
(paren
id|nd
comma
id|dev
comma
id|node_devfs_handle
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PCIBA
id|dump_nodes
c_func
(paren
op_amp
id|global_node_list
)paren
suffix:semicolon
macro_line|#endif
r_return
id|success
suffix:semicolon
)brace
r_static
r_int
DECL|function|generic_open
id|generic_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|TRACE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: should check that they&squot;re not trying to open the ROM&n;           writable */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
r_static
r_int
DECL|function|rom_mmap
id|rom_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_int
r_int
id|pci_pa
suffix:semicolon
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|nd
op_assign
(paren
r_struct
id|node_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|pci_pa
op_assign
id|pci_resource_start
c_func
(paren
id|nd-&gt;u.rom.dev
comma
id|PCI_ROM_RESOURCE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nd-&gt;u.rom.mmapped
)paren
(brace
id|nd-&gt;u.rom.mmapped
op_assign
l_bool|true
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;Enabling ROM address decoder.&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;rom_mmap: FIXME: some cards do not allow both ROM and memory addresses to&bslash;n&quot;
l_string|&quot;rom_mmap: FIXME: be enabled simultaneously, as they share a decoder.&bslash;n&quot;
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|nd-&gt;u.rom.dev
comma
id|PCI_ROM_ADDRESS
comma
op_amp
id|nd-&gt;u.rom.saved_rom_base_reg
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;ROM base address contains %x&bslash;n&quot;
comma
id|nd-&gt;u.rom.saved_rom_base_reg
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|nd-&gt;u.rom.dev
comma
id|PCI_ROM_ADDRESS
comma
id|nd-&gt;u.rom.saved_rom_base_reg
op_or
id|PCI_ROM_ADDRESS_ENABLE
)paren
suffix:semicolon
)brace
r_return
id|mmap_pci_address
c_func
(paren
id|vma
comma
id|pci_pa
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|rom_release
id|rom_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|nd
op_assign
(paren
r_struct
id|node_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;u.rom.mmapped
)paren
(brace
id|nd-&gt;u.rom.mmapped
op_assign
l_bool|false
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;Disabling ROM address decoder.&bslash;n&quot;
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|nd-&gt;u.rom.dev
comma
id|PCI_ROM_ADDRESS
comma
id|nd-&gt;u.rom.saved_rom_base_reg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* indicate success */
)brace
r_static
r_int
DECL|function|base_mmap
id|base_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|resource
op_star
id|resource
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|resource
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|mmap_pci_address
c_func
(paren
id|vma
comma
id|resource-&gt;start
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|config_ioctl
id|config_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_union
id|cfg_data
(brace
r_uint8
id|byte
suffix:semicolon
r_uint16
id|word
suffix:semicolon
r_uint32
id|dword
suffix:semicolon
)brace
id|read_data
comma
id|write_data
suffix:semicolon
r_int
id|dir
comma
id|size
comma
id|offset
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;cmd = %x (DIR = %x, TYPE = %x, NR = %x, SIZE = %x)&bslash;n&quot;
comma
id|cmd
comma
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
comma
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
comma
id|_IOC_NR
c_func
(paren
id|cmd
)paren
comma
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;arg = %lx&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|pci_dev
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* PCIIOCCFG{RD,WR}: read and/or write PCI configuration&n;&t;   space. If both, the read happens first (this becomes a swap&n;&t;   operation, atomic with respect to other updates through&n;&t;   this path).  */
id|dir
op_assign
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
suffix:semicolon
DECL|macro|do_swap
mdefine_line|#define do_swap(suffix, type)&t; &t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (dir &amp; _IOC_READ) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;pci_read_config_##suffix(dev, _IOC_NR(cmd), &t;&bslash;&n;&t;&t;&t;&t;&t;&t; &amp;read_data.suffix);&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (dir &amp; _IOC_WRITE) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;get_user(write_data.suffix, (type)arg);&t;&t;&bslash;&n;&t;&t;&t;pci_write_config_##suffix(dev, _IOC_NR(cmd), &t;&bslash;&n;&t;&t;&t;&t;&t;&t;  write_data.suffix);&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (dir &amp; _IOC_READ) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;put_user(read_data.suffix, (type)arg);&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
id|size
op_assign
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|offset
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;sanity check&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|size
OG
l_int|0
)paren
op_logical_or
(paren
id|size
op_le
l_int|4
)paren
)paren
op_logical_and
(paren
(paren
id|offset
op_plus
id|size
)paren
op_le
l_int|256
)paren
op_logical_and
(paren
id|dir
op_amp
(paren
id|_IOC_READ
op_or
id|_IOC_WRITE
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
id|do_swap
c_func
(paren
id|byte
comma
r_uint8
op_star
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|do_swap
c_func
(paren
id|word
comma
r_uint16
op_star
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|do_swap
c_func
(paren
id|dword
comma
r_uint32
op_star
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINTF
c_func
(paren
l_string|&quot;invalid ioctl&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PCIBA
r_static
r_void
DECL|function|dump_allocations
id|dump_allocations
c_func
(paren
r_struct
id|list_head
op_star
id|dalp
)paren
(brace
r_struct
id|dma_allocation
op_star
id|dap
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
id|dalp
)paren
(brace
id|dap
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|dma_allocation
comma
id|list
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  handle = %lx, va = %p&bslash;n&quot;
comma
id|dap-&gt;handle
comma
id|dap-&gt;va
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dump_nodes
id|dump_nodes
c_func
(paren
r_struct
id|list_head
op_star
id|nodes
)paren
(brace
r_struct
id|node_data
op_star
id|ndp
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
id|nodes
)paren
(brace
id|ndp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|node_data
comma
id|global_node_list
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ndp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if 0
mdefine_line|#define NEW(ptr) (ptr = kmalloc(sizeof (*(ptr)), GFP_KERNEL))
r_static
r_void
id|test_list
c_func
(paren
r_void
)paren
(brace
id|u64
id|i
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|the_list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dma_allocation
op_star
id|new_alloc
suffix:semicolon
id|NEW
c_func
(paren
id|new_alloc
)paren
suffix:semicolon
id|new_alloc-&gt;va
op_assign
(paren
r_void
op_star
)paren
id|i
suffix:semicolon
id|new_alloc-&gt;handle
op_assign
l_int|5
op_star
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d - the_list-&gt;next = %lx&bslash;n&quot;
comma
id|i
comma
id|the_list.next
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_alloc-&gt;list
comma
op_amp
id|the_list
)paren
suffix:semicolon
)brace
id|dump_allocations
c_func
(paren
op_amp
id|the_list
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
r_static
id|LIST_HEAD
c_func
(paren
id|dma_buffer_list
)paren
suffix:semicolon
r_static
r_int
DECL|function|dma_ioctl
id|dma_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
r_uint64
id|argv
suffix:semicolon
r_int
id|result
suffix:semicolon
r_struct
id|dma_allocation
op_star
id|dma_alloc
suffix:semicolon
r_struct
id|list_head
op_star
id|iterp
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;cmd = %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;arg = %lx&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
id|nd
op_assign
(paren
r_struct
id|node_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
macro_line|#ifdef DEBUG_PCIBA
id|DPRINTF
c_func
(paren
l_string|&quot;at dma_ioctl entry&bslash;n&quot;
)paren
suffix:semicolon
id|dump_allocations
c_func
(paren
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PCIIOCDMAALLOC
suffix:colon
multiline_comment|/* PCIIOCDMAALLOC: allocate a chunk of physical memory&n;&t;&t;   and set it up for DMA. Return the PCI address that&n;&t;&t;   gets to it.  */
id|DPRINTF
c_func
(paren
l_string|&quot;case PCIIOCDMAALLOC (%lx)&bslash;n&quot;
comma
id|PCIIOCDMAALLOC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_user
c_func
(paren
id|argv
comma
(paren
r_uint64
op_star
)paren
id|arg
)paren
)paren
)paren
r_return
id|result
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;argv (size of buffer) = %lx&bslash;n&quot;
comma
id|argv
)paren
suffix:semicolon
id|dma_alloc
op_assign
(paren
r_struct
id|dma_allocation
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dma_allocation
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_alloc
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dma_alloc-&gt;size
op_assign
(paren
r_int
)paren
id|argv
suffix:semicolon
id|dma_alloc-&gt;va
op_assign
id|pci_alloc_consistent
c_func
(paren
id|nd-&gt;u.dma.dev
comma
id|dma_alloc-&gt;size
comma
op_amp
id|dma_alloc-&gt;handle
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;dma_alloc-&gt;va = %p, dma_alloc-&gt;handle = %lx&bslash;n&quot;
comma
id|dma_alloc-&gt;va
comma
id|dma_alloc-&gt;handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_alloc-&gt;va
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|dma_alloc
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|dma_alloc-&gt;list
comma
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|put_user
c_func
(paren
(paren
r_uint64
)paren
id|dma_alloc-&gt;handle
comma
(paren
r_uint64
op_star
)paren
id|arg
)paren
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
l_string|&quot;put_user failed&bslash;n&quot;
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|nd-&gt;u.dma.dev
comma
(paren
r_int
)paren
id|argv
comma
id|dma_alloc-&gt;va
comma
id|dma_alloc-&gt;handle
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dma_alloc
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PCIBA
id|DPRINTF
c_func
(paren
l_string|&quot;after insertion&bslash;n&quot;
)paren
suffix:semicolon
id|dump_allocations
c_func
(paren
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PCIIOCDMAFREE
suffix:colon
id|DPRINTF
c_func
(paren
l_string|&quot;case PCIIOCDMAFREE (%lx)&bslash;n&quot;
comma
id|PCIIOCDMAFREE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_user
c_func
(paren
id|argv
comma
(paren
r_uint64
op_star
)paren
id|arg
)paren
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
l_string|&quot;get_user failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
l_string|&quot;argv (physical address of DMA buffer) = %lx&bslash;n&quot;
comma
id|argv
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|iterp
comma
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
(brace
r_struct
id|dma_allocation
op_star
id|da
op_assign
id|list_entry
c_func
(paren
id|iterp
comma
r_struct
id|dma_allocation
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|da-&gt;handle
op_eq
id|argv
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|nd-&gt;u.dma.dev
comma
id|da-&gt;size
comma
id|da-&gt;va
comma
id|da-&gt;handle
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|da-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|da
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PCIBA
id|DPRINTF
c_func
(paren
l_string|&quot;after deletion&bslash;n&quot;
)paren
suffix:semicolon
id|dump_allocations
c_func
(paren
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
)brace
multiline_comment|/* previously allocated dma buffer wasn&squot;t found */
id|DPRINTF
c_func
(paren
l_string|&quot;attempt to free invalid dma handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
id|DPRINTF
c_func
(paren
l_string|&quot;undefined ioctl&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|dma_mmap
id|dma_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|node_data
op_star
id|nd
suffix:semicolon
r_struct
id|list_head
op_star
id|iterp
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|nd
op_assign
(paren
r_struct
id|node_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_start is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_end is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;offset = %lx&bslash;n&quot;
comma
id|vma-&gt;vm_pgoff
)paren
suffix:semicolon
multiline_comment|/* get kernel virtual address for the dma buffer (necessary&n;&t; * for the mmap). */
id|list_for_each
c_func
(paren
id|iterp
comma
op_amp
id|nd-&gt;u.dma.dma_allocs
)paren
(brace
r_struct
id|dma_allocation
op_star
id|da
op_assign
id|list_entry
c_func
(paren
id|iterp
comma
r_struct
id|dma_allocation
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* why does mmap shift its offset argument? */
r_if
c_cond
(paren
id|da-&gt;handle
op_eq
id|vma-&gt;vm_pgoff
op_lshift
id|PAGE_SHIFT
)paren
(brace
id|DPRINTF
c_func
(paren
l_string|&quot;found dma handle&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|mmap_kernel_address
c_func
(paren
id|vma
comma
id|da-&gt;va
)paren
)paren
)paren
(brace
r_return
id|result
suffix:semicolon
multiline_comment|/* failure */
)brace
r_else
(brace
multiline_comment|/* it seems like at least one of these&n;&t;&t;&t;&t;   should show up in user land....&n;&t;&t;&t;&t;   I&squot;m missing something */
op_star
(paren
r_char
op_star
)paren
id|da-&gt;va
op_assign
l_int|0xaa
suffix:semicolon
id|strncpy
c_func
(paren
id|da-&gt;va
comma
l_string|&quot;        Toastie!&quot;
comma
id|da-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0x18badbeeful
comma
(paren
id|u64
op_star
)paren
id|vma-&gt;vm_start
)paren
)paren
id|DPRINTF
c_func
(paren
l_string|&quot;put_user failed?!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
)brace
)brace
id|DPRINTF
c_func
(paren
l_string|&quot;attempt to mmap an invalid dma handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_int
DECL|function|mmap_pci_address
id|mmap_pci_address
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|pci_va
)paren
(brace
r_int
r_int
id|pci_pa
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_start is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_end is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
multiline_comment|/* the size of the vma doesn&squot;t necessarily correspond to the&n;           size specified in the mmap call.  So we can&squot;t really do any&n;           kind of sanity check here.  This is a dangerous driver, and&n;           it&squot;s very easy for a user process to kill the machine.  */
id|DPRINTF
c_func
(paren
l_string|&quot;PCI base at virtual address %lx&bslash;n&quot;
comma
id|pci_va
)paren
suffix:semicolon
multiline_comment|/* the __pa macro is intended for region 7 on IA64, so it&n;&t;   doesn&squot;t work for region 6 */
multiline_comment|/* pci_pa = __pa(pci_va); */
multiline_comment|/* should be replaced by __tpa or equivalent (preferably a&n;&t;   generic equivalent) */
id|pci_pa
op_assign
id|pci_va
op_amp
op_complement
l_int|0xe000000000000000ul
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;PCI base at physical address %lx&bslash;n&quot;
comma
id|pci_pa
)paren
suffix:semicolon
multiline_comment|/* there are various arch-specific versions of this function&n;           defined in linux/drivers/char/mem.c, but it would be nice&n;           if all architectures put it in pgtable.h.  it&squot;s defined&n;           there for ia64.... */
id|vma-&gt;vm_page_prot
op_assign
id|pgprot_noncached
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|VM_NONCACHED
op_or
id|VM_RESERVED
op_or
id|VM_IO
suffix:semicolon
r_return
id|io_remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|pci_pa
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mmap_kernel_address
id|mmap_kernel_address
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_void
op_star
id|kernel_va
)paren
(brace
r_int
r_int
id|kernel_pa
suffix:semicolon
id|TRACE
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_start is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;vma-&gt;vm_end is %lx&bslash;n&quot;
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
multiline_comment|/* the size of the vma doesn&squot;t necessarily correspond to the&n;           size specified in the mmap call.  So we can&squot;t really do any&n;           kind of sanity check here.  This is a dangerous driver, and&n;           it&squot;s very easy for a user process to kill the machine.  */
id|DPRINTF
c_func
(paren
l_string|&quot;mapping virtual address %p&bslash;n&quot;
comma
id|kernel_va
)paren
suffix:semicolon
id|kernel_pa
op_assign
id|__pa
c_func
(paren
id|kernel_va
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;mapping physical address %lx&bslash;n&quot;
comma
id|kernel_pa
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|VM_NONCACHED
op_or
id|VM_RESERVED
op_or
id|VM_IO
suffix:semicolon
r_return
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|kernel_pa
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
)brace
eof
