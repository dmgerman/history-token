multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/ioerror_handling.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/sn1/bedrock.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
macro_line|#include &lt;asm/sn/sn1/hubio.h&gt;
macro_line|#include &lt;asm/sn/sn1/hubio_next.h&gt;
macro_line|#endif
DECL|macro|copyin
mdefine_line|#define copyin(_a, _b, _c)&t;copy_from_user(_b, _a, _c)
macro_line|#ifndef&t;DEBUG_PCIBA
DECL|macro|DEBUG_PCIBA
mdefine_line|#define&t;DEBUG_PCIBA&t;&t;0
macro_line|#endif
multiline_comment|/* v_mapphys does not percolate page offset back. */
DECL|macro|PCIBA_ALIGN_CHECK
mdefine_line|#define&t;PCIBA_ALIGN_CHECK&t;1
macro_line|#include &lt;asm/sn/pci/pciba.h&gt;
multiline_comment|/* grab an unused space code for &quot;User DMA&quot; space */
macro_line|#ifndef&t;PCIBA_SPACE_UDMA
DECL|macro|PCIBA_SPACE_UDMA
mdefine_line|#define&t;PCIBA_SPACE_UDMA&t;(14)
macro_line|#endif
macro_line|#if DEBUG_REFCT
r_extern
r_int
id|hwgraph_vertex_refct
c_func
(paren
id|vertex_hdl_t
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|pci_user_dma_max_pages
suffix:semicolon
DECL|macro|NEW
mdefine_line|#define NEW(ptr)&t;(ptr = kmem_zalloc(sizeof (*(ptr)), KM_SLEEP))
DECL|macro|DEL
mdefine_line|#define DEL(ptr)&t;(kfree(ptr))
multiline_comment|/* Oops -- no standard &quot;pci address&quot; type! */
DECL|typedef|pciaddr_t
r_typedef
r_uint64
id|pciaddr_t
suffix:semicolon
multiline_comment|/* ================================================================&n; *            driver types&n; */
DECL|typedef|pciba_slot_t
r_typedef
r_struct
id|pciba_slot_s
op_star
id|pciba_slot_t
suffix:semicolon
DECL|typedef|pciba_comm_t
r_typedef
r_struct
id|pciba_comm_s
op_star
id|pciba_comm_t
suffix:semicolon
DECL|typedef|pciba_soft_t
r_typedef
r_struct
id|pciba_soft_s
op_star
id|pciba_soft_t
suffix:semicolon
DECL|typedef|pciba_map_t
DECL|typedef|pciba_map_h
r_typedef
r_struct
id|pciba_map_s
op_star
id|pciba_map_t
comma
op_star
op_star
id|pciba_map_h
suffix:semicolon
DECL|typedef|pciba_dma_t
DECL|typedef|pciba_dma_h
r_typedef
r_struct
id|pciba_dma_s
op_star
id|pciba_dma_t
comma
op_star
op_star
id|pciba_dma_h
suffix:semicolon
DECL|typedef|pciba_bus_t
r_typedef
r_struct
id|pciba_bus_s
op_star
id|pciba_bus_t
suffix:semicolon
DECL|macro|TRACKED_SPACES
mdefine_line|#define&t;TRACKED_SPACES&t;16
DECL|struct|pciba_comm_s
r_struct
id|pciba_comm_s
(brace
DECL|member|conn
id|devfs_handle_t
id|conn
suffix:semicolon
DECL|member|bus
id|pciba_bus_t
id|bus
suffix:semicolon
DECL|member|refct
r_int
id|refct
suffix:semicolon
DECL|member|soft
id|pciba_soft_t
id|soft
(braket
id|TRACKED_SPACES
)braket
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|dmap
id|pciba_dma_t
id|dmap
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* pciba_soft: device_info() for all openables */
DECL|struct|pciba_soft_s
r_struct
id|pciba_soft_s
(brace
DECL|member|comm
id|pciba_comm_t
id|comm
suffix:semicolon
DECL|member|vhdl
id|devfs_handle_t
id|vhdl
suffix:semicolon
DECL|member|refct
r_int
id|refct
suffix:semicolon
DECL|member|space
id|pciio_space_t
id|space
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|iomem
id|pciio_space_t
id|iomem
suffix:semicolon
DECL|member|base
id|pciaddr_t
id|base
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|pciba_soft_get
mdefine_line|#define&t;pciba_soft_get(v)&t;(pciba_soft_t)hwgraph_fastinfo_get(v)
DECL|macro|pciba_soft_set
mdefine_line|#define&t;pciba_soft_set(v,i)&t;hwgraph_fastinfo_set(v,(arbitrary_info_t)(i))
DECL|macro|pciba_soft_lock
mdefine_line|#define&t;pciba_soft_lock(soft)&t;down(&amp;soft-&gt;comm-&gt;lock)
DECL|macro|pciba_soft_unlock
mdefine_line|#define&t;pciba_soft_unlock(soft)&t;up(&amp;soft-&gt;comm-&gt;lock)
multiline_comment|/* pciba_map: data describing a mapping.&n; * (ie. a user mmap request)&n; */
DECL|struct|pciba_map_s
r_struct
id|pciba_map_s
(brace
DECL|member|next
id|pciba_map_t
id|next
suffix:semicolon
macro_line|#ifdef LATER
DECL|member|uthread
id|uthread_t
op_star
id|uthread
suffix:semicolon
macro_line|#endif
DECL|member|handle
id|__psunsigned_t
id|handle
suffix:semicolon
DECL|member|uvaddr
id|uvaddr_t
id|uvaddr
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|map
id|pciio_piomap_t
id|map
suffix:semicolon
DECL|member|space
id|pciio_space_t
id|space
suffix:semicolon
DECL|member|base
id|pciaddr_t
id|base
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* pciba_dma: data describing a DMA mapping.&n; */
DECL|struct|pciba_dma_s
r_struct
id|pciba_dma_s
(brace
DECL|member|next
id|pciba_dma_t
id|next
suffix:semicolon
DECL|member|paddr
id|iopaddr_t
id|paddr
suffix:semicolon
multiline_comment|/* starting phys addr */
DECL|member|kaddr
id|caddr_t
id|kaddr
suffix:semicolon
multiline_comment|/* starting kern addr */
DECL|member|map
id|pciio_dmamap_t
id|map
suffix:semicolon
multiline_comment|/* mapping resources (ugh!) */
DECL|member|daddr
id|pciaddr_t
id|daddr
suffix:semicolon
multiline_comment|/* starting pci addr */
DECL|member|pages
r_int
id|pages
suffix:semicolon
multiline_comment|/* size of block in pages */
DECL|member|bytes
r_int
id|bytes
suffix:semicolon
multiline_comment|/* size of block in bytes */
DECL|member|handle
id|__psunsigned_t
id|handle
suffix:semicolon
multiline_comment|/* mapping handle */
)brace
suffix:semicolon
multiline_comment|/* pciba_bus: common bus info for all openables&n; * descended from the same master vertex.&n; */
DECL|struct|pciba_bus_s
r_struct
id|pciba_bus_s
(brace
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|maps
id|pciba_map_t
id|maps
suffix:semicolon
multiline_comment|/* stack of mappings */
DECL|member|refct
r_int
id|refct
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|pciba_bus_lock
mdefine_line|#define&t;pciba_bus_lock(bus)&t;down(&amp;bus-&gt;lock)
DECL|macro|pciba_bus_unlock
mdefine_line|#define&t;pciba_bus_unlock(bus)&t;up(&amp;bus-&gt;lock)
DECL|union|ioctl_arg_buffer_u
r_typedef
r_union
id|ioctl_arg_buffer_u
(brace
DECL|member|data
r_char
id|data
(braket
id|IOCPARM_MASK
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|uc
r_uint8
id|uc
suffix:semicolon
DECL|member|us
r_uint16
id|us
suffix:semicolon
DECL|member|ui
r_uint32
id|ui
suffix:semicolon
DECL|member|ud
r_uint64
id|ud
suffix:semicolon
DECL|member|ca
id|caddr_t
id|ca
suffix:semicolon
macro_line|#if ULI
DECL|member|uli
r_struct
id|uliargs
id|uli
suffix:semicolon
DECL|member|uli32
r_struct
id|uliargs32
id|uli32
suffix:semicolon
macro_line|#endif
DECL|typedef|ioctl_arg_buffer_t
)brace
id|ioctl_arg_buffer_t
suffix:semicolon
multiline_comment|/* ================================================================&n; *            driver variables&n; */
DECL|variable|pciba_mversion
r_char
op_star
id|pciba_mversion
op_assign
l_string|&quot;mload version 7.0&quot;
suffix:semicolon
DECL|variable|pciba_devflag
r_int
id|pciba_devflag
op_assign
l_int|0x1
op_or
l_int|0x200
op_or
l_int|0x400
suffix:semicolon
multiline_comment|/* this counts the reasons why we can not&n; * currently unload this driver.&n; */
DECL|variable|pciba_prevent_unload
id|atomic_t
id|pciba_prevent_unload
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
DECL|variable|space_v
r_static
r_struct
id|reg_values
id|space_v
(braket
)braket
op_assign
(brace
(brace
id|PCIIO_SPACE_NONE
comma
l_string|&quot;none&quot;
)brace
comma
(brace
id|PCIIO_SPACE_ROM
comma
l_string|&quot;ROM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_IO
comma
l_string|&quot;I/O&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM
comma
l_string|&quot;MEM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM32
comma
l_string|&quot;MEM(32)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM64
comma
l_string|&quot;MEM(64)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_CFG
comma
l_string|&quot;CFG&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
comma
l_string|&quot;WIN(0)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|1
)paren
comma
l_string|&quot;WIN(1)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|2
)paren
comma
l_string|&quot;WIN(2)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|3
)paren
comma
l_string|&quot;WIN(3)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|4
)paren
comma
l_string|&quot;WIN(4)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|5
)paren
comma
l_string|&quot;WIN(5)&quot;
)brace
comma
(brace
id|PCIBA_SPACE_UDMA
comma
l_string|&quot;UDMA&quot;
)brace
comma
(brace
id|PCIIO_SPACE_BAD
comma
l_string|&quot;BAD&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|space_desc
r_static
r_struct
id|reg_desc
id|space_desc
(braket
)braket
op_assign
(brace
(brace
l_int|0xFF
comma
l_int|0
comma
l_string|&quot;space&quot;
comma
l_int|0
comma
id|space_v
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|pciba_edge_lbl_base
r_char
id|pciba_edge_lbl_base
(braket
)braket
op_assign
l_string|&quot;base&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_cfg
r_char
id|pciba_edge_lbl_cfg
(braket
)braket
op_assign
l_string|&quot;config&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_dma
r_char
id|pciba_edge_lbl_dma
(braket
)braket
op_assign
l_string|&quot;dma&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_intr
r_char
id|pciba_edge_lbl_intr
(braket
)braket
op_assign
l_string|&quot;intr&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_io
r_char
id|pciba_edge_lbl_io
(braket
)braket
op_assign
l_string|&quot;io&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_mem
r_char
id|pciba_edge_lbl_mem
(braket
)braket
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_rom
r_char
id|pciba_edge_lbl_rom
(braket
)braket
op_assign
l_string|&quot;rom&quot;
suffix:semicolon
DECL|variable|pciba_edge_lbl_win
r_char
op_star
id|pciba_edge_lbl_win
(braket
l_int|6
)braket
op_assign
(brace
l_string|&quot;0&quot;
comma
l_string|&quot;1&quot;
comma
l_string|&quot;2&quot;
comma
l_string|&quot;3&quot;
comma
l_string|&quot;4&quot;
comma
l_string|&quot;5&quot;
)brace
suffix:semicolon
DECL|macro|PCIBA_EDGE_LBL_BASE
mdefine_line|#define&t;PCIBA_EDGE_LBL_BASE&t;pciba_edge_lbl_base
DECL|macro|PCIBA_EDGE_LBL_CFG
mdefine_line|#define&t;PCIBA_EDGE_LBL_CFG&t;pciba_edge_lbl_cfg
DECL|macro|PCIBA_EDGE_LBL_DMA
mdefine_line|#define&t;PCIBA_EDGE_LBL_DMA&t;pciba_edge_lbl_dma
DECL|macro|PCIBA_EDGE_LBL_INTR
mdefine_line|#define&t;PCIBA_EDGE_LBL_INTR&t;pciba_edge_lbl_intr
DECL|macro|PCIBA_EDGE_LBL_IO
mdefine_line|#define&t;PCIBA_EDGE_LBL_IO&t;pciba_edge_lbl_io
DECL|macro|PCIBA_EDGE_LBL_MEM
mdefine_line|#define&t;PCIBA_EDGE_LBL_MEM&t;pciba_edge_lbl_mem
DECL|macro|PCIBA_EDGE_LBL_ROM
mdefine_line|#define&t;PCIBA_EDGE_LBL_ROM&t;pciba_edge_lbl_rom
DECL|macro|PCIBA_EDGE_LBL_WIN
mdefine_line|#define&t;PCIBA_EDGE_LBL_WIN(n)&t;pciba_edge_lbl_win[n]
DECL|macro|PCIBA_EDGE_LBL_FLIP
mdefine_line|#define&t;PCIBA_EDGE_LBL_FLIP&t;pciba_edge_lbl_flip
DECL|variable|pciba_info_lbl_bus
r_static
r_char
id|pciba_info_lbl_bus
(braket
)braket
op_assign
l_string|&quot;pciba_bus&quot;
suffix:semicolon
DECL|macro|PCIBA_INFO_LBL_BUS
mdefine_line|#define&t;PCIBA_INFO_LBL_BUS&t;pciba_info_lbl_bus
DECL|variable|pciba_fops
r_struct
id|file_operations
id|pciba_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
l_int|NULL
comma
id|read
suffix:colon
l_int|NULL
comma
id|write
suffix:colon
l_int|NULL
comma
id|readdir
suffix:colon
l_int|NULL
comma
id|poll
suffix:colon
l_int|NULL
comma
id|ioctl
suffix:colon
l_int|NULL
comma
id|mmap
suffix:colon
l_int|NULL
comma
id|open
suffix:colon
l_int|NULL
comma
id|flush
suffix:colon
l_int|NULL
comma
id|release
suffix:colon
l_int|NULL
comma
id|fsync
suffix:colon
l_int|NULL
comma
id|fasync
suffix:colon
l_int|NULL
comma
id|lock
suffix:colon
l_int|NULL
comma
id|readv
suffix:colon
l_int|NULL
comma
id|writev
suffix:colon
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* ================================================================&n; *            function table of contents&n; */
r_void
id|pciba_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|pciba_attach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_static
r_void
id|pciba_sub_attach
c_func
(paren
id|pciba_comm_t
comma
id|pciio_space_t
comma
id|pciio_space_t
comma
id|pciaddr_t
comma
id|devfs_handle_t
comma
id|devfs_handle_t
comma
r_char
op_star
)paren
suffix:semicolon
r_static
id|pciba_bus_t
id|pciba_find_bus
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef LATER
r_static
r_void
id|pciba_map_push
c_func
(paren
id|pciba_bus_t
comma
id|pciba_map_t
)paren
suffix:semicolon
r_static
id|pciba_map_t
id|pciba_map_pop_hdl
c_func
(paren
id|pciba_bus_t
comma
id|__psunsigned_t
)paren
suffix:semicolon
r_static
r_void
id|pciba_sub_detach
c_func
(paren
id|devfs_handle_t
comma
r_char
op_star
)paren
suffix:semicolon
DECL|variable|pciba_unload_me
r_static
id|pciio_iter_f
id|pciba_unload_me
suffix:semicolon
macro_line|#endif
r_int
id|pciba_unload
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|pciba_unreg
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|pciba_detach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pciba_open
c_func
(paren
id|dev_t
op_star
comma
r_int
comma
r_int
comma
r_struct
id|cred
op_star
)paren
suffix:semicolon
r_int
id|pciba_close
c_func
(paren
id|dev_t
)paren
suffix:semicolon
r_int
id|pciba_read
c_func
(paren
id|dev_t
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|pciba_write
c_func
(paren
id|dev_t
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|pciba_ioctl
c_func
(paren
id|dev_t
comma
r_int
comma
r_void
op_star
comma
r_int
comma
id|cred_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pciba_map
c_func
(paren
id|dev_t
comma
id|vhandl_t
op_star
comma
id|off_t
comma
r_int
comma
r_uint32
)paren
suffix:semicolon
r_int
id|pciba_unmap
c_func
(paren
id|dev_t
comma
id|vhandl_t
op_star
)paren
suffix:semicolon
macro_line|#if ULI
r_void
id|pciba_clearuli
c_func
(paren
r_struct
id|uli
op_star
)paren
suffix:semicolon
DECL|variable|pciba_intr
r_static
id|intr_func_f
id|pciba_intr
suffix:semicolon
macro_line|#endif /* Undef as it gets implemented */
multiline_comment|/* ================================================================&n; *            driver load, register, and setup&n; */
r_void
DECL|function|pciba_init
id|pciba_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * What do we need to do here?&n;&t; */
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef LATER
macro_line|#if HWG_PERF_CHECK &amp;&amp; IP30 &amp;&amp; !DEBUG
r_void
DECL|function|pciba_timeout
id|pciba_timeout
c_func
(paren
r_void
op_star
id|arg1
comma
r_void
op_star
id|arg2
)paren
(brace
r_struct
id|semaphore
op_star
id|semap
op_assign
(paren
id|sema_t
op_star
)paren
id|arg1
suffix:semicolon
r_int
r_int
op_star
id|cvalp
op_assign
(paren
r_int
r_int
op_star
)paren
id|arg2
suffix:semicolon
r_if
c_cond
(paren
id|cvalp
)paren
id|cvalp
(braket
l_int|0
)braket
op_assign
id|RAW_COUNT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|semap
)paren
id|up
c_func
(paren
id|semap
)paren
suffix:semicolon
)brace
DECL|variable|cNval
r_volatile
r_int
r_int
id|cNval
(braket
l_int|1
)braket
suffix:semicolon
DECL|variable|tsema
r_struct
id|semaphore
id|tsema
suffix:semicolon
r_void
DECL|function|pciba_timeout_test
id|pciba_timeout_test
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|c0val
comma
id|cval
suffix:semicolon
id|toid_t
id|tid
suffix:semicolon
r_extern
r_void
id|hwg_hprint
c_func
(paren
r_int
r_int
comma
r_char
op_star
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|tsema
comma
l_int|0
)paren
suffix:semicolon
id|cNval
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|c0val
op_assign
id|RAW_COUNT
c_func
(paren
)paren
suffix:semicolon
id|tid
op_assign
id|timeout
c_func
(paren
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|pciba_timeout
comma
(paren
r_void
op_star
)paren
l_int|0
comma
l_int|1
comma
(paren
r_void
op_star
)paren
id|cNval
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
id|cval
op_assign
id|cNval
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cval
op_eq
l_int|0
)paren
(brace
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|PRINT_ALERT
c_func
(paren
l_string|&quot;pciba: one-tick timeout did not happen in a second&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cval
op_assign
id|cval
op_minus
id|c0val
suffix:semicolon
id|hwg_hprint
c_func
(paren
id|cval
comma
l_string|&quot;timeout(1)&quot;
)paren
suffix:semicolon
id|cNval
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|c0val
op_assign
id|RAW_COUNT
c_func
(paren
)paren
suffix:semicolon
id|tid
op_assign
id|timeout
c_func
(paren
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|pciba_timeout
comma
(paren
r_void
op_star
)paren
op_amp
id|tsema
comma
l_int|2
comma
(paren
r_void
op_star
)paren
id|cNval
)paren
suffix:semicolon
multiline_comment|/* FIXME : this probably needs to be down_interruptible() */
r_if
c_cond
(paren
id|down
c_func
(paren
op_amp
id|tsema
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* wait for the pciba_timeout */
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: timeout(2) time check aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cval
op_assign
id|cNval
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cval
op_eq
l_int|0
)paren
(brace
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: timeout(2) time not logged&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cval
op_assign
id|cval
op_minus
id|c0val
suffix:semicolon
id|hwg_hprint
c_func
(paren
id|cval
comma
l_string|&quot;timeout(2)&quot;
)paren
suffix:semicolon
id|cNval
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|c0val
op_assign
id|RAW_COUNT
c_func
(paren
)paren
suffix:semicolon
id|tid
op_assign
id|timeout
c_func
(paren
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|pciba_timeout
comma
(paren
r_void
op_star
)paren
op_amp
id|tsema
comma
id|HZ
comma
(paren
r_void
op_star
)paren
id|cNval
)paren
suffix:semicolon
multiline_comment|/* FIXME : this probably needs to be down_interruptible() */
r_if
c_cond
(paren
id|down
c_func
(paren
op_amp
id|tsema
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* wait for the pciba_timeout */
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: timeout(HZ) time check aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cval
op_assign
id|cNval
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cval
op_eq
l_int|0
)paren
(brace
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: timeout(HZ) time not logged&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cval
op_assign
id|cval
op_minus
id|c0val
suffix:semicolon
id|hwg_hprint
c_func
(paren
id|cval
comma
l_string|&quot;timeout(HZ)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;verifying untimeout() cancells ...&bslash;n&quot;
)paren
suffix:semicolon
id|cNval
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|tid
op_assign
id|timeout
c_func
(paren
(paren
r_void
(paren
op_star
)paren
(paren
)paren
)paren
id|pciba_timeout
comma
(paren
r_void
op_star
)paren
l_int|0
comma
l_int|2
comma
(paren
r_void
op_star
)paren
id|cNval
)paren
suffix:semicolon
id|untimeout
c_func
(paren
id|tid
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
id|cval
op_assign
id|cNval
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cval
op_ne
l_int|0
)paren
(brace
id|PRINT_ALERT
c_func
(paren
l_string|&quot;pciba: unable to cancel two-tick timeout&bslash;n&quot;
)paren
suffix:semicolon
id|cval
op_sub_assign
id|c0val
suffix:semicolon
id|hwg_hprint
c_func
(paren
id|cval
comma
l_string|&quot;CANCELLED timeout(2)&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_int
DECL|function|pciba_reg
id|pciba_reg
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_reg()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pciio_driver_register
c_func
(paren
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_string|&quot;pciba_&quot;
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if HWG_PERF_CHECK &amp;&amp; IP30 &amp;&amp; !DEBUG
id|printk
c_func
(paren
l_string|&quot;%s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
id|pciba_timeout_test
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_REFCT
(brace
r_char
op_star
id|cname
op_assign
l_string|&quot;pciba&quot;
suffix:semicolon
r_char
op_star
id|dname
op_assign
l_string|&quot;ptv&quot;
suffix:semicolon
r_char
op_star
id|cpath0
op_assign
l_string|&quot;node/xtalk/15&quot;
suffix:semicolon
r_char
op_star
id|uname0
op_assign
l_string|&quot;0&quot;
suffix:semicolon
r_char
op_star
id|cpath1
op_assign
l_string|&quot;node/xtalk/13&quot;
suffix:semicolon
r_char
op_star
id|uname1
op_assign
l_string|&quot;1&quot;
suffix:semicolon
id|devfs_handle_t
id|conn
suffix:semicolon
id|devfs_handle_t
id|conv
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pciba refct tests:&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|SHOWREF
mdefine_line|#define&t;SHOWREF(vhdl,func)&t;printk(&quot;ref=%d&bslash;t%s&bslash;t(%d) %v&bslash;n&quot;, hwgraph_vertex_refct(vhdl), #func, vhdl, vhdl);
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_path_add
c_func
(paren
id|hwgraph_root
comma
id|cname
comma
op_amp
id|conv
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to create conv (ret=%d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|conv
comma
id|hwgraph_path_add
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|hwgraph_root
comma
id|cpath0
comma
op_amp
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %s (ret=%d)&bslash;n&quot;
comma
id|cpath0
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_char_device_add
c_func
(paren
id|conn
comma
id|dname
comma
l_string|&quot;pciba_&quot;
comma
op_amp
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to create %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_char_device_add
)paren
suffix:semicolon
id|hwgraph_chmod
c_func
(paren
id|vhdl
comma
l_int|0666
)paren
suffix:semicolon
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_chmod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_add
c_func
(paren
id|conv
comma
id|vhdl
comma
id|uname0
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to create %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|uname0
comma
id|vhdl
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_add
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|hwgraph_root
comma
id|cpath1
comma
op_amp
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %s (ret=%d)&bslash;n&quot;
comma
id|cpath1
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_char_device_add
c_func
(paren
id|conn
comma
id|dname
comma
l_string|&quot;pciba_&quot;
comma
op_amp
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to create %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_char_device_add
)paren
suffix:semicolon
id|hwgraph_chmod
c_func
(paren
id|vhdl
comma
l_int|0666
)paren
suffix:semicolon
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_chmod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_add
c_func
(paren
id|conv
comma
id|vhdl
comma
id|uname1
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to create %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|uname1
comma
id|vhdl
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_add
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|hwgraph_root
comma
id|cpath0
comma
op_amp
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %s (ret=%d)&bslash;n&quot;
comma
id|cpath0
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|conn
comma
id|dname
comma
op_amp
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_remove
c_func
(paren
id|conv
comma
id|uname0
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to remove edge %v/%s (ret=%d)&bslash;n&quot;
comma
id|conv
comma
id|uname0
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_remove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_remove
c_func
(paren
id|conn
comma
id|dname
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to remove edge %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_remove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tvertex %d destroyed OK&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_destroy
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|hwgraph_root
comma
id|cpath1
comma
op_amp
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %s (ret=%d)&bslash;n&quot;
comma
id|cpath1
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_traverse
c_func
(paren
id|conn
comma
id|dname
comma
op_amp
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to find %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_traverse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_remove
c_func
(paren
id|conv
comma
id|uname1
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to remove edge %v/%s (ret=%d)&bslash;n&quot;
comma
id|conv
comma
id|uname1
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_remove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_remove
c_func
(paren
id|conn
comma
id|dname
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to remove edge %v/%s (ret=%d)&bslash;n&quot;
comma
id|conn
comma
id|dname
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_edge_remove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|vhdl
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tvertex %d destroyed OK&bslash;n&quot;
comma
id|vhdl
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|vhdl
comma
id|hwgraph_vertex_destroy
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|conn
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conn
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_edge_remove
c_func
(paren
id|hwgraph_root
comma
id|cname
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tunable to remove edge %v/%s (ret=%d)&bslash;n&quot;
comma
id|hwgraph_root
comma
id|cname
comma
id|ret
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conv
comma
id|hwgraph_edge_remove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_unref
c_func
(paren
id|conv
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;unable to unref %v&bslash;n&quot;
comma
id|conv
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conv
comma
id|hwgraph_vertex_unref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|conv
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tvertex %d destroyed OK&bslash;n&quot;
comma
id|conv
)paren
suffix:semicolon
r_else
id|SHOWREF
c_func
(paren
id|conv
comma
id|hwgraph_vertex_destroy
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_int
DECL|function|pciba_attach
id|pciba_attach
c_func
(paren
id|devfs_handle_t
id|hconn
)paren
(brace
macro_line|#if defined(PCIIO_SLOT_NONE)
id|pciio_info_t
id|info
op_assign
id|pciio_info_get
c_func
(paren
id|hconn
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
id|pciba_comm_t
id|comm
suffix:semicolon
id|pciba_bus_t
id|bus
suffix:semicolon
r_int
id|ht
suffix:semicolon
id|devfs_handle_t
id|hbase
suffix:semicolon
id|devfs_handle_t
id|gconn
suffix:semicolon
id|devfs_handle_t
id|gbase
suffix:semicolon
r_int
id|win
suffix:semicolon
r_int
id|wins
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|pciaddr_t
id|base
suffix:semicolon
r_int
id|iwins
suffix:semicolon
r_int
id|mwins
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_attach(%p)&bslash;n&quot;
comma
id|hconn
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Pick up &quot;dualslot guest&quot; vertex,&n;     * which gets all functionality except&n;     * config space access.&n;     */
r_if
c_cond
(paren
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|hconn
comma
l_string|&quot;.guest&quot;
comma
op_amp
id|gconn
)paren
)paren
op_logical_or
(paren
id|hconn
op_eq
id|gconn
)paren
)paren
id|gconn
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
id|bus
op_assign
id|pciba_find_bus
c_func
(paren
id|hconn
comma
l_int|1
)paren
suffix:semicolon
id|bus-&gt;refct
op_increment
suffix:semicolon
multiline_comment|/* set up data common to all pciba openables&n;     * on this connection point.&n;     */
id|NEW
c_func
(paren
id|comm
)paren
suffix:semicolon
id|comm-&gt;conn
op_assign
id|hconn
suffix:semicolon
id|comm-&gt;bus
op_assign
id|bus
suffix:semicolon
id|comm-&gt;refct
op_assign
l_int|0
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|comm-&gt;lock
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if !defined(PCIIO_SLOT_NONE)
r_if
c_cond
(paren
id|bus-&gt;refct
op_eq
l_int|1
)paren
macro_line|#else
r_if
c_cond
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
macro_line|#endif
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|devfs_handle_t
id|master
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|hconn
)paren
suffix:semicolon
id|master
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_IO
comma
id|PCIIO_SPACE_IO
comma
l_int|0
comma
id|master
comma
id|master
comma
id|PCIBA_EDGE_LBL_IO
)paren
suffix:semicolon
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_MEM
comma
id|PCIIO_SPACE_MEM
comma
l_int|0
comma
id|master
comma
id|master
comma
id|PCIBA_EDGE_LBL_MEM
)paren
suffix:semicolon
macro_line|#if defined(PCIIO_SLOT_NONE)
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
id|ht
op_assign
l_int|0x7F
op_amp
id|pciio_config_get
c_func
(paren
id|hconn
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|wins
op_assign
(paren
(paren
id|ht
op_eq
l_int|0x00
)paren
ques
c_cond
l_int|6
suffix:colon
(paren
id|ht
op_eq
l_int|0x01
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
suffix:semicolon
id|mwins
op_assign
id|iwins
op_assign
l_int|0
suffix:semicolon
id|hbase
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
id|gbase
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|wins
suffix:semicolon
id|win
op_increment
)paren
(brace
id|base
op_assign
id|pciio_config_get
c_func
(paren
id|hconn
comma
id|PCI_CFG_BASE_ADDR
c_func
(paren
id|win
)paren
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_amp
l_int|1
)paren
(brace
id|space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|base
op_and_assign
l_int|0xFFFFFFFC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|base
op_and_assign
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_or_assign
(paren
(paren
id|pciaddr_t
)paren
id|pciio_config_get
c_func
(paren
id|hconn
comma
id|PCI_CFG_BASE_ADDR
c_func
(paren
id|win
op_plus
l_int|1
)paren
comma
l_int|4
)paren
)paren
op_lshift
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|base
op_and_assign
l_int|0xFFFFFFF0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
r_break
suffix:semicolon
macro_line|#if PCIBA_ALIGN_CHECK
r_if
c_cond
(paren
id|base
op_amp
(paren
id|_PAGESZ
op_minus
l_int|1
)paren
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%p pciba: BASE%d not page aligned!&bslash;n&quot;
l_string|&quot;&bslash;tmmap this window at offset 0x%x via &bslash;&quot;.../pci/%s&bslash;&quot;&bslash;n&quot;
comma
id|hconn
comma
id|win
comma
id|base
comma
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
ques
c_cond
l_string|&quot;io&quot;
suffix:colon
l_string|&quot;mem&quot;
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
multiline_comment|/* next window */
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|hbase
op_eq
id|GRAPH_VERTEX_NONE
)paren
op_logical_and
(paren
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_path_add
c_func
(paren
id|hconn
comma
id|PCIBA_EDGE_LBL_BASE
comma
op_amp
id|hbase
)paren
)paren
op_logical_or
(paren
id|hbase
op_eq
id|GRAPH_VERTEX_NONE
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* no base vertex, no more windows. */
r_if
c_cond
(paren
(paren
id|gconn
op_ne
id|GRAPH_VERTEX_NONE
)paren
op_logical_and
(paren
id|gbase
op_eq
id|GRAPH_VERTEX_NONE
)paren
op_logical_and
(paren
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_path_add
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_BASE
comma
op_amp
id|gbase
)paren
)paren
op_logical_or
(paren
id|gbase
op_eq
id|GRAPH_VERTEX_NONE
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* no base vertex, no more windows. */
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|win
)paren
comma
id|space
comma
id|base
comma
id|hbase
comma
id|gbase
comma
id|PCIBA_EDGE_LBL_WIN
c_func
(paren
id|win
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iwins
op_increment
)paren
(brace
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|win
)paren
comma
id|space
comma
id|base
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_IO
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|mwins
op_increment
)paren
(brace
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|win
)paren
comma
id|space
comma
id|base
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_MEM
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
id|win
op_increment
suffix:semicolon
)brace
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_CFG
comma
id|PCIIO_SPACE_NONE
comma
l_int|0
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_CFG
)paren
suffix:semicolon
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIBA_SPACE_UDMA
comma
id|PCIIO_SPACE_NONE
comma
l_int|0
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_DMA
)paren
suffix:semicolon
macro_line|#if ULI
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_NONE
comma
id|PCIIO_SPACE_NONE
comma
l_int|0
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_INTR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* XXX should ignore if device is an IOC3 */
r_if
c_cond
(paren
id|ht
op_eq
l_int|0x01
)paren
id|base
op_assign
id|pciio_config_get
c_func
(paren
id|hconn
comma
id|PCI_EXPANSION_ROM
op_plus
l_int|8
comma
l_int|4
)paren
suffix:semicolon
r_else
id|base
op_assign
id|pciio_config_get
c_func
(paren
id|hconn
comma
id|PCI_EXPANSION_ROM
comma
l_int|4
)paren
suffix:semicolon
id|base
op_and_assign
l_int|0xFFFFF000
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
r_if
c_cond
(paren
id|base
op_amp
(paren
id|_PAGESZ
op_minus
l_int|1
)paren
)paren
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%v pciba: ROM is 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tnot page aligned, mmap will be difficult&bslash;n&quot;
comma
id|hconn
comma
id|base
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
l_string|&quot;0x%x pciba: ROM is 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tnot page aligned, mmap will be difficult&bslash;n&quot;
comma
id|hconn
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
id|pciba_sub_attach
c_func
(paren
id|comm
comma
id|PCIIO_SPACE_ROM
comma
id|PCIIO_SPACE_MEM
comma
id|base
comma
id|hconn
comma
id|gconn
comma
id|PCIBA_EDGE_LBL_ROM
)paren
suffix:semicolon
)brace
macro_line|#if !FICUS&t;/* FICUS shorts the refct by one on path_add */
r_if
c_cond
(paren
id|hbase
op_ne
id|GRAPH_VERTEX_NONE
)paren
id|hwgraph_vertex_unref
c_func
(paren
id|hbase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gbase
op_ne
id|GRAPH_VERTEX_NONE
)paren
id|hwgraph_vertex_unref
c_func
(paren
id|gbase
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|pciba_sub_attach2
id|pciba_sub_attach2
c_func
(paren
id|pciba_comm_t
id|comm
comma
id|pciio_space_t
id|space
comma
id|pciio_space_t
id|iomem
comma
id|pciaddr_t
id|base
comma
id|devfs_handle_t
id|from
comma
r_char
op_star
id|name
comma
r_char
op_star
id|suf
comma
r_int
id|bigend
)paren
(brace
r_char
id|nbuf
(braket
l_int|128
)braket
suffix:semicolon
id|pciba_soft_t
id|soft
suffix:semicolon
id|devfs_handle_t
id|handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|suf
op_logical_and
op_star
id|suf
)paren
(brace
id|strcpy
c_func
(paren
id|nbuf
comma
id|name
)paren
suffix:semicolon
id|name
op_assign
id|nbuf
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
id|suf
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_sub_attach2 %p/%s %p at %p[%x]&bslash;n&quot;
comma
id|from
comma
id|name
comma
id|space
comma
id|space_desc
comma
id|iomem
comma
id|space_desc
comma
id|base
comma
id|from
comma
id|name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|space
OL
id|TRACKED_SPACES
)paren
r_if
c_cond
(paren
(paren
id|soft
op_assign
id|comm-&gt;soft
(braket
id|space
)braket
(braket
id|bigend
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|soft-&gt;refct
op_increment
suffix:semicolon
id|hwgraph_edge_add
c_func
(paren
id|from
comma
id|soft-&gt;vhdl
comma
id|name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|NEW
c_func
(paren
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|soft
)paren
r_return
suffix:semicolon
id|soft-&gt;comm
op_assign
id|comm
suffix:semicolon
id|soft-&gt;space
op_assign
id|space
suffix:semicolon
id|soft-&gt;size
op_assign
l_int|0
suffix:semicolon
id|soft-&gt;iomem
op_assign
id|iomem
suffix:semicolon
id|soft-&gt;base
op_assign
id|base
suffix:semicolon
id|soft-&gt;refct
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_NONE
)paren
id|soft-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bigend
)paren
id|soft-&gt;flags
op_assign
id|PCIIO_BYTE_STREAM
suffix:semicolon
r_else
id|soft-&gt;flags
op_assign
id|PCIIO_WORD_VALUES
suffix:semicolon
id|handle
op_assign
id|hwgraph_register
c_func
(paren
id|from
comma
id|name
comma
l_int|0
comma
id|DEVFS_FL_AUTO_DEVNUM
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
op_amp
id|pciba_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|soft-&gt;vhdl
op_assign
id|handle
suffix:semicolon
id|pciba_soft_set
c_func
(paren
id|soft-&gt;vhdl
comma
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OL
id|TRACKED_SPACES
)paren
id|comm-&gt;soft
(braket
id|space
)braket
(braket
id|bigend
)braket
op_assign
id|soft
suffix:semicolon
id|comm-&gt;refct
op_increment
suffix:semicolon
)brace
r_static
r_void
DECL|function|pciba_sub_attach1
id|pciba_sub_attach1
c_func
(paren
id|pciba_comm_t
id|comm
comma
id|pciio_space_t
id|space
comma
id|pciio_space_t
id|iomem
comma
id|pciaddr_t
id|base
comma
id|devfs_handle_t
id|hfrom
comma
id|devfs_handle_t
id|gfrom
comma
r_char
op_star
id|name
comma
r_char
op_star
id|suf
comma
r_int
id|bigend
)paren
(brace
id|pciba_sub_attach2
c_func
(paren
id|comm
comma
id|space
comma
id|iomem
comma
id|base
comma
id|hfrom
comma
id|name
comma
id|suf
comma
id|bigend
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gfrom
op_ne
id|GRAPH_VERTEX_NONE
)paren
op_logical_and
(paren
id|gfrom
op_ne
id|hfrom
)paren
)paren
id|pciba_sub_attach2
c_func
(paren
id|comm
comma
id|space
comma
id|iomem
comma
id|base
comma
id|gfrom
comma
id|name
comma
id|suf
comma
id|bigend
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pciba_sub_attach
id|pciba_sub_attach
c_func
(paren
id|pciba_comm_t
id|comm
comma
id|pciio_space_t
id|space
comma
id|pciio_space_t
id|iomem
comma
id|pciaddr_t
id|base
comma
id|devfs_handle_t
id|hfrom
comma
id|devfs_handle_t
id|gfrom
comma
r_char
op_star
id|name
)paren
(brace
id|pciba_sub_attach1
c_func
(paren
id|comm
comma
id|space
comma
id|iomem
comma
id|base
comma
id|hfrom
comma
id|gfrom
comma
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iomem
op_ne
id|PCIIO_SPACE_NONE
)paren
(brace
id|pciba_sub_attach1
c_func
(paren
id|comm
comma
id|space
comma
id|iomem
comma
id|base
comma
id|hfrom
comma
id|gfrom
comma
id|name
comma
l_string|&quot;_le&quot;
comma
l_int|0
)paren
suffix:semicolon
id|pciba_sub_attach1
c_func
(paren
id|comm
comma
id|space
comma
id|iomem
comma
id|base
comma
id|hfrom
comma
id|gfrom
comma
id|name
comma
l_string|&quot;_be&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef LATER
r_static
r_void
DECL|function|pciba_reload_me
id|pciba_reload_me
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_reload_me(%v)&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|pconn_vhdl
comma
id|PCIBA_EDGE_LBL_CFG
comma
op_amp
id|vhdl
)paren
)paren
r_return
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* LATER */
r_static
id|pciba_bus_t
DECL|function|pciba_find_bus
id|pciba_find_bus
c_func
(paren
id|devfs_handle_t
id|pconn
comma
r_int
id|cflag
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|devfs_handle_t
id|master
suffix:semicolon
id|arbitrary_info_t
id|ainfo
suffix:semicolon
id|pciba_bus_t
id|bus
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn
)paren
suffix:semicolon
id|master
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_info_get_LBL
c_func
(paren
id|master
comma
id|PCIBA_INFO_LBL_BUS
comma
op_amp
id|ainfo
)paren
)paren
r_return
(paren
id|pciba_bus_t
)paren
id|ainfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cflag
)paren
r_return
l_int|0
suffix:semicolon
id|NEW
c_func
(paren
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
l_int|0
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|bus-&gt;lock
comma
l_int|1
)paren
suffix:semicolon
id|ainfo
op_assign
(paren
id|arbitrary_info_t
)paren
id|bus
suffix:semicolon
id|hwgraph_info_add_LBL
c_func
(paren
id|master
comma
id|PCIBA_INFO_LBL_BUS
comma
id|ainfo
)paren
suffix:semicolon
id|hwgraph_info_get_LBL
c_func
(paren
id|master
comma
id|PCIBA_INFO_LBL_BUS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciba_bus_t
)paren
id|ainfo
op_ne
id|bus
)paren
id|DEL
c_func
(paren
id|bus
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
r_else
id|printk
c_func
(paren
l_string|&quot;pcbia_find_bus: new bus at %p&bslash;n&quot;
comma
id|master
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|pciba_bus_t
)paren
id|ainfo
suffix:semicolon
)brace
macro_line|#ifdef LATER
r_static
r_void
DECL|function|pciba_map_push
id|pciba_map_push
c_func
(paren
id|pciba_bus_t
id|bus
comma
id|pciba_map_t
id|map
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_map_push(bus=0x%x, map=0x%x, hdl=0x%x&bslash;n&quot;
comma
id|bus
comma
id|map
comma
id|map-&gt;handle
)paren
suffix:semicolon
macro_line|#endif
id|pciba_bus_lock
c_func
(paren
id|bus
)paren
suffix:semicolon
id|map-&gt;next
op_assign
id|bus-&gt;maps
suffix:semicolon
id|bus-&gt;maps
op_assign
id|map
suffix:semicolon
id|pciba_bus_unlock
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
r_static
id|pciba_map_t
DECL|function|pciba_map_pop_hdl
id|pciba_map_pop_hdl
c_func
(paren
id|pciba_bus_t
id|bus
comma
id|__psunsigned_t
id|handle
)paren
(brace
id|pciba_map_h
id|hdl
suffix:semicolon
id|pciba_map_t
id|map
suffix:semicolon
id|pciba_bus_lock
c_func
(paren
id|bus
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hdl
op_assign
op_amp
id|bus-&gt;maps
suffix:semicolon
id|map
op_assign
op_star
id|hdl
suffix:semicolon
id|hdl
op_assign
op_amp
id|map-&gt;next
)paren
r_if
c_cond
(paren
id|map-&gt;handle
op_eq
id|handle
)paren
(brace
op_star
id|hdl
op_assign
id|map-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pciba_bus_unlock
c_func
(paren
id|bus
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_map_pop_va(bus=0x%x, handle=0x%x) returns map=0x%x&bslash;n&quot;
comma
id|bus
comma
id|handle
comma
id|map
)paren
suffix:semicolon
macro_line|#endif
r_return
id|map
suffix:semicolon
)brace
multiline_comment|/* ================================================================&n; *            driver teardown, unregister and unload&n; */
r_int
DECL|function|pciba_unload
id|pciba_unload
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printk
c_func
(paren
l_string|&quot;pciba_unload()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pciba_prevent_unload
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pciio_iterate
c_func
(paren
l_string|&quot;pciba_&quot;
comma
id|pciba_unload_me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pciba_unreg
id|pciba_unreg
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_unreg()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pciba_prevent_unload
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pciio_driver_unregister
c_func
(paren
l_string|&quot;pciba_&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pciba_detach
id|pciba_detach
c_func
(paren
id|devfs_handle_t
id|conn
)paren
(brace
id|devfs_handle_t
id|base
suffix:semicolon
id|pciba_bus_t
id|bus
suffix:semicolon
id|devfs_handle_t
id|gconn
suffix:semicolon
id|devfs_handle_t
id|gbase
suffix:semicolon
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|devfs_handle_t
id|master
suffix:semicolon
id|arbitrary_info_t
id|ainfo
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_detach(%v)&bslash;n&quot;
comma
id|conn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|conn
comma
l_string|&quot;.guest&quot;
comma
op_amp
id|gconn
)paren
)paren
op_logical_or
(paren
id|conn
op_eq
id|gconn
)paren
)paren
id|gconn
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_if
c_cond
(paren
id|gconn
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_CFG
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_DMA
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_ROM
)paren
suffix:semicolon
macro_line|#if ULI
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_INTR
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_edge_remove
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_BASE
comma
op_amp
id|gbase
)paren
)paren
(brace
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_MEM
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gconn
comma
id|PCIBA_EDGE_LBL_IO
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;0&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;1&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;2&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;3&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;4&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|gbase
comma
l_string|&quot;5&quot;
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|gbase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|gbase
)paren
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: hwgraph_vertex_destroy(%v/base) failed (%d)&quot;
comma
id|conn
comma
id|ret
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: hwgraph_vertex_destroy(0x%x/base) failed (%d)&quot;
comma
id|conn
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_REFCT
id|printk
c_func
(paren
l_string|&quot;&bslash;tretained refct %d&bslash;n&quot;
comma
id|hwgraph_vertex_refct
c_func
(paren
id|gbase
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_CFG
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_DMA
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_ROM
)paren
suffix:semicolon
macro_line|#if ULI
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_INTR
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_edge_remove
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_BASE
comma
op_amp
id|base
)paren
)paren
(brace
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_MEM
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|conn
comma
id|PCIBA_EDGE_LBL_IO
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;0&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;1&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;2&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;3&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;4&quot;
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|base
comma
l_string|&quot;5&quot;
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|base
)paren
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|PRINT_WARNING
c_func
(paren
id|CE_WARN
comma
l_string|&quot;pciba: hwgraph_vertex_destroy(%v/base) failed (%d)&quot;
comma
id|conn
comma
id|ret
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
id|CE_WARN
comma
l_string|&quot;pciba: hwgraph_vertex_destroy(0x%x/base) failed (%d)&quot;
comma
id|conn
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_REFCT
id|printk
c_func
(paren
l_string|&quot;&bslash;tretained refct %d&bslash;n&quot;
comma
id|hwgraph_vertex_refct
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|bus
op_assign
id|pciba_find_bus
c_func
(paren
id|conn
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_logical_and
op_logical_neg
op_decrement
(paren
id|bus-&gt;refct
)paren
)paren
(brace
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|conn
)paren
suffix:semicolon
id|master
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|master
comma
id|PCIBA_EDGE_LBL_IO
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|master
comma
id|PCIBA_EDGE_LBL_MEM
)paren
suffix:semicolon
id|pciba_sub_detach
c_func
(paren
id|master
comma
id|PCIBA_EDGE_LBL_CFG
)paren
suffix:semicolon
id|hwgraph_info_remove_LBL
c_func
(paren
id|master
comma
id|PCIBA_INFO_LBL_BUS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pcbia_detach: DEL(bus) at %v&bslash;n&quot;
comma
id|master
)paren
suffix:semicolon
macro_line|#endif
id|DEL
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|pciba_sub_detach1
id|pciba_sub_detach1
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_char
op_star
id|name
comma
r_char
op_star
id|suf
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|pciba_soft_t
id|soft
suffix:semicolon
id|pciba_comm_t
id|comm
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|nbuf
(braket
l_int|128
)braket
suffix:semicolon
r_if
c_cond
(paren
id|suf
op_logical_and
op_star
id|suf
)paren
(brace
id|strcpy
c_func
(paren
id|nbuf
comma
id|name
)paren
suffix:semicolon
id|name
op_assign
id|nbuf
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
id|suf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_edge_remove
c_func
(paren
id|conn
comma
id|name
comma
op_amp
id|vhdl
)paren
)paren
op_logical_and
(paren
(paren
id|soft
op_assign
id|pciba_soft_get
c_func
(paren
id|vhdl
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
macro_line|#if DEBUG_PCIBA
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|prink
c_func
(paren
l_string|&quot;pciba_sub_detach(%v,%s)&bslash;n&quot;
comma
id|conn
comma
id|name
)paren
suffix:semicolon
macro_line|#else
id|prink
c_func
(paren
l_string|&quot;pciba_sub_detach(0x%x,%s)&bslash;n&quot;
comma
id|conn
comma
id|name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|hwgraph_vertex_unref
c_func
(paren
id|soft-&gt;vhdl
)paren
suffix:semicolon
macro_line|#if DEBUG_REFCT
id|printk
c_func
(paren
l_string|&quot;&bslash;tadjusted refct %d (soft ref: %d)&bslash;n&quot;
comma
id|hwgraph_vertex_refct
c_func
(paren
id|vhdl
)paren
comma
id|soft-&gt;refct
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
op_decrement
(paren
id|soft-&gt;refct
)paren
)paren
(brace
id|comm
op_assign
id|soft-&gt;comm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
(paren
id|comm-&gt;refct
)paren
)paren
(brace
id|DEL
c_func
(paren
id|comm
)paren
suffix:semicolon
)brace
id|pciba_soft_set
c_func
(paren
id|vhdl
comma
l_int|0
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|soft
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
(paren
id|ret
op_assign
id|hwgraph_vertex_destroy
c_func
(paren
id|vhdl
)paren
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: hwgraph_vertex_destroy(0x%x/%s) failed (%d)&quot;
comma
id|conn
comma
id|name
comma
id|ret
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pciba: hwgraph_vertex_destroy(%v/%s) failed (%d)&quot;
comma
id|conn
comma
id|name
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_REFCT
id|printk
c_func
(paren
l_string|&quot;&bslash;tretained refct %d&bslash;n&quot;
comma
id|hwgraph_vertex_refct
c_func
(paren
id|vhdl
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|pciba_sub_detach
id|pciba_sub_detach
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_char
op_star
id|name
)paren
(brace
id|pciba_sub_detach1
c_func
(paren
id|conn
comma
id|name
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|pciba_sub_detach1
c_func
(paren
id|conn
comma
id|name
comma
l_string|&quot;_le&quot;
)paren
suffix:semicolon
id|pciba_sub_detach1
c_func
(paren
id|conn
comma
id|name
comma
l_string|&quot;_be&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pciba_unload_me
id|pciba_unload_me
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|devfs_handle_t
id|c_vhdl
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_unload_me(%v)&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|pconn_vhdl
comma
id|PCIBA_EDGE_LBL_CFG
comma
op_amp
id|c_vhdl
)paren
)paren
r_return
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|c_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/* ================================================================&n; *            standard unix entry points&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciba_open
id|pciba_open
c_func
(paren
id|dev_t
op_star
id|devp
comma
r_int
id|flag
comma
r_int
id|otyp
comma
r_struct
id|cred
op_star
id|crp
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_open(%V)&bslash;n&quot;
comma
op_star
id|devp
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciba_close
id|pciba_close
c_func
(paren
id|dev_t
id|dev
)paren
(brace
id|devfs_handle_t
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pciba_soft_t
id|soft
op_assign
id|pciba_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_close(%V)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* if there is pending DMA for this device, hit the&n;     * device over the head with a baseball bat and&n;     * release the system memory resources.&n;     */
r_if
c_cond
(paren
id|soft
op_logical_and
id|soft-&gt;comm-&gt;dmap
)paren
(brace
id|pciba_dma_t
id|next
suffix:semicolon
id|pciba_dma_t
id|dmap
suffix:semicolon
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmap
op_assign
id|soft-&gt;comm-&gt;dmap
)paren
(brace
id|soft-&gt;comm-&gt;dmap
op_assign
l_int|0
suffix:semicolon
id|pciio_reset
c_func
(paren
id|soft-&gt;comm-&gt;conn
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmap-&gt;kaddr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmap-&gt;paddr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dmap-&gt;bytes
OL
id|NBPP
)paren
r_break
suffix:semicolon
id|next
op_assign
id|dmap-&gt;next
suffix:semicolon
id|kvpfree
c_func
(paren
id|dmap-&gt;kaddr
comma
id|dmap-&gt;bytes
op_div
id|NBPP
)paren
suffix:semicolon
id|dmap-&gt;paddr
op_assign
l_int|0
suffix:semicolon
id|dmap-&gt;bytes
op_assign
l_int|0
suffix:semicolon
id|DEL
c_func
(paren
id|dmap
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dmap
op_assign
id|next
)paren
suffix:semicolon
)brace
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
r_int
DECL|function|pciba_read
id|pciba_read
c_func
(paren
id|dev_t
id|dev
comma
id|cred_t
op_star
id|crp
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_read(%V)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_return
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
r_int
DECL|function|pciba_write
id|pciba_write
c_func
(paren
id|dev_t
id|dev
comma
id|cred_t
op_star
id|crp
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_write(%V)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_return
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciba_ioctl
id|pciba_ioctl
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|cmd
comma
r_void
op_star
id|uarg
comma
r_int
id|mode
comma
id|cred_t
op_star
id|crp
comma
r_int
op_star
id|rvalp
)paren
(brace
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|pciba_soft_t
id|soft
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|ioctl_arg_buffer_t
id|arg
suffix:semicolon
r_int
id|psize
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#if ULI
r_char
id|abi
op_assign
id|get_current_abi
c_func
(paren
)paren
suffix:semicolon
id|pciio_intr_t
id|intr
op_assign
l_int|0
suffix:semicolon
id|device_desc_t
id|desc
suffix:semicolon
id|cpuid_t
id|intrcpu
suffix:semicolon
r_int
id|lines
suffix:semicolon
r_struct
id|uli
op_star
id|uli
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
id|flags
suffix:semicolon
r_void
op_star
id|kaddr
op_assign
l_int|0
suffix:semicolon
id|iopaddr_t
id|paddr
suffix:semicolon
id|pciba_dma_h
id|dmah
suffix:semicolon
id|pciba_dma_t
id|dmap
op_assign
l_int|0
suffix:semicolon
id|pciio_dmamap_t
id|dmamap
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes
suffix:semicolon
r_int
id|pages
suffix:semicolon
id|pciaddr_t
id|daddr
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_ioctl(%V,0x%x)&bslash;n&quot;
comma
id|dev
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|psize
op_assign
(paren
id|cmd
op_rshift
l_int|16
)paren
op_amp
id|IOCPARM_MASK
suffix:semicolon
macro_line|#if ULI
id|ASSERT
c_func
(paren
r_sizeof
(paren
r_struct
id|uliargs
)paren
OG
l_int|8
)paren
suffix:semicolon
multiline_comment|/* prevent CFG access conflict */
id|ASSERT
c_func
(paren
r_sizeof
(paren
r_struct
id|uliargs
)paren
op_le
id|IOCPARM_MASK
)paren
suffix:semicolon
macro_line|#endif
id|arg.ca
op_assign
id|uarg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|psize
OG
l_int|0
)paren
op_logical_and
(paren
id|cmd
op_amp
(paren
id|IOC_OUT
op_or
id|IOC_IN
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|psize
OG
r_sizeof
(paren
id|arg
)paren
)paren
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;bad parameter size */
r_else
(brace
r_if
c_cond
(paren
id|cmd
op_amp
id|IOC_OUT
)paren
id|bzero
c_func
(paren
id|arg.data
comma
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|IOC_IN
)paren
op_logical_and
(paren
id|copyin
c_func
(paren
id|uarg
comma
id|arg.data
comma
id|psize
)paren
OL
l_int|0
)paren
)paren
id|err
op_assign
id|EFAULT
suffix:semicolon
multiline_comment|/* &quot;parameter copyin failed&quot; */
)brace
)brace
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|soft
op_assign
id|pciba_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|space
op_assign
id|soft-&gt;space
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;invalid ioctl for this vertex&quot; */
r_switch
c_cond
(paren
id|space
)paren
(brace
macro_line|#if ULI
r_case
id|PCIIO_SPACE_NONE
suffix:colon
multiline_comment|/* the &quot;intr&quot; vertex */
multiline_comment|/* PCIIOCSETULI: set up user interrupts.&n;&t;     */
id|lines
op_assign
id|cmd
op_amp
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|ABI_IS_64BIT
c_func
(paren
id|abi
)paren
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_ne
id|PCIIOCSETULI
c_func
(paren
id|lines
)paren
)paren
(brace
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;invalid ioctl for this vertex&quot; */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|uliargs
id|uliargs
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|PCIIOCSETULI32
c_func
(paren
id|lines
)paren
)paren
(brace
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;invalid ioctl for this vertex&quot; */
r_break
suffix:semicolon
)brace
id|uliargs32_to_uliargs
c_func
(paren
op_amp
id|arg.uli32
comma
op_amp
id|uliargs
)paren
suffix:semicolon
id|arg.uli
op_assign
id|uliargs
suffix:semicolon
)brace
id|desc
op_assign
id|device_desc_dup
c_func
(paren
id|soft-&gt;comm-&gt;conn
)paren
suffix:semicolon
id|device_desc_flags_set
c_func
(paren
id|desc
comma
(paren
id|device_desc_flags_get
c_func
(paren
id|desc
)paren
op_or
id|D_INTR_NOTHREAD
)paren
)paren
suffix:semicolon
id|device_desc_intr_swlevel_set
c_func
(paren
id|desc
comma
id|INTR_SWLEVEL_NOTHREAD_DEFAULT
)paren
suffix:semicolon
id|device_desc_intr_name_set
c_func
(paren
id|desc
comma
l_string|&quot;PCIBA&quot;
)paren
suffix:semicolon
id|device_desc_default_set
c_func
(paren
id|soft-&gt;comm-&gt;conn
comma
id|desc
)paren
suffix:semicolon
multiline_comment|/* When designating interrupts, the slot number&n;&t;     * is taken from the connection point.&n;&t;     * Bits 0..3 are used to select INTA..INTD; more&n;&t;     * than one bit can be specified. These should&n;&t;     * be constructed using PCIIO_INTR_LINE_[ABCD].&n;&t;     */
id|intr
op_assign
id|pciio_intr_alloc
(paren
id|soft-&gt;comm-&gt;conn
comma
id|desc
comma
id|lines
comma
id|soft-&gt;vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|ENOMEM
suffix:semicolon
multiline_comment|/* &quot;insufficient resources&quot; */
r_break
suffix:semicolon
)brace
id|intrcpu
op_assign
id|cpuvertex_to_cpuid
c_func
(paren
id|pciio_intr_cpu_get
c_func
(paren
id|intr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_assign
id|new_uli
c_func
(paren
op_amp
id|arg.uli
comma
op_amp
id|uli
comma
id|intrcpu
)paren
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* &quot;unable to set up ULI&quot; */
)brace
id|atomic_inc
c_func
(paren
op_amp
id|pciba_prevent_unload
)paren
suffix:semicolon
id|pciio_intr_connect
c_func
(paren
id|intr
comma
id|pciba_intr
comma
id|uli
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTE: don&squot;t set the teardown function&n;&t;     * until the interrupt is connected.&n;&t;     */
id|uli-&gt;teardownarg1
op_assign
(paren
id|__psint_t
)paren
id|intr
suffix:semicolon
id|uli-&gt;teardown
op_assign
id|pciba_clearuli
suffix:semicolon
id|arg.uli.id
op_assign
id|uli-&gt;index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ABI_IS_64BIT
c_func
(paren
id|abi
)paren
)paren
(brace
r_struct
id|uliargs32
id|uliargs32
suffix:semicolon
id|uliargs_to_uliargs32
c_func
(paren
op_amp
id|arg.uli
comma
op_amp
id|uliargs32
)paren
suffix:semicolon
id|arg.uli32
op_assign
id|uliargs32
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|PCIBA_SPACE_UDMA
suffix:colon
multiline_comment|/* the &quot;dma&quot; vertex */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PCIIOCDMAALLOC
suffix:colon
multiline_comment|/* PCIIOCDMAALLOC: allocate a chunk of physical&n;&t;&t; * memory and set it up for DMA. Return the&n;&t;&t; * PCI address that gets to it.&n;&t;&t; * NOTE: this allocates memory local to the&n;&t;&t; * CPU doing the ioctl, not local to the&n;&t;&t; * device that will be doing the DMA.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|_CAP_ABLE
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|err
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* separate the halves of the incoming parameter */
id|flags
op_assign
id|arg.ud
op_rshift
l_int|32
suffix:semicolon
id|bytes
op_assign
id|arg.ud
op_amp
l_int|0xFFFFFFFF
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: user wants 0x%x bytes of DMA, flags 0x%x&bslash;n&quot;
comma
id|bytes
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* round up the requested size to the next highest page */
id|pages
op_assign
(paren
id|bytes
op_plus
id|NBPP
op_minus
l_int|1
)paren
op_div
id|NBPP
suffix:semicolon
multiline_comment|/* make sure the requested size is something reasonable */
r_if
c_cond
(paren
id|pages
OG
id|pci_user_dma_max_pages
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: request for too much buffer space&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &quot;request for too much buffer space&quot; */
)brace
multiline_comment|/* &quot;correct&quot; number of bytes */
id|bytes
op_assign
id|pages
op_star
id|NBPP
suffix:semicolon
multiline_comment|/* allocate the space */
multiline_comment|/* XXX- force to same node as the device? */
multiline_comment|/* XXX- someday, we want to handle user buffers,&n;&t;&t; *    and noncontiguous pages, but this will&n;&t;&t; *      require either fancy mapping or handing&n;&t;&t; *      a list of blocks back to the user. For&n;&t;&t; *      now, just tell users to allocate a lot of&n;&t;&t; *      individual single-pages and manage their&n;&t;&t; *      scatter-gather manually.&n;&t;&t; */
id|kaddr
op_assign
id|kvpalloc
c_func
(paren
id|pages
comma
id|VM_DIRECT
op_or
id|KM_NOSLEEP
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kaddr
op_eq
l_int|0
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: unable to get %d contiguous pages&bslash;n&quot;
comma
id|pages
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|EAGAIN
suffix:semicolon
multiline_comment|/* &quot;insufficient resources, try again later&quot; */
r_break
suffix:semicolon
)brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: kaddr is 0x%x&bslash;n&quot;
comma
id|kaddr
)paren
suffix:semicolon
macro_line|#endif
id|paddr
op_assign
id|kvtophys
c_func
(paren
id|kaddr
)paren
suffix:semicolon
id|daddr
op_assign
id|pciio_dmatrans_addr
(paren
id|soft-&gt;comm-&gt;conn
comma
l_int|0
comma
id|paddr
comma
id|bytes
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|daddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* &quot;no direct path available&quot; */
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: dmatrans failed, trying dmamap&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dmamap
op_assign
id|pciio_dmamap_alloc
(paren
id|soft-&gt;comm-&gt;conn
comma
l_int|0
comma
id|bytes
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmamap
op_eq
l_int|0
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: unable to allocate dmamap&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &quot;out of mapping resources&quot; */
)brace
id|daddr
op_assign
id|pciio_dmamap_addr
(paren
id|dmamap
comma
id|paddr
comma
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|daddr
op_eq
l_int|0
)paren
(brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: dmamap_addr failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &quot;can&squot;t get there from here&quot; */
)brace
)brace
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: daddr is 0x%x&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
id|NEW
c_func
(paren
id|dmap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmap
)paren
(brace
id|err
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &quot;no memory available&quot; */
)brace
id|dmap-&gt;bytes
op_assign
id|bytes
suffix:semicolon
id|dmap-&gt;pages
op_assign
id|pages
suffix:semicolon
id|dmap-&gt;paddr
op_assign
id|paddr
suffix:semicolon
id|dmap-&gt;kaddr
op_assign
id|kaddr
suffix:semicolon
id|dmap-&gt;map
op_assign
id|dmamap
suffix:semicolon
id|dmap-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|dmap-&gt;handle
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: dmap 0x%x contains va 0x%x bytes 0x%x pa 0x%x pages 0x%x daddr 0x%x&bslash;n&quot;
comma
id|dmap
comma
id|kaddr
comma
id|bytes
comma
id|paddr
comma
id|pages
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
id|arg.ud
op_assign
id|dmap-&gt;daddr
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIOCDMAFREE
suffix:colon
multiline_comment|/* PCIIOCDMAFREE: Find the chunk of&n;&t;&t; * User DMA memory, and release its&n;&t;&t; * resources back to the system.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|_CAP_ABLE
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|err
op_assign
id|EPERM
suffix:semicolon
multiline_comment|/* &quot;you can&squot;t do that&quot; */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|soft-&gt;comm-&gt;dmap
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;no User DMA to free&quot; */
r_break
suffix:semicolon
)brace
multiline_comment|/* find the request. */
id|daddr
op_assign
id|arg.ud
suffix:semicolon
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;block not found&quot; */
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dmah
op_assign
op_amp
id|soft-&gt;comm-&gt;dmap
suffix:semicolon
id|dmap
op_assign
op_star
id|dmah
suffix:semicolon
id|dmah
op_assign
op_amp
id|dmap-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dmap-&gt;daddr
op_eq
id|daddr
)paren
(brace
r_if
c_cond
(paren
id|dmap-&gt;handle
op_ne
l_int|0
)paren
(brace
id|dmap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t DEL this dmap! */
id|err
op_assign
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;please unmap first&quot; */
r_break
suffix:semicolon
multiline_comment|/* break outa for loop. */
)brace
op_star
id|dmah
op_assign
id|dmap-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dmamap
op_assign
id|dmap-&gt;map
)paren
(brace
id|pciio_dmamap_free
c_func
(paren
id|dmamap
)paren
suffix:semicolon
id|dmamap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t free it twice! */
)brace
id|kvpfree
c_func
(paren
id|dmap-&gt;kaddr
comma
id|dmap-&gt;bytes
op_div
id|NBPP
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|dmap
)paren
suffix:semicolon
id|dmap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t link this back into the list! */
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &quot;all done&quot; */
r_break
suffix:semicolon
multiline_comment|/* break outa for loop. */
)brace
)brace
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* break outa case PCIIOCDMAFREE: */
)brace
r_break
suffix:semicolon
multiline_comment|/* break outa case PCIBA_SPACE_UDMA: */
r_case
id|PCIIO_SPACE_CFG
suffix:colon
multiline_comment|/* PCIIOCCFG{RD,WR}: read and/or write&n;&t;     * PCI configuration space. If both,&n;&t;     * the read happens first (this becomes&n;&t;     * a swap operation, atomic with respect&n;&t;     * to other updates through this path).&n;&t;     *&n;&t;     * Should be *last* IOCTl command checked,&n;&t;     * so other patterns can nip useless codes&n;&t;     * out of the space this decodes.&n;&t;     */
id|err
op_assign
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|psize
OG
l_int|0
)paren
op_logical_or
(paren
id|psize
op_le
l_int|8
)paren
op_logical_and
(paren
(paren
(paren
id|cmd
op_amp
l_int|0xFF
)paren
op_plus
id|psize
)paren
op_le
l_int|256
)paren
op_logical_and
(paren
id|cmd
op_amp
(paren
id|IOC_IN
op_or
id|IOC_OUT
)paren
)paren
)paren
(brace
r_uint64
id|rdata
suffix:semicolon
r_uint64
id|wdata
suffix:semicolon
r_int
id|shft
suffix:semicolon
id|shft
op_assign
l_int|64
op_minus
(paren
l_int|8
op_star
id|psize
)paren
suffix:semicolon
id|wdata
op_assign
id|arg.ud
op_rshift
id|shft
suffix:semicolon
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
id|IOC_OUT
)paren
id|rdata
op_assign
id|pciio_config_get
c_func
(paren
id|soft-&gt;comm-&gt;conn
comma
id|cmd
op_amp
l_int|0xFFFF
comma
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
id|IOC_IN
)paren
id|pciio_config_set
c_func
(paren
id|soft-&gt;comm-&gt;conn
comma
id|cmd
op_amp
l_int|0xFFFF
comma
id|psize
comma
id|wdata
)paren
suffix:semicolon
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
id|arg.ud
op_assign
id|rdata
op_lshift
id|shft
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* done: come here if all went OK.&n;     */
r_if
c_cond
(paren
(paren
id|err
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|cmd
op_amp
id|IOC_OUT
)paren
op_logical_and
(paren
id|psize
OG
l_int|0
)paren
)paren
op_logical_and
id|copyout
c_func
(paren
id|arg.data
comma
id|uarg
comma
id|psize
)paren
)paren
id|err
op_assign
id|EFAULT
suffix:semicolon
multiline_comment|/* This gets delayed until after the copyout so we&n;     * do not free the dmap on a copyout error, or&n;     * alternately end up with a dangling allocated&n;     * buffer that the user never got back.&n;     */
r_if
c_cond
(paren
(paren
id|err
op_eq
l_int|0
)paren
op_logical_and
id|dmap
)paren
(brace
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
id|dmap-&gt;next
op_assign
id|soft-&gt;comm-&gt;dmap
suffix:semicolon
id|soft-&gt;comm-&gt;dmap
op_assign
id|dmap
suffix:semicolon
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* Things went badly. Clean up.&n;&t; */
macro_line|#if ULI
r_if
c_cond
(paren
id|intr
)paren
(brace
id|pciio_intr_disconnect
c_func
(paren
id|intr
)paren
suffix:semicolon
id|pciio_intr_free
c_func
(paren
id|intr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uli
)paren
id|free_uli
c_func
(paren
id|uli
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dmap
)paren
(brace
r_if
c_cond
(paren
id|dmap-&gt;map
op_logical_and
(paren
id|dmap-&gt;map
op_ne
id|dmamap
)paren
)paren
id|pciio_dmamap_free
c_func
(paren
id|dmap-&gt;map
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|dmap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmamap
)paren
id|pciio_dmamap_free
c_func
(paren
id|dmamap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kaddr
)paren
id|kvpfree
c_func
(paren
id|kaddr
comma
id|pages
)paren
suffix:semicolon
)brace
r_return
op_star
id|rvalp
op_assign
id|err
suffix:semicolon
)brace
multiline_comment|/* ================================================================&n; *            mapping support&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciba_map
id|pciba_map
c_func
(paren
id|dev_t
id|dev
comma
id|vhandl_t
op_star
id|vt
comma
id|off_t
id|off
comma
r_int
id|len
comma
r_uint32
id|prot
)paren
(brace
id|devfs_handle_t
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pciba_soft_t
id|soft
op_assign
id|pciba_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|devfs_handle_t
id|conn
op_assign
id|soft-&gt;comm-&gt;conn
suffix:semicolon
id|pciio_space_t
id|space
op_assign
id|soft-&gt;space
suffix:semicolon
r_int
id|pages
op_assign
(paren
id|len
op_plus
id|NBPP
op_minus
l_int|1
)paren
op_div
id|NBPP
suffix:semicolon
id|pciio_piomap_t
id|pciio_piomap
op_assign
l_int|0
suffix:semicolon
id|caddr_t
id|kaddr
suffix:semicolon
id|pciba_map_t
id|map
suffix:semicolon
id|pciba_dma_t
id|dmap
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_map(%V,vt=0x%x)&bslash;n&quot;
comma
id|dev
comma
id|vt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|space
op_eq
id|PCIBA_SPACE_UDMA
)paren
(brace
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dmap
op_assign
id|soft-&gt;comm-&gt;dmap
suffix:semicolon
id|dmap
op_ne
l_int|NULL
suffix:semicolon
id|dmap
op_assign
id|dmap-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|off
op_eq
id|dmap-&gt;daddr
)paren
(brace
r_if
c_cond
(paren
id|pages
op_ne
id|dmap-&gt;pages
)paren
(brace
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;size mismatch&quot; */
)brace
id|v_mapphys
c_func
(paren
id|vt
comma
id|dmap-&gt;kaddr
comma
id|dmap-&gt;bytes
)paren
suffix:semicolon
id|dmap-&gt;handle
op_assign
id|v_gethandle
c_func
(paren
id|vt
)paren
suffix:semicolon
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: mapped dma at kaddr 0x%x via handle 0x%x&bslash;n&quot;
comma
id|dmap-&gt;kaddr
comma
id|dmap-&gt;handle
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;block not found&quot; */
)brace
r_if
c_cond
(paren
id|soft-&gt;iomem
op_eq
id|PCIIO_SPACE_NONE
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;mmap not supported&quot; */
id|kaddr
op_assign
(paren
id|caddr_t
)paren
id|pciio_pio_addr
(paren
id|conn
comma
l_int|0
comma
id|space
comma
id|off
comma
id|len
comma
op_amp
id|pciio_piomap
comma
id|soft-&gt;flags
op_or
id|PCIIO_FIXED
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: mapped %R[0x%x..0x%x] via map 0x%x to kaddr 0x%x&bslash;n&quot;
comma
id|space
comma
id|space_desc
comma
id|off
comma
id|off
op_plus
id|len
op_minus
l_int|1
comma
id|pciio_piomap
comma
id|kaddr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|kaddr
op_eq
l_int|NULL
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* &quot;you can&squot;t get there from here&quot; */
id|NEW
c_func
(paren
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pciio_piomap
)paren
id|pciio_piomap_free
c_func
(paren
id|pciio_piomap
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
multiline_comment|/* &quot;unable to get memory resources */
)brace
macro_line|#ifdef LATER
id|map-&gt;uthread
op_assign
id|curuthread
suffix:semicolon
macro_line|#endif
id|map-&gt;handle
op_assign
id|v_gethandle
c_func
(paren
id|vt
)paren
suffix:semicolon
id|map-&gt;uvaddr
op_assign
id|v_getaddr
c_func
(paren
id|vt
)paren
suffix:semicolon
id|map-&gt;map
op_assign
id|pciio_piomap
suffix:semicolon
id|map-&gt;space
op_assign
id|soft-&gt;iomem
suffix:semicolon
id|map-&gt;base
op_assign
id|soft-&gt;base
op_plus
id|off
suffix:semicolon
id|map-&gt;size
op_assign
id|len
suffix:semicolon
id|pciba_map_push
c_func
(paren
id|soft-&gt;comm-&gt;bus
comma
id|map
)paren
suffix:semicolon
multiline_comment|/* Inform the system of the correct&n;     * kvaddr corresponding to the thing&n;     * that is being mapped.&n;     */
id|v_mapphys
c_func
(paren
id|vt
comma
id|kaddr
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pciba_unmap
id|pciba_unmap
c_func
(paren
id|dev_t
id|dev
comma
id|vhandl_t
op_star
id|vt
)paren
(brace
id|devfs_handle_t
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pciba_soft_t
id|soft
op_assign
id|pciba_soft_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|pciba_bus_t
id|bus
op_assign
id|soft-&gt;comm-&gt;bus
suffix:semicolon
id|pciba_map_t
id|map
suffix:semicolon
id|__psunsigned_t
id|handle
op_assign
id|v_gethandle
c_func
(paren
id|vt
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_unmap(%V,vt=%x)&bslash;n&quot;
comma
id|dev
comma
id|vt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If this is a userDMA buffer,&n;     * make a note that it has been unmapped&n;     * so it can be released.&n;     */
r_if
c_cond
(paren
id|soft-&gt;comm-&gt;dmap
)paren
(brace
id|pciba_dma_t
id|dmap
suffix:semicolon
id|pciba_soft_lock
c_func
(paren
id|soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dmap
op_assign
id|soft-&gt;comm-&gt;dmap
suffix:semicolon
id|dmap
op_ne
l_int|NULL
suffix:semicolon
id|dmap
op_assign
id|dmap-&gt;next
)paren
r_if
c_cond
(paren
id|handle
op_eq
id|dmap-&gt;handle
)paren
(brace
id|dmap-&gt;handle
op_assign
l_int|0
suffix:semicolon
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba: unmapped dma at kaddr 0x%x via handle 0x%x&bslash;n&quot;
comma
id|dmap-&gt;kaddr
comma
id|handle
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* found userPCI */
)brace
id|pciba_soft_unlock
c_func
(paren
id|soft
)paren
suffix:semicolon
)brace
id|map
op_assign
id|pciba_map_pop_hdl
c_func
(paren
id|bus
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* no match */
r_if
c_cond
(paren
id|map-&gt;map
)paren
id|pciio_piomap_free
c_func
(paren
id|map-&gt;map
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* all done OK */
)brace
macro_line|#if ULI
r_void
DECL|function|pciba_clearuli
id|pciba_clearuli
c_func
(paren
r_struct
id|uli
op_star
id|uli
)paren
(brace
id|pciio_intr_t
id|intr
op_assign
(paren
id|pciio_intr_t
)paren
id|uli-&gt;teardownarg1
suffix:semicolon
macro_line|#if DEBUG_PCIBA
id|printf
c_func
(paren
l_string|&quot;pciba_clearuli(0x%x)&bslash;n&quot;
comma
id|uli
)paren
suffix:semicolon
macro_line|#endif
id|pciio_intr_disconnect
c_func
(paren
id|intr
)paren
suffix:semicolon
id|pciio_intr_free
c_func
(paren
id|intr
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|pciba_prevent_unload
)paren
suffix:semicolon
)brace
r_void
DECL|function|pciba_intr
id|pciba_intr
c_func
(paren
id|intr_arg_t
id|arg
)paren
(brace
r_struct
id|uli
op_star
id|uli
op_assign
(paren
r_struct
id|uli
op_star
)paren
id|arg
suffix:semicolon
r_int
id|ulinum
op_assign
id|uli-&gt;index
suffix:semicolon
r_extern
r_void
id|frs_handle_uli
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ulinum
op_ge
l_int|0
op_logical_and
id|ulinum
OL
id|MAX_ULIS
)paren
(brace
id|uli_callup
c_func
(paren
id|ulinum
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
dot
id|p_frs_flags
)paren
id|frs_handle_uli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif /* LATER - undef as we implement each routine */
eof
