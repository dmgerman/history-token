multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; *  ifconfig_net - SGI&squot;s Persistent Network Device names.&n; *&n; * Copyright (C) 1992-1997, 2000-2002 Silicon Graphics, Inc.  All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;linux/devfs_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/ifconfig_net.h&gt;
DECL|macro|SGI_IFCONFIG_NET
mdefine_line|#define SGI_IFCONFIG_NET &quot;SGI-PERSISTENT NETWORK DEVICE NAME DRIVER&quot;
DECL|macro|SGI_IFCONFIG_NET_VERSION
mdefine_line|#define SGI_IFCONFIG_NET_VERSION &quot;1.0&quot;
multiline_comment|/*&n; * Some Global definitions.&n; */
DECL|variable|ifconfig_net_handle
id|devfs_handle_t
id|ifconfig_net_handle
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ifconfig_net_debug
r_int
r_int
id|ifconfig_net_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * ifconfig_net_open - Opens the special device node &quot;/devhw/.ifconfig_net&quot;.&n; */
DECL|function|ifconfig_net_open
r_static
r_int
id|ifconfig_net_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|ifconfig_net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ifconfig_net_open called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ifconfig_net_close - Closes the special device node &quot;/devhw/.ifconfig_net&quot;.&n; */
DECL|function|ifconfig_net_close
r_static
r_int
id|ifconfig_net_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|ifconfig_net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ifconfig_net_close called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * assign_ifname - Assign the next available interface name from the persistent list.&n; */
r_void
DECL|function|assign_ifname
id|assign_ifname
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifname_num
op_star
id|ifname_num
)paren
(brace
multiline_comment|/*&n;&t; * Handle eth devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ifname_num-&gt;next_eth
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Assign it the next available eth interface number. &n;&t;&t;&t; */
id|memset
c_func
(paren
id|dev-&gt;name
comma
l_int|0
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
(paren
r_int
)paren
id|ifname_num-&gt;next_eth
)paren
suffix:semicolon
id|ifname_num-&gt;next_eth
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle fddi devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;fddi&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ifname_num-&gt;next_fddi
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Assign it the next available fddi interface number.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|dev-&gt;name
comma
l_int|0
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;fddi%d&quot;
comma
(paren
r_int
)paren
id|ifname_num-&gt;next_fddi
)paren
suffix:semicolon
id|ifname_num-&gt;next_fddi
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle hip devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;hip&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ifname_num-&gt;next_hip
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Assign it the next available hip interface number.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|dev-&gt;name
comma
l_int|0
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;hip%d&quot;
comma
(paren
r_int
)paren
id|ifname_num-&gt;next_hip
)paren
suffix:semicolon
id|ifname_num-&gt;next_hip
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle tr devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;tr&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ifname_num-&gt;next_tr
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Assign it the next available tr interface number.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|dev-&gt;name
comma
l_int|0
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;tr%d&quot;
comma
(paren
r_int
)paren
id|ifname_num-&gt;next_tr
)paren
suffix:semicolon
id|ifname_num-&gt;next_tr
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle fc devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;fc&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ifname_num-&gt;next_fc
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Assign it the next available fc interface number.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|dev-&gt;name
comma
l_int|0
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;fc%d&quot;
comma
(paren
r_int
)paren
id|ifname_num-&gt;next_fc
)paren
suffix:semicolon
id|ifname_num-&gt;next_fc
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * find_persistent_ifname: Returns the entry that was seen in previous boot.&n; */
r_struct
id|ifname_MAC
op_star
DECL|function|find_persistent_ifname
id|find_persistent_ifname
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifname_MAC
op_star
id|ifname_MAC
)paren
(brace
r_while
c_loop
(paren
id|ifname_MAC-&gt;addr_len
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ifname_MAC-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
op_eq
l_int|0
)paren
r_return
id|ifname_MAC
suffix:semicolon
id|ifname_MAC
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ifconfig_net_ioctl: ifconfig_net driver ioctl interface.&n; */
DECL|function|ifconfig_net_ioctl
r_static
r_int
id|ifconfig_net_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_extern
r_struct
id|net_device
op_star
id|__dev_get_by_name
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|ifname_MAC
op_star
id|found
suffix:semicolon
r_char
id|temp
(braket
l_int|64
)braket
suffix:semicolon
macro_line|#endif
r_struct
id|ifname_MAC
op_star
id|ifname_MAC
suffix:semicolon
r_struct
id|ifname_MAC
op_star
id|new_devices
comma
op_star
id|temp_new_devices
suffix:semicolon
r_struct
id|ifname_num
op_star
id|ifname_num
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|ifconfig_net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HCL: hcl_ioctl called.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read in the header and see how big of a buffer we really need to &n;&t; * allocate.&n;&t; */
id|ifname_num
op_assign
(paren
r_struct
id|ifname_num
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ifname_num
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|ifname_num
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|ifname_num
)paren
)paren
suffix:semicolon
id|size
op_assign
id|ifname_num-&gt;size
suffix:semicolon
id|kfree
c_func
(paren
id|ifname_num
)paren
suffix:semicolon
id|ifname_num
op_assign
(paren
r_struct
id|ifname_num
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ifname_MAC
op_assign
(paren
r_struct
id|ifname_MAC
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ifname_num
op_plus
(paren
r_sizeof
(paren
r_struct
id|ifname_num
)paren
)paren
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|ifname_num
comma
(paren
r_char
op_star
)paren
id|arg
comma
id|size
)paren
suffix:semicolon
id|new_devices
op_assign
id|kmalloc
c_func
(paren
id|size
op_minus
r_sizeof
(paren
r_struct
id|ifname_num
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|temp_new_devices
op_assign
id|new_devices
suffix:semicolon
id|memset
c_func
(paren
id|new_devices
comma
l_int|0
comma
id|size
op_minus
r_sizeof
(paren
r_struct
id|ifname_num
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
multiline_comment|/*&n;&t; * Go through the net device entries and make them persistent!&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip NULL entries or &quot;lo&quot;&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;addr_len
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;lo&quot;
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * See if we have a persistent interface name for this device.&n;&t;&t; */
id|found
op_assign
l_int|NULL
suffix:semicolon
id|found
op_assign
id|find_persistent_ifname
c_func
(paren
id|dev
comma
id|ifname_MAC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|found-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Never seen this before .. */
id|assign_ifname
c_func
(paren
id|dev
comma
id|ifname_num
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Save the information for the next boot.&n;&t;&t;&t; */
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%s %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|temp_new_devices-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|temp_new_devices-&gt;addr_len
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|temp_new_devices-&gt;dev_addr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|temp_new_devices
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Copy back to the User Buffer area any new devices encountered.&n;&t; */
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
op_plus
(paren
r_sizeof
(paren
r_struct
id|ifname_num
)paren
)paren
comma
id|new_devices
comma
id|size
op_minus
r_sizeof
(paren
r_struct
id|ifname_num
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ifconfig_net_fops
r_struct
id|file_operations
id|ifconfig_net_fops
op_assign
(brace
id|ioctl
suffix:colon
id|ifconfig_net_ioctl
comma
multiline_comment|/* ioctl */
id|open
suffix:colon
id|ifconfig_net_open
comma
multiline_comment|/* open */
id|release
suffix:colon
id|ifconfig_net_close
multiline_comment|/* release */
)brace
suffix:semicolon
multiline_comment|/*&n; * init_ifconfig_net() - Boot time initialization.  Ensure that it is called &n; *&t;after devfs has been initialized.&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
macro_line|#else
r_int
id|__init
id|init_ifconfig_net
c_func
(paren
r_void
)paren
macro_line|#endif
(brace
id|ifconfig_net_handle
op_assign
l_int|NULL
suffix:semicolon
id|ifconfig_net_handle
op_assign
id|hwgraph_register
c_func
(paren
id|hwgraph_root
comma
l_string|&quot;.ifconfig_net&quot;
comma
l_int|0
comma
id|DEVFS_FL_AUTO_DEVNUM
comma
l_int|0
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
l_int|0
comma
l_int|0
comma
op_amp
id|ifconfig_net_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifconfig_net_handle
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Unable to create SGI PERSISTENT NETWORK DEVICE Name Driver.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
