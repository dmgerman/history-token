multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#ifdef BRINGUP
DECL|variable|NeedXbridgeSwap
r_int
id|NeedXbridgeSwap
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/cmn_err.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_defs.h&gt;
macro_line|#include &lt;asm/sn/prio.h&gt;
macro_line|#include &lt;asm/sn/ioerror_handling.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/ioc3.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/sn1/bedrock.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
macro_line|#include &lt;asm/sn/sn1/hubio.h&gt;
macro_line|#include &lt;asm/sn/sn1/hubio_next.h&gt;
macro_line|#endif
macro_line|#if defined(BRINGUP)
macro_line|#if 0
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1&t; /* To avoid lots of bad printk() formats leave off */
macro_line|#endif
DECL|macro|PCI_DEBUG
mdefine_line|#define PCI_DEBUG 1
DECL|macro|ATTACH_DEBUG
mdefine_line|#define ATTACH_DEBUG 1
DECL|macro|PCIBR_SOFT_LIST
mdefine_line|#define PCIBR_SOFT_LIST 1
macro_line|#endif
macro_line|#ifndef&t;LOCAL
DECL|macro|LOCAL
mdefine_line|#define&t;LOCAL&t;&t;static
macro_line|#endif
DECL|macro|PCIBR_LLP_CONTROL_WAR
mdefine_line|#define PCIBR_LLP_CONTROL_WAR
macro_line|#if defined (PCIBR_LLP_CONTROL_WAR)
DECL|variable|pcibr_llp_control_war_cnt
r_int
id|pcibr_llp_control_war_cnt
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* PCIBR_LLP_CONTROL_WAR */
DECL|macro|NEWAf
mdefine_line|#define&t;NEWAf(ptr,n,f)&t;(ptr = kmem_zalloc((n)*sizeof (*(ptr)), (f&amp;PCIIO_NOSLEEP)?KM_NOSLEEP:KM_SLEEP))
DECL|macro|NEWA
mdefine_line|#define NEWA(ptr,n)&t;(ptr = kmem_zalloc((n)*sizeof (*(ptr)), KM_SLEEP))
DECL|macro|DELA
mdefine_line|#define DELA(ptr,n)&t;(kfree(ptr))
DECL|macro|NEWf
mdefine_line|#define NEWf(ptr,f)&t;NEWAf(ptr,1,f)
DECL|macro|NEW
mdefine_line|#define NEW(ptr)&t;NEWA(ptr,1)
DECL|macro|DEL
mdefine_line|#define DEL(ptr)&t;DELA(ptr,1)
DECL|variable|pcibr_devflag
r_int
id|pcibr_devflag
op_assign
id|D_MP
suffix:semicolon
DECL|macro|F
mdefine_line|#define F(s,n)&t;&t;{ 1l&lt;&lt;(s),-(s), n }
DECL|variable|bridge_int_status_desc
r_struct
id|reg_desc
id|bridge_int_status_desc
(braket
)braket
op_assign
(brace
id|F
c_func
(paren
l_int|31
comma
l_string|&quot;MULTI_ERR&quot;
)paren
comma
id|F
c_func
(paren
l_int|30
comma
l_string|&quot;PMU_ESIZE_EFAULT&quot;
)paren
comma
id|F
c_func
(paren
l_int|29
comma
l_string|&quot;UNEXPECTED_RESP&quot;
)paren
comma
id|F
c_func
(paren
l_int|28
comma
l_string|&quot;BAD_XRESP_PACKET&quot;
)paren
comma
id|F
c_func
(paren
l_int|27
comma
l_string|&quot;BAD_XREQ_PACKET&quot;
)paren
comma
id|F
c_func
(paren
l_int|26
comma
l_string|&quot;RESP_XTALK_ERROR&quot;
)paren
comma
id|F
c_func
(paren
l_int|25
comma
l_string|&quot;REQ_XTALK_ERROR&quot;
)paren
comma
id|F
c_func
(paren
l_int|24
comma
l_string|&quot;INVALID_ADDRESS&quot;
)paren
comma
id|F
c_func
(paren
l_int|23
comma
l_string|&quot;UNSUPPORTED_XOP&quot;
)paren
comma
id|F
c_func
(paren
l_int|22
comma
l_string|&quot;XREQ_FIFO_OFLOW&quot;
)paren
comma
id|F
c_func
(paren
l_int|21
comma
l_string|&quot;LLP_REC_SNERROR&quot;
)paren
comma
id|F
c_func
(paren
l_int|20
comma
l_string|&quot;LLP_REC_CBERROR&quot;
)paren
comma
id|F
c_func
(paren
l_int|19
comma
l_string|&quot;LLP_RCTY&quot;
)paren
comma
id|F
c_func
(paren
l_int|18
comma
l_string|&quot;LLP_TX_RETRY&quot;
)paren
comma
id|F
c_func
(paren
l_int|17
comma
l_string|&quot;LLP_TCTY&quot;
)paren
comma
id|F
c_func
(paren
l_int|16
comma
l_string|&quot;SSRAM_PERR&quot;
)paren
comma
id|F
c_func
(paren
l_int|15
comma
l_string|&quot;PCI_ABORT&quot;
)paren
comma
id|F
c_func
(paren
l_int|14
comma
l_string|&quot;PCI_PARITY&quot;
)paren
comma
id|F
c_func
(paren
l_int|13
comma
l_string|&quot;PCI_SERR&quot;
)paren
comma
id|F
c_func
(paren
l_int|12
comma
l_string|&quot;PCI_PERR&quot;
)paren
comma
id|F
c_func
(paren
l_int|11
comma
l_string|&quot;PCI_MASTER_TOUT&quot;
)paren
comma
id|F
c_func
(paren
l_int|10
comma
l_string|&quot;PCI_RETRY_CNT&quot;
)paren
comma
id|F
c_func
(paren
l_int|9
comma
l_string|&quot;XREAD_REQ_TOUT&quot;
)paren
comma
id|F
c_func
(paren
l_int|8
comma
l_string|&quot;GIO_BENABLE_ERR&quot;
)paren
comma
id|F
c_func
(paren
l_int|7
comma
l_string|&quot;INT7&quot;
)paren
comma
id|F
c_func
(paren
l_int|6
comma
l_string|&quot;INT6&quot;
)paren
comma
id|F
c_func
(paren
l_int|5
comma
l_string|&quot;INT5&quot;
)paren
comma
id|F
c_func
(paren
l_int|4
comma
l_string|&quot;INT4&quot;
)paren
comma
id|F
c_func
(paren
l_int|3
comma
l_string|&quot;INT3&quot;
)paren
comma
id|F
c_func
(paren
l_int|2
comma
l_string|&quot;INT2&quot;
)paren
comma
id|F
c_func
(paren
l_int|1
comma
l_string|&quot;INT1&quot;
)paren
comma
id|F
c_func
(paren
l_int|0
comma
l_string|&quot;INT0&quot;
)paren
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|space_v
r_struct
id|reg_values
id|space_v
(braket
)braket
op_assign
(brace
(brace
id|PCIIO_SPACE_NONE
comma
l_string|&quot;none&quot;
)brace
comma
(brace
id|PCIIO_SPACE_ROM
comma
l_string|&quot;ROM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_IO
comma
l_string|&quot;I/O&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM
comma
l_string|&quot;MEM&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM32
comma
l_string|&quot;MEM(32)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_MEM64
comma
l_string|&quot;MEM(64)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_CFG
comma
l_string|&quot;CFG&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
comma
l_string|&quot;WIN(0)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|1
)paren
comma
l_string|&quot;WIN(1)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|2
)paren
comma
l_string|&quot;WIN(2)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|3
)paren
comma
l_string|&quot;WIN(3)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|4
)paren
comma
l_string|&quot;WIN(4)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|5
)paren
comma
l_string|&quot;WIN(5)&quot;
)brace
comma
(brace
id|PCIIO_SPACE_BAD
comma
l_string|&quot;BAD&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|space_desc
r_struct
id|reg_desc
id|space_desc
(braket
)braket
op_assign
(brace
(brace
l_int|0xFF
comma
l_int|0
comma
l_string|&quot;space&quot;
comma
l_int|0
comma
id|space_v
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#if DEBUG
DECL|macro|device_desc
mdefine_line|#define&t;device_desc&t;device_bits
DECL|variable|device_bits
id|LOCAL
r_struct
id|reg_desc
id|device_bits
(braket
)braket
op_assign
(brace
(brace
id|BRIDGE_DEV_ERR_LOCK_EN
comma
l_int|0
comma
l_string|&quot;ERR_LOCK_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PAGE_CHK_DIS
comma
l_int|0
comma
l_string|&quot;PAGE_CHK_DIS&quot;
)brace
comma
(brace
id|BRIDGE_DEV_FORCE_PCI_PAR
comma
l_int|0
comma
l_string|&quot;FORCE_PCI_PAR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_VIRTUAL_EN
comma
l_int|0
comma
l_string|&quot;VIRTUAL_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PMU_WRGA_EN
comma
l_int|0
comma
l_string|&quot;PMU_WRGA_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DIR_WRGA_EN
comma
l_int|0
comma
l_string|&quot;DIR_WRGA_EN&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_SIZE
comma
l_int|0
comma
l_string|&quot;DEV_SIZE&quot;
)brace
comma
(brace
id|BRIDGE_DEV_RT
comma
l_int|0
comma
l_string|&quot;RT&quot;
)brace
comma
(brace
id|BRIDGE_DEV_SWAP_PMU
comma
l_int|0
comma
l_string|&quot;SWAP_PMU&quot;
)brace
comma
(brace
id|BRIDGE_DEV_SWAP_DIR
comma
l_int|0
comma
l_string|&quot;SWAP_DIR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PREF
comma
l_int|0
comma
l_string|&quot;PREF&quot;
)brace
comma
(brace
id|BRIDGE_DEV_PRECISE
comma
l_int|0
comma
l_string|&quot;PRECISE&quot;
)brace
comma
(brace
id|BRIDGE_DEV_COH
comma
l_int|0
comma
l_string|&quot;COH&quot;
)brace
comma
(brace
id|BRIDGE_DEV_BARRIER
comma
l_int|0
comma
l_string|&quot;BARRIER&quot;
)brace
comma
(brace
id|BRIDGE_DEV_GBR
comma
l_int|0
comma
l_string|&quot;GBR&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_SWAP
comma
l_int|0
comma
l_string|&quot;DEV_SWAP&quot;
)brace
comma
(brace
id|BRIDGE_DEV_DEV_IO_MEM
comma
l_int|0
comma
l_string|&quot;DEV_IO_MEM&quot;
)brace
comma
(brace
id|BRIDGE_DEV_OFF_MASK
comma
id|BRIDGE_DEV_OFF_ADDR_SHFT
comma
l_string|&quot;DEV_OFF&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif&t;/* DEBUG */
macro_line|#ifdef SUPPORT_PRINTING_R_FORMAT
DECL|variable|xio_cmd_pactyp
id|LOCAL
r_struct
id|reg_values
id|xio_cmd_pactyp
(braket
)braket
op_assign
(brace
(brace
l_int|0x0
comma
l_string|&quot;RdReq&quot;
)brace
comma
(brace
l_int|0x1
comma
l_string|&quot;RdResp&quot;
)brace
comma
(brace
l_int|0x2
comma
l_string|&quot;WrReqWithResp&quot;
)brace
comma
(brace
l_int|0x3
comma
l_string|&quot;WrResp&quot;
)brace
comma
(brace
l_int|0x4
comma
l_string|&quot;WrReqNoResp&quot;
)brace
comma
(brace
l_int|0x5
comma
l_string|&quot;Reserved(5)&quot;
)brace
comma
(brace
l_int|0x6
comma
l_string|&quot;FetchAndOp&quot;
)brace
comma
(brace
l_int|0x7
comma
l_string|&quot;Reserved(7)&quot;
)brace
comma
(brace
l_int|0x8
comma
l_string|&quot;StoreAndOp&quot;
)brace
comma
(brace
l_int|0x9
comma
l_string|&quot;Reserved(9)&quot;
)brace
comma
(brace
l_int|0xa
comma
l_string|&quot;Reserved(a)&quot;
)brace
comma
(brace
l_int|0xb
comma
l_string|&quot;Reserved(b)&quot;
)brace
comma
(brace
l_int|0xc
comma
l_string|&quot;Reserved(c)&quot;
)brace
comma
(brace
l_int|0xd
comma
l_string|&quot;Reserved(d)&quot;
)brace
comma
(brace
l_int|0xe
comma
l_string|&quot;SpecialReq&quot;
)brace
comma
(brace
l_int|0xf
comma
l_string|&quot;SpecialResp&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|xio_cmd_bits
id|LOCAL
r_struct
id|reg_desc
id|xio_cmd_bits
(braket
)braket
op_assign
(brace
(brace
id|WIDGET_DIDN
comma
op_minus
l_int|28
comma
l_string|&quot;DIDN&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_SIDN
comma
op_minus
l_int|24
comma
l_string|&quot;SIDN&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_PACTYP
comma
op_minus
l_int|20
comma
l_string|&quot;PACTYP&quot;
comma
l_int|0
comma
id|xio_cmd_pactyp
)brace
comma
(brace
id|WIDGET_TNUM
comma
op_minus
l_int|15
comma
l_string|&quot;TNUM&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|WIDGET_COHERENT
comma
l_int|0
comma
l_string|&quot;COHERENT&quot;
)brace
comma
(brace
id|WIDGET_DS
comma
l_int|0
comma
l_string|&quot;DS&quot;
)brace
comma
(brace
id|WIDGET_GBR
comma
l_int|0
comma
l_string|&quot;GBR&quot;
)brace
comma
(brace
id|WIDGET_VBPM
comma
l_int|0
comma
l_string|&quot;VBPM&quot;
)brace
comma
(brace
id|WIDGET_ERROR
comma
l_int|0
comma
l_string|&quot;ERROR&quot;
)brace
comma
(brace
id|WIDGET_BARRIER
comma
l_int|0
comma
l_string|&quot;BARRIER&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif&t;/* SUPPORT_PRINTING_R_FORMAT */
macro_line|#if PCIBR_FREEZE_TIME || PCIBR_ATE_DEBUG
DECL|variable|ate_bits
id|LOCAL
r_struct
id|reg_desc
id|ate_bits
(braket
)braket
op_assign
(brace
(brace
l_int|0xFFFF000000000000ull
comma
op_minus
l_int|48
comma
l_string|&quot;RMF&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
op_complement
(paren
id|IOPGSIZE
op_minus
l_int|1
)paren
op_amp
multiline_comment|/* may trim off some low bits */
l_int|0x0000FFFFFFFFF000ull
comma
l_int|0
comma
l_string|&quot;XIO&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
l_int|0x0000000000000F00ull
comma
op_minus
l_int|8
comma
l_string|&quot;port&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
l_int|0x0000000000000010ull
comma
l_int|0
comma
l_string|&quot;Barrier&quot;
)brace
comma
(brace
l_int|0x0000000000000008ull
comma
l_int|0
comma
l_string|&quot;Prefetch&quot;
)brace
comma
(brace
l_int|0x0000000000000004ull
comma
l_int|0
comma
l_string|&quot;Precise&quot;
)brace
comma
(brace
l_int|0x0000000000000002ull
comma
l_int|0
comma
l_string|&quot;Coherent&quot;
)brace
comma
(brace
l_int|0x0000000000000001ull
comma
l_int|0
comma
l_string|&quot;Valid&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if PCIBR_ATE_DEBUG
DECL|variable|ssram_sizes
id|LOCAL
r_struct
id|reg_values
id|ssram_sizes
(braket
)braket
op_assign
(brace
(brace
id|BRIDGE_CTRL_SSRAM_512K
comma
l_string|&quot;512k&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SSRAM_128K
comma
l_string|&quot;128k&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SSRAM_64K
comma
l_string|&quot;64k&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SSRAM_1K
comma
l_string|&quot;1k&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|control_bits
id|LOCAL
r_struct
id|reg_desc
id|control_bits
(braket
)braket
op_assign
(brace
(brace
id|BRIDGE_CTRL_FLASH_WR_EN
comma
l_int|0
comma
l_string|&quot;FLASH_WR_EN&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_EN_CLK50
comma
l_int|0
comma
l_string|&quot;EN_CLK50&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_EN_CLK40
comma
l_int|0
comma
l_string|&quot;EN_CLK40&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_EN_CLK33
comma
l_int|0
comma
l_string|&quot;EN_CLK33&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_RST_MASK
comma
op_minus
l_int|24
comma
l_string|&quot;RST&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_IO_SWAP
comma
l_int|0
comma
l_string|&quot;IO_SWAP&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_MEM_SWAP
comma
l_int|0
comma
l_string|&quot;MEM_SWAP&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_PAGE_SIZE
comma
l_int|0
comma
l_string|&quot;PAGE_SIZE&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SS_PAR_BAD
comma
l_int|0
comma
l_string|&quot;SS_PAR_BAD&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SS_PAR_EN
comma
l_int|0
comma
l_string|&quot;SS_PAR_EN&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SSRAM_SIZE_MASK
comma
l_int|0
comma
l_string|&quot;SSRAM_SIZE&quot;
comma
l_int|0
comma
id|ssram_sizes
)brace
comma
(brace
id|BRIDGE_CTRL_F_BAD_PKT
comma
l_int|0
comma
l_string|&quot;F_BAD_PKT&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_LLP_XBAR_CRD_MASK
comma
op_minus
l_int|12
comma
l_string|&quot;LLP_XBAR_CRD&quot;
comma
l_string|&quot;%d&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_CLR_RLLP_CNT
comma
l_int|0
comma
l_string|&quot;CLR_RLLP_CNT&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_CLR_TLLP_CNT
comma
l_int|0
comma
l_string|&quot;CLR_TLLP_CNT&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_SYS_END
comma
l_int|0
comma
l_string|&quot;SYS_END&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_MAX_TRANS_MASK
comma
op_minus
l_int|4
comma
l_string|&quot;MAX_TRANS&quot;
comma
l_string|&quot;%d&quot;
)brace
comma
(brace
id|BRIDGE_CTRL_WIDGET_ID_MASK
comma
l_int|0
comma
l_string|&quot;WIDGET_ID&quot;
comma
l_string|&quot;%x&quot;
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* kbrick widgetnum-to-bus layout */
DECL|variable|p_busnum
r_int
id|p_busnum
(braket
id|MAX_PORT_NUM
)braket
op_assign
(brace
multiline_comment|/* widget#      */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x0 - 0x7    */
l_int|2
comma
multiline_comment|/* 0x8          */
l_int|1
comma
multiline_comment|/* 0x9          */
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0xa - 0xb    */
l_int|5
comma
multiline_comment|/* 0xc          */
l_int|6
comma
multiline_comment|/* 0xd          */
l_int|4
comma
multiline_comment|/* 0xe          */
l_int|3
comma
multiline_comment|/* 0xf          */
)brace
suffix:semicolon
multiline_comment|/*&n; * Additional PIO spaces per slot are&n; * recorded in this structure.&n; */
DECL|struct|pciio_piospace_s
r_struct
id|pciio_piospace_s
(brace
DECL|member|next
id|pciio_piospace_t
id|next
suffix:semicolon
multiline_comment|/* another space for this device */
DECL|member|free
r_char
id|free
suffix:semicolon
multiline_comment|/* 1 if free, 0 if in use               */
DECL|member|space
id|pciio_space_t
id|space
suffix:semicolon
multiline_comment|/* Which space is in use                */
DECL|member|start
id|iopaddr_t
id|start
suffix:semicolon
multiline_comment|/* Starting address of the PIO space    */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* size of PIO space                    */
)brace
suffix:semicolon
multiline_comment|/* Use io spin locks. This ensures that all the PIO writes from a particular&n; * CPU to a particular IO device are synched before the start of the next&n; * set of PIO operations to the same device.&n; */
DECL|macro|pcibr_lock
mdefine_line|#define pcibr_lock(pcibr_soft)&t;&t;io_splock(pcibr_soft-&gt;bs_lock)
DECL|macro|pcibr_unlock
mdefine_line|#define pcibr_unlock(pcibr_soft, s)&t;io_spunlock(pcibr_soft-&gt;bs_lock,s)
macro_line|#if PCIBR_SOFT_LIST
DECL|typedef|pcibr_list_p
r_typedef
r_struct
id|pcibr_list_s
op_star
id|pcibr_list_p
suffix:semicolon
DECL|struct|pcibr_list_s
r_struct
id|pcibr_list_s
(brace
DECL|member|bl_next
id|pcibr_list_p
id|bl_next
suffix:semicolon
DECL|member|bl_soft
id|pcibr_soft_t
id|bl_soft
suffix:semicolon
DECL|member|bl_vhdl
id|devfs_handle_t
id|bl_vhdl
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pcibr_list
id|pcibr_list_p
id|pcibr_list
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|typedef|cfg_p
r_typedef
r_volatile
r_int
op_star
id|cfg_p
suffix:semicolon
DECL|typedef|reg_p
r_typedef
r_volatile
id|bridgereg_t
op_star
id|reg_p
suffix:semicolon
DECL|macro|INFO_LBL_PCIBR_ASIC_REV
mdefine_line|#define&t;INFO_LBL_PCIBR_ASIC_REV&t;&quot;_pcibr_asic_rev&quot;
DECL|macro|PCIBR_D64_BASE_UNSET
mdefine_line|#define&t;PCIBR_D64_BASE_UNSET&t;(0xFFFFFFFFFFFFFFFF)
DECL|macro|PCIBR_D32_BASE_UNSET
mdefine_line|#define&t;PCIBR_D32_BASE_UNSET&t;(0xFFFFFFFF)
DECL|macro|PCIBR_VALID_SLOT
mdefine_line|#define PCIBR_VALID_SLOT(s)&t;(s &lt; 8)
macro_line|#ifdef SN_XXX
r_extern
r_int
id|hub_device_flags_set
c_func
(paren
id|devfs_handle_t
id|widget_dev
comma
id|hub_widget_flags_t
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_extern
id|devfs_handle_t
id|hwgraph_root
suffix:semicolon
r_extern
id|graph_error_t
id|hwgraph_vertex_unref
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
suffix:semicolon
r_extern
r_int
id|cap_able
c_func
(paren
r_uint64
id|x
)paren
suffix:semicolon
r_extern
r_uint64
id|rmalloc
c_func
(paren
r_struct
id|map
op_star
id|mp
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|rmfree
c_func
(paren
r_struct
id|map
op_star
id|mp
comma
r_int
id|size
comma
r_uint64
id|a
)paren
suffix:semicolon
r_extern
r_int
id|hwgraph_vertex_name_get
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
r_extern
r_int
id|atoi
c_func
(paren
r_register
r_char
op_star
id|p
)paren
suffix:semicolon
r_extern
r_void
op_star
id|swap_ptr
c_func
(paren
r_void
op_star
op_star
id|loc
comma
r_void
op_star
r_new
)paren
suffix:semicolon
r_extern
r_char
op_star
id|dev_to_name
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
r_extern
id|cnodeid_t
id|nodevertex_to_cnodeid
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
suffix:semicolon
r_extern
id|graph_error_t
id|hwgraph_edge_remove
c_func
(paren
id|devfs_handle_t
id|from
comma
r_char
op_star
id|name
comma
id|devfs_handle_t
op_star
id|toptr
)paren
suffix:semicolon
r_extern
r_struct
id|map
op_star
id|rmallocmap
c_func
(paren
r_uint64
id|mapsiz
)paren
suffix:semicolon
r_extern
r_void
id|rmfreemap
c_func
(paren
r_struct
id|map
op_star
id|mp
)paren
suffix:semicolon
r_extern
r_int
id|compare_and_swap_ptr
c_func
(paren
r_void
op_star
op_star
id|location
comma
r_void
op_star
id|old_ptr
comma
r_void
op_star
id|new_ptr
)paren
suffix:semicolon
r_extern
r_void
id|cmn_err_tag
c_func
(paren
r_int
id|seqnumber
comma
r_register
r_int
id|level
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    Function Table of Contents&n; *&n; *      The order of functions in this file has stopped&n; *      making much sense. We might want to take a look&n; *      at it some time and bring back some sanity, or&n; *      perhaps bust this file into smaller chunks.&n; */
id|LOCAL
r_void
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_void
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_int
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_int
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
comma
id|pciio_slot_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_void
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|pcibr_wrb_flush
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_rrb_alloc
c_func
(paren
id|devfs_handle_t
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pcibr_rrb_check
c_func
(paren
id|devfs_handle_t
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_int
id|pcibr_alloc_all_rrbs
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_rrb_flush
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
r_int
comma
id|bridgereg_t
)paren
suffix:semicolon
r_void
id|pcibr_release_device
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|bridgereg_t
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_clearwidint
c_func
(paren
id|bridge_t
op_star
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
comma
id|cfg_p
comma
r_int
op_star
)paren
suffix:semicolon
r_void
id|pcibr_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|pcibr_attach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_detach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_open
c_func
(paren
id|devfs_handle_t
op_star
comma
r_int
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_close
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_map
c_func
(paren
id|devfs_handle_t
comma
id|vhandl_t
op_star
comma
id|off_t
comma
r_int
comma
id|uint
)paren
suffix:semicolon
r_int
id|pcibr_unmap
c_func
(paren
id|devfs_handle_t
comma
id|vhandl_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_ioctl
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_void
op_star
comma
r_int
comma
r_struct
id|cred
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_void
id|pcibr_freeblock_sub
c_func
(paren
id|iopaddr_t
op_star
comma
id|iopaddr_t
op_star
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
macro_line|#ifndef BRINGUP
id|LOCAL
r_int
id|pcibr_init_ext_ate_ram
c_func
(paren
id|bridge_t
op_star
)paren
suffix:semicolon
macro_line|#endif
id|LOCAL
r_int
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|LOCAL
id|pcibr_info_t
id|pcibr_info_get
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|LOCAL
id|pcibr_info_t
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_function_t
comma
id|pciio_vendor_id_t
comma
id|pciio_device_id_t
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_device_info_free
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_device_attach
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_device_detach
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
id|iopaddr_t
id|pcibr_addr_pci_to_xio
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|pcibr_piomap_t
id|pcibr_piomap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piomap_free
c_func
(paren
id|pcibr_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pcibr_piomap_addr
c_func
(paren
id|pcibr_piomap_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piomap_done
c_func
(paren
id|pcibr_piomap_t
)paren
suffix:semicolon
id|caddr_t
id|pcibr_piotrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_piospace_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_space_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_piospace_free
c_func
(paren
id|devfs_handle_t
comma
id|pciio_space_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
id|iopaddr_t
id|pcibr_flags_to_d64
c_func
(paren
r_int
comma
id|pcibr_soft_t
)paren
suffix:semicolon
id|LOCAL
id|bridge_ate_t
id|pcibr_flags_to_ate
c_func
(paren
r_int
)paren
suffix:semicolon
id|pcibr_dmamap_t
id|pcibr_dmamap_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_free
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
id|LOCAL
id|bridge_ate_p
id|pcibr_ate_addr
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
id|iopaddr_t
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft_t
comma
id|iopaddr_t
comma
r_int
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmamap_addr
c_func
(paren
id|pcibr_dmamap_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|pcibr_dmamap_list
c_func
(paren
id|pcibr_dmamap_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_done
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
id|cnodeid_t
id|pcibr_get_dmatrans_node
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmatrans_addr
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|paddr_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|alenlist_t
id|pcibr_dmatrans_list
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|alenlist_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmamap_drain
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_void
id|pcibr_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
comma
id|paddr_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_dmalist_drain
c_func
(paren
id|devfs_handle_t
comma
id|alenlist_t
)paren
suffix:semicolon
id|iopaddr_t
id|pcibr_dmamap_pciaddr_get
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_static
r_int
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
)paren
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr_alloc
c_func
(paren
id|devfs_handle_t
comma
id|device_desc_t
comma
id|pciio_intr_line_t
comma
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
)paren
suffix:semicolon
r_int
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
comma
id|intr_func_t
comma
id|intr_arg_t
comma
r_void
op_star
)paren
suffix:semicolon
r_void
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
id|devfs_handle_t
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
)paren
suffix:semicolon
r_void
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
comma
r_int
comma
id|xwidgetnum_t
comma
id|iopaddr_t
comma
id|xtalk_intr_vector_t
)paren
suffix:semicolon
r_void
id|pcibr_intr_list_func
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
id|LOCAL
r_void
id|print_bridge_errcmd
c_func
(paren
r_uint32
comma
r_char
op_star
)paren
suffix:semicolon
r_void
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
r_uint32
id|pcibr_errintr_group
c_func
(paren
r_uint32
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft_t
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_error_intr_handler
c_func
(paren
id|intr_arg_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_addr_toslot
c_func
(paren
id|pcibr_soft_t
comma
id|iopaddr_t
comma
id|pciio_space_t
op_star
comma
id|iopaddr_t
op_star
comma
id|pciio_function_t
op_star
)paren
suffix:semicolon
id|LOCAL
r_void
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft_t
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_error_handler
c_func
(paren
id|error_handler_arg_t
comma
r_int
comma
id|ioerror_mode_t
comma
id|ioerror_t
op_star
)paren
suffix:semicolon
r_int
id|pcibr_error_devenable
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_provider_startup
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pcibr_provider_shutdown
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_int
id|pcibr_reset
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
id|pciio_endian_t
id|pcibr_endian_set
c_func
(paren
id|devfs_handle_t
comma
id|pciio_endian_t
comma
id|pciio_endian_t
)paren
suffix:semicolon
r_int
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft_t
comma
id|pciio_slot_t
comma
id|pciio_priority_t
)paren
suffix:semicolon
id|pciio_priority_t
id|pcibr_priority_set
c_func
(paren
id|devfs_handle_t
comma
id|pciio_priority_t
)paren
suffix:semicolon
r_int
id|pcibr_device_flags_set
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_device_flags_t
)paren
suffix:semicolon
id|LOCAL
id|cfg_p
id|pcibr_config_addr
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
r_uint64
id|pcibr_config_get
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|LOCAL
r_uint64
id|do_pcibr_config_get
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_config_set
c_func
(paren
id|devfs_handle_t
comma
r_int
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
id|LOCAL
r_void
id|do_pcibr_config_set
c_func
(paren
id|cfg_p
comma
r_int
comma
r_int
comma
r_uint64
)paren
suffix:semicolon
id|LOCAL
id|pcibr_hints_t
id|pcibr_hints_get
c_func
(paren
id|devfs_handle_t
comma
r_int
)paren
suffix:semicolon
r_void
id|pcibr_hints_fix_rrbs
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pcibr_hints_dualslot
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_void
id|pcibr_hints_intr_bits
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_intr_bits_f
op_star
)paren
suffix:semicolon
r_void
id|pcibr_set_rrb_callback
c_func
(paren
id|devfs_handle_t
comma
id|rrb_alloc_funct_t
)paren
suffix:semicolon
r_void
id|pcibr_hints_handsoff
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|pcibr_hints_subdevs
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
r_uint64
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_reset
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_info_init
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_info_free
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_addr_space_init
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_device_init
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_guest_info_init
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_call_device_attach
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
id|LOCAL
r_int
id|pcibr_slot_call_device_detach
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_powerup
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_shutdown
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_int
id|pcibr_slot_inquiry
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    RRB management&n; */
DECL|macro|LSBIT
mdefine_line|#define LSBIT(word)&t;&t;((word) &amp;~ ((word)-1))
DECL|macro|PCIBR_RRB_SLOT_VIRTUAL
mdefine_line|#define PCIBR_RRB_SLOT_VIRTUAL&t;8
id|LOCAL
r_void
DECL|function|do_pcibr_rrb_clear
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrb
)paren
(brace
id|bridgereg_t
id|status
suffix:semicolon
multiline_comment|/* bridge_lock must be held;&n;     * this RRB must be disabled.&n;     */
multiline_comment|/* wait until RRB has no outstanduing XIO packets. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_INUSE
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
multiline_comment|/* if the RRB has data, drain it. */
r_if
c_cond
(paren
id|status
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
id|bridge-&gt;b_resp_clear
op_assign
id|BRIDGE_RRB_CLEAR
c_func
(paren
id|rrb
)paren
suffix:semicolon
multiline_comment|/* wait until RRB is no longer valid. */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|bridge-&gt;b_resp_status
)paren
op_amp
id|BRIDGE_RRB_VALID
c_func
(paren
id|rrb
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* XXX- beats on bridge. bad idea? */
)brace
)brace
)brace
id|LOCAL
r_void
DECL|function|do_pcibr_rrb_flush
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
r_int
id|rrbn
)paren
(brace
id|reg_p
id|rrbp
op_assign
op_amp
id|bridge-&gt;b_rrb_map
(braket
id|rrbn
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|bridgereg_t
id|rrbv
suffix:semicolon
r_int
id|shft
op_assign
l_int|4
op_star
(paren
id|rrbn
op_rshift
l_int|1
)paren
suffix:semicolon
r_int
id|ebit
op_assign
id|BRIDGE_RRB_EN
op_lshift
id|shft
suffix:semicolon
id|rrbv
op_assign
op_star
id|rrbp
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
op_star
id|rrbp
op_assign
id|rrbv
op_amp
op_complement
id|ebit
suffix:semicolon
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
id|rrbn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrbv
op_amp
id|ebit
)paren
op_star
id|rrbp
op_assign
id|rrbv
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_rrb_count_valid: count how many RRBs are&n; *      marked valid for the specified PCI slot on this&n; *      bridge.&n; *&n; *      NOTE: The &quot;slot&quot; parameter for all pcibr_rrb&n; *      management routines must include the &quot;virtual&quot;&n; *      bit; when manageing both the normal and the&n; *      virtual channel, separate calls to these&n; *      routines must be made. To denote the virtual&n; *      channel, add PCIBR_RRB_SLOT_VIRTUAL to the slot&n; *      number.&n; *&n; *      IMPL NOTE: The obvious algorithm is to iterate&n; *      through the RRB fields, incrementing a count if&n; *      the RRB is valid and matches the slot. However,&n; *      it is much simpler to use an algorithm derived&n; *      from the &quot;partitioned add&quot; idea. First, XOR in a&n; *      pattern such that the fields that match this&n; *      slot come up &quot;all ones&quot; and all other fields&n; *      have zeros in the mismatching bits. Then AND&n; *      together the bits in the field, so we end up&n; *      with one bit turned on for each field that&n; *      matched. Now we need to count these bits. This&n; *      can be done either with a series of shift/add&n; *      instructions or by using &quot;tmp % 15&quot;; I expect&n; *      that the cascaded shift/add will be faster.&n; */
id|LOCAL
r_int
DECL|function|do_pcibr_rrb_count_valid
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_xor_assign
l_int|0x11111111
op_star
(paren
l_int|7
op_minus
id|slot
op_div
l_int|2
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0xCCCCCCCC
op_amp
id|tmp
)paren
op_rshift
l_int|2
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x22222222
op_amp
id|tmp
)paren
op_rshift
l_int|1
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|4
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|16
suffix:semicolon
r_return
id|tmp
op_amp
l_int|15
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_count_avail: count how many RRBs are&n; *      available to be allocated for the specified slot.&n; *&n; *      IMPL NOTE: similar to the above, except we are&n; *      just counting how many fields have the valid bit&n; *      turned off.&n; */
id|LOCAL
r_int
DECL|function|do_pcibr_rrb_count_avail
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridgereg_t
id|tmp
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_assign
(paren
l_int|0x88888888
op_amp
op_complement
id|tmp
)paren
op_rshift
l_int|3
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|4
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|tmp
op_add_assign
id|tmp
op_rshift
l_int|16
suffix:semicolon
r_return
id|tmp
op_amp
l_int|15
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_alloc: allocate some additional RRBs&n; *      for the specified slot. Returns -1 if there were&n; *      insufficient free RRBs to satisfy the request,&n; *      or 0 if the request was fulfilled.&n; *&n; *      Note that if a request can be partially filled,&n; *      it will be, even if we return failure.&n; *&n; *      IMPL NOTE: again we avoid iterating across all&n; *      the RRBs; instead, we form up a word containing&n; *      one bit for each free RRB, then peel the bits&n; *      off from the low end.&n; */
id|LOCAL
r_int
DECL|function|do_pcibr_rrb_alloc
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|more
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|reg
comma
id|tmp
comma
id|bit
suffix:semicolon
id|reg
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
id|tmp
op_assign
(paren
l_int|0x88888888
op_amp
op_complement
id|reg
)paren
op_rshift
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|more
op_decrement
OG
l_int|0
)paren
(brace
id|bit
op_assign
id|LSBIT
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
(brace
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_and_assign
op_complement
id|bit
suffix:semicolon
id|reg
op_assign
(paren
(paren
id|reg
op_amp
op_complement
(paren
id|bit
op_star
l_int|15
)paren
)paren
op_or
(paren
id|bit
op_star
(paren
l_int|8
op_plus
id|slot
op_div
l_int|2
)paren
)paren
)paren
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; *    do_pcibr_rrb_free: release some of the RRBs that&n; *      have been allocated for the specified&n; *      slot. Returns zero for success, or negative if&n; *      it was unable to free that many RRBs.&n; *&n; *      IMPL NOTE: We form up a bit for each RRB&n; *      allocated to the slot, aligned with the VALID&n; *      bitfield this time; then we peel bits off one at&n; *      a time, releasing the corresponding RRB.&n; */
id|LOCAL
r_int
DECL|function|do_pcibr_rrb_free
id|do_pcibr_rrb_free
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|pciio_slot_t
id|slot
comma
r_int
id|less
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|reg
comma
id|tmp
comma
id|clr
comma
id|bit
suffix:semicolon
r_int
id|i
suffix:semicolon
id|clr
op_assign
l_int|0
suffix:semicolon
id|reg
op_assign
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
suffix:semicolon
multiline_comment|/* This needs to be done otherwise the rrb&squot;s on the virtual channel&n;     * for this slot won&squot;t be freed !!&n;     */
id|tmp
op_assign
id|reg
op_amp
l_int|0xbbbbbbbb
suffix:semicolon
id|tmp
op_xor_assign
(paren
l_int|0x11111111
op_star
(paren
l_int|7
op_minus
id|slot
op_div
l_int|2
)paren
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x33333333
op_amp
id|tmp
)paren
op_lshift
l_int|2
suffix:semicolon
id|tmp
op_and_assign
(paren
l_int|0x44444444
op_amp
id|tmp
)paren
op_lshift
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|less
op_decrement
OG
l_int|0
)paren
(brace
id|bit
op_assign
id|LSBIT
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
(brace
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_and_assign
op_complement
id|bit
suffix:semicolon
id|reg
op_and_assign
op_complement
id|bit
suffix:semicolon
id|clr
op_or_assign
id|bit
suffix:semicolon
)brace
id|bridge-&gt;b_rrb_map
(braket
id|slot
op_amp
l_int|1
)braket
dot
id|reg
op_assign
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|clr
op_amp
(paren
l_int|8
op_lshift
(paren
l_int|4
op_star
id|i
)paren
)paren
)paren
id|do_pcibr_rrb_clear
c_func
(paren
id|bridge
comma
(paren
l_int|2
op_star
id|i
)paren
op_plus
(paren
id|slot
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|do_pcibr_rrb_autoalloc
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|slot
comma
r_int
id|more_rrbs
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|got
suffix:semicolon
r_for
c_loop
(paren
id|got
op_assign
l_int|0
suffix:semicolon
id|got
OL
id|more_rrbs
suffix:semicolon
op_increment
id|got
)paren
(brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
op_amp
l_int|7
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
op_amp
l_int|7
)braket
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
OG
l_int|0
)paren
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_decrement
suffix:semicolon
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|slot
comma
l_int|1
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;do_pcibr_rrb_autoalloc: add one to slot %d%s&bslash;n&quot;
comma
id|slot
op_amp
l_int|7
comma
id|slot
op_amp
l_int|8
ques
c_cond
l_string|&quot;v&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_increment
suffix:semicolon
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %d+%d free RRBs. Allocation list:&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Device driver interface to flush the write buffers for a specified&n; * device hanging off the bridge.&n; */
r_int
DECL|function|pcibr_wrb_flush
id|pcibr_wrb_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_volatile
id|bridgereg_t
op_star
id|wrb_flush
suffix:semicolon
id|wrb_flush
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|wrb_flush
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to request RRBs for a specified device&n; * hanging off a Bridge.  The driver requests the total number of&n; * RRBs it would like for the normal channel (vchan0) and for the&n; * &quot;virtual channel&quot; (vchan1).  The actual number allocated to each&n; * channel is returned.&n; *&n; * If we cannot allocate at least one RRB to a channel that needs&n; * at least one, return -1 (failure).  Otherwise, satisfy the request&n; * as best we can and return 0.&n; */
r_int
DECL|function|pcibr_rrb_alloc
id|pcibr_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|desired_vchan0
suffix:semicolon
r_int
id|desired_vchan1
suffix:semicolon
r_int
id|orig_vchan0
suffix:semicolon
r_int
id|orig_vchan1
suffix:semicolon
r_int
id|delta_vchan0
suffix:semicolon
r_int
id|delta_vchan1
suffix:semicolon
r_int
id|final_vchan0
suffix:semicolon
r_int
id|final_vchan1
suffix:semicolon
r_int
id|avail_rrbs
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;     * TBD: temper request with admin info about RRB allocation,&n;     * and according to demand from other devices on this Bridge.&n;     *&n;     * One way of doing this would be to allocate two RRBs&n;     * for each device on the bus, before any drivers start&n;     * asking for extras. This has the weakness that one&n;     * driver might not give back an &quot;extra&quot; RRB until after&n;     * another driver has already failed to get one that&n;     * it wanted.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* How many RRBs do we own? */
id|orig_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
id|orig_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
multiline_comment|/* How many RRBs do we want? */
id|desired_vchan0
op_assign
id|count_vchan0
ques
c_cond
op_star
id|count_vchan0
suffix:colon
id|orig_vchan0
suffix:semicolon
id|desired_vchan1
op_assign
id|count_vchan1
ques
c_cond
op_star
id|count_vchan1
suffix:colon
id|orig_vchan1
suffix:semicolon
multiline_comment|/* How many RRBs are free? */
id|avail_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
multiline_comment|/* Figure desired deltas */
id|delta_vchan0
op_assign
id|desired_vchan0
op_minus
id|orig_vchan0
suffix:semicolon
id|delta_vchan1
op_assign
id|desired_vchan1
op_minus
id|orig_vchan1
suffix:semicolon
multiline_comment|/* Trim back deltas to something&n;     * that we can actually meet, by&n;     * decreasing the ending allocation&n;     * for whichever channel wants&n;     * more RRBs. If both want the same&n;     * number, cut the second channel.&n;     * NOTE: do not change the allocation for&n;     * a channel that was passed as NULL.&n;     */
r_while
c_loop
(paren
(paren
id|delta_vchan0
op_plus
id|delta_vchan1
)paren
OG
id|avail_rrbs
)paren
(brace
r_if
c_cond
(paren
id|count_vchan0
op_logical_and
(paren
op_logical_neg
id|count_vchan1
op_logical_or
(paren
(paren
id|orig_vchan0
op_plus
id|delta_vchan0
)paren
OG
(paren
id|orig_vchan1
op_plus
id|delta_vchan1
)paren
)paren
)paren
)paren
id|delta_vchan0
op_decrement
suffix:semicolon
r_else
id|delta_vchan1
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Figure final RRB allocations&n;     */
id|final_vchan0
op_assign
id|orig_vchan0
op_plus
id|delta_vchan0
suffix:semicolon
id|final_vchan1
op_assign
id|orig_vchan1
op_plus
id|delta_vchan1
suffix:semicolon
multiline_comment|/* If either channel wants RRBs but our actions&n;     * would leave it with none, declare an error,&n;     * but DO NOT change any RRB allocations.&n;     */
r_if
c_cond
(paren
(paren
id|desired_vchan0
op_logical_and
op_logical_neg
id|final_vchan0
)paren
op_logical_or
(paren
id|desired_vchan1
op_logical_and
op_logical_neg
id|final_vchan1
)paren
)paren
(brace
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Commit the allocations: free, then alloc.&n;&t; */
r_if
c_cond
(paren
id|delta_vchan0
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
op_minus
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OL
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|PCIBR_RRB_SLOT_VIRTUAL
op_plus
id|pciio_slot
comma
op_minus
id|delta_vchan1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan0
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|pciio_slot
comma
id|delta_vchan0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_vchan1
OG
l_int|0
)paren
(paren
r_void
)paren
id|do_pcibr_rrb_alloc
c_func
(paren
id|bridge
comma
id|PCIBR_RRB_SLOT_VIRTUAL
op_plus
id|pciio_slot
comma
id|delta_vchan1
)paren
suffix:semicolon
multiline_comment|/* Return final values to caller.&n;&t; */
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|final_vchan0
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|final_vchan1
suffix:semicolon
multiline_comment|/* prevent automatic changes to this slot&squot;s RRBs&n;&t; */
id|pcibr_soft-&gt;bs_rrb_fixed
op_or_assign
l_int|1
op_lshift
id|pciio_slot
suffix:semicolon
multiline_comment|/* Track the actual allocations, release&n;&t; * any further reservations, and update the&n;&t; * number of available RRBs.&n;&t; */
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
op_assign
id|final_vchan0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|final_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_minus
id|delta_vchan0
op_minus
id|delta_vchan1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_rrb_alloc: slot %d set to %d+%d; %d+%d free&bslash;n&quot;
comma
id|pciio_slot
comma
id|final_vchan0
comma
id|final_vchan1
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pciio_slot
op_assign
l_int|0
suffix:semicolon
id|pciio_slot
OL
l_int|8
suffix:semicolon
op_increment
id|pciio_slot
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Device driver interface to check the current state&n; * of the RRB allocations.&n; *&n; *   pconn_vhdl is your PCI connection point (specifies which&n; *      PCI bus and which slot).&n; *&n; *   count_vchan0 points to where to return the number of RRBs&n; *      assigned to the primary DMA channel, used by all DMA&n; *      that does not explicitly ask for the alternate virtual&n; *      channel.&n; *&n; *   count_vchan1 points to where to return the number of RRBs&n; *      assigned to the secondary DMA channel, used when&n; *      PCIBR_VCHAN1 and PCIIO_DMA_A64 are specified.&n; *&n; *   count_reserved points to where to return the number of RRBs&n; *      that have been automatically reserved for your device at&n; *      startup, but which have not been assigned to a&n; *      channel. RRBs must be assigned to a channel to be used;&n; *      this can be done either with an explicit pcibr_rrb_alloc&n; *      call, or automatically by the infrastructure when a DMA&n; *      translation is constructed. Any call to pcibr_rrb_alloc&n; *      will release any unassigned reserved RRBs back to the&n; *      free pool.&n; *&n; *   count_pool points to where to return the number of RRBs&n; *      that are currently unassigned and unreserved. This&n; *      number can (and will) change as other drivers make calls&n; *      to pcibr_rrb_alloc, or automatically allocate RRBs for&n; *      DMA beyond their initial reservation.&n; *&n; * NULL may be passed for any of the return value pointers&n; * the caller is not interested in.&n; *&n; * The return value is &quot;0&quot; if all went well, or &quot;-1&quot; if&n; * there is a problem. Additionally, if the wrong vertex&n; * is passed in, one of the subsidiary support functions&n; * could panic with a &quot;bad pciio fingerprint.&quot;&n; */
r_int
DECL|function|pcibr_rrb_check
id|pcibr_rrb_check
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
comma
r_int
op_star
id|count_reserved
comma
r_int
op_star
id|count_pool
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
)paren
op_logical_and
(paren
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
)paren
op_logical_and
(paren
(paren
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
)paren
OL
l_int|8
)paren
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan0
)paren
op_star
id|count_vchan0
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_vchan1
)paren
op_star
id|count_vchan1
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_reserved
)paren
op_star
id|count_reserved
op_assign
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count_pool
)paren
op_star
id|count_pool
op_assign
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|pciio_slot
op_amp
l_int|1
)braket
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* pcibr_alloc_all_rrbs allocates all the rrbs available in the quantities&n; * requested for each of the devies.  The evn_odd argument indicates whether&n; * allcoation for the odd or even rrbs is requested and next group of four pairse&n; * are the amount to assign to each device (they should sum to &lt;= 8) and&n; * whether to set the viritual bit for that device (1 indictaes yes, 0 indicates no)&n; * the devices in order are either 0, 2, 4, 6 or 1, 3, 5, 7&n; * if even_odd is even we alloc even rrbs else we allocate odd rrbs&n; * returns 0 if no errors else returns -1&n; */
r_int
DECL|function|pcibr_alloc_all_rrbs
id|pcibr_alloc_all_rrbs
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|even_odd
comma
r_int
id|dev_1_rrbs
comma
r_int
id|virt1
comma
r_int
id|dev_2_rrbs
comma
r_int
id|virt2
comma
r_int
id|dev_3_rrbs
comma
r_int
id|virt3
comma
r_int
id|dev_4_rrbs
comma
r_int
id|virt4
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
macro_line|#ifdef colin
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
macro_line|#else
id|pcibr_soft_t
id|pcibr_soft
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|bridge_t
op_star
id|bridge
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|rrb_setting
op_assign
l_int|0
suffix:semicolon
r_int
id|rrb_shift
op_assign
l_int|7
suffix:semicolon
r_uint32
id|cur_rrb
suffix:semicolon
r_int
id|dev_rrbs
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|virt
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|hwgraph_traverse
c_func
(paren
id|vhdl
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
)paren
(brace
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft
)paren
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bridge
op_eq
l_int|NULL
)paren
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_piotrans_addr
(paren
id|vhdl
comma
l_int|NULL
comma
l_int|0
comma
r_sizeof
(paren
id|bridge_t
)paren
comma
l_int|0
)paren
suffix:semicolon
id|even_odd
op_and_assign
l_int|1
suffix:semicolon
id|dev_rrbs
(braket
l_int|0
)braket
op_assign
id|dev_1_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|1
)braket
op_assign
id|dev_2_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|2
)braket
op_assign
id|dev_3_rrbs
suffix:semicolon
id|dev_rrbs
(braket
l_int|3
)braket
op_assign
id|dev_4_rrbs
suffix:semicolon
id|virt
(braket
l_int|0
)braket
op_assign
id|virt1
suffix:semicolon
id|virt
(braket
l_int|1
)braket
op_assign
id|virt2
suffix:semicolon
id|virt
(braket
l_int|2
)braket
op_assign
id|virt3
suffix:semicolon
id|virt
(braket
l_int|3
)braket
op_assign
id|virt4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev_1_rrbs
op_plus
id|dev_2_rrbs
op_plus
id|dev_3_rrbs
op_plus
id|dev_4_rrbs
)paren
OG
l_int|8
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev_1_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_2_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_3_rrbs
OL
l_int|0
)paren
op_logical_or
(paren
id|dev_4_rrbs
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* walk through rrbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|virt
(braket
id|i
)braket
)paren
(brace
id|cur_rrb
op_assign
id|i
op_or
l_int|0xc
suffix:semicolon
id|cur_rrb
op_assign
id|cur_rrb
op_lshift
(paren
id|rrb_shift
op_star
l_int|4
)paren
suffix:semicolon
id|rrb_shift
op_decrement
suffix:semicolon
id|rrb_setting
op_assign
id|rrb_setting
op_or
id|cur_rrb
suffix:semicolon
id|dev_rrbs
(braket
id|i
)braket
op_assign
id|dev_rrbs
(braket
id|i
)braket
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dev_rrbs
(braket
id|i
)braket
suffix:semicolon
id|j
op_increment
)paren
(brace
id|cur_rrb
op_assign
id|i
op_or
l_int|0x8
suffix:semicolon
id|cur_rrb
op_assign
id|cur_rrb
op_lshift
(paren
id|rrb_shift
op_star
l_int|4
)paren
suffix:semicolon
id|rrb_shift
op_decrement
suffix:semicolon
id|rrb_setting
op_assign
id|rrb_setting
op_or
id|cur_rrb
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibr_soft
)paren
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge-&gt;b_rrb_map
(braket
id|even_odd
)braket
dot
id|reg
op_assign
id|rrb_setting
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_fixed
op_or_assign
l_int|0x55
op_lshift
id|even_odd
suffix:semicolon
multiline_comment|/* since we&squot;ve &quot;FIXED&quot; the allocations&n;&t; * for these slots, we probably can dispense&n;&t; * with tracking avail/res/valid data, but&n;&t; * keeping it up to date helps debugging.&n;&t; */
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|even_odd
)braket
op_assign
l_int|8
op_minus
(paren
id|dev_1_rrbs
op_plus
id|dev_2_rrbs
op_plus
id|dev_3_rrbs
op_plus
id|dev_4_rrbs
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|even_odd
op_plus
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|0
)braket
op_assign
id|dev_1_rrbs
op_minus
id|virt1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|2
)braket
op_assign
id|dev_2_rrbs
op_minus
id|virt2
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|4
)braket
op_assign
id|dev_3_rrbs
op_minus
id|virt3
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|6
)braket
op_assign
id|dev_4_rrbs
op_minus
id|virt4
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|0
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|2
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt2
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|4
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt3
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|even_odd
op_plus
l_int|6
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|virt4
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_rrb_flush: chase down all the RRBs assigned&n; *      to the specified connection point, and flush&n; *      them.&n; */
r_void
DECL|function|pcibr_rrb_flush
id|pcibr_rrb_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|s
suffix:semicolon
id|reg_p
id|rrbp
suffix:semicolon
r_int
id|rrbm
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rrbn
suffix:semicolon
r_int
id|sval
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|sval
op_assign
id|BRIDGE_RRB_EN
op_or
(paren
id|pciio_slot
op_rshift
l_int|1
)paren
suffix:semicolon
id|mask
op_assign
id|BRIDGE_RRB_EN
op_or
id|BRIDGE_RRB_PDEV
suffix:semicolon
id|rrbn
op_assign
id|pciio_slot
op_amp
l_int|1
suffix:semicolon
id|rrbp
op_assign
op_amp
id|bridge-&gt;b_rrb_map
(braket
id|rrbn
)braket
dot
id|reg
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|rrbm
op_assign
op_star
id|rrbp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|rrbm
op_amp
id|mask
)paren
op_eq
id|sval
)paren
id|do_pcibr_rrb_flush
c_func
(paren
id|bridge
comma
id|rrbn
)paren
suffix:semicolon
id|rrbm
op_rshift_assign
l_int|4
suffix:semicolon
id|rrbn
op_add_assign
l_int|2
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    Device(x) register management&n; */
multiline_comment|/* pcibr_try_set_device: attempt to modify Device(x)&n; * for the specified slot on the specified bridge&n; * as requested in flags, limited to the specified&n; * bits. Returns which BRIDGE bits were in conflict,&n; * or ZERO if everything went OK.&n; *&n; * Caller MUST hold pcibr_lock when calling this function.&n; */
id|LOCAL
r_int
DECL|function|pcibr_try_set_device
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
r_int
id|flags
comma
id|bridgereg_t
id|mask
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|bridgereg_t
id|old
suffix:semicolon
id|bridgereg_t
r_new
suffix:semicolon
id|bridgereg_t
id|chg
suffix:semicolon
id|bridgereg_t
id|bad
suffix:semicolon
id|bridgereg_t
id|badpmu
suffix:semicolon
id|bridgereg_t
id|badd32
suffix:semicolon
id|bridgereg_t
id|badd64
suffix:semicolon
id|bridgereg_t
id|fix
suffix:semicolon
r_int
id|s
suffix:semicolon
id|bridgereg_t
id|xmask
suffix:semicolon
id|xmask
op_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|xmask
op_assign
id|XBRIDGE_DEV_PMU_BITS
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|xmask
op_assign
id|XBRIDGE_DEV_D64_BITS
suffix:semicolon
)brace
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|old
op_assign
id|slotp-&gt;bss_device
suffix:semicolon
multiline_comment|/* figure out what the desired&n;     * Device(x) bits are based on&n;     * the flags specified.&n;     */
r_new
op_assign
id|old
suffix:semicolon
multiline_comment|/* Currently, we inherit anything that&n;     * the new caller has not specified in&n;     * one way or another, unless we take&n;     * action here to not inherit.&n;     *&n;     * This is needed for the &quot;swap&quot; stuff,&n;     * since it could have been set via&n;     * pcibr_endian_set -- altho note that&n;     * any explicit PCIBR_BYTE_STREAM or&n;     * PCIBR_WORD_VALUES will freely override&n;     * the effect of that call (and vice&n;     * versa, no protection either way).&n;     *&n;     * I want to get rid of pcibr_endian_set&n;     * in favor of tracking DMA endianness&n;     * using the flags specified when DMA&n;     * channels are created.&n;     */
DECL|macro|BRIDGE_DEV_WRGA_BITS
mdefine_line|#define&t;BRIDGE_DEV_WRGA_BITS&t;(BRIDGE_DEV_PMU_WRGA_EN | BRIDGE_DEV_DIR_WRGA_EN)
DECL|macro|BRIDGE_DEV_SWAP_BITS
mdefine_line|#define&t;BRIDGE_DEV_SWAP_BITS&t;(BRIDGE_DEV_SWAP_PMU | BRIDGE_DEV_SWAP_DIR)
multiline_comment|/* Do not use Barrier, Write Gather,&n;     * or Prefetch unless asked.&n;     * Leave everything else as it&n;     * was from the last time.&n;     */
r_new
op_assign
r_new
op_amp
op_complement
id|BRIDGE_DEV_BARRIER
op_amp
op_complement
id|BRIDGE_DEV_WRGA_BITS
op_amp
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
multiline_comment|/* Generic macro flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_DATA
)paren
(brace
macro_line|#ifdef colin
r_new
op_assign
r_new
op_amp
op_complement
id|BRIDGE_DEV_BARRIER
multiline_comment|/* barrier off */
op_or
id|BRIDGE_DEV_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
macro_line|#else
r_new
op_assign
(paren
r_new
op_amp
op_complement
id|BRIDGE_DEV_BARRIER
)paren
multiline_comment|/* barrier off */
op_or
id|BRIDGE_DEV_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
macro_line|#endif
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_CMD
)paren
(brace
macro_line|#ifdef colin
r_new
op_assign
r_new
op_amp
op_complement
id|BRIDGE_DEV_PREF
multiline_comment|/* prefetch off */
op_amp
op_complement
id|BRIDGE_DEV_WRGA_BITS
multiline_comment|/* write gather off */
op_or
id|BRIDGE_DEV_BARRIER
suffix:semicolon
multiline_comment|/* barrier on */
macro_line|#else
r_new
op_assign
(paren
(paren
r_new
op_amp
op_complement
id|BRIDGE_DEV_PREF
)paren
multiline_comment|/* prefetch off */
op_amp
op_complement
id|BRIDGE_DEV_WRGA_BITS
)paren
multiline_comment|/* write gather off */
op_or
id|BRIDGE_DEV_BARRIER
suffix:semicolon
multiline_comment|/* barrier on */
macro_line|#endif
)brace
multiline_comment|/* Generic detail flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WRITE_GATHER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOWRITE_GATHER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_PREFETCH
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOPREFETCH
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_WRGA_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
r_new
op_or_assign
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
ques
c_cond
id|BRIDGE_DEV_SWAP_DIR
suffix:colon
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
r_new
op_and_assign
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
ques
c_cond
op_complement
id|BRIDGE_DEV_SWAP_DIR
suffix:colon
op_complement
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
multiline_comment|/* Provider-specific flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
r_new
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
r_new
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_64BIT
)paren
r_new
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NO64BIT
)paren
r_new
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
id|chg
op_assign
id|old
op_xor
r_new
suffix:semicolon
multiline_comment|/* what are we changing, */
id|chg
op_and_assign
id|xmask
suffix:semicolon
multiline_comment|/* of the interesting bits */
r_if
c_cond
(paren
id|chg
)paren
(brace
id|badd32
op_assign
id|slotp-&gt;bss_d32_uctr
ques
c_cond
(paren
id|BRIDGE_DEV_D32_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
id|badpmu
op_assign
id|slotp-&gt;bss_pmu_uctr
ques
c_cond
(paren
id|XBRIDGE_DEV_PMU_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|badd64
op_assign
id|slotp-&gt;bss_d64_uctr
ques
c_cond
(paren
id|XBRIDGE_DEV_D64_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|badpmu
op_assign
id|slotp-&gt;bss_pmu_uctr
ques
c_cond
(paren
id|BRIDGE_DEV_PMU_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|badd64
op_assign
id|slotp-&gt;bss_d64_uctr
ques
c_cond
(paren
id|BRIDGE_DEV_D64_BITS
op_amp
id|chg
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
id|bad
op_assign
id|badpmu
op_or
id|badd32
op_or
id|badd64
suffix:semicolon
r_if
c_cond
(paren
id|bad
)paren
(brace
multiline_comment|/* some conflicts can be resolved by&n;&t;     * forcing the bit on. this may cause&n;&t;     * some performance degredation in&n;&t;     * the stream(s) that want the bit off,&n;&t;     * but the alternative is not allowing&n;&t;     * the new stream at all.&n;&t;     */
macro_line|#ifdef colin
r_if
c_cond
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_PRECISE
op_or
id|BRIDGE_DEV_BARRIER
)paren
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_PRECISE
op_or
id|BRIDGE_DEV_BARRIER
)paren
)paren
)paren
(brace
macro_line|#endif
id|bad
op_and_assign
op_complement
id|fix
suffix:semicolon
multiline_comment|/* don&squot;t change these bits if&n;&t;&t; * they are already set in &quot;old&quot;&n;&t;&t; */
id|chg
op_and_assign
op_complement
(paren
id|fix
op_amp
id|old
)paren
suffix:semicolon
)brace
multiline_comment|/* some conflicts can be resolved by&n;&t;     * forcing the bit off. this may cause&n;&t;     * some performance degredation in&n;&t;     * the stream(s) that want the bit on,&n;&t;     * but the alternative is not allowing&n;&t;     * the new stream at all.&n;&t;     */
macro_line|#ifdef colin
r_if
c_cond
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_WRGA_BITS
op_or
id|BRIDGE_DEV_PREF
)paren
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|fix
op_assign
id|bad
op_amp
(paren
id|BRIDGE_DEV_WRGA_BITS
op_or
id|BRIDGE_DEV_PREF
)paren
)paren
)paren
(brace
macro_line|#endif
id|bad
op_and_assign
op_complement
id|fix
suffix:semicolon
multiline_comment|/* don&squot;t change these bits if&n;&t;&t; * we wanted to turn them on.&n;&t;&t; */
id|chg
op_and_assign
op_complement
(paren
id|fix
op_amp
r_new
)paren
suffix:semicolon
)brace
multiline_comment|/* conflicts in other bits mean&n;&t;     * we can not establish this DMA&n;&t;     * channel while the other(s) are&n;&t;     * still present.&n;&t;     */
r_if
c_cond
(paren
id|bad
)paren
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp;&amp; PCIBR_DEV_DEBUG)
id|printk
c_func
(paren
l_string|&quot;pcibr_try_set_device: mod blocked by %R&bslash;n&quot;
comma
id|bad
comma
id|device_bits
)paren
suffix:semicolon
macro_line|#endif
r_return
id|bad
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|slotp-&gt;bss_pmu_uctr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D32_BITS
)paren
id|slotp-&gt;bss_d32_uctr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|slotp-&gt;bss_d64_uctr
op_increment
suffix:semicolon
multiline_comment|/* the value we want to write is the&n;     * original value, with the bits for&n;     * our selected changes flipped, and&n;     * with any disabled features turned off.&n;     */
r_new
op_assign
id|old
op_xor
id|chg
suffix:semicolon
multiline_comment|/* only change what we want to change */
r_if
c_cond
(paren
id|slotp-&gt;bss_device
op_eq
r_new
)paren
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_assign
r_new
suffix:semicolon
id|slotp-&gt;bss_device
op_assign
r_new
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DEV_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): 0x%p&bslash;n&quot;
comma
id|slot
comma
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_release_device
id|pcibr_release_device
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|bridgereg_t
id|mask
)paren
(brace
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_PMU_BITS
)paren
id|slotp-&gt;bss_pmu_uctr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D32_BITS
)paren
id|slotp-&gt;bss_d32_uctr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|BRIDGE_DEV_D64_BITS
)paren
id|slotp-&gt;bss_d64_uctr
op_decrement
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * flush write gather buffer for slot&n; */
id|LOCAL
r_void
DECL|function|pcibr_device_write_gather_flush
id|pcibr_device_write_gather_flush
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|s
suffix:semicolon
r_volatile
r_uint32
id|wrf
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|wrf
op_assign
id|bridge-&gt;b_wr_req_buf
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    Bridge (pcibr) &quot;Device Driver&quot; entry points&n; */
multiline_comment|/*&n; * pcibr_probe_slot: read a config space word&n; * while trapping any errors; reutrn zero if&n; * all went OK, or nonzero if there was an error.&n; * The value read, if any, is passed back&n; * through the valp parameter.&n; */
id|LOCAL
r_int
DECL|function|pcibr_probe_slot
id|pcibr_probe_slot
c_func
(paren
id|bridge_t
op_star
id|bridge
comma
id|cfg_p
id|cfg
comma
r_int
op_star
id|valp
)paren
(brace
r_int
id|rv
suffix:semicolon
id|bridgereg_t
id|old_enable
comma
id|new_enable
suffix:semicolon
id|old_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|new_enable
op_assign
id|old_enable
op_amp
op_complement
id|BRIDGE_IMR_PCI_MST_TIMEOUT
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|new_enable
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
macro_line|#if defined(BRINGUP)
multiline_comment|/*&n;&t; * The xbridge doesn&squot;t clear b_err_int_view unless&n;&t; * multi-err is cleared...&n;&t; */
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_if
c_cond
(paren
id|bridge-&gt;b_err_int_view
op_amp
id|BRIDGE_ISR_PCI_MST_TIMEOUT
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
)brace
macro_line|#endif&t;/* BRINGUP */
macro_line|#endif&t;/* CONFIG_SGI_IP35 || CONFIG_IA64_SGI_SN1 */
r_if
c_cond
(paren
id|bridge-&gt;b_int_status
op_amp
id|BRIDGE_IRR_PCI_GRP
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_PCI_GRP_CLR
suffix:semicolon
(paren
r_void
)paren
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* flushbus */
)brace
id|rv
op_assign
id|badaddr_val
c_func
(paren
(paren
r_void
op_star
)paren
id|cfg
comma
l_int|4
comma
id|valp
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
macro_line|#if defined(BRINGUP)
multiline_comment|/*&n;&t; * The xbridge doesn&squot;t set master timeout in b_int_status&n;&t; * here.  Fortunately it&squot;s in error_interrupt_view.&n;&t; */
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_if
c_cond
(paren
id|bridge-&gt;b_err_int_view
op_amp
id|BRIDGE_ISR_PCI_MST_TIMEOUT
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
id|rv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unoccupied slot */
)brace
macro_line|#endif&t;/* BRINGUP */
macro_line|#endif /* CONFIG_SGI_IP35 */
id|bridge-&gt;b_int_enable
op_assign
id|old_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_init: called once during system startup or&n; *      when a loadable driver is loaded.&n; *&n; *      The driver_register function should normally&n; *      be in _reg, not _init.  But the pcibr driver is&n; *      required by devinit before the _reg routines&n; *      are called, so this is an exception.&n; */
r_void
DECL|function|pcibr_init
id|pcibr_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_init&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|xwidget_driver_register
c_func
(paren
id|XBRIDGE_WIDGET_PART_NUM
comma
id|XBRIDGE_WIDGET_MFGR_NUM
comma
l_string|&quot;pcibr_&quot;
comma
l_int|0
)paren
suffix:semicolon
id|xwidget_driver_register
c_func
(paren
id|BRIDGE_WIDGET_PART_NUM
comma
id|BRIDGE_WIDGET_MFGR_NUM
comma
l_string|&quot;pcibr_&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * open/close mmap/munmap interface would be used by processes&n; * that plan to map the PCI bridge, and muck around with the&n; * registers. This is dangerous to do, and will be allowed&n; * to a select brand of programs. Typically these are&n; * diagnostics programs, or some user level commands we may&n; * write to do some weird things.&n; * To start with expect them to have root priveleges.&n; * We will ask for more later.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|pcibr_open
id|pcibr_open
c_func
(paren
id|devfs_handle_t
op_star
id|devp
comma
r_int
id|oflag
comma
r_int
id|otyp
comma
id|cred_t
op_star
id|credp
)paren
(brace
macro_line|#ifndef CONFIG_IA64_SGI_IO
r_if
c_cond
(paren
op_logical_neg
id|_CAP_CRABLE
c_func
(paren
(paren
r_uint64
)paren
id|credp
comma
(paren
r_uint64
)paren
id|CAP_DEVICE_MGT
)paren
)paren
r_return
id|EPERM
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_close
id|pcibr_close
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|oflag
comma
r_int
id|otyp
comma
id|cred_t
op_star
id|crp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_map
id|pcibr_map
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|vhandl_t
op_star
id|vt
comma
id|off_t
id|off
comma
r_int
id|len
comma
id|uint
id|prot
)paren
(brace
r_int
id|error
suffix:semicolon
id|devfs_handle_t
id|vhdl
op_assign
id|dev_to_vhdl
c_func
(paren
id|dev
)paren
suffix:semicolon
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|len
op_assign
id|ctob
c_func
(paren
id|btoc
c_func
(paren
id|len
)paren
)paren
suffix:semicolon
multiline_comment|/* Make len page aligned */
id|error
op_assign
id|v_mapphys
c_func
(paren
id|vt
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|__psunsigned_t
)paren
id|bridge
op_plus
id|off
)paren
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the offset being mapped corresponds to the flash prom&n;     * base, and if the mapping succeeds, and if the user&n;     * has requested the protections to be WRITE, enable the&n;     * flash prom to be written.&n;     *&n;     * XXX- deprecate this in favor of using the&n;     * real flash driver ...&n;     */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
(paren
id|off
op_eq
id|BRIDGE_EXTERNAL_FLASH
)paren
op_logical_or
(paren
id|len
OG
id|BRIDGE_EXTERNAL_FLASH
)paren
)paren
)paren
(brace
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * ensure that we write and read without any interruption.&n;&t; * The read following the write is required for the Bridge war&n;&t; */
id|s
op_assign
id|splhi
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_control
op_or_assign
id|BRIDGE_CTRL_FLASH_WR_EN
suffix:semicolon
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* inval addr bug war */
id|splx
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_unmap
id|pcibr_unmap
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|vhandl_t
op_star
id|vt
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|hwgraph_connectpt_get
c_func
(paren
(paren
id|devfs_handle_t
)paren
id|dev
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
multiline_comment|/*&n;     * If flashprom write was enabled, disable it, as&n;     * this is the last unmap.&n;     */
r_if
c_cond
(paren
id|bridge-&gt;b_wid_control
op_amp
id|BRIDGE_CTRL_FLASH_WR_EN
)paren
(brace
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * ensure that we write and read without any interruption.&n;&t; * The read following the write is required for the Bridge war&n;&t; */
id|s
op_assign
id|splhi
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_control
op_and_assign
op_complement
id|BRIDGE_CTRL_FLASH_WR_EN
suffix:semicolon
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* inval addr bug war */
id|splx
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is special case code used by grio. There are plans to make&n; * this a bit more general in the future, but till then this should&n; * be sufficient.&n; */
id|pciio_slot_t
DECL|function|pcibr_device_slot_get
id|pcibr_device_slot_get
c_func
(paren
id|devfs_handle_t
id|dev_vhdl
)paren
(brace
r_char
id|devname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|devfs_handle_t
id|tdev
suffix:semicolon
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|PCIIO_SLOT_NONE
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|dev_vhdl
comma
id|devname
comma
id|MAXDEVNAME
)paren
suffix:semicolon
multiline_comment|/* run back along the canonical path&n;     * until we find a PCI connection point.&n;     */
id|tdev
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|dev_vhdl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tdev
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
id|pciio_info
op_assign
id|pciio_info_chk
c_func
(paren
id|tdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_info
)paren
(brace
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|tdev
)paren
suffix:semicolon
id|tdev
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|tdev
)paren
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|tdev
)paren
suffix:semicolon
r_return
id|slot
suffix:semicolon
)brace
multiline_comment|/*==========================================================================&n; *&t;BRIDGE PCI SLOT RELATED IOCTLs&n; */
multiline_comment|/*&n; * pcibr_slot_powerup&n; *&t;Software initialize the pci slot.&n; */
r_int
DECL|function|pcibr_slot_powerup
id|pcibr_slot_powerup
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
multiline_comment|/* Check for the valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_shutdown&n; *&t;Software shutdown the pci slot&n; */
r_int
DECL|function|pcibr_slot_shutdown
id|pcibr_slot_shutdown
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
multiline_comment|/* Check for valid slot */
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pci_space_name
r_char
op_star
id|pci_space_name
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ROM&quot;
comma
l_string|&quot;IO&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;MEM&quot;
comma
l_string|&quot;MEM32&quot;
comma
l_string|&quot;MEM64&quot;
comma
l_string|&quot;CFG&quot;
comma
l_string|&quot;WIN0&quot;
comma
l_string|&quot;WIN1&quot;
comma
l_string|&quot;WIN2&quot;
comma
l_string|&quot;WIN3&quot;
comma
l_string|&quot;WIN4&quot;
comma
l_string|&quot;WIN5&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;BAD&quot;
)brace
suffix:semicolon
r_void
DECL|function|pcibr_slot_func_info_print
id|pcibr_slot_func_info_print
c_func
(paren
id|pcibr_info_h
id|pcibr_infoh
comma
r_int
id|func
comma
r_int
id|verbose
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_char
id|name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_int
id|win
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_return
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_vertex
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tSlot Name : %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tPER-SLOT FUNCTION INFO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_vertex
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;tSlot Name : %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tPCI Bus : %d &quot;
comma
id|pcibr_info-&gt;f_bus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Slot : %d &quot;
comma
id|pcibr_info-&gt;f_slot
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Function : %d&bslash;n&quot;
comma
id|pcibr_info-&gt;f_func
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_master
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;tBus provider : %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tProvider Fns : 0x%p &quot;
comma
id|pcibr_info-&gt;f_pops
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Error Handler : 0x%p Arg 0x%p&bslash;n&quot;
comma
id|pcibr_info-&gt;f_efunc
comma
id|pcibr_info-&gt;f_einfo
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tVendorId : 0x%x &quot;
comma
id|pcibr_info-&gt;f_vendor
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DeviceId : 0x%x&bslash;n&quot;
comma
id|pcibr_info-&gt;f_device
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;tBase Register Info&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;tReg#&bslash;tBase&bslash;t&bslash;tSize&bslash;t&bslash;tSpace&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|6
suffix:semicolon
id|win
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;t%d&bslash;t0x%lx&bslash;t%s0x%lx&bslash;t%s%s&bslash;n&quot;
comma
id|win
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_ge
l_int|0x100000
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;&bslash;t&quot;
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
op_ge
l_int|0x100000
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;&bslash;t&quot;
comma
id|pci_space_name
(braket
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;t7&bslash;t0x%x&bslash;t%s0x%x&bslash;t%sROM&bslash;n&quot;
comma
id|pcibr_info-&gt;f_rbase
comma
id|pcibr_info-&gt;f_rbase
OG
l_int|0x100000
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;&bslash;t&quot;
comma
id|pcibr_info-&gt;f_rsize
comma
id|pcibr_info-&gt;f_rsize
OG
l_int|0x100000
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;&bslash;t&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;tInterrupt Bit Map&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;tPCI Int#&bslash;tBridge Pin#&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|4
suffix:semicolon
id|win
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;tINT%c&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|win
op_plus
l_char|&squot;A&squot;
comma
id|pcibr_info-&gt;f_ibit
(braket
id|win
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_slot_info_print
id|pcibr_slot_info_print
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
r_int
id|verbose
)paren
(brace
id|pcibr_soft_slot_t
id|pss
suffix:semicolon
r_char
id|slot_conn_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_int
id|func
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|b_resp
suffix:semicolon
id|reg_p
id|b_respp
suffix:semicolon
r_int
id|dev
suffix:semicolon
id|bridgereg_t
id|b_int_device
suffix:semicolon
id|bridgereg_t
id|b_int_host
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
id|pin
op_assign
l_int|0
suffix:semicolon
r_int
id|int_bits
op_assign
l_int|0
suffix:semicolon
id|pss
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nPCI INFRASTRUCTURAL INFO FOR SLOT %d&bslash;n&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tHost Present ? %s &quot;
comma
id|pss-&gt;has_host
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tHost Slot : %d&bslash;n&quot;
comma
id|pss-&gt;host_slot
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|slot_conn_name
comma
l_string|&quot;%v&quot;
comma
id|pss-&gt;slot_conn
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;tSlot Conn : %s&bslash;n&quot;
comma
id|slot_conn_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t#Functions : %d&bslash;n&quot;
comma
id|pss-&gt;bss_ninfo
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|pss-&gt;bss_ninfo
suffix:semicolon
id|func
op_increment
)paren
id|pcibr_slot_func_info_print
c_func
(paren
id|pss-&gt;bss_infos
comma
id|func
comma
id|verbose
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tDevio[Space:%s,Base:0x%lx,Shadow:0x%x]&bslash;n&quot;
comma
id|pci_space_name
(braket
id|pss-&gt;bss_devio.bssd_space
)braket
comma
id|pss-&gt;bss_devio.bssd_base
comma
id|pss-&gt;bss_device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tUsage counts : pmu %d d32 %d d64 %d&bslash;n&quot;
comma
id|pss-&gt;bss_pmu_uctr
comma
id|pss-&gt;bss_d32_uctr
comma
id|pss-&gt;bss_d64_uctr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tDirect Trans Info : d64_base 0x%x d64_flags 0x%x&quot;
l_string|&quot;d32_base 0x%x d32_flags 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pss-&gt;bss_d64_base
comma
id|pss-&gt;bss_d64_flags
comma
(paren
r_int
r_int
)paren
id|pss-&gt;bss_d32_base
comma
id|pss-&gt;bss_d32_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tExt ATEs active ? %s&quot;
comma
id|pss-&gt;bss_ext_ates_active
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Command register : 0x%p &quot;
comma
id|pss-&gt;bss_cmd_pointer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Shadow command val : 0x%x&bslash;n&quot;
comma
id|pss-&gt;bss_cmd_shadow
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tSoft RRB Info[Valid %d+%d, Reserved %d]&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_amp
l_int|1
)paren
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_odd_resp
suffix:semicolon
r_else
id|b_respp
op_assign
op_amp
id|bridge-&gt;b_even_resp
suffix:semicolon
id|b_resp
op_assign
op_star
id|b_respp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;tBridge RRB Info&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;tRRB#&bslash;tVirtual&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
l_int|8
suffix:semicolon
id|dev
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|b_resp
op_amp
id|BRIDGE_RRB_EN
)paren
op_logical_and
(paren
id|b_resp
op_amp
id|BRIDGE_RRB_PDEV
)paren
op_eq
(paren
id|slot
op_rshift
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;t%d&bslash;t%s&bslash;n&quot;
comma
id|dev
comma
(paren
id|b_resp
op_amp
id|BRIDGE_RRB_VDEV
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|b_resp
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|b_int_device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;tBridge Interrupt Info&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tInt_device 0x%x&bslash;n&bslash;t&bslash;tInt_enable 0x%x &quot;
l_string|&quot;&bslash;n&bslash;t&bslash;tEnabled pin#s for this slot: &quot;
comma
id|b_int_device
comma
id|b_int_enable
)paren
suffix:semicolon
r_while
c_loop
(paren
id|b_int_device
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|b_int_device
op_amp
l_int|7
)paren
op_eq
id|slot
)paren
op_logical_and
(paren
id|b_int_enable
op_amp
(paren
l_int|1
op_lshift
id|pin
)paren
)paren
)paren
(brace
id|int_bits
op_or_assign
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|pin
)paren
suffix:semicolon
)brace
id|pin
op_increment
suffix:semicolon
id|b_int_device
op_rshift_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|int_bits
)paren
id|printk
c_func
(paren
l_string|&quot;NONE &quot;
)paren
suffix:semicolon
id|b_int_host
op_assign
id|bridge-&gt;b_int_addr
(braket
id|slot
)braket
dot
id|addr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;t&bslash;tInt_host_addr 0x%x&bslash;n&quot;
comma
id|b_int_host
)paren
suffix:semicolon
)brace
DECL|variable|verbose
r_int
id|verbose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * pcibr_slot_inquiry&n; *&t;Print information about the pci slot maintained by the infrastructure.&n; *&t;Current information displayed&n; *&t;&t;Slot hwgraph name&n; *&t;&t;Vendor/Device info&n; *&t;&t;Base register info&n; *&t;&t;Interrupt mapping from device pins to the bridge pins&n; *&t;&t;Devio register&n; *&t;&t;Software RRB info&n; *&t;&t;RRB register info&n; *&t;In verbose mode following additional info is displayed&n; *&t;&t;Host/Gues info&n; *&t;&t;PCI Bus #,slot #, function #&n; *&t;&t;Slot provider hwgraph name&n; *&t;&t;Provider Functions&n; *&t;&t;Error handler&n; *&t;&t;DMA mapping usage counters&n; *&t;&t;DMA direct translation info&n; *&t;&t;External SSRAM workaround info&n; */
r_int
DECL|function|pcibr_slot_inquiry
id|pcibr_slot_inquiry
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
multiline_comment|/* Make sure that we are dealing with a bridge device vertex */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* Make sure that we have a valid pci slot number or PCIIO_SLOT_NONE */
r_if
c_cond
(paren
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
op_logical_and
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* Print information for the requested pci slot */
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
id|pcibr_slot_info_print
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|verbose
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Print information for all the slots */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
id|slot
op_increment
)paren
id|pcibr_slot_info_print
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|verbose
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_ioctl
id|pcibr_ioctl
c_func
(paren
id|devfs_handle_t
id|dev
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|flag
comma
r_struct
id|cred
op_star
id|cr
comma
r_int
op_star
id|rvalp
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|hwgraph_connectpt_get
c_func
(paren
(paren
id|devfs_handle_t
)paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef colin
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#ifdef colin
r_case
id|GIOCSETBW
suffix:colon
(brace
id|grio_ioctl_info_t
id|info
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
(paren
r_uint64
)paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COPYIN
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|grio_ioctl_info_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr:: prev_vhdl: %d reqbw: %lld&bslash;n&quot;
comma
id|info.prev_vhdl
comma
id|info.reqbw
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* GRIO_DEBUG */
r_if
c_cond
(paren
(paren
id|slot
op_assign
id|pcibr_device_slot_get
c_func
(paren
id|info.prev_vhdl
)paren
)paren
op_eq
id|PCIIO_SLOT_NONE
)paren
(brace
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info.reqbw
)paren
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCI_PRIO_HIGH
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|GIOCRELEASEBW
suffix:colon
(brace
id|grio_ioctl_info_t
id|info
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COPYIN
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|grio_ioctl_info_t
)paren
)paren
)paren
(brace
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef GRIO_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr:: prev_vhdl: %d reqbw: %lld&bslash;n&quot;
comma
id|info.prev_vhdl
comma
id|info.reqbw
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* GRIO_DEBUG */
r_if
c_cond
(paren
(paren
id|slot
op_assign
id|pcibr_device_slot_get
c_func
(paren
id|info.prev_vhdl
)paren
)paren
op_eq
id|PCIIO_SLOT_NONE
)paren
(brace
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info.reqbw
)paren
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCI_PRIO_LOW
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif /* colin */
r_case
id|PCIBR_SLOT_POWERUP
suffix:colon
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|slot
op_assign
(paren
id|pciio_slot_t
)paren
(paren
r_uint64
)paren
id|arg
suffix:semicolon
id|error
op_assign
id|pcibr_slot_powerup
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PCIBR_SLOT_SHUTDOWN
suffix:colon
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|slot
op_assign
(paren
id|pciio_slot_t
)paren
(paren
r_uint64
)paren
id|arg
suffix:semicolon
id|error
op_assign
id|pcibr_slot_shutdown
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PCIBR_SLOT_INQUIRY
suffix:colon
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_able
c_func
(paren
id|CAP_DEVICE_MGT
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|slot
op_assign
(paren
id|pciio_slot_t
)paren
(paren
r_uint64
)paren
id|arg
suffix:semicolon
id|error
op_assign
id|pcibr_slot_inquiry
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_void
DECL|function|pcibr_freeblock_sub
id|pcibr_freeblock_sub
c_func
(paren
id|iopaddr_t
op_star
id|free_basep
comma
id|iopaddr_t
op_star
id|free_lastp
comma
id|iopaddr_t
id|base
comma
r_int
id|size
)paren
(brace
id|iopaddr_t
id|free_base
op_assign
op_star
id|free_basep
suffix:semicolon
id|iopaddr_t
id|free_last
op_assign
op_star
id|free_lastp
suffix:semicolon
id|iopaddr_t
id|last
op_assign
id|base
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|last
OL
id|free_base
)paren
op_logical_or
(paren
id|base
OG
id|free_last
)paren
)paren
suffix:semicolon
multiline_comment|/* free block outside arena */
r_else
r_if
c_cond
(paren
(paren
id|base
op_le
id|free_base
)paren
op_logical_and
(paren
id|last
op_ge
id|free_last
)paren
)paren
multiline_comment|/* free block contains entire arena */
op_star
id|free_basep
op_assign
op_star
id|free_lastp
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base
op_le
id|free_base
)paren
multiline_comment|/* free block is head of arena */
op_star
id|free_basep
op_assign
id|last
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|last
op_ge
id|free_last
)paren
multiline_comment|/* free block is tail of arena */
op_star
id|free_lastp
op_assign
id|base
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * We are left with two regions: the free area&n;     * in the arena &quot;below&quot; the block, and the free&n;     * area in the arena &quot;above&quot; the block. Keep&n;     * the one that is bigger.&n;     */
r_else
r_if
c_cond
(paren
(paren
id|base
op_minus
id|free_base
)paren
OG
(paren
id|free_last
op_minus
id|last
)paren
)paren
op_star
id|free_lastp
op_assign
id|base
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* keep lower chunk */
r_else
op_star
id|free_basep
op_assign
id|last
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* keep upper chunk */
)brace
macro_line|#ifdef IRIX
multiline_comment|/* Convert from ssram_bits in control register to number of SSRAM entries */
DECL|macro|ATE_NUM_ENTRIES
mdefine_line|#define ATE_NUM_ENTRIES(n) _ate_info[n]
multiline_comment|/* Possible choices for number of ATE entries in Bridge&squot;s SSRAM */
DECL|variable|_ate_info
id|LOCAL
r_int
id|_ate_info
(braket
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* 0 entries */
l_int|8
op_star
l_int|1024
comma
multiline_comment|/* 8K entries */
l_int|16
op_star
l_int|1024
comma
multiline_comment|/* 16K entries */
l_int|64
op_star
l_int|1024
multiline_comment|/* 64K entries */
)brace
suffix:semicolon
DECL|macro|ATE_NUM_SIZES
mdefine_line|#define ATE_NUM_SIZES (sizeof(_ate_info) / sizeof(int))
DECL|macro|ATE_PROBE_VALUE
mdefine_line|#define ATE_PROBE_VALUE 0x0123456789abcdefULL
macro_line|#endif&t;/* IRIX */
multiline_comment|/*&n; * Determine the size of this bridge&squot;s external mapping SSRAM, and set&n; * the control register appropriately to reflect this size, and initialize&n; * the external SSRAM.&n; */
macro_line|#ifndef BRINGUP
id|LOCAL
r_int
DECL|function|pcibr_init_ext_ate_ram
id|pcibr_init_ext_ate_ram
c_func
(paren
id|bridge_t
op_star
id|bridge
)paren
(brace
r_int
id|largest_working_size
op_assign
l_int|0
suffix:semicolon
r_int
id|num_entries
comma
id|entry
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|bridgereg_t
id|old_enable
comma
id|new_enable
suffix:semicolon
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Probe SSRAM to determine its size. */
id|old_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|new_enable
op_assign
id|old_enable
op_amp
op_complement
id|BRIDGE_IMR_PCI_MST_TIMEOUT
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|new_enable
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ATE_NUM_SIZES
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Try writing a value */
id|bridge-&gt;b_ext_ate_ram
(braket
id|ATE_NUM_ENTRIES
c_func
(paren
id|i
)paren
op_minus
l_int|1
)braket
op_assign
id|ATE_PROBE_VALUE
suffix:semicolon
multiline_comment|/* Guard against wrap */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|bridge-&gt;b_ext_ate_ram
(braket
id|ATE_NUM_ENTRIES
c_func
(paren
id|j
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* See if value was written */
r_if
c_cond
(paren
id|bridge-&gt;b_ext_ate_ram
(braket
id|ATE_NUM_ENTRIES
c_func
(paren
id|i
)paren
op_minus
l_int|1
)braket
op_eq
id|ATE_PROBE_VALUE
)paren
id|largest_working_size
op_assign
id|i
suffix:semicolon
)brace
id|bridge-&gt;b_int_enable
op_assign
id|old_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
multiline_comment|/*&n;     * ensure that we write and read without any interruption.&n;     * The read following the write is required for the Bridge war&n;     */
id|s
op_assign
id|splhi
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef colin
id|bridge-&gt;b_wid_control
op_assign
(paren
id|bridge-&gt;b_wid_control
op_amp
op_complement
id|BRIDGE_CTRL_SSRAM_SIZE_MASK
)paren
op_or
id|BRIDGE_CTRL_SSRAM_SIZE
c_func
(paren
id|largest_working_size
)paren
suffix:semicolon
macro_line|#endif
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* inval addr bug war */
id|splx
c_func
(paren
id|s
)paren
suffix:semicolon
id|num_entries
op_assign
id|ATE_NUM_ENTRIES
c_func
(paren
id|largest_working_size
)paren
suffix:semicolon
macro_line|#if PCIBR_ATE_DEBUG
r_if
c_cond
(paren
id|num_entries
)paren
id|printk
c_func
(paren
l_string|&quot;bridge at 0x%x: clearing %d external ATEs&bslash;n&quot;
comma
id|bridge
comma
id|num_entries
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;bridge at 0x%x: no externa9422l ATE RAM found&bslash;n&quot;
comma
id|bridge
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize external mapping entries */
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|num_entries
suffix:semicolon
id|entry
op_increment
)paren
id|bridge-&gt;b_ext_ate_ram
(braket
id|entry
)braket
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|num_entries
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* !BRINGUP */
multiline_comment|/*&n; * Allocate &quot;count&quot; contiguous Bridge Address Translation Entries&n; * on the specified bridge to be used for PCI to XTALK mappings.&n; * Indices in rm map range from 1..num_entries.  Indicies returned&n; * to caller range from 0..num_entries-1.&n; *&n; * Return the start index on success, -1 on failure.&n; */
id|LOCAL
r_int
DECL|function|pcibr_ate_alloc
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|count
)paren
(brace
r_int
id|index
op_assign
l_int|0
suffix:semicolon
id|index
op_assign
(paren
r_int
)paren
id|rmalloc
c_func
(paren
id|pcibr_soft-&gt;bs_int_ate_map
comma
(paren
r_int
)paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index
op_logical_and
id|pcibr_soft-&gt;bs_ext_ate_map
)paren
id|index
op_assign
(paren
r_int
)paren
id|rmalloc
c_func
(paren
id|pcibr_soft-&gt;bs_ext_ate_map
comma
(paren
r_int
)paren
id|count
)paren
suffix:semicolon
multiline_comment|/* rmalloc manages resources in the 1..n&n;     * range, with 0 being failure.&n;     * pcibr_ate_alloc manages resources&n;     * in the 0..n-1 range, with -1 being failure.&n;     */
r_return
id|index
op_minus
l_int|1
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|pcibr_ate_free
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|index
comma
r_int
id|count
)paren
multiline_comment|/* Who says there&squot;s no such thing as a free meal? :-) */
(brace
multiline_comment|/* note the &quot;+1&quot; since rmalloc handles 1..n but&n;     * we start counting ATEs at zero.&n;     */
id|rmfree
c_func
(paren
(paren
id|index
OL
id|pcibr_soft-&gt;bs_int_ate_size
)paren
ques
c_cond
id|pcibr_soft-&gt;bs_int_ate_map
suffix:colon
id|pcibr_soft-&gt;bs_ext_ate_map
comma
id|count
comma
id|index
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|LOCAL
id|pcibr_info_t
DECL|function|pcibr_info_get
id|pcibr_info_get
c_func
(paren
id|devfs_handle_t
id|vhdl
)paren
(brace
r_return
(paren
id|pcibr_info_t
)paren
id|pciio_info_get
c_func
(paren
id|vhdl
)paren
suffix:semicolon
)brace
id|pcibr_info_t
DECL|function|pcibr_device_info_new
id|pcibr_device_info_new
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
comma
id|pciio_function_t
id|rfunc
comma
id|pciio_vendor_id_t
id|vendor
comma
id|pciio_device_id_t
id|device
)paren
(brace
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
r_int
id|ibit
suffix:semicolon
id|func
op_assign
(paren
id|rfunc
op_eq
id|PCIIO_FUNC_NONE
)paren
ques
c_cond
l_int|0
suffix:colon
id|rfunc
suffix:semicolon
id|NEW
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
id|pciio_device_info_new
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
comma
id|pcibr_soft-&gt;bs_vhdl
comma
id|slot
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
multiline_comment|/*&n;&t; * Currently favored mapping from PCI&n;&t; * slot number and INTA/B/C/D to Bridge&n;&t; * PCI Interrupt Bit Number:&n;&t; *&n;&t; *     SLOT     A B C D&n;&t; *      0       0 4 0 4&n;&t; *      1       1 5 1 5&n;&t; *      2       2 6 2 6&n;&t; *      3       3 7 3 7&n;&t; *      4       4 0 4 0&n;&t; *      5       5 1 5 1&n;&t; *      6       6 2 6 2&n;&t; *      7       7 3 7 3&n;&t; *&n;&t; * XXX- allow pcibr_hints to override default&n;&t; * XXX- allow ADMIN to override pcibr_hints&n;&t; */
r_for
c_loop
(paren
id|ibit
op_assign
l_int|0
suffix:semicolon
id|ibit
OL
l_int|4
suffix:semicolon
op_increment
id|ibit
)paren
id|pcibr_info-&gt;f_ibit
(braket
id|ibit
)braket
op_assign
(paren
id|slot
op_plus
l_int|4
op_star
id|ibit
)paren
op_amp
l_int|7
suffix:semicolon
multiline_comment|/*&n;&t; * Record the info in the sparse func info space.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;pcibr_device_info_new: slot= %d  func= %d  bss_ninfo= %d  pcibr_info= 0x%p&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
comma
id|pcibr_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
OL
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
)paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
(braket
id|func
)braket
op_assign
id|pcibr_info
suffix:semicolon
)brace
r_return
id|pcibr_info
suffix:semicolon
)brace
r_void
DECL|function|pcibr_device_info_free
id|pcibr_device_info_free
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_function_t
id|func
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
r_int
id|nfunc
op_assign
id|slotp-&gt;bss_ninfo
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info
op_assign
id|slotp-&gt;bss_infos
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
id|slotp-&gt;bss_infos
(braket
id|func
)braket
op_assign
l_int|0
suffix:semicolon
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|pciio_device_info_free
c_func
(paren
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|pcibr_info
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the DEVIO(x) for this slot */
id|slotp-&gt;bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|slotp-&gt;bss_devio.bssd_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_device
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the mapping usage counters */
id|slotp-&gt;bss_pmu_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_uctr
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d64_uctr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the Direct translation info */
id|slotp-&gt;bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear out shadow info necessary for the external SSRAM workaround */
id|slotp-&gt;bss_ext_ates_active
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_cmd_pointer
op_assign
l_int|0
suffix:semicolon
id|slotp-&gt;bss_cmd_shadow
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * PCI_ADDR_SPACE_LIMITS_LOAD&n; *&t;Gets the current values of &n; *&t;&t;pci io base, &n; *&t;&t;pci io last,&n; *&t;&t;pci low memory base,&n; *&t;&t;pci low memory last,&n; *&t;&t;pci high memory base,&n; * &t;&t;pci high memory last&n; */
DECL|macro|PCI_ADDR_SPACE_LIMITS_LOAD
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_LOAD()&t;&t;&t;&bslash;&n;    pci_io_fb = pcibr_soft-&gt;bs_spinfo.pci_io_base;&t;&bslash;&n;    pci_io_fl = pcibr_soft-&gt;bs_spinfo.pci_io_last;&t;&bslash;&n;    pci_lo_fb = pcibr_soft-&gt;bs_spinfo.pci_swin_base;&t;&bslash;&n;    pci_lo_fl = pcibr_soft-&gt;bs_spinfo.pci_swin_last;&t;&bslash;&n;    pci_hi_fb = pcibr_soft-&gt;bs_spinfo.pci_mem_base;&t;&bslash;&n;    pci_hi_fl = pcibr_soft-&gt;bs_spinfo.pci_mem_last;
multiline_comment|/*&n; * PCI_ADDR_SPACE_LIMITS_STORE&n; *&t;Sets the current values of&n; *&t;&t;pci io base, &n; *&t;&t;pci io last,&n; *&t;&t;pci low memory base,&n; *&t;&t;pci low memory last,&n; *&t;&t;pci high memory base,&n; * &t;&t;pci high memory last&n; */
DECL|macro|PCI_ADDR_SPACE_LIMITS_STORE
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_STORE()&t;&t;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_io_base = pci_io_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_io_last = pci_io_fl;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_swin_base = pci_lo_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_swin_last = pci_lo_fl;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_mem_base = pci_hi_fb;&t;&bslash;&n;    pcibr_soft-&gt;bs_spinfo.pci_mem_last = pci_hi_fl;
DECL|macro|PCI_ADDR_SPACE_LIMITS_PRINT
mdefine_line|#define PCI_ADDR_SPACE_LIMITS_PRINT()&t;&t;&t;&bslash;&n;    printf(&quot;+++++++++++++++++++++++&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;IO base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;SWIN base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;MEM base 0x%x last 0x%x&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;   &quot;+++++++++++++++++++++++&bslash;n&quot;,&t;&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_io_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_io_last,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_swin_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_swin_last,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_mem_base,&t;&t;&bslash;&n;&t;   pcibr_soft-&gt;bs_spinfo.pci_mem_last);
multiline_comment|/*&n; * pcibr_slot_reset&n; *&t;Reset the pci device in the particular slot .&n; */
r_int
DECL|function|pcibr_slot_reset
id|pcibr_slot_reset
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|ctrlreg
comma
id|tmp
suffix:semicolon
r_volatile
id|bridgereg_t
op_star
id|wrb_flush
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Enable the DMA operations from this device of the xtalk widget&n;&t; * (PCI host bridge in this case).&n;&t; */
id|xtalk_widgetdev_enable
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Set the reset slot bit in the bridge&squot;s wid control register&n;&t; * to reset the pci slot &n;&t; */
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Read the bridge widget control and clear out the reset pin&n;&t; * bit for the corresponding slot. &n;&t; */
id|tmp
op_assign
id|ctrlreg
op_assign
id|bridge-&gt;b_wid_control
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|BRIDGE_CTRL_RST_PIN
c_func
(paren
id|slot
)paren
suffix:semicolon
id|bridge-&gt;b_wid_control
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* Restore the old control register back.&n;&t; * NOTE : pci card gets reset when the reset pin bit&n;&t; * changes from 0 (set above) to 1 (going to be set now).&n;&t; */
id|bridge-&gt;b_wid_control
op_assign
id|ctrlreg
suffix:semicolon
multiline_comment|/* Flush the write buffers if any !! */
id|wrb_flush
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|slot
)braket
dot
id|reg
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|wrb_flush
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_info_init&n; *&t;Probe for this slot and see if it is populated.&n; *&t;If it is populated initialize the generic pci infrastructural&n; * &t;information associated with this particular pci device.&n; */
r_int
DECL|function|pcibr_slot_info_init
id|pcibr_slot_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|cfg_p
id|cfgw
suffix:semicolon
r_int
id|idword
suffix:semicolon
r_int
id|pfail
suffix:semicolon
r_int
id|idwords
(braket
l_int|8
)braket
suffix:semicolon
id|pciio_vendor_id_t
id|vendor
suffix:semicolon
id|pciio_device_id_t
id|device
suffix:semicolon
r_int
id|htype
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|pci_io_fb
comma
id|pci_io_fl
suffix:semicolon
id|iopaddr_t
id|pci_lo_fb
comma
id|pci_lo_fl
suffix:semicolon
id|iopaddr_t
id|pci_hi_fb
comma
id|pci_hi_fl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pciio_function_t
id|rfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|conn_vhdl
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
multiline_comment|/* Get the basic software information required to proceed */
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
)paren
r_return
l_int|1
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* Load the current values of allocated pci address spaces */
id|PCI_ADDR_SPACE_LIMITS_LOAD
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we have a host slot (eg:- IOC3 has 2 pci slots and the initialization&n;     * is done by the host slot then we are done.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Try to read the device-id/vendor-id from the config space */
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
suffix:semicolon
macro_line|#ifdef BRINGUP
r_if
c_cond
(paren
id|slot
OL
l_int|3
op_logical_or
id|slot
op_eq
l_int|7
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
macro_line|#endif /* BRINGUP */
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idword
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idword
suffix:semicolon
multiline_comment|/* If the vendor id is not valid then the slot is not populated&n;     * and we are done.&n;     */
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* next slot */
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|nfunc
op_assign
l_int|1
suffix:semicolon
id|rfunc
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|pfail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: if a card claims to be multifunction&n;     * but only responds to config space 0, treat&n;     * it as a unifunction card.&n;     */
r_if
c_cond
(paren
id|htype
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* MULTIFUNCTION */
r_for
c_loop
(paren
id|func
op_assign
l_int|1
suffix:semicolon
id|func
OL
l_int|8
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_probe_slot
c_func
(paren
id|bridge
comma
id|cfgw
comma
op_amp
id|idwords
(braket
id|func
)braket
)paren
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vendor
op_assign
l_int|0xFFFF
op_amp
id|idwords
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
l_int|0xFFFF
)paren
(brace
id|pfail
op_or_assign
l_int|1
op_lshift
id|func
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nfunc
op_assign
id|func
op_plus
l_int|1
suffix:semicolon
id|rfunc
op_assign
l_int|0
suffix:semicolon
)brace
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
suffix:semicolon
)brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
id|nfunc
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
r_int
id|cmd_reg
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
r_if
c_cond
(paren
id|pfail
op_amp
(paren
l_int|1
op_lshift
id|func
)paren
)paren
r_continue
suffix:semicolon
id|idword
op_assign
id|idwords
(braket
id|func
)braket
suffix:semicolon
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
id|device
op_assign
l_int|0xFFFF
op_amp
(paren
id|idword
op_rshift
l_int|16
)paren
suffix:semicolon
id|htype
op_assign
id|do_pcibr_config_get
c_func
(paren
id|cfgw
comma
id|PCI_CFG_HEADER_TYPE
comma
l_int|1
)paren
suffix:semicolon
id|rfunc
op_assign
id|func
suffix:semicolon
)brace
id|htype
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|htype
op_ne
l_int|0x00
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%s pcibr: pci slot %d func %d has strange header type 0x%x&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|htype
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|PRINT_NOTICE
c_func
(paren
l_string|&quot;%s pcibr: pci slot %d func %d: vendor 0x%x device 0x%x&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|func
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
macro_line|#endif&t;
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|rfunc
comma
id|vendor
comma
id|device
)paren
suffix:semicolon
id|conn_vhdl
op_assign
id|pciio_device_info_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|slotp-&gt;slot_conn
op_assign
id|conn_vhdl
suffix:semicolon
id|cmd_reg
op_assign
id|cfgw
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
op_increment
id|win
)paren
(brace
id|iopaddr_t
id|base
comma
id|mask
comma
id|code
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * GET THE BASE &amp; SIZE OF THIS WINDOW:&n;&t;     *&n;&t;     * The low two or four bits of the BASE register&n;&t;     * determines which address space we are in; the&n;&t;     * rest is a base address. BASE registers&n;&t;     * determine windows that are power-of-two sized&n;&t;     * and naturally aligned, so we can get the size&n;&t;     * of a window by writing all-ones to the&n;&t;     * register, reading it back, and seeing which&n;&t;     * bits are used for decode; the least&n;&t;     * significant nonzero bit is also the size of&n;&t;     * the window.&n;&t;     *&n;&t;     * WARNING: someone may already have allocated&n;&t;     * some PCI space to this window, and in fact&n;&t;     * PIO may be in process at this very moment&n;&t;     * from another processor (or even from this&n;&t;     * one, if we get interrupted)! So, if the BASE&n;&t;     * already has a nonzero address, be generous&n;&t;     * and use the LSBit of that address as the&n;&t;     * size; this could overstate the window size.&n;&t;     * Usually, when one card is set up, all are set&n;&t;     * up; so, since we don&squot;t bitch about&n;&t;     * overlapping windows, we are ok.&n;&t;     *&n;&t;     * UNFORTUNATELY, some cards do not clear their&n;&t;     * BASE registers on reset. I have two heuristics&n;&t;     * that can detect such cards: first, if the&n;&t;     * decode enable is turned off for the space&n;&t;     * that the window uses, we can disregard the&n;&t;     * initial value. second, if the address is&n;&t;     * outside the range that we use, we can disregard&n;&t;     * it as well.&n;&t;     *&n;&t;     * This is looking very PCI generic. Except for&n;&t;     * knowing how many slots and where their config&n;&t;     * spaces are, this window loop and the next one&n;&t;     * could probably be shared with other PCI host&n;&t;     * adapters. It would be interesting to see if&n;&t;     * this could be pushed up into pciio, when we&n;&t;     * start supporting more PCI providers.&n;&t;     */
macro_line|#ifdef LITTLE_ENDIAN
id|base
op_assign
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
suffix:semicolon
macro_line|#else
id|base
op_assign
id|wptr
(braket
id|win
)braket
suffix:semicolon
macro_line|#endif /* LITTLE_ENDIAN */
r_if
c_cond
(paren
id|base
op_amp
l_int|1
)paren
(brace
multiline_comment|/* BASE is in I/O space. */
id|space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|mask
op_assign
op_minus
l_int|4
suffix:semicolon
id|code
op_assign
id|base
op_amp
l_int|3
suffix:semicolon
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_IO_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
)brace
r_else
(brace
multiline_comment|/* BASE is in MEM space. */
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|mask
op_assign
op_minus
l_int|16
suffix:semicolon
id|code
op_assign
id|base
op_amp
l_int|15
suffix:semicolon
id|base
op_assign
id|base
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* not assigned */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd_reg
op_amp
id|PCI_CMD_MEM_SPACE
)paren
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decode not enabled */
)brace
r_else
r_if
c_cond
(paren
id|base
op_amp
l_int|0xC0000000
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
r_else
r_if
c_cond
(paren
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
op_logical_and
macro_line|#ifdef LITTLE_ENDIAN
(paren
id|wptr
(braket
(paren
(paren
(paren
id|win
op_plus
l_int|1
)paren
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_ne
l_int|0
)paren
)paren
(brace
macro_line|#else 
(paren
id|wptr
(braket
id|win
op_plus
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
(brace
macro_line|#endif /* LITTLE_ENDIAN */
id|base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* outside permissable range */
)brace
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|0
)paren
(brace
multiline_comment|/* estimate size */
id|size
op_assign
id|base
op_amp
op_minus
id|base
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* calculate size */
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* turn on all bits */
id|size
op_assign
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
suffix:semicolon
multiline_comment|/* get stored bits */
macro_line|#else 
id|wptr
(braket
id|win
)braket
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* turn on all bits */
id|size
op_assign
id|wptr
(braket
id|win
)braket
suffix:semicolon
multiline_comment|/* get stored bits */
macro_line|#endif /* LITTLE_ENDIAN */
id|size
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* keep addr */
id|size
op_and_assign
op_minus
id|size
suffix:semicolon
multiline_comment|/* keep lsbit */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
op_assign
id|space
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t;     * If this window already has PCI space&n;&t;     * allocated for it, &quot;subtract&quot; that space from&n;&t;     * our running freeblocks. Don&squot;t worry about&n;&t;     * overlaps in existing allocated windows; we&n;&t;     * may be overstating their sizes anyway.&n;&t;     */
r_if
c_cond
(paren
id|base
op_logical_and
id|size
)paren
(brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
(brace
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_io_fb
comma
op_amp
id|pci_io_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_lo_fb
comma
op_amp
id|pci_lo_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
id|pcibr_freeblock_sub
c_func
(paren
op_amp
id|pci_hi_fb
comma
op_amp
id|pci_hi_fl
comma
id|base
comma
id|size
)paren
suffix:semicolon
)brace
)brace
macro_line|#if defined(IOC3_VENDOR_ID_NUM) &amp;&amp; defined(IOC3_DEVICE_ID_NUM)
multiline_comment|/*&n;&t;     * IOC3 BASE_ADDR* BUG WORKAROUND&n;&t;     *&n;&t;     &n;&t;     * If we write to BASE1 on the IOC3, the&n;&t;     * data in BASE0 is replaced. The&n;&t;     * original workaround was to remember&n;&t;     * the value of BASE0 and restore it&n;&t;     * when we ran off the end of the BASE&n;&t;     * registers; however, a later&n;&t;     * workaround was added (I think it was&n;&t;     * rev 1.44) to avoid setting up&n;&t;     * anything but BASE0, with the comment&n;&t;     * that writing all ones to BASE1 set&n;&t;     * the enable-parity-error test feature&n;&t;     * in IOC3&squot;s SCR bit 14.&n;&t;     *&n;&t;     * So, unless we defer doing any PCI&n;&t;     * space allocation until drivers&n;&t;     * attach, and set up a way for drivers&n;&t;     * (the IOC3 in paricular) to tell us&n;&t;     * generically to keep our hands off&n;&t;     * BASE registers, we gotta &quot;know&quot; about&n;&t;     * the IOC3 here.&n;&t;     *&n;&t;     * Too bad the PCI folks didn&squot;t reserve the&n;&t;     * all-zero value for &squot;no BASE here&squot; (it is a&n;&t;     * valid code for an uninitialized BASE in&n;&t;     * 32-bit PCI memory space).&n;&t;     */
r_if
c_cond
(paren
(paren
id|vendor
op_eq
id|IOC3_VENDOR_ID_NUM
)paren
op_logical_and
(paren
id|device
op_eq
id|IOC3_DEVICE_ID_NUM
)paren
)paren
r_break
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|code
op_eq
id|PCI_BA_MEM_64BIT
)paren
(brace
id|win
op_increment
suffix:semicolon
multiline_comment|/* skip upper half */
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* which must be zero */
macro_line|#else 
id|wptr
(braket
id|win
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* which must be zero */
macro_line|#endif /* LITTLE_ENDIAN */
)brace
)brace
multiline_comment|/* next win */
)brace
multiline_comment|/* next func */
multiline_comment|/* Store back the values for allocated pci address spaces */
id|PCI_ADDR_SPACE_LIMITS_STORE
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_info_free&n; *&t;Remove all the pci infrastructural information associated&n; * &t;with a particular pci device.&n; */
r_int
DECL|function|pcibr_slot_info_free
id|pcibr_slot_info_free
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
macro_line|#if defined(PCI_HOTSWAP_DEBUG)
id|cfg_p
id|cfgw
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|win
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
macro_line|#endif /* PCI_HOTSWAP_DEBUG */
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#if defined(PCI_HOTSWAP_DEBUG)
multiline_comment|/* Clean out all the base registers */
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
op_increment
id|win
)paren
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|wptr
(braket
id|win
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
macro_line|#endif /* PCI_HOTSWAP_DEBUG */
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_device_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|DELA
c_func
(paren
id|pcibr_infoh
comma
id|nfunc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|as_debug
r_int
id|as_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * pcibr_slot_addr_space_init&n; *&t;Reserve chunks of pci address space as required by &n; * &t;the base registers in the card.&n; */
r_int
DECL|function|pcibr_slot_addr_space_init
id|pcibr_slot_addr_space_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|iopaddr_t
id|pci_io_fb
comma
id|pci_io_fl
suffix:semicolon
id|iopaddr_t
id|pci_lo_fb
comma
id|pci_lo_fl
suffix:semicolon
id|iopaddr_t
id|pci_hi_fb
comma
id|pci_hi_fl
suffix:semicolon
r_int
id|align
suffix:semicolon
id|iopaddr_t
id|mask
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|func
suffix:semicolon
r_int
id|win
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Get the current values for the allocated pci address spaces */
id|PCI_ADDR_SPACE_LIMITS_LOAD
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as_debug
)paren
macro_line|#ifdef colin
id|PCI_ADDR_SPACE_LIMITS_PRINT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate address space,&n;     * for windows that have not been&n;     * previously assigned.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
l_int|0
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
r_if
c_cond
(paren
id|nfunc
OL
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_infoh
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Try to make the DevIO windows not&n;     * overlap by pushing the &quot;io&quot; and &quot;hi&quot;&n;     * allocation areas up to the next one&n;     * or two megabyte bound. This also&n;     * keeps them from being zero.&n;     *&n;     * DO NOT do this with &quot;pci_lo&quot; since&n;     * the entire &quot;lo&quot; area is only a&n;     * megabyte, total ...&n;     */
id|align
op_assign
(paren
id|slot
OL
l_int|2
)paren
ques
c_cond
l_int|0x200000
suffix:colon
l_int|0x100000
suffix:semicolon
id|mask
op_assign
op_minus
id|align
suffix:semicolon
id|pci_io_fb
op_assign
(paren
id|pci_io_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
id|pci_hi_fb
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|cfg_p
id|cfgw
suffix:semicolon
id|cfg_p
id|wptr
suffix:semicolon
id|pciio_space_t
id|space
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
id|cfg_p
id|pci_cfg_cmd_reg_p
suffix:semicolon
r_int
id|pci_cfg_cmd_reg
suffix:semicolon
r_int
id|pci_cfg_cmd_reg_add
op_assign
l_int|0
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|cfgw
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|f
(braket
id|func
)braket
dot
id|l
suffix:semicolon
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_CFG_BASE_ADDR_0
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
id|PCI_CFG_BASE_ADDRS
suffix:semicolon
op_increment
id|win
)paren
(brace
id|space
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
suffix:semicolon
id|base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
id|size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
(brace
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d is in %d[0x%x..0x%x], alloc by prom&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|space
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
multiline_comment|/* already allocated */
)brace
id|align
op_assign
id|size
suffix:semicolon
multiline_comment|/* ie. 0x00001000 */
r_if
c_cond
(paren
id|align
OL
id|_PAGESZ
)paren
id|align
op_assign
id|_PAGESZ
suffix:semicolon
multiline_comment|/* ie. 0x00004000 */
id|mask
op_assign
op_minus
id|align
suffix:semicolon
multiline_comment|/* ie. 0xFFFFC000 */
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|base
op_assign
(paren
id|pci_io_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_io_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_io_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
macro_line|#ifdef LITTLE_ENDIAN
r_if
c_cond
(paren
(paren
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
macro_line|#else
r_if
c_cond
(paren
(paren
id|wptr
(braket
id|win
)braket
op_amp
id|PCI_BA_MEM_LOCATION
)paren
op_eq
macro_line|#endif  /* LITTLE_ENDIAN */
id|PCI_BA_MEM_1MEG
)paren
(brace
multiline_comment|/* allocate from 20-bit PCI space */
id|base
op_assign
(paren
id|pci_lo_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_lo_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_lo_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate from 32-bit or 64-bit PCI space */
id|base
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_hi_fl
)paren
(brace
id|base
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_hi_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|base
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d window %d had bad space code %d&bslash;n&quot;
comma
id|slot
comma
id|win
comma
id|space
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_assign
id|base
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
op_assign
id|base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Setting base address 0x%p base 0x%x&bslash;n&quot;
comma
op_amp
(paren
id|wptr
(braket
(paren
(paren
id|win
op_star
l_int|4
)paren
op_xor
l_int|4
)paren
op_div
l_int|4
)braket
)paren
comma
id|base
)paren
suffix:semicolon
macro_line|#else
id|wptr
(braket
id|win
)braket
op_assign
id|base
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
r_if
c_cond
(paren
id|base
op_ge
id|size
)paren
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d is in %d [0x%x..0x%x], alloc by pcibr&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|space
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr: slot %d func %d window %d, unable to alloc 0x%x in 0x%p&bslash;n&quot;
comma
id|slot
comma
id|func
comma
id|win
comma
id|size
comma
id|space
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* next base */
multiline_comment|/*&n;&t; * Allocate space for the EXPANSION ROM&n;&t; * NOTE: DO NOT DO THIS ON AN IOC3,&n;&t; * as it blows the system away.&n;&t; */
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_vendor_id
op_ne
id|IOC3_VENDOR_ID_NUM
)paren
op_logical_or
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device_id
op_ne
id|IOC3_DEVICE_ID_NUM
)paren
)paren
(brace
id|wptr
op_assign
id|cfgw
op_plus
id|PCI_EXPANSION_ROM
op_div
l_int|4
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
l_int|1
)braket
op_assign
l_int|0xFFFFF000
suffix:semicolon
id|mask
op_assign
id|wptr
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#else
op_star
id|wptr
op_assign
l_int|0xFFFFF000
suffix:semicolon
id|mask
op_assign
op_star
id|wptr
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0xFFFFF000
)paren
(brace
id|size
op_assign
id|mask
op_amp
op_minus
id|mask
suffix:semicolon
id|align
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|align
OL
id|_PAGESZ
)paren
id|align
op_assign
id|_PAGESZ
suffix:semicolon
id|mask
op_assign
op_minus
id|align
suffix:semicolon
id|base
op_assign
(paren
id|pci_hi_fb
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|pci_hi_fl
)paren
id|base
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|pci_hi_fb
op_assign
id|base
op_plus
id|size
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|wptr
(braket
l_int|1
)braket
op_assign
id|base
suffix:semicolon
macro_line|#else
op_star
id|wptr
op_assign
id|base
suffix:semicolon
macro_line|#endif  /* LITTLE_ENDIAN */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s/%d ROM in 0x%lx..0x%lx (alloc by pcibr)&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|slot
comma
id|base
comma
id|base
op_plus
id|size
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
id|pcibr_info-&gt;f_rbase
op_assign
id|base
suffix:semicolon
id|pcibr_info-&gt;f_rsize
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * if necessary, update the board&squot;s&n;&t; * command register to enable decoding&n;&t; * in the windows we added.&n;&t; *&n;&t; * There are some bits we always want to&n;&t; * be sure are set.&n;&t; */
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_IO_SPACE
suffix:semicolon
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_MEM_SPACE
suffix:semicolon
id|pci_cfg_cmd_reg_add
op_or_assign
id|PCI_CMD_BUS_MASTER
suffix:semicolon
id|pci_cfg_cmd_reg_p
op_assign
id|cfgw
op_plus
id|PCI_CFG_COMMAND
op_div
l_int|4
suffix:semicolon
id|pci_cfg_cmd_reg
op_assign
op_star
id|pci_cfg_cmd_reg_p
suffix:semicolon
macro_line|#if PCI_FBBE&t;/* XXX- check here to see if dev can do fast-back-to-back */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|pci_cfg_cmd_reg
op_rshift
l_int|16
)paren
op_amp
id|PCI_STAT_F_BK_BK_CAP
)paren
)paren
id|fast_back_to_back_enable
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|pci_cfg_cmd_reg
op_and_assign
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|pci_cfg_cmd_reg_add
op_amp
op_complement
id|pci_cfg_cmd_reg
)paren
op_star
id|pci_cfg_cmd_reg_p
op_assign
id|pci_cfg_cmd_reg
op_or
id|pci_cfg_cmd_reg_add
suffix:semicolon
)brace
multiline_comment|/* next func */
multiline_comment|/* Now that we have allocated new chunks of pci address spaces to this&n;     * card we need to update the bookkeeping values which indicate&n;     * the current pci address space allocations.&n;     */
id|PCI_ADDR_SPACE_LIMITS_STORE
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_device_init&n; * &t;Setup the device register in the bridge for this pci slot.&n; */
r_int
DECL|function|pcibr_slot_device_init
id|pcibr_slot_device_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/*&n;     * Adjustments to Device(x)&n;     * and init of bss_device shadow&n;     */
id|devreg
op_assign
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_PAGE_CHK_DIS
suffix:semicolon
id|devreg
op_or_assign
id|BRIDGE_DEV_COH
op_or
id|BRIDGE_DEV_VIRTUAL_EN
suffix:semicolon
macro_line|#ifdef LITTLE_ENDIAN
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): 0x%lx&bslash;n&quot;
comma
id|slot
comma
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr: PCI space allocation done.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_guest_info_init&n; *&t;Setup the host/guest relations for a pci slot.&n; */
r_int
DECL|function|pcibr_slot_guest_info_init
id|pcibr_slot_guest_info_init
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* create info and verticies for guest slots;&n;     * for compatibilitiy macros, create info&n;     * for even unpopulated slots (but do not&n;     * build verticies for them).&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OL
l_int|1
)paren
(brace
id|NEWA
c_func
(paren
id|pcibr_infoh
comma
l_int|1
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
op_assign
id|pcibr_infoh
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|slot
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slotp-&gt;slot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* generate host/guest relations&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_int
id|host
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_soft_slot_t
id|host_slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|host
)braket
suffix:semicolon
id|hwgraph_edge_add
c_func
(paren
id|slotp-&gt;slot_conn
comma
id|host_slotp-&gt;slot_conn
comma
id|EDGE_LBL_HOST
)paren
suffix:semicolon
multiline_comment|/* XXX- only gives us one guest edge per&n;&t; * host. If/when we have a host with more than&n;&t; * one guest, we will need to figure out how&n;&t; * the host finds all its guests, and sorts&n;&t; * out which one is which.&n;&t; */
id|hwgraph_edge_add
c_func
(paren
id|host_slotp-&gt;slot_conn
comma
id|slotp-&gt;slot_conn
comma
id|EDGE_LBL_GUEST
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_initial_rrb_alloc&n; *&t;Allocate a default number of rrbs for this slot on &n; * &t;the two channels. This is dictated by the rrb allocation&n; * &t;strategy routine defined per platform.&n; */
r_int
DECL|function|pcibr_slot_initial_rrb_alloc
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|c0
comma
id|c1
suffix:semicolon
r_int
id|r
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* How may RRBs are on this slot?&n;     */
id|c0
op_assign
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge
comma
id|slot
)paren
suffix:semicolon
id|c1
op_assign
id|do_pcibr_rrb_count_valid
c_func
(paren
id|bridge
comma
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)paren
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: slot %d started with %d+%d&bslash;n&quot;
comma
id|slot
comma
id|c0
comma
id|c1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Do we really need any?&n;     */
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
op_logical_and
op_logical_neg
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
r_if
c_cond
(paren
id|c0
OG
l_int|0
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
comma
id|c0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c1
OG
l_int|0
)paren
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
comma
id|c1
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_assign
l_int|0x1000
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
l_int|0x1000
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|c0
op_plus
id|c1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_assign
id|c0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
id|c1
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|0
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
op_assign
id|do_pcibr_rrb_count_avail
c_func
(paren
id|bridge
comma
l_int|1
)paren
suffix:semicolon
id|r
op_assign
l_int|3
op_minus
(paren
id|c0
op_plus
id|c1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
id|r
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_avail
(braket
id|slot
op_amp
l_int|1
)braket
op_sub_assign
id|r
suffix:semicolon
)brace
macro_line|#if PCIBR_RRB_DEBUG
id|printk
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_attach&n; *&t;This calls the associated driver attach routine for the pci&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_attach
id|pcibr_slot_call_device_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|async_attach_t
id|aa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
comma
id|conn_vhdl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
l_int|0
suffix:semicolon
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|aa
op_assign
id|async_attach_get_info
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;npcibr_slot_call_device_attach: link 0x%p pci bus 0x%p slot %d&bslash;n&quot;
comma
id|xconn_vhdl
comma
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
multiline_comment|/* If the pci device has been disabled in the prom,&n;&t; * do not set it up for driver attach. NOTE: usrpci&n;&t; * and pciba will not &quot;see&quot; this connection point!&n;&t; */
r_if
c_cond
(paren
id|device_admin_info_get
c_func
(paren
id|conn_vhdl
comma
id|ADMIN_LBL_DISABLED
)paren
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pcibr_slot_call_device_attach: %v disabled&bslash;n&quot;
comma
id|conn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aa
)paren
id|async_attach_add_info
c_func
(paren
id|conn_vhdl
comma
id|aa
)paren
suffix:semicolon
id|pciio_device_attach
c_func
(paren
id|conn_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/* next func */
id|printk
c_func
(paren
l_string|&quot;&bslash;npcibr_slot_call_device_attach: DONE&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_slot_call_device_detach&n; *&t;This calls the associated driver detach routine for the pci&n; * &t;card in this slot.&n; */
r_int
DECL|function|pcibr_slot_call_device_detach
id|pcibr_slot_call_device_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|func
suffix:semicolon
id|devfs_handle_t
id|conn_vhdl
suffix:semicolon
r_int
id|nfunc
suffix:semicolon
r_int
id|ndetach
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_soft
op_logical_or
op_logical_neg
id|PCIBR_VALID_SLOT
c_func
(paren
id|slot
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
r_return
l_int|0
suffix:semicolon
id|nfunc
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
op_increment
id|func
)paren
(brace
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_info-&gt;f_vendor
op_eq
id|PCIIO_VENDOR_ID_NONE
)paren
r_continue
suffix:semicolon
id|conn_vhdl
op_assign
id|pcibr_info-&gt;f_vertex
suffix:semicolon
multiline_comment|/* Make sure that we do not detach a system critical device&n;&t; * vertex.&n;&t; */
r_if
c_cond
(paren
id|is_sys_critical_vertex
c_func
(paren
id|conn_vhdl
)paren
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%v is a system critical device vertex&bslash;n&quot;
comma
id|conn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|ndetach
op_assign
l_int|0
suffix:semicolon
id|pciio_device_detach
c_func
(paren
id|conn_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/* next func */
r_return
id|ndetach
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_device_attach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific initialization that needs to be done.&n; *&t;This is usually called when we want to initialize a new&n; * &t;pci card on the bus.&n; */
r_int
DECL|function|pcibr_device_attach
id|pcibr_device_attach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
r_return
(paren
multiline_comment|/* Reset the slot */
id|pcibr_slot_reset
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* FInd out what is out there */
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* Set up the address space for this slot in the pci land */
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* Setup the device register */
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* Setup host/guest relations */
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* Initial RRB management */
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
op_logical_or
multiline_comment|/* Call the device attach */
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_device_detach&n; *&t;This is a place holder routine to keep track of all the&n; *&t;slot-specific freeing that needs to be done.&n; */
r_int
DECL|function|pcibr_device_detach
id|pcibr_device_detach
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_slot_t
id|slot
)paren
(brace
multiline_comment|/* Call the device detach */
r_return
(paren
id|pcibr_slot_call_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_device_unregister&n; *&t;This frees up any hardware resources reserved for this pci device&n; * &t;and removes any pci infrastructural information setup for it.&n; *&t;This is usually used at the time of shutting down of the pci card.&n; */
r_void
DECL|function|pcibr_device_unregister
id|pcibr_device_unregister
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
suffix:semicolon
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* Detach the pciba name space */
id|pciio_device_detach
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_vhdl
op_assign
id|pciio_info_master_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Clear all the hardware xtalk resources for this device */
id|xtalk_widgetdev_shutdown
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Flush all the rrbs */
id|pcibr_rrb_flush
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* Free the rrbs allocated to this slot */
id|do_pcibr_rrb_free
c_func
(paren
id|bridge
comma
id|slot
comma
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_plus
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush the write buffers !! */
(paren
r_void
)paren
id|pcibr_wrb_flush
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* Clear the information specific to the slot */
(paren
r_void
)paren
id|pcibr_slot_info_free
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * build a convenience link path in the&n; * form of &quot;.../&lt;iobrick&gt;/bus/&lt;busnum&gt;&quot;&n; * &n; * returns 1 on success, 0 otherwise&n; *&n; * depends on hwgraph separator == &squot;/&squot;&n; */
r_int
DECL|function|pcibr_bus_cnvlink
id|pcibr_bus_cnvlink
c_func
(paren
id|devfs_handle_t
id|f_c
comma
r_int
id|slot
)paren
(brace
r_char
id|dst
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_char
op_star
id|dp
op_assign
id|dst
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|xp
suffix:semicolon
r_int
id|widgetnum
suffix:semicolon
r_char
id|pcibus
(braket
l_int|8
)braket
suffix:semicolon
id|devfs_handle_t
id|nvtx
comma
id|svtx
suffix:semicolon
r_int
id|rv
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_bus_cnvlink: slot= %d f_c= %p&bslash;n&quot;
comma
id|slot
comma
id|f_c
)paren
suffix:semicolon
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|f_c
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_vertex_name_get
c_func
(paren
id|f_c
comma
id|dst
comma
id|MAXDEVNAME
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* dst example == /hw/module/001c02/Pbrick/xtalk/8/pci/direct */
multiline_comment|/* find the widget number */
id|xp
op_assign
id|strstr
c_func
(paren
id|dst
comma
l_string|&quot;/&quot;
id|EDGE_LBL_XTALK
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|widgetnum
op_assign
id|atoi
c_func
(paren
id|xp
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|widgetnum
template_param
id|XBOW_PORT_F
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* remove &quot;/pci/direct&quot; from path */
id|cp
op_assign
id|strstr
c_func
(paren
id|dst
comma
l_string|&quot;/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/&quot;
l_string|&quot;direct&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|cp
op_assign
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* get the vertex for the widget */
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
l_int|NULL
comma
id|dp
comma
op_amp
id|svtx
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|xp
op_assign
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* remove &quot;/xtalk/...&quot; from path */
multiline_comment|/* dst example now == /hw/module/001c02/Pbrick */
multiline_comment|/* get the bus number */
id|strcat
c_func
(paren
id|dst
comma
l_string|&quot;/bus&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pcibus
comma
l_string|&quot;%d&quot;
comma
id|p_busnum
(braket
id|widgetnum
)braket
)paren
suffix:semicolon
multiline_comment|/* link to bus to widget */
id|rv
op_assign
id|hwgraph_path_add
c_func
(paren
l_int|NULL
comma
id|dp
comma
op_amp
id|nvtx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_eq
id|rv
)paren
id|rv
op_assign
id|hwgraph_edge_add
c_func
(paren
id|nvtx
comma
id|svtx
comma
id|pcibus
)paren
suffix:semicolon
r_return
(paren
id|rv
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_attach: called every time the crosstalk&n; *      infrastructure is asked to initialize a widget&n; *      that matches the part number we handed to the&n; *      registration routine above.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_attach
id|pcibr_attach
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
multiline_comment|/* REFERENCED */
id|graph_error_t
id|rc
suffix:semicolon
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
id|devfs_handle_t
id|ctlr_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
l_int|NULL
suffix:semicolon
id|bridgereg_t
id|id
suffix:semicolon
r_int
id|rev
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|xwidget_info_t
id|info
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
id|device_desc_t
id|dev_desc
suffix:semicolon
r_int
id|slot
suffix:semicolon
r_int
id|ibit
suffix:semicolon
id|devfs_handle_t
id|noslot_conn
suffix:semicolon
r_char
id|devnm
(braket
id|MAXDEVNAME
)braket
comma
op_star
id|s
suffix:semicolon
id|pcibr_hints_t
id|pcibr_hints
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
id|rrb_fixed
op_assign
l_int|0
suffix:semicolon
id|iopaddr_t
id|pci_io_fb
comma
id|pci_io_fl
suffix:semicolon
id|iopaddr_t
id|pci_lo_fb
comma
id|pci_lo_fl
suffix:semicolon
id|iopaddr_t
id|pci_hi_fb
comma
id|pci_hi_fl
suffix:semicolon
r_int
id|spl_level
suffix:semicolon
r_char
op_star
id|nicinfo
op_assign
(paren
r_char
op_star
)paren
l_int|0
suffix:semicolon
macro_line|#if PCI_FBBE
r_int
id|fast_back_to_back_enable
suffix:semicolon
macro_line|#endif
id|async_attach_t
id|aa
op_assign
l_int|NULL
suffix:semicolon
id|aa
op_assign
id|async_attach_get_info
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; ATTACH_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: xconn_vhdl=  %p&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|xconn_vhdl
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s &bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Setup the PRB for the bridge in CONVEYOR BELT&n;     * mode. PRBs are setup in default FIRE-AND-FORGET&n;     * mode during the initialization.&n;     */
id|hub_device_flags_set
c_func
(paren
id|xconn_vhdl
comma
id|HUB_PIO_CONVEYOR
)paren
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_piotrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|NULL
comma
l_int|0
comma
r_sizeof
(paren
id|bridge_t
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef MEDUSA_HACK
r_if
c_cond
(paren
(paren
id|bridge-&gt;b_wid_stat
op_amp
id|BRIDGE_STAT_PCI_GIO_N
)paren
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* someone else handles GIO bridges. */
macro_line|#endif
macro_line|#ifdef BRINGUP
r_if
c_cond
(paren
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|bridge-&gt;b_wid_id
)paren
op_eq
id|XBRIDGE_PART_REV_A
)paren
id|NeedXbridgeSwap
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: Called with vertex 0x%p, b_wid_stat 0x%x, gio 0x%x&bslash;n&quot;
comma
id|xconn_vhdl
comma
id|bridge-&gt;b_wid_stat
comma
id|BRIDGE_STAT_PCI_GIO_N
)paren
suffix:semicolon
multiline_comment|/*&n;     * Create the vertex for the PCI bus, which we&n;     * will also use to hold the pcibr_soft and&n;     * which will be the &quot;master&quot; vertex for all the&n;     * pciio connection points we will hang off it.&n;     * This needs to happen before we call nic_bridge_vertex_info&n;     * as we are some of the *_vmc functions need access to the edges.&n;     *&n;     * Opening this vertex will provide access to&n;     * the Bridge registers themselves.&n;     */
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|xconn_vhdl
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rc
op_assign
id|hwgraph_char_device_add
c_func
(paren
id|pcibr_vhdl
comma
id|EDGE_LBL_CONTROLLER
comma
l_string|&quot;pcibr_&quot;
comma
op_amp
id|ctlr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
multiline_comment|/*&n;     * decode the nic, and hang its stuff off our&n;     * connection point where other drivers can get&n;     * at it.&n;     */
macro_line|#ifdef LATER
id|nicinfo
op_assign
id|BRIDGE_VERTEX_MFG_INFO
c_func
(paren
id|xconn_vhdl
comma
(paren
id|nic_data_t
)paren
op_amp
id|bridge-&gt;b_nic
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Get the hint structure; if some NIC callback&n;     * marked this vertex as &quot;hands-off&quot; then we&n;     * just return here, before doing anything else.&n;     */
id|pcibr_hints
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints
op_logical_and
id|pcibr_hints-&gt;ph_hands_off
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* generic operations disabled */
id|id
op_assign
id|bridge-&gt;b_wid_id
suffix:semicolon
id|rev
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|id
)paren
suffix:semicolon
id|hwgraph_info_add_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
(paren
id|arbitrary_info_t
)paren
id|rev
)paren
suffix:semicolon
multiline_comment|/*&n;     * allocate soft state structure, fill in some&n;     * fields, and hook it up to our vertex.&n;     */
id|NEW
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|BZERO
c_func
(paren
id|pcibr_soft
comma
r_sizeof
op_star
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft_set
c_func
(paren
id|pcibr_vhdl
comma
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_conn
op_assign
id|xconn_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft-&gt;bs_base
op_assign
id|bridge
suffix:semicolon
id|pcibr_soft-&gt;bs_rev_num
op_assign
id|rev
suffix:semicolon
id|pcibr_soft-&gt;bs_intr_bits
op_assign
id|pcibr_intr_bits
suffix:semicolon
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
(brace
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|XBRIDGE_INTERNAL_ATES
suffix:semicolon
id|pcibr_soft-&gt;bs_xbridge
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_int_ate_size
op_assign
id|BRIDGE_INTERNAL_ATES
suffix:semicolon
id|pcibr_soft-&gt;bs_xbridge
op_assign
l_int|0
suffix:semicolon
)brace
id|pcibr_soft-&gt;bsi_err_intr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bridges up through REV C&n;     * are unable to set the direct&n;     * byteswappers to BYTE_STREAM.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_le
id|BRIDGE_PART_REV_C
)paren
(brace
id|pcibr_soft-&gt;bs_pio_end_io
op_assign
id|PCIIO_WORD_VALUES
suffix:semicolon
id|pcibr_soft-&gt;bs_pio_end_mem
op_assign
id|PCIIO_WORD_VALUES
suffix:semicolon
)brace
macro_line|#if PCIBR_SOFT_LIST
(brace
id|pcibr_list_p
id|self
suffix:semicolon
id|NEW
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;bl_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|self-&gt;bl_vhdl
op_assign
id|pcibr_vhdl
suffix:semicolon
id|self-&gt;bl_next
op_assign
id|pcibr_list
suffix:semicolon
id|self-&gt;bl_next
op_assign
id|swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|pcibr_list
comma
(paren
r_void
op_star
)paren
id|self
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;     * get the name of this bridge vertex and keep the info. Use this&n;     * only where it is really needed now: like error interrupts.&n;     */
id|s
op_assign
id|dev_to_name
c_func
(paren
id|pcibr_vhdl
comma
id|devnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pcibr_soft-&gt;bs_name
comma
id|s
)paren
suffix:semicolon
macro_line|#if SHOW_REVS || DEBUG
macro_line|#if !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%sBridge ASIC: rev %s (code=0x%x) at %s&bslash;n&quot;
comma
id|is_xbridge
c_func
(paren
id|bridge
)paren
ques
c_cond
l_string|&quot;X&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_A
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_B
)paren
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_C
)paren
ques
c_cond
l_string|&quot;C&quot;
suffix:colon
(paren
id|rev
op_eq
id|BRIDGE_PART_REV_D
)paren
ques
c_cond
l_string|&quot;D&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBRIDGE_PART_REV_A
)paren
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
(paren
id|rev
op_eq
id|XBRIDGE_PART_REV_B
)paren
ques
c_cond
l_string|&quot;B&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|rev
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
macro_line|#endif
id|info
op_assign
id|xwidget_info_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_xid
op_assign
id|xwidget_info_id_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_master
op_assign
id|xwidget_info_master_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|pcibr_soft-&gt;bs_mxid
op_assign
id|xwidget_info_masterid_get
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/*&n;     * Init bridge lock.&n;     */
id|spinlock_init
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_lock
comma
l_string|&quot;pcibr_loc&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we have one, process the hints structure.&n;     */
r_if
c_cond
(paren
id|pcibr_hints
)paren
(brace
id|rrb_fixed
op_assign
id|pcibr_hints-&gt;ph_rrb_fixed
suffix:semicolon
id|pcibr_soft-&gt;bs_rrb_fixed
op_assign
id|rrb_fixed
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_hints-&gt;ph_intr_bits
)paren
id|pcibr_soft-&gt;bs_intr_bits
op_assign
id|pcibr_hints-&gt;ph_intr_bits
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
(brace
r_int
id|hslot
op_assign
id|pcibr_hints-&gt;ph_host_slot
(braket
id|slot
)braket
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hslot
OL
l_int|0
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|slot
suffix:semicolon
)brace
r_else
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
op_assign
l_int|1
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
op_assign
id|hslot
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * set up initial values for state fields&n;     */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
(brace
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_devio.bssd_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d64_base
op_assign
id|PCIBR_D64_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_d32_base
op_assign
id|PCIBR_D32_BASE_UNSET
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ibit
op_assign
l_int|0
suffix:semicolon
id|ibit
OL
l_int|8
suffix:semicolon
op_increment
id|ibit
)paren
(brace
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_xtalk_intr
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_intr
(braket
id|ibit
)braket
dot
id|bsi_pcibr_intr_list
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * connect up our error handler&n;     */
id|xwidget_error_register
c_func
(paren
id|xconn_vhdl
comma
id|pcibr_error_handler
comma
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/*&n;     * Initialize various Bridge registers.&n;     */
multiline_comment|/*&n;     * On pre-Rev.D bridges, set the PCI_RETRY_CNT&n;     * to zero to avoid dropping stores. (#475347)&n;     */
r_if
c_cond
(paren
id|rev
OL
id|BRIDGE_PART_REV_D
)paren
id|bridge-&gt;b_bus_timeout
op_and_assign
op_complement
id|BRIDGE_BUS_PCI_RETRY_MASK
suffix:semicolon
multiline_comment|/*&n;     * Clear all pending interrupts.&n;     */
id|bridge-&gt;b_int_rst_stat
op_assign
(paren
id|BRIDGE_IRR_ALL_CLR
)paren
suffix:semicolon
multiline_comment|/*&n;     * Until otherwise set up,&n;     * assume all interrupts are&n;     * from slot 7.&n;     */
id|bridge-&gt;b_int_device
op_assign
(paren
r_uint32
)paren
l_int|0xffffffff
suffix:semicolon
(brace
id|bridgereg_t
id|dirmap
suffix:semicolon
id|paddr_t
id|paddr
suffix:semicolon
id|iopaddr_t
id|xbase
suffix:semicolon
id|xwidgetnum_t
id|xport
suffix:semicolon
id|iopaddr_t
id|offset
suffix:semicolon
r_int
id|num_entries
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|cnodeid_t
id|cnodeid
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
r_char
op_star
id|node_val
suffix:semicolon
id|devfs_handle_t
id|node_vhdl
suffix:semicolon
r_char
id|vname
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
multiline_comment|/* Set the Bridge&squot;s 32-bit PCI to XTalk&n;&t; * Direct Map register to the most useful&n;&t; * value we can determine.  Note that we&n;&t; * must use a single xid for all of:&n;&t; *      direct-mapped 32-bit DMA accesses&n;&t; *      direct-mapped 64-bit DMA accesses&n;&t; *      DMA accesses through the PMU&n;&t; *      interrupts&n;&t; * This is the only way to guarantee that&n;&t; * completion interrupts will reach a CPU&n;&t; * after all DMA data has reached memory.&n;&t; * (Of course, there may be a few special&n;&t; * drivers/controllers that explicitly manage&n;&t; * this ordering problem.)&n;&t; */
id|cnodeid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default node id */
multiline_comment|/*&n;&t; * Determine the base address node id to be used for all 32-bit&n;&t; * Direct Mapping I/O. The default is node 0, but this can be changed&n;&t; * via a DEVICE_ADMIN directive and the PCIBUS_DMATRANS_NODE&n;&t; * attribute in the irix.sm config file. A device driver can obtain&n;&t; * this node value via a call to pcibr_get_dmatrans_node().&n;&t; */
id|node_val
op_assign
id|device_admin_info_get
c_func
(paren
id|pcibr_vhdl
comma
id|ADMIN_LBL_DMATRANS_NODE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node_val
op_ne
l_int|NULL
)paren
(brace
id|node_vhdl
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
id|node_val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
id|cnodeid
op_assign
id|nodevertex_to_cnodeid
c_func
(paren
id|node_vhdl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|node_vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
op_logical_or
(paren
id|cnodeid
op_eq
id|CNODEID_NONE
)paren
)paren
(brace
id|cnodeid
op_assign
l_int|0
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|pcibr_vhdl
comma
id|vname
comma
r_sizeof
(paren
id|vname
)paren
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Invalid hwgraph node path specified:&bslash;n     DEVICE_ADMIN: %s %s=%s&bslash;n&quot;
comma
id|vname
comma
id|ADMIN_LBL_DMATRANS_NODE
comma
id|node_val
)paren
suffix:semicolon
)brace
)brace
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|paddr
op_assign
id|NODE_OFFSET
c_func
(paren
id|nasid
)paren
op_plus
l_int|0
suffix:semicolon
multiline_comment|/* currently, we just assume that if we ask&n;&t; * for a DMA mapping to &quot;zero&quot; the XIO&n;&t; * host will transmute this into a request&n;&t; * for the lowest hunk of memory.&n;&t; */
id|xbase
op_assign
id|xtalk_dmatrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|paddr
comma
id|_PAGESZ
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xbase
op_ne
id|XIO_NOWHERE
)paren
(brace
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xbase
)paren
)paren
(brace
id|xport
op_assign
id|XIO_PORT
c_func
(paren
id|xbase
)paren
suffix:semicolon
id|xbase
op_assign
id|XIO_ADDR
c_func
(paren
id|xbase
)paren
suffix:semicolon
)brace
r_else
id|xport
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
id|offset
op_assign
id|xbase
op_amp
(paren
(paren
l_int|1ull
op_lshift
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
)paren
op_minus
l_int|1ull
)paren
suffix:semicolon
id|xbase
op_rshift_assign
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
suffix:semicolon
id|dirmap
op_assign
id|xport
op_lshift
id|BRIDGE_DIRMAP_W_ID_SHFT
suffix:semicolon
macro_line|#ifdef IRIX
id|dirmap
op_or_assign
id|BRIDGE_DIRMAP_RMF_64
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|xbase
)paren
id|dirmap
op_or_assign
id|BRIDGE_DIRMAP_OFF
op_amp
id|xbase
suffix:semicolon
r_else
r_if
c_cond
(paren
id|offset
op_ge
(paren
l_int|512
op_lshift
l_int|20
)paren
)paren
id|dirmap
op_or_assign
id|BRIDGE_DIRMAP_ADD512
suffix:semicolon
id|bridge-&gt;b_dir_map
op_assign
id|dirmap
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set bridge&squot;s idea of page size according to the system&squot;s&n;&t; * idea of &quot;IO page size&quot;.  TBD: The idea of IO page size&n;&t; * should really go away.&n;&t; */
multiline_comment|/*&n;&t; * ensure that we write and read without any interruption.&n;&t; * The read following the write is required for the Bridge war&n;&t; */
id|spl_level
op_assign
id|splhi
c_func
(paren
)paren
suffix:semicolon
macro_line|#if IOPGSIZE == 4096
id|bridge-&gt;b_wid_control
op_and_assign
op_complement
id|BRIDGE_CTRL_PAGE_SIZE
suffix:semicolon
macro_line|#elif IOPGSIZE == 16384
id|bridge-&gt;b_wid_control
op_or_assign
id|BRIDGE_CTRL_PAGE_SIZE
suffix:semicolon
macro_line|#else
op_lshift
template_param
suffix:semicolon
macro_line|#endif
id|bridge-&gt;b_wid_control
suffix:semicolon
multiline_comment|/* inval addr bug war */
id|splx
c_func
(paren
id|spl_level
)paren
suffix:semicolon
multiline_comment|/* Initialize internal mapping entries */
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|pcibr_soft-&gt;bs_int_ate_size
suffix:semicolon
id|entry
op_increment
)paren
id|bridge-&gt;b_int_ate_ram
(braket
id|entry
)braket
dot
id|wr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Determine if there&squot;s external mapping SSRAM on this&n;&t; * bridge.  Set up Bridge control register appropriately,&n;&t; * inititlize SSRAM, and set software up to manage RAM&n;&t; * entries as an allocatable resource.&n;&t; *&n;&t; * Currently, we just use the rm* routines to manage ATE&n;&t; * allocation.  We should probably replace this with a&n;&t; * Best Fit allocator.&n;&t; *&n;&t; * For now, if we have external SSRAM, avoid using&n;&t; * the internal ssram: we can&squot;t turn PREFETCH on&n;&t; * when we use the internal SSRAM; and besides,&n;&t; * this also guarantees that no allocation will&n;&t; * straddle the internal/external line, so we&n;&t; * can increment ATE write addresses rather than&n;&t; * recomparing against BRIDGE_INTERNAL_ATES every&n;&t; * time.&n;&t; */
macro_line|#ifdef BRINGUP
multiline_comment|/*&n;&t; * 082799: for some reason pcibr_init_ext_ate_ram is causing&n;&t; * a Data Bus Error.  It should be zero anyway so just force it.&n;&t; */
id|num_entries
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|num_entries
op_assign
id|pcibr_init_ext_ate_ram
c_func
(paren
id|bridge
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* we always have 128 ATEs (512 for Xbridge) inside the chip&n;&t; * even if disabled for debugging.&n;&t; */
id|pcibr_soft-&gt;bs_int_ate_map
op_assign
id|rmallocmap
c_func
(paren
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft
comma
l_int|0
comma
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: %d INTERNAL ATEs&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|num_entries
OG
id|pcibr_soft-&gt;bs_int_ate_size
)paren
(brace
macro_line|#if PCIBR_ATE_NOTBOTH&t;&t;&t;/* for debug -- forces us to use external ates */
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: disabling internal ATEs.&bslash;n&quot;
)paren
suffix:semicolon
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft
comma
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_soft-&gt;bs_ext_ate_map
op_assign
id|rmallocmap
c_func
(paren
id|num_entries
)paren
suffix:semicolon
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft
comma
id|pcibr_soft-&gt;bs_int_ate_size
comma
id|num_entries
op_minus
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: %d EXTERNAL ATEs&bslash;n&quot;
comma
id|num_entries
op_minus
id|pcibr_soft-&gt;bs_int_ate_size
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
(brace
id|bridgereg_t
id|dirmap
suffix:semicolon
id|iopaddr_t
id|xbase
suffix:semicolon
multiline_comment|/*&n;&t; * now figure the *real* xtalk base address&n;&t; * that dirmap sends us to.&n;&t; */
id|dirmap
op_assign
id|bridge-&gt;b_dir_map
suffix:semicolon
r_if
c_cond
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_OFF
)paren
id|xbase
op_assign
(paren
id|iopaddr_t
)paren
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_OFF
)paren
op_lshift
id|BRIDGE_DIRMAP_OFF_ADDRSHFT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_ADD512
)paren
id|xbase
op_assign
l_int|512
op_lshift
l_int|20
suffix:semicolon
r_else
id|xbase
op_assign
l_int|0
suffix:semicolon
id|pcibr_soft-&gt;bs_dir_xbase
op_assign
id|xbase
suffix:semicolon
multiline_comment|/* it is entirely possible that we may, at this&n;&t; * point, have our dirmap pointing somewhere&n;&t; * other than our &quot;master&quot; port.&n;&t; */
id|pcibr_soft-&gt;bs_dir_xport
op_assign
(paren
id|dirmap
op_amp
id|BRIDGE_DIRMAP_W_ID
)paren
op_rshift
id|BRIDGE_DIRMAP_W_ID_SHFT
suffix:semicolon
)brace
multiline_comment|/* pcibr sources an error interrupt;&n;     * figure out where to send it.&n;     *&n;     * If any interrupts are enabled in bridge,&n;     * then the prom set us up and our interrupt&n;     * has already been reconnected in mlreset&n;     * above.&n;     *&n;     * Need to set the D_INTR_ISERR flag&n;     * in the dev_desc used for allocating the&n;     * error interrupt, so our interrupt will&n;     * be properly routed and prioritized.&n;     *&n;     * If our crosstalk provider wants to&n;     * fix widget error interrupts to specific&n;     * destinations, D_INTR_ISERR is how it&n;     * knows to do this.&n;     */
id|dev_desc
op_assign
id|device_desc_dup
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|device_desc_flags_set
c_func
(paren
id|dev_desc
comma
id|device_desc_flags_get
c_func
(paren
id|dev_desc
)paren
op_or
id|D_INTR_ISERR
)paren
suffix:semicolon
id|device_desc_intr_name_set
c_func
(paren
id|dev_desc
comma
l_string|&quot;Bridge error&quot;
)paren
suffix:semicolon
id|xtalk_intr
op_assign
id|xtalk_intr_alloc
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|pcibr_vhdl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
id|device_desc_free
c_func
(paren
id|dev_desc
)paren
suffix:semicolon
id|pcibr_soft-&gt;bsi_err_intr
op_assign
id|xtalk_intr
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
multiline_comment|/*&n;     * On IP35 with XBridge, we do some extra checks in pcibr_setwidint&n;     * in order to work around some addressing limitations.  In order&n;     * for that fire wall to work properly, we need to make sure we&n;     * start from a known clean state.&n;     */
id|pcibr_clearwidint
c_func
(paren
id|bridge
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;pribr_attach:  FIXME Error Interrupt not registered&bslash;n&quot;
)paren
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
(paren
id|intr_func_t
)paren
id|pcibr_error_intr_handler
comma
(paren
id|intr_arg_t
)paren
id|pcibr_soft
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setwidint
comma
(paren
r_void
op_star
)paren
id|bridge
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * now we can start handling error interrupts;&n;     * enable all of them.&n;     * NOTE: some PCI ints may already be enabled.&n;     */
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
op_or
id|BRIDGE_ISR_ERRORS
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_int_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do not send &quot;clear interrupt&quot; packets */
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
multiline_comment|/*&n;     * Depending on the rev of bridge, disable certain features.&n;     * Easiest way seems to be to force the PCIBR_NOwhatever&n;     * flag to be on for all DMA calls, which overrides any&n;     * PCIBR_whatever flag or even the setting of whatever&n;     * from the PCIIO_DMA_class flags (or even from the other&n;     * PCIBR flags, since NO overrides YES).&n;     */
id|pcibr_soft-&gt;bs_dma_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PREFETCH:&n;     * Always completely disabled for REV.A;&n;     * at &quot;pcibr_prefetch_enable_rev&quot;, anyone&n;     * asking for PCIIO_PREFETCH gets it.&n;     * Between these two points, you have to ask&n;     * for PCIBR_PREFETCH, which promises that&n;     * your driver knows about known Bridge WARs.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
id|BRIDGE_PART_REV_B
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIBR_NOPREFETCH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
(paren
id|BRIDGE_WIDGET_PART_NUM
op_lshift
l_int|4
op_or
id|pcibr_prefetch_enable_rev
)paren
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIIO_NOPREFETCH
suffix:semicolon
multiline_comment|/* WRITE_GATHER:&n;     * Disabled up to but not including the&n;     * rev number in pcibr_wg_enable_rev. There&n;     * is no &quot;WAR range&quot; as with prefetch.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
OL
(paren
id|BRIDGE_WIDGET_PART_NUM
op_lshift
l_int|4
op_or
id|pcibr_wg_enable_rev
)paren
)paren
id|pcibr_soft-&gt;bs_dma_flags
op_or_assign
id|PCIBR_NOWRITE_GATHER
suffix:semicolon
id|pciio_provider_register
c_func
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_provider
)paren
suffix:semicolon
id|pciio_provider_startup
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|pci_io_fb
op_assign
l_int|0x00000004
suffix:semicolon
multiline_comment|/* I/O FreeBlock Base */
id|pci_io_fl
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
multiline_comment|/* I/O FreeBlock Last */
id|pci_lo_fb
op_assign
l_int|0x00000010
suffix:semicolon
multiline_comment|/* Low Memory FreeBlock Base */
id|pci_lo_fl
op_assign
l_int|0x001FFFFF
suffix:semicolon
multiline_comment|/* Low Memory FreeBlock Last */
id|pci_hi_fb
op_assign
l_int|0x00200000
suffix:semicolon
multiline_comment|/* High Memory FreeBlock Base */
id|pci_hi_fl
op_assign
l_int|0x3FFFFFFF
suffix:semicolon
multiline_comment|/* High Memory FreeBlock Last */
id|PCI_ADDR_SPACE_LIMITS_STORE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* build &quot;no-slot&quot; connection point&n;     */
id|pcibr_info
op_assign
id|pcibr_device_info_new
(paren
id|pcibr_soft
comma
id|PCIIO_SLOT_NONE
comma
id|PCIIO_FUNC_NONE
comma
id|PCIIO_VENDOR_ID_NONE
comma
id|PCIIO_DEVICE_ID_NONE
)paren
suffix:semicolon
id|noslot_conn
op_assign
id|pciio_device_info_register
(paren
id|pcibr_vhdl
comma
op_amp
id|pcibr_info-&gt;f_c
)paren
suffix:semicolon
multiline_comment|/* Remember the no slot connection point info for tearing it&n;     * down during detach.&n;     */
id|pcibr_soft-&gt;bs_noslot_conn
op_assign
id|noslot_conn
suffix:semicolon
id|pcibr_soft-&gt;bs_noslot_info
op_assign
id|pcibr_info
suffix:semicolon
macro_line|#if PCI_FBBE
id|fast_back_to_back_enable
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#if PCI_FBBE
r_if
c_cond
(paren
id|fast_back_to_back_enable
)paren
(brace
multiline_comment|/*&n;&t; * All devices on the bus are capable of fast back to back, so&n;&t; * we need to set the fast back to back bit in all devices on&n;&t; * the bus that are capable of doing such accesses.&n;&t; */
)brace
macro_line|#endif
macro_line|#ifdef IRIX
multiline_comment|/* If the bridge has been reset then there is no need to reset&n;     * the individual PCI slots.&n;     */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Reset all the slots */
(paren
r_void
)paren
id|pcibr_slot_reset
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Find out what is out there */
(paren
r_void
)paren
id|pcibr_slot_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Set up the address space for this slot in the pci land */
(paren
r_void
)paren
id|pcibr_slot_addr_space_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Setup the device register */
(paren
r_void
)paren
id|pcibr_slot_device_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Set up convenience links */
r_if
c_cond
(paren
id|is_xbridge
c_func
(paren
id|bridge
)paren
)paren
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
OG
l_int|0
)paren
multiline_comment|/* if occupied */
id|pcibr_bus_cnvlink
c_func
(paren
id|pcibr_info-&gt;f_vertex
comma
id|slot
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Setup host/guest relations */
(paren
r_void
)paren
id|pcibr_slot_guest_info_init
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Initial RRB management */
(paren
r_void
)paren
id|pcibr_slot_initial_rrb_alloc
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
macro_line|#ifdef dagum
multiline_comment|/* driver attach routines should be called out from generic linux code */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
multiline_comment|/* Call the device attach */
(paren
r_void
)paren
id|pcibr_slot_call_device_attach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
macro_line|#endif /* dagum */
macro_line|#ifdef LATER
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|nicinfo
comma
id|XTALK_PCI_PART_NUM
)paren
)paren
(brace
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
l_int|1
comma
l_int|8
)paren
suffix:semicolon
macro_line|#if PCIBR_RRB_DEBUG
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;nFound XTALK_PCI (030-1275) at %v&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pcibr_attach: %v Shoebox RRB MANAGEMENT: %d+%d free&bslash;n&quot;
comma
id|pcibr_vhdl
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|0
)braket
comma
id|pcibr_soft-&gt;bs_rrb_avail
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t%d+%d+%d&quot;
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
l_int|0xFFF
op_amp
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: FIXME to call do_pcibr_rrb_autoalloc nicinfo 0x%p&bslash;n&quot;
comma
id|nicinfo
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aa
)paren
id|async_attach_add_info
c_func
(paren
id|noslot_conn
comma
id|aa
)paren
suffix:semicolon
id|pciio_device_attach
c_func
(paren
id|noslot_conn
)paren
suffix:semicolon
multiline_comment|/* &n;     * Tear down pointer to async attach info -- async threads for&n;     * bridge&squot;s descendants may be running but the bridge&squot;s work is done.&n;     */
r_if
c_cond
(paren
id|aa
)paren
id|async_attach_del_info
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_detach:&n; *&t;Detach the bridge device from the hwgraph after cleaning out all the &n; *&t;underlying vertices.&n; */
r_int
DECL|function|pcibr_detach
id|pcibr_detach
c_func
(paren
id|devfs_handle_t
id|xconn
)paren
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
multiline_comment|/* Get the bridge vertex from its xtalk connection point */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xconn
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pcibr_vhdl
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
l_int|1
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Disable the interrupts from the bridge */
id|bridge-&gt;b_int_enable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Detach all the PCI devices talking to this bridge */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
id|slot
op_increment
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_device_detach called for %p/%d&bslash;n&quot;
comma
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_device_detach
c_func
(paren
id|pcibr_vhdl
comma
id|slot
)paren
suffix:semicolon
)brace
multiline_comment|/* Unregister the no-slot connection point */
id|pciio_device_info_unregister
c_func
(paren
id|pcibr_vhdl
comma
op_amp
(paren
id|pcibr_soft-&gt;bs_noslot_info-&gt;f_c
)paren
)paren
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|pcibr_soft-&gt;bs_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
multiline_comment|/* Error handler gets unregistered when the widget info is &n;     * cleaned &n;     */
multiline_comment|/* Free the soft ATE maps */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_int_ate_map
)paren
id|rmfreemap
c_func
(paren
id|pcibr_soft-&gt;bs_int_ate_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_ext_ate_map
)paren
id|rmfreemap
c_func
(paren
id|pcibr_soft-&gt;bs_ext_ate_map
)paren
suffix:semicolon
multiline_comment|/* Disconnect the error interrupt and free the xtalk resources &n;     * associated with it.&n;     */
id|xtalk_intr_disconnect
c_func
(paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
suffix:semicolon
id|xtalk_intr_free
c_func
(paren
id|pcibr_soft-&gt;bsi_err_intr
)paren
suffix:semicolon
multiline_comment|/* Clear the software state maintained by the bridge driver for this&n;     * bridge.&n;     */
id|DEL
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/* Remove the Bridge revision labelled info */
(paren
r_void
)paren
id|hwgraph_info_remove_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove the character device associated with this bridge */
(paren
r_void
)paren
id|hwgraph_edge_remove
c_func
(paren
id|pcibr_vhdl
comma
id|EDGE_LBL_CONTROLLER
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove the PCI bridge vertex */
(paren
r_void
)paren
id|hwgraph_edge_remove
c_func
(paren
id|xconn
comma
id|EDGE_LBL_PCI
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pcibr_asic_rev
id|pcibr_asic_rev
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
suffix:semicolon
id|arbitrary_info_t
id|ainfo
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_traverse
c_func
(paren
id|pconn_vhdl
comma
id|EDGE_LBL_MASTER
comma
op_amp
id|pcibr_vhdl
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_info_get_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
op_amp
id|ainfo
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
(paren
r_int
)paren
id|ainfo
suffix:semicolon
)brace
r_int
DECL|function|pcibr_write_gather_flush
id|pcibr_write_gather_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_device_write_gather_flush
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    PIO MANAGEMENT&n; */
id|LOCAL
id|iopaddr_t
DECL|function|pcibr_addr_pci_to_xio
id|pcibr_addr_pci_to_xio
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|pciio_slot_t
id|slot
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|bar
suffix:semicolon
multiline_comment|/* which BASE reg on device is decoding */
id|iopaddr_t
id|xio_addr
op_assign
id|XIO_NOWHERE
suffix:semicolon
id|pciio_space_t
id|wspace
suffix:semicolon
multiline_comment|/* which space device is decoding */
id|iopaddr_t
id|wbase
suffix:semicolon
multiline_comment|/* base of device decode on PCI */
r_int
id|wsize
suffix:semicolon
multiline_comment|/* size of device decode on PCI */
r_int
r_try
suffix:semicolon
multiline_comment|/* DevIO(x) window scanning order control */
r_int
id|win
suffix:semicolon
multiline_comment|/* which DevIO(x) window is being used */
id|pciio_space_t
id|mspace
suffix:semicolon
multiline_comment|/* target space for devio(x) register */
id|iopaddr_t
id|mbase
suffix:semicolon
multiline_comment|/* base of devio(x) mapped area on PCI */
r_int
id|msize
suffix:semicolon
multiline_comment|/* size of devio(x) mapped area on PCI */
r_int
id|mmask
suffix:semicolon
multiline_comment|/* addr bits stored in Device(x) */
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|has_host
)paren
(brace
id|slot
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_NONE
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_CFG
)paren
(brace
multiline_comment|/*&n;&t; * Usually, the first mapping&n;&t; * established to a PCI device&n;&t; * is to its config space.&n;&t; *&n;&t; * In any case, we definitely&n;&t; * do NOT need to worry about&n;&t; * PCI BASE registers, and&n;&t; * MUST NOT attempt to point&n;&t; * the DevIO(x) window at&n;&t; * this access ...&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
op_le
id|BRIDGE_TYPE0_CFG_FUNC_OFF
)paren
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|BRIDGE_TYPE0_CFG_DEV
c_func
(paren
id|slot
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_ROM
)paren
(brace
multiline_comment|/* PIO to the Expansion Rom.&n;&t; * Driver is responsible for&n;&t; * enabling and disabling&n;&t; * decodes properly.&n;&t; */
id|wbase
op_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
id|wsize
op_assign
id|pcibr_info-&gt;f_rsize
suffix:semicolon
multiline_comment|/*&n;&t; * While the driver should know better&n;&t; * than to attempt to map more space&n;&t; * than the device is decoding, he might&n;&t; * do it; better to bail out here.&n;&t; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
id|wsize
)paren
r_goto
id|done
suffix:semicolon
id|pci_addr
op_add_assign
id|wbase
suffix:semicolon
id|space
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
)brace
multiline_comment|/*&n;     * reduce window mappings to raw&n;     * space mappings (maybe allocating&n;     * windows), and try for DevIO(x)&n;     * usage (setting it if it is available).&n;     */
id|bar
op_assign
id|space
op_minus
id|PCIIO_SPACE_WIN0
suffix:semicolon
r_if
c_cond
(paren
id|bar
OL
l_int|6
)paren
(brace
id|wspace
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_space
suffix:semicolon
r_if
c_cond
(paren
id|wspace
op_eq
id|PCIIO_SPACE_NONE
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* get pci base and size */
id|wbase
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_base
suffix:semicolon
id|wsize
op_assign
id|pcibr_info-&gt;f_window
(braket
id|bar
)braket
dot
id|w_size
suffix:semicolon
multiline_comment|/*&n;&t; * While the driver should know better&n;&t; * than to attempt to map more space&n;&t; * than the device is decoding, he might&n;&t; * do it; better to bail out here.&n;&t; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
id|wsize
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* shift from window relative to&n;&t; * decoded space relative.&n;&t; */
id|pci_addr
op_add_assign
id|wbase
suffix:semicolon
id|space
op_assign
id|wspace
suffix:semicolon
)brace
r_else
id|bar
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Scan all the DevIO(x) windows twice looking for one&n;     * that can satisfy our request. The first time through,&n;     * only look at assigned windows; the second time, also&n;     * look at PCIIO_SPACE_NONE windows. Arrange the order&n;     * so we always look at our own window first.&n;     *&n;     * We will not attempt to satisfy a single request&n;     * by concatinating multiple windows.&n;     */
r_for
c_loop
(paren
r_try
op_assign
l_int|0
suffix:semicolon
r_try
OL
l_int|16
suffix:semicolon
op_increment
r_try
)paren
(brace
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|win
op_assign
(paren
r_try
op_plus
id|slot
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* If this DevIO(x) mapping area can provide&n;&t; * a mapping to this address, use it.&n;&t; */
id|msize
op_assign
(paren
id|win
OL
l_int|2
)paren
ques
c_cond
l_int|0x200000
suffix:colon
l_int|0x100000
suffix:semicolon
id|mmask
op_assign
op_minus
id|msize
suffix:semicolon
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_IO
)paren
id|mmask
op_and_assign
l_int|0x3FFFFFFF
suffix:semicolon
id|offset
op_assign
id|pci_addr
op_amp
(paren
id|msize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If this window can&squot;t possibly handle that request,&n;&t; * go on to the next window.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|pci_addr
op_amp
(paren
id|msize
op_minus
l_int|1
)paren
)paren
op_plus
id|req_size
)paren
OG
id|msize
)paren
r_continue
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
suffix:semicolon
multiline_comment|/* Is this window &quot;nailed down&quot;?&n;&t; * If not, maybe we can use it.&n;&t; * (only check this the second time through)&n;&t; */
id|mspace
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_space
suffix:semicolon
r_if
c_cond
(paren
(paren
r_try
OG
l_int|7
)paren
op_logical_and
(paren
id|mspace
op_eq
id|PCIIO_SPACE_NONE
)paren
)paren
(brace
multiline_comment|/* If this is the primary DevIO(x) window&n;&t;     * for some other device, skip it.&n;&t;     */
r_if
c_cond
(paren
(paren
id|win
op_ne
id|slot
)paren
op_logical_and
(paren
id|PCIIO_VENDOR_ID_NONE
op_ne
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_vendor_id
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* It&squot;s a free window, and we fit in it.&n;&t;     * Set up Device(win) to our taste.&n;&t;     */
id|mbase
op_assign
id|pci_addr
op_amp
id|mmask
suffix:semicolon
multiline_comment|/* check that we would really get from&n;&t;     * here to there.&n;&t;     */
r_if
c_cond
(paren
(paren
id|mbase
op_or
id|offset
)paren
op_ne
id|pci_addr
)paren
r_continue
suffix:semicolon
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_IO
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_IO_MEM
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_IO_MEM
suffix:semicolon
id|devreg
op_or_assign
(paren
id|mbase
op_rshift
l_int|20
)paren
op_amp
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
multiline_comment|/* default is WORD_VALUES.&n;&t;     * if you specify both,&n;&t;     * operation is undefined.&n;&t;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_DEV_SWAP
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge-&gt;b_device
(braket
id|win
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): 0x%lx&bslash;n&quot;
comma
id|win
comma
id|bridge-&gt;b_device
(braket
id|win
)braket
dot
id|reg
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_space
op_assign
id|space
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_base
op_assign
id|mbase
suffix:semicolon
id|xio_addr
op_assign
id|BRIDGE_DEVIO
c_func
(paren
id|win
)paren
op_plus
(paren
id|pci_addr
op_minus
id|mbase
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s LINE %d map to space %d space desc 0x%x[%lx..%lx] for slot %d allocates DevIO(%d) devreg 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
id|space
comma
id|space_desc
comma
id|pci_addr
comma
id|pci_addr
op_plus
id|req_size
op_minus
l_int|1
comma
id|slot
comma
id|win
comma
id|devreg
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* endif DevIO(x) not pointed */
id|mbase
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|win
)braket
dot
id|bss_devio.bssd_base
suffix:semicolon
multiline_comment|/* Now check for request incompat with DevIO(x)&n;&t; */
r_if
c_cond
(paren
(paren
id|mspace
op_ne
id|space
)paren
op_logical_or
(paren
id|pci_addr
OL
id|mbase
)paren
op_logical_or
(paren
(paren
id|pci_addr
op_plus
id|req_size
)paren
OG
(paren
id|mbase
op_plus
id|msize
)paren
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_logical_and
op_logical_neg
(paren
id|devreg
op_amp
id|BRIDGE_DEV_DEV_SWAP
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
op_logical_and
(paren
id|devreg
op_amp
id|BRIDGE_DEV_DEV_SWAP
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* DevIO(x) window is pointed at PCI space&n;&t; * that includes our target. Calculate the&n;&t; * final XIO address, release the lock and&n;&t; * return.&n;&t; */
id|xio_addr
op_assign
id|BRIDGE_DEVIO
c_func
(paren
id|win
)paren
op_plus
(paren
id|pci_addr
op_minus
id|mbase
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s LINE %d map to space %d [0x%p..0x%p] for slot %d uses DevIO(%d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
id|space
comma
id|pci_addr
comma
id|pci_addr
op_plus
id|req_size
op_minus
l_int|1
comma
id|slot
comma
id|win
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|space
)paren
(brace
multiline_comment|/*&n;&t; * Accesses to device decode&n;&t; * areas that do a not fit&n;&t; * within the DevIO(x) space are&n;&t; * modified to be accesses via&n;&t; * the direct mapping areas.&n;&t; *&n;&t; * If necessary, drivers can&n;&t; * explicitly ask for mappings&n;&t; * into these address spaces,&n;&t; * but this should never be needed.&n;&t; */
r_case
id|PCIIO_SPACE_MEM
suffix:colon
multiline_comment|/* &quot;mem space&quot; */
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
multiline_comment|/* &quot;mem, use 32-bit-wide bus&quot; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|BRIDGE_PCI_MEM32_BASE
op_plus
id|req_size
op_minus
l_int|1
)paren
op_le
id|BRIDGE_PCI_MEM32_LIMIT
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|BRIDGE_PCI_MEM32_BASE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM64
suffix:colon
multiline_comment|/* &quot;mem, use 64-bit-wide bus&quot; */
r_if
c_cond
(paren
(paren
id|pci_addr
op_plus
id|BRIDGE_PCI_MEM64_BASE
op_plus
id|req_size
op_minus
l_int|1
)paren
op_le
id|BRIDGE_PCI_MEM64_LIMIT
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|BRIDGE_PCI_MEM64_BASE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_IO
suffix:colon
multiline_comment|/* &quot;i/o space&quot; */
multiline_comment|/* Bridge Hardware Bug WAR #482741:&n;&t; * The 4G area that maps directly from&n;&t; * XIO space to PCI I/O space is busted&n;&t; * until Bridge Rev D.&n;&t; */
r_if
c_cond
(paren
(paren
id|pcibr_soft-&gt;bs_rev_num
OG
id|BRIDGE_PART_REV_C
)paren
op_logical_and
(paren
(paren
id|pci_addr
op_plus
id|BRIDGE_PCI_IO_BASE
op_plus
id|req_size
op_minus
l_int|1
)paren
op_le
id|BRIDGE_PCI_IO_LIMIT
)paren
)paren
id|xio_addr
op_assign
id|pci_addr
op_plus
id|BRIDGE_PCI_IO_BASE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check that &quot;Direct PIO&quot; byteswapping matches,&n;     * try to change it if it does not.&n;     */
r_if
c_cond
(paren
id|xio_addr
op_ne
id|XIO_NOWHERE
)paren
(brace
r_int
id|bst
suffix:semicolon
multiline_comment|/* nonzero to set bytestream */
r_int
op_star
id|bfp
suffix:semicolon
multiline_comment|/* addr of record of how swapper is set */
r_int
id|swb
suffix:semicolon
multiline_comment|/* which control bit to mung */
r_int
id|bfo
suffix:semicolon
multiline_comment|/* current swapper setting */
r_int
id|bfn
suffix:semicolon
multiline_comment|/* desired swapper setting */
id|bfp
op_assign
(paren
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
ques
c_cond
(paren
op_amp
id|pcibr_soft-&gt;bs_pio_end_io
)paren
suffix:colon
(paren
op_amp
id|pcibr_soft-&gt;bs_pio_end_mem
)paren
)paren
suffix:semicolon
id|bfo
op_assign
op_star
id|bfp
suffix:semicolon
id|bst
op_assign
id|flags
op_amp
id|PCIIO_BYTE_STREAM
suffix:semicolon
id|bfn
op_assign
id|bst
ques
c_cond
id|PCIIO_BYTE_STREAM
suffix:colon
id|PCIIO_WORD_VALUES
suffix:semicolon
r_if
c_cond
(paren
id|bfn
op_eq
id|bfo
)paren
(brace
multiline_comment|/* we already match. */
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bfo
op_ne
l_int|0
)paren
(brace
multiline_comment|/* we have a conflict. */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_addr_pci_to_xio: swap conflict in space %d , was%s%s, want%s%s&bslash;n&quot;
comma
id|space
comma
id|bfo
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfo
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|xio_addr
op_assign
id|XIO_NOWHERE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* OK to make the change. */
id|bridgereg_t
id|octl
comma
id|nctl
suffix:semicolon
id|swb
op_assign
(paren
id|space
op_eq
id|PCIIO_SPACE_IO
)paren
ques
c_cond
id|BRIDGE_CTRL_IO_SWAP
suffix:colon
id|BRIDGE_CTRL_MEM_SWAP
suffix:semicolon
id|octl
op_assign
id|bridge-&gt;b_wid_control
suffix:semicolon
id|nctl
op_assign
id|bst
ques
c_cond
id|octl
op_or
id|swb
suffix:colon
id|octl
op_amp
op_complement
id|swb
suffix:semicolon
r_if
c_cond
(paren
id|octl
op_ne
id|nctl
)paren
multiline_comment|/* make the change if any */
id|bridge-&gt;b_wid_control
op_assign
id|nctl
suffix:semicolon
op_star
id|bfp
op_assign
id|bfn
suffix:semicolon
multiline_comment|/* record the assignment */
macro_line|#if DEBUG &amp;&amp; PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_addr_pci_to_xio: swap for space %d  set to%s%s&bslash;n&quot;
comma
id|space
comma
id|bfn
op_amp
id|PCIIO_BYTE_STREAM
ques
c_cond
l_string|&quot; BYTE_STREAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bfn
op_amp
id|PCIIO_WORD_VALUES
ques
c_cond
l_string|&quot; WORD_VALUES&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|done
suffix:colon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|xio_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED6 */
id|pcibr_piomap_t
DECL|function|pcibr_piomap_alloc
id|pcibr_piomap_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|req_size_max
comma
r_int
id|flags
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pcibr_piomap_t
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap_t
id|maplist
suffix:semicolon
id|pcibr_piomap_t
id|pcibr_piomap
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|xtalk_piomap_t
id|xtalk_piomap
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* Make sure that the req sizes are non-zero */
r_if
c_cond
(paren
(paren
id|req_size
OL
l_int|1
)paren
op_logical_or
(paren
id|req_size_max
OL
l_int|1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;     * Code to translate slot/space/addr&n;     * into xio_addr is common between&n;     * this routine and pcibr_piotrans_addr.&n;     */
id|xio_addr
op_assign
id|pcibr_addr_pci_to_xio
c_func
(paren
id|pconn_vhdl
comma
id|pciio_slot
comma
id|space
comma
id|pci_addr
comma
id|req_size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Check the piomap list to see if there is already an allocated&n;     * piomap entry but not in use. If so use that one. Otherwise&n;     * allocate a new piomap entry and add it to the piomap list&n;     */
id|mapptr
op_assign
op_amp
(paren
id|pcibr_info-&gt;f_piomap
)paren
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_piomap
op_assign
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap
op_ne
l_int|NULL
suffix:semicolon
id|pcibr_piomap
op_assign
id|pcibr_piomap-&gt;bp_next
)paren
(brace
r_if
c_cond
(paren
id|pcibr_piomap-&gt;bp_mapsz
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_piomap
)paren
id|mapptr
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|NEW
c_func
(paren
id|pcibr_piomap
)paren
suffix:semicolon
)brace
id|pcibr_piomap-&gt;bp_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_piomap-&gt;bp_slot
op_assign
id|pciio_slot
suffix:semicolon
id|pcibr_piomap-&gt;bp_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_piomap-&gt;bp_space
op_assign
id|space
suffix:semicolon
id|pcibr_piomap-&gt;bp_pciaddr
op_assign
id|pci_addr
suffix:semicolon
id|pcibr_piomap-&gt;bp_mapsz
op_assign
id|req_size
suffix:semicolon
id|pcibr_piomap-&gt;bp_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_piomap-&gt;bp_toc
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mapptr
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|maplist
op_assign
op_star
id|mapptr
suffix:semicolon
id|pcibr_piomap-&gt;bp_next
op_assign
id|maplist
suffix:semicolon
op_star
id|mapptr
op_assign
id|pcibr_piomap
suffix:semicolon
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_piomap
)paren
(brace
id|xtalk_piomap
op_assign
id|xtalk_piomap_alloc
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|xio_addr
comma
id|req_size
comma
id|req_size_max
comma
id|flags
op_amp
id|PIOMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_piomap
)paren
(brace
id|pcibr_piomap-&gt;bp_xtalk_addr
op_assign
id|xio_addr
suffix:semicolon
id|pcibr_piomap-&gt;bp_xtalk_pio
op_assign
id|xtalk_piomap
suffix:semicolon
)brace
r_else
(brace
id|pcibr_piomap-&gt;bp_mapsz
op_assign
l_int|0
suffix:semicolon
id|pcibr_piomap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|pcibr_piomap
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piomap_free
id|pcibr_piomap_free
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
)paren
(brace
id|xtalk_piomap_free
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
)paren
suffix:semicolon
id|pcibr_piomap-&gt;bp_xtalk_pio
op_assign
l_int|0
suffix:semicolon
id|pcibr_piomap-&gt;bp_mapsz
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|caddr_t
DECL|function|pcibr_piomap_addr
id|pcibr_piomap_addr
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
)paren
(brace
r_return
id|xtalk_piomap_addr
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
comma
id|pcibr_piomap-&gt;bp_xtalk_addr
op_plus
id|pci_addr
op_minus
id|pcibr_piomap-&gt;bp_pciaddr
comma
id|req_size
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piomap_done
id|pcibr_piomap_done
c_func
(paren
id|pcibr_piomap_t
id|pcibr_piomap
)paren
(brace
id|xtalk_piomap_done
c_func
(paren
id|pcibr_piomap-&gt;bp_xtalk_pio
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|caddr_t
DECL|function|pcibr_piotrans_addr
id|pcibr_piotrans_addr
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|xio_addr
op_assign
id|pcibr_addr_pci_to_xio
c_func
(paren
id|pconn_vhdl
comma
id|pciio_slot
comma
id|space
comma
id|pci_addr
comma
id|req_size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|xtalk_piotrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|xio_addr
comma
id|req_size
comma
id|flags
op_amp
id|PIOMAP_FLAGS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PIO Space allocation and management.&n; *      Allocate and Manage the PCI PIO space (mem and io space)&n; *      This routine is pretty simplistic at this time, and&n; *      does pretty trivial management of allocation and freeing..&n; *      The current scheme is prone for fragmentation..&n; *      Change the scheme to use bitmaps.&n; */
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_piospace_alloc
id|pcibr_piospace_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
r_int
id|req_size
comma
r_int
id|alignment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_info_t
id|pciio_info
op_assign
op_amp
id|pcibr_info-&gt;f_c
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pciio_piospace_t
id|piosp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|iopaddr_t
op_star
id|pciaddr
comma
op_star
id|pcilast
suffix:semicolon
id|iopaddr_t
id|start_addr
suffix:semicolon
r_int
id|align_mask
suffix:semicolon
multiline_comment|/*&n;     * Check for proper alignment&n;     */
id|ASSERT
c_func
(paren
id|alignment
op_ge
id|NBPP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|alignment
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|align_mask
op_assign
id|alignment
op_minus
l_int|1
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
multiline_comment|/*&n;     * First look if a previously allocated chunk exists.&n;     */
r_if
c_cond
(paren
(paren
id|piosp
op_assign
id|pcibr_info-&gt;f_piospace
)paren
op_ne
(paren
id|pciio_piospace_t
)paren
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * Look through the list for a right sized free chunk.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|piosp-&gt;free
op_logical_and
(paren
id|piosp-&gt;space
op_eq
id|space
)paren
op_logical_and
(paren
id|piosp-&gt;count
op_ge
id|req_size
)paren
op_logical_and
op_logical_neg
(paren
id|piosp-&gt;start
op_amp
id|align_mask
)paren
)paren
(brace
id|piosp-&gt;free
op_assign
l_int|0
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|piosp-&gt;start
suffix:semicolon
)brace
id|piosp
op_assign
id|piosp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|piosp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|piosp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|space
)paren
(brace
r_case
id|PCIIO_SPACE_IO
suffix:colon
id|pciaddr
op_assign
op_amp
id|pcibr_soft-&gt;bs_spinfo.pci_io_base
suffix:semicolon
id|pcilast
op_assign
op_amp
id|pcibr_soft-&gt;bs_spinfo.pci_io_last
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIIO_SPACE_MEM
suffix:colon
r_case
id|PCIIO_SPACE_MEM32
suffix:colon
id|pciaddr
op_assign
op_amp
id|pcibr_soft-&gt;bs_spinfo.pci_mem_base
suffix:semicolon
id|pcilast
op_assign
op_amp
id|pcibr_soft-&gt;bs_spinfo.pci_mem_last
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|start_addr
op_assign
op_star
id|pciaddr
suffix:semicolon
multiline_comment|/*&n;     * Align start_addr.&n;     */
r_if
c_cond
(paren
id|start_addr
op_amp
id|align_mask
)paren
id|start_addr
op_assign
(paren
id|start_addr
op_plus
id|align_mask
)paren
op_amp
op_complement
id|align_mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_addr
op_plus
id|req_size
)paren
OG
op_star
id|pcilast
)paren
(brace
multiline_comment|/*&n;&t; * If too big a request, reject it.&n;&t; */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|pciaddr
op_assign
(paren
id|start_addr
op_plus
id|req_size
)paren
suffix:semicolon
id|NEW
c_func
(paren
id|piosp
)paren
suffix:semicolon
id|piosp-&gt;free
op_assign
l_int|0
suffix:semicolon
id|piosp-&gt;space
op_assign
id|space
suffix:semicolon
id|piosp-&gt;start
op_assign
id|start_addr
suffix:semicolon
id|piosp-&gt;count
op_assign
id|req_size
suffix:semicolon
id|piosp-&gt;next
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
id|pcibr_info-&gt;f_piospace
op_assign
id|piosp
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|start_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_piospace_free
id|pcibr_piospace_free
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pciaddr
comma
r_int
id|req_size
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pcibr_info-&gt;f_mfast
suffix:semicolon
id|pciio_piospace_t
id|piosp
suffix:semicolon
r_int
id|s
suffix:semicolon
r_char
id|name
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n;     * Look through the bridge data structures for the pciio_piospace_t&n;     * structure corresponding to  &squot;pciaddr&squot;&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|piosp
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
r_while
c_loop
(paren
id|piosp
)paren
(brace
multiline_comment|/*&n;&t; * Piospace free can only be for the complete&n;&t; * chunk and not parts of it..&n;&t; */
r_if
c_cond
(paren
id|piosp-&gt;start
op_eq
id|pciaddr
)paren
(brace
r_if
c_cond
(paren
id|piosp-&gt;count
op_eq
id|req_size
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;     * Improper size passed for freeing..&n;&t;     * Print a message and break;&n;&t;     */
id|hwgraph_vertex_name_get
c_func
(paren
id|pconn_vhdl
comma
id|name
comma
l_int|1024
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pcibr_piospace_free: error&quot;
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Device %s freeing size (0x%lx) different than allocated (0x%lx)&quot;
comma
id|name
comma
id|req_size
comma
id|piosp-&gt;count
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Freeing 0x%lx instead&quot;
comma
id|piosp-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|piosp
op_assign
id|piosp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|piosp
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pcibr_piospace_free: Address 0x%lx size 0x%lx - No match&bslash;n&quot;
comma
id|pciaddr
comma
id|req_size
)paren
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|piosp-&gt;free
op_assign
l_int|1
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    DMA MANAGEMENT&n; *&n; *      The Bridge ASIC provides three methods of doing&n; *      DMA: via a &quot;direct map&quot; register available in&n; *      32-bit PCI space (which selects a contiguous 2G&n; *      address space on some other widget), via&n; *      &quot;direct&quot; addressing via 64-bit PCI space (all&n; *      destination information comes from the PCI&n; *      address, including transfer attributes), and via&n; *      a &quot;mapped&quot; region that allows a bunch of&n; *      different small mappings to be established with&n; *      the PMU.&n; *&n; *      For efficiency, we most prefer to use the 32-bit&n; *      direct mapping facility, since it requires no&n; *      resource allocations. The advantage of using the&n; *      PMU over the 64-bit direct is that single-cycle&n; *      PCI addressing can be used; the advantage of&n; *      using 64-bit direct over PMU addressing is that&n; *      we do not have to allocate entries in the PMU.&n; */
multiline_comment|/*&n; * Convert PCI-generic software flags and Bridge-specific software flags&n; * into Bridge-specific Direct Map attribute bits.&n; */
id|LOCAL
id|iopaddr_t
DECL|function|pcibr_flags_to_d64
id|pcibr_flags_to_d64
c_func
(paren
r_int
id|flags
comma
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|iopaddr_t
id|attributes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sanity check: Bridge only allows use of VCHAN1 via 64-bit addrs */
macro_line|#ifdef IRIX
id|ASSERT_ALWAYS
c_func
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
op_logical_or
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Generic macro flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_DATA
)paren
(brace
multiline_comment|/* standard data channel */
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_BAR
suffix:semicolon
multiline_comment|/* no barrier bit */
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_CMD
)paren
(brace
multiline_comment|/* standard command channel */
id|attributes
op_or_assign
id|PCI64_ATTR_BAR
suffix:semicolon
multiline_comment|/* barrier bit on */
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* disable prefetch */
)brace
multiline_comment|/* Generic detail flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_PREFETCH
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* the swap bit is in the address attributes for xbridge */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_SWAP
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_SWAP
suffix:semicolon
)brace
multiline_comment|/* Provider-specific flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_PREC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_PREC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|attributes
op_or_assign
id|PCI64_ATTR_VIRTUAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN0
)paren
id|attributes
op_and_assign
op_complement
id|PCI64_ATTR_VIRTUAL
suffix:semicolon
r_return
(paren
id|attributes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert PCI-generic software flags and Bridge-specific software flags&n; * into Bridge-specific Address Translation Entry attribute bits.&n; */
id|LOCAL
id|bridge_ate_t
DECL|function|pcibr_flags_to_ate
id|pcibr_flags_to_ate
c_func
(paren
r_int
id|flags
)paren
(brace
id|bridge_ate_t
id|attributes
suffix:semicolon
multiline_comment|/* default if nothing specified:&n;     * NOBARRIER&n;     * NOPREFETCH&n;     * NOPRECISE&n;     * COHERENT&n;     * Plus the valid bit&n;     */
id|attributes
op_assign
id|ATE_CO
op_or
id|ATE_V
suffix:semicolon
multiline_comment|/* Generic macro flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_DATA
)paren
(brace
multiline_comment|/* standard data channel */
id|attributes
op_and_assign
op_complement
id|ATE_BAR
suffix:semicolon
multiline_comment|/* no barrier */
id|attributes
op_or_assign
id|ATE_PREF
suffix:semicolon
multiline_comment|/* prefetch on */
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_CMD
)paren
(brace
multiline_comment|/* standard command channel */
id|attributes
op_or_assign
id|ATE_BAR
suffix:semicolon
multiline_comment|/* barrier bit on */
id|attributes
op_and_assign
op_complement
id|ATE_PREF
suffix:semicolon
multiline_comment|/* disable prefetch */
)brace
multiline_comment|/* Generic detail flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_PREFETCH
)paren
id|attributes
op_or_assign
id|ATE_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|ATE_PREF
suffix:semicolon
multiline_comment|/* Provider-specific flags&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
id|attributes
op_or_assign
id|ATE_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
id|attributes
op_and_assign
op_complement
id|ATE_BAR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
id|attributes
op_or_assign
id|ATE_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|attributes
op_and_assign
op_complement
id|ATE_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
id|attributes
op_or_assign
id|ATE_PREC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
id|attributes
op_and_assign
op_complement
id|ATE_PREC
suffix:semicolon
r_return
(paren
id|attributes
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|pcibr_dmamap_t
DECL|function|pcibr_dmamap_alloc
id|pcibr_dmamap_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
r_int
id|req_size_max
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|xtalk_dmamap_t
id|xtalk_dmamap
suffix:semicolon
id|pcibr_dmamap_t
id|pcibr_dmamap
suffix:semicolon
r_int
id|ate_count
suffix:semicolon
r_int
id|ate_index
suffix:semicolon
multiline_comment|/* merge in forced flags */
id|flags
op_or_assign
id|pcibr_soft-&gt;bs_dma_flags
suffix:semicolon
id|NEWf
c_func
(paren
id|pcibr_dmamap
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_dmamap
)paren
r_return
l_int|0
suffix:semicolon
id|xtalk_dmamap
op_assign
id|xtalk_dmamap_alloc
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|req_size_max
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xtalk_dmamap
)paren
(brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_attach: xtalk_dmamap_alloc failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|DEL
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xio_port
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_dmamap-&gt;bd_slot
op_assign
id|slot
suffix:semicolon
id|pcibr_dmamap-&gt;bd_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xtalk
op_assign
id|xtalk_dmamap
suffix:semicolon
id|pcibr_dmamap-&gt;bd_max_size
op_assign
id|req_size_max
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_port
op_assign
id|xio_port
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_D64_BITS
)paren
)paren
(brace
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
multiline_comment|/* Device is capable of A64 operations,&n;&t;     * and the attributes of the DMA are&n;&t;     * consistant with any previous DMA&n;&t;     * mappings using shared resources.&n;&t;     */
id|pci_addr
op_assign
id|pcibr_flags_to_d64
c_func
(paren
id|flags
comma
id|pcibr_soft
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
l_int|0
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|pci_addr
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|slot
op_add_assign
id|PCIBR_RRB_SLOT_VIRTUAL
suffix:semicolon
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|pci_addr
op_amp
id|PCI64_ATTR_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: using direct64&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: unable to use direct64&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|flags
op_and_assign
op_complement
id|PCIIO_DMA_A64
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_FIXED
)paren
(brace
multiline_comment|/* warning: mappings may fail later,&n;&t; * if direct32 can&squot;t get to the address.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_D32_BITS
)paren
)paren
(brace
multiline_comment|/* User desires DIRECT A32 operations,&n;&t;     * and the attributes of the DMA are&n;&t;     * consistant with any previous DMA&n;&t;     * mappings using shared resources.&n;&t;     * Mapping calls may fail if target&n;&t;     * is outside the direct32 range.&n;&t;     */
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: using direct32&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
id|pcibr_soft-&gt;bs_dir_xbase
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|PCI32_DIRECT_BASE
suffix:semicolon
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: unable to use direct32&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If the user demands FIXED and we can&squot;t&n;&t; * give it to him, fail.&n;&t; */
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate Address Translation Entries from the mapping RAM.&n;     * Unless the PCIBR_NO_ATE_ROUNDUP flag is specified,&n;     * the maximum number of ATEs is based on the worst-case&n;     * scenario, where the requested target is in the&n;     * last byte of an ATE; thus, mapping IOPGSIZE+2&n;     * does end up requiring three ATEs.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_NO_ATE_ROUNDUP
)paren
)paren
(brace
id|ate_count
op_assign
id|IOPG
c_func
(paren
(paren
id|IOPGSIZE
op_minus
l_int|1
)paren
multiline_comment|/* worst case start offset */
op_plus
id|req_size_max
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
r_else
(brace
multiline_comment|/* assume requested target is page aligned */
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|req_size_max
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
id|ate_index
op_assign
id|pcibr_ate_alloc
c_func
(paren
id|pcibr_soft
comma
id|ate_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate_index
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|flags
comma
id|BRIDGE_DEV_PMU_BITS
)paren
)paren
(brace
id|bridge_ate_t
id|ate_proto
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: using PMU&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ate_proto
op_assign
id|pcibr_flags_to_ate
c_func
(paren
id|flags
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_assign
id|flags
suffix:semicolon
id|pcibr_dmamap-&gt;bd_pci_addr
op_assign
id|PCI32_MAPPED_BASE
op_plus
id|IOPGSIZE
op_star
id|ate_index
suffix:semicolon
multiline_comment|/*&n;&t;     * for xbridge the byte-swap bit == bit 29 of pci address&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_BYTE_STREAM
)paren
id|ATE_SWAP_ON
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * If swap was set in bss_device in pcibr_endian_set()&n;&t;&t;     * we need to change the address bit.&n;&t;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_SWAP_PMU
)paren
id|ATE_SWAP_ON
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_WORD_VALUES
)paren
id|ATE_SWAP_OFF
c_func
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
)brace
id|pcibr_dmamap-&gt;bd_xio_addr
op_assign
l_int|0
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_ptr
op_assign
id|pcibr_ate_addr
c_func
(paren
id|pcibr_soft
comma
id|ate_index
)paren
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_index
op_assign
id|ate_index
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_count
op_assign
id|ate_count
suffix:semicolon
id|pcibr_dmamap-&gt;bd_ate_proto
op_assign
id|ate_proto
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
)paren
(brace
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ate_proto
op_amp
id|ATE_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ate_index
op_ge
id|pcibr_soft-&gt;bs_int_ate_size
op_logical_and
op_logical_neg
id|pcibr_soft-&gt;bs_xbridge
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_volatile
r_int
op_star
id|cmd_regp
suffix:semicolon
r_int
id|cmd_reg
suffix:semicolon
r_int
id|s
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_or_assign
id|PCIBR_DMAMAP_SSRAM
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|cmd_regp
op_assign
op_amp
(paren
id|bridge
op_member_access_from_pointer
id|b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
)paren
suffix:semicolon
id|cmd_reg
op_assign
op_star
id|cmd_regp
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_cmd_pointer
op_assign
id|cmd_regp
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_cmd_shadow
op_assign
id|cmd_reg
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|pcibr_dmamap
suffix:semicolon
)brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: unable to use PMU&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_ate_free
c_func
(paren
id|pcibr_soft
comma
id|ate_index
comma
id|ate_count
)paren
suffix:semicolon
)brace
multiline_comment|/* total failure: sorry, you just can&squot;t&n;     * get from here to there that way.&n;     */
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_alloc: complete failure.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|xtalk_dmamap_free
c_func
(paren
id|xtalk_dmamap
)paren
suffix:semicolon
id|DEL
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_dmamap_free
id|pcibr_dmamap_free
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|pcibr_dmamap-&gt;bd_slot
suffix:semicolon
macro_line|#ifdef IRIX
r_int
id|flags
op_assign
id|pcibr_dmamap-&gt;bd_flags
suffix:semicolon
macro_line|#endif
multiline_comment|/* Make sure that bss_ext_ates_active&n;     * is properly kept up to date.&n;     */
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|PCIBR_DMAMAP_BUSY
op_amp
id|flags
)paren
r_if
c_cond
(paren
id|PCIBR_DMAMAP_SSRAM
op_amp
id|flags
)paren
id|atomicAddInt
c_func
(paren
op_amp
(paren
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|xtalk_dmamap_free
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
id|pcibr_release_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|BRIDGE_DEV_D64_BITS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_ate_count
)paren
(brace
id|pcibr_ate_free
c_func
(paren
id|pcibr_dmamap-&gt;bd_soft
comma
id|pcibr_dmamap-&gt;bd_ate_index
comma
id|pcibr_dmamap-&gt;bd_ate_count
)paren
suffix:semicolon
id|pcibr_release_device
c_func
(paren
id|pcibr_soft
comma
id|slot
comma
id|BRIDGE_DEV_PMU_BITS
)paren
suffix:semicolon
)brace
id|DEL
c_func
(paren
id|pcibr_dmamap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup an Address Translation Entry as specified.  Use either the Bridge&n; * internal maps or the external map RAM, as appropriate.&n; */
id|LOCAL
id|bridge_ate_p
DECL|function|pcibr_ate_addr
id|pcibr_ate_addr
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|ate_index
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_return
(paren
id|ate_index
OL
id|pcibr_soft-&gt;bs_int_ate_size
)paren
ques
c_cond
op_amp
(paren
id|bridge-&gt;b_int_ate_ram
(braket
id|ate_index
)braket
dot
id|wr
)paren
suffix:colon
op_amp
(paren
id|bridge-&gt;b_ext_ate_ram
(braket
id|ate_index
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *    pcibr_addr_xio_to_pci: given a PIO range, hand&n; *      back the corresponding base PCI MEM address;&n; *      this is used to short-circuit DMA requests that&n; *      loop back onto this PCI bus.&n; */
id|LOCAL
id|iopaddr_t
DECL|function|pcibr_addr_xio_to_pci
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft_t
id|soft
comma
id|iopaddr_t
id|xio_addr
comma
r_int
id|req_size
)paren
(brace
id|iopaddr_t
id|xio_lim
op_assign
id|xio_addr
op_plus
id|req_size
op_minus
l_int|1
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|BRIDGE_PCI_MEM32_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|BRIDGE_PCI_MEM32_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|BRIDGE_PCI_MEM32_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|BRIDGE_PCI_MEM64_BASE
)paren
op_logical_and
(paren
id|xio_lim
op_le
id|BRIDGE_PCI_MEM64_LIMIT
)paren
)paren
(brace
id|pci_addr
op_assign
id|xio_addr
op_minus
id|BRIDGE_PCI_MEM64_BASE
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
r_if
c_cond
(paren
(paren
id|xio_addr
op_ge
id|BRIDGE_DEVIO
c_func
(paren
id|slot
)paren
)paren
op_logical_and
(paren
id|xio_lim
OL
id|BRIDGE_DEVIO
c_func
(paren
id|slot
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|bridgereg_t
id|dev
suffix:semicolon
id|dev
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_device
suffix:semicolon
id|pci_addr
op_assign
id|dev
op_amp
id|BRIDGE_DEV_OFF_MASK
suffix:semicolon
id|pci_addr
op_lshift_assign
id|BRIDGE_DEV_OFF_ADDR_SHFT
suffix:semicolon
id|pci_addr
op_add_assign
id|xio_addr
op_minus
id|BRIDGE_DEVIO
c_func
(paren
id|slot
)paren
suffix:semicolon
r_return
(paren
id|dev
op_amp
id|BRIDGE_DEV_DEV_IO_MEM
)paren
ques
c_cond
id|pci_addr
suffix:colon
id|PCI_NOWHERE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We are starting to get more complexity&n; * surrounding writing ATEs, so pull&n; * the writing code into this new function.&n; * XXX mail ranga@engr for IP27 prom!&n; */
macro_line|#if PCIBR_FREEZE_TIME
DECL|macro|ATE_FREEZE
mdefine_line|#define&t;ATE_FREEZE()&t;s = ate_freeze(pcibr_dmamap, &amp;freeze_time, cmd_regs)
macro_line|#else
DECL|macro|ATE_FREEZE
mdefine_line|#define&t;ATE_FREEZE()&t;s = ate_freeze(pcibr_dmamap, cmd_regs)
macro_line|#endif
id|LOCAL
r_int
DECL|function|ate_freeze
id|ate_freeze
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
macro_line|#if PCIBR_FREEZE_TIME
r_int
op_star
id|freeze_time_ptr
comma
macro_line|#endif
r_int
op_star
id|cmd_regs
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
macro_line|#ifdef IRIX
r_int
id|dma_slot
op_assign
id|pcibr_dmamap-&gt;bd_slot
suffix:semicolon
macro_line|#endif
r_int
id|ext_ates
op_assign
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_SSRAM
suffix:semicolon
r_int
id|slot
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|cmd_reg
suffix:semicolon
r_volatile
r_int
op_star
id|cmd_lwa
suffix:semicolon
r_int
id|cmd_lwd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext_ates
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Bridge Hardware Bug WAR #484930:&n;     * Bridge can&squot;t handle updating External ATEs&n;     * while DMA is occuring that uses External ATEs,&n;     * even if the particular ATEs involved are disjoint.&n;     */
multiline_comment|/* need to prevent anyone else from&n;     * unfreezing the grant while we&n;     * are working; also need to prevent&n;     * this thread from being interrupted&n;     * to keep PCI grant freeze time&n;     * at an absolute minimum.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
macro_line|#ifdef IRIX
multiline_comment|/* just in case pcibr_dmamap_done was not called */
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_BUSY
)paren
(brace
id|pcibr_dmamap-&gt;bd_flags
op_and_assign
op_complement
id|PCIBR_DMAMAP_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_SSRAM
)paren
id|atomicAddInt
c_func
(paren
op_amp
(paren
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|dma_slot
)braket
dot
id|bss_ext_ates_active
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xtalk_dmamap_done
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if PCIBR_FREEZE_TIME
op_star
id|freeze_time_ptr
op_assign
id|get_timestamp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|cmd_lwa
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
r_if
c_cond
(paren
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
)paren
(brace
id|cmd_reg
op_assign
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|slot
)braket
dot
id|bss_cmd_shadow
suffix:semicolon
r_if
c_cond
(paren
id|cmd_reg
op_amp
id|PCI_CMD_BUS_MASTER
)paren
(brace
id|cmd_lwa
op_assign
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|slot
)braket
dot
id|bss_cmd_pointer
suffix:semicolon
id|cmd_lwd
op_assign
id|cmd_reg
op_xor
id|PCI_CMD_BUS_MASTER
suffix:semicolon
id|cmd_lwa
(braket
l_int|0
)braket
op_assign
id|cmd_lwd
suffix:semicolon
)brace
id|cmd_regs
(braket
id|slot
)braket
op_assign
id|cmd_reg
suffix:semicolon
)brace
r_else
id|cmd_regs
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd_lwa
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/* Read the last master bit that has been cleared. This PIO read&n;&t;     * on the PCI bus is to ensure the completion of any DMAs that&n;&t;     * are due to bus requests issued by PCI devices before the&n;&t;     * clearing of master bits.&n;&t;     */
id|cmd_lwa
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Flush all the write buffers in the bridge */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
r_if
c_cond
(paren
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|slot
)braket
dot
id|bss_ext_ates_active
)paren
(brace
multiline_comment|/* Flush the write buffer associated with this&n;&t;&t;&t;     * PCI device which might be using dma map RAM.&n;&t;&t;&t;     */
id|bridge-&gt;b_wr_req_buf
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
)brace
)brace
r_return
id|s
suffix:semicolon
)brace
DECL|macro|ATE_WRITE
mdefine_line|#define&t;ATE_WRITE()    ate_write(ate_ptr, ate_count, ate)
id|LOCAL
r_void
DECL|function|ate_write
id|ate_write
c_func
(paren
id|bridge_ate_p
id|ate_ptr
comma
r_int
id|ate_count
comma
id|bridge_ate_t
id|ate
)paren
(brace
r_while
c_loop
(paren
id|ate_count
op_decrement
OG
l_int|0
)paren
(brace
op_star
id|ate_ptr
op_increment
op_assign
id|ate
suffix:semicolon
id|ate
op_add_assign
id|IOPGSIZE
suffix:semicolon
)brace
)brace
macro_line|#if PCIBR_FREEZE_TIME
DECL|macro|ATE_THAW
mdefine_line|#define&t;ATE_THAW()&t;ate_thaw(pcibr_dmamap, ate_index, ate, ate_total, freeze_time, cmd_regs, s)
macro_line|#else
DECL|macro|ATE_THAW
mdefine_line|#define&t;ATE_THAW()&t;ate_thaw(pcibr_dmamap, ate_index, cmd_regs, s)
macro_line|#endif
id|LOCAL
r_void
DECL|function|ate_thaw
id|ate_thaw
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
r_int
id|ate_index
comma
macro_line|#if PCIBR_FREEZE_TIME
id|bridge_ate_t
id|ate
comma
r_int
id|ate_total
comma
r_int
id|freeze_time_start
comma
macro_line|#endif
r_int
op_star
id|cmd_regs
comma
r_int
id|s
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
macro_line|#ifdef IRIX
r_int
id|dma_slot
op_assign
id|pcibr_dmamap-&gt;bd_slot
suffix:semicolon
macro_line|#endif
r_int
id|slot
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|ext_ates
op_assign
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_SSRAM
suffix:semicolon
r_int
id|cmd_reg
suffix:semicolon
macro_line|#if PCIBR_FREEZE_TIME
r_int
id|freeze_time
suffix:semicolon
r_static
r_int
id|max_freeze_time
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|max_ate_total
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ext_ates
)paren
r_return
suffix:semicolon
multiline_comment|/* restore cmd regs */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
op_increment
id|slot
)paren
r_if
c_cond
(paren
(paren
id|cmd_reg
op_assign
id|cmd_regs
(braket
id|slot
)braket
)paren
op_amp
id|PCI_CMD_BUS_MASTER
)paren
id|bridge-&gt;b_type0_cfg_dev
(braket
id|slot
)braket
dot
id|l
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
op_assign
id|cmd_reg
suffix:semicolon
id|pcibr_dmamap-&gt;bd_flags
op_or_assign
id|PCIBR_DMAMAP_BUSY
suffix:semicolon
macro_line|#ifdef IRIX
id|atomicAddInt
c_func
(paren
op_amp
(paren
id|pcibr_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|dma_slot
)braket
dot
id|bss_ext_ates_active
)paren
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if PCIBR_FREEZE_TIME
id|freeze_time
op_assign
id|get_timestamp
c_func
(paren
)paren
op_minus
id|freeze_time_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|max_freeze_time
OL
id|freeze_time
)paren
op_logical_or
(paren
id|max_ate_total
OL
id|ate_total
)paren
)paren
(brace
r_if
c_cond
(paren
id|max_freeze_time
OL
id|freeze_time
)paren
id|max_freeze_time
op_assign
id|freeze_time
suffix:semicolon
r_if
c_cond
(paren
id|max_ate_total
OL
id|ate_total
)paren
id|max_ate_total
op_assign
id|ate_total
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: pci freeze time %d usec for %d ATEs&bslash;n&quot;
l_string|&quot;&bslash;tfirst ate: %R&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|freeze_time
op_star
l_int|1000
op_div
l_int|1250
comma
id|ate_total
comma
id|ate
comma
id|ate_bits
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_dmamap_addr
id|pcibr_dmamap_addr
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
id|paddr_t
id|paddr
comma
r_int
id|req_size
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|pcibr_dmamap
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|req_size
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|req_size
op_le
id|pcibr_dmamap-&gt;bd_max_size
)paren
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
id|flags
op_assign
id|pcibr_dmamap-&gt;bd_flags
suffix:semicolon
id|xio_addr
op_assign
id|xtalk_dmamap_addr
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
comma
id|paddr
comma
id|req_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_dmamap-&gt;bd_xio_port
suffix:semicolon
multiline_comment|/* If this DMA is to an address that&n;     * refers back to this Bridge chip,&n;     * reduce it back to the correct&n;     * PCI MEM address.&n;     */
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|pci_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|req_size
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
multiline_comment|/* A64 DMA:&n;&t; * always use 64-bit direct mapping,&n;&t; * which always works.&n;&t; * Device(x) was set up during&n;&t; * dmamap allocation.&n;&t; */
multiline_comment|/* attributes are already bundled up into bd_pci_addr.&n;&t; */
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
op_or
id|xio_addr
suffix:semicolon
multiline_comment|/* Bridge Hardware WAR #482836:&n;&t; * If the transfer is not cache aligned&n;&t; * and the Bridge Rev is &lt;= B, force&n;&t; * prefetch to be off.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|pci_addr
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_addr (direct64):&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;tXIO port 0x%x offset 0x%x&bslash;n&quot;
l_string|&quot;&bslash;treturning PCI 0x%x&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
comma
id|xio_addr
comma
id|pci_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_FIXED
)paren
(brace
multiline_comment|/* A32 direct DMA:&n;&t; * always use 32-bit direct mapping,&n;&t; * which may fail.&n;&t; * Device(x) was set up during&n;&t; * dmamap allocation.&n;&t; */
r_if
c_cond
(paren
id|xio_port
op_ne
id|pcibr_soft-&gt;bs_dir_xport
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wrong DIDN */
r_else
r_if
c_cond
(paren
id|xio_addr
OL
id|pcibr_dmamap-&gt;bd_xio_addr
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* out of range */
r_else
r_if
c_cond
(paren
(paren
id|xio_addr
op_plus
id|req_size
)paren
OG
(paren
id|pcibr_dmamap-&gt;bd_xio_addr
op_plus
id|BRIDGE_DMA_DIRECT_SIZE
)paren
)paren
id|pci_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* out of range */
r_else
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_plus
id|xio_addr
op_minus
id|pcibr_dmamap-&gt;bd_xio_addr
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_addr (direct32):&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;tXIO port 0x%x offset 0x%x&bslash;n&quot;
l_string|&quot;&bslash;treturning PCI 0x%x&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_port
comma
id|xio_addr
comma
id|pci_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|iopaddr_t
id|offset
op_assign
id|IOPGOFF
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|bridge_ate_t
id|ate_proto
op_assign
id|pcibr_dmamap-&gt;bd_ate_proto
suffix:semicolon
r_int
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|offset
op_plus
id|req_size
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|ate_index
op_assign
id|pcibr_dmamap-&gt;bd_ate_index
suffix:semicolon
r_int
id|cmd_regs
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if PCIBR_FREEZE_TIME
r_int
id|ate_total
op_assign
id|ate_count
suffix:semicolon
r_int
id|freeze_time
suffix:semicolon
macro_line|#endif
macro_line|#if PCIBR_ATE_DEBUG
id|bridge_ate_t
id|ate_cmp
suffix:semicolon
id|bridge_ate_p
id|ate_cptr
suffix:semicolon
r_int
id|ate_lo
comma
id|ate_hi
suffix:semicolon
r_int
id|ate_bad
op_assign
l_int|0
suffix:semicolon
r_int
id|ate_rbc
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|bridge_ate_p
id|ate_ptr
op_assign
id|pcibr_dmamap-&gt;bd_ate_ptr
suffix:semicolon
id|bridge_ate_t
id|ate
suffix:semicolon
multiline_comment|/* Bridge Hardware WAR #482836:&n;&t; * If the transfer is not cache aligned&n;&t; * and the Bridge Rev is &lt;= B, force&n;&t; * prefetch to be off.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|ate_proto
op_and_assign
op_complement
id|ATE_PREF
suffix:semicolon
id|ate
op_assign
id|ate_proto
op_or
(paren
id|xio_port
op_lshift
id|ATE_TIDSHIFT
)paren
op_or
(paren
id|xio_addr
op_minus
id|offset
)paren
suffix:semicolon
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
op_plus
id|offset
suffix:semicolon
multiline_comment|/* Fill in our mapping registers&n;&t; * with the appropriate xtalk data,&n;&t; * and hand back the PCI address.&n;&t; */
id|ASSERT
c_func
(paren
id|ate_count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate_count
op_le
id|pcibr_dmamap-&gt;bd_ate_count
)paren
(brace
id|ATE_FREEZE
c_func
(paren
)paren
suffix:semicolon
id|ATE_WRITE
c_func
(paren
)paren
suffix:semicolon
id|ATE_THAW
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
r_else
(brace
multiline_comment|/* The number of ATE&squot;s required is greater than the number&n;&t;&t; * allocated for this map. One way this can happen is if&n;&t;&t; * pcibr_dmamap_alloc() was called with the PCIBR_NO_ATE_ROUNDUP&n;&t;&t; * flag, and then when that map is used (right now), the&n;&t;&t; * target address tells us we really did need to roundup.&n;&t;&t; * The other possibility is that the map is just plain too&n;&t;&t; * small to handle the requested target area.&n;&t;&t; */
macro_line|#if PCIBR_ATE_DEBUG
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pcibr_dmamap_addr :&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;tate_count 0x%x bd_ate_count 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tATE&squot;s required &gt; number allocated&bslash;n&quot;
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|ate_count
comma
id|pcibr_dmamap-&gt;bd_ate_count
)paren
suffix:semicolon
macro_line|#endif
id|pci_addr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|pci_addr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|alenlist_t
DECL|function|pcibr_dmamap_list
id|pcibr_dmamap_list
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
comma
id|alenlist_t
id|palenlist
comma
r_int
id|flags
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
macro_line|#ifdef IRIX
id|bridge_t
op_star
id|bridge
suffix:semicolon
macro_line|#else
id|bridge_t
op_star
id|bridge
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
r_int
id|al_flags
op_assign
(paren
id|flags
op_amp
id|PCIIO_NOSLEEP
)paren
ques
c_cond
id|AL_NOSLEEP
suffix:colon
l_int|0
suffix:semicolon
r_int
id|inplace
op_assign
id|flags
op_amp
id|PCIIO_INPLACE
suffix:semicolon
id|alenlist_t
id|pciio_alenlist
op_assign
l_int|0
suffix:semicolon
id|alenlist_t
id|xtalk_alenlist
suffix:semicolon
r_int
id|length
suffix:semicolon
id|iopaddr_t
id|offset
suffix:semicolon
r_int
id|direct64
suffix:semicolon
macro_line|#ifdef IRIX
r_int
id|ate_index
suffix:semicolon
r_int
id|ate_count
suffix:semicolon
r_int
id|ate_total
op_assign
l_int|0
suffix:semicolon
id|bridge_ate_p
id|ate_ptr
suffix:semicolon
id|bridge_ate_t
id|ate_proto
suffix:semicolon
macro_line|#else
r_int
id|ate_index
op_assign
l_int|0
suffix:semicolon
r_int
id|ate_count
op_assign
l_int|0
suffix:semicolon
r_int
id|ate_total
op_assign
l_int|0
suffix:semicolon
id|bridge_ate_p
id|ate_ptr
op_assign
(paren
id|bridge_ate_p
)paren
l_int|0
suffix:semicolon
id|bridge_ate_t
id|ate_proto
op_assign
(paren
id|bridge_ate_t
)paren
l_int|0
suffix:semicolon
macro_line|#endif
id|bridge_ate_t
id|ate_prev
suffix:semicolon
id|bridge_ate_t
id|ate
suffix:semicolon
id|alenaddr_t
id|xio_addr
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
id|alenaddr_t
id|new_addr
suffix:semicolon
r_int
id|cmd_regs
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|s
op_assign
l_int|0
suffix:semicolon
macro_line|#if PCIBR_FREEZE_TIME
r_int
id|freeze_time
suffix:semicolon
macro_line|#endif
r_int
id|ate_freeze_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To pair ATE_THAW&n;&t;&t;&t;&t;&t;&t;&t; * with an ATE_FREEZE&n;&t;&t;&t;&t;&t;&t;&t; */
id|pcibr_soft
op_assign
id|pcibr_dmamap-&gt;bd_soft
suffix:semicolon
id|xtalk_alenlist
op_assign
id|xtalk_dmamap_list
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
comma
id|palenlist
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xtalk_alenlist
)paren
r_goto
id|fail
suffix:semicolon
id|alenlist_cursor_init
c_func
(paren
id|xtalk_alenlist
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inplace
)paren
(brace
id|pciio_alenlist
op_assign
id|xtalk_alenlist
suffix:semicolon
)brace
r_else
(brace
id|pciio_alenlist
op_assign
id|alenlist_create
c_func
(paren
id|al_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pciio_alenlist
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|direct64
op_assign
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIIO_DMA_A64
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|direct64
)paren
(brace
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|ate_ptr
op_assign
id|pcibr_dmamap-&gt;bd_ate_ptr
suffix:semicolon
id|ate_index
op_assign
id|pcibr_dmamap-&gt;bd_ate_index
suffix:semicolon
id|ate_proto
op_assign
id|pcibr_dmamap-&gt;bd_ate_proto
suffix:semicolon
id|ATE_FREEZE
c_func
(paren
)paren
suffix:semicolon
id|ate_freeze_done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Remember that we need to do an ATE_THAW */
)brace
id|pci_addr
op_assign
id|pcibr_dmamap-&gt;bd_pci_addr
suffix:semicolon
id|ate_prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* matches no valid ATEs */
r_while
c_loop
(paren
id|ALENLIST_SUCCESS
op_eq
id|alenlist_get
c_func
(paren
id|xtalk_alenlist
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|xio_addr
comma
op_amp
id|length
comma
id|al_flags
)paren
)paren
(brace
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_dmamap-&gt;bd_xio_port
suffix:semicolon
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|new_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_addr
op_eq
id|PCI_NOWHERE
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|direct64
)paren
(brace
id|new_addr
op_assign
id|pci_addr
op_or
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
multiline_comment|/* Bridge Hardware WAR #482836:&n;&t;     * If the transfer is not cache aligned&n;&t;     * and the Bridge Rev is &lt;= B, force&n;&t;     * prefetch to be off.&n;&t;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|new_addr
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* calculate the ate value for&n;&t;     * the first address. If it&n;&t;     * matches the previous&n;&t;     * ATE written (ie. we had&n;&t;     * multiple blocks in the&n;&t;     * same IOPG), then back up&n;&t;     * and reuse that ATE.&n;&t;     *&n;&t;     * We are NOT going to&n;&t;     * aggressively try to&n;&t;     * reuse any other ATEs.&n;&t;     */
id|offset
op_assign
id|IOPGOFF
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|ate
op_assign
id|ate_proto
op_or
(paren
id|xio_port
op_lshift
id|ATE_TIDSHIFT
)paren
op_or
(paren
id|xio_addr
op_minus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate
op_eq
id|ate_prev
)paren
(brace
macro_line|#if PCIBR_ATE_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmamap_list: ATE share&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ate_ptr
op_decrement
suffix:semicolon
id|ate_index
op_decrement
suffix:semicolon
id|pci_addr
op_sub_assign
id|IOPGSIZE
suffix:semicolon
)brace
id|new_addr
op_assign
id|pci_addr
op_plus
id|offset
suffix:semicolon
multiline_comment|/* Fill in the hardware ATEs&n;&t;     * that contain this block.&n;&t;     */
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|offset
op_plus
id|length
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
id|ate_total
op_add_assign
id|ate_count
suffix:semicolon
multiline_comment|/* Ensure that this map contains enough ATE&squot;s */
r_if
c_cond
(paren
id|ate_total
OG
id|pcibr_dmamap-&gt;bd_ate_count
)paren
(brace
macro_line|#if PCIBR_ATE_DEBUG
id|PRINT_WARNING
c_func
(paren
l_string|&quot;pcibr_dmamap_list :&bslash;n&quot;
l_string|&quot;&bslash;twanted xio_addr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;tate_total 0x%x bd_ate_count 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tATE&squot;s required &gt; number allocated&bslash;n&quot;
comma
id|xio_addr
comma
id|xio_addr
op_plus
id|length
op_minus
l_int|1
comma
id|ate_total
comma
id|pcibr_dmamap-&gt;bd_ate_count
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|fail
suffix:semicolon
)brace
id|ATE_WRITE
c_func
(paren
)paren
suffix:semicolon
id|ate_index
op_add_assign
id|ate_count
suffix:semicolon
id|ate_ptr
op_add_assign
id|ate_count
suffix:semicolon
id|ate_count
op_lshift_assign
id|IOPFNSHIFT
suffix:semicolon
id|ate
op_add_assign
id|ate_count
suffix:semicolon
id|pci_addr
op_add_assign
id|ate_count
suffix:semicolon
)brace
multiline_comment|/* write the PCI DMA address&n;&t; * out to the scatter-gather list.&n;&t; */
r_if
c_cond
(paren
id|inplace
)paren
(brace
r_if
c_cond
(paren
id|ALENLIST_SUCCESS
op_ne
id|alenlist_replace
c_func
(paren
id|pciio_alenlist
comma
l_int|NULL
comma
op_amp
id|new_addr
comma
op_amp
id|length
comma
id|al_flags
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ALENLIST_SUCCESS
op_ne
id|alenlist_append
c_func
(paren
id|pciio_alenlist
comma
id|new_addr
comma
id|length
comma
id|al_flags
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|inplace
)paren
id|alenlist_done
c_func
(paren
id|xtalk_alenlist
)paren
suffix:semicolon
multiline_comment|/* Reset the internal cursor of the alenlist to be returned back&n;     * to the caller.&n;     */
id|alenlist_cursor_init
c_func
(paren
id|pciio_alenlist
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* In case an ATE_FREEZE was done do the ATE_THAW to unroll all the&n;     * changes that ATE_FREEZE has done to implement the external SSRAM&n;     * bug workaround.&n;     */
r_if
c_cond
(paren
id|ate_freeze_done
)paren
(brace
id|ATE_THAW
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
r_return
id|pciio_alenlist
suffix:semicolon
id|fail
suffix:colon
multiline_comment|/* There are various points of failure after doing an ATE_FREEZE&n;     * We need to do an ATE_THAW. Otherwise the ATEs are locked forever.&n;     * The decision to do an ATE_THAW needs to be based on whether a&n;     * an ATE_FREEZE was done before.&n;     */
r_if
c_cond
(paren
id|ate_freeze_done
)paren
(brace
id|ATE_THAW
c_func
(paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pciio_alenlist
op_logical_and
op_logical_neg
id|inplace
)paren
id|alenlist_destroy
c_func
(paren
id|pciio_alenlist
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_dmamap_done
id|pcibr_dmamap_done
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
multiline_comment|/*&n;     * We could go through and invalidate ATEs here;&n;     * for performance reasons, we don&squot;t.&n;     * We also don&squot;t enforce the strict alternation&n;     * between _addr/_list and _done, but Hub does.&n;     */
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_BUSY
)paren
(brace
id|pcibr_dmamap-&gt;bd_flags
op_and_assign
op_complement
id|PCIBR_DMAMAP_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_dmamap-&gt;bd_flags
op_amp
id|PCIBR_DMAMAP_SSRAM
)paren
id|atomicAddInt
c_func
(paren
op_amp
(paren
id|pcibr_dmamap-&gt;bd_soft
op_member_access_from_pointer
id|bs_slot
(braket
id|pcibr_dmamap-&gt;bd_slot
)braket
dot
id|bss_ext_ates_active
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
id|xtalk_dmamap_done
c_func
(paren
id|pcibr_dmamap-&gt;bd_xtalk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For each bridge, the DIR_OFF value in the Direct Mapping Register&n; * determines the PCI to Crosstalk memory mapping to be used for all&n; * 32-bit Direct Mapping memory accesses. This mapping can be to any&n; * node in the system. This function will return that compact node id.&n; */
multiline_comment|/*ARGSUSED */
id|cnodeid_t
DECL|function|pcibr_get_dmatrans_node
id|pcibr_get_dmatrans_node
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_return
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|NASID_GET
c_func
(paren
id|pcibr_soft-&gt;bs_dir_xbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|iopaddr_t
DECL|function|pcibr_dmatrans_addr
id|pcibr_dmatrans_addr
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|paddr_t
id|paddr
comma
r_int
id|req_size
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|iopaddr_t
id|xio_addr
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
r_int
id|have_rrbs
suffix:semicolon
r_int
id|min_rrbs
suffix:semicolon
multiline_comment|/* merge in forced flags */
id|flags
op_or_assign
id|pcibr_soft-&gt;bs_dma_flags
suffix:semicolon
id|xio_addr
op_assign
id|xtalk_dmatrans_addr
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|paddr
comma
id|req_size
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xio_addr
)paren
(brace
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * find which XIO port this goes to.&n;     */
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
(brace
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
multiline_comment|/*&n;     * If this DMA comes back to us,&n;     * return the PCI MEM address on&n;     * which it would land, or NULL&n;     * if the target is something&n;     * on bridge other than PCI MEM.&n;     */
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|pci_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|req_size
)paren
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
multiline_comment|/* If the caller can use A64, try to&n;     * satisfy the request with the 64-bit&n;     * direct map. This can fail if the&n;     * configuration bits in Device(x)&n;     * conflict with our flags.&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|PCIIO_DMA_A64
)paren
(brace
id|pci_addr
op_assign
id|slotp-&gt;bss_d64_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
)paren
id|flags
op_or_assign
id|PCIBR_VCHAN0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_addr
op_ne
id|PCIBR_D64_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d64_flags
)paren
)paren
(brace
id|pci_addr
op_or_assign
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DMA_DEBUG
macro_line|#if HWG_PERF_CHECK
r_if
c_cond
(paren
id|xio_addr
op_ne
l_int|0x20000000
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr: [reuse]&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tdirect 64bit address is 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D64_BITS
)paren
)paren
(brace
id|pci_addr
op_assign
id|pcibr_flags_to_d64
c_func
(paren
id|flags
comma
id|pcibr_soft
)paren
suffix:semicolon
id|slotp-&gt;bss_d64_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d64_base
op_assign
id|pci_addr
suffix:semicolon
id|pci_addr
op_or_assign
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|pciio_slot
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_VCHAN1
)paren
id|pciio_slot
op_add_assign
id|PCIBR_RRB_SLOT_VIRTUAL
suffix:semicolon
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|pci_addr
op_amp
id|PCI64_ATTR_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
macro_line|#if PCIBR_DMA_DEBUG
macro_line|#if HWG_PERF_CHECK
r_if
c_cond
(paren
id|xio_addr
op_ne
l_int|0x20000000
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tdirect 64bit address is 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tnew flags: 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|pci_addr
comma
(paren
r_uint64
)paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* our flags conflict with Device(x).&n;&t; */
id|flags
op_assign
id|flags
op_amp
op_complement
id|PCIIO_DMA_A64
op_amp
op_complement
id|PCIBR_VCHAN0
suffix:semicolon
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tUnable to set Device(x) bits for Direct-64&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Try to satisfy the request with the 32-bit direct&n;     * map. This can fail if the configuration bits in&n;     * Device(x) conflict with our flags, or if the&n;     * target address is outside where DIR_OFF points.&n;     */
(brace
r_int
id|map_size
op_assign
l_int|1ULL
op_lshift
l_int|31
suffix:semicolon
id|iopaddr_t
id|xio_base
op_assign
id|pcibr_soft-&gt;bs_dir_xbase
suffix:semicolon
id|iopaddr_t
id|offset
op_assign
id|xio_addr
op_minus
id|xio_base
suffix:semicolon
id|iopaddr_t
id|endoff
op_assign
id|req_size
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req_size
OG
id|map_size
)paren
op_logical_or
(paren
id|xio_addr
OL
id|xio_base
)paren
op_logical_or
(paren
id|xio_port
op_ne
id|pcibr_soft-&gt;bs_dir_xport
)paren
op_logical_or
(paren
id|endoff
OG
id|map_size
)paren
)paren
(brace
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;txio region outside direct32 target&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|pci_addr
op_assign
id|slotp-&gt;bss_d32_base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_addr
op_ne
id|PCIBR_D32_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d32_flags
)paren
)paren
(brace
id|pci_addr
op_or_assign
id|offset
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr: [reuse]&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tmapped via direct32 offset 0x%x&bslash;n&quot;
l_string|&quot;&bslash;twill DMA via pci addr 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|offset
comma
id|pci_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D32_BITS
)paren
)paren
(brace
id|pci_addr
op_assign
id|PCI32_DIRECT_BASE
suffix:semicolon
id|slotp-&gt;bss_d32_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|pci_addr
suffix:semicolon
id|pci_addr
op_or_assign
id|offset
suffix:semicolon
multiline_comment|/* Make sure we have an RRB (or two).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcibr_soft-&gt;bs_rrb_fixed
op_amp
(paren
l_int|1
op_lshift
id|pciio_slot
)paren
)paren
)paren
(brace
id|have_rrbs
op_assign
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|pciio_slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|slotp-&gt;bss_device
op_amp
id|BRIDGE_DEV_PREF
)paren
id|min_rrbs
op_assign
l_int|2
suffix:semicolon
r_else
id|min_rrbs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|have_rrbs
OL
id|min_rrbs
)paren
id|do_pcibr_rrb_autoalloc
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|min_rrbs
op_minus
id|have_rrbs
)paren
suffix:semicolon
)brace
)brace
macro_line|#if PCIBR_DMA_DEBUG
macro_line|#if HWG_PERF_CHECK
r_if
c_cond
(paren
id|xio_addr
op_ne
l_int|0x20000000
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tmapped via direct32 offset 0x%x&bslash;n&quot;
l_string|&quot;&bslash;twill DMA via pci addr 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tnew flags: 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
comma
id|offset
comma
id|pci_addr
comma
(paren
r_uint64
)paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|pci_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* our flags conflict with Device(x).&n;&t;     */
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tUnable to set Device(x) bits for Direct-32&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
l_string|&quot;&bslash;tno acceptable PCI address found or constructable&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
id|alenlist_t
DECL|function|pcibr_dmatrans_list
id|pcibr_dmatrans_list
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|alenlist_t
id|palenlist
comma
r_int
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_slot_t
id|slotp
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
suffix:semicolon
id|xwidgetnum_t
id|xio_port
suffix:semicolon
id|alenlist_t
id|pciio_alenlist
op_assign
l_int|0
suffix:semicolon
id|alenlist_t
id|xtalk_alenlist
op_assign
l_int|0
suffix:semicolon
r_int
id|inplace
suffix:semicolon
r_int
id|direct64
suffix:semicolon
r_int
id|al_flags
suffix:semicolon
id|iopaddr_t
id|xio_base
suffix:semicolon
id|alenaddr_t
id|xio_addr
suffix:semicolon
r_int
id|xio_size
suffix:semicolon
r_int
id|map_size
suffix:semicolon
id|iopaddr_t
id|pci_base
suffix:semicolon
id|alenaddr_t
id|pci_addr
suffix:semicolon
r_int
id|relbits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* merge in forced flags */
id|flags
op_or_assign
id|pcibr_soft-&gt;bs_dma_flags
suffix:semicolon
id|inplace
op_assign
id|flags
op_amp
id|PCIIO_INPLACE
suffix:semicolon
id|direct64
op_assign
id|flags
op_amp
id|PCIIO_DMA_A64
suffix:semicolon
id|al_flags
op_assign
(paren
id|flags
op_amp
id|PCIIO_NOSLEEP
)paren
ques
c_cond
id|AL_NOSLEEP
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|direct64
)paren
(brace
id|map_size
op_assign
l_int|1ull
op_lshift
l_int|48
suffix:semicolon
id|xio_base
op_assign
l_int|0
suffix:semicolon
id|pci_base
op_assign
id|slotp-&gt;bss_d64_base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_base
op_ne
id|PCIBR_D64_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d64_flags
)paren
)paren
(brace
multiline_comment|/* reuse previous base info */
)brace
r_else
r_if
c_cond
(paren
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D64_BITS
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* DMA configuration conflict */
r_goto
id|fail
suffix:semicolon
)brace
r_else
(brace
id|relbits
op_assign
id|BRIDGE_DEV_D64_BITS
suffix:semicolon
id|pci_base
op_assign
id|pcibr_flags_to_d64
c_func
(paren
id|flags
comma
id|pcibr_soft
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xio_base
op_assign
id|pcibr_soft-&gt;bs_dir_xbase
suffix:semicolon
id|map_size
op_assign
l_int|1ull
op_lshift
l_int|31
suffix:semicolon
id|pci_base
op_assign
id|slotp-&gt;bss_d32_base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_base
op_ne
id|PCIBR_D32_BASE_UNSET
)paren
op_logical_and
(paren
id|flags
op_eq
id|slotp-&gt;bss_d32_flags
)paren
)paren
(brace
multiline_comment|/* reuse previous base info */
)brace
r_else
r_if
c_cond
(paren
id|pcibr_try_set_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|flags
comma
id|BRIDGE_DEV_D32_BITS
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* DMA configuration conflict */
r_goto
id|fail
suffix:semicolon
)brace
r_else
(brace
id|relbits
op_assign
id|BRIDGE_DEV_D32_BITS
suffix:semicolon
id|pci_base
op_assign
id|PCI32_DIRECT_BASE
suffix:semicolon
)brace
)brace
id|xtalk_alenlist
op_assign
id|xtalk_dmatrans_list
c_func
(paren
id|xconn_vhdl
comma
l_int|0
comma
id|palenlist
comma
id|flags
op_amp
id|DMAMAP_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xtalk_alenlist
)paren
r_goto
id|fail
suffix:semicolon
id|alenlist_cursor_init
c_func
(paren
id|xtalk_alenlist
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inplace
)paren
(brace
id|pciio_alenlist
op_assign
id|xtalk_alenlist
suffix:semicolon
)brace
r_else
(brace
id|pciio_alenlist
op_assign
id|alenlist_create
c_func
(paren
id|al_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pciio_alenlist
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ALENLIST_SUCCESS
op_eq
id|alenlist_get
c_func
(paren
id|xtalk_alenlist
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|xio_addr
comma
op_amp
id|xio_size
comma
id|al_flags
)paren
)paren
(brace
multiline_comment|/*&n;&t; * find which XIO port this goes to.&n;&t; */
r_if
c_cond
(paren
id|XIO_PACKED
c_func
(paren
id|xio_addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|xio_addr
op_eq
id|XIO_NOWHERE
)paren
(brace
macro_line|#if PCIBR_DMA_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_dmatrans_addr:&bslash;n&quot;
l_string|&quot;&bslash;tpciio connection point %v&bslash;n&quot;
l_string|&quot;&bslash;txtalk connection point %v&bslash;n&quot;
l_string|&quot;&bslash;twanted paddr [0x%x..0x%x]&bslash;n&quot;
l_string|&quot;&bslash;txtalk_dmatrans_addr returned 0x%x&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|xconn_vhdl
comma
id|paddr
comma
id|paddr
op_plus
id|req_size
op_minus
l_int|1
comma
id|xio_addr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|xio_port
op_assign
id|XIO_PORT
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|xio_addr
op_assign
id|XIO_ADDR
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
)brace
r_else
id|xio_port
op_assign
id|pcibr_soft-&gt;bs_mxid
suffix:semicolon
multiline_comment|/*&n;&t; * If this DMA comes back to us,&n;&t; * return the PCI MEM address on&n;&t; * which it would land, or NULL&n;&t; * if the target is something&n;&t; * on bridge other than PCI MEM.&n;&t; */
r_if
c_cond
(paren
id|xio_port
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
(brace
id|pci_addr
op_assign
id|pcibr_addr_xio_to_pci
c_func
(paren
id|pcibr_soft
comma
id|xio_addr
comma
id|xio_size
)paren
suffix:semicolon
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|pci_addr
op_eq
l_int|NULL
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|pci_addr
op_eq
(paren
id|alenaddr_t
)paren
l_int|NULL
)paren
)paren
macro_line|#endif
r_goto
id|fail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|direct64
)paren
(brace
id|ASSERT
c_func
(paren
id|xio_port
op_ne
l_int|0
)paren
suffix:semicolon
id|pci_addr
op_assign
id|pci_base
op_or
id|xio_addr
op_or
(paren
(paren
r_uint64
)paren
id|xio_port
op_lshift
id|PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
)brace
r_else
(brace
id|iopaddr_t
id|offset
op_assign
id|xio_addr
op_minus
id|xio_base
suffix:semicolon
id|iopaddr_t
id|endoff
op_assign
id|xio_size
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xio_size
OG
id|map_size
)paren
op_logical_or
(paren
id|xio_addr
OL
id|xio_base
)paren
op_logical_or
(paren
id|xio_port
op_ne
id|pcibr_soft-&gt;bs_dir_xport
)paren
op_logical_or
(paren
id|endoff
OG
id|map_size
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|pci_addr
op_assign
id|pci_base
op_plus
(paren
id|xio_addr
op_minus
id|xio_base
)paren
suffix:semicolon
)brace
multiline_comment|/* write the PCI DMA address&n;&t; * out to the scatter-gather list.&n;&t; */
r_if
c_cond
(paren
id|inplace
)paren
(brace
r_if
c_cond
(paren
id|ALENLIST_SUCCESS
op_ne
id|alenlist_replace
c_func
(paren
id|pciio_alenlist
comma
l_int|NULL
comma
op_amp
id|pci_addr
comma
op_amp
id|xio_size
comma
id|al_flags
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ALENLIST_SUCCESS
op_ne
id|alenlist_append
c_func
(paren
id|pciio_alenlist
comma
id|pci_addr
comma
id|xio_size
comma
id|al_flags
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
)brace
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|relbits
)paren
macro_line|#else
r_if
c_cond
(paren
id|relbits
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
id|direct64
)paren
(brace
id|slotp-&gt;bss_d64_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d64_base
op_assign
id|pci_base
suffix:semicolon
)brace
r_else
(brace
id|slotp-&gt;bss_d32_flags
op_assign
id|flags
suffix:semicolon
id|slotp-&gt;bss_d32_base
op_assign
id|pci_base
suffix:semicolon
)brace
macro_line|#ifndef IRIX
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|inplace
)paren
id|alenlist_done
c_func
(paren
id|xtalk_alenlist
)paren
suffix:semicolon
multiline_comment|/* Reset the internal cursor of the alenlist to be returned back&n;     * to the caller.&n;     */
id|alenlist_cursor_init
c_func
(paren
id|pciio_alenlist
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|pciio_alenlist
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|relbits
)paren
id|pcibr_release_device
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|relbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciio_alenlist
op_logical_and
op_logical_neg
id|inplace
)paren
id|alenlist_destroy
c_func
(paren
id|pciio_alenlist
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmamap_drain
id|pcibr_dmamap_drain
c_func
(paren
id|pcibr_dmamap_t
id|map
)paren
(brace
id|xtalk_dmamap_drain
c_func
(paren
id|map-&gt;bd_xtalk
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmaaddr_drain
id|pcibr_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|paddr_t
id|paddr
comma
r_int
id|bytes
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|xtalk_dmaaddr_drain
c_func
(paren
id|xconn_vhdl
comma
id|paddr
comma
id|bytes
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_dmalist_drain
id|pcibr_dmalist_drain
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|alenlist_t
id|list
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|xtalk_dmalist_drain
c_func
(paren
id|xconn_vhdl
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the starting PCIbus address out of the given DMA map.&n; * This function is supposed to be used by a close friend of PCI bridge&n; * since it relies on the fact that the starting address of the map is fixed at&n; * the allocation time in the current implementation of PCI bridge.&n; */
id|iopaddr_t
DECL|function|pcibr_dmamap_pciaddr_get
id|pcibr_dmamap_pciaddr_get
c_func
(paren
id|pcibr_dmamap_t
id|pcibr_dmamap
)paren
(brace
r_return
(paren
id|pcibr_dmamap-&gt;bd_pci_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    INTERRUPT MANAGEMENT&n; */
r_static
r_int
DECL|function|pcibr_intr_bits
id|pcibr_intr_bits
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
)paren
(brace
id|pciio_slot_t
id|slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|info
)paren
suffix:semicolon
r_int
id|bbits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Currently favored mapping from PCI&n;     * slot number and INTA/B/C/D to Bridge&n;     * PCI Interrupt Bit Number:&n;     *&n;     *     SLOT     A B C D&n;     *      0       0 4 0 4&n;     *      1       1 5 1 5&n;     *      2       2 6 2 6&n;     *      3       3 7 3 7&n;     *      4       4 0 4 0&n;     *      5       5 1 5 1&n;     *      6       6 2 6 2&n;     *      7       7 3 7 3&n;     */
r_if
c_cond
(paren
id|slot
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_A
op_or
id|PCIIO_INTR_LINE_C
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|lines
op_amp
(paren
id|PCIIO_INTR_LINE_B
op_or
id|PCIIO_INTR_LINE_D
)paren
)paren
id|bbits
op_or_assign
l_int|1
op_lshift
(paren
id|slot
op_xor
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|bbits
suffix:semicolon
)brace
macro_line|#ifdef IRIX
multiline_comment|/* Wrapper for pcibr interrupt threads. */
r_static
r_void
DECL|function|pcibr_intrd
id|pcibr_intrd
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
(brace
multiline_comment|/* Called on each restart */
id|ASSERT
c_func
(paren
id|cpuid
c_func
(paren
)paren
op_eq
id|intr-&gt;bi_mustruncpu
)paren
suffix:semicolon
macro_line|#ifdef ITHREAD_LATENCY
id|xthread_update_latstats
c_func
(paren
id|intr-&gt;bi_tinfo-&gt;thd_latstats
)paren
suffix:semicolon
macro_line|#endif /* ITHREAD_LATENCY */
id|ASSERT
c_func
(paren
id|intr-&gt;bi_func
op_ne
l_int|NULL
)paren
suffix:semicolon
id|intr
op_member_access_from_pointer
id|bi_func
c_func
(paren
id|intr-&gt;bi_arg
)paren
suffix:semicolon
multiline_comment|/* Invoke the interrupt handler */
id|ipsema
c_func
(paren
op_amp
id|intr-&gt;bi_tinfo.thd_isync
)paren
suffix:semicolon
multiline_comment|/* Sleep &squot;till next interrupt */
multiline_comment|/* NOTREACHED */
)brace
r_static
r_void
DECL|function|pcibr_intrd_start
id|pcibr_intrd_start
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
(brace
id|ASSERT
c_func
(paren
id|intr-&gt;bi_mustruncpu
op_ge
l_int|0
)paren
suffix:semicolon
id|setmustrun
c_func
(paren
id|intr-&gt;bi_mustruncpu
)paren
suffix:semicolon
id|xthread_set_func
c_func
(paren
id|KT_TO_XT
c_func
(paren
id|curthreadp
)paren
comma
(paren
id|xt_func_t
op_star
)paren
id|pcibr_intrd
comma
(paren
r_void
op_star
)paren
id|intr
)paren
suffix:semicolon
id|atomicSetInt
c_func
(paren
op_amp
id|intr-&gt;bi_tinfo.thd_flags
comma
id|THD_INIT
)paren
suffix:semicolon
id|ipsema
c_func
(paren
op_amp
id|intr-&gt;bi_tinfo.thd_isync
)paren
suffix:semicolon
multiline_comment|/* Comes out in pcibr_intrd */
multiline_comment|/* NOTREACHED */
)brace
r_static
r_void
DECL|function|pcibr_thread_setup
id|pcibr_thread_setup
c_func
(paren
id|pcibr_intr_t
id|intr
comma
r_int
id|bridge_levels
comma
id|ilvl_t
id|intr_swlevel
)paren
(brace
r_char
id|thread_name
(braket
l_int|32
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|thread_name
comma
l_string|&quot;pcibr_intrd[0x%x]&quot;
comma
id|bridge_levels
)paren
suffix:semicolon
multiline_comment|/* XXX need to adjust priority whenever an interrupt is connected */
id|atomicSetInt
c_func
(paren
op_amp
id|intr-&gt;bi_tinfo.thd_flags
comma
id|THD_ISTHREAD
op_or
id|THD_REG
)paren
suffix:semicolon
id|xthread_setup
c_func
(paren
id|thread_name
comma
id|intr_swlevel
comma
op_amp
id|intr-&gt;bi_tinfo
comma
(paren
id|xt_func_t
op_star
)paren
id|pcibr_intrd_start
comma
(paren
r_void
op_star
)paren
id|intr
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* IRIX */
multiline_comment|/*ARGSUSED */
id|pcibr_intr_t
DECL|function|pcibr_intr_alloc
id|pcibr_intr_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_intr_line_t
id|lines
comma
id|devfs_handle_t
id|owner_dev
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pcibr_info-&gt;f_slot
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pcibr_info-&gt;f_mfast
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|is_threaded
suffix:semicolon
r_int
id|thread_swlevel
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intr_p
suffix:semicolon
id|pcibr_intr_t
op_star
id|pcibr_intr_p
suffix:semicolon
id|pcibr_intr_list_t
op_star
id|intr_list_p
suffix:semicolon
id|pcibr_intr_wrap_t
op_star
id|intr_wrap_p
suffix:semicolon
r_int
id|pcibr_int_bits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
op_assign
(paren
id|xtalk_intr_t
)paren
l_int|0
suffix:semicolon
id|hub_intr_t
id|hub_intr
suffix:semicolon
id|pcibr_intr_t
id|pcibr_intr
suffix:semicolon
id|pcibr_intr_list_t
id|intr_entry
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pcibr_intr_alloc&bslash;n&quot;
l_string|&quot;%v:%s%s%s%s%s&bslash;n&quot;
comma
id|owner_dev
comma
id|pconn_vhdl
comma
op_logical_neg
(paren
id|lines
op_amp
l_int|15
)paren
ques
c_cond
l_string|&quot; No INTs?&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|1
ques
c_cond
l_string|&quot; INTA&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|2
ques
c_cond
l_string|&quot; INTB&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|4
ques
c_cond
l_string|&quot; INTC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lines
op_amp
l_int|8
ques
c_cond
l_string|&quot; INTD&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NEW
c_func
(paren
id|pcibr_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_intr
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev_desc
)paren
(brace
id|is_threaded
op_assign
op_logical_neg
(paren
id|device_desc_flags_get
c_func
(paren
id|dev_desc
)paren
op_amp
id|D_INTR_NOTHREAD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_threaded
)paren
id|thread_swlevel
op_assign
id|device_desc_intr_swlevel_get
c_func
(paren
id|dev_desc
)paren
suffix:semicolon
)brace
r_else
(brace
r_extern
r_int
id|default_intr_pri
suffix:semicolon
id|is_threaded
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* PCI interrupts are threaded, by default */
id|thread_swlevel
op_assign
id|default_intr_pri
suffix:semicolon
)brace
id|pcibr_intr-&gt;bi_dev
op_assign
id|pconn_vhdl
suffix:semicolon
id|pcibr_intr-&gt;bi_lines
op_assign
id|lines
suffix:semicolon
id|pcibr_intr-&gt;bi_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|pcibr_intr-&gt;bi_ibits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bits will be added below */
id|pcibr_intr-&gt;bi_func
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unset until connect */
id|pcibr_intr-&gt;bi_arg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unset until connect */
id|pcibr_intr-&gt;bi_flags
op_assign
id|is_threaded
ques
c_cond
l_int|0
suffix:colon
id|PCIIO_INTR_NOTHREAD
suffix:semicolon
id|pcibr_intr-&gt;bi_mustruncpu
op_assign
id|CPU_NONE
suffix:semicolon
id|pcibr_int_bits
op_assign
id|pcibr_soft
op_member_access_from_pointer
id|bs_intr_bits
c_func
(paren
(paren
id|pciio_info_t
)paren
id|pcibr_info
comma
id|lines
)paren
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_int_bits: 0x%X&bslash;n&quot;
comma
id|pcibr_int_bits
)paren
suffix:semicolon
macro_line|#endif 
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|xtalk_intr_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This xtalk_intr_alloc is constrained for two reasons:&n;&t;&t; * 1) Normal interrupts and error interrupts need to be delivered&n;&t;&t; *    through a single xtalk target widget so that there aren&squot;t any&n;&t;&t; *    ordering problems with DMA, completion interrupts, and error&n;&t;&t; *    interrupts. (Use of xconn_vhdl forces this.)&n;&t;&t; *&n;&t;&t; * 2) On IP35, addressing constraints on IP35 and Bridge force&n;&t;&t; *    us to use a single PI number for all interrupts from a&n;&t;&t; *    single Bridge. (IP35-specific code forces this, and we&n;&t;&t; *    verify in pcibr_setwidint.)&n;&t;&t; */
id|xtalk_intr
op_assign
id|xtalk_intr_alloc
c_func
(paren
id|xconn_vhdl
comma
id|dev_desc
comma
id|owner_dev
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: xtalk_intr=0x%X&bslash;n&quot;
comma
id|xconn_vhdl
comma
id|xtalk_intr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* both an assert and a runtime check on this:&n;&t;&t; * we need to check in non-DEBUG kernels, and&n;&t;&t; * the ASSERT gets us more information when&n;&t;&t; * we use DEBUG kernels.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|xtalk_intr
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtalk_intr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* it is quite possible that our&n;&t;&t;     * xtalk_intr_alloc failed because&n;&t;&t;     * someone else got there first,&n;&t;&t;     * and we can find their results&n;&t;&t;     * in xtalk_intr_p.&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
op_star
id|xtalk_intr_p
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_ALERT
c_func
(paren
l_string|&quot;pcibr_intr_alloc %v: unable to get xtalk interrupt resources&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|xtalk_intr_p
comma
l_int|NULL
comma
id|xtalk_intr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;     * now tell the bridge which slot is&n;&t;&t;     * using this interrupt line.&n;&t;&t;     */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|int_dev
op_or_assign
id|pciio_slot
op_lshift
id|BRIDGE_INT_DEV_SHFT
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
multiline_comment|/* XXXMP */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: bridge intr bit %d clears my wrb&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* someone else got one allocated first;&n;&t;&t;     * free the one we just created, and&n;&t;&t;     * retrieve the one they allocated.&n;&t;&t;     */
id|xtalk_intr_free
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|xtalk_intr
op_assign
op_star
id|xtalk_intr_p
suffix:semicolon
macro_line|#if PARANOID
multiline_comment|/* once xtalk_intr is set, we never clear it,&n;&t;&t;     * so if the CAS fails above, this condition&n;&t;&t;     * can &quot;never happen&quot; ...&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|xtalk_intr
)paren
(brace
id|PRINT_ALERT
c_func
(paren
l_string|&quot;pcibr_intr_alloc %v: unable to set xtalk interrupt resources&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
multiline_comment|/* yes, we leak resources here. */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;&t;     * For threaded drivers, set the interrupt thread to run wherever&n;&t;     * the interrupt is targeted.&n;&t;     */
macro_line|#ifdef notyet
r_if
c_cond
(paren
id|is_threaded
)paren
(brace
id|cpuid_t
id|old_mustrun
op_assign
id|pcibr_intr-&gt;bi_mustruncpu
suffix:semicolon
id|pcibr_intr-&gt;bi_mustruncpu
op_assign
id|cpuvertex_to_cpuid
c_func
(paren
id|xtalk_intr_cpu_get
c_func
(paren
id|xtalk_intr
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pcibr_intr-&gt;bi_mustruncpu
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is possible, but very unlikely: It means that 2 (or more) interrupts&n;&t;&t; * originating on a single Bridge and used by a single device were unable to&n;&t;&t; * find sufficient xtalk interrupt resources that would allow them all to be&n;&t;&t; * handled by the same CPU.  If someone tries to target lots of interrupts to&n;&t;&t; * a single CPU, we might hit this case.  Things should still operate correctly,&n;&t;&t; * but it&squot;s a sub-optimal configuration.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|old_mustrun
op_ne
id|CPU_NONE
)paren
op_logical_and
(paren
id|old_mustrun
op_ne
id|pcibr_intr-&gt;bi_mustruncpu
)paren
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Conflict on where to schedule interrupts for %v&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
id|PRINT_WARNING
c_func
(paren
l_string|&quot;(on cpu %d or on cpu %d)&bslash;n&quot;
comma
id|old_mustrun
comma
id|pcibr_intr-&gt;bi_mustruncpu
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|pcibr_intr-&gt;bi_ibits
op_or_assign
l_int|1
op_lshift
id|pcibr_int_bit
suffix:semicolon
id|NEW
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
id|intr_entry-&gt;il_next
op_assign
l_int|NULL
suffix:semicolon
id|intr_entry-&gt;il_intr
op_assign
id|pcibr_intr
suffix:semicolon
id|intr_entry-&gt;il_wrbf
op_assign
op_amp
(paren
id|bridge-&gt;b_wr_req_buf
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
id|intr_list_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_list
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the first interrupt on this bridge bit.&n;&t;&t; */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) allocated [FIRST]&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* first entry on list was erased,&n;&t;&t; * and we replaced it, so we&n;&t;&t; * don&squot;t need our intr_entry.&n;&t;&t; */
id|DEL
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) replaces erased first&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* we are the new second interrupt on this bit.&n;&t;&t; * switch to local wrapper.&n;&t;&t; */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) is new SECOND&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
id|NEW
c_func
(paren
id|intr_wrap
)paren
suffix:semicolon
id|intr_wrap-&gt;iw_soft
op_assign
id|pcibr_soft
suffix:semicolon
id|intr_wrap-&gt;iw_stat
op_assign
op_amp
(paren
id|bridge-&gt;b_int_status
)paren
suffix:semicolon
id|intr_wrap-&gt;iw_intr
op_assign
l_int|1
op_lshift
id|pcibr_int_bit
suffix:semicolon
id|intr_wrap-&gt;iw_list
op_assign
id|intr_list
suffix:semicolon
id|intr_wrap_p
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_wrap_p
comma
l_int|NULL
comma
id|intr_wrap
)paren
)paren
(brace
multiline_comment|/* someone else set up the wrapper.&n;&t;&t;     */
id|DEL
c_func
(paren
id|intr_wrap
)paren
suffix:semicolon
r_continue
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%v bridge bit %d wrapper state created&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|pcibr_intr_p
op_assign
op_amp
id|intr_list-&gt;il_intr
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|pcibr_intr_p
comma
l_int|NULL
comma
id|pcibr_intr
)paren
)paren
(brace
multiline_comment|/* an entry on list was erased,&n;&t;&t;     * and we replaced it, so we&n;&t;&t;     * don&squot;t need our intr_entry.&n;&t;&t;     */
id|DEL
c_func
(paren
id|intr_entry
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) replaces erased Nth&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|intr_list_p
op_assign
op_amp
id|intr_list-&gt;il_next
suffix:semicolon
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
id|intr_list_p
comma
l_int|NULL
comma
id|intr_entry
)paren
)paren
(brace
multiline_comment|/* entry appended to share list&n;&t;&t;     */
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v INT 0x%x (bridge bit %d) is new Nth&bslash;n&quot;
comma
id|pconn_vhdl
comma
id|pcibr_int_bits
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* step to next record in chain&n;&t;&t; */
id|intr_list
op_assign
op_star
id|intr_list_p
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|is_threaded
)paren
(brace
multiline_comment|/* Set pcibr_intr-&gt;bi_tinfo */
id|pcibr_thread_setup
c_func
(paren
id|pcibr_intr
comma
id|pcibr_int_bits
comma
id|thread_swlevel
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|pcibr_intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_CONNECTED
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v pcibr_intr_alloc complete&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
id|hub_intr
op_assign
(paren
id|hub_intr_t
)paren
id|xtalk_intr
suffix:semicolon
id|pcibr_intr-&gt;bi_irq
op_assign
id|hub_intr-&gt;i_bit
suffix:semicolon
id|pcibr_intr-&gt;bi_cpu
op_assign
id|hub_intr-&gt;i_cpuid
suffix:semicolon
r_return
id|pcibr_intr
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_free
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|pcibr_intr_list_t
id|intr_list
suffix:semicolon
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
id|xtalk_intr_t
op_star
id|xtalk_intrp
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
r_for
c_loop
(paren
id|intr_list
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_list
suffix:semicolon
id|intr_list
op_ne
l_int|NULL
suffix:semicolon
id|intr_list
op_assign
id|intr_list-&gt;il_next
)paren
r_if
c_cond
(paren
id|compare_and_swap_ptr
c_func
(paren
(paren
r_void
op_star
op_star
)paren
op_amp
id|intr_list-&gt;il_intr
comma
id|pcibr_intr
comma
l_int|NULL
)paren
)paren
(brace
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: cleared a handler from bit %d&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* If this interrupt line is not being shared between multiple&n;&t;     * devices release the xtalk interrupt resources.&n;&t;     */
id|intr_wrap
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
id|xtalk_intrp
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|intr_wrap
op_eq
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|xtalk_intrp
)paren
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|int_dev
suffix:semicolon
id|xtalk_intr_free
c_func
(paren
op_star
id|xtalk_intrp
)paren
suffix:semicolon
op_star
id|xtalk_intrp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the PCI device interrupt to bridge interrupt pin&n;&t;&t; * mapping.&n;&t;&t; */
id|int_dev
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|int_dev
op_and_assign
op_complement
id|BRIDGE_INT_DEV_MASK
c_func
(paren
id|pcibr_int_bit
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|int_dev
suffix:semicolon
)brace
)brace
)brace
id|DEL
c_func
(paren
id|pcibr_intr
)paren
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|pcibr_setpciint
id|pcibr_setpciint
c_func
(paren
id|xtalk_intr_t
id|xtalk_intr
)paren
(brace
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
id|bridgereg_t
op_star
id|int_addr
op_assign
(paren
id|bridgereg_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
op_star
id|int_addr
op_assign
(paren
(paren
id|BRIDGE_INT_ADDR_HOST
op_amp
(paren
id|addr
op_rshift
l_int|30
)paren
)paren
op_or
(paren
id|BRIDGE_INT_ADDR_FLD
op_amp
id|vect
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_intr_connect
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
comma
id|intr_func_t
id|intr_func
comma
id|intr_arg_t
id|intr_arg
comma
r_void
op_star
id|thread
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_intr
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v: pcibr_intr_connect 0x%X(0x%X)&bslash;n&quot;
comma
id|pcibr_intr-&gt;bi_dev
comma
id|intr_func
comma
id|intr_arg
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_intr-&gt;bi_func
op_assign
id|intr_func
suffix:semicolon
id|pcibr_intr-&gt;bi_arg
op_assign
id|intr_arg
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_or_assign
id|PCIIO_INTR_CONNECTED
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and make sure there are xtalk resources&n;     * allocated for it.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
id|xtalk_intr_t
id|xtalk_intr
suffix:semicolon
r_int
op_star
id|setptr
suffix:semicolon
id|xtalk_intr
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
suffix:semicolon
multiline_comment|/* if we have no wrap structure,&n;&t;     * tell xtalk to deliver the interrupt&n;&t;     * directly to the client.&n;&t;     */
id|intr_wrap
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
r_if
c_cond
(paren
id|intr_wrap
op_eq
l_int|NULL
)paren
(brace
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
(paren
id|intr_func_t
)paren
id|intr_func
comma
(paren
id|intr_arg_t
)paren
id|intr_arg
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;b_int_addr
(braket
id|pcibr_int_bit
)braket
dot
id|addr
)paren
comma
id|thread
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v bridge bit %d routed by xtalk&bslash;n&quot;
comma
id|pcibr_intr-&gt;bi_dev
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
id|setptr
op_assign
op_amp
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_wrap_set
suffix:semicolon
r_if
c_cond
(paren
op_star
id|setptr
)paren
r_continue
suffix:semicolon
multiline_comment|/* We have a wrap structure, so we&squot;re sharing a Bridge interrupt level */
id|xtalk_intr_disconnect
c_func
(paren
id|xtalk_intr
)paren
suffix:semicolon
multiline_comment|/* Disconnect old interrupt */
multiline_comment|/*&n;&t;&t;If the existing xtalk_intr was allocated without the NOTHREAD flag,&n;&t;&t;we need to allocate a new one that&squot;s NOTHREAD, and connect to the&n;&t;&t;new one.   pcibr_intr_list_func expects to run at interrupt level&n;&t;&t;rather than in a thread.  With today&squot;s devices, this can&squot;t happen,&n;&t;&t;so let&squot;s punt on writing the code till we need it (probably never).&n;&t;&t;Instead, just ASSERT that we&squot;re a NOTHREAD xtalk_intr.&n;&t;    */
macro_line|#ifdef IRIX
id|ASSERT_ALWAYS
c_func
(paren
op_logical_neg
(paren
id|pcibr_intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_NOTHREAD
)paren
op_logical_or
id|xtalk_intr_flags_get
c_func
(paren
id|xtalk_intr
)paren
op_amp
id|XTALK_INTR_NOTHREAD
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Use the wrapper dispatch function to handle shared Bridge interrupts */
id|xtalk_intr_connect
c_func
(paren
id|xtalk_intr
comma
id|pcibr_intr_list_func
comma
(paren
id|intr_arg_t
)paren
id|intr_wrap
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;b_int_addr
(braket
id|pcibr_int_bit
)braket
dot
id|addr
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|setptr
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; INTR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%v bridge bit %d wrapper connected&bslash;n&quot;
comma
id|pcibr_intr-&gt;bi_dev
comma
id|pcibr_int_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_or_assign
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_intr_disconnect
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
id|pcibr_intr_wrap_t
id|intr_wrap
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/* Stop calling the function. Now.&n;     */
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
op_amp
id|pcibr_intr-&gt;bi_flags
)paren
op_and_assign
op_complement
id|PCIIO_INTR_CONNECTED
suffix:semicolon
id|pcibr_intr-&gt;bi_func
op_assign
l_int|0
suffix:semicolon
id|pcibr_intr-&gt;bi_arg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * For each PCI interrupt line requested, figure&n;     * out which Bridge PCI Interrupt Line it maps&n;     * to, and disconnect the interrupt.&n;     */
multiline_comment|/* don&squot;t disable interrupts for lines that&n;     * are shared between devices.&n;     */
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
op_logical_and
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_wrap_set
)paren
)paren
id|pcibr_int_bits
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_int_bits
)paren
r_return
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_and_assign
op_complement
id|pcibr_int_bits
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
(brace
multiline_comment|/* if we have set up the share wrapper,&n;&t;     * do not disconnect it.&n;&t;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_wrap_set
)paren
r_continue
suffix:semicolon
id|xtalk_intr_disconnect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
multiline_comment|/* if we have a share wrapper state,&n;&t;     * connect us up; this closes the hole&n;&t;     * where the connection of the wrapper&n;&t;     * was in progress as we disconnected.&n;&t;     */
id|intr_wrap
op_assign
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_pcibr_intr_wrap
suffix:semicolon
r_if
c_cond
(paren
id|intr_wrap
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|xtalk_intr_connect
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
comma
id|pcibr_intr_list_func
comma
(paren
id|intr_arg_t
)paren
id|intr_wrap
comma
(paren
id|xtalk_intr_setfunc_t
)paren
id|pcibr_setpciint
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|bridge-&gt;b_int_addr
(braket
id|pcibr_int_bit
)braket
dot
id|addr
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*ARGSUSED */
id|devfs_handle_t
DECL|function|pcibr_intr_cpu_get
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
id|pcibr_intr
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|pcibr_intr-&gt;bi_soft
suffix:semicolon
r_int
id|pcibr_int_bits
op_assign
id|pcibr_intr-&gt;bi_ibits
suffix:semicolon
r_int
id|pcibr_int_bit
suffix:semicolon
r_for
c_loop
(paren
id|pcibr_int_bit
op_assign
l_int|0
suffix:semicolon
id|pcibr_int_bit
OL
l_int|8
suffix:semicolon
id|pcibr_int_bit
op_increment
)paren
r_if
c_cond
(paren
id|pcibr_int_bits
op_amp
(paren
l_int|1
op_lshift
id|pcibr_int_bit
)paren
)paren
r_return
id|xtalk_intr_cpu_get
c_func
(paren
id|pcibr_soft-&gt;bs_intr
(braket
id|pcibr_int_bit
)braket
dot
id|bsi_xtalk_intr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    INTERRUPT HANDLING&n; */
id|LOCAL
r_void
DECL|function|pcibr_clearwidint
id|pcibr_clearwidint
c_func
(paren
id|bridge_t
op_star
id|bridge
)paren
(brace
id|bridge-&gt;b_wid_int_upper
op_assign
l_int|0
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
l_int|0
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|pcibr_setwidint
id|pcibr_setwidint
c_func
(paren
id|xtalk_intr_t
id|intr
)paren
(brace
id|xwidgetnum_t
id|targ
op_assign
id|xtalk_intr_target_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|iopaddr_t
id|addr
op_assign
id|xtalk_intr_addr_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|xtalk_intr_vector_t
id|vect
op_assign
id|xtalk_intr_vector_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|widgetreg_t
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
suffix:semicolon
id|widgetreg_t
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|xtalk_intr_sfarg_get
c_func
(paren
id|intr
)paren
suffix:semicolon
id|NEW_b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|NEW_b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|OLD_b_wid_int_upper
op_assign
id|bridge-&gt;b_wid_int_upper
suffix:semicolon
id|OLD_b_wid_int_lower
op_assign
id|bridge-&gt;b_wid_int_lower
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IP35) || defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_GENERIC)
multiline_comment|/* Verify that all interrupts from this Bridge are using a single PI */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
l_int|0
)paren
op_logical_and
(paren
id|OLD_b_wid_int_lower
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Once set, these registers shouldn&squot;t change; they should&n;&t; * be set multiple times with the same values.&n;&t; *&n;&t; * If we&squot;re attempting to change these registers, it means&n;&t; * that our heuristics for allocating interrupts in a way&n;&t; * appropriate for IP35 have failed, and the admin needs to&n;&t; * explicitly direct some interrupts (or we need to make the&n;&t; * heuristics more clever).&n;&t; *&n;&t; * In practice, we hope this doesn&squot;t happen very often, if&n;&t; * at all.&n;&t; */
r_if
c_cond
(paren
(paren
id|OLD_b_wid_int_upper
op_ne
id|NEW_b_wid_int_upper
)paren
op_logical_or
(paren
id|OLD_b_wid_int_lower
op_ne
id|NEW_b_wid_int_lower
)paren
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Interrupt allocation is too complex.&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;Use explicit administrative interrupt targetting.&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;bridge=0x%lx targ=0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bridge
comma
id|targ
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;NEW=0x%x/0x%x  OLD=0x%x/0x%x&bslash;n&quot;
comma
id|NEW_b_wid_int_upper
comma
id|NEW_b_wid_int_lower
comma
id|OLD_b_wid_int_upper
comma
id|OLD_b_wid_int_lower
)paren
suffix:semicolon
id|PRINT_PANIC
c_func
(paren
l_string|&quot;PCI Bridge interrupt targetting error&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SGI_IP35 */
id|bridge-&gt;b_wid_int_upper
op_assign
id|NEW_b_wid_int_upper
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|NEW_b_wid_int_lower
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_intr_preset: called during mlreset time&n; * if the platform specific code needs to route&n; * one of the Bridge&squot;s xtalk interrupts before the&n; * xtalk infrastructure is available.&n; */
r_void
DECL|function|pcibr_xintr_preset
id|pcibr_xintr_preset
c_func
(paren
r_void
op_star
id|which_widget
comma
r_int
id|which_widget_intr
comma
id|xwidgetnum_t
id|targ
comma
id|iopaddr_t
id|addr
comma
id|xtalk_intr_vector_t
id|vect
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|which_widget
suffix:semicolon
r_if
c_cond
(paren
id|which_widget_intr
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* bridge widget error interrupt */
id|bridge-&gt;b_wid_int_upper
op_assign
(paren
(paren
l_int|0x000F0000
op_amp
(paren
id|targ
op_lshift
l_int|16
)paren
)paren
op_or
id|XTALK_ADDR_TO_UPPER
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_wid_int_lower
op_assign
id|XTALK_ADDR_TO_LOWER
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bridge-&gt;b_int_host_err
op_assign
id|vect
suffix:semicolon
multiline_comment|/* turn on all interrupts except&n;&t; * the PCI interrupt requests,&n;&t; * at least at heart.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
op_complement
id|BRIDGE_IMR_INT_MSK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* routing a pci device interrupt.&n;&t; * targ and low 38 bits of addr must&n;&t; * be the same as the already set&n;&t; * value for the widget error interrupt.&n;&t; */
id|bridge-&gt;b_int_addr
(braket
id|which_widget_intr
)braket
dot
id|addr
op_assign
(paren
(paren
id|BRIDGE_INT_ADDR_HOST
op_amp
(paren
id|addr
op_rshift
l_int|30
)paren
)paren
op_or
(paren
id|BRIDGE_INT_ADDR_FLD
op_amp
id|vect
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now bridge can let it through;&n;&t; * NB: still should be blocked at&n;&t; * xtalk provider end, until the service&n;&t; * function is set.&n;&t; */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|1
op_lshift
id|vect
suffix:semicolon
)brace
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
r_void
DECL|function|pcibr_intr_list_func
id|pcibr_intr_list_func
c_func
(paren
id|intr_arg_t
id|arg
)paren
(brace
id|pcibr_intr_wrap_t
id|wrap
op_assign
(paren
id|pcibr_intr_wrap_t
)paren
id|arg
suffix:semicolon
id|reg_p
id|statp
op_assign
id|wrap-&gt;iw_stat
suffix:semicolon
id|bridgereg_t
id|mask
op_assign
id|wrap-&gt;iw_intr
suffix:semicolon
id|reg_p
id|wrbf
suffix:semicolon
id|pcibr_intr_list_t
id|list
suffix:semicolon
id|pcibr_intr_t
id|intr
suffix:semicolon
id|intr_func_t
id|func
suffix:semicolon
r_int
id|clearit
suffix:semicolon
r_int
id|thread_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Loop until either&n;     * 1) All interrupts have been removed by direct-called interrupt handlers OR&n;     * 2) We&squot;ve woken up at least one interrupt thread that will presumably clear&n;     *    Bridge interrupt bits&n;     */
r_while
c_loop
(paren
(paren
op_logical_neg
id|thread_count
)paren
op_logical_and
(paren
id|mask
op_amp
op_star
id|statp
)paren
)paren
(brace
id|clearit
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|wrap-&gt;iw_list
suffix:semicolon
id|list
op_ne
l_int|NULL
suffix:semicolon
id|list
op_assign
id|list-&gt;il_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|intr
op_assign
id|list-&gt;il_intr
)paren
op_logical_and
(paren
id|intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_CONNECTED
)paren
)paren
(brace
r_int
id|is_threaded
suffix:semicolon
id|ASSERT
c_func
(paren
id|intr-&gt;bi_func
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This device may have initiated write&n;&t;&t; * requests since the bridge last saw&n;&t;&t; * an edge on this interrupt input; flushing&n;&t;&t; * the buffer here should help but may not&n;&t;&t; * be sufficient if we get more requests after&n;&t;&t; * the flush, followed by the card deciding&n;&t;&t; * it wants service, before the interrupt&n;&t;&t; * handler checks to see if things need&n;&t;&t; * to be done.&n;&t;&t; *&n;&t;&t; * There is a similar race condition if&n;&t;&t; * an interrupt handler loops around and&n;&t;&t; * notices further service is requred.&n;&t;&t; * Perhaps we need to have an explicit&n;&t;&t; * call that interrupt handlers need to&n;&t;&t; * do between noticing that DMA to memory&n;&t;&t; * has completed, but before observing the&n;&t;&t; * contents of memory?&n;&t;&t; */
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|wrbf
op_assign
id|list-&gt;il_wrbf
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|wrbf
op_assign
id|list-&gt;il_wrbf
)paren
)paren
macro_line|#endif
(paren
r_void
)paren
op_star
id|wrbf
suffix:semicolon
multiline_comment|/* write request buffer flush */
id|is_threaded
op_assign
op_logical_neg
(paren
id|intr-&gt;bi_flags
op_amp
id|PCIIO_INTR_NOTHREAD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_threaded
)paren
(brace
id|thread_count
op_increment
suffix:semicolon
macro_line|#ifdef IRIX
id|icvsema
c_func
(paren
op_amp
id|intr-&gt;bi_tinfo.thd_isync
comma
id|intr-&gt;bi_tinfo.thd_pri
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* Non-threaded.  Call the interrupt handler at interrupt level */
id|func
op_assign
id|intr-&gt;bi_func
suffix:semicolon
id|func
c_func
(paren
id|intr-&gt;bi_arg
)paren
suffix:semicolon
)brace
id|clearit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* If there were no handlers,&n;&t; * disable the interrupt and return.&n;&t; * It will get enabled again after&n;&t; * a handler is connected.&n;&t; * If we don&squot;t do this, we would&n;&t; * sit here and spin through the&n;&t; * list forever.&n;&t; */
r_if
c_cond
(paren
id|clearit
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
id|wrap-&gt;iw_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|b_int_enable
suffix:semicolon
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|b_int_enable
op_assign
id|bridge-&gt;b_int_enable
suffix:semicolon
id|b_int_enable
op_and_assign
op_complement
id|mask
suffix:semicolon
id|bridge-&gt;b_int_enable
op_assign
id|b_int_enable
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* =====================================================================&n; *    ERROR HANDLING&n; */
macro_line|#ifdef&t;DEBUG
macro_line|#ifdef&t;ERROR_DEBUG
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;100&t;/* Timeout with ERROR_DEBUG defined */
macro_line|#else
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;40&t;/* Timeout in debug mode  */
macro_line|#endif
macro_line|#else
DECL|macro|BRIDGE_PIOERR_TIMEOUT
mdefine_line|#define BRIDGE_PIOERR_TIMEOUT&t;1&t;/* Timeout in non-debug mode                            */
macro_line|#endif
id|LOCAL
r_void
DECL|function|print_bridge_errcmd
id|print_bridge_errcmd
c_func
(paren
r_uint32
id|cmdword
comma
r_char
op_star
id|errtype
)paren
(brace
macro_line|#ifdef SUPPORT_PRINTING_R_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;&t;Bridge %s error command word register %R&quot;
comma
id|errtype
comma
id|cmdword
comma
id|xio_cmd_bits
)paren
suffix:semicolon
macro_line|#else
id|PRINT_WARNING
c_func
(paren
l_string|&quot;&t;Bridge %s error command word register 0x%x&quot;
comma
id|errtype
comma
id|cmdword
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|pcibr_isr_errs
id|LOCAL
r_char
op_star
id|pcibr_isr_errs
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;08: GIO non-contiguous byte enable in crosstalk packet&quot;
comma
l_string|&quot;09: PCI to Crosstalk read request timeout&quot;
comma
l_string|&quot;10: PCI retry operation count exhausted.&quot;
comma
l_string|&quot;11: PCI bus device select timeout&quot;
comma
l_string|&quot;12: PCI device reported parity error&quot;
comma
l_string|&quot;13: PCI Address/Cmd parity error &quot;
comma
l_string|&quot;14: PCI Bridge detected parity error&quot;
comma
l_string|&quot;15: PCI abort condition&quot;
comma
l_string|&quot;16: SSRAM parity error&quot;
comma
l_string|&quot;17: LLP Transmitter Retry count wrapped&quot;
comma
l_string|&quot;18: LLP Transmitter side required Retry&quot;
comma
l_string|&quot;19: LLP Receiver retry count wrapped&quot;
comma
l_string|&quot;20: LLP Receiver check bit error&quot;
comma
l_string|&quot;21: LLP Receiver sequence number error&quot;
comma
l_string|&quot;22: Request packet overflow&quot;
comma
l_string|&quot;23: Request operation not supported by bridge&quot;
comma
l_string|&quot;24: Request packet has invalid address for bridge widget&quot;
comma
l_string|&quot;25: Incoming request xtalk command word error bit set or invalid sideband&quot;
comma
l_string|&quot;26: Incoming response xtalk command word error bit set or invalid sideband&quot;
comma
l_string|&quot;27: Framing error, request cmd data size does not match actual&quot;
comma
l_string|&quot;28: Framing error, response cmd data size does not match actual&quot;
comma
l_string|&quot;29: Unexpected response arrived&quot;
comma
l_string|&quot;30: Access to SSRAM beyond device limits&quot;
comma
l_string|&quot;31: Multiple errors occurred&quot;
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * PCI Bridge Error interrupt handling.&n; * This routine gets invoked from system interrupt dispatcher&n; * and is responsible for invoking appropriate error handler,&n; * depending on the type of error.&n; * This IS a duplicate of bridge_errintr defined specfic to IP30.&n; * There are some minor differences in terms of the return value and&n; * parameters passed. One of these two should be removed at some point&n; * of time.&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_error_dump
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|int_status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|int_status
op_assign
(paren
id|bridge-&gt;b_int_status
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
suffix:semicolon
id|PRINT_ALERT
c_func
(paren
l_string|&quot;%s PCI BRIDGE ERROR: int_status is 0x%X&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|int_status
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PCIBR_ISR_ERR_START
suffix:semicolon
id|i
OL
id|PCIBR_ISR_MAX_ERRS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|int_status
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%s&quot;
comma
id|pcibr_isr_errs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_XTALK_ERROR
)paren
(brace
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_err_cmdword
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;   Bridge error address 0x%lx&quot;
comma
(paren
(paren
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_upper
op_lshift
l_int|32
)paren
op_or
id|bridge-&gt;b_wid_err_lower
)paren
)paren
suffix:semicolon
id|print_bridge_errcmd
c_func
(paren
id|bridge-&gt;b_wid_aux_err
comma
l_string|&quot;Aux&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
(paren
id|BRIDGE_ISR_BAD_XRESP_PKT
op_or
id|BRIDGE_ISR_RESP_XTLK_ERR
)paren
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;&t;Bridge response buffer: dev-num %d buff-num %d addr 0x%lx&bslash;n&quot;
comma
(paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_rshift
l_int|20
)paren
op_amp
l_int|0x3
)paren
comma
(paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_rshift
l_int|16
)paren
op_amp
l_int|0xF
)paren
comma
(paren
(paren
(paren
r_uint64
)paren
(paren
id|bridge-&gt;b_wid_resp_upper
op_amp
l_int|0xFFFF
)paren
op_lshift
l_int|32
)paren
op_or
id|bridge-&gt;b_wid_resp_lower
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_SSRAM_PERR
)paren
id|PRINT_WARNING
c_func
(paren
l_string|&quot;   Bridge SSRAM parity error register 0x%x&quot;
comma
id|bridge-&gt;b_ram_perr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_PCIBUS_ERROR
)paren
(brace
id|PRINT_WARNING
c_func
(paren
l_string|&quot;   PCI/GIO error upper address register 0x%x&quot;
comma
id|bridge-&gt;b_pci_err_upper
)paren
suffix:semicolon
id|PRINT_WARNING
c_func
(paren
l_string|&quot;   PCI/GIO error lower address register 0x%x&quot;
comma
id|bridge-&gt;b_pci_err_lower
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_ERROR_FATAL
)paren
(brace
id|cmn_err_tag
c_func
(paren
l_int|14
comma
(paren
r_int
)paren
id|CE_PANIC
comma
l_string|&quot;PCI Bridge Error interrupt killed the system&quot;
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED */
)brace
r_else
(brace
id|PRINT_ALERT
c_func
(paren
l_string|&quot;Non-fatal Error in Bridge..&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|macro|PCIBR_ERRINTR_GROUP
mdefine_line|#define PCIBR_ERRINTR_GROUP(error)&t;&bslash;&n;&t;&t;(( error &amp; (BRIDGE_IRR_PCI_GRP|BRIDGE_IRR_GIO_GRP)
r_uint32
DECL|function|pcibr_errintr_group
id|pcibr_errintr_group
c_func
(paren
r_uint32
id|error
)paren
(brace
r_uint32
id|group
op_assign
id|BRIDGE_IRR_MULTI_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_PCI_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_PCI_GRP_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_SSRAM_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_SSRAM_GRP_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_LLP_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_LLP_GRP_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_REQ_DSP_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_REQ_DSP_GRP_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_RESP_BUF_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_RESP_BUF_GRP_CLR
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|BRIDGE_IRR_CRP_GRP
)paren
id|group
op_or_assign
id|BRIDGE_IRR_CRP_GRP_CLR
suffix:semicolon
r_return
id|group
suffix:semicolon
)brace
multiline_comment|/* pcibr_pioerr_check():&n; *&t;Check to see if this pcibr has a PCI PIO&n; *&t;TIMEOUT error; if so, clear it and bump&n; *&t;the timeout-count on any piomaps that&n; *&t;could cover the address.&n; */
r_static
r_void
DECL|function|pcibr_pioerr_check
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft_t
id|soft
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|b_int_status
suffix:semicolon
id|bridgereg_t
id|b_pci_err_lower
suffix:semicolon
id|bridgereg_t
id|b_pci_err_upper
suffix:semicolon
id|iopaddr_t
id|pci_addr
suffix:semicolon
id|pciio_slot_t
id|slot
suffix:semicolon
id|pcibr_piomap_t
id|map
suffix:semicolon
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|win
suffix:semicolon
r_int
id|func
suffix:semicolon
id|bridge
op_assign
id|soft-&gt;bs_base
suffix:semicolon
id|b_int_status
op_assign
id|bridge-&gt;b_int_status
suffix:semicolon
r_if
c_cond
(paren
id|b_int_status
op_amp
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
(brace
id|b_pci_err_lower
op_assign
id|bridge-&gt;b_pci_err_lower
suffix:semicolon
id|b_pci_err_upper
op_assign
id|bridge-&gt;b_pci_err_upper
suffix:semicolon
id|b_int_status
op_assign
id|bridge-&gt;b_int_status
suffix:semicolon
r_if
c_cond
(paren
id|b_int_status
op_amp
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
(brace
id|bridge-&gt;b_int_rst_stat
op_assign
(paren
id|BRIDGE_IRR_PCI_GRP_CLR
op_or
id|BRIDGE_IRR_MULTI_CLR
)paren
suffix:semicolon
id|pci_addr
op_assign
id|b_pci_err_upper
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
suffix:semicolon
id|pci_addr
op_assign
(paren
id|pci_addr
op_lshift
l_int|32
)paren
op_or
id|b_pci_err_lower
suffix:semicolon
id|slot
op_assign
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|nfunc
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|nfunc
suffix:semicolon
id|func
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|pcibr_info-&gt;f_piomap
suffix:semicolon
id|map
op_ne
l_int|NULL
suffix:semicolon
id|map
op_assign
id|map-&gt;bp_next
)paren
(brace
id|base
op_assign
id|map-&gt;bp_pciaddr
suffix:semicolon
id|size
op_assign
id|map-&gt;bp_mapsz
suffix:semicolon
id|win
op_assign
id|map-&gt;bp_space
op_minus
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win
OL
l_int|6
)paren
id|base
op_add_assign
id|soft-&gt;bs_slot
(braket
id|slot
)braket
dot
id|bss_window
(braket
id|win
)braket
dot
id|bssw_base
suffix:semicolon
r_else
r_if
c_cond
(paren
id|map-&gt;bp_space
op_eq
id|PCIIO_SPACE_ROM
)paren
id|base
op_add_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
macro_line|#ifdef IRIX
r_if
c_cond
(paren
(paren
id|pci_addr
op_ge
id|base
)paren
op_logical_and
(paren
id|pci_addr
OL
(paren
id|base
op_plus
id|size
)paren
)paren
)paren
id|atomicAddInt
c_func
(paren
id|map-&gt;bp_toc
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * PCI Bridge Error interrupt handler.&n; *      This gets invoked, whenever a PCI bridge sends an error interrupt.&n; *      Primarily this servers two purposes.&n; *              - If an error can be handled (typically a PIO read/write&n; *                error, we try to do it silently.&n; *              - If an error cannot be handled, we die violently.&n; *      Interrupt due to PIO errors:&n; *              - Bridge sends an interrupt, whenever a PCI operation&n; *                done by the bridge as the master fails. Operations could&n; *                be either a PIO read or a PIO write.&n; *                PIO Read operation also triggers a bus error, and it&squot;s&n; *                We primarily ignore this interrupt in that context..&n; *                For PIO write errors, this is the only indication.&n; *                and we have to handle with the info from here.&n; *&n; *                So, there is no way to distinguish if an interrupt is&n; *                due to read or write error!.&n; */
id|LOCAL
r_void
DECL|function|pcibr_error_intr_handler
id|pcibr_error_intr_handler
c_func
(paren
id|intr_arg_t
id|arg
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|bridgereg_t
id|int_status
suffix:semicolon
id|bridgereg_t
id|err_status
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if defined(SN0_HWDEBUG)
r_extern
r_int
id|la_trigger_nasid1
suffix:semicolon
r_extern
r_int
id|la_trigger_nasid2
suffix:semicolon
r_extern
r_int
id|la_trigger_val
suffix:semicolon
macro_line|#endif
multiline_comment|/* REFERENCED */
id|bridgereg_t
id|disable_errintr_mask
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef IRIX
r_int
id|rv
suffix:semicolon
macro_line|#else
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
id|error_code
op_assign
id|IOECODE_DMA
op_or
id|IOECODE_READ
suffix:semicolon
id|ioerror_mode_t
id|mode
op_assign
id|MODE_DEVERROR
suffix:semicolon
id|ioerror_t
id|ioe
suffix:semicolon
macro_line|#if defined(SN0_HWDEBUG)
multiline_comment|/*&n;    * trigger points for logic analyzer. Used to debug the DMA timeout&n;    * note that 0xcafe is added to the trigger values to avoid false&n;    * triggers when la_trigger_val shows up in a cacheline as data&n;    */
r_if
c_cond
(paren
id|la_trigger_nasid1
op_ne
op_minus
l_int|1
)paren
id|REMOTE_HUB_PI_S
c_func
(paren
id|la_trigger_nasid1
comma
l_int|0
comma
id|PI_CPU_NUM
comma
id|la_trigger_val
op_plus
l_int|0xcafe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|la_trigger_nasid2
op_ne
op_minus
l_int|1
)paren
id|REMOTE_HUB_PI_S
c_func
(paren
id|la_trigger_nasid2
comma
l_int|0
comma
id|PI_CPU_NUM
comma
id|la_trigger_val
op_plus
l_int|0xcafe
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if PCIBR_SOFT_LIST
multiline_comment|/* IP27 seems to be handing us junk.&n;     */
(brace
id|pcibr_list_p
id|entry
suffix:semicolon
id|entry
op_assign
id|pcibr_list
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pcibr_error_intr_handler:&bslash;n&quot;
l_string|&quot;&bslash;tparameter (0x%p) is not a pcibr_soft!&quot;
comma
id|arg
)paren
suffix:semicolon
id|PRINT_PANIC
c_func
(paren
l_string|&quot;Invalid parameter to pcibr_error_intr_handler&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|intr_arg_t
)paren
id|entry-&gt;bl_soft
op_eq
id|arg
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|entry-&gt;bl_next
suffix:semicolon
)brace
)brace
macro_line|#endif
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|arg
suffix:semicolon
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
multiline_comment|/*&n;     * pcibr_error_intr_handler gets invoked whenever bridge encounters&n;     * an error situation, and the interrupt for that error is enabled.&n;     * This routine decides if the error is fatal or not, and takes&n;     * action accordingly.&n;     *&n;     * In one case there is a need for special action.&n;     * In case of PIO read/write timeouts due to user level, we do&n;     * get an error interrupt. In this case, way to handle would&n;     * be to start a timeout. If the error was due to &quot;read&quot;, bus&n;     * error handling code takes care of it. If error is due to write,&n;     * it&squot;s handled at timeout&n;     */
multiline_comment|/* int_status is which bits we have to clear;&n;     * err_status is the bits we haven&squot;t handled yet.&n;     */
id|int_status
op_assign
id|bridge-&gt;b_int_status
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
suffix:semicolon
id|err_status
op_assign
id|int_status
op_amp
op_complement
id|BRIDGE_ISR_MULTI_ERR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|int_status
op_amp
op_complement
id|BRIDGE_ISR_INT_MSK
)paren
)paren
(brace
multiline_comment|/*&n;&t; * No error bit set!!.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/* If we have a PCIBUS_PIOERR,&n;     * hand it to the logger but otherwise&n;     * ignore the event.&n;     */
r_if
c_cond
(paren
id|int_status
op_amp
id|BRIDGE_ISR_PCIBUS_PIOERR
)paren
(brace
id|pcibr_pioerr_check
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|err_status
op_and_assign
op_complement
id|BRIDGE_ISR_PCIBUS_PIOERR
suffix:semicolon
id|int_status
op_and_assign
op_complement
id|BRIDGE_ISR_PCIBUS_PIOERR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err_status
)paren
(brace
r_struct
id|bs_errintr_stat_s
op_star
id|bs_estat
op_assign
id|pcibr_soft-&gt;bs_errintr_stat
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PCIBR_ISR_ERR_START
suffix:semicolon
id|i
OL
id|PCIBR_ISR_MAX_ERRS
suffix:semicolon
id|i
op_increment
comma
id|bs_estat
op_increment
)paren
(brace
r_if
c_cond
(paren
id|err_status
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_uint32
id|errrate
op_assign
l_int|0
suffix:semicolon
r_uint32
id|errcount
op_assign
l_int|0
suffix:semicolon
r_uint32
id|errinterval
op_assign
l_int|0
comma
id|current_tick
op_assign
l_int|0
suffix:semicolon
r_int
id|panic_on_llp_tx_retry
op_assign
l_int|0
suffix:semicolon
r_int
id|is_llp_tx_retry_intr
op_assign
l_int|0
suffix:semicolon
id|bs_estat-&gt;bs_errcount_total
op_increment
suffix:semicolon
macro_line|#ifdef IRIX
id|current_tick
op_assign
id|lbolt
suffix:semicolon
macro_line|#else
id|current_tick
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|errinterval
op_assign
(paren
id|current_tick
op_minus
id|bs_estat-&gt;bs_lasterr_timestamp
)paren
suffix:semicolon
id|errcount
op_assign
(paren
id|bs_estat-&gt;bs_errcount_total
op_minus
id|bs_estat-&gt;bs_lasterr_snapshot
)paren
suffix:semicolon
id|is_llp_tx_retry_intr
op_assign
(paren
id|BRIDGE_ISR_LLP_TX_RETRY
op_eq
(paren
l_int|1
op_lshift
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* On a non-zero error rate (which is equivalent to&n;&t;&t; * to 100 errors /sec at least) for the LLP transmitter&n;&t;&t; * retry interrupt we need to panic the system&n;&t;&t; * to prevent potential data corruption .&n;&t;&t; * NOTE : errcount is being compared to PCIBR_ERRTIME_THRESHOLD&n;&t;&t; * to make sure that we are not seing cases like x error&n;&t;&t; * interrupts per y ticks for very low x ,y (x &gt; y ) which&n;&t;&t; * makes error rate be &gt; 100 /sec.&n;&t;&t; */
multiline_comment|/* Check for the divide by zero condition while&n;&t;&t; * calculating the error rates.&n;&t;&t; */
r_if
c_cond
(paren
id|errinterval
)paren
(brace
id|errrate
op_assign
id|errcount
op_div
id|errinterval
suffix:semicolon
multiline_comment|/* If able to calculate error rate&n;&t;&t;     * on a LLP transmitter retry interrupt check&n;&t;&t;     * if the error rate is nonzero and we have seen&n;&t;&t;     * a certain minimum number of errors.&n;&t;&t;     */
r_if
c_cond
(paren
id|is_llp_tx_retry_intr
op_logical_and
id|errrate
op_logical_and
(paren
id|errcount
op_ge
id|PCIBR_ERRTIME_THRESHOLD
)paren
)paren
(brace
id|panic_on_llp_tx_retry
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|errrate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Since we are not able to calculate the&n;&t;&t;     * error rate check if we exceeded a certain&n;&t;&t;     * minimum number of errors for LLP transmitter&n;&t;&t;     * retries. Note that this can only happen&n;&t;&t;     * within the first tick after the last snapshot.&n;&t;&t;     */
r_if
c_cond
(paren
id|is_llp_tx_retry_intr
op_logical_and
(paren
id|errcount
op_ge
id|PCIBR_ERRINTR_DISABLE_LEVEL
)paren
)paren
(brace
id|panic_on_llp_tx_retry
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|panic_on_llp_tx_retry
)paren
(brace
r_static
r_uint32
id|last_printed_rate
suffix:semicolon
r_if
c_cond
(paren
id|errrate
OG
id|last_printed_rate
)paren
(brace
id|last_printed_rate
op_assign
id|errrate
suffix:semicolon
multiline_comment|/* Print the warning only if the error rate&n;&t;&t;&t; * for the transmitter retry interrupt&n;&t;&t;&t; * exceeded the previously printed rate.&n;&t;&t;&t; */
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%s: %s, Excessive error interrupts : %d/tick&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|errrate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;     * Update snapshot, and time&n;&t;&t;     */
id|bs_estat-&gt;bs_lasterr_timestamp
op_assign
id|current_tick
suffix:semicolon
id|bs_estat-&gt;bs_lasterr_snapshot
op_assign
id|bs_estat-&gt;bs_errcount_total
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the error rate is high enough, print the error rate.&n;&t;&t; */
r_if
c_cond
(paren
id|errinterval
OG
id|PCIBR_ERRTIME_THRESHOLD
)paren
(brace
r_if
c_cond
(paren
id|errrate
OG
id|PCIBR_ERRRATE_THRESHOLD
)paren
(brace
id|PRINT_NOTICE
c_func
(paren
l_string|&quot;%s: %s, Error rate %d/tick&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|errrate
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Update snapshot, and time&n;&t;&t;&t; */
id|bs_estat-&gt;bs_lasterr_timestamp
op_assign
id|current_tick
suffix:semicolon
id|bs_estat-&gt;bs_lasterr_snapshot
op_assign
id|bs_estat-&gt;bs_errcount_total
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bs_estat-&gt;bs_errcount_total
OG
id|PCIBR_ERRINTR_DISABLE_LEVEL
)paren
(brace
multiline_comment|/*&n;&t;&t;     * We have seen a fairly large number of errors of&n;&t;&t;     * this type. Let&squot;s disable the interrupt. But flash&n;&t;&t;     * a message about the interrupt being disabled.&n;&t;&t;     */
id|PRINT_NOTICE
c_func
(paren
l_string|&quot;%s Disabling error interrupt type %s. Error count %d&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|pcibr_isr_errs
(braket
id|i
)braket
comma
id|bs_estat-&gt;bs_errcount_total
)paren
suffix:semicolon
id|disable_errintr_mask
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|disable_errintr_mask
)paren
(brace
multiline_comment|/*&n;&t; * Disable some high frequency errors as they&n;&t; * could eat up too much cpu time.&n;&t; */
id|bridge-&gt;b_int_enable
op_and_assign
op_complement
id|disable_errintr_mask
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we leave the PROM cacheable, T5 might&n;     * try to do a cache line sized writeback to it,&n;     * which will cause a BRIDGE_ISR_INVLD_ADDR.&n;     */
r_if
c_cond
(paren
(paren
id|err_status
op_amp
id|BRIDGE_ISR_INVLD_ADDR
)paren
op_logical_and
(paren
l_int|0x00000000
op_eq
id|bridge-&gt;b_wid_err_upper
)paren
op_logical_and
(paren
l_int|0x00C00000
op_eq
(paren
l_int|0xFFC00000
op_amp
id|bridge-&gt;b_wid_err_lower
)paren
)paren
op_logical_and
(paren
l_int|0x00402000
op_eq
(paren
l_int|0x00F07F00
op_amp
id|bridge-&gt;b_wid_err_cmdword
)paren
)paren
)paren
(brace
id|err_status
op_and_assign
op_complement
id|BRIDGE_ISR_INVLD_ADDR
suffix:semicolon
)brace
macro_line|#if defined (PCIBR_LLP_CONTROL_WAR)
multiline_comment|/*&n;     * The bridge bug, where the llp_config or control registers&n;     * need to be read back after being written, affects an MP&n;     * system since there could be small windows between writing&n;     * the register and reading it back on one cpu while another&n;     * cpu is fielding an interrupt. If we run into this scenario,&n;     * workaround the problem by ignoring the error. (bug 454474)&n;     * pcibr_llp_control_war_cnt keeps an approximate number of&n;     * times we saw this problem on a system.&n;     */
r_if
c_cond
(paren
(paren
id|err_status
op_amp
id|BRIDGE_ISR_INVLD_ADDR
)paren
op_logical_and
(paren
(paren
(paren
(paren
r_uint64
)paren
id|bridge-&gt;b_wid_err_upper
op_lshift
l_int|32
)paren
op_or
(paren
id|bridge-&gt;b_wid_err_lower
)paren
)paren
op_eq
(paren
id|BRIDGE_INT_RST_STAT
op_amp
l_int|0xff0
)paren
)paren
)paren
(brace
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|kdebug
)paren
id|PRINT_NOTICE
c_func
(paren
l_string|&quot;%s bridge: ignoring llp/control address interrupt&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
macro_line|#endif
id|pcibr_llp_control_war_cnt
op_increment
suffix:semicolon
id|err_status
op_and_assign
op_complement
id|BRIDGE_ISR_INVLD_ADDR
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* PCIBR_LLP_CONTROL_WAR */
multiline_comment|/* Check if this is the RESP_XTALK_ERROR interrupt. &n;     * This can happen due to a failed DMA READ operation.&n;     */
r_if
c_cond
(paren
id|err_status
op_amp
id|BRIDGE_ISR_RESP_XTLK_ERR
)paren
(brace
multiline_comment|/* Phase 1 : Look at the error state in the bridge and further&n;&t; * down in the device layers.&n;&t; */
macro_line|#if defined(CONFIG_SGI_IO_ERROR_HANDLING)
(paren
r_void
)paren
id|error_state_set
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|ERROR_STATE_LOOKUP
)paren
suffix:semicolon
macro_line|#endif
id|IOERROR_SETVALUE
c_func
(paren
op_amp
id|ioe
comma
id|widgetnum
comma
id|pcibr_soft-&gt;bs_xid
)paren
suffix:semicolon
(paren
r_void
)paren
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
id|error_code
comma
id|mode
comma
op_amp
id|ioe
)paren
suffix:semicolon
multiline_comment|/* Phase 2 : Perform the action agreed upon in phase 1.&n;&t; */
macro_line|#if defined(CONFIG_SGI_IO_ERROR_HANDLING)
(paren
r_void
)paren
id|error_state_set
c_func
(paren
id|pcibr_soft-&gt;bs_conn
comma
id|ERROR_STATE_ACTION
)paren
suffix:semicolon
macro_line|#endif
id|rv
op_assign
id|pcibr_error_handler
c_func
(paren
(paren
id|error_handler_arg_t
)paren
id|pcibr_soft
comma
id|error_code
comma
id|mode
comma
op_amp
id|ioe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rv
op_ne
id|IOERROR_HANDLED
)paren
(brace
macro_line|#ifdef&t;DEBUG
r_if
c_cond
(paren
id|err_status
op_amp
id|BRIDGE_ISR_ERROR_DUMP
)paren
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
macro_line|#else&t;
r_if
c_cond
(paren
id|err_status
op_amp
id|BRIDGE_ISR_ERROR_FATAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BRIDGE ERR STATUS 0x%x&bslash;n&quot;
comma
id|err_status
)paren
suffix:semicolon
id|pcibr_error_dump
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;     * We can&squot;t return without re-enabling the interrupt, since&n;     * it would cause problems for devices like IOC3 (Lost&n;     * interrupts ?.). So, just cleanup the interrupt, and&n;     * use saved values later..&n;     */
id|bridge-&gt;b_int_rst_stat
op_assign
id|pcibr_errintr_group
c_func
(paren
id|int_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_addr_toslot&n; *      Given the &squot;pciaddr&squot; find out which slot this address is&n; *      allocated to, and return the slot number.&n; *      While we have the info handy, construct the&n; *      function number, space code and offset as well.&n; *&n; * NOTE: if this routine is called, we don&squot;t know whether&n; * the address is in CFG, MEM, or I/O space. We have to guess.&n; * This will be the case on PIO stores, where the only way&n; * we have of getting the address is to check the Bridge, which&n; * stores the PCI address but not the space and not the xtalk&n; * address (from which we could get it).&n; */
id|LOCAL
r_int
DECL|function|pcibr_addr_toslot
id|pcibr_addr_toslot
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|iopaddr_t
id|pciaddr
comma
id|pciio_space_t
op_star
id|spacep
comma
id|iopaddr_t
op_star
id|offsetp
comma
id|pciio_function_t
op_star
id|funcp
)paren
(brace
macro_line|#ifdef IRIX
r_int
id|s
comma
id|f
comma
id|w
suffix:semicolon
macro_line|#else
r_int
id|s
comma
id|f
op_assign
l_int|0
comma
id|w
suffix:semicolon
macro_line|#endif
id|iopaddr_t
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
id|pciio_piospace_t
id|piosp
suffix:semicolon
multiline_comment|/*&n;     * Check if the address is in config space&n;     */
r_if
c_cond
(paren
(paren
id|pciaddr
op_ge
id|BRIDGE_CONFIG_BASE
)paren
op_logical_and
(paren
id|pciaddr
OL
id|BRIDGE_CONFIG_END
)paren
)paren
(brace
r_if
c_cond
(paren
id|pciaddr
op_ge
id|BRIDGE_CONFIG1_BASE
)paren
id|pciaddr
op_sub_assign
id|BRIDGE_CONFIG1_BASE
suffix:semicolon
r_else
id|pciaddr
op_sub_assign
id|BRIDGE_CONFIG_BASE
suffix:semicolon
id|s
op_assign
id|pciaddr
op_div
id|BRIDGE_CONFIG_SLOT_SIZE
suffix:semicolon
id|pciaddr
op_mod_assign
id|BRIDGE_CONFIG_SLOT_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|funcp
)paren
(brace
id|f
op_assign
id|pciaddr
op_div
l_int|0x100
suffix:semicolon
id|pciaddr
op_mod_assign
l_int|0x100
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spacep
)paren
op_star
id|spacep
op_assign
id|PCIIO_SPACE_CFG
suffix:semicolon
r_if
c_cond
(paren
id|offsetp
)paren
op_star
id|offsetp
op_assign
id|pciaddr
suffix:semicolon
r_if
c_cond
(paren
id|funcp
)paren
op_star
id|funcp
op_assign
id|f
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
l_int|8
suffix:semicolon
id|s
op_increment
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|s
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|s
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|nf
suffix:semicolon
id|f
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|f
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|w
op_assign
l_int|0
suffix:semicolon
id|w
OL
l_int|6
suffix:semicolon
id|w
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibr_info-&gt;f_window
(braket
id|w
)braket
dot
id|w_space
op_eq
id|PCIIO_SPACE_NONE
)paren
(brace
r_continue
suffix:semicolon
)brace
id|base
op_assign
id|pcibr_info-&gt;f_window
(braket
id|w
)braket
dot
id|w_base
suffix:semicolon
id|size
op_assign
id|pcibr_info-&gt;f_window
(braket
id|w
)braket
dot
id|w_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pciaddr
op_ge
id|base
)paren
op_logical_and
(paren
id|pciaddr
OL
(paren
id|base
op_plus
id|size
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|spacep
)paren
op_star
id|spacep
op_assign
id|PCIIO_SPACE_WIN
c_func
(paren
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offsetp
)paren
op_star
id|offsetp
op_assign
id|pciaddr
op_minus
id|base
suffix:semicolon
r_if
c_cond
(paren
id|funcp
)paren
op_star
id|funcp
op_assign
id|f
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/* endif match */
)brace
multiline_comment|/* next window */
)brace
multiline_comment|/* next func */
)brace
multiline_comment|/* next slot */
multiline_comment|/*&n;     * Check if the address was allocated as part of the&n;     * pcibr_piospace_alloc calls.&n;     */
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
l_int|8
suffix:semicolon
id|s
op_increment
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|s
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|s
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|nf
suffix:semicolon
id|f
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|f
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
id|piosp
op_assign
id|pcibr_info-&gt;f_piospace
suffix:semicolon
r_while
c_loop
(paren
id|piosp
)paren
(brace
r_if
c_cond
(paren
(paren
id|piosp-&gt;start
op_le
id|pciaddr
)paren
op_logical_and
(paren
(paren
id|piosp-&gt;count
op_plus
id|piosp-&gt;start
)paren
OG
id|pciaddr
)paren
)paren
(brace
r_if
c_cond
(paren
id|spacep
)paren
op_star
id|spacep
op_assign
id|piosp-&gt;space
suffix:semicolon
r_if
c_cond
(paren
id|offsetp
)paren
op_star
id|offsetp
op_assign
id|pciaddr
op_minus
id|piosp-&gt;start
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/* endif match */
id|piosp
op_assign
id|piosp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* next piosp */
)brace
multiline_comment|/* next func */
)brace
multiline_comment|/* next slot */
multiline_comment|/*&n;     * Some other random address on the PCI bus ...&n;     * we have no way of knowing whether this was&n;     * a MEM or I/O access; so, for now, we just&n;     * assume that the low 1G is MEM, the next&n;     * 3G is I/O, and anything above the 4G limit&n;     * is obviously MEM.&n;     */
r_if
c_cond
(paren
id|spacep
)paren
op_star
id|spacep
op_assign
(paren
(paren
id|pciaddr
OL
(paren
l_int|1ul
op_lshift
l_int|30
)paren
)paren
ques
c_cond
id|PCIIO_SPACE_MEM
suffix:colon
(paren
id|pciaddr
OL
(paren
l_int|4ul
op_lshift
l_int|30
)paren
)paren
ques
c_cond
id|PCIIO_SPACE_IO
suffix:colon
id|PCIIO_SPACE_MEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offsetp
)paren
op_star
id|offsetp
op_assign
id|pciaddr
suffix:semicolon
r_return
id|PCIIO_SLOT_NONE
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|pcibr_error_cleanup
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|ASSERT
c_func
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
suffix:semicolon
id|error_code
op_assign
id|error_code
suffix:semicolon
id|bridge-&gt;b_int_rst_stat
op_assign
(paren
id|BRIDGE_IRR_PCI_GRP_CLR
op_or
id|BRIDGE_IRR_MULTI_CLR
)paren
suffix:semicolon
(paren
r_void
)paren
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* flushbus */
)brace
multiline_comment|/*&n; * pcibr_error_extract&n; *      Given the &squot;pcibr vertex handle&squot; find out which slot&n; *      the bridge status error address (from pcibr_soft info&n; *      hanging off the vertex)&n; *      allocated to, and return the slot number.&n; *      While we have the info handy, construct the&n; *      space code and offset as well.&n; *&n; * NOTE: if this routine is called, we don&squot;t know whether&n; * the address is in CFG, MEM, or I/O space. We have to guess.&n; * This will be the case on PIO stores, where the only way&n; * we have of getting the address is to check the Bridge, which&n; * stores the PCI address but not the space and not the xtalk&n; * address (from which we could get it).&n; *&n; * XXX- this interface has no way to return the function&n; * number on a multifunction card, even though that data&n; * is available.&n; */
id|pciio_slot_t
DECL|function|pcibr_error_extract
id|pcibr_error_extract
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_space_t
op_star
id|spacep
comma
id|iopaddr_t
op_star
id|offsetp
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
op_assign
l_int|0
suffix:semicolon
id|iopaddr_t
id|bserr_addr
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|pciio_slot_t
id|slot
op_assign
id|PCIIO_SLOT_NONE
suffix:semicolon
id|arbitrary_info_t
id|rev
suffix:semicolon
multiline_comment|/* Do a sanity check as to whether we really got a &n;     * bridge vertex handle.&n;     */
r_if
c_cond
(paren
id|hwgraph_info_get_LBL
c_func
(paren
id|pcibr_vhdl
comma
id|INFO_LBL_PCIBR_ASIC_REV
comma
op_amp
id|rev
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_return
id|slot
suffix:semicolon
id|pcibr_soft
op_assign
id|pcibr_soft_get
c_func
(paren
id|pcibr_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft
)paren
(brace
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bserr_addr
op_assign
id|bridge-&gt;b_pci_err_lower
op_or
(paren
(paren
r_uint64
)paren
(paren
id|bridge-&gt;b_pci_err_upper
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
id|slot
op_assign
id|pcibr_addr_toslot
c_func
(paren
id|pcibr_soft
comma
id|bserr_addr
comma
id|spacep
comma
id|offsetp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|slot
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_device_disable
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|devnum
)paren
(brace
multiline_comment|/*&n;     * XXX&n;     * Device failed to handle error. Take steps to&n;     * disable this device ? HOW TO DO IT ?&n;     *&n;     * If there are any Read response buffers associated&n;     * with this device, it&squot;s time to get them back!!&n;     *&n;     * We can disassociate any interrupt level associated&n;     * with this device, and disable that interrupt level&n;     *&n;     * For now it&squot;s just a place holder&n;     */
)brace
multiline_comment|/*&n; * pcibr_pioerror&n; *      Handle PIO error that happened at the bridge pointed by pcibr_soft.&n; *&n; *      Queries the Bus interface attached to see if the device driver&n; *      mapping the device-number that caused error can handle the&n; *      situation. If so, it will clean up any error, and return&n; *      indicating the error was handled. If the device driver is unable&n; *      to handle the error, it expects the bus-interface to disable that&n; *      device, and takes any steps needed here to take away any resources&n; *      associated with this device.&n; */
DECL|macro|BEM_ADD_STR
mdefine_line|#define BEM_ADD_STR(s)&t;printk(&quot;%s&quot;, (s))
macro_line|#ifdef SUPPORT_SGI_CMN_ERR_STUFF
DECL|macro|BEM_ADD_VAR
mdefine_line|#define BEM_ADD_VAR(v)&t;printk(&quot;&bslash;t%20s: 0x%x&bslash;n&quot;, #v, (v))
DECL|macro|BEM_ADD_REG
mdefine_line|#define BEM_ADD_REG(r)&t;printk(&quot;&bslash;t%20s: %R&bslash;n&quot;, #r, (r), r ## _desc)
DECL|macro|BEM_ADD_NSPC
mdefine_line|#define BEM_ADD_NSPC(n,s)&t;printk(&quot;&bslash;t%20s: %R&bslash;n&quot;, n, s, space_desc)
macro_line|#else
DECL|macro|BEM_ADD_VAR
mdefine_line|#define BEM_ADD_VAR(v)&t;
DECL|macro|BEM_ADD_REG
mdefine_line|#define BEM_ADD_REG(r)&t;
DECL|macro|BEM_ADD_NSPC
mdefine_line|#define BEM_ADD_NSPC(n,s)
macro_line|#endif
DECL|macro|BEM_ADD_SPC
mdefine_line|#define BEM_ADD_SPC(s)&t;&t;BEM_ADD_NSPC(#s, s)
multiline_comment|/* BEM_ADD_IOE doesn&squot;t dump the whole ioerror, it just&n; * decodes the PCI specific portions -- we count on our&n; * callers to dump the raw IOE data.&n; */
macro_line|#ifdef colin
DECL|macro|BEM_ADD_IOE
mdefine_line|#define BEM_ADD_IOE(ioe)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (IOERROR_FIELDVALID(ioe, busspace)) {&t;&t;&t;&bslash;&n;&t;&t;unsigned&t;&t;spc;&t;&t;&t;&t;&bslash;&n;&t;&t;unsigned&t;&t;win;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;spc = IOERROR_GETVALUE(ioe, busspace);&t;&t;&t;&bslash;&n;&t;&t;win = spc - PCIIO_SPACE_WIN(0);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;switch (spc) {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_CFG:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI Slot %d Func %d CFG space Offset 0x%x&bslash;n&quot;,&t;&bslash;&n;&t;    pciio_widgetdev_slot_get(IOERROR_GETVALUE(ioe, widgetdev)),&t;&bslash;&n;&t;    pciio_widgetdev_func_get(IOERROR_GETVALUE(ioe, widgetdev)),&t;&bslash;&n;&t;&t;&t;    IOERROR_GETVALUE(ioe, busaddr));&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_IO:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI I/O space  Offset 0x%x&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;&t;    IOERROR_GETVALUE(ioe, busaddr));&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM32:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case PCIIO_SPACE_MEM64:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI MEM space Offset 0x%x&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;&t;    IOERROR_GETVALUE(ioe, busaddr));&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;default:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    if (win &lt; 6) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    printk(&quot;&bslash;tPCI Slot %d Func %d Window %d Offset 0x%x&bslash;n&quot;,&bslash;&n;&t;    pciio_widgetdev_slot_get(IOERROR_GETVALUE(ioe, widgetdev)),&t;&bslash;&n;&t;    pciio_widgetdev_func_get(IOERROR_GETVALUE(ioe, widgetdev)),&t;&bslash;&n;&t;&t;&t;    win,&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;    IOERROR_GETVALUE(ioe, busaddr));&t;&t;&bslash;&n;&t;&t;    }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
macro_line|#else
DECL|macro|BEM_ADD_IOE
mdefine_line|#define BEM_ADD_IOE(ioe)
macro_line|#endif
multiline_comment|/*ARGSUSED */
id|LOCAL
r_int
DECL|function|pcibr_pioerror
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
r_int
id|retval
op_assign
id|IOERROR_HANDLED
suffix:semicolon
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|bridge_int_status
suffix:semicolon
id|bridgereg_t
id|bridge_pci_err_lower
suffix:semicolon
id|bridgereg_t
id|bridge_pci_err_upper
suffix:semicolon
id|bridgereg_t
id|bridge_pci_err_addr
suffix:semicolon
id|iopaddr_t
id|bad_xaddr
suffix:semicolon
id|pciio_space_t
id|raw_space
suffix:semicolon
multiline_comment|/* raw PCI space */
id|iopaddr_t
id|raw_paddr
suffix:semicolon
multiline_comment|/* raw PCI address */
id|pciio_space_t
id|space
suffix:semicolon
multiline_comment|/* final PCI space */
id|pciio_slot_t
id|slot
suffix:semicolon
multiline_comment|/* final PCI slot, if appropriate */
id|pciio_function_t
id|func
suffix:semicolon
multiline_comment|/* final PCI func, if appropriate */
id|iopaddr_t
id|offset
suffix:semicolon
multiline_comment|/* final PCI offset */
r_int
id|cs
comma
id|cw
comma
id|cf
suffix:semicolon
id|pciio_space_t
id|wx
suffix:semicolon
id|iopaddr_t
id|wb
suffix:semicolon
r_int
id|ws
suffix:semicolon
id|iopaddr_t
id|wl
suffix:semicolon
multiline_comment|/*&n;     * We expect to have an &quot;xtalkaddr&quot; coming in,&n;     * and need to construct the slot/space/offset.&n;     */
macro_line|#ifdef colin
id|bad_xaddr
op_assign
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|xtalkaddr
)paren
suffix:semicolon
macro_line|#else
id|bad_xaddr
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|slot
op_assign
id|PCIIO_SLOT_NONE
suffix:semicolon
id|func
op_assign
id|PCIIO_FUNC_NONE
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_NONE
suffix:semicolon
id|raw_paddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_TYPE0_CFG_DEV0
)paren
op_logical_and
(paren
id|bad_xaddr
OL
id|BRIDGE_TYPE1_CFG
)paren
)paren
(brace
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_TYPE0_CFG_DEV0
suffix:semicolon
id|slot
op_assign
id|raw_paddr
op_div
id|BRIDGE_TYPE0_CFG_SLOT_OFF
suffix:semicolon
id|raw_paddr
op_assign
id|raw_paddr
op_mod
id|BRIDGE_TYPE0_CFG_SLOT_OFF
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_CFG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_TYPE1_CFG
)paren
op_logical_and
(paren
id|bad_xaddr
OL
(paren
id|BRIDGE_TYPE1_CFG
op_plus
l_int|0x1000
)paren
)paren
)paren
(brace
multiline_comment|/* Type 1 config space:&n;&t; * slot and function numbers not known.&n;&t; * Perhaps we can read them back?&n;&t; */
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_TYPE1_CFG
suffix:semicolon
id|raw_space
op_assign
id|PCIIO_SPACE_CFG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_DEVIO0
)paren
op_logical_and
(paren
id|bad_xaddr
OL
id|BRIDGE_DEVIO
c_func
(paren
id|BRIDGE_DEV_CNT
)paren
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_DEVIO0
suffix:semicolon
id|x
op_assign
id|raw_paddr
op_div
id|BRIDGE_DEVIO_OFF
suffix:semicolon
id|raw_paddr
op_mod_assign
id|BRIDGE_DEVIO_OFF
suffix:semicolon
multiline_comment|/* first two devio windows are double-sized */
r_if
c_cond
(paren
(paren
id|x
op_eq
l_int|1
)paren
op_logical_or
(paren
id|x
op_eq
l_int|3
)paren
)paren
id|raw_paddr
op_add_assign
id|BRIDGE_DEVIO_OFF
suffix:semicolon
r_if
c_cond
(paren
id|x
OG
l_int|0
)paren
id|x
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|x
OG
l_int|1
)paren
id|x
op_decrement
suffix:semicolon
multiline_comment|/* x is which devio reg; no guarantee&n;&t; * pci slot x will be responding.&n;&t; * still need to figure out who decodes&n;&t; * space/offset on the bus.&n;&t; */
id|raw_space
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_devio.bssd_space
suffix:semicolon
r_if
c_cond
(paren
id|raw_space
op_eq
id|PCIIO_SPACE_NONE
)paren
(brace
multiline_comment|/* Someone got an error because they&n;&t;     * accessed the PCI bus via a DevIO(x)&n;&t;     * window that pcibr has not yet assigned&n;&t;     * to any specific PCI address. It is&n;&t;     * quite possible that the Device(x)&n;&t;     * register has been changed since they&n;&t;     * made their access, but we will give it&n;&t;     * our best decode shot.&n;&t;     */
id|raw_space
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_DEV_IO_MEM
ques
c_cond
id|PCIIO_SPACE_MEM
suffix:colon
id|PCIIO_SPACE_IO
suffix:semicolon
id|raw_paddr
op_add_assign
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_device
op_amp
id|BRIDGE_DEV_OFF_MASK
)paren
op_lshift
id|BRIDGE_DEV_OFF_ADDR_SHFT
suffix:semicolon
)brace
r_else
id|raw_paddr
op_add_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|x
)braket
dot
id|bss_devio.bssd_base
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_MEM32_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_MEM32_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_MEM32
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_MEM32_BASE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_MEM64_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_MEM64_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_MEM64
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_MEM64_BASE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bad_xaddr
op_ge
id|BRIDGE_PCI_IO_BASE
)paren
op_logical_and
(paren
id|bad_xaddr
op_le
id|BRIDGE_PCI_IO_LIMIT
)paren
)paren
(brace
id|raw_space
op_assign
id|PCIIO_SPACE_IO
suffix:semicolon
id|raw_paddr
op_assign
id|bad_xaddr
op_minus
id|BRIDGE_PCI_IO_BASE
suffix:semicolon
)brace
id|space
op_assign
id|raw_space
suffix:semicolon
id|offset
op_assign
id|raw_paddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
op_logical_and
(paren
id|space
op_ne
id|PCIIO_SPACE_NONE
)paren
)paren
(brace
multiline_comment|/* we&squot;ve got a space/offset but not which&n;&t; * pci slot decodes it. Check through our&n;&t; * notions of which devices decode where.&n;&t; *&n;&t; * Yes, this &quot;duplicates&quot; some logic in&n;&t; * pcibr_addr_toslot; the difference is,&n;&t; * this code knows which space we are in,&n;&t; * and can really really tell what is&n;&t; * going on (no guessing).&n;&t; */
r_for
c_loop
(paren
id|cs
op_assign
l_int|0
suffix:semicolon
(paren
id|cs
OL
l_int|8
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
id|cs
op_increment
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|cf
op_assign
l_int|0
suffix:semicolon
(paren
id|cf
OL
id|nf
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
id|cf
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|cf
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|cw
op_assign
l_int|0
suffix:semicolon
(paren
id|cw
OL
l_int|6
)paren
op_logical_and
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
suffix:semicolon
op_increment
id|cw
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|wx
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_space
)paren
op_ne
id|PCIIO_SPACE_NONE
)paren
op_logical_and
(paren
(paren
id|wb
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_base
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|ws
op_assign
id|pcibr_info-&gt;f_window
(braket
id|cw
)braket
dot
id|w_size
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|wl
op_assign
id|wb
op_plus
id|ws
)paren
OG
id|wb
)paren
op_logical_and
(paren
(paren
id|wb
op_le
id|offset
)paren
op_logical_and
(paren
id|wl
OG
id|offset
)paren
)paren
)paren
(brace
multiline_comment|/* MEM, MEM32 and MEM64 need to&n;&t;&t;&t; * compare as equal ...&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|space
)paren
op_logical_or
(paren
(paren
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
op_logical_and
(paren
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM
)paren
op_logical_or
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|space
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
)paren
)paren
(brace
id|slot
op_assign
id|cs
suffix:semicolon
id|func
op_assign
id|cf
suffix:semicolon
id|space
op_assign
id|PCIIO_SPACE_WIN
c_func
(paren
id|cw
)paren
suffix:semicolon
id|offset
op_sub_assign
id|wb
suffix:semicolon
)brace
multiline_comment|/* endif window space match */
)brace
multiline_comment|/* endif window valid and addr match */
)brace
multiline_comment|/* next window unless slot set */
)brace
multiline_comment|/* next func unless slot set */
)brace
multiline_comment|/* next slot unless slot set */
multiline_comment|/* XXX- if slot is still -1, no PCI devices are&n;&t; * decoding here using their standard PCI BASE&n;&t; * registers. This would be a really good place&n;&t; * to cross-coordinate with the pciio PCI&n;&t; * address space allocation routines, to find&n;&t; * out if this address is &quot;allocated&quot; by any of&n;&t; * our subsidiary devices.&n;&t; */
)brace
multiline_comment|/* Scan all piomap records on this PCI bus to update&n;     * the TimeOut Counters on all matching maps. If we&n;     * don&squot;t already know the slot number, take it from&n;     * the first matching piomap. Note that we have to&n;     * compare maps against raw_space and raw_paddr&n;     * since space and offset could already be&n;     * window-relative.&n;     *&n;     * There is a chance that one CPU could update&n;     * through this path, and another CPU could also&n;     * update due to an interrupt. Closing this hole&n;     * would only result in the possibility of some&n;     * errors never getting logged at all, and since the&n;     * use for bp_toc is as a logical test rather than a&n;     * strict count, the excess counts are not a&n;     * problem.&n;     */
r_for
c_loop
(paren
id|cs
op_assign
l_int|0
suffix:semicolon
id|cs
OL
l_int|8
suffix:semicolon
op_increment
id|cs
)paren
(brace
r_int
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|cf
op_assign
l_int|0
suffix:semicolon
id|cf
OL
id|nf
suffix:semicolon
id|cf
op_increment
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|cf
)braket
suffix:semicolon
id|pcibr_piomap_t
id|map
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|pcibr_info-&gt;f_piomap
suffix:semicolon
id|map
op_ne
l_int|NULL
suffix:semicolon
id|map
op_assign
id|map-&gt;bp_next
)paren
(brace
id|wx
op_assign
id|map-&gt;bp_space
suffix:semicolon
id|wb
op_assign
id|map-&gt;bp_pciaddr
suffix:semicolon
id|ws
op_assign
id|map-&gt;bp_mapsz
suffix:semicolon
id|cw
op_assign
id|wx
op_minus
id|PCIIO_SPACE_WIN
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cw
OL
l_int|6
)paren
(brace
id|wb
op_add_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_base
suffix:semicolon
id|wx
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_space
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wx
op_eq
id|PCIIO_SPACE_ROM
)paren
(brace
id|wb
op_add_assign
id|pcibr_info-&gt;f_rbase
suffix:semicolon
id|wx
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM32
)paren
op_logical_or
(paren
id|wx
op_eq
id|PCIIO_SPACE_MEM64
)paren
)paren
id|wx
op_assign
id|PCIIO_SPACE_MEM
suffix:semicolon
id|wl
op_assign
id|wb
op_plus
id|ws
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wx
op_eq
id|raw_space
)paren
op_logical_and
(paren
id|raw_paddr
op_ge
id|wb
)paren
op_logical_and
(paren
id|raw_paddr
OL
id|wl
)paren
)paren
(brace
macro_line|#ifdef IRIX
id|atomicAddInt
c_func
(paren
id|map-&gt;bp_toc
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
(brace
id|slot
op_assign
id|cs
suffix:semicolon
id|space
op_assign
id|map-&gt;bp_space
suffix:semicolon
r_if
c_cond
(paren
id|cw
OL
l_int|6
)paren
id|offset
op_sub_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|cs
)braket
dot
id|bss_window
(braket
id|cw
)braket
dot
id|bssw_base
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|space
op_ne
id|PCIIO_SPACE_NONE
)paren
(brace
r_if
c_cond
(paren
id|slot
op_ne
id|PCIIO_SLOT_NONE
)paren
(brace
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|func
op_ne
id|PCIIO_FUNC_NONE
)paren
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
id|func
)paren
)paren
suffix:semicolon
r_else
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|func
op_ne
id|PCIIO_FUNC_NONE
)paren
(brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
id|func
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|slot
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busspace
comma
id|space
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busaddr
comma
id|offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVPROBE
)paren
(brace
multiline_comment|/*&n;&t; * During probing, we don&squot;t really care what the&n;&t; * error is. Clean up the error in Bridge, notify&n;&t; * subsidiary devices, and return success.&n;&t; */
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft
comma
id|error_code
)paren
suffix:semicolon
multiline_comment|/* if appropriate, give the error handler for this slot&n;&t; * a shot at this probe access as well.&n;&t; */
r_return
(paren
id|slot
op_eq
id|PCIIO_SLOT_NONE
)paren
ques
c_cond
id|IOERROR_HANDLED
suffix:colon
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we don&squot;t know what &quot;PCI SPACE&quot; the access&n;     * was targeting, we may have problems at the&n;     * Bridge itself. Don&squot;t touch any bridge registers,&n;     * and do complain loudly.&n;     */
r_if
c_cond
(paren
id|space
op_eq
id|PCIIO_SPACE_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XIO Bus Error at %s&bslash;n&quot;
l_string|&quot;&bslash;taccess to XIO bus offset 0x%lx&bslash;n&quot;
l_string|&quot;&bslash;tdoes not correspond to any PCI address&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
comma
id|bad_xaddr
)paren
suffix:semicolon
multiline_comment|/* caller will dump contents of ioe struct */
r_return
id|IOERROR_XTALKLEVEL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Read the PCI Bridge error log registers.&n;     */
id|bridge_int_status
op_assign
id|bridge-&gt;b_int_status
suffix:semicolon
id|bridge_pci_err_upper
op_assign
id|bridge-&gt;b_pci_err_upper
suffix:semicolon
id|bridge_pci_err_lower
op_assign
id|bridge-&gt;b_pci_err_lower
suffix:semicolon
id|bridge_pci_err_addr
op_assign
id|bridge_pci_err_lower
op_or
(paren
(paren
(paren
id|iopaddr_t
)paren
id|bridge_pci_err_upper
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
multiline_comment|/*&n;     * Actual PCI Error handling situation.&n;     * Typically happens when a user level process accesses&n;     * PCI space, and it causes some error.&n;     *&n;     * Due to PCI Bridge implementation, we get two indication&n;     * for a read error: an interrupt and a Bus error.&n;     * We like to handle read error in the bus error context.&n;     * But the interrupt comes and goes before bus error&n;     * could make much progress. (NOTE: interrupd does&n;     * come in _after_ bus error processing starts. But it&squot;s&n;     * completed by the time bus error code reaches PCI PIO&n;     * error handling.&n;     * Similarly write error results in just an interrupt,&n;     * and error handling has to be done at interrupt level.&n;     * There is no way to distinguish at interrupt time, if an&n;     * error interrupt is due to read/write error..&n;     */
multiline_comment|/* We know the xtalk addr, the raw pci bus space,&n;     * the raw pci bus address, the decoded pci bus&n;     * space, the offset within that space, and the&n;     * decoded pci slot (which may be &quot;PCIIO_SLOT_NONE&quot; if no slot&n;     * is known to be involved).&n;     */
multiline_comment|/*&n;     * Hand the error off to the handler registered&n;     * for the slot that should have decoded the error,&n;     * or to generic PCI handling (if pciio decides that&n;     * such is appropriate).&n;     */
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
multiline_comment|/* Generate a generic message for IOERROR_UNHANDLED&n;&t; * since the subsidiary handlers were silent, and&n;&t; * did no recovery.&n;&t; */
r_if
c_cond
(paren
id|retval
op_eq
id|IOERROR_UNHANDLED
)paren
(brace
id|retval
op_assign
id|IOERROR_PANIC
suffix:semicolon
multiline_comment|/* we may or may not want to print some of this,&n;&t;     * depending on debug level and which error code.&n;&t;     */
id|PRINT_ALERT
c_func
(paren
l_string|&quot;PIO Error on PCI Bus %s&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
multiline_comment|/* this decodes part of the ioe; our caller&n;&t;     * will dump the raw details in DEBUG and&n;&t;     * kdebug kernels.&n;&t;     */
id|BEM_ADD_IOE
c_func
(paren
id|ioe
)paren
suffix:semicolon
)brace
macro_line|#if defined(FORCE_ERRORS)
r_if
c_cond
(paren
l_int|0
)paren
(brace
macro_line|#elif !DEBUG
r_if
c_cond
(paren
id|kdebug
)paren
(brace
macro_line|#endif
multiline_comment|/*&n;&t;       * dump raw data from bridge&n;&t;     */
id|BEM_ADD_STR
c_func
(paren
l_string|&quot;DEBUG DATA -- raw info from Bridge ASIC:&bslash;n&quot;
)paren
suffix:semicolon
id|BEM_ADD_REG
c_func
(paren
id|bridge_int_status
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|bridge_pci_err_upper
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|bridge_pci_err_lower
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|bridge_pci_err_addr
)paren
suffix:semicolon
id|BEM_ADD_SPC
c_func
(paren
id|raw_space
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|raw_paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
(brace
macro_line|#ifdef colin
id|slot
op_assign
id|pciio_widgetdev_slot_get
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
suffix:semicolon
id|func
op_assign
id|pciio_widgetdev_func_get
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
suffix:semicolon
macro_line|#else
id|slot
op_assign
op_minus
l_int|1
suffix:semicolon
id|func
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|slot
OL
l_int|8
)paren
(brace
macro_line|#ifdef SUPPORT_SGI_CMN_ERR_STUFF
id|bridgereg_t
id|device
op_assign
id|bridge-&gt;b_device
(braket
id|slot
)braket
dot
id|reg
suffix:semicolon
macro_line|#endif
id|BEM_ADD_VAR
c_func
(paren
id|slot
)paren
suffix:semicolon
id|BEM_ADD_VAR
c_func
(paren
id|func
)paren
suffix:semicolon
id|BEM_ADD_REG
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
)brace
macro_line|#if !DEBUG || defined(FORCE_ERRORS)
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Since error could not be handled at lower level,&n;&t; * error data logged has not  been cleared.&n;&t; * Clean up errors, and&n;&t; * re-enable bridge to interrupt on error conditions.&n;&t; * NOTE: Wheather we get the interrupt on PCI_ABORT or not is&n;&t; * dependent on INT_ENABLE register. This write just makes sure&n;&t; * that if the interrupt was enabled, we do get the interrupt.&n;&t; *&n;&t; * CAUTION: Resetting bit BRIDGE_IRR_PCI_GRP_CLR, acknowledges&n;&t; *      a group of interrupts. If while handling this error,&n;&t; *      some other error has occurred, that would be&n;&t; *      implicitly cleared by this write.&n;&t; *      Need a way to ensure we don&squot;t inadvertently clear some&n;&t; *      other errors.&n;&t; */
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|IOERROR_FIELDVALID
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mode
op_eq
id|MODE_DEVUSERERROR
)paren
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft
comma
id|error_code
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * bridge_dmaerror&n; *      Some error was identified in a DMA transaction.&n; *      This routine will identify the &lt;device, address&gt; that caused the error,&n; *      and try to invoke the appropriate bus service to handle this.&n; */
DECL|macro|BRIDGE_DMA_READ_ERROR
mdefine_line|#define BRIDGE_DMA_READ_ERROR (BRIDGE_ISR_RESP_XTLK_ERR|BRIDGE_ISR_XREAD_REQ_TIMEOUT)
r_int
DECL|function|pcibr_dmard_error
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|bus_lowaddr
comma
id|bus_uppraddr
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|bufnum
suffix:semicolon
multiline_comment|/*&n;     * In case of DMA errors, bridge should have logged the&n;     * address that caused the error.&n;     * Look up the address, in the bridge error registers, and&n;     * take appropriate action&n;     */
macro_line|#ifdef colin
id|ASSERT
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetnum
)paren
op_eq
id|pcibr_soft-&gt;bs_xid
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bridge
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * read error log registers&n;     */
id|bus_lowaddr
op_assign
id|bridge-&gt;b_wid_resp_lower
suffix:semicolon
id|bus_uppraddr
op_assign
id|bridge-&gt;b_wid_resp_upper
suffix:semicolon
id|bufnum
op_assign
id|BRIDGE_RESP_ERRUPPR_BUFNUM
c_func
(paren
id|bus_uppraddr
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
comma
id|pciio_widgetdev_create
c_func
(paren
id|BRIDGE_RESP_ERRUPPR_DEVICE
c_func
(paren
id|bus_uppraddr
)paren
comma
l_int|0
)paren
)paren
suffix:semicolon
id|IOERROR_SETVALUE
c_func
(paren
id|ioe
comma
id|busaddr
comma
(paren
id|bus_lowaddr
op_or
(paren
(paren
id|iopaddr_t
)paren
(paren
id|bus_uppraddr
op_amp
id|BRIDGE_ERRUPPR_ADDRMASK
)paren
op_lshift
l_int|32
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * need to ensure that the xtalk address in ioe&n;     * maps to PCI error address read from bridge.&n;     * How to convert PCI address back to Xtalk address ?&n;     * (better idea: convert XTalk address to PCI address&n;     * and then do the compare!)&n;     */
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
macro_line|#ifdef colin
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
)paren
suffix:semicolon
macro_line|#else
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Re-enable bridge to interrupt on BRIDGE_IRR_RESP_BUF_GRP_CLR&n;     * NOTE: Wheather we get the interrupt on BRIDGE_IRR_RESP_BUF_GRP_CLR or&n;     * not is dependent on INT_ENABLE register. This write just makes sure&n;     * that if the interrupt was enabled, we do get the interrupt.&n;     */
id|bridge-&gt;b_int_rst_stat
op_assign
id|BRIDGE_IRR_RESP_BUF_GRP_CLR
suffix:semicolon
multiline_comment|/*&n;     * Also, release the &quot;bufnum&quot; back to buffer pool that could be re-used.&n;     * This is done by &quot;disabling&quot; the buffer for a moment, then restoring&n;     * the original assignment.&n;     */
(brace
id|reg_p
id|regp
suffix:semicolon
id|bridgereg_t
id|regv
suffix:semicolon
id|bridgereg_t
id|mask
suffix:semicolon
id|regp
op_assign
(paren
id|bufnum
op_amp
l_int|1
)paren
ques
c_cond
op_amp
id|bridge-&gt;b_odd_resp
suffix:colon
op_amp
id|bridge-&gt;b_even_resp
suffix:semicolon
id|mask
op_assign
l_int|0xF
op_lshift
(paren
(paren
id|bufnum
op_rshift
l_int|1
)paren
op_star
l_int|4
)paren
suffix:semicolon
id|regv
op_assign
op_star
id|regp
suffix:semicolon
op_star
id|regp
op_assign
id|regv
op_amp
op_complement
id|mask
suffix:semicolon
op_star
id|regp
op_assign
id|regv
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pcibr_dmawr_error:&n; *      Handle a dma write error caused by a device attached to this bridge.&n; *&n; *      ioe has the widgetnum, widgetdev, and memaddr fields updated&n; *      But we don&squot;t know the PCI address that corresponds to &quot;memaddr&quot;&n; *      nor do we know which device driver is generating this address.&n; *&n; *      There is no easy way to find out the PCI address(es) that map&n; *      to a specific system memory address. Bus handling code is also&n; *      of not much help, since they don&squot;t keep track of the DMA mapping&n; *      that have been handed out.&n; *      So it&squot;s a dead-end at this time.&n; *&n; *      If translation is available, we could invoke the error handling&n; *      interface of the device driver.&n; */
multiline_comment|/*ARGSUSED */
r_int
DECL|function|pcibr_dmawr_error
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|devfs_handle_t
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|pciio_error_handler
c_func
(paren
id|pcibr_vhdl
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|retval
op_ne
id|IOERROR_HANDLED
)paren
(brace
id|pcibr_device_disable
c_func
(paren
id|pcibr_soft
comma
id|pciio_widgetdev_slot_get
c_func
(paren
id|IOERROR_GETVALUE
c_func
(paren
id|ioe
comma
id|widgetdev
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Bridge error handler.&n; *      Interface to handle all errors that involve bridge in some way.&n; *&n; *      This normally gets called from xtalk error handler.&n; *      ioe has different set of fields set depending on the error that&n; *      was encountered. So, we have a bit field indicating which of the&n; *      fields are valid.&n; *&n; * NOTE: This routine could be operating in interrupt context. So,&n; *      don&squot;t try to sleep here (till interrupt threads work!!)&n; */
id|LOCAL
r_int
DECL|function|pcibr_error_handler
id|pcibr_error_handler
c_func
(paren
id|error_handler_arg_t
id|einfo
comma
r_int
id|error_code
comma
id|ioerror_mode_t
id|mode
comma
id|ioerror_t
op_star
id|ioe
)paren
(brace
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
r_int
id|retval
op_assign
id|IOERROR_BADERRORCODE
suffix:semicolon
id|devfs_handle_t
id|xconn_vhdl
comma
id|pcibr_vhdl
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IO_ERROR_HANDLING)
id|error_state_t
id|e_state
suffix:semicolon
macro_line|#endif
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|einfo
suffix:semicolon
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
id|pcibr_vhdl
op_assign
id|pcibr_soft-&gt;bs_vhdl
suffix:semicolon
macro_line|#if defined(CONFIG_SGI_IO_ERROR_HANDLING)
id|e_state
op_assign
id|error_state_get
c_func
(paren
id|xconn_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_state_set
c_func
(paren
id|pcibr_vhdl
comma
id|e_state
)paren
op_eq
id|ERROR_RETURN_CODE_CANNOT_SET_STATE
)paren
r_return
id|IOERROR_UNHANDLED
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we are in the action handling phase clean out the error state&n;     * on the xswitch.&n;     */
macro_line|#if defined(CONFIG_SGI_IO_ERROR_HANDLING)
r_if
c_cond
(paren
id|e_state
op_eq
id|ERROR_STATE_ACTION
)paren
(paren
r_void
)paren
id|error_state_set
c_func
(paren
id|xconn_vhdl
comma
id|ERROR_STATE_NONE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG &amp;&amp; ERROR_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: pcibr_error_handler&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_name
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|pcibr_soft
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
id|retval
op_assign
id|pcibr_pioerror
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|mode
comma
id|ioe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_DMA
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_READ
)paren
(brace
multiline_comment|/*&n;&t;     * DMA read error occurs when a device attached to the bridge&n;&t;     * tries to read some data from system memory, and this&n;&t;     * either results in a timeout or access error.&n;&t;     * First case is indicated by the bit &quot;XREAD_REQ_TOUT&quot;&n;&t;     * and second case by &quot;RESP_XTALK_ERROR&quot; bit in bridge error&n;&t;     * interrupt status register.&n;&t;     *&n;&t;     * pcibr_error_intr_handler would get invoked first, and it has&n;&t;     * the responsibility of calling pcibr_error_handler with&n;&t;     * suitable parameters.&n;&t;     */
id|retval
op_assign
id|pcibr_dmard_error
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|MODE_DEVERROR
comma
id|ioe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_amp
id|IOECODE_WRITE
)paren
(brace
multiline_comment|/*&n;&t;     * A device attached to this bridge has been generating&n;&t;     * bad DMA writes. Find out the device attached, and&n;&t;     * slap on it&squot;s wrist.&n;&t;     */
id|retval
op_assign
id|pcibr_dmawr_error
c_func
(paren
id|pcibr_soft
comma
id|error_code
comma
id|MODE_DEVERROR
comma
id|ioe
)paren
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Reenable a device after handling the error.&n; * This is called by the lower layers when they wish to be reenabled&n; * after an error.&n; * Note that each layer would be calling the previous layer to reenable&n; * first, before going ahead with their own re-enabling.&n; */
r_int
DECL|function|pcibr_error_devenable
id|pcibr_error_devenable
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
id|error_code
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error_code
op_amp
id|IOECODE_PIO
)paren
suffix:semicolon
multiline_comment|/* If the error is not known to be a write,&n;     * we have to call devenable.&n;     * write errors are isolated to the bridge.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|error_code
op_amp
id|IOECODE_WRITE
)paren
)paren
(brace
id|devfs_handle_t
id|xconn_vhdl
op_assign
id|pcibr_soft-&gt;bs_conn
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|xtalk_error_devenable
c_func
(paren
id|xconn_vhdl
comma
id|pciio_slot
comma
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|IOERROR_HANDLED
)paren
r_return
id|rc
suffix:semicolon
)brace
id|pcibr_error_cleanup
c_func
(paren
id|pcibr_soft
comma
id|error_code
)paren
suffix:semicolon
r_return
id|IOERROR_HANDLED
suffix:semicolon
)brace
multiline_comment|/* =====================================================================&n; *    CONFIGURATION MANAGEMENT&n; */
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_provider_startup
id|pcibr_provider_startup
c_func
(paren
id|devfs_handle_t
id|pcibr
)paren
(brace
)brace
multiline_comment|/*ARGSUSED */
r_void
DECL|function|pcibr_provider_shutdown
id|pcibr_provider_shutdown
c_func
(paren
id|devfs_handle_t
id|pcibr
)paren
(brace
)brace
r_int
DECL|function|pcibr_reset
id|pcibr_reset
c_func
(paren
id|devfs_handle_t
id|conn
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|conn
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridgereg_t
id|ctlreg
suffix:semicolon
r_int
id|cfgctl
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|f
comma
id|nf
suffix:semicolon
id|pcibr_info_h
id|pcibr_infoh
suffix:semicolon
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
r_int
id|win
suffix:semicolon
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|has_host
)paren
(brace
id|pciio_slot
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|host_slot
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_infos
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pciio_slot
OL
l_int|4
)paren
(brace
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|nf
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_ninfo
suffix:semicolon
id|pcibr_infoh
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_infos
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|nf
suffix:semicolon
op_increment
id|f
)paren
r_if
c_cond
(paren
id|pcibr_infoh
(braket
id|f
)braket
)paren
id|cfgctl
(braket
id|f
)braket
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|pciio_slot
)braket
dot
id|f
(braket
id|f
)braket
dot
id|l
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
suffix:semicolon
id|ctlreg
op_assign
id|bridge-&gt;b_wid_control
suffix:semicolon
id|bridge-&gt;b_wid_control
op_assign
id|ctlreg
op_or
id|BRIDGE_CTRL_RST
c_func
(paren
id|pciio_slot
)paren
suffix:semicolon
multiline_comment|/* XXX delay? */
id|bridge-&gt;b_wid_control
op_assign
id|ctlreg
suffix:semicolon
multiline_comment|/* XXX delay? */
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|nf
suffix:semicolon
op_increment
id|f
)paren
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|f
)braket
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|f
)braket
)paren
)paren
macro_line|#endif
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|6
suffix:semicolon
op_increment
id|win
)paren
r_if
c_cond
(paren
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
op_ne
l_int|0
)paren
id|bridge-&gt;b_type0_cfg_dev
(braket
id|pciio_slot
)braket
dot
id|f
(braket
id|f
)braket
dot
id|l
(braket
id|PCI_CFG_BASE_ADDR
c_func
(paren
id|win
)paren
op_div
l_int|4
)braket
op_assign
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|nf
suffix:semicolon
op_increment
id|f
)paren
r_if
c_cond
(paren
id|pcibr_infoh
(braket
id|f
)braket
)paren
id|bridge-&gt;b_type0_cfg_dev
(braket
id|pciio_slot
)braket
dot
id|f
(braket
id|f
)braket
dot
id|l
(braket
id|PCI_CFG_COMMAND
op_div
l_int|4
)braket
op_assign
id|cfgctl
(braket
id|f
)braket
suffix:semicolon
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|PRINT_WARNING
c_func
(paren
l_string|&quot;%v: pcibr_reset unimplemented for slot %d&bslash;n&quot;
comma
id|conn
comma
id|pciio_slot
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pciio_endian_t
DECL|function|pcibr_endian_set
id|pcibr_endian_set
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;     * Bridge supports hardware swapping; so we can always&n;     * arrange for the caller&squot;s desired endianness.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
r_if
c_cond
(paren
id|device_end
op_ne
id|desired_end
)paren
id|devreg
op_or_assign
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
r_else
id|devreg
op_and_assign
op_complement
id|BRIDGE_DEV_SWAP_BITS
suffix:semicolon
multiline_comment|/* NOTE- if we ever put SWAP bits&n;     * onto the disabled list, we will&n;     * have to change the logic here.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DEV_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): 0x%p&bslash;n&quot;
comma
id|pciio_slot
comma
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
)paren
suffix:semicolon
macro_line|#endif
r_return
id|desired_end
suffix:semicolon
)brace
multiline_comment|/* This (re)sets the GBR and REALTIME bits and also keeps track of how&n; * many sets are outstanding. Reset succeeds only if the number of outstanding&n; * sets == 1.&n; */
r_int
DECL|function|pcibr_priority_bits_set
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|pciio_slot
comma
id|pciio_priority_t
id|device_prio
)paren
(brace
r_int
id|s
suffix:semicolon
r_int
op_star
id|counter
suffix:semicolon
id|bridgereg_t
id|rtbits
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|rc
op_assign
id|PRIO_SUCCESS
suffix:semicolon
multiline_comment|/* in dual-slot configurations, the host and the&n;     * guest have separate DMA resources, so they&n;     * have separate requirements for priority bits.&n;     */
id|counter
op_assign
op_amp
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_pri_uctr
)paren
suffix:semicolon
multiline_comment|/*&n;     * Bridge supports PCI notions of LOW and HIGH priority&n;     * arbitration rings via a &quot;REAL_TIME&quot; bit in the per-device&n;     * Bridge register. The &quot;GBR&quot; bit controls access to the GBR&n;     * ring on the xbow. These two bits are (re)set together.&n;     *&n;     * XXX- Bug in Rev B Bridge Si:&n;     * Symptom: Prefetcher starts operating incorrectly. This happens&n;     * due to corruption of the address storage ram in the prefetcher&n;     * when a non-real time pci request is pulled and a real-time one is&n;     * put in it&squot;s place. Workaround: Use only a single arbitration ring&n;     * on pci bus. GBR and RR can still be uniquely used per&n;     * device. NETLIST MERGE DONE, WILL BE FIXED IN REV C.&n;     */
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_rev_num
op_ne
id|BRIDGE_PART_REV_B
)paren
id|rtbits
op_or_assign
id|BRIDGE_DEV_RT
suffix:semicolon
multiline_comment|/* NOTE- if we ever put DEV_RT or DEV_GBR on&n;     * the disabled list, we will have to take&n;     * it into account here.&n;     */
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
r_if
c_cond
(paren
id|device_prio
op_eq
id|PCI_PRIO_HIGH
)paren
(brace
macro_line|#ifdef IRIX
r_if
c_cond
(paren
op_increment
op_star
id|counter
op_eq
l_int|1
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
op_increment
op_star
id|counter
op_eq
l_int|1
)paren
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
id|rtbits
)paren
id|devreg
op_or_assign
id|rtbits
suffix:semicolon
r_else
id|rc
op_assign
id|PRIO_FAIL
suffix:semicolon
macro_line|#ifndef IRIX
)brace
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|device_prio
op_eq
id|PCI_PRIO_LOW
)paren
(brace
r_if
c_cond
(paren
op_star
id|counter
op_le
l_int|0
)paren
id|rc
op_assign
id|PRIO_FAIL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_decrement
op_star
id|counter
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|rtbits
)paren
id|devreg
op_and_assign
op_complement
id|rtbits
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|pciio_priority_t
DECL|function|pcibr_priority_set
id|pcibr_priority_set
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|pciio_priority_t
id|device_prio
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
(paren
r_void
)paren
id|pcibr_priority_bits_set
c_func
(paren
id|pcibr_soft
comma
id|pciio_slot
comma
id|device_prio
)paren
suffix:semicolon
r_return
id|device_prio
suffix:semicolon
)brace
multiline_comment|/*&n; * Interfaces to allow special (e.g. SGI) drivers to set/clear&n; * Bridge-specific device flags.  Many flags are modified through&n; * PCI-generic interfaces; we don&squot;t allow them to be directly&n; * manipulated here.  Only flags that at this point seem pretty&n; * Bridge-specific can be set through these special interfaces.&n; * We may add more flags as the need arises, or remove flags and&n; * create PCI-generic interfaces as the need arises.&n; *&n; * Returns 0 on failure, 1 on success&n; */
r_int
DECL|function|pcibr_device_flags_set
id|pcibr_device_flags_set
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
id|pcibr_device_flags_t
id|flags
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
op_assign
id|pciio_info_slot_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
id|bridgereg_t
id|set
op_assign
l_int|0
suffix:semicolon
id|bridgereg_t
id|clr
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|PCIBR_DEVICE_FLAGS
)paren
op_eq
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PMU_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PMU_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_WRITE_GATHER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_DIR_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOWRITE_GATHER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_DIR_WRGA_EN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PREFETCH
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPREFETCH
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PREF
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_PRECISE
)paren
id|set
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOPRECISE
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_PRECISE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_BARRIER
)paren
id|set
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NOBARRIER
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_64BIT
)paren
id|set
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PCIBR_NO64BIT
)paren
id|clr
op_or_assign
id|BRIDGE_DEV_DEV_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|set
op_logical_or
id|clr
)paren
(brace
id|bridgereg_t
id|devreg
suffix:semicolon
r_int
id|s
suffix:semicolon
id|s
op_assign
id|pcibr_lock
c_func
(paren
id|pcibr_soft
)paren
suffix:semicolon
id|devreg
op_assign
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
suffix:semicolon
macro_line|#ifdef IRIX
id|devreg
op_assign
id|devreg
op_amp
op_complement
id|clr
op_or
id|set
suffix:semicolon
macro_line|#else
id|devreg
op_assign
(paren
id|devreg
op_amp
op_complement
id|clr
)paren
op_or
id|set
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_ne
id|devreg
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
op_assign
id|devreg
suffix:semicolon
id|pcibr_soft-&gt;bs_slot
(braket
id|pciio_slot
)braket
dot
id|bss_device
op_assign
id|devreg
suffix:semicolon
id|bridge-&gt;b_wid_tflush
suffix:semicolon
multiline_comment|/* wait until Bridge PIO complete */
)brace
id|pcibr_unlock
c_func
(paren
id|pcibr_soft
comma
id|s
)paren
suffix:semicolon
macro_line|#if DEBUG &amp;&amp; PCIBR_DEV_DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr Device(%d): %R&bslash;n&quot;
comma
id|pciio_slot
comma
id|bridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|regbridge-&gt;b_device
(braket
id|pciio_slot
)braket
dot
id|reg
comma
id|device_bits
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef LITTLE_ENDIAN
multiline_comment|/*&n; * on sn-ia we need to twiddle the addresses going out&n; * the pci bus because we use the unswizzled synergy space&n; * (the alternative is to use the swizzled synergy space&n; * and byte swap the data)&n; */
DECL|macro|CB
mdefine_line|#define&t;CB(b,r)&t;(((volatile uint8_t *) b)[((r)^4)])
DECL|macro|CS
mdefine_line|#define&t;CS(b,r)&t;(((volatile uint16_t *) b)[((r^4)/2)])
DECL|macro|CW
mdefine_line|#define&t;CW(b,r)&t;(((volatile uint32_t *) b)[((r^4)/4)])
macro_line|#else
DECL|macro|CB
mdefine_line|#define&t;CB(b,r)&t;(((volatile uint8_t *) cfgbase)[(r)^3])
DECL|macro|CS
mdefine_line|#define&t;CS(b,r)&t;(((volatile uint16_t *) cfgbase)[((r)/2)^1])
DECL|macro|CW
mdefine_line|#define&t;CW(b,r)&t;(((volatile uint32_t *) cfgbase)[(r)/4])
macro_line|#endif /* LITTLE_ENDIAN */
id|LOCAL
id|cfg_p
DECL|function|pcibr_config_addr
id|pcibr_config_addr
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_int
id|reg
)paren
(brace
id|pcibr_info_t
id|pcibr_info
suffix:semicolon
id|pciio_slot_t
id|pciio_slot
suffix:semicolon
id|pciio_function_t
id|pciio_func
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
id|cfg_p
id|cfgbase
op_assign
(paren
id|cfg_p
)paren
l_int|0
suffix:semicolon
id|pcibr_info
op_assign
id|pcibr_info_get
c_func
(paren
id|conn
)paren
suffix:semicolon
id|pciio_slot
op_assign
id|pcibr_info-&gt;f_slot
suffix:semicolon
r_if
c_cond
(paren
id|pciio_slot
op_eq
id|PCIIO_SLOT_NONE
)paren
id|pciio_slot
op_assign
id|PCI_TYPE1_SLOT
c_func
(paren
id|reg
)paren
suffix:semicolon
id|pciio_func
op_assign
id|pcibr_info-&gt;f_func
suffix:semicolon
r_if
c_cond
(paren
id|pciio_func
op_eq
id|PCIIO_FUNC_NONE
)paren
id|pciio_func
op_assign
id|PCI_TYPE1_FUNC
c_func
(paren
id|reg
)paren
suffix:semicolon
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pcibr_info-&gt;f_mfast
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibr_soft_t
)paren
l_int|0
op_ne
id|pcibr_soft
)paren
(brace
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bridge_t
op_star
)paren
l_int|0
op_ne
id|bridge
)paren
(brace
id|cfgbase
op_assign
id|bridge-&gt;b_type0_cfg_dev
(braket
id|pciio_slot
)braket
dot
id|f
(braket
id|pciio_func
)braket
dot
id|l
suffix:semicolon
)brace
)brace
r_return
id|cfgbase
suffix:semicolon
)brace
r_uint64
DECL|function|pcibr_config_get
id|pcibr_config_get
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_int
id|reg
comma
r_int
id|size
)paren
(brace
r_return
id|do_pcibr_config_get
c_func
(paren
id|pcibr_config_addr
c_func
(paren
id|conn
comma
id|reg
)paren
comma
id|PCI_TYPE1_REG
c_func
(paren
id|reg
)paren
comma
id|size
)paren
suffix:semicolon
)brace
id|LOCAL
r_uint64
DECL|function|do_pcibr_config_get
id|do_pcibr_config_get
c_func
(paren
id|cfg_p
id|cfgbase
comma
r_int
id|reg
comma
r_int
id|size
)paren
(brace
r_int
id|value
suffix:semicolon
id|value
op_assign
id|CW
c_func
(paren
id|cfgbase
comma
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|3
)paren
id|value
op_rshift_assign
l_int|8
op_star
(paren
id|reg
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|4
)paren
id|value
op_and_assign
(paren
l_int|1
op_lshift
(paren
l_int|8
op_star
id|size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_void
DECL|function|pcibr_config_set
id|pcibr_config_set
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_int
id|reg
comma
r_int
id|size
comma
r_uint64
id|value
)paren
(brace
id|do_pcibr_config_set
c_func
(paren
id|pcibr_config_addr
c_func
(paren
id|conn
comma
id|reg
)paren
comma
id|PCI_TYPE1_REG
c_func
(paren
id|reg
)paren
comma
id|size
comma
id|value
)paren
suffix:semicolon
)brace
id|LOCAL
r_void
DECL|function|do_pcibr_config_set
id|do_pcibr_config_set
c_func
(paren
id|cfg_p
id|cfgbase
comma
r_int
id|reg
comma
r_int
id|size
comma
r_uint64
id|value
)paren
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
id|CB
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|reg
op_amp
l_int|1
)paren
(brace
id|CB
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
id|CB
c_func
(paren
id|cfgbase
comma
id|reg
op_plus
l_int|1
)paren
op_assign
id|value
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
id|CS
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|reg
op_amp
l_int|1
)paren
(brace
id|CB
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
id|CS
c_func
(paren
id|cfgbase
comma
id|reg
op_plus
l_int|1
)paren
op_assign
id|value
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|CS
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
id|CB
c_func
(paren
id|cfgbase
comma
id|reg
op_plus
l_int|2
)paren
op_assign
id|value
op_rshift
l_int|16
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|CW
c_func
(paren
id|cfgbase
comma
id|reg
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|pcibr_provider
id|pciio_provider_t
id|pcibr_provider
op_assign
(brace
(paren
id|pciio_piomap_alloc_f
op_star
)paren
id|pcibr_piomap_alloc
comma
(paren
id|pciio_piomap_free_f
op_star
)paren
id|pcibr_piomap_free
comma
(paren
id|pciio_piomap_addr_f
op_star
)paren
id|pcibr_piomap_addr
comma
(paren
id|pciio_piomap_done_f
op_star
)paren
id|pcibr_piomap_done
comma
(paren
id|pciio_piotrans_addr_f
op_star
)paren
id|pcibr_piotrans_addr
comma
(paren
id|pciio_piospace_alloc_f
op_star
)paren
id|pcibr_piospace_alloc
comma
(paren
id|pciio_piospace_free_f
op_star
)paren
id|pcibr_piospace_free
comma
(paren
id|pciio_dmamap_alloc_f
op_star
)paren
id|pcibr_dmamap_alloc
comma
(paren
id|pciio_dmamap_free_f
op_star
)paren
id|pcibr_dmamap_free
comma
(paren
id|pciio_dmamap_addr_f
op_star
)paren
id|pcibr_dmamap_addr
comma
(paren
id|pciio_dmamap_list_f
op_star
)paren
id|pcibr_dmamap_list
comma
(paren
id|pciio_dmamap_done_f
op_star
)paren
id|pcibr_dmamap_done
comma
(paren
id|pciio_dmatrans_addr_f
op_star
)paren
id|pcibr_dmatrans_addr
comma
(paren
id|pciio_dmatrans_list_f
op_star
)paren
id|pcibr_dmatrans_list
comma
(paren
id|pciio_dmamap_drain_f
op_star
)paren
id|pcibr_dmamap_drain
comma
(paren
id|pciio_dmaaddr_drain_f
op_star
)paren
id|pcibr_dmaaddr_drain
comma
(paren
id|pciio_dmalist_drain_f
op_star
)paren
id|pcibr_dmalist_drain
comma
(paren
id|pciio_intr_alloc_f
op_star
)paren
id|pcibr_intr_alloc
comma
(paren
id|pciio_intr_free_f
op_star
)paren
id|pcibr_intr_free
comma
(paren
id|pciio_intr_connect_f
op_star
)paren
id|pcibr_intr_connect
comma
(paren
id|pciio_intr_disconnect_f
op_star
)paren
id|pcibr_intr_disconnect
comma
(paren
id|pciio_intr_cpu_get_f
op_star
)paren
id|pcibr_intr_cpu_get
comma
(paren
id|pciio_provider_startup_f
op_star
)paren
id|pcibr_provider_startup
comma
(paren
id|pciio_provider_shutdown_f
op_star
)paren
id|pcibr_provider_shutdown
comma
(paren
id|pciio_reset_f
op_star
)paren
id|pcibr_reset
comma
(paren
id|pciio_write_gather_flush_f
op_star
)paren
id|pcibr_write_gather_flush
comma
(paren
id|pciio_endian_set_f
op_star
)paren
id|pcibr_endian_set
comma
(paren
id|pciio_priority_set_f
op_star
)paren
id|pcibr_priority_set
comma
(paren
id|pciio_config_get_f
op_star
)paren
id|pcibr_config_get
comma
(paren
id|pciio_config_set_f
op_star
)paren
id|pcibr_config_set
comma
(paren
id|pciio_error_devenable_f
op_star
)paren
id|pcibr_error_devenable
comma
(paren
id|pciio_error_extract_f
op_star
)paren
id|pcibr_error_extract
comma
)brace
suffix:semicolon
id|LOCAL
id|pcibr_hints_t
DECL|function|pcibr_hints_get
id|pcibr_hints_get
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|alloc
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
id|graph_error_t
id|rv
suffix:semicolon
id|pcibr_hints_t
id|hint
suffix:semicolon
id|rv
op_assign
id|hwgraph_info_get_LBL
c_func
(paren
id|xconn_vhdl
comma
id|INFO_LBL_PCIBR_HINTS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alloc
op_logical_and
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
)paren
(brace
id|NEW
c_func
(paren
id|hint
)paren
suffix:semicolon
id|hint-&gt;rrb_alloc_funct
op_assign
l_int|NULL
suffix:semicolon
id|hint-&gt;ph_intr_bits
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_info_add_LBL
c_func
(paren
id|xconn_vhdl
comma
id|INFO_LBL_PCIBR_HINTS
comma
(paren
id|arbitrary_info_t
)paren
id|hint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
r_goto
id|abnormal_exit
suffix:semicolon
id|rv
op_assign
id|hwgraph_info_get_LBL
c_func
(paren
id|xconn_vhdl
comma
id|INFO_LBL_PCIBR_HINTS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
r_goto
id|abnormal_exit
suffix:semicolon
r_if
c_cond
(paren
id|ainfo
op_ne
(paren
id|arbitrary_info_t
)paren
id|hint
)paren
r_goto
id|abnormal_exit
suffix:semicolon
)brace
r_return
(paren
id|pcibr_hints_t
)paren
id|ainfo
suffix:semicolon
id|abnormal_exit
suffix:colon
macro_line|#ifdef IRIX
id|printf
c_func
(paren
l_string|&quot;SHOULD NOT BE HERE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|DEL
c_func
(paren
id|hint
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|pcibr_hints_fix_some_rrbs
id|pcibr_hints_fix_some_rrbs
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
id|mask
)paren
(brace
id|pcibr_hints_t
id|hint
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
)paren
id|hint-&gt;ph_rrb_fixed
op_assign
id|mask
suffix:semicolon
macro_line|#if DEBUG
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_fix_rrbs: pcibr_hints_get failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|pcibr_hints_fix_rrbs
id|pcibr_hints_fix_rrbs
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
id|pcibr_hints_fix_some_rrbs
c_func
(paren
id|xconn_vhdl
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
r_void
DECL|function|pcibr_hints_dualslot
id|pcibr_hints_dualslot
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
id|pciio_slot_t
id|host
comma
id|pciio_slot_t
id|guest
)paren
(brace
id|pcibr_hints_t
id|hint
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
)paren
id|hint-&gt;ph_host_slot
(braket
id|guest
)braket
op_assign
id|host
op_plus
l_int|1
suffix:semicolon
macro_line|#if DEBUG
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_dualslot: pcibr_hints_get failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|pcibr_hints_intr_bits
id|pcibr_hints_intr_bits
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
id|pcibr_intr_bits_f
op_star
id|xxx_intr_bits
)paren
(brace
id|pcibr_hints_t
id|hint
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
)paren
id|hint-&gt;ph_intr_bits
op_assign
id|xxx_intr_bits
suffix:semicolon
macro_line|#if DEBUG
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_intr_bits: pcibr_hints_get failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|pcibr_set_rrb_callback
id|pcibr_set_rrb_callback
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
id|rrb_alloc_funct_t
id|rrb_alloc_funct
)paren
(brace
id|pcibr_hints_t
id|hint
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
)paren
id|hint-&gt;rrb_alloc_funct
op_assign
id|rrb_alloc_funct
suffix:semicolon
)brace
r_void
DECL|function|pcibr_hints_handsoff
id|pcibr_hints_handsoff
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
)paren
(brace
id|pcibr_hints_t
id|hint
op_assign
id|pcibr_hints_get
c_func
(paren
id|xconn_vhdl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
)paren
id|hint-&gt;ph_hands_off
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG
r_else
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_handsoff: pcibr_hints_get failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|xconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|pcibr_hints_subdevs
id|pcibr_hints_subdevs
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
id|pciio_slot_t
id|slot
comma
r_uint64
id|subdevs
)paren
(brace
id|arbitrary_info_t
id|ainfo
op_assign
l_int|0
suffix:semicolon
r_char
id|sdname
(braket
l_int|16
)braket
suffix:semicolon
id|devfs_handle_t
id|pconn_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
id|sprintf
c_func
(paren
id|sdname
comma
l_string|&quot;pci/%d&quot;
comma
id|slot
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_path_add
c_func
(paren
id|xconn_vhdl
comma
id|sdname
comma
op_amp
id|pconn_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pconn_vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_subdevs: hwgraph_path_create failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p (seeking %s)&bslash;n&quot;
comma
id|xconn_vhdl
comma
id|sdname
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|hwgraph_info_get_LBL
c_func
(paren
id|pconn_vhdl
comma
id|INFO_LBL_SUBDEVS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ainfo
op_eq
l_int|0
)paren
(brace
r_uint64
op_star
id|subdevp
suffix:semicolon
id|NEW
c_func
(paren
id|subdevp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subdevp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_subdevs: subdev ptr alloc failed at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
op_star
id|subdevp
op_assign
id|subdevs
suffix:semicolon
id|hwgraph_info_add_LBL
c_func
(paren
id|pconn_vhdl
comma
id|INFO_LBL_SUBDEVS
comma
(paren
id|arbitrary_info_t
)paren
id|subdevp
)paren
suffix:semicolon
id|hwgraph_info_get_LBL
c_func
(paren
id|pconn_vhdl
comma
id|INFO_LBL_SUBDEVS
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ainfo
op_eq
(paren
id|arbitrary_info_t
)paren
id|subdevp
)paren
r_return
suffix:semicolon
id|DEL
c_func
(paren
id|subdevp
)paren
suffix:semicolon
macro_line|#ifdef IRIX
r_if
c_cond
(paren
id|ainfo
op_eq
l_int|NULL
)paren
macro_line|#else
r_if
c_cond
(paren
id|ainfo
op_eq
(paren
id|arbitrary_info_t
)paren
l_int|NULL
)paren
macro_line|#endif
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_hints_subdevs: null subdevs ptr at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;pcibr_subdevs_get: dup subdev add_LBL at&bslash;n&quot;
l_string|&quot;&bslash;t%p&bslash;n&quot;
comma
id|pconn_vhdl
)paren
suffix:semicolon
macro_line|#endif
)brace
op_star
(paren
r_uint64
op_star
)paren
id|ainfo
op_assign
id|subdevs
suffix:semicolon
)brace
macro_line|#ifdef colin
macro_line|#include &lt;sys/idbg.h&gt;
macro_line|#include &lt;sys/idbgentry.h&gt;
DECL|variable|pci_space
r_char
op_star
id|pci_space
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ROM&quot;
comma
l_string|&quot;IO&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;MEM&quot;
comma
l_string|&quot;MEM32&quot;
comma
l_string|&quot;MEM64&quot;
comma
l_string|&quot;CFG&quot;
comma
l_string|&quot;WIN0&quot;
comma
l_string|&quot;WIN1&quot;
comma
l_string|&quot;WIN2&quot;
comma
l_string|&quot;WIN3&quot;
comma
l_string|&quot;WIN4&quot;
comma
l_string|&quot;WIN5&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;BAD&quot;
)brace
suffix:semicolon
r_void
DECL|function|idbg_pss_func
id|idbg_pss_func
c_func
(paren
id|pcibr_info_h
id|pcibr_infoh
comma
r_int
id|func
)paren
(brace
id|pcibr_info_t
id|pcibr_info
op_assign
id|pcibr_infoh
(braket
id|func
)braket
suffix:semicolon
r_char
id|name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_int
id|win
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibr_info
)paren
r_return
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Per-slot Function Info&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_vertex
)paren
suffix:semicolon
macro_line|#endif
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tSlot Name : %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tPCI Bus : %d &quot;
comma
id|pcibr_info-&gt;f_bus
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Slot : %d &quot;
comma
id|pcibr_info-&gt;f_slot
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Function : %d &quot;
comma
id|pcibr_info-&gt;f_func
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;VendorId : 0x%x &quot;
comma
id|pcibr_info-&gt;f_vendor
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;DeviceId : 0x%x&bslash;n&quot;
comma
id|pcibr_info-&gt;f_device
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_PRINTING_V_FORMAT
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%v&quot;
comma
id|pcibr_info-&gt;f_master
)paren
suffix:semicolon
macro_line|#endif
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tBus provider : %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tProvider Fns : 0x%x &quot;
comma
id|pcibr_info-&gt;f_pops
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Error Handler : 0x%x Arg 0x%x&bslash;n&quot;
comma
id|pcibr_info-&gt;f_efunc
comma
id|pcibr_info-&gt;f_einfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|6
suffix:semicolon
id|win
op_increment
)paren
(brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tBase Reg #%d space %s base 0x%x size 0x%x&bslash;n&quot;
comma
id|win
comma
id|pci_space
(braket
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_space
)braket
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_base
comma
id|pcibr_info-&gt;f_window
(braket
id|win
)braket
dot
id|w_size
)paren
suffix:semicolon
)brace
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tRom base 0x%x size 0x%x&bslash;n&quot;
comma
id|pcibr_info-&gt;f_rbase
comma
id|pcibr_info-&gt;f_rsize
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tInterrupt Bit Map&bslash;n&quot;
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tPCI Int#&bslash;tBridge Pin#&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|win
op_assign
l_int|0
suffix:semicolon
id|win
OL
l_int|4
suffix:semicolon
id|win
op_increment
)paren
id|qprintf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tINT%c&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|win
op_plus
l_char|&squot;A&squot;
comma
id|pcibr_info-&gt;f_ibit
(braket
id|win
)braket
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|idbg_pss_info
id|idbg_pss_info
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
comma
id|pciio_slot_t
id|slot
)paren
(brace
id|pcibr_soft_slot_t
id|pss
suffix:semicolon
r_char
id|slot_conn_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_int
id|func
suffix:semicolon
id|pss
op_assign
op_amp
id|pcibr_soft-&gt;bs_slot
(braket
id|slot
)braket
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;PCI INFRASTRUCTURAL INFO FOR SLOT %d&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tHost Present ? %s &quot;
comma
id|pss-&gt;has_host
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tHost Slot : %d&bslash;n&quot;
comma
id|pss-&gt;host_slot
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|slot_conn_name
comma
l_string|&quot;%v&quot;
comma
id|pss-&gt;slot_conn
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tSlot Conn : %s&bslash;n&quot;
comma
id|slot_conn_name
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;t#Functions : %d&bslash;n&quot;
comma
id|pss-&gt;bss_ninfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
id|pss-&gt;bss_ninfo
suffix:semicolon
id|func
op_increment
)paren
id|idbg_pss_func
c_func
(paren
id|pss-&gt;bss_infos
comma
id|func
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tSpace : %s &quot;
comma
id|pci_space
(braket
id|pss-&gt;bss_devio.bssd_space
)braket
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tBase : 0x%x &quot;
comma
id|pss-&gt;bss_devio.bssd_base
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tShadow Devreg : 0x%x&bslash;n&quot;
comma
id|pss-&gt;bss_device
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tUsage counts : pmu %d d32 %d d64 %d&bslash;n&quot;
comma
id|pss-&gt;bss_pmu_uctr
comma
id|pss-&gt;bss_d32_uctr
comma
id|pss-&gt;bss_d64_uctr
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tDirect Trans Info : d64_base 0x%x d64_flags 0x%x&quot;
l_string|&quot;d32_base 0x%x d32_flags 0x%x&bslash;n&quot;
comma
id|pss-&gt;bss_d64_base
comma
id|pss-&gt;bss_d64_flags
comma
id|pss-&gt;bss_d32_base
comma
id|pss-&gt;bss_d32_flags
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tExt ATEs active ? %s&quot;
comma
id|pss-&gt;bss_ext_ates_active
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot; Command register : 0x%x &quot;
comma
id|pss-&gt;bss_cmd_pointer
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot; Shadow command val : 0x%x&bslash;n&quot;
comma
id|pss-&gt;bss_cmd_shadow
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;&bslash;tRRB Info : Valid %d+%d Reserved %d&bslash;n&quot;
comma
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
)braket
comma
id|pcibr_soft-&gt;bs_rrb_valid
(braket
id|slot
op_plus
id|PCIBR_RRB_SLOT_VIRTUAL
)braket
comma
id|pcibr_soft-&gt;bs_rrb_res
(braket
id|slot
)braket
)paren
suffix:semicolon
)brace
DECL|variable|ips
r_int
id|ips
op_assign
l_int|0
suffix:semicolon
r_void
DECL|function|idbg_pss
id|idbg_pss
c_func
(paren
id|pcibr_soft_t
id|pcibr_soft
)paren
(brace
id|pciio_slot_t
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|ips
op_ge
l_int|0
op_logical_and
id|ips
OL
l_int|8
)paren
id|idbg_pss_info
c_func
(paren
id|pcibr_soft
comma
id|ips
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ips
OL
l_int|0
)paren
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
id|slot
op_increment
)paren
id|idbg_pss_info
c_func
(paren
id|pcibr_soft
comma
id|slot
)paren
suffix:semicolon
r_else
id|qprintf
c_func
(paren
l_string|&quot;Invalid ips %d&bslash;n&quot;
comma
id|ips
)paren
suffix:semicolon
)brace
macro_line|#endif /* colin */
r_int
DECL|function|pcibr_dma_enabled
id|pcibr_dma_enabled
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
(brace
id|pciio_info_t
id|pciio_info
op_assign
id|pciio_info_get
c_func
(paren
id|pconn_vhdl
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|pciio_info_mfast_get
c_func
(paren
id|pciio_info
)paren
suffix:semicolon
r_return
id|xtalk_dma_enabled
c_func
(paren
id|pcibr_soft-&gt;bs_conn
)paren
suffix:semicolon
)brace
eof
