multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2002 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/sn_cpuid.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/labelcl.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xbow.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/eeprom.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xswitch.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalk_private.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalkaddrs.h&gt;
multiline_comment|/* #define IOGRAPH_DEBUG */
macro_line|#ifdef IOGRAPH_DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif /* IOGRAPH_DEBUG */
multiline_comment|/* #define PROBE_TEST */
multiline_comment|/* At most 2 hubs can be connected to an xswitch */
DECL|macro|NUM_XSWITCH_VOLUNTEER
mdefine_line|#define NUM_XSWITCH_VOLUNTEER 2
multiline_comment|/*&n; * Track which hubs have volunteered to manage devices hanging off of&n; * a Crosstalk Switch (e.g. xbow).  This structure is allocated,&n; * initialized, and hung off the xswitch vertex early on when the&n; * xswitch vertex is created.&n; */
DECL|struct|xswitch_vol_s
r_typedef
r_struct
id|xswitch_vol_s
(brace
DECL|member|xswitch_volunteer_mutex
id|mutex_t
id|xswitch_volunteer_mutex
suffix:semicolon
DECL|member|xswitch_volunteer_count
r_int
id|xswitch_volunteer_count
suffix:semicolon
DECL|member|xswitch_volunteer
id|devfs_handle_t
id|xswitch_volunteer
(braket
id|NUM_XSWITCH_VOLUNTEER
)braket
suffix:semicolon
DECL|typedef|xswitch_vol_t
)brace
op_star
id|xswitch_vol_t
suffix:semicolon
r_void
DECL|function|xswitch_vertex_init
id|xswitch_vertex_init
c_func
(paren
id|devfs_handle_t
id|xswitch
)paren
(brace
id|xswitch_vol_t
id|xvolinfo
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|xvolinfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|xswitch_vol_s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mutex_init
c_func
(paren
op_amp
id|xvolinfo-&gt;xswitch_volunteer_mutex
)paren
suffix:semicolon
id|xvolinfo-&gt;xswitch_volunteer_count
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|hwgraph_info_add_LBL
c_func
(paren
id|xswitch
comma
id|INFO_LBL_XSWITCH_VOL
comma
(paren
id|arbitrary_info_t
)paren
id|xvolinfo
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rc
op_assign
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * When assignment of hubs to widgets is complete, we no longer need the&n; * xswitch volunteer structure hanging around.  Destroy it.&n; */
r_static
r_void
DECL|function|xswitch_volunteer_delete
id|xswitch_volunteer_delete
c_func
(paren
id|devfs_handle_t
id|xswitch
)paren
(brace
id|xswitch_vol_t
id|xvolinfo
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|hwgraph_info_remove_LBL
c_func
(paren
id|xswitch
comma
id|INFO_LBL_XSWITCH_VOL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|xvolinfo
)paren
suffix:semicolon
macro_line|#ifdef LATER
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
id|rc
op_assign
id|rc
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|xvolinfo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A Crosstalk master volunteers to manage xwidgets on the specified xswitch.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|volunteer_for_widgets
id|volunteer_for_widgets
c_func
(paren
id|devfs_handle_t
id|xswitch
comma
id|devfs_handle_t
id|master
)paren
(brace
id|xswitch_vol_t
id|xvolinfo
op_assign
l_int|NULL
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_info_get_LBL
c_func
(paren
id|xswitch
comma
id|INFO_LBL_XSWITCH_VOL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|xvolinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xvolinfo
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef LATER
r_if
c_cond
(paren
op_logical_neg
id|is_headless_node_vertex
c_func
(paren
id|master
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;volunteer for widgets: vertex %v has no info label&quot;
comma
id|xswitch
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;volunteer for widgets: vertex 0x%x has no info label&quot;
comma
id|xswitch
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* LATER */
r_return
suffix:semicolon
)brace
id|mutex_lock
c_func
(paren
op_amp
id|xvolinfo-&gt;xswitch_volunteer_mutex
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xvolinfo-&gt;xswitch_volunteer_count
OL
id|NUM_XSWITCH_VOLUNTEER
)paren
suffix:semicolon
id|xvolinfo-&gt;xswitch_volunteer
(braket
id|xvolinfo-&gt;xswitch_volunteer_count
)braket
op_assign
id|master
suffix:semicolon
id|xvolinfo-&gt;xswitch_volunteer_count
op_increment
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
id|xvolinfo-&gt;xswitch_volunteer_mutex
)paren
suffix:semicolon
)brace
r_extern
r_int
id|xbow_port_io_enabled
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|widgetnum
)paren
suffix:semicolon
multiline_comment|/*&n; * Assign all the xwidgets hanging off the specified xswitch to the&n; * Crosstalk masters that have volunteered for xswitch duty.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|assign_widgets_to_volunteers
id|assign_widgets_to_volunteers
c_func
(paren
id|devfs_handle_t
id|xswitch
comma
id|devfs_handle_t
id|hubv
)paren
(brace
r_int
id|curr_volunteer
comma
id|num_volunteer
suffix:semicolon
id|xwidgetnum_t
id|widgetnum
suffix:semicolon
id|xswitch_info_t
id|xswitch_info
suffix:semicolon
id|xswitch_vol_t
id|xvolinfo
op_assign
l_int|NULL
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|xswitch_info
op_assign
id|xswitch_info_get
c_func
(paren
id|xswitch
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xswitch_info
op_ne
l_int|NULL
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_info_get_LBL
c_func
(paren
id|xswitch
comma
id|INFO_LBL_XSWITCH_VOL
comma
(paren
id|arbitrary_info_t
op_star
)paren
op_amp
id|xvolinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xvolinfo
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef LATER
r_if
c_cond
(paren
op_logical_neg
id|is_headless_node_vertex
c_func
(paren
id|hubv
)paren
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;assign_widgets_to_volunteers:vertex %v has &quot;
l_string|&quot; no info label&quot;
comma
id|xswitch
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;assign_widgets_to_volunteers:vertex 0x%x has &quot;
l_string|&quot; no info label&quot;
comma
id|xswitch
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* LATER */
r_return
suffix:semicolon
)brace
id|num_volunteer
op_assign
id|xvolinfo-&gt;xswitch_volunteer_count
suffix:semicolon
id|ASSERT
c_func
(paren
id|num_volunteer
OG
l_int|0
)paren
suffix:semicolon
id|curr_volunteer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Assign master hub for xswitch itself.  */
r_if
c_cond
(paren
id|HUB_WIDGET_ID_MIN
OG
l_int|0
)paren
(brace
id|hubv
op_assign
id|xvolinfo-&gt;xswitch_volunteer
(braket
l_int|0
)braket
suffix:semicolon
id|xswitch_info_master_assignment_set
c_func
(paren
id|xswitch_info
comma
(paren
id|xwidgetnum_t
)paren
l_int|0
comma
id|hubv
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * TBD: Use administrative information to alter assignment of&n;&t; * widgets to hubs.&n;&t; */
r_for
c_loop
(paren
id|widgetnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|widgetnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widgetnum
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ignore disabled/empty ports.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xbow_port_io_enabled
c_func
(paren
id|nasid
comma
id|widgetnum
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this is the master IO board, assign it to the same &n;&t;&t; * hub that owned it in the prom.&n;&t;&t; */
r_if
c_cond
(paren
id|is_master_nasid_widget
c_func
(paren
id|nasid
comma
id|widgetnum
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_volunteer
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hubv
op_assign
id|xvolinfo-&gt;xswitch_volunteer
(braket
id|i
)braket
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|get_console_nasid
c_func
(paren
)paren
)paren
r_goto
id|do_assignment
suffix:semicolon
)brace
macro_line|#ifdef LATER
id|PRINT_PANIC
c_func
(paren
l_string|&quot;Nasid == %d, console nasid == %d&quot;
comma
id|nasid
comma
id|get_console_nasid
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t; * Do a round-robin assignment among the volunteer nodes.&n;&t;&t; */
id|hubv
op_assign
id|xvolinfo-&gt;xswitch_volunteer
(braket
id|curr_volunteer
)braket
suffix:semicolon
id|curr_volunteer
op_assign
(paren
id|curr_volunteer
op_plus
l_int|1
)paren
op_mod
id|num_volunteer
suffix:semicolon
multiline_comment|/* fall through */
id|do_assignment
suffix:colon
multiline_comment|/*&n;&t;&t; * At this point, we want to make hubv the master of widgetnum.&n;&t;&t; */
id|xswitch_info_master_assignment_set
c_func
(paren
id|xswitch_info
comma
id|widgetnum
comma
id|hubv
)paren
suffix:semicolon
)brace
id|xswitch_volunteer_delete
c_func
(paren
id|xswitch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Early iograph initialization.  Called by master CPU in mlreset().&n; * Useful for including iograph.o in kernel.o.&n; */
r_void
DECL|function|iograph_early_init
id|iograph_early_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n; * Need new way to get this information ..&n; */
id|cnodeid_t
id|cnode
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|lboard_t
op_star
id|board
suffix:semicolon
multiline_comment|/*&n;&t; * Init. the board-to-hwgraph link early, so FRU analyzer&n;&t; * doesn&squot;t trip on leftover values if we panic early on.&n;&t; */
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|board
op_assign
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;iograph_early_init: Found board 0x%p&bslash;n&quot;
comma
id|board
)paren
suffix:semicolon
multiline_comment|/* Check out all the board info stored on a node */
r_while
c_loop
(paren
id|board
)paren
(brace
id|board-&gt;brd_graph_link
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
id|board
op_assign
id|KLCF_NEXT
c_func
(paren
id|board
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;iograph_early_init: Found board 0x%p&bslash;n&quot;
comma
id|board
)paren
suffix:semicolon
)brace
)brace
id|hubio_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef LINUX_KERNEL_THREADS
DECL|variable|io_init_sema
r_static
r_struct
id|semaphore
id|io_init_sema
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Let boot processor know that we&squot;re done initializing our node&squot;s IO&n; * and then exit.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|io_init_done
id|io_init_done
c_func
(paren
id|cnodeid_t
id|cnodeid
comma
id|cpu_cookie_t
id|c
)paren
(brace
multiline_comment|/* Let boot processor know that we&squot;re done. */
macro_line|#ifdef LINUX_KERNEL_THREADS
id|up
c_func
(paren
op_amp
id|io_init_sema
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LATER
multiline_comment|/* This is for the setnoderun done when the io_init thread&n;&t; * started &n;&t; */
id|restorenoderun
c_func
(paren
id|c
)paren
suffix:semicolon
id|sthread_exit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* &n; * Probe to see if this hub&squot;s xtalk link is active.  If so,&n; * return the Crosstalk Identification of the widget that we talk to.  &n; * This is called before any of the Crosstalk infrastructure for &n; * this hub is set up.  It&squot;s usually called on the node that we&squot;re&n; * probing, but not always.&n; *&n; * TBD: Prom code should actually do this work, and pass through &n; * hwid for our use.&n; */
r_static
r_void
DECL|function|early_probe_for_widget
id|early_probe_for_widget
c_func
(paren
id|devfs_handle_t
id|hubv
comma
id|xwidget_hwid_t
id|hwid
)paren
(brace
id|hubreg_t
id|llp_csr_reg
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|llp_csr_reg
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|IIO_LLP_CSR
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If link is up, read the widget&squot;s part number.&n;&t; * A direct connect widget must respond to widgetnum=0.&n;&t; */
r_if
c_cond
(paren
id|llp_csr_reg
op_amp
id|IIO_LLP_CSR_IS_UP
)paren
(brace
multiline_comment|/* TBD: Put hub into &quot;indirect&quot; mode */
multiline_comment|/*&n;&t;&t; * We&squot;re able to read from a widget because our hub&squot;s &n;&t;&t; * WIDGET_ID was set up earlier.&n;&t;&t; */
id|widgetreg_t
id|widget_id
op_assign
op_star
(paren
r_volatile
id|widgetreg_t
op_star
)paren
(paren
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|0x0
)paren
op_plus
id|WIDGET_ID
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;early_probe_for_widget: Hub Vertex 0x%p is UP widget_id = 0x%x Register 0x%p&bslash;n&quot;
comma
id|hubv
comma
id|widget_id
comma
(paren
r_volatile
id|widgetreg_t
op_star
)paren
(paren
id|RAW_NODE_SWIN_BASE
c_func
(paren
id|nasid
comma
l_int|0x0
)paren
op_plus
id|WIDGET_ID
)paren
)paren
suffix:semicolon
id|hwid-&gt;part_num
op_assign
id|XWIDGET_PART_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
id|hwid-&gt;rev_num
op_assign
id|XWIDGET_REV_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
id|hwid-&gt;mfg_num
op_assign
id|XWIDGET_MFG_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
multiline_comment|/* TBD: link reset */
)brace
r_else
(brace
id|hwid-&gt;part_num
op_assign
id|XWIDGET_PART_NUM_NONE
suffix:semicolon
id|hwid-&gt;rev_num
op_assign
id|XWIDGET_REV_NUM_NONE
suffix:semicolon
id|hwid-&gt;mfg_num
op_assign
id|XWIDGET_MFG_NUM_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/* Add inventory information to the widget vertex &n; * Right now (module,slot,revision) is being&n; * added as inventory information.&n; */
r_static
r_void
DECL|function|xwidget_inventory_add
id|xwidget_inventory_add
c_func
(paren
id|devfs_handle_t
id|widgetv
comma
id|lboard_t
op_star
id|board
comma
r_struct
id|xwidget_hwid_s
id|hwid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|board
)paren
r_return
suffix:semicolon
multiline_comment|/* Donot add inventory information for the baseio&n;&t; * on a speedo with an xbox. It has already been&n;&t; * taken care of in SN00_vmc.&n;&t; * Speedo with xbox&squot;s baseio comes in at slot io1 (widget 9)&n;&t; */
id|device_inventory_add
c_func
(paren
id|widgetv
comma
id|INV_IOBD
comma
id|board-&gt;brd_type
comma
id|board-&gt;brd_module
comma
id|SLOTNUM_GETSLOT
c_func
(paren
id|board-&gt;brd_slot
)paren
comma
id|hwid.rev_num
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * io_xswitch_widget_init&n; *&t;&n; */
multiline_comment|/* defined in include/linux/ctype.h  */
multiline_comment|/* #define toupper(c)&t;(islower(c) ? (c) - &squot;a&squot; + &squot;A&squot; : (c)) */
r_void
DECL|function|io_xswitch_widget_init
id|io_xswitch_widget_init
c_func
(paren
id|devfs_handle_t
id|xswitchv
comma
id|devfs_handle_t
id|hubv
comma
id|xwidgetnum_t
id|widgetnum
comma
id|async_attach_t
id|aa
)paren
(brace
id|xswitch_info_t
id|xswitch_info
suffix:semicolon
id|xwidgetnum_t
id|hub_widgetid
suffix:semicolon
id|devfs_handle_t
id|widgetv
suffix:semicolon
id|cnodeid_t
id|cnode
suffix:semicolon
id|widgetreg_t
id|widget_id
suffix:semicolon
id|nasid_t
id|nasid
comma
id|peer_nasid
suffix:semicolon
r_struct
id|xwidget_hwid_s
id|hwid
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
multiline_comment|/*REFERENCED*/
r_int
id|rc
suffix:semicolon
r_char
id|slotname
(braket
id|SLOTNUM_MAXLENGTH
)braket
suffix:semicolon
r_char
id|pathname
(braket
l_int|128
)braket
suffix:semicolon
r_char
id|new_name
(braket
l_int|64
)braket
suffix:semicolon
id|moduleid_t
id|module
suffix:semicolon
id|slotid_t
id|slot
suffix:semicolon
id|lboard_t
op_star
id|board
op_assign
l_int|NULL
suffix:semicolon
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
id|slotid_t
id|get_widget_slotnum
c_func
(paren
r_int
id|xbow
comma
r_int
id|widget
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;&bslash;nio_xswitch_widget_init: hubv 0x%p, xswitchv 0x%p, widgetnum 0x%x&bslash;n&quot;
comma
id|hubv
comma
id|xswitchv
comma
id|widgetnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that xswitchv is indeed an attached xswitch.&n;&t; */
id|xswitch_info
op_assign
id|xswitch_info_get
c_func
(paren
id|xswitchv
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xswitch_info
op_ne
l_int|NULL
)paren
suffix:semicolon
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
id|nasid
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
id|cnode
op_assign
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|hub_widgetid
op_assign
id|hubinfo-&gt;h_widgetid
suffix:semicolon
multiline_comment|/* Who&squot;s the other guy on out crossbow (if anyone) */
id|peer_nasid
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|xbow_peer
suffix:semicolon
r_if
c_cond
(paren
id|peer_nasid
op_eq
id|INVALID_NASID
)paren
multiline_comment|/* If I don&squot;t have a peer, use myself. */
id|peer_nasid
op_assign
id|nasid
suffix:semicolon
multiline_comment|/* Check my xbow structure and my peer&squot;s */
r_if
c_cond
(paren
op_logical_neg
id|xbow_port_io_enabled
c_func
(paren
id|nasid
comma
id|widgetnum
)paren
op_logical_and
op_logical_neg
id|xbow_port_io_enabled
c_func
(paren
id|peer_nasid
comma
id|widgetnum
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xswitch_info_link_ok
c_func
(paren
id|xswitch_info
comma
id|widgetnum
)paren
)paren
(brace
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current hub is not supposed to be the master &n;&t;&t; * for this widgetnum, then skip this widget.&n;&t;&t; */
r_if
c_cond
(paren
id|xswitch_info_master_assignment_get
c_func
(paren
id|xswitch_info
comma
id|widgetnum
)paren
op_ne
id|hubv
)paren
(brace
r_return
suffix:semicolon
)brace
id|module
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
suffix:semicolon
macro_line|#ifdef XBRIDGE_REGS_SIM
multiline_comment|/* hardwire for now...could do this with something like:&n;&t;&t; * xbow_soft_t soft = hwgraph_fastinfo_get(vhdl);&n;&t;&t; * xbow_t xbow = soft-&gt;base;&n;&t;&t; * xbowreg_t xwidget_id = xbow-&gt;xb_wid_id;&n;&t;&t; * but I don&squot;t feel like figuring out vhdl right now..&n;&t;&t; * and I know for a fact the answer is 0x2d000049 &n;&t;&t; */
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: XBRIDGE_REGS_SIM FIXME: reading xwidget id: hardwired to xbridge (0x2d000049).&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;XWIDGET_PART_NUM(0x2d000049)= 0x%x&bslash;n&quot;
comma
id|XWIDGET_PART_NUM
c_func
(paren
l_int|0x2d000049
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XWIDGET_PART_NUM
c_func
(paren
l_int|0x2d000049
)paren
op_eq
id|XXBOW_WIDGET_PART_NUM
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|nasid_has_xbridge
c_func
(paren
id|nasid
)paren
)paren
(brace
macro_line|#endif /* XBRIDGE_REGS_SIM */
id|board
op_assign
id|find_lboard_module_class
c_func
(paren
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
comma
id|module
comma
id|KLTYPE_IOBRICK
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: Board 0x%p&bslash;n&quot;
comma
id|board
)paren
suffix:semicolon
(brace
id|lboard_t
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|board
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: Found KLTYPE_IOBRICK Board 0x%p brd_type 0x%x&bslash;n&quot;
comma
id|board
comma
id|board-&gt;brd_type
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: FIXME did not find IOBOARD&bslash;n&quot;
)paren
suffix:semicolon
id|board
op_assign
op_amp
id|dummy
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; &t;&t; * Make sure we really want to say xbrick, pbrick,&n;&t;&t;&t; * etc. rather than XIO, graphics, etc.&n;&t; &t;&t; */
macro_line|#ifdef SUPPORT_PRINTING_M_FORMAT
id|sprintf
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%M/&quot;
l_string|&quot;%cbrick&quot;
l_string|&quot;/%s/%d&quot;
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
macro_line|#else
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|buffer
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%s/&quot;
l_string|&quot;%cbrick&quot;
l_string|&quot;/%s/%d&quot;
comma
id|buffer
comma
macro_line|#endif
(paren
id|board-&gt;brd_type
op_eq
id|KLTYPE_IBRICK
)paren
ques
c_cond
l_char|&squot;I&squot;
suffix:colon
(paren
id|board-&gt;brd_type
op_eq
id|KLTYPE_PBRICK
)paren
ques
c_cond
l_char|&squot;P&squot;
suffix:colon
(paren
id|board-&gt;brd_type
op_eq
id|KLTYPE_XBRICK
)paren
ques
c_cond
l_char|&squot;X&squot;
suffix:colon
l_char|&squot;?&squot;
comma
id|EDGE_LBL_XTALK
comma
id|widgetnum
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: path= %s&bslash;n&quot;
comma
id|pathname
)paren
suffix:semicolon
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|hwgraph_root
comma
id|pathname
comma
op_amp
id|widgetv
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rc
op_eq
id|GRAPH_SUCCESS
)paren
suffix:semicolon
multiline_comment|/* This is needed to let the user programs to map the&n;&t;&t; * module,slot numbers to the corresponding widget numbers&n;&t;&t; * on the crossbow.&n;&t;&t; */
id|rc
op_assign
id|device_master_set
c_func
(paren
id|hwgraph_connectpt_get
c_func
(paren
id|widgetv
)paren
comma
id|hubv
)paren
suffix:semicolon
multiline_comment|/* If we are looking at the global master io6&n;&t;&t; * then add information about the version of&n;&t;&t; * the io6prom as a part of &quot;detailed inventory&quot;&n;&t;&t; * information.&n;&t;&t; */
r_if
c_cond
(paren
id|is_master_baseio
c_func
(paren
id|nasid
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
id|get_widget_slotnum
c_func
(paren
l_int|0
comma
id|widgetnum
)paren
)paren
)paren
(brace
r_extern
r_void
id|klhwg_baseio_inventory_add
c_func
(paren
id|devfs_handle_t
comma
id|cnodeid_t
)paren
suffix:semicolon
id|module
op_assign
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
suffix:semicolon
macro_line|#ifdef XBRIDGE_REGS_SIM
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: XBRIDGE_REGS_SIM FIXME: reading xwidget id: hardwired to xbridge (0x2d000049).&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XWIDGET_PART_NUM
c_func
(paren
l_int|0x2d000049
)paren
op_eq
id|XXBOW_WIDGET_PART_NUM
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|nasid_has_xbridge
c_func
(paren
id|nasid
)paren
)paren
(brace
macro_line|#endif /* XBRIDGE_REGS_SIM */
id|board
op_assign
id|find_lboard_module
c_func
(paren
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
comma
id|module
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Change iobrick to correct i/o brick&n;&t;&t;&t;&t; */
macro_line|#ifdef SUPPORT_PRINTING_M_FORMAT
id|sprintf
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%M/&quot;
macro_line|#else
id|sprintf
c_func
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%x/&quot;
macro_line|#endif
l_string|&quot;iobrick&quot;
l_string|&quot;/%s/%d&quot;
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
id|EDGE_LBL_XTALK
comma
id|widgetnum
)paren
suffix:semicolon
)brace
r_else
(brace
id|slot
op_assign
id|get_widget_slotnum
c_func
(paren
l_int|0
comma
id|widgetnum
)paren
suffix:semicolon
id|board
op_assign
id|get_board_name
c_func
(paren
id|nasid
comma
id|module
comma
id|slot
comma
id|new_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; &t; * Create the vertex for the widget, &n;&t;&t;&t;&t; * using the decimal &n;&t;&t;&t; &t; * widgetnum as the name of the primary edge.&n;&t;&t;&t; &t; */
macro_line|#ifdef SUPPORT_PRINTING_M_FORMAT
id|sprintf
c_func
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%M/&quot;
id|EDGE_LBL_SLOT
l_string|&quot;/%s/%s&quot;
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
id|slotname
comma
id|new_name
)paren
suffix:semicolon
macro_line|#else
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|buffer
comma
id|NODEPDA
c_func
(paren
id|cnode
)paren
op_member_access_from_pointer
id|module_id
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pathname
comma
id|EDGE_LBL_MODULE
l_string|&quot;/%s/&quot;
id|EDGE_LBL_SLOT
l_string|&quot;/%s/%s&quot;
comma
id|buffer
comma
id|slotname
comma
id|new_name
)paren
suffix:semicolon
macro_line|#endif
)brace
id|rc
op_assign
id|hwgraph_path_add
c_func
(paren
id|hwgraph_root
comma
id|pathname
comma
op_amp
id|widgetv
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: (2) path= %s&bslash;n&quot;
comma
id|pathname
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;         * This is a weird ass code needed for error injection&n;&t;&t;         * purposes.&n;&t;&t;         */
id|rc
op_assign
id|device_master_set
c_func
(paren
id|hwgraph_connectpt_get
c_func
(paren
id|widgetv
)paren
comma
id|hubv
)paren
suffix:semicolon
id|klhwg_baseio_inventory_add
c_func
(paren
id|widgetv
comma
id|cnode
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|widgetnum
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: FIXME hwgraph_edge_add %s xswitchv 0x%p, widgetv 0x%p&bslash;n&quot;
comma
id|name
comma
id|xswitchv
comma
id|widgetv
)paren
suffix:semicolon
id|rc
op_assign
id|hwgraph_edge_add
c_func
(paren
id|xswitchv
comma
id|widgetv
comma
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * crosstalk switch code tracks which&n;&t;&t; * widget is attached to each link.&n;&t;&t; */
id|xswitch_info_vhdl_set
c_func
(paren
id|xswitch_info
comma
id|widgetnum
comma
id|widgetv
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Peek at the widget to get its crosstalk part and&n;&t;&t; * mfgr numbers, then present it to the generic xtalk&n;&t;&t; * bus provider to have its driver attach routine&n;&t;&t; * called (or not).&n;&t;&t; */
macro_line|#ifdef XBRIDGE_REGS_SIM
id|widget_id
op_assign
l_int|0x2d000049
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_xswitch_widget_init: XBRIDGE_REGS_SIM FIXME: id hardwired to widget_id&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|widget_id
op_assign
id|XWIDGET_ID_READ
c_func
(paren
id|nasid
comma
id|widgetnum
)paren
suffix:semicolon
macro_line|#endif /* XBRIDGE_REGS_SIM */
id|hwid.part_num
op_assign
id|XWIDGET_PART_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
id|hwid.rev_num
op_assign
id|XWIDGET_REV_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
id|hwid.mfg_num
op_assign
id|XWIDGET_MFG_NUM
c_func
(paren
id|widget_id
)paren
suffix:semicolon
multiline_comment|/* Store some inventory information about&n;&t;&t; * the xwidget in the hardware graph.&n;&t;&t; */
id|xwidget_inventory_add
c_func
(paren
id|widgetv
comma
id|board
comma
id|hwid
)paren
suffix:semicolon
(paren
r_void
)paren
id|xwidget_register
c_func
(paren
op_amp
id|hwid
comma
id|widgetv
comma
id|widgetnum
comma
id|hubv
comma
id|hub_widgetid
comma
id|aa
)paren
suffix:semicolon
macro_line|#ifdef&t;SN0_USE_BTE
id|bte_bpush_war
c_func
(paren
id|cnode
comma
(paren
r_void
op_star
)paren
id|board
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_static
r_void
DECL|function|io_init_xswitch_widgets
id|io_init_xswitch_widgets
c_func
(paren
id|devfs_handle_t
id|xswitchv
comma
id|cnodeid_t
id|cnode
)paren
(brace
id|xwidgetnum_t
id|widgetnum
suffix:semicolon
id|async_attach_t
id|aa
suffix:semicolon
id|aa
op_assign
id|async_attach_new
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_xswitch_widgets: xswitchv 0x%p for cnode %d&bslash;n&quot;
comma
id|xswitchv
comma
id|cnode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|widgetnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|widgetnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widgetnum
op_increment
)paren
(brace
id|io_xswitch_widget_init
c_func
(paren
id|xswitchv
comma
id|cnodeid_to_vertex
c_func
(paren
id|cnode
)paren
comma
id|widgetnum
comma
id|aa
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Wait for parallel attach threads, if any, to complete.&n;&t; */
id|async_attach_waitall
c_func
(paren
id|aa
)paren
suffix:semicolon
id|async_attach_free
c_func
(paren
id|aa
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For each PCI bridge connected to the xswitch, add a link from the&n; * board&squot;s klconfig info to the bridge&squot;s hwgraph vertex.  This lets&n; * the FRU analyzer find the bridge without traversing the hardware&n; * graph and risking hangs.&n; */
r_static
r_void
DECL|function|io_link_xswitch_widgets
id|io_link_xswitch_widgets
c_func
(paren
id|devfs_handle_t
id|xswitchv
comma
id|cnodeid_t
id|cnodeid
)paren
(brace
id|xwidgetnum_t
id|widgetnum
suffix:semicolon
r_char
id|pathname
(braket
l_int|128
)braket
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
id|nasid_t
id|nasid
comma
id|peer_nasid
suffix:semicolon
id|lboard_t
op_star
id|board
suffix:semicolon
multiline_comment|/* And its connected hub&squot;s nasids */
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|peer_nasid
op_assign
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
op_member_access_from_pointer
id|xbow_peer
suffix:semicolon
multiline_comment|/* &n;&t; * Look for paths matching &quot;&lt;widgetnum&gt;/pci&quot; under xswitchv.&n;&t; * For every widget, init. its lboard&squot;s hwgraph link.  If the&n;&t; * board has a PCI bridge, point the link to it.&n;&t; */
r_for
c_loop
(paren
id|widgetnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|widgetnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widgetnum
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d&quot;
comma
id|widgetnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xswitchv
comma
id|pathname
comma
op_amp
id|vhdl
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_continue
suffix:semicolon
id|board
op_assign
id|find_lboard_module
c_func
(paren
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|nasid
)paren
comma
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
op_member_access_from_pointer
id|module_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|board
op_eq
l_int|NULL
op_logical_and
id|peer_nasid
op_ne
id|INVALID_NASID
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try to find the board on our peer&n;&t;&t;&t; */
id|board
op_assign
id|find_lboard_module
c_func
(paren
(paren
id|lboard_t
op_star
)paren
id|KL_CONFIG_INFO
c_func
(paren
id|peer_nasid
)paren
comma
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
op_member_access_from_pointer
id|module_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|board
op_eq
l_int|NULL
)paren
(brace
macro_line|#if defined(SUPPORT_PRINTING_V_FORMAT)
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not find PROM info for vertex %v, &quot;
l_string|&quot;FRU analyzer may fail&quot;
comma
id|vhdl
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not find PROM info for vertex 0x%p, &quot;
l_string|&quot;FRU analyzer may fail&quot;
comma
(paren
r_void
op_star
)paren
id|vhdl
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d/&quot;
id|EDGE_LBL_PCI
comma
id|widgetnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xswitchv
comma
id|pathname
comma
op_amp
id|vhdl
)paren
op_eq
id|GRAPH_SUCCESS
)paren
id|board-&gt;brd_graph_link
op_assign
id|vhdl
suffix:semicolon
r_else
id|board-&gt;brd_graph_link
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialize all I/O on the specified node.&n; */
r_static
r_void
DECL|function|io_init_node
id|io_init_node
c_func
(paren
id|cnodeid_t
id|cnodeid
)paren
(brace
multiline_comment|/*REFERENCED*/
id|devfs_handle_t
id|hubv
comma
id|switchv
comma
id|widgetv
suffix:semicolon
r_struct
id|xwidget_hwid_s
id|hwid
suffix:semicolon
id|hubinfo_t
id|hubinfo
suffix:semicolon
r_int
id|is_xswitch
suffix:semicolon
id|nodepda_t
op_star
id|npdap
suffix:semicolon
r_struct
id|semaphore
op_star
id|peer_sema
op_assign
l_int|0
suffix:semicolon
r_uint32
id|widget_partnum
suffix:semicolon
id|nodepda_router_info_t
op_star
id|npda_rip
suffix:semicolon
id|cpu_cookie_t
id|c
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|hubdev_docallouts
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
macro_line|#ifdef LATER
multiline_comment|/* Try to execute on the node that we&squot;re initializing. */
id|c
op_assign
id|setnoderun
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
macro_line|#endif
id|npdap
op_assign
id|NODEPDA
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the &quot;top&quot; vertex for this node&squot;s hardware&n;&t; * graph; it will carry the per-hub hub-specific&n;&t; * data, and act as the crosstalk provider master.&n;&t; * It&squot;s canonical path is probably something of the&n;&t; * form /hw/module/%M/slot/%d/node&n;&t; */
id|hubv
op_assign
id|cnodeid_to_vertex
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Initialize IO for cnode %d hubv(node) 0x%p npdap 0x%p&bslash;n&quot;
comma
id|cnodeid
comma
id|hubv
comma
id|npdap
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hubv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
id|hubdev_docallouts
c_func
(paren
id|hubv
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the dependent routers if we have any.&n;&t; */
id|npda_rip
op_assign
id|npdap-&gt;npda_rip_first
suffix:semicolon
r_while
c_loop
(paren
id|npda_rip
)paren
(brace
multiline_comment|/* If the router info has not been initialized&n;&t;&t; * then we need to do the router initialization&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|npda_rip-&gt;router_infop
)paren
(brace
id|router_init
c_func
(paren
id|cnodeid
comma
l_int|0
comma
id|npda_rip
)paren
suffix:semicolon
)brace
id|npda_rip
op_assign
id|npda_rip-&gt;router_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read mfg info on this hub&n;&t; */
macro_line|#ifdef LATER
id|printk
c_func
(paren
l_string|&quot;io_init_node: FIXME need to implement HUB_VERTEX_MFG_INFO&bslash;n&quot;
)paren
suffix:semicolon
id|HUB_VERTEX_MFG_INFO
c_func
(paren
id|hubv
)paren
suffix:semicolon
macro_line|#endif /* LATER */
multiline_comment|/* &n;&t; * If nothing connected to this hub&squot;s xtalk port, we&squot;re done.&n;&t; */
id|early_probe_for_widget
c_func
(paren
id|hubv
comma
op_amp
id|hwid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwid.part_num
op_eq
id|XWIDGET_PART_NUM_NONE
)paren
(brace
macro_line|#ifdef PROBE_TEST
r_if
c_cond
(paren
(paren
id|cnodeid
op_eq
l_int|1
)paren
op_logical_or
(paren
id|cnodeid
op_eq
l_int|2
)paren
)paren
(brace
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|600
suffix:semicolon
id|index
op_increment
)paren
id|DBG
c_func
(paren
l_string|&quot;Interfering with device probing!!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* io_init_done takes cpu cookie as 2nd argument &n;&t;&t; * to do a restorenoderun for the setnoderun done &n;&t;&t; * at the start of this thread &n;&t;&t; */
id|DBG
c_func
(paren
l_string|&quot;**** io_init_node: Node&squot;s 0x%p hub widget has XWIDGET_PART_NUM_NONE ****&bslash;n&quot;
comma
id|hubv
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/* &n;&t; * attach our hub_provider information to hubv,&n;&t; * so we can use it as a crosstalk provider &quot;master&quot;&n;&t; * vertex.&n;&t; */
id|xtalk_provider_register
c_func
(paren
id|hubv
comma
op_amp
id|hub_provider
)paren
suffix:semicolon
id|xtalk_provider_startup
c_func
(paren
id|hubv
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create a vertex to represent the crosstalk bus&n;&t; * attached to this hub, and a vertex to be used&n;&t; * as the connect point for whatever is out there&n;&t; * on the other side of our crosstalk connection.&n;&t; *&n;&t; * Crosstalk Switch drivers &quot;climb up&quot; from their&n;&t; * connection point to try and take over the switch&n;&t; * point.&n;&t; *&n;&t; * Of course, the edges and verticies may already&n;&t; * exist, in which case our net effect is just to&n;&t; * associate the &quot;xtalk_&quot; driver with the connection&n;&t; * point for the device.&n;&t; */
(paren
r_void
)paren
id|hwgraph_path_add
c_func
(paren
id|hubv
comma
id|EDGE_LBL_XTALK
comma
op_amp
id|switchv
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Created &squot;xtalk&squot; entry to &squot;../node/&squot; xtalk vertex 0x%p&bslash;n&quot;
comma
id|switchv
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|switchv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_edge_add
c_func
(paren
id|hubv
comma
id|switchv
comma
id|EDGE_LBL_IO
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Created symlink &squot;io&squot; from ../node/io to ../node/xtalk &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to find the widget id and update the basew_id field&n;&t; * accordingly. In particular, SN00 has direct connected bridge,&n;&t; * and hence widget id is Not 0.&n;&t; */
id|widget_partnum
op_assign
(paren
(paren
(paren
op_star
(paren
r_volatile
r_int32
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
comma
l_int|0
)paren
op_plus
id|WIDGET_ID
)paren
)paren
)paren
op_amp
id|WIDGET_PART_NUM
)paren
op_rshift
id|WIDGET_PART_NUM_SHFT
suffix:semicolon
r_if
c_cond
(paren
id|widget_partnum
op_eq
id|BRIDGE_WIDGET_PART_NUM
op_logical_or
id|widget_partnum
op_eq
id|XBRIDGE_WIDGET_PART_NUM
)paren
(brace
id|npdap-&gt;basew_id
op_assign
(paren
(paren
(paren
op_star
(paren
r_volatile
r_int32
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
comma
l_int|0
)paren
op_plus
id|BRIDGE_WID_CONTROL
)paren
)paren
)paren
op_amp
id|WIDGET_WIDGET_ID
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Found XBRIDGE widget_partnum= 0x%x&bslash;n&quot;
comma
id|widget_partnum
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|widget_partnum
op_eq
id|XBOW_WIDGET_PART_NUM
op_logical_or
id|widget_partnum
op_eq
id|XXBOW_WIDGET_PART_NUM
)paren
(brace
multiline_comment|/* &n;&t;&t; * Xbow control register does not have the widget ID field.&n;&t;&t; * So, hard code the widget ID to be zero.&n;&t;&t; */
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Found XBOW widget_partnum= 0x%x&bslash;n&quot;
comma
id|widget_partnum
)paren
suffix:semicolon
id|npdap-&gt;basew_id
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|widget_partnum
op_eq
id|XG_WIDGET_PART_NUM
)paren
(brace
multiline_comment|/* &n;&t;&t; * OK, WTF do we do here if we have an XG direct connected to a HUB/Bedrock???&n;&t;&t; * So, hard code the widget ID to be zero?&n;&t;&t; */
id|npdap-&gt;basew_id
op_assign
l_int|0
suffix:semicolon
id|npdap-&gt;basew_id
op_assign
(paren
(paren
(paren
op_star
(paren
r_volatile
r_int32
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
comma
l_int|0
)paren
op_plus
id|BRIDGE_WID_CONTROL
)paren
)paren
)paren
op_amp
id|WIDGET_WIDGET_ID
)paren
suffix:semicolon
)brace
r_else
(brace
id|npdap-&gt;basew_id
op_assign
(paren
(paren
(paren
op_star
(paren
r_volatile
r_int32
op_star
)paren
(paren
id|NODE_SWIN_BASE
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnodeid
)paren
comma
l_int|0
)paren
op_plus
id|BRIDGE_WID_CONTROL
)paren
)paren
)paren
op_amp
id|WIDGET_WIDGET_ID
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot; ****io_init_node: Unknown Widget Part Number 0x%x Widgt ID 0x%x attached to Hubv 0x%p ****&bslash;n&quot;
comma
id|widget_partnum
comma
id|npdap-&gt;basew_id
comma
(paren
r_void
op_star
)paren
id|hubv
)paren
suffix:semicolon
multiline_comment|/*NOTREACHED*/
)brace
(brace
r_char
id|widname
(braket
l_int|10
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|widname
comma
l_string|&quot;%x&quot;
comma
id|npdap-&gt;basew_id
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwgraph_path_add
c_func
(paren
id|switchv
comma
id|widname
comma
op_amp
id|widgetv
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;io_init_node: Created &squot;%s&squot; to &squot;..node/xtalk/&squot; vertex 0x%p&bslash;n&quot;
comma
id|widname
comma
id|widgetv
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|widgetv
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
)brace
id|nodepda-&gt;basew_xc
op_assign
id|widgetv
suffix:semicolon
id|is_xswitch
op_assign
id|xwidget_hwid_is_xswitch
c_func
(paren
op_amp
id|hwid
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Try to become the master of the widget.  If this is an xswitch&n;&t; * with multiple hubs connected, only one will succeed.  Mastership&n;&t; * of an xswitch is used only when touching registers on that xswitch.&n;&t; * The slave xwidgets connected to the xswitch can be owned by various&n;&t; * masters.&n;&t; */
r_if
c_cond
(paren
id|device_master_set
c_func
(paren
id|widgetv
comma
id|hubv
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Only one hub (thread) per Crosstalk device or switch makes&n;&t;&t; * it to here.&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * Initialize whatever xwidget is hanging off our hub.&n;&t;&t; * Whatever it is, it&squot;s accessible through widgetnum 0.&n;&t;&t; */
id|hubinfo_get
c_func
(paren
id|hubv
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
(paren
r_void
)paren
id|xwidget_register
c_func
(paren
op_amp
id|hwid
comma
id|widgetv
comma
id|npdap-&gt;basew_id
comma
id|hubv
comma
id|hubinfo-&gt;h_widgetid
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_xswitch
)paren
(brace
multiline_comment|/* io_init_done takes cpu cookie as 2nd argument &n;&t;&t;&t; * to do a restorenoderun for the setnoderun done &n;&t;&t;&t; * at the start of this thread &n;&t;&t;&t; */
id|io_init_done
c_func
(paren
id|cnodeid
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/* &n;&t;&t; * Special handling for Crosstalk Switches (e.g. xbow).&n;&t;&t; * We need to do things in roughly the following order:&n;&t;&t; *&t;1) Initialize xswitch hardware (done above)&n;&t;&t; *&t;2) Determine which hubs are available to be widget masters&n;&t;&t; *&t;3) Discover which links are active from the xswitch&n;&t;&t; *&t;4) Assign xwidgets hanging off the xswitch to hubs&n;&t;&t; *&t;5) Initialize all xwidgets on the xswitch&n;&t;&t; */
id|volunteer_for_widgets
c_func
(paren
id|switchv
comma
id|hubv
)paren
suffix:semicolon
multiline_comment|/* If there&squot;s someone else on this crossbow, recognize him */
r_if
c_cond
(paren
id|npdap-&gt;xbow_peer
op_ne
id|INVALID_NASID
)paren
(brace
id|nodepda_t
op_star
id|peer_npdap
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|npdap-&gt;xbow_peer
)paren
)paren
suffix:semicolon
id|peer_sema
op_assign
op_amp
id|peer_npdap-&gt;xbow_sema
suffix:semicolon
id|volunteer_for_widgets
c_func
(paren
id|switchv
comma
id|peer_npdap-&gt;node_vertex
)paren
suffix:semicolon
)brace
id|assign_widgets_to_volunteers
c_func
(paren
id|switchv
comma
id|hubv
)paren
suffix:semicolon
multiline_comment|/* Signal that we&squot;re done */
r_if
c_cond
(paren
id|peer_sema
)paren
(brace
id|mutex_unlock
c_func
(paren
id|peer_sema
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Wait &squot;til master is done assigning widgets. */
id|mutex_lock
c_func
(paren
op_amp
id|npdap-&gt;xbow_sema
)paren
suffix:semicolon
)brace
macro_line|#ifdef PROBE_TEST
r_if
c_cond
(paren
(paren
id|cnodeid
op_eq
l_int|1
)paren
op_logical_or
(paren
id|cnodeid
op_eq
l_int|2
)paren
)paren
(brace
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|500
suffix:semicolon
id|index
op_increment
)paren
id|DBG
c_func
(paren
l_string|&quot;Interfering with device probing!!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Now both nodes can safely inititialize widgets */
id|io_init_xswitch_widgets
c_func
(paren
id|switchv
comma
id|cnodeid
)paren
suffix:semicolon
id|io_link_xswitch_widgets
c_func
(paren
id|switchv
comma
id|cnodeid
)paren
suffix:semicolon
multiline_comment|/* io_init_done takes cpu cookie as 2nd argument &n;&t; * to do a restorenoderun for the setnoderun done &n;&t; * at the start of this thread &n;&t; */
id|io_init_done
c_func
(paren
id|cnodeid
comma
id|c
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;&bslash;nio_init_node: DONE INITIALIZED ALL I/O FOR CNODEID %d&bslash;n&bslash;n&quot;
comma
id|cnodeid
)paren
suffix:semicolon
)brace
DECL|macro|IOINIT_STKSZ
mdefine_line|#define IOINIT_STKSZ&t;(16 * 1024)
DECL|macro|__DEVSTR1
mdefine_line|#define __DEVSTR1 &t;&quot;/../.master/&quot;
DECL|macro|__DEVSTR2
mdefine_line|#define __DEVSTR2 &t;&quot;/target/&quot;
DECL|macro|__DEVSTR3
mdefine_line|#define __DEVSTR3 &t;&quot;/lun/0/disk/partition/&quot;
DECL|macro|__DEVSTR4
mdefine_line|#define&t;__DEVSTR4&t;&quot;/../ef&quot;
macro_line|#if defined(CONFIG_IA64_SGI_SN1)
multiline_comment|/*&n; * Currently, we need to allow for 5 IBrick slots with 1 FC each&n; * plus an internal 1394.&n; *&n; * ioconfig starts numbering SCSI&squot;s at NUM_BASE_IO_SCSI_CTLR.&n; */
DECL|macro|NUM_BASE_IO_SCSI_CTLR
mdefine_line|#define NUM_BASE_IO_SCSI_CTLR 6
macro_line|#else
DECL|macro|NUM_BASE_IO_SCSI_CTLR
mdefine_line|#define NUM_BASE_IO_SCSI_CTLR 6
macro_line|#endif
multiline_comment|/*&n; * This tells ioconfig where it can start numbering scsi controllers.&n; * Below this base number, platform-specific handles the numbering.&n; * XXX Irix legacy..controller numbering should be part of devfsd&squot;s job&n; */
DECL|variable|num_base_io_scsi_ctlr
r_int
id|num_base_io_scsi_ctlr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* used by syssgi */
DECL|variable|base_io_scsi_ctlr_vhdl
id|devfs_handle_t
id|base_io_scsi_ctlr_vhdl
(braket
id|NUM_BASE_IO_SCSI_CTLR
)braket
suffix:semicolon
DECL|variable|baseio_enet_vhdl
DECL|variable|baseio_console_vhdl
r_static
id|devfs_handle_t
id|baseio_enet_vhdl
comma
id|baseio_console_vhdl
suffix:semicolon
multiline_comment|/*&n; * Put the logical controller number information in the &n; * scsi controller vertices for each scsi controller that&n; * is in a &quot;fixed position&quot;.&n; */
r_static
r_void
DECL|function|scsi_ctlr_nums_add
id|scsi_ctlr_nums_add
c_func
(paren
id|devfs_handle_t
id|pci_vhdl
)paren
(brace
(brace
r_int
id|i
suffix:semicolon
id|num_base_io_scsi_ctlr
op_assign
id|NUM_BASE_IO_SCSI_CTLR
suffix:semicolon
multiline_comment|/* Initialize base_io_scsi_ctlr_vhdl array */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BASE_IO_SCSI_CTLR
suffix:semicolon
id|i
op_increment
)paren
id|base_io_scsi_ctlr_vhdl
(braket
id|i
)braket
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
)brace
(brace
multiline_comment|/*&n;&t; * May want to consider changing the SN0 code, above, to work more like&n;&t; * the way this works.&n;&t; */
id|devfs_handle_t
id|base_ibrick_xbridge_vhdl
suffix:semicolon
id|devfs_handle_t
id|base_ibrick_xtalk_widget_vhdl
suffix:semicolon
id|devfs_handle_t
id|scsi_ctlr_vhdl
suffix:semicolon
r_int
id|i
suffix:semicolon
id|graph_error_t
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * This is a table of &quot;well-known&quot; SCSI controllers and their well-known&n;&t; * controller numbers.  The names in the table start from the base IBrick&squot;s&n;&t; * Xbridge vertex, so the first component is the xtalk widget number.&n;&t; */
r_static
r_struct
(brace
r_char
op_star
id|base_ibrick_scsi_path
suffix:semicolon
r_int
id|controller_number
suffix:semicolon
)brace
id|hardwired_scsi_controllers
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;15/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/1/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|0
)brace
comma
(brace
l_string|&quot;15/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/2/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|1
)brace
comma
(brace
l_string|&quot;15/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/3/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|2
)brace
comma
(brace
l_string|&quot;14/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/1/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|3
)brace
comma
(brace
l_string|&quot;14/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/2/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|4
)brace
comma
(brace
l_string|&quot;15/&quot;
id|EDGE_LBL_PCI
l_string|&quot;/6/ohci/0/&quot;
id|EDGE_LBL_SCSI_CTLR
l_string|&quot;/0&quot;
comma
l_int|5
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
multiline_comment|/* must be last */
)brace
suffix:semicolon
id|base_ibrick_xtalk_widget_vhdl
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|pci_vhdl
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|base_ibrick_xtalk_widget_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
id|base_ibrick_xbridge_vhdl
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|base_ibrick_xtalk_widget_vhdl
)paren
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|base_ibrick_xbridge_vhdl
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|base_ibrick_xtalk_widget_vhdl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate through the list of well-known SCSI controllers.&n;&t; * For each controller found, set it&squot;s controller number according&n;&t; * to the table.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|hardwired_scsi_controllers
(braket
id|i
)braket
dot
id|base_ibrick_scsi_path
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rv
op_assign
id|hwgraph_path_lookup
c_func
(paren
id|base_ibrick_xbridge_vhdl
comma
id|hardwired_scsi_controllers
(braket
id|i
)braket
dot
id|base_ibrick_scsi_path
comma
op_amp
id|scsi_ctlr_vhdl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
multiline_comment|/* No SCSI at this path */
r_continue
suffix:semicolon
id|ASSERT
c_func
(paren
id|hardwired_scsi_controllers
(braket
id|i
)braket
dot
id|controller_number
OL
id|NUM_BASE_IO_SCSI_CTLR
)paren
suffix:semicolon
id|base_io_scsi_ctlr_vhdl
(braket
id|hardwired_scsi_controllers
(braket
id|i
)braket
dot
id|controller_number
)braket
op_assign
id|scsi_ctlr_vhdl
suffix:semicolon
id|device_controller_num_set
c_func
(paren
id|scsi_ctlr_vhdl
comma
id|hardwired_scsi_controllers
(braket
id|i
)braket
dot
id|controller_number
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|scsi_ctlr_vhdl
)paren
suffix:semicolon
multiline_comment|/* (even though we&squot;re actually keeping a reference) */
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|base_ibrick_xbridge_vhdl
)paren
suffix:semicolon
)brace
)brace
macro_line|#include &lt;asm/sn/ioerror_handling.h&gt;
DECL|variable|sys_critical_graph_root
id|devfs_handle_t
id|sys_critical_graph_root
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
multiline_comment|/* Define the system critical vertices and connect them through&n; * a canonical parent-child relationships for easy traversal&n; * during io error handling.&n; */
r_static
r_void
DECL|function|sys_critical_graph_init
id|sys_critical_graph_init
c_func
(paren
r_void
)paren
(brace
id|devfs_handle_t
id|bridge_vhdl
comma
id|master_node_vhdl
suffix:semicolon
id|devfs_handle_t
id|xbow_vhdl
op_assign
id|GRAPH_VERTEX_NONE
suffix:semicolon
r_extern
id|devfs_handle_t
id|hwgraph_root
suffix:semicolon
id|devfs_handle_t
id|pci_slot_conn
suffix:semicolon
r_int
id|slot
suffix:semicolon
id|devfs_handle_t
id|baseio_console_conn
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;sys_critical_graph_init: FIXME.&bslash;n&quot;
)paren
suffix:semicolon
id|baseio_console_conn
op_assign
id|hwgraph_connectpt_get
c_func
(paren
id|baseio_console_vhdl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baseio_console_conn
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the vertex handle for the baseio bridge */
id|bridge_vhdl
op_assign
id|device_master_get
c_func
(paren
id|baseio_console_conn
)paren
suffix:semicolon
multiline_comment|/* Get the master node of the baseio card */
id|master_node_vhdl
op_assign
id|cnodeid_to_vertex
c_func
(paren
id|master_node_get
c_func
(paren
id|baseio_console_vhdl
)paren
)paren
suffix:semicolon
multiline_comment|/* Add the &quot;root-&gt;node&quot; part of the system critical graph */
id|sys_critical_graph_vertex_add
c_func
(paren
id|hwgraph_root
comma
id|master_node_vhdl
)paren
suffix:semicolon
multiline_comment|/* Check if we have a crossbow */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|master_node_vhdl
comma
id|EDGE_LBL_XTALK
l_string|&quot;/0&quot;
comma
op_amp
id|xbow_vhdl
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
multiline_comment|/* We have a crossbow.Add &quot;node-&gt;xbow&quot; part of the system &n;&t;&t; * critical graph.&n;&t;&t; */
id|sys_critical_graph_vertex_add
c_func
(paren
id|master_node_vhdl
comma
id|xbow_vhdl
)paren
suffix:semicolon
multiline_comment|/* Add &quot;xbow-&gt;baseio bridge&quot; of the system critical graph */
id|sys_critical_graph_vertex_add
c_func
(paren
id|xbow_vhdl
comma
id|bridge_vhdl
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|xbow_vhdl
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* We donot have a crossbow. Add &quot;node-&gt;baseio_bridge&quot;&n;&t;&t; * part of the system critical graph.&n;&t;&t; */
id|sys_critical_graph_vertex_add
c_func
(paren
id|master_node_vhdl
comma
id|bridge_vhdl
)paren
suffix:semicolon
multiline_comment|/* Add all the populated PCI slot vertices to the system critical&n;&t; * graph with the bridge vertex as the parent.&n;&t; */
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|8
suffix:semicolon
id|slot
op_increment
)paren
(brace
r_char
id|slot_edge
(braket
l_int|10
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|slot_edge
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|bridge_vhdl
comma
id|slot_edge
comma
op_amp
id|pci_slot_conn
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_continue
suffix:semicolon
id|sys_critical_graph_vertex_add
c_func
(paren
id|bridge_vhdl
comma
id|pci_slot_conn
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pci_slot_conn
)paren
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|bridge_vhdl
)paren
suffix:semicolon
multiline_comment|/* Add the &quot;ioc3 pci connection point  -&gt; console ioc3&quot; part &n;&t; * of the system critical graph&n;&t; */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|baseio_console_vhdl
comma
l_string|&quot;..&quot;
comma
op_amp
id|pci_slot_conn
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
id|sys_critical_graph_vertex_add
c_func
(paren
id|pci_slot_conn
comma
id|baseio_console_vhdl
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pci_slot_conn
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the &quot;ethernet pci connection point  -&gt; base ethernet&quot; part of &n;&t; * the system  critical graph&n;&t; */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|baseio_enet_vhdl
comma
l_string|&quot;..&quot;
comma
op_amp
id|pci_slot_conn
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
id|sys_critical_graph_vertex_add
c_func
(paren
id|pci_slot_conn
comma
id|baseio_enet_vhdl
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pci_slot_conn
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the &quot;scsi controller pci connection point  -&gt; base scsi &n;&t; * controller&quot; part of the system critical graph&n;&t; */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|base_io_scsi_ctlr_vhdl
(braket
l_int|0
)braket
comma
l_string|&quot;../..&quot;
comma
op_amp
id|pci_slot_conn
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
id|sys_critical_graph_vertex_add
c_func
(paren
id|pci_slot_conn
comma
id|base_io_scsi_ctlr_vhdl
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pci_slot_conn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|base_io_scsi_ctlr_vhdl
(braket
l_int|1
)braket
comma
l_string|&quot;../..&quot;
comma
op_amp
id|pci_slot_conn
)paren
op_eq
id|GRAPH_SUCCESS
)paren
(brace
id|sys_critical_graph_vertex_add
c_func
(paren
id|pci_slot_conn
comma
id|base_io_scsi_ctlr_vhdl
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|hwgraph_vertex_unref
c_func
(paren
id|pci_slot_conn
)paren
suffix:semicolon
)brace
id|hwgraph_vertex_unref
c_func
(paren
id|baseio_console_conn
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|baseio_ctlr_num_set
id|baseio_ctlr_num_set
c_func
(paren
r_void
)paren
(brace
r_char
id|name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
id|devfs_handle_t
id|console_vhdl
comma
id|pci_vhdl
comma
id|enet_vhdl
suffix:semicolon
id|devfs_handle_t
id|ioc3_console_vhdl_get
c_func
(paren
r_void
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;baseio_ctlr_num_set; FIXME&bslash;n&quot;
)paren
suffix:semicolon
id|console_vhdl
op_assign
id|ioc3_console_vhdl_get
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_vhdl
op_eq
id|GRAPH_VERTEX_NONE
)paren
r_return
suffix:semicolon
multiline_comment|/* Useful for setting up the system critical graph */
id|baseio_console_vhdl
op_assign
id|console_vhdl
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|console_vhdl
comma
id|name
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
id|__DEVSTR1
)paren
suffix:semicolon
id|pci_vhdl
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
id|name
)paren
suffix:semicolon
id|scsi_ctlr_nums_add
c_func
(paren
id|pci_vhdl
)paren
suffix:semicolon
multiline_comment|/* Unref the pci_vhdl due to the reference by hwgraph_path_to_vertex&n;&t; */
id|hwgraph_vertex_unref
c_func
(paren
id|pci_vhdl
)paren
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|console_vhdl
comma
id|name
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
id|__DEVSTR4
)paren
suffix:semicolon
id|enet_vhdl
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
id|name
)paren
suffix:semicolon
multiline_comment|/* Useful for setting up the system critical graph */
id|baseio_enet_vhdl
op_assign
id|enet_vhdl
suffix:semicolon
id|device_controller_num_set
c_func
(paren
id|enet_vhdl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Unref the enet_vhdl due to the reference by hwgraph_path_to_vertex&n;&t; */
id|hwgraph_vertex_unref
c_func
(paren
id|enet_vhdl
)paren
suffix:semicolon
)brace
multiline_comment|/* #endif */
r_void
DECL|function|sn00_rrb_alloc
id|sn00_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
op_star
id|vendor_list
)paren
(brace
multiline_comment|/* REFERENCED */
r_int
id|rtn_val
suffix:semicolon
multiline_comment|/* &n;&t;** sn00 population:&t;&t;errb&t;orrb&n;&t;**&t;0- ql&t;&t;&t;3+?&n;&t;**&t;1- ql&t;&t;&t;        2&n;&t;**&t;2- ioc3 ethernet&t;2+?&n;&t;**&t;3- ioc3 secondary&t;        1&n;&t;**&t;4-                      0&n;&t;** &t;5- PCI slot&n;&t;** &t;6- PCI slot&n;&t;** &t;7- PCI slot&n;&t;*/
multiline_comment|/* The following code implements this heuristic for getting &n;&t; * maximum usage out of the rrbs&n;&t; *&n;&t; * constraints:&n;&t; *  8 bit ql1 needs 1+1&n;&t; *  ql0 or ql5,6,7 wants 1+2&n;&t; *  ethernet wants 2 or more&n;&t; *&n;&t; * rules for even rrbs:&n;&t; *  if nothing in slot 6 &n;&t; *   4 rrbs to 0 and 2  (0xc8889999)&n;&t; *  else &n;         *   3 2 3 to slots 0 2 6  (0xc8899bbb)&n;&t; *&n;         * rules for odd rrbs&n;&t; *  if nothing in slot 5 or 7  (0xc8889999)&n;&t; *   4 rrbs to 1 and 3&n;&t; *  else if 1 thing in 5 or 7  (0xc8899aaa) or (0xc8899bbb)&n;         *   3 2 3 to slots 1 3 5|7&n;         *  else&n;         *   2 1 3 2 to slots 1 3 5 7 (note: if there&squot;s a ql card in 7 this&n;&t; *           (0xc89aaabb)      may short what it wants therefore the&n;&t; *&t;&t;&t;       rule should be to plug pci slots in order)&n;&t; */
r_if
c_cond
(paren
id|vendor_list
(braket
l_int|6
)braket
op_ne
id|PCIIO_VENDOR_ID_NONE
)paren
(brace
multiline_comment|/* something in slot 6 */
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|0
comma
l_int|4
comma
l_int|1
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtn_val
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn00_rrb_alloc: pcibr_alloc_all_rrbs failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vendor_list
(braket
l_int|5
)braket
op_ne
id|PCIIO_VENDOR_ID_NONE
)paren
op_logical_and
(paren
id|vendor_list
(braket
l_int|7
)braket
op_ne
id|PCIIO_VENDOR_ID_NONE
)paren
)paren
(brace
multiline_comment|/* soemthing in slot 5 and 7 */
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor_list
(braket
l_int|5
)braket
op_ne
id|PCIIO_VENDOR_ID_NONE
)paren
(brace
multiline_comment|/* soemthing in slot 5 but not 7 */
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor_list
(braket
l_int|7
)braket
op_ne
id|PCIIO_VENDOR_ID_NONE
)paren
(brace
multiline_comment|/* soemthing in slot 7 but not 5 */
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* nothing in slot 5 or 7 */
id|rtn_val
op_assign
id|pcibr_alloc_all_rrbs
c_func
(paren
id|vhdl
comma
l_int|1
comma
l_int|4
comma
l_int|1
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtn_val
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sn00_rrb_alloc: pcibr_alloc_all_rrbs failed&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize all I/O devices.  Starting closest to nodes, probe and&n; * initialize outward.&n; */
r_void
DECL|function|init_all_devices
id|init_all_devices
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Governor on init threads..bump up when safe &n;&t; * (beware many devfs races) &n;&t; */
macro_line|#ifdef LATER
r_int
id|io_init_node_threads
op_assign
l_int|2
suffix:semicolon
macro_line|#endif
id|cnodeid_t
id|cnodeid
comma
id|active
suffix:semicolon
macro_line|#ifdef LINUX_KERNEL_THREADS
id|sema_init
c_func
(paren
op_amp
id|io_init_sema
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|active
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
)paren
(brace
macro_line|#ifdef LINUX_KERNEL_THREADS
r_char
id|thread_name
(braket
l_int|16
)braket
suffix:semicolon
r_extern
r_int
id|io_init_pri
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Spawn a service thread for each node to initialize all&n;&t;&t; * I/O on that node.  Each thread attempts to bind itself &n;&t;&t; * to the node whose I/O it&squot;s initializing.&n;&t;&t; */
id|sprintf
c_func
(paren
id|thread_name
comma
l_string|&quot;IO_init[%d]&quot;
comma
id|cnodeid
)paren
suffix:semicolon
(paren
r_void
)paren
id|sthread_create
c_func
(paren
id|thread_name
comma
l_int|0
comma
id|IOINIT_STKSZ
comma
l_int|0
comma
id|io_init_pri
comma
id|KT_PS
comma
(paren
id|st_func_t
op_star
)paren
id|io_init_node
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|cnodeid
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|DBG
c_func
(paren
l_string|&quot;init_all_devices: Calling io_init_node() for cnode %d&bslash;n&quot;
comma
id|cnodeid
)paren
suffix:semicolon
id|io_init_node
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;init_all_devices: Done io_init_node() for cnode %d&bslash;n&quot;
comma
id|cnodeid
)paren
suffix:semicolon
macro_line|#endif /* LINUX_KERNEL_THREADS */
macro_line|#ifdef LINUX_KERNEL_THREADS
multiline_comment|/* Limit how many nodes go at once, to not overload hwgraph */
multiline_comment|/* TBD: Should timeout */
id|DBG
c_func
(paren
l_string|&quot;started thread for cnode %d&bslash;n&quot;
comma
id|cnodeid
)paren
suffix:semicolon
id|active
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|io_init_node_threads
op_logical_and
id|active
op_ge
id|io_init_node_threads
)paren
(brace
id|down
c_func
(paren
op_amp
id|io_init_sema
)paren
suffix:semicolon
id|active
op_decrement
suffix:semicolon
)brace
macro_line|#endif /* LINUX_KERNEL_THREADS */
)brace
macro_line|#ifdef LINUX_KERNEL_THREADS
multiline_comment|/* Wait until all IO_init threads are done */
r_while
c_loop
(paren
id|active
OG
l_int|0
)paren
(brace
macro_line|#ifdef AA_DEBUG
id|DBG
c_func
(paren
l_string|&quot;waiting, %d still active&bslash;n&quot;
comma
id|active
)paren
suffix:semicolon
macro_line|#endif
id|down
c_func
(paren
op_amp
id|io_init_sema
)paren
suffix:semicolon
id|active
op_decrement
suffix:semicolon
)brace
macro_line|#endif /* LINUX_KERNEL_THREADS */
r_for
c_loop
(paren
id|cnodeid
op_assign
l_int|0
suffix:semicolon
id|cnodeid
OL
id|numnodes
suffix:semicolon
id|cnodeid
op_increment
)paren
multiline_comment|/*&n;&t; &t; * Update information generated by IO init.&n;&t;&t; */
id|update_node_information
c_func
(paren
id|cnodeid
)paren
suffix:semicolon
id|baseio_ctlr_num_set
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Setup the system critical graph (which is a subgraph of the&n;&t; * main hwgraph). This information is useful during io error&n;&t; * handling.&n;&t; */
id|sys_critical_graph_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#if HWG_PRINT
id|hwgraph_print
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|toint
mdefine_line|#define toint(x) ((int)(x) - (int)(&squot;0&squot;))
r_void
DECL|function|devnamefromarcs
id|devnamefromarcs
c_func
(paren
r_char
op_star
id|devnm
)paren
(brace
r_int
id|val
suffix:semicolon
r_char
id|tmpnm
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_char
op_star
id|tmp1
comma
op_star
id|tmp2
suffix:semicolon
id|val
op_assign
id|strncmp
c_func
(paren
id|devnm
comma
l_string|&quot;dks&quot;
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|tmp1
op_assign
id|devnm
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|tmp1
)paren
)paren
r_return
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|isdigit
c_func
(paren
op_star
id|tmp1
)paren
)paren
(brace
id|val
op_assign
l_int|10
op_star
id|val
op_plus
id|toint
c_func
(paren
op_star
id|tmp1
)paren
suffix:semicolon
id|tmp1
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|tmp1
op_ne
l_char|&squot;d&squot;
)paren
(brace
r_return
suffix:semicolon
)brace
r_else
id|tmp1
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OL
l_int|0
)paren
op_logical_or
(paren
id|val
op_ge
id|NUM_BASE_IO_SCSI_CTLR
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|viable_found
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Only controller numbers 0..%d  are supported for&bslash;n&quot;
comma
id|NUM_BASE_IO_SCSI_CTLR
op_minus
l_int|1
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;prom &bslash;&quot;root&bslash;&quot; variables of the form dksXdXsX.&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;To use another disk you must use the full hardware graph path&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Possible controller numbers for use in &squot;dksXdXsX&squot; on this system: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BASE_IO_SCSI_CTLR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|base_io_scsi_ctlr_vhdl
(braket
id|i
)braket
op_ne
id|GRAPH_VERTEX_NONE
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
id|viable_found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|viable_found
)paren
id|DBG
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|DBG
c_func
(paren
l_string|&quot;none found!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef LATER
r_if
c_cond
(paren
id|kdebug
)paren
id|debug
c_func
(paren
l_string|&quot;ring&quot;
)paren
suffix:semicolon
macro_line|#endif
id|DELAY
c_func
(paren
l_int|15000000
)paren
suffix:semicolon
singleline_comment|//prom_reboot();
id|panic
c_func
(paren
l_string|&quot;FIXME: devnamefromarcs: should call prom_reboot here.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
id|ASSERT
c_func
(paren
id|base_io_scsi_ctlr_vhdl
(braket
id|val
)braket
op_ne
id|GRAPH_VERTEX_NONE
)paren
suffix:semicolon
id|vertex_to_name
c_func
(paren
id|base_io_scsi_ctlr_vhdl
(braket
id|val
)braket
comma
id|tmpnm
comma
id|MAXDEVNAME
)paren
suffix:semicolon
id|tmp2
op_assign
id|tmpnm
op_plus
id|strlen
c_func
(paren
id|tmpnm
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tmp2
comma
id|__DEVSTR2
)paren
suffix:semicolon
id|tmp2
op_add_assign
id|strlen
c_func
(paren
id|__DEVSTR2
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp1
op_ne
l_char|&squot;s&squot;
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|tmp2
op_increment
op_assign
op_star
id|tmp1
op_increment
)paren
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
id|tmp1
op_increment
suffix:semicolon
id|strcpy
c_func
(paren
id|tmp2
comma
id|__DEVSTR3
)paren
suffix:semicolon
id|tmp2
op_add_assign
id|strlen
c_func
(paren
id|__DEVSTR3
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|tmp2
op_increment
op_assign
op_star
id|tmp1
op_increment
)paren
)paren
suffix:semicolon
id|tmp2
op_decrement
suffix:semicolon
op_star
id|tmp2
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|strcpy
c_func
(paren
id|tmp2
comma
id|EDGE_LBL_BLOCK
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|devnm
comma
id|tmpnm
)paren
suffix:semicolon
)brace
r_static
DECL|variable|io_brick_tab
r_struct
id|io_brick_map_s
id|io_brick_tab
(braket
)braket
op_assign
(brace
multiline_comment|/* Ibrick widget number to PCI bus number map */
(brace
l_char|&squot;I&squot;
comma
multiline_comment|/* Ibrick type    */
multiline_comment|/*  PCI Bus #                                  Widget #       */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x0 - 0x7      */
l_int|0
comma
multiline_comment|/* 0x8            */
l_int|0
comma
multiline_comment|/* 0x9            */
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0xa - 0xb      */
l_int|0
comma
multiline_comment|/* 0xc            */
l_int|0
comma
multiline_comment|/* 0xd            */
l_int|2
comma
multiline_comment|/* 0xe            */
l_int|1
multiline_comment|/* 0xf            */
)brace
)brace
comma
multiline_comment|/* Pbrick widget number to PCI bus number map */
(brace
l_char|&squot;P&squot;
comma
multiline_comment|/* Pbrick type    */
multiline_comment|/*  PCI Bus #                                  Widget #       */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x0 - 0x7      */
l_int|2
comma
multiline_comment|/* 0x8            */
l_int|1
comma
multiline_comment|/* 0x9            */
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0xa - 0xb      */
l_int|5
comma
multiline_comment|/* 0xc            */
l_int|6
comma
multiline_comment|/* 0xd            */
l_int|4
comma
multiline_comment|/* 0xe            */
l_int|3
multiline_comment|/* 0xf            */
)brace
)brace
comma
multiline_comment|/* Xbrick widget to XIO slot map */
(brace
l_char|&squot;X&squot;
comma
multiline_comment|/* Xbrick type    */
multiline_comment|/*  XIO Slot #                                 Widget #       */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x0 - 0x7      */
l_int|1
comma
multiline_comment|/* 0x8            */
l_int|2
comma
multiline_comment|/* 0x9            */
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0xa - 0xb      */
l_int|3
comma
multiline_comment|/* 0xc            */
l_int|4
comma
multiline_comment|/* 0xd            */
l_int|0
comma
multiline_comment|/* 0xe            */
l_int|0
multiline_comment|/* 0xf            */
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Use the brick&squot;s type to map a widget number to a meaningful int&n; */
r_int
DECL|function|io_brick_map_widget
id|io_brick_map_widget
c_func
(paren
r_char
id|brick_type
comma
r_int
id|widget_num
)paren
(brace
r_int
id|num_bricks
comma
id|i
suffix:semicolon
multiline_comment|/* Calculate number of bricks in table */
id|num_bricks
op_assign
r_sizeof
(paren
id|io_brick_tab
)paren
op_div
r_sizeof
(paren
id|io_brick_tab
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Look for brick prefix in table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bricks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|brick_type
op_eq
id|io_brick_tab
(braket
id|i
)braket
dot
id|ibm_type
)paren
r_return
id|io_brick_tab
(braket
id|i
)braket
dot
id|ibm_map_wid
(braket
id|widget_num
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Use the device&squot;s vertex to map the device&squot;s widget to a meaningful int&n; */
r_int
DECL|function|io_path_map_widget
id|io_path_map_widget
c_func
(paren
id|devfs_handle_t
id|vertex
)paren
(brace
r_char
id|hw_path_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
r_char
op_star
id|wp
comma
op_star
id|bp
comma
op_star
id|sp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|widget_num
suffix:semicolon
r_int
id|atoi
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
r_int
id|hwgraph_vertex_name_get
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_char
op_star
id|buf
comma
id|uint
id|buflen
)paren
suffix:semicolon
multiline_comment|/* Get the full path name of the vertex */
r_if
c_cond
(paren
id|GRAPH_SUCCESS
op_ne
id|hwgraph_vertex_name_get
c_func
(paren
id|vertex
comma
id|hw_path_name
comma
id|MAXDEVNAME
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Find the widget number in the path name */
id|wp
op_assign
id|strstr
c_func
(paren
id|hw_path_name
comma
l_string|&quot;/&quot;
id|EDGE_LBL_XTALK
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|widget_num
op_assign
id|atoi
c_func
(paren
id|wp
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|widget_num
template_param
id|XBOW_PORT_F
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Find &quot;brick&quot; in the path name */
id|bp
op_assign
id|strstr
c_func
(paren
id|hw_path_name
comma
l_string|&quot;brick&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Find preceding slash */
id|sp
op_assign
id|bp
suffix:semicolon
r_while
c_loop
(paren
id|sp
OG
id|hw_path_name
)paren
(brace
id|sp
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|sp
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Invalid if no preceding slash */
r_if
c_cond
(paren
op_logical_neg
id|sp
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Bump slash pointer to &quot;brick&quot; prefix */
id|sp
op_increment
suffix:semicolon
multiline_comment|/*&n;         * Verify &quot;brick&quot; prefix length;  valid exaples:&n;         * &squot;I&squot; from &quot;/Ibrick&quot;&n;         * &squot;P&squot; from &quot;/Pbrick&quot;&n;         * &squot;X&squot; from &quot;/Xbrick&quot;&n;         */
r_if
c_cond
(paren
(paren
id|bp
op_minus
id|sp
)paren
op_ne
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|io_brick_map_widget
c_func
(paren
op_star
id|sp
comma
id|widget_num
)paren
)paren
suffix:semicolon
)brace
eof
