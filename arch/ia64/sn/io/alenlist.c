multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
multiline_comment|/* Implementation of Address/Length Lists. */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/alenlist.h&gt;
macro_line|#include &lt;asm/sn/mmzone_sn1.h&gt;
multiline_comment|/*&n; * Logically, an Address/Length List is a list of Pairs, where each pair&n; * holds an Address and a Length, all in some Address Space.  In this&n; * context, &quot;Address Space&quot; is a particular Crosstalk Widget address&n; * space, a PCI device address space, a VME bus address space, a&n; * physical memory address space, etc.&n; *&n; * The main use for these Lists is to provide a single mechanism that&n; * describes where in an address space a DMA occurs.  This allows the&n; * various I/O Bus support layers to provide a single interface for&n; * DMA mapping and DMA translation without regard to how the DMA target&n; * was specified by upper layers.  The upper layers commonly specify a &n; * DMA target via a buf structure page list, a kernel virtual address,&n; * a user virtual address, a vector of addresses (a la uio and iov), &n; * or possibly a pfn list.&n; *&n; * Address/Length Lists also enable drivers to take advantage of their&n; * inate scatter/gather capabilities in systems where some address&n; * translation may be required between bus adapters.  The driver forms&n; * a List that represents physical memory targets.  This list is passed&n; * to the various adapters, which apply various translations.  The final&n; * list that&squot;s returned to the driver is in terms of its local address&n; * address space -- addresses which can be passed off to a scatter/gather&n; * capable DMA controller.&n; *&n; * The current implementation is intended to be useful both in kernels&n; * that support interrupt threads (INTR_KTHREAD) and in systems that do&n; * not support interrupt threads.  Of course, in the latter case, some&n; * interfaces can be called only within a suspendable context.&n; *&n; * Basic operations on Address/Length Lists include:&n; *&t;alenlist_create&t;&t;Create a list&n; *&t;alenlist_clear&t;&t;Clear a list&n; *&t;alenlist_destroy&t;Destroy a list&n; *&t;alenlist_append&t;&t;Append a Pair to the end of a list&n; *&t;alenlist_replace&t;Replace a Pair in the middle of a list&n; *&t;alenlist_get&t;&t;Get an Address/Length Pair from a list&n; *&t;alenlist_size&t;&t;Return the number of Pairs in a list&n; *&t;alenlist_concat&t;&t;Append one list to the end of another&n; *&t;alenlist_clone&t;&t;Create a new copy of a list&n; *&n; * Operations that convert from upper-level specifications to Address/&n; * Length Lists currently include:&n; *&t;kvaddr_to_alenlist&t;Convert from a kernel virtual address&n; *&t;uvaddr_to_alenlist&t;Convert from a user virtual address&n; *&t;buf_to_alenlist&t;&t;Convert from a buf structure&n; *&t;alenlist_done&t;&t;Tell system that we&squot;re done with an alenlist&n; *&t;&t;&t;&t;obtained from a conversion.&n; * Additional convenience operations:&n; *&t;alenpair_init&t;&t;Create a list and initialize it with a Pair&n; *&t;alenpair_get&t;&t;Peek at the first pair on a List&n; *&n; * A supporting type for Address/Length Lists is an alenlist_cursor_t.  A&n; * cursor marks a position in a List, and determines which Pair is fetched&n; * by alenlist_get.&n; *&t;alenlist_cursor_create&t;Allocate and initialize a cursor&n; *&t;alenlist_cursor_destroy&t;Free space consumed by a cursor&n; *&t;alenlist_cursor_init&t;(Re-)Initialize a cursor to point &n; *&t;&t;&t;&t;to the start of a list&n; *&t;alenlist_cursor_clone&t;Clone a cursor (at the current offset)&n; *&t;alenlist_cursor_offset&t;Return the number of bytes into&n; *&t;&t;&t;&t;a list that this cursor marks&n; * Multiple cursors can point at various points into a List.  Also, each&n; * list maintains one &quot;internal cursor&quot; which may be updated by alenlist_clear&n; * and alenlist_get.  If calling code simply wishes to scan sequentially&n; * through a list starting at the beginning, and if it is the only user of&n; * a list, it can rely on this internal cursor rather than managing a &n; * separate explicit cursor.&n; *&n; * The current implementation allows callers to allocate both cursors and&n; * the lists as local stack (structure) variables.  This allows for some&n; * extra efficiency at the expense of forward binary compatibility.  It &n; * is recommended that customer drivers refrain from local allocation.&n; * In fact, we likely will choose to move the structures out of the public &n; * header file into a private place in order to discourage this usage.&n; *&n; * Currently, no locking is provided by the alenlist implementation.&n; *&n; * Implementation notes:&n; * For efficiency, Pairs are grouped into &quot;chunks&quot; of, say, 32 Pairs&n; * and a List consists of some number of these chunks.  Chunks are completely&n; * invisible to calling code.  Chunks should be large enough to hold most&n; * standard-sized DMA&squot;s, but not so large that they consume excessive space.&n; *&n; * It is generally expected that Lists will be constructed at one time and&n; * scanned at a later time.  It is NOT expected that drivers will scan&n; * a List while the List is simultaneously extended, although this is&n; * theoretically possible with sufficient upper-level locking.&n; *&n; * In order to support demands of Real-Time drivers and in order to support&n; * swapping under low-memory conditions, we support the concept of a&n; * &quot;pre-allocated fixed-sized List&quot;.  After creating a List with &n; * alenlist_create, a driver may explicitly grow the list (via &quot;alenlist_grow&quot;)&n; * to a specific number of Address/Length pairs.  It is guaranteed that future &n; * operations involving this list will never automatically grow the list &n; * (i.e. if growth is ever required, the operation will fail).  Additionally, &n; * operations that use alenlist&squot;s (e.g. DMA operations) accept a flag which &n; * causes processing to take place &quot;in-situ&quot;; that is, the input alenlist &n; * entries are replaced with output alenlist entries.  The combination of &n; * pre-allocated Lists and in-situ processing allows us to avoid the &n; * potential deadlock scenario where we sleep (waiting for memory) in the &n; * swap out path.&n; *&n; * For debugging, we track the number of allocated Lists in alenlist_count&n; * the number of allocated chunks in alenlist_chunk_count, and the number&n; * of allocate cursors in alenlist_cursor_count.  We also provide a debug &n; * routine, alenlist_show, which dumps the contents of an Address/Length List.&n; *&n; * Currently, Lists are formed by drivers on-demand.  Eventually, we may&n; * associate an alenlist with a buf structure and keep it up to date as&n; * we go along.  In that case, buf_to_alenlist simply returns a pointer&n; * to the existing List, and increments the Lists&squot;s reference count.&n; * alenlist_done would decrement the reference count and destroys the List&n; * if it was the last reference.&n; *&n; * Eventually alenlist&squot;s may allow better support for user-level scatter/&n; * gather operations (e.g. via readv/writev):  With proper support, we&n; * could potentially handle a vector of reads with a single scatter/gather&n; * DMA operation.  This could be especially useful on NUMA systems where&n; * there&squot;s more of a reason for users to use vector I/O operations.&n; *&n; * Eventually, alenlist&squot;s may replace kaio lists, vhand page lists,&n; * buffer cache pfdat lists, DMA page lists, etc.&n; */
multiline_comment|/* Opaque data types */
multiline_comment|/* An Address/Length pair.  */
DECL|struct|alen_s
r_typedef
r_struct
id|alen_s
(brace
DECL|member|al_addr
id|alenaddr_t
id|al_addr
suffix:semicolon
DECL|member|al_length
r_int
id|al_length
suffix:semicolon
DECL|typedef|alen_t
)brace
id|alen_t
suffix:semicolon
multiline_comment|/* &n; * Number of elements in one chunk of an Address/Length List.&n; *&n; * This size should be sufficient to hold at least an &quot;average&quot; size&n; * DMA request.  Must be at least 1, and should be a power of 2,&n; * for efficiency.&n; */
DECL|macro|ALEN_CHUNK_SZ
mdefine_line|#define ALEN_CHUNK_SZ ((512*1024)/NBPP)
multiline_comment|/*&n; * A fixed-size set of Address/Length Pairs.  Chunks of Pairs are strung together &n; * to form a complete Address/Length List.  Chunking is entirely hidden within the &n; * alenlist implementation, and it simply makes allocation and growth of lists more &n; * efficient.&n; */
DECL|struct|alenlist_chunk_s
r_typedef
r_struct
id|alenlist_chunk_s
(brace
DECL|member|alc_pair
id|alen_t
id|alc_pair
(braket
id|ALEN_CHUNK_SZ
)braket
suffix:semicolon
multiline_comment|/* list of addr/len pairs */
DECL|member|alc_next
r_struct
id|alenlist_chunk_s
op_star
id|alc_next
suffix:semicolon
multiline_comment|/* point to next chunk of pairs */
DECL|typedef|alenlist_chunk_t
)brace
op_star
id|alenlist_chunk_t
suffix:semicolon
multiline_comment|/* &n; * An Address/Length List.  An Address/Length List is allocated with alenlist_create.  &n; * Alternatively, a list can be allocated on the stack (local variable of type &n; * alenlist_t) and initialized with alenpair_init or with a combination of &n; * alenlist_clear and alenlist_append, etc.  Code which statically allocates these&n; * structures loses forward binary compatibility!&n; *&n; * A statically allocated List is sufficiently large to hold ALEN_CHUNK_SZ pairs.&n; */
DECL|struct|alenlist_s
r_struct
id|alenlist_s
(brace
DECL|member|al_flags
r_int
r_int
id|al_flags
suffix:semicolon
DECL|member|al_logical_size
r_int
r_int
id|al_logical_size
suffix:semicolon
multiline_comment|/* logical size of list, in pairs */
DECL|member|al_actual_size
r_int
r_int
id|al_actual_size
suffix:semicolon
multiline_comment|/* actual size of list, in pairs */
DECL|member|al_last_chunk
r_struct
id|alenlist_chunk_s
op_star
id|al_last_chunk
suffix:semicolon
multiline_comment|/* pointer to last logical chunk */
DECL|member|al_cursor
r_struct
id|alenlist_cursor_s
id|al_cursor
suffix:semicolon
multiline_comment|/* internal cursor */
DECL|member|al_chunk
r_struct
id|alenlist_chunk_s
id|al_chunk
suffix:semicolon
multiline_comment|/* initial set of pairs */
DECL|member|al_compaction_address
id|alenaddr_t
id|al_compaction_address
suffix:semicolon
multiline_comment|/* used to compact pairs */
)brace
suffix:semicolon
multiline_comment|/* al_flags field */
DECL|macro|AL_FIXED_SIZE
mdefine_line|#define AL_FIXED_SIZE&t;0x1&t;/* List is pre-allocated, and of fixed size */
DECL|variable|alenlist_zone
id|zone_t
op_star
id|alenlist_zone
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|alenlist_chunk_zone
id|zone_t
op_star
id|alenlist_chunk_zone
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|alenlist_cursor_zone
id|zone_t
op_star
id|alenlist_cursor_zone
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if DEBUG
DECL|variable|alenlist_count
r_int
id|alenlist_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Currently allocated Lists */
DECL|variable|alenlist_chunk_count
r_int
id|alenlist_chunk_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Currently allocated chunks */
DECL|variable|alenlist_cursor_count
r_int
id|alenlist_cursor_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Currently allocate cursors */
DECL|macro|INCR_COUNT
mdefine_line|#define INCR_COUNT(ptr) atomic_inc((ptr));
DECL|macro|DECR_COUNT
mdefine_line|#define DECR_COUNT(ptr) atomic_dec((ptr));
macro_line|#else
DECL|macro|INCR_COUNT
mdefine_line|#define INCR_COUNT(ptr)
DECL|macro|DECR_COUNT
mdefine_line|#define DECR_COUNT(ptr)
macro_line|#endif /* DEBUG */
macro_line|#if DEBUG
r_static
r_void
id|alenlist_show
c_func
(paren
id|alenlist_t
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
multiline_comment|/*&n; * Initialize Address/Length List management.  One time initialization.&n; */
r_void
DECL|function|alenlist_init
id|alenlist_init
c_func
(paren
r_void
)paren
(brace
id|alenlist_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
r_struct
id|alenlist_s
)paren
comma
l_string|&quot;alenlist&quot;
)paren
suffix:semicolon
id|alenlist_chunk_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
r_struct
id|alenlist_chunk_s
)paren
comma
l_string|&quot;alchunk&quot;
)paren
suffix:semicolon
id|alenlist_cursor_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
r_struct
id|alenlist_cursor_s
)paren
comma
l_string|&quot;alcursor&quot;
)paren
suffix:semicolon
macro_line|#if DEBUG
id|idbg_addfunc
c_func
(paren
l_string|&quot;alenshow&quot;
comma
id|alenlist_show
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
)brace
multiline_comment|/*&n; * Initialize an Address/Length List cursor.&n; */
r_static
r_void
DECL|function|do_cursor_init
id|do_cursor_init
c_func
(paren
id|alenlist_t
id|alenlist
comma
id|alenlist_cursor_t
id|cursorp
)paren
(brace
id|cursorp-&gt;al_alenlist
op_assign
id|alenlist
suffix:semicolon
id|cursorp-&gt;al_offset
op_assign
l_int|0
suffix:semicolon
id|cursorp-&gt;al_chunk
op_assign
op_amp
id|alenlist-&gt;al_chunk
suffix:semicolon
id|cursorp-&gt;al_index
op_assign
l_int|0
suffix:semicolon
id|cursorp-&gt;al_bcount
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an Address/Length List, and clear it.&n; * Set the cursor to the beginning.&n; */
id|alenlist_t
DECL|function|alenlist_create
id|alenlist_create
c_func
(paren
r_int
id|flags
)paren
(brace
id|alenlist_t
id|alenlist
suffix:semicolon
id|alenlist
op_assign
id|kmem_zone_alloc
c_func
(paren
id|alenlist_zone
comma
id|flags
op_amp
id|AL_NOSLEEP
ques
c_cond
id|VM_NOSLEEP
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alenlist
)paren
(brace
id|INCR_COUNT
c_func
(paren
op_amp
id|alenlist_count
)paren
suffix:semicolon
id|alenlist-&gt;al_flags
op_assign
l_int|0
suffix:semicolon
id|alenlist-&gt;al_logical_size
op_assign
l_int|0
suffix:semicolon
id|alenlist-&gt;al_actual_size
op_assign
id|ALEN_CHUNK_SZ
suffix:semicolon
id|alenlist-&gt;al_last_chunk
op_assign
op_amp
id|alenlist-&gt;al_chunk
suffix:semicolon
id|alenlist-&gt;al_chunk.alc_next
op_assign
l_int|NULL
suffix:semicolon
id|do_cursor_init
c_func
(paren
id|alenlist
comma
op_amp
id|alenlist-&gt;al_cursor
)paren
suffix:semicolon
)brace
r_return
id|alenlist
suffix:semicolon
)brace
multiline_comment|/*&n; * Grow an Address/Length List so that all resources needed to contain&n; * the specified number of Pairs are pre-allocated.  An Address/Length&n; * List that has been explicitly &quot;grown&quot; will never *automatically*&n; * grow, shrink, or be destroyed.&n; *&n; * Pre-allocation is useful for Real-Time drivers and for drivers that&n; * may be used along the swap-out path and therefore cannot afford to &n; * sleep until memory is freed.&n; * &n; * The cursor is set to the beginning of the list.&n; */
r_int
DECL|function|alenlist_grow
id|alenlist_grow
c_func
(paren
id|alenlist_t
id|alenlist
comma
r_int
id|npairs
)paren
(brace
multiline_comment|/* &n;&t; * This interface should be used relatively rarely, so&n;&t; * the implementation is kept simple: We clear the List,&n;&t; * then append npairs bogus entries.  Finally, we mark&n;&t; * the list as FIXED_SIZE and re-initialize the internal&n;&t; * cursor.&n;&t; */
multiline_comment|/* &n;&t; * Temporarily mark as non-fixed size, since we&squot;re about&n;&t; * to shrink and expand it.&n;&t; */
id|alenlist-&gt;al_flags
op_and_assign
op_complement
id|AL_FIXED_SIZE
suffix:semicolon
multiline_comment|/* Free whatever was in the alenlist. */
id|alenlist_clear
c_func
(paren
id|alenlist
)paren
suffix:semicolon
multiline_comment|/* Allocate everything that we need via automatic expansion. */
r_while
c_loop
(paren
id|npairs
op_decrement
)paren
r_if
c_cond
(paren
id|alenlist_append
c_func
(paren
id|alenlist
comma
l_int|0
comma
l_int|0
comma
id|AL_NOCOMPACT
)paren
op_eq
id|ALENLIST_FAILURE
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
multiline_comment|/* Now, mark as FIXED_SIZE */
id|alenlist-&gt;al_flags
op_or_assign
id|AL_FIXED_SIZE
suffix:semicolon
multiline_comment|/* Clear out bogus entries */
id|alenlist_clear
c_func
(paren
id|alenlist
)paren
suffix:semicolon
multiline_comment|/* Initialize internal cursor to the beginning */
id|do_cursor_init
c_func
(paren
id|alenlist
comma
op_amp
id|alenlist-&gt;al_cursor
)paren
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear an Address/Length List so that it holds no pairs.&n; */
r_void
DECL|function|alenlist_clear
id|alenlist_clear
c_func
(paren
id|alenlist_t
id|alenlist
)paren
(brace
id|alenlist_chunk_t
id|chunk
comma
id|freechunk
suffix:semicolon
multiline_comment|/*&n;&t; * If this List is not FIXED_SIZE, free all the&n;&t; * extra chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|alenlist-&gt;al_flags
op_amp
id|AL_FIXED_SIZE
)paren
)paren
(brace
multiline_comment|/* First, free any extension alenlist chunks */
id|chunk
op_assign
id|alenlist-&gt;al_chunk.alc_next
suffix:semicolon
r_while
c_loop
(paren
id|chunk
)paren
(brace
id|freechunk
op_assign
id|chunk
suffix:semicolon
id|chunk
op_assign
id|chunk-&gt;alc_next
suffix:semicolon
id|kmem_zone_free
c_func
(paren
id|alenlist_chunk_zone
comma
id|freechunk
)paren
suffix:semicolon
id|DECR_COUNT
c_func
(paren
op_amp
id|alenlist_chunk_count
)paren
suffix:semicolon
)brace
id|alenlist-&gt;al_actual_size
op_assign
id|ALEN_CHUNK_SZ
suffix:semicolon
id|alenlist-&gt;al_chunk.alc_next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|alenlist-&gt;al_logical_size
op_assign
l_int|0
suffix:semicolon
id|alenlist-&gt;al_last_chunk
op_assign
op_amp
id|alenlist-&gt;al_chunk
suffix:semicolon
id|do_cursor_init
c_func
(paren
id|alenlist
comma
op_amp
id|alenlist-&gt;al_cursor
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create and initialize an Address/Length Pair.&n; * This is intended for degenerate lists, consisting of a single &n; * address/length pair.&n; */
id|alenlist_t
DECL|function|alenpair_init
id|alenpair_init
c_func
(paren
id|alenaddr_t
id|address
comma
r_int
id|length
)paren
(brace
id|alenlist_t
id|alenlist
suffix:semicolon
id|alenlist
op_assign
id|alenlist_create
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|alenlist-&gt;al_logical_size
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|alenlist-&gt;al_last_chunk
op_eq
op_amp
id|alenlist-&gt;al_chunk
)paren
suffix:semicolon
id|alenlist-&gt;al_chunk.alc_pair
(braket
l_int|0
)braket
dot
id|al_length
op_assign
id|length
suffix:semicolon
id|alenlist-&gt;al_chunk.alc_pair
(braket
l_int|0
)braket
dot
id|al_addr
op_assign
id|address
suffix:semicolon
r_return
id|alenlist
suffix:semicolon
)brace
multiline_comment|/*&n; * Return address/length from a degenerate (1-pair) List, or&n; * first pair from a larger list.  Does NOT update the internal cursor,&n; * so this is an easy way to peek at a start address.&n; */
r_int
DECL|function|alenpair_get
id|alenpair_get
c_func
(paren
id|alenlist_t
id|alenlist
comma
id|alenaddr_t
op_star
id|address
comma
r_int
op_star
id|length
)paren
(brace
r_if
c_cond
(paren
id|alenlist-&gt;al_logical_size
op_eq
l_int|0
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
op_star
id|length
op_assign
id|alenlist-&gt;al_chunk.alc_pair
(braket
l_int|0
)braket
dot
id|al_length
suffix:semicolon
op_star
id|address
op_assign
id|alenlist-&gt;al_chunk.alc_pair
(braket
l_int|0
)braket
dot
id|al_addr
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy an Address/Length List.&n; */
r_void
DECL|function|alenlist_destroy
id|alenlist_destroy
c_func
(paren
id|alenlist_t
id|alenlist
)paren
(brace
r_if
c_cond
(paren
id|alenlist
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; * Turn off FIXED_SIZE so this List can be &n;&t; * automatically shrunk.&n;&t; */
id|alenlist-&gt;al_flags
op_and_assign
op_complement
id|AL_FIXED_SIZE
suffix:semicolon
multiline_comment|/* Free extension chunks first */
r_if
c_cond
(paren
id|alenlist-&gt;al_chunk.alc_next
)paren
id|alenlist_clear
c_func
(paren
id|alenlist
)paren
suffix:semicolon
multiline_comment|/* Now, free the alenlist itself */
id|kmem_zone_free
c_func
(paren
id|alenlist_zone
comma
id|alenlist
)paren
suffix:semicolon
id|DECR_COUNT
c_func
(paren
op_amp
id|alenlist_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release an Address/Length List.&n; * This is in preparation for a day when alenlist&squot;s may be longer-lived, and&n; * perhaps associated with a buf structure.  We&squot;d add a reference count, and&n; * this routine would decrement the count.  For now, we create alenlist&squot;s on&n; * on demand and free them when done.  If the driver is not explicitly managing&n; * a List for its own use, it should call alenlist_done rather than alenlist_destroy.&n; */
r_void
DECL|function|alenlist_done
id|alenlist_done
c_func
(paren
id|alenlist_t
id|alenlist
)paren
(brace
id|alenlist_destroy
c_func
(paren
id|alenlist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Append another address/length to the end of an Address/Length List,&n; * growing the list if permitted and necessary.&n; *&n; * Returns: SUCCESS/FAILURE&n; */
r_int
DECL|function|alenlist_append
id|alenlist_append
c_func
(paren
id|alenlist_t
id|alenlist
comma
multiline_comment|/* append to this list */
id|alenaddr_t
id|address
comma
multiline_comment|/* address to append */
r_int
id|length
comma
multiline_comment|/* length to append */
r_int
id|flags
)paren
(brace
id|alen_t
op_star
id|alenp
suffix:semicolon
r_int
id|index
comma
id|last_index
suffix:semicolon
id|index
op_assign
id|alenlist-&gt;al_logical_size
op_mod
id|ALEN_CHUNK_SZ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|alenlist-&gt;al_logical_size
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * See if we can compact this new pair in with the previous entry.&n;&t;&t; * al_compaction_address holds that value that we&squot;d need to see&n;&t;&t; * in order to compact.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|AL_NOCOMPACT
)paren
op_logical_and
(paren
id|alenlist-&gt;al_compaction_address
op_eq
id|address
)paren
)paren
(brace
id|last_index
op_assign
(paren
id|alenlist-&gt;al_logical_size
op_minus
l_int|1
)paren
op_mod
id|ALEN_CHUNK_SZ
suffix:semicolon
id|alenp
op_assign
op_amp
(paren
id|alenlist-&gt;al_last_chunk-&gt;alc_pair
(braket
id|last_index
)braket
)paren
suffix:semicolon
id|alenp-&gt;al_length
op_add_assign
id|length
suffix:semicolon
id|alenlist-&gt;al_compaction_address
op_add_assign
id|length
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re out of room in this chunk, move to a new chunk.&n;&t; &t; */
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|alenlist-&gt;al_flags
op_amp
id|AL_FIXED_SIZE
)paren
(brace
id|alenlist-&gt;al_last_chunk
op_assign
id|alenlist-&gt;al_last_chunk-&gt;alc_next
suffix:semicolon
multiline_comment|/* If we&squot;re out of space in a FIXED_SIZE List, quit. */
r_if
c_cond
(paren
id|alenlist-&gt;al_last_chunk
op_eq
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|alenlist-&gt;al_logical_size
op_eq
id|alenlist-&gt;al_actual_size
)paren
suffix:semicolon
r_return
id|ALENLIST_FAILURE
suffix:semicolon
)brace
)brace
r_else
(brace
id|alenlist_chunk_t
id|new_chunk
suffix:semicolon
id|new_chunk
op_assign
id|kmem_zone_alloc
c_func
(paren
id|alenlist_chunk_zone
comma
id|flags
op_amp
id|AL_NOSLEEP
ques
c_cond
id|VM_NOSLEEP
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_chunk
op_eq
l_int|NULL
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|alenlist-&gt;al_last_chunk-&gt;alc_next
op_assign
id|new_chunk
suffix:semicolon
id|new_chunk-&gt;alc_next
op_assign
l_int|NULL
suffix:semicolon
id|alenlist-&gt;al_last_chunk
op_assign
id|new_chunk
suffix:semicolon
id|alenlist-&gt;al_actual_size
op_add_assign
id|ALEN_CHUNK_SZ
suffix:semicolon
id|INCR_COUNT
c_func
(paren
op_amp
id|alenlist_chunk_count
)paren
suffix:semicolon
)brace
)brace
)brace
id|alenp
op_assign
op_amp
(paren
id|alenlist-&gt;al_last_chunk-&gt;alc_pair
(braket
id|index
)braket
)paren
suffix:semicolon
id|alenp-&gt;al_addr
op_assign
id|address
suffix:semicolon
id|alenp-&gt;al_length
op_assign
id|length
suffix:semicolon
id|alenlist-&gt;al_logical_size
op_increment
suffix:semicolon
id|alenlist-&gt;al_compaction_address
op_assign
id|address
op_plus
id|length
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace an item in an Address/Length List.  Cursor is updated so&n; * that alenlist_get will get the next item in the list.  This interface &n; * is not very useful for drivers; but it is useful to bus providers &n; * that need to translate between address spaced in situ.  The old Address&n; * and Length are returned.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|alenlist_replace
id|alenlist_replace
c_func
(paren
id|alenlist_t
id|alenlist
comma
multiline_comment|/* in: replace in this list */
id|alenlist_cursor_t
id|cursorp
comma
multiline_comment|/* inout: which item to replace */
id|alenaddr_t
op_star
id|addrp
comma
multiline_comment|/* inout: address */
r_int
op_star
id|lengthp
comma
multiline_comment|/* inout: length */
r_int
id|flags
)paren
(brace
id|alen_t
op_star
id|alenp
suffix:semicolon
id|alenlist_chunk_t
id|chunk
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_int
id|length
suffix:semicolon
id|alenaddr_t
id|addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addrp
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|lengthp
op_eq
l_int|NULL
)paren
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
r_if
c_cond
(paren
id|alenlist-&gt;al_logical_size
op_eq
l_int|0
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|addr
op_assign
op_star
id|addrp
suffix:semicolon
id|length
op_assign
op_star
id|lengthp
suffix:semicolon
multiline_comment|/* &n;&t; * If no cursor explicitly specified, use the Address/Length List&squot;s &n;&t; * internal cursor.&n;&t; */
r_if
c_cond
(paren
id|cursorp
op_eq
l_int|NULL
)paren
id|cursorp
op_assign
op_amp
id|alenlist-&gt;al_cursor
suffix:semicolon
id|chunk
op_assign
id|cursorp-&gt;al_chunk
suffix:semicolon
id|index
op_assign
id|cursorp-&gt;al_index
suffix:semicolon
id|ASSERT
c_func
(paren
id|cursorp-&gt;al_alenlist
op_eq
id|alenlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cursorp-&gt;al_alenlist
op_ne
id|alenlist
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|alenp
op_assign
op_amp
id|chunk-&gt;alc_pair
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* Return old values */
op_star
id|addrp
op_assign
id|alenp-&gt;al_length
suffix:semicolon
op_star
id|lengthp
op_assign
id|alenp-&gt;al_addr
suffix:semicolon
multiline_comment|/* Set up new values */
id|alenp-&gt;al_length
op_assign
id|length
suffix:semicolon
id|alenp-&gt;al_addr
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Update cursor to point to next item */
id|cursorp-&gt;al_bcount
op_assign
id|length
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a cursor in order to walk an alenlist.&n; * An alenlist_cursor always points to the last thing that was obtained&n; * from the list.  If al_chunk is NULL, then nothing has yet been obtained.&n; *&n; * Note: There is an &quot;internal cursor&quot; associated with every Address/Length List.&n; * For users that scan sequentially through a List, it is more efficient to&n; * simply use the internal cursor.  The caller must insure that no other users&n; * will simultaneously scan the List.  The caller can reposition the internal&n; * cursor by calling alenlist_cursor_init with a NULL cursorp.&n; */
r_int
DECL|function|alenlist_cursor_init
id|alenlist_cursor_init
c_func
(paren
id|alenlist_t
id|alenlist
comma
r_int
id|offset
comma
id|alenlist_cursor_t
id|cursorp
)paren
(brace
r_int
id|byte_count
suffix:semicolon
r_if
c_cond
(paren
id|cursorp
op_eq
l_int|NULL
)paren
id|cursorp
op_assign
op_amp
id|alenlist-&gt;al_cursor
suffix:semicolon
multiline_comment|/* Get internal cursor&squot;s byte count for use as a hint.&n;&t; *&n;&t; * If the internal cursor points passed the point that we&squot;re interested in,&n;&t; * we need to seek forward from the beginning.  Otherwise, we can seek forward&n;&t; * from the internal cursor.&n;&t; */
r_if
c_cond
(paren
(paren
id|offset
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|byte_count
op_assign
id|alenlist_cursor_offset
c_func
(paren
id|alenlist
comma
(paren
id|alenlist_cursor_t
)paren
l_int|NULL
)paren
)paren
op_le
id|offset
)paren
)paren
(brace
id|offset
op_sub_assign
id|byte_count
suffix:semicolon
id|alenlist_cursor_clone
c_func
(paren
id|alenlist
comma
l_int|NULL
comma
id|cursorp
)paren
suffix:semicolon
)brace
r_else
id|do_cursor_init
c_func
(paren
id|alenlist
comma
id|cursorp
)paren
suffix:semicolon
multiline_comment|/* We could easily speed this up, but it shouldn&squot;t be used very often. */
r_while
c_loop
(paren
id|offset
op_ne
l_int|0
)paren
(brace
id|alenaddr_t
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
id|alenlist_get
c_func
(paren
id|alenlist
comma
id|cursorp
comma
id|offset
comma
op_amp
id|addr
comma
op_amp
id|length
comma
l_int|0
)paren
op_ne
id|ALENLIST_SUCCESS
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|offset
op_sub_assign
id|length
suffix:semicolon
)brace
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy a cursor.  The source cursor is either an internal alenlist cursor&n; * or an explicit cursor.&n; */
r_int
DECL|function|alenlist_cursor_clone
id|alenlist_cursor_clone
c_func
(paren
id|alenlist_t
id|alenlist
comma
id|alenlist_cursor_t
id|cursorp_in
comma
id|alenlist_cursor_t
id|cursorp_out
)paren
(brace
id|ASSERT
c_func
(paren
id|cursorp_out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alenlist
op_logical_and
id|cursorp_in
)paren
r_if
c_cond
(paren
id|alenlist
op_ne
id|cursorp_in-&gt;al_alenlist
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
r_if
c_cond
(paren
id|alenlist
)paren
op_star
id|cursorp_out
op_assign
id|alenlist-&gt;al_cursor
suffix:semicolon
multiline_comment|/* small structure copy */
r_else
r_if
c_cond
(paren
id|cursorp_in
)paren
op_star
id|cursorp_out
op_assign
op_star
id|cursorp_in
suffix:semicolon
multiline_comment|/* small structure copy */
r_else
r_return
id|ALENLIST_FAILURE
suffix:semicolon
multiline_comment|/* no source */
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the number of bytes passed so far according to the specified cursor.&n; * If cursorp is NULL, use the alenlist&squot;s internal cursor.&n; */
r_int
DECL|function|alenlist_cursor_offset
id|alenlist_cursor_offset
c_func
(paren
id|alenlist_t
id|alenlist
comma
id|alenlist_cursor_t
id|cursorp
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|alenlist
op_logical_or
op_logical_neg
id|cursorp
op_logical_or
(paren
id|alenlist
op_eq
id|cursorp-&gt;al_alenlist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cursorp
op_eq
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|alenlist
)paren
suffix:semicolon
id|cursorp
op_assign
op_amp
id|alenlist-&gt;al_cursor
suffix:semicolon
)brace
r_return
id|cursorp-&gt;al_offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and initialize an Address/Length List cursor.&n; */
id|alenlist_cursor_t
DECL|function|alenlist_cursor_create
id|alenlist_cursor_create
c_func
(paren
id|alenlist_t
id|alenlist
comma
r_int
id|flags
)paren
(brace
id|alenlist_cursor_t
id|cursorp
suffix:semicolon
id|ASSERT
c_func
(paren
id|alenlist
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cursorp
op_assign
id|kmem_zone_alloc
c_func
(paren
id|alenlist_cursor_zone
comma
id|flags
op_amp
id|AL_NOSLEEP
ques
c_cond
id|VM_NOSLEEP
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cursorp
)paren
(brace
id|INCR_COUNT
c_func
(paren
op_amp
id|alenlist_cursor_count
)paren
suffix:semicolon
id|alenlist_cursor_init
c_func
(paren
id|alenlist
comma
l_int|0
comma
id|cursorp
)paren
suffix:semicolon
)brace
r_return
id|cursorp
suffix:semicolon
)brace
multiline_comment|/*&n; * Free an Address/Length List cursor.&n; */
r_void
DECL|function|alenlist_cursor_destroy
id|alenlist_cursor_destroy
c_func
(paren
id|alenlist_cursor_t
id|cursorp
)paren
(brace
id|DECR_COUNT
c_func
(paren
op_amp
id|alenlist_cursor_count
)paren
suffix:semicolon
id|kmem_zone_free
c_func
(paren
id|alenlist_cursor_zone
comma
id|cursorp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch an address/length pair from an Address/Length List.  Update&n; * the &quot;cursor&quot; so that next time this routine is called, we&squot;ll get&n; * the next address range.  Never return a length that exceeds maxlength&n; * (if non-zero).  If maxlength is a power of 2, never return a length &n; * that crosses a maxlength boundary.  [This may seem strange at first,&n; * but it&squot;s what many drivers want.]&n; *&n; * Returns: SUCCESS/FAILURE&n; */
r_int
DECL|function|alenlist_get
id|alenlist_get
c_func
(paren
id|alenlist_t
id|alenlist
comma
multiline_comment|/* in: get from this list */
id|alenlist_cursor_t
id|cursorp
comma
multiline_comment|/* inout: which item to get */
r_int
id|maxlength
comma
multiline_comment|/* in: at most this length */
id|alenaddr_t
op_star
id|addrp
comma
multiline_comment|/* out: address */
r_int
op_star
id|lengthp
comma
multiline_comment|/* out: length */
r_int
id|flags
)paren
(brace
id|alen_t
op_star
id|alenp
suffix:semicolon
id|alenlist_chunk_t
id|chunk
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_int
id|bcount
suffix:semicolon
r_int
id|length
suffix:semicolon
multiline_comment|/* &n;&t; * If no cursor explicitly specified, use the Address/Length List&squot;s &n;&t; * internal cursor.&n;&t; */
r_if
c_cond
(paren
id|cursorp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|alenlist-&gt;al_logical_size
op_eq
l_int|0
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|cursorp
op_assign
op_amp
id|alenlist-&gt;al_cursor
suffix:semicolon
)brace
id|chunk
op_assign
id|cursorp-&gt;al_chunk
suffix:semicolon
id|index
op_assign
id|cursorp-&gt;al_index
suffix:semicolon
id|bcount
op_assign
id|cursorp-&gt;al_bcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|cursorp-&gt;al_alenlist
op_eq
id|alenlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cursorp-&gt;al_alenlist
op_ne
id|alenlist
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|alenp
op_assign
op_amp
id|chunk-&gt;alc_pair
(braket
id|index
)braket
suffix:semicolon
id|length
op_assign
id|alenp-&gt;al_length
op_minus
id|bcount
suffix:semicolon
multiline_comment|/* Bump up to next pair, if we&squot;re done with this pair. */
r_if
c_cond
(paren
id|length
op_eq
l_int|0
)paren
(brace
id|cursorp-&gt;al_bcount
op_assign
id|bcount
op_assign
l_int|0
suffix:semicolon
id|cursorp-&gt;al_index
op_assign
id|index
op_assign
(paren
id|index
op_plus
l_int|1
)paren
op_mod
id|ALEN_CHUNK_SZ
suffix:semicolon
multiline_comment|/* Bump up to next chunk, if we&squot;re done with this chunk. */
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cursorp-&gt;al_chunk
op_eq
id|alenlist-&gt;al_last_chunk
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
id|chunk
op_assign
id|chunk-&gt;alc_next
suffix:semicolon
id|ASSERT
c_func
(paren
id|chunk
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If in last chunk, don&squot;t go beyond end. */
r_if
c_cond
(paren
id|cursorp-&gt;al_chunk
op_eq
id|alenlist-&gt;al_last_chunk
)paren
(brace
r_int
id|last_size
op_assign
id|alenlist-&gt;al_logical_size
op_mod
id|ALEN_CHUNK_SZ
suffix:semicolon
r_if
c_cond
(paren
id|last_size
op_logical_and
(paren
id|index
op_ge
id|last_size
)paren
)paren
r_return
id|ALENLIST_FAILURE
suffix:semicolon
)brace
)brace
id|alenp
op_assign
op_amp
id|chunk-&gt;alc_pair
(braket
id|index
)braket
suffix:semicolon
id|length
op_assign
id|alenp-&gt;al_length
suffix:semicolon
)brace
multiline_comment|/* Constrain what we return according to maxlength */
r_if
c_cond
(paren
id|maxlength
)paren
(brace
r_int
id|maxlen1
op_assign
id|maxlength
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|maxlength
op_amp
id|maxlen1
)paren
op_eq
l_int|0
)paren
multiline_comment|/* power of 2 */
id|maxlength
op_sub_assign
(paren
(paren
id|alenp-&gt;al_addr
op_plus
id|cursorp-&gt;al_bcount
)paren
op_amp
id|maxlen1
)paren
suffix:semicolon
id|length
op_assign
id|MIN
c_func
(paren
id|maxlength
comma
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the cursor, if desired. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|AL_LEAVE_CURSOR
)paren
)paren
(brace
id|cursorp-&gt;al_bcount
op_add_assign
id|length
suffix:semicolon
id|cursorp-&gt;al_chunk
op_assign
id|chunk
suffix:semicolon
)brace
op_star
id|lengthp
op_assign
id|length
suffix:semicolon
op_star
id|addrp
op_assign
id|alenp-&gt;al_addr
op_plus
id|bcount
suffix:semicolon
r_return
id|ALENLIST_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the number of pairs in the specified Address/Length List.&n; * (For FIXED_SIZE Lists, this returns the logical size of the List, &n; * not the actual capacity of the List.)&n; */
r_int
DECL|function|alenlist_size
id|alenlist_size
c_func
(paren
id|alenlist_t
id|alenlist
)paren
(brace
r_return
id|alenlist-&gt;al_logical_size
suffix:semicolon
)brace
multiline_comment|/*&n; * Concatenate two Address/Length Lists.&n; */
r_void
DECL|function|alenlist_concat
id|alenlist_concat
c_func
(paren
id|alenlist_t
id|from
comma
id|alenlist_t
id|to
)paren
(brace
r_struct
id|alenlist_cursor_s
id|cursor
suffix:semicolon
id|alenaddr_t
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
id|alenlist_cursor_init
c_func
(paren
id|from
comma
l_int|0
comma
op_amp
id|cursor
)paren
suffix:semicolon
r_while
c_loop
(paren
id|alenlist_get
c_func
(paren
id|from
comma
op_amp
id|cursor
comma
(paren
r_int
)paren
l_int|0
comma
op_amp
id|addr
comma
op_amp
id|length
comma
l_int|0
)paren
op_eq
id|ALENLIST_SUCCESS
)paren
(brace
id|alenlist_append
c_func
(paren
id|to
comma
id|addr
comma
id|length
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Create a copy of a list.&n; * (Not all attributes of the old list are cloned.  For instance, if&n; * a FIXED_SIZE list is cloned, the resulting list is NOT FIXED_SIZE.)&n; */
id|alenlist_t
DECL|function|alenlist_clone
id|alenlist_clone
c_func
(paren
id|alenlist_t
id|old_list
comma
r_int
id|flags
)paren
(brace
id|alenlist_t
id|new_list
suffix:semicolon
id|new_list
op_assign
id|alenlist_create
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_list
op_ne
l_int|NULL
)paren
id|alenlist_concat
c_func
(paren
id|old_list
comma
id|new_list
)paren
suffix:semicolon
r_return
id|new_list
suffix:semicolon
)brace
multiline_comment|/* &n; * Convert a kernel virtual address to a Physical Address/Length List.&n; */
id|alenlist_t
DECL|function|kvaddr_to_alenlist
id|kvaddr_to_alenlist
c_func
(paren
id|alenlist_t
id|alenlist
comma
id|caddr_t
id|kvaddr
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
id|alenaddr_t
id|paddr
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|piece_length
suffix:semicolon
r_int
id|created_alenlist
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If caller supplied a List, use it.  Otherwise, allocate one. */
r_if
c_cond
(paren
id|alenlist
op_eq
l_int|NULL
)paren
(brace
id|alenlist
op_assign
id|alenlist_create
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|created_alenlist
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|alenlist_clear
c_func
(paren
id|alenlist
)paren
suffix:semicolon
id|created_alenlist
op_assign
l_int|0
suffix:semicolon
)brace
id|paddr
op_assign
id|kvtophys
c_func
(paren
id|kvaddr
)paren
suffix:semicolon
id|offset
op_assign
id|poff
c_func
(paren
id|kvaddr
)paren
suffix:semicolon
multiline_comment|/* Handle first page */
id|piece_length
op_assign
id|MIN
c_func
(paren
id|NBPP
op_minus
id|offset
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alenlist_append
c_func
(paren
id|alenlist
comma
id|paddr
comma
id|piece_length
comma
id|flags
)paren
op_eq
id|ALENLIST_FAILURE
)paren
r_goto
id|failure
suffix:semicolon
id|length
op_sub_assign
id|piece_length
suffix:semicolon
id|kvaddr
op_add_assign
id|piece_length
suffix:semicolon
multiline_comment|/* Handle middle pages */
r_while
c_loop
(paren
id|length
op_ge
id|NBPP
)paren
(brace
id|paddr
op_assign
id|kvtophys
c_func
(paren
id|kvaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alenlist_append
c_func
(paren
id|alenlist
comma
id|paddr
comma
id|NBPP
comma
id|flags
)paren
op_eq
id|ALENLIST_FAILURE
)paren
r_goto
id|failure
suffix:semicolon
id|length
op_sub_assign
id|NBPP
suffix:semicolon
id|kvaddr
op_add_assign
id|NBPP
suffix:semicolon
)brace
multiline_comment|/* Handle last page */
r_if
c_cond
(paren
id|length
)paren
(brace
id|ASSERT
c_func
(paren
id|length
OL
id|NBPP
)paren
suffix:semicolon
id|paddr
op_assign
id|kvtophys
c_func
(paren
id|kvaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alenlist_append
c_func
(paren
id|alenlist
comma
id|paddr
comma
id|length
comma
id|flags
)paren
op_eq
id|ALENLIST_FAILURE
)paren
r_goto
id|failure
suffix:semicolon
)brace
id|alenlist_cursor_init
c_func
(paren
id|alenlist
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|alenlist
suffix:semicolon
id|failure
suffix:colon
r_if
c_cond
(paren
id|created_alenlist
)paren
id|alenlist_destroy
c_func
(paren
id|alenlist
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if DEBUG
r_static
r_void
DECL|function|alenlist_show
id|alenlist_show
c_func
(paren
id|alenlist_t
id|alenlist
)paren
(brace
r_struct
id|alenlist_cursor_s
id|cursor
suffix:semicolon
id|alenaddr_t
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|alenlist_cursor_init
c_func
(paren
id|alenlist
comma
l_int|0
comma
op_amp
id|cursor
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;Address/Length List@0x%x:&bslash;n&quot;
comma
id|alenlist
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;logical size=0x%x actual size=0x%x last_chunk at 0x%x&bslash;n&quot;
comma
id|alenlist-&gt;al_logical_size
comma
id|alenlist-&gt;al_actual_size
comma
id|alenlist-&gt;al_last_chunk
)paren
suffix:semicolon
id|qprintf
c_func
(paren
l_string|&quot;cursor: chunk=0x%x index=%d offset=0x%x&bslash;n&quot;
comma
id|alenlist-&gt;al_cursor.al_chunk
comma
id|alenlist-&gt;al_cursor.al_index
comma
id|alenlist-&gt;al_cursor.al_bcount
)paren
suffix:semicolon
r_while
c_loop
(paren
id|alenlist_get
c_func
(paren
id|alenlist
comma
op_amp
id|cursor
comma
(paren
r_int
)paren
l_int|0
comma
op_amp
id|addr
comma
op_amp
id|length
comma
l_int|0
)paren
op_eq
id|ALENLIST_SUCCESS
)paren
(brace
id|qprintf
c_func
(paren
l_string|&quot;%d:&bslash;t0x%lx 0x%lx&bslash;n&quot;
comma
op_increment
id|i
comma
id|addr
comma
id|length
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG */
eof
