multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/synergy.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
r_extern
r_void
id|mlreset
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|init_hcl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|klgraph_hack_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|per_hub_init
c_func
(paren
id|cnodeid_t
)paren
suffix:semicolon
r_extern
r_void
id|hubspc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pciba_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pciio_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|xtalk_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|xbow_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|xbmon_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pciiox_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usrpci_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ioc3_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|initialize_io
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_platform_nodepda
c_func
(paren
id|nodepda_t
op_star
comma
id|cnodeid_t
)paren
suffix:semicolon
r_extern
r_void
id|intr_clear_all
c_func
(paren
id|nasid_t
)paren
suffix:semicolon
r_extern
r_void
id|klhwg_add_all_modules
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_extern
r_void
id|klhwg_add_all_nodes
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_void
id|sn_mp_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|devfs_handle_t
id|hwgraph_root
suffix:semicolon
r_extern
r_void
id|io_module_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|cnodeid_t
id|nasid_to_compact_node
(braket
)braket
suffix:semicolon
r_extern
r_void
id|pci_bus_cvlink_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|temp_hack
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_platform_pda
c_func
(paren
id|cpuid_t
id|cpu
)paren
suffix:semicolon
r_extern
r_int
id|pci_bus_to_hcl_cvlink
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|synergy_da_t
op_star
id|Synergy_da_indr
(braket
)braket
suffix:semicolon
DECL|macro|DEBUG_IO_INIT
mdefine_line|#define DEBUG_IO_INIT
macro_line|#ifdef DEBUG_IO_INIT
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif /* DEBUG_IO_INIT */
multiline_comment|/*&n; * kern/ml/csu.s calls mlsetup&n; *   mlsetup calls mlreset(master) - kern/os/startup.c&n; *   j main&n; *&n; &n; * SN/slave.s start_slave_loop calls slave_entry&n; * SN/slave.s slave_entry calls slave_loop&n; * SN/slave.s slave_loop calls bootstrap&n; * bootstrap in SN1/SN1asm.s calls cboot&n; * cboot calls mlreset(slave) - ml/SN/mp.c&n; *&n; * sgi_io_infrastructure_init() gets called right before pci_init() &n; * in Linux mainline.  This routine actually mirrors the IO Infrastructure &n; * call sequence in IRIX, ofcourse, nicely modified for Linux.&n; *&n; * It is very IMPORTANT that this call is only made by the Master CPU!&n; *&n; */
r_void
DECL|function|sgi_master_io_infr_init
id|sgi_master_io_infr_init
c_func
(paren
r_void
)paren
(brace
r_int
id|cnode
suffix:semicolon
r_extern
r_int
id|maxnodes
suffix:semicolon
multiline_comment|/*&n;&t; * Do any early init stuff .. einit_tbl[] etc.&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling init_hcl().&bslash;n&quot;
)paren
suffix:semicolon
id|init_hcl
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Sets up the hwgraph compatibility layer with devfs */
multiline_comment|/*&n;&t; * initialize the Linux PCI to xwidget vertexes ..&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling pci_bus_cvlink_init().&bslash;n&quot;
)paren
suffix:semicolon
id|pci_bus_cvlink_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hack to provide statically initialzed klgraph entries.&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling klgraph_hack_init()&bslash;n&quot;
)paren
suffix:semicolon
id|klgraph_hack_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is the Master CPU.  Emulate mlsetup and main.c in Irix.&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling mlreset(0).&bslash;n&quot;
)paren
suffix:semicolon
id|mlreset
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Master .. */
multiline_comment|/*&n;&t; * allowboot() is called by kern/os/main.c in main()&n;&t; * Emulate allowboot() ...&n;&t; *   per_cpu_init() - only need per_hub_init()&n;&t; *   cpu_io_setup() - Nothing to do.&n;&t; * &n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling sn_mp_setup().&bslash;n&quot;
)paren
suffix:semicolon
id|sn_mp_setup
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling per_hub_init(0).&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|maxnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|per_hub_init
c_func
(paren
id|cnode
)paren
suffix:semicolon
)brace
multiline_comment|/* We can do headless hub cnodes here .. */
multiline_comment|/*&n;&t; * io_init[] stuff.&n;&t; *&n;&t; * Get SGI IO Infrastructure drivers to init and register with &n;&t; * each other etc.&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling hubspc_init()&bslash;n&quot;
)paren
suffix:semicolon
id|hubspc_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling pciba_init()&bslash;n&quot;
)paren
suffix:semicolon
id|pciba_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling pciio_init()&bslash;n&quot;
)paren
suffix:semicolon
id|pciio_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling pcibr_init()&bslash;n&quot;
)paren
suffix:semicolon
id|pcibr_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling xtalk_init()&bslash;n&quot;
)paren
suffix:semicolon
id|xtalk_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling xbow_init()&bslash;n&quot;
)paren
suffix:semicolon
id|xbow_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling xbmon_init()&bslash;n&quot;
)paren
suffix:semicolon
id|xbmon_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling pciiox_init()&bslash;n&quot;
)paren
suffix:semicolon
id|pciiox_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling usrpci_init()&bslash;n&quot;
)paren
suffix:semicolon
id|usrpci_init
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: calling ioc3_init()&bslash;n&quot;
)paren
suffix:semicolon
id|ioc3_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&n;&t; * Our IO Infrastructure drivers are in place .. &n;&t; * Initialize the whole IO Infrastructure .. xwidget/device probes.&n;&t; *&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: Start Probe and IO Initialization&bslash;n&quot;
)paren
suffix:semicolon
id|initialize_io
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; sgi_master_io_infr_init: Setting up SGI IO Links for Linux PCI&bslash;n&quot;
)paren
suffix:semicolon
id|pci_bus_to_hcl_cvlink
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;--&gt; Leave sgi_master_io_infr_init: DONE setting up SGI Links for PCI&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sgi_slave_io_infr_init - This routine must be called on all cpus except &n; * the Master CPU.&n; */
r_void
DECL|function|sgi_slave_io_infr_init
id|sgi_slave_io_infr_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Emulate cboot() .. */
id|mlreset
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* This is a slave cpu */
singleline_comment|// per_hub_init(0); /* Need to get and send in actual cnode number */
multiline_comment|/* Done */
)brace
multiline_comment|/*&n; * One-time setup for MP SN.&n; * Allocate per-node data, slurp prom klconfig information and&n; * convert it to hwgraph information.&n; */
r_void
DECL|function|sn_mp_setup
id|sn_mp_setup
c_func
(paren
r_void
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
r_extern
r_int
id|maxnodes
suffix:semicolon
id|cpuid_t
id|cpu
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;sn_mp_setup: Entered.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NODEPDA(x) Macro depends on nodepda&n;&t; * subnodepda is also statically set to calias space which we &n;&t; * do not currently support yet .. just a hack for now.&n;&t; */
macro_line|#ifdef NUMA_BASE
id|maxnodes
op_assign
id|numnodes
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;sn_mp_setup(): maxnodes= %d  numnodes= %d&bslash;n&quot;
comma
id|maxnodes
comma
id|numnodes
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn_mp_setup(): Allocating backing store for *Nodepdaindr[%2d] &bslash;n&quot;
comma
id|maxnodes
)paren
suffix:semicolon
multiline_comment|/*&n;         * Initialize Nodpdaindr and per-node nodepdaindr array&n;         */
op_star
id|Nodepdaindr
op_assign
(paren
id|nodepda_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|nodepda_t
op_star
)paren
op_star
id|numnodes
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|maxnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|Nodepdaindr
(braket
id|cnode
)braket
op_assign
(paren
id|nodepda_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nodepda_s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|Synergy_da_indr
(braket
id|cnode
op_star
l_int|2
)braket
op_assign
(paren
id|synergy_da_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|synergy_da_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|Synergy_da_indr
(braket
(paren
id|cnode
op_star
l_int|2
)paren
op_plus
l_int|1
)braket
op_assign
(paren
id|synergy_da_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|synergy_da_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|Nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|pernode_pdaindr
op_assign
id|Nodepdaindr
suffix:semicolon
id|subnodepda
op_assign
op_amp
id|Nodepdaindr
(braket
id|cnode
)braket
op_member_access_from_pointer
id|snpda
(braket
id|cnode
)braket
suffix:semicolon
)brace
id|nodepda
op_assign
id|Nodepdaindr
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#else
id|Nodepdaindr
op_assign
(paren
id|nodepda_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nodepda_s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|nodepda
op_assign
id|Nodepdaindr
(braket
l_int|0
)braket
suffix:semicolon
id|subnodepda
op_assign
op_amp
id|Nodepdaindr
(braket
l_int|0
)braket
op_member_access_from_pointer
id|snpda
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#endif /* NUMA_BASE */
multiline_comment|/*&n;&t; * Before we let the other processors run, set up the platform specific&n;&t; * stuff in the nodepda.&n;&t; *&n;&t; * ???? maxnodes set in mlreset .. who sets it now ????&n;&t; * ???? cpu_node_probe() called in mlreset to set up the following:&n;&t; *      compact_to_nasid_node[] - cnode id gives nasid&n;&t; *      nasid_to_compact_node[] - nasid gives cnode id&n;&t; *&n;&t; *&t;do_cpumask() sets the following:&n;&t; *      cpuid_to_compact_node[] - cpuid gives cnode id&n;&t; *&n;&t; *      nasid comes from gdap-&gt;g_nasidtable[]&n;&t; *      ml/SN/promif.c&n;&t; */
macro_line|#ifdef CONFIG_IA64_SGI_SN1
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|smp_num_cpus
suffix:semicolon
id|cpu
op_increment
)paren
(brace
multiline_comment|/* Skip holes in CPU space */
r_if
c_cond
(paren
id|cpu_enabled
c_func
(paren
id|cpu
)paren
)paren
(brace
id|init_platform_pda
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|maxnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set up platform-dependent nodepda fields.&n;&t;&t; * The following routine actually sets up the hubinfo struct&n;&t;&t; * in nodepda.&n;&t;&t; */
id|DBG
c_func
(paren
l_string|&quot;sn_mp_io_setup: calling init_platform_nodepda(%2d)&bslash;n&quot;
comma
id|cnode
)paren
suffix:semicolon
id|init_platform_nodepda
c_func
(paren
id|Nodepdaindr
(braket
id|cnode
)braket
comma
id|cnode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize platform-dependent vertices in the hwgraph:&n;&t; *&t;module&n;&t; *&t;node&n;&t; *&t;cpu&n;&t; *&t;memory&n;&t; *&t;slot&n;&t; *&t;hub&n;&t; *&t;router&n;&t; *&t;xbow&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;sn_mp_io_setup: calling io_module_init()&bslash;n&quot;
)paren
suffix:semicolon
id|io_module_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Use to be called module_init() .. */
id|DBG
c_func
(paren
l_string|&quot;sn_mp_setup: calling klhwg_add_all_modules()&bslash;n&quot;
)paren
suffix:semicolon
id|klhwg_add_all_modules
c_func
(paren
id|hwgraph_root
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;sn_mp_setup: calling klhwg_add_all_nodes()&bslash;n&quot;
)paren
suffix:semicolon
id|klhwg_add_all_nodes
c_func
(paren
id|hwgraph_root
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|maxnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * This routine clears the Hub&squot;s Interrupt registers.&n;&t;&t; */
macro_line|#ifdef CONFIG_IA64_SGI_SN1
multiline_comment|/*&n;&t;&t; * We need to move this intr_clear_all() routine &n;&t;&t; * from SN/intr.c to a more appropriate file.&n;&t;&t; * Talk to Al Mayer.&n;&t;&t; */
id|intr_clear_all
c_func
(paren
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
)paren
suffix:semicolon
multiline_comment|/* now init the hub */
singleline_comment|//&t;per_hub_init(cnode);
macro_line|#endif
)brace
macro_line|#if defined(CONFIG_IA64_SGI_SYNERGY_PERF)
id|synergy_perf_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IA64_SGI_SYNERGY_PERF */
)brace
eof
