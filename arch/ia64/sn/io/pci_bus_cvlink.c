multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/hack.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/cmn_err.h&gt;
macro_line|#include &lt;asm/sn/iobus.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/sn/pio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalkaddrs.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
singleline_comment|// #include &lt;sys/ql.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
r_extern
r_int
id|bridge_rev_b_data_check_disable
suffix:semicolon
DECL|macro|MAX_PCI_XWIDGET
mdefine_line|#define MAX_PCI_XWIDGET 256
DECL|variable|busnum_to_xwidget
id|devfs_handle_t
id|busnum_to_xwidget
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|busnum_to_nid
id|nasid_t
id|busnum_to_nid
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|num_bridges
r_int
r_char
id|num_bridges
suffix:semicolon
DECL|variable|done_probing
r_static
r_int
id|done_probing
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|pci_bus_map_create
c_func
(paren
id|devfs_handle_t
id|xtalk
)paren
suffix:semicolon
id|devfs_handle_t
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
suffix:semicolon
multiline_comment|/*&n; * pci_bus_cvlink_init() - To be called once during initialization before &n; *&t;SGI IO Infrastructure init is called.&n; */
r_void
DECL|function|pci_bus_cvlink_init
id|pci_bus_cvlink_init
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|busnum_to_xwidget
comma
l_int|0x0
comma
r_sizeof
(paren
id|devfs_handle_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_nid
comma
l_int|0x0
comma
r_sizeof
(paren
id|nasid_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|num_bridges
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_vertex() - Given a logical Linux Bus Number returns the associated &n; *&t;pci bus vertex from the SGI IO Infrastructure.&n; */
id|devfs_handle_t
DECL|function|pci_bus_to_vertex
id|pci_bus_to_vertex
c_func
(paren
r_int
r_char
id|busnum
)paren
(brace
id|devfs_handle_t
id|xwidget
suffix:semicolon
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * First get the xwidget vertex.&n;&t; */
id|xwidget
op_assign
id|busnum_to_xwidget
(braket
id|busnum
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xwidget
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Use devfs to get the pci vertex from xwidget.&n;&t; */
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xwidget
comma
id|EDGE_LBL_PCI
comma
op_amp
id|pci_bus
)paren
op_ne
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_to_vertex: Cannot find pci bus for given bus number %d&bslash;n&quot;
comma
id|busnum
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_return
id|pci_bus
suffix:semicolon
)brace
multiline_comment|/*&n; * devfn_to_vertex() - returns the vertex of the device given the bus, slot, &n; *&t;and function numbers.&n; */
id|devfs_handle_t
DECL|function|devfn_to_vertex
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
(brace
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
r_int
id|func
op_assign
l_int|0
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|device_vertex
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Go get the pci bus vertex.&n;&t; */
id|pci_bus
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
(brace
multiline_comment|/*&n;&t;&t; * During probing, the Linux pci code invents non existant&n;&t;&t; * bus numbers and pci_dev structures and tries to access&n;&t;&t; * them to determine existance. Don&squot;t crib during probing.&n;&t;&t; */
r_if
c_cond
(paren
id|done_probing
)paren
id|printk
c_func
(paren
l_string|&quot;devfn_to_vertex: Invalid bus number %d given.&bslash;n&quot;
comma
id|busnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go get the slot&amp;function vertex.&n;&t; * Should call pciio_slot_func_to_name() when ready.&n;&t; */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
suffix:semicolon
id|func
op_assign
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d%c&quot;
comma
id|slot
comma
l_char|&squot;a&squot;
op_plus
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|pci_bus
comma
id|name
comma
op_amp
id|device_vertex
)paren
op_ne
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device_vertex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;devfn_to_vertex: Unable to get slot&amp;func %s from pci vertex 0x%p&bslash;n&quot;
comma
id|name
comma
id|pci_bus
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|device_vertex
suffix:semicolon
)brace
multiline_comment|/*&n; * Most drivers currently do not properly tell the arch specific pci dma&n; * interfaces whether they can handle A64. Here is where we privately&n; * keep track of this.&n; */
r_static
r_void
id|__init
DECL|function|set_sn1_pci64
id|set_sn1_pci64
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|vendor
op_assign
id|dev-&gt;vendor
suffix:semicolon
r_int
r_int
id|device
op_assign
id|dev-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_QLOGIC
)paren
(brace
r_if
c_cond
(paren
(paren
id|device
op_eq
id|PCI_DEVICE_ID_QLOGIC_ISP2100
)paren
op_logical_or
(paren
id|device
op_eq
id|PCI_DEVICE_ID_QLOGIC_ISP2200
)paren
)paren
(brace
id|SET_PCIA64
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_SGI
)paren
(brace
r_if
c_cond
(paren
id|device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
id|SET_PCIA64
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * sn1_pci_fixup() - This routine is called when platform_pci_fixup() is &n; *&t;invoked at the end of pcibios_init() to link the Linux pci &n; *&t;infrastructure to SGI IO Infrasturcture - ia64/kernel/pci.c&n; *&n; *&t;Other platform specific fixup can also be done here.&n; */
r_void
DECL|function|sn1_pci_fixup
id|sn1_pci_fixup
c_func
(paren
r_int
id|arg
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|device_dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sn1_widget_sysdata
op_star
id|widget_sysdata
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_extern
r_void
id|sn1_pci_find_bios
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
(brace
id|sn1_pci_find_bios
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0
(brace
id|devfs_handle_t
id|bridge_vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|bridge_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Before Changing PIO Map Address:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Before devreg fixup&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 0 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|0
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 1 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|1
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 2 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|2
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 3 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|3
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 4 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|4
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 5 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|5
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 6 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|6
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 7 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|7
)braket
dot
id|reg
)paren
suffix:semicolon
)brace
macro_line|#endif
id|done_probing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sn1_pci_fixup not supported on simulator.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef REAL_HARDWARE
multiline_comment|/*&n;&t; * Initialize the pci bus vertex in the pci_bus struct.&n;&t; */
r_for
c_loop
(paren
id|ln
op_assign
id|pci_root_buses.next
suffix:semicolon
id|ln
op_ne
op_amp
id|pci_root_buses
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|pci_bus
op_assign
id|pci_bus_b
c_func
(paren
id|ln
)paren
suffix:semicolon
id|widget_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn1_widget_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|widget_sysdata-&gt;vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|pci_bus-&gt;number
)paren
suffix:semicolon
id|pci_bus-&gt;sysdata
op_assign
(paren
r_void
op_star
)paren
id|widget_sysdata
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * set the root start and end so that drivers calling check_region()&n;&t; * won&squot;t see a conflict&n;&t; */
id|ioport_resource.start
op_or_assign
id|IO_SWIZ_BASE
suffix:semicolon
id|ioport_resource.end
op_or_assign
(paren
id|HSPEC_SWIZ_BASE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the device vertex in the pci_dev struct.&n;&t; */
id|pci_for_each_dev
c_func
(paren
id|device_dev
)paren
(brace
r_int
r_int
id|irq
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|device_dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
op_logical_and
id|device_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
r_extern
r_void
id|pci_fixup_ioc3
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
suffix:semicolon
id|pci_fixup_ioc3
c_func
(paren
id|device_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the device vertex */
id|device_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn1_device_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|device_sysdata-&gt;vhdl
op_assign
id|devfn_to_vertex
c_func
(paren
id|device_dev-&gt;bus-&gt;number
comma
id|device_dev-&gt;devfn
)paren
suffix:semicolon
id|device_sysdata-&gt;isa64
op_assign
l_int|0
suffix:semicolon
id|device_dev-&gt;sysdata
op_assign
(paren
r_void
op_star
)paren
id|device_sysdata
suffix:semicolon
id|set_sn1_pci64
c_func
(paren
id|device_dev
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|device_dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the resources address correctly.  The assumption here &n;&t;&t; * is that the addresses in the resource structure has been&n;&t;&t; * read from the card and it was set in the card by our&n;&t;&t; * Infrastructure ..&n;&t;&t; */
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|size
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_minus
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|res
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|pciio_config_get
c_func
(paren
id|vhdl
comma
(paren
r_int
)paren
id|PCI_BASE_ADDRESS_0
op_plus
id|idx
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Before pciio_pio_addr Base address %d = 0x%lx&bslash;n&quot;
comma
id|idx
comma
id|res
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Changing device %d:%d resource start address from 0x%lx&quot;
comma
id|PCI_SLOT
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
)paren
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|idx
)paren
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_plus
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the addresses to go to the SWIZZLE ..&n;&t;&t;&t; */
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_amp
l_int|0xfffff7ffffffffff
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_amp
l_int|0xfffff7ffffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; to 0x%lx&bslash;n&quot;
comma
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|pciio_config_get
c_func
(paren
id|vhdl
comma
(paren
r_int
)paren
id|PCI_BASE_ADDRESS_0
op_plus
id|idx
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;After pciio_pio_addr Base address %d = 0x%lx&bslash;n&quot;
comma
id|idx
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now handle the ROM resource ..&n;&t;&t; */
id|size
op_assign
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_minus
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Changing device %d:%d ROM resource start address from 0x%lx&quot;
comma
id|PCI_SLOT
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
)paren
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_ROM
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_plus
id|size
suffix:semicolon
multiline_comment|/*&n;                 * go through synergy swizzled space&n;                 */
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_and_assign
l_int|0xfffff7ffffffffffUL
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_and_assign
l_int|0xfffff7ffffffffffUL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the Command Word on the Card.&n;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
multiline_comment|/* If the device doesn&squot;t support */
multiline_comment|/* bit gets dropped .. no harm */
id|pci_write_config_word
c_func
(paren
id|device_dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  to 0x%lx&bslash;n&quot;
comma
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the irq correctly.&n;&t;&t; * Bits 7:3 = slot&n;&t;&t; * Bits 2:0 = function&n;&t;&t; *&n;&t;&t; * In the IRQ we will have:&n;&t;&t; *&t;Bits 24:16 = bus number&n;&t;&t; *&t;Bits 15:8 = slot|func number&n;&t;&t; */
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
op_assign
(paren
id|irq
op_or
(paren
id|device_dev-&gt;devfn
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|irq
op_assign
(paren
id|irq
op_or
(paren
(paren
id|device_dev-&gt;bus-&gt;number
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|device_dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn1_pci_fixup: slot= %d  fn= %d  vendor= 0x%x  device= 0x%x  irq= 0x%x&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|device_dev-&gt;devfn
)paren
comma
id|device_dev-&gt;vendor
comma
id|device_dev-&gt;device
comma
id|device_dev-&gt;irq
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* REAL_HARDWARE */
macro_line|#if 0
(brace
id|devfs_handle_t
id|bridge_vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|bridge_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;After Changing PIO Map Address:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Before devreg fixup&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 0 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|0
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 1 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|1
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 2 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|2
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 3 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|3
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 4 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|4
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 5 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|5
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 6 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|6
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 7 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|7
)braket
dot
id|reg
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * pci_bus_map_create() - Called by pci_bus_to_hcl_cvlink() to finish the job.&n; */
r_static
r_int
DECL|function|pci_bus_map_create
id|pci_bus_map_create
c_func
(paren
id|devfs_handle_t
id|xtalk
)paren
(brace
id|devfs_handle_t
id|master_node_vertex
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|xwidget
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
id|hubinfo_t
id|hubinfo
op_assign
l_int|NULL
suffix:semicolon
id|xwidgetnum_t
id|widgetnum
suffix:semicolon
r_char
id|pathname
(braket
l_int|128
)braket
suffix:semicolon
id|graph_error_t
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * Loop throught this vertex and get the Xwidgets ..&n;&t; */
r_for
c_loop
(paren
id|widgetnum
op_assign
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|widgetnum
op_le
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widgetnum
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d&quot;
comma
id|widgetnum
)paren
suffix:semicolon
id|xwidget
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_traverse
c_func
(paren
id|xtalk
comma
id|pathname
comma
op_amp
id|xwidget
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xwidget
)paren
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d/&quot;
id|EDGE_LBL_PCI
comma
id|widgetnum
)paren
suffix:semicolon
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xtalk
comma
id|pathname
comma
op_amp
id|pci_bus
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Assign the correct bus number and also the nasid of this &n;&t;&t; * pci Xwidget.&n;&t;&t; * &n;&t;&t; * Should not be any race here ...&n;&t;&t; */
id|num_bridges
op_increment
suffix:semicolon
id|busnum_to_xwidget
(braket
id|num_bridges
op_minus
l_int|1
)braket
op_assign
id|xwidget
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the master node and from there get the NASID.&n;&t;&t; */
id|master_node_vertex
op_assign
id|device_master_get
c_func
(paren
id|xwidget
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|master_node_vertex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; **** pci_bus_map_create: Unable to get .master for vertex 0x%p **** &bslash;n&quot;
comma
id|xwidget
)paren
suffix:semicolon
)brace
id|hubinfo_get
c_func
(paren
id|master_node_vertex
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hubinfo
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; **** pci_bus_map_create: Unable to get hubinfo for master node vertex 0x%p ****&bslash;n&quot;
comma
id|master_node_vertex
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|busnum_to_nid
(braket
id|num_bridges
op_minus
l_int|1
)braket
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_map_create: Found Hub nasid %d PCI Xwidget 0x%p  widgetnum= %d&bslash;n&quot;
comma
id|hubinfo-&gt;h_nasid
comma
id|xwidget
comma
id|widgetnum
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_hcl_cvlink() - This routine is called after SGI IO Infrastructure   &n; *      initialization has completed to set up the mappings between Xbridge&n; *      and logical pci bus numbers.  We also set up the NASID for each of these&n; *      xbridges.&n; *&n; *      Must be called before pci_init() is invoked.&n; */
r_int
DECL|function|pci_bus_to_hcl_cvlink
id|pci_bus_to_hcl_cvlink
c_func
(paren
r_void
)paren
(brace
id|devfs_handle_t
id|devfs_hdl
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|module_comp
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|node
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|xtalk
op_assign
l_int|NULL
suffix:semicolon
id|graph_vertex_place_t
id|placeptr
op_assign
id|EDGE_PLACE_WANT_REAL_EDGES
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_char
id|name
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate throught each xtalk links in the system ..&n;&t; * /hw/module/001c01/node/xtalk/ 8|9|10|11|12|13|14|15 &n;&t; *&n;&t; * /hw/module/001c01/node/xtalk/15 -&gt; /hw/module/001c01/Ibrick/xtalk/15&n;&t; *&n;&t; * What if it is not pci?&n;&t; */
id|devfs_hdl
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
l_string|&quot;/dev/hw/module&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop throught this directory &quot;/devfs/hw/module/&quot; and get each &n;&t; * of it&squot;s entry.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Get vertex of component /dev/hw/&lt;module_number&gt; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|name
comma
l_char|&squot;0&squot;
comma
l_int|256
)paren
suffix:semicolon
id|module_comp
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_edge_get_next
c_func
(paren
id|devfs_hdl
comma
(paren
r_char
op_star
)paren
id|name
comma
op_amp
id|module_comp
comma
(paren
id|uint
op_star
)paren
op_amp
id|placeptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_eq
l_int|0
)paren
op_logical_and
(paren
id|module_comp
)paren
)paren
(brace
multiline_comment|/* Found a valid entry */
id|node
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|module_comp
comma
l_string|&quot;node&quot;
comma
op_amp
id|node
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_to_hcl_cvlink: No more Module Component.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rv
op_ne
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|node
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_to_hcl_cvlink: Module Component does not have node vertex.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|xtalk
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|node
comma
l_string|&quot;xtalk&quot;
comma
op_amp
id|xtalk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_ne
l_int|0
)paren
op_logical_or
(paren
id|xtalk
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_to_hcl_cvlink: Node has no xtalk vertex.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;pci_bus_to_hcl_cvlink: Found Module %s node vertex = 0x%p xtalk vertex = 0x%p&bslash;n&quot;
comma
id|name
comma
id|node
comma
id|xtalk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Call routine to get the existing PCI Xwidget and create&n;&t;&t; * the convenience link from &quot;/devfs/hw/pci_bus/..&quot;&n;&t;&t; */
id|pci_bus_map_create
c_func
(paren
id|xtalk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sgi_pci_intr_support -&n; */
r_int
DECL|function|sgi_pci_intr_support
id|sgi_pci_intr_support
(paren
r_int
r_int
id|requested_irq
comma
id|device_desc_t
op_star
id|dev_desc
comma
id|devfs_handle_t
op_star
id|bus_vertex
comma
id|pciio_intr_line_t
op_star
id|lines
comma
id|devfs_handle_t
op_star
id|device_vertex
)paren
(brace
r_int
r_int
id|bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
r_char
id|intr_pin
op_assign
l_int|0
suffix:semicolon
r_struct
id|sn1_widget_sysdata
op_star
id|widget_sysdata
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgi_pci_intr_support: Called with requested_irq 0x%x&bslash;n&quot;
comma
id|requested_irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_desc
op_logical_or
op_logical_neg
id|bus_vertex
op_logical_or
op_logical_neg
id|device_vertex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sgi_pci_intr_support: Invalid parameter dev_desc 0x%p, bus_vertex 0x%p, device_vertex 0x%p&bslash;n&quot;
comma
id|dev_desc
comma
id|bus_vertex
comma
id|device_vertex
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|devfn
op_assign
(paren
id|requested_irq
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|bus
op_assign
(paren
id|requested_irq
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|pci_dev
op_assign
id|pci_find_slot
c_func
(paren
id|bus
comma
id|devfn
)paren
suffix:semicolon
id|widget_sysdata
op_assign
(paren
r_struct
id|sn1_widget_sysdata
op_star
)paren
id|pci_dev-&gt;bus-&gt;sysdata
suffix:semicolon
op_star
id|bus_vertex
op_assign
id|widget_sysdata-&gt;vhdl
suffix:semicolon
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|pci_dev-&gt;sysdata
suffix:semicolon
op_star
id|device_vertex
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
macro_line|#if 0
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
op_star
id|device_vertex
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s pos %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
comma
id|pos
)paren
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP */
multiline_comment|/*&n;&t; * Get the Interrupt PIN.&n;&t; */
id|pci_read_config_byte
c_func
(paren
id|pci_dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|intr_pin
)paren
suffix:semicolon
op_star
id|lines
op_assign
(paren
id|pciio_intr_line_t
)paren
id|intr_pin
suffix:semicolon
macro_line|#ifdef BRINGUP
multiline_comment|/*&n;&t; * ioc3 can&squot;t decode the PCI_INTERRUPT_PIN field of its config&n;&t; * space so we have to set it here&n;&t; */
r_if
c_cond
(paren
id|pci_dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
op_logical_and
id|pci_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
op_star
id|lines
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : IOC3 HACK: lines= %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
id|lines
)paren
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP */
multiline_comment|/* Not supported currently */
op_star
id|dev_desc
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgi_pci_intr_support: Device Descriptor 0x%p, Bus Vertex 0x%p, Interrupt Pins 0x%x, Device Vertex 0x%p&bslash;n&quot;
comma
op_star
id|dev_desc
comma
op_star
id|bus_vertex
comma
op_star
id|lines
comma
op_star
id|device_vertex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
