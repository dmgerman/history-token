multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/hack.h&gt;
macro_line|#include &lt;asm/sn/sgi.h&gt;
macro_line|#include &lt;asm/sn/iobus.h&gt;
macro_line|#include &lt;asm/sn/iograph.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/sn/pio.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xwidget.h&gt;
macro_line|#include &lt;asm/sn/sn_private.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/invent.h&gt;
macro_line|#include &lt;asm/sn/hcl.h&gt;
macro_line|#include &lt;asm/sn/hcl_util.h&gt;
macro_line|#include &lt;asm/sn/agent.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/xtalk/xtalkaddrs.h&gt;
macro_line|#include &lt;asm/sn/klconfig.h&gt;
macro_line|#include &lt;asm/sn/io.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
singleline_comment|// #include &lt;sys/ql.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr.h&gt;
macro_line|#include &lt;asm/sn/pci/pcibr_private.h&gt;
r_extern
r_int
id|bridge_rev_b_data_check_disable
suffix:semicolon
macro_line|#include &lt;asm/sn/pci/pci_bus_cvlink.h&gt;
DECL|macro|MAX_PCI_XWIDGET
mdefine_line|#define MAX_PCI_XWIDGET 256
DECL|variable|busnum_to_pcibr_vhdl
id|devfs_handle_t
id|busnum_to_pcibr_vhdl
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|busnum_to_nid
id|nasid_t
id|busnum_to_nid
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|busnum_to_atedmamaps
r_void
op_star
id|busnum_to_atedmamaps
(braket
id|MAX_PCI_XWIDGET
)braket
suffix:semicolon
DECL|variable|num_bridges
r_int
r_char
id|num_bridges
suffix:semicolon
DECL|variable|done_probing
r_static
r_int
id|done_probing
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|pci_bus_map_create
c_func
(paren
id|devfs_handle_t
id|xtalk
)paren
suffix:semicolon
id|devfs_handle_t
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
suffix:semicolon
DECL|macro|SN1_IOPORTS_UNIT
mdefine_line|#define SN1_IOPORTS_UNIT 256
DECL|macro|MAX_IOPORTS
mdefine_line|#define MAX_IOPORTS 0xffff
DECL|macro|MAX_IOPORTS_CHUNKS
mdefine_line|#define MAX_IOPORTS_CHUNKS (MAX_IOPORTS / SN1_IOPORTS_UNIT)
DECL|variable|ioports_to_tlbs
r_struct
id|ioports_to_tlbs_s
id|ioports_to_tlbs
(braket
id|MAX_IOPORTS_CHUNKS
)braket
suffix:semicolon
r_int
r_int
id|sn1_allocate_ioports
c_func
(paren
r_int
r_int
id|pci_address
)paren
suffix:semicolon
multiline_comment|/*&n; * pci_bus_cvlink_init() - To be called once during initialization before &n; *&t;SGI IO Infrastructure init is called.&n; */
r_void
DECL|function|pci_bus_cvlink_init
id|pci_bus_cvlink_init
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|busnum_to_pcibr_vhdl
comma
l_int|0x0
comma
r_sizeof
(paren
id|devfs_handle_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_nid
comma
l_int|0x0
comma
r_sizeof
(paren
id|nasid_t
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_atedmamaps
comma
l_int|0x0
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|MAX_PCI_XWIDGET
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ioports_to_tlbs
comma
l_int|0x0
comma
r_sizeof
(paren
id|ioports_to_tlbs
)paren
)paren
suffix:semicolon
id|num_bridges
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_vertex() - Given a logical Linux Bus Number returns the associated &n; *&t;pci bus vertex from the SGI IO Infrastructure.&n; */
id|devfs_handle_t
DECL|function|pci_bus_to_vertex
id|pci_bus_to_vertex
c_func
(paren
r_int
r_char
id|busnum
)paren
(brace
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * First get the xwidget vertex.&n;&t; */
id|pci_bus
op_assign
id|busnum_to_pcibr_vhdl
(braket
id|busnum
)braket
suffix:semicolon
r_return
id|pci_bus
suffix:semicolon
)brace
multiline_comment|/*&n; * devfn_to_vertex() - returns the vertex of the device given the bus, slot, &n; *&t;and function numbers.&n; */
id|devfs_handle_t
DECL|function|devfn_to_vertex
id|devfn_to_vertex
c_func
(paren
r_int
r_char
id|busnum
comma
r_int
r_int
id|devfn
)paren
(brace
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
r_int
id|func
op_assign
l_int|0
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|device_vertex
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Go get the pci bus vertex.&n;&t; */
id|pci_bus
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
(brace
multiline_comment|/*&n;&t;&t; * During probing, the Linux pci code invents non-existent&n;&t;&t; * bus numbers and pci_dev structures and tries to access&n;&t;&t; * them to determine existence. Don&squot;t crib during probing.&n;&t;&t; */
r_if
c_cond
(paren
id|done_probing
)paren
id|printk
c_func
(paren
l_string|&quot;devfn_to_vertex: Invalid bus number %d given.&bslash;n&quot;
comma
id|busnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go get the slot&amp;function vertex.&n;&t; * Should call pciio_slot_func_to_name() when ready.&n;&t; */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
suffix:semicolon
id|func
op_assign
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|slot
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d%c&quot;
comma
id|slot
comma
l_char|&squot;a&squot;
op_plus
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|pci_bus
comma
id|name
comma
op_amp
id|device_vertex
)paren
op_ne
id|GRAPH_SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device_vertex
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|device_vertex
suffix:semicolon
)brace
multiline_comment|/*&n; * Most drivers currently do not properly tell the arch specific pci dma&n; * interfaces whether they can handle A64. Here is where we privately&n; * keep track of this.&n; */
r_static
r_void
id|__init
DECL|function|set_sn1_pci64
id|set_sn1_pci64
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|vendor
op_assign
id|dev-&gt;vendor
suffix:semicolon
r_int
r_int
id|device
op_assign
id|dev-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_QLOGIC
)paren
(brace
r_if
c_cond
(paren
(paren
id|device
op_eq
id|PCI_DEVICE_ID_QLOGIC_ISP2100
)paren
op_logical_or
(paren
id|device
op_eq
id|PCI_DEVICE_ID_QLOGIC_ISP2200
)paren
)paren
(brace
id|SET_PCIA64
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_SGI
)paren
(brace
r_if
c_cond
(paren
id|device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
id|SET_PCIA64
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * sn1_allocate_ioports() - This routine provides the allocation and &n; *&t;mappings between Linux style IOPORTs management.&n; *&n; *&t;For simplicity sake, SN1 will allocate IOPORTs in chunks of &n; *&t;256bytes .. irrespective of what the card desires.  This may &n; *&t;have to change when we understand how to deal with legacy ioports &n; *&t;which are hardcoded in some drivers e.g. SVGA.&n; *&n; *&t;Ofcourse, the SN1 IO Infrastructure has no concept of IOPORT numbers.&n; *&t;It will remain so.  The IO Infrastructure will continue to map &n; *&t;IO Resource just like IRIX.  When this is done, we map IOPORT &n; *&t;chunks to these resources.  The Linux drivers will see and use real &n; *&t;IOPORT numbers.  The various IOPORT access macros e.g. inb/outb etc. &n; *&t;does the munging of these IOPORT numbers to make a Uncache Virtual &n; *&t;Address.  This address via the tlb entries generates the PCI Address &n; *&t;allocated by the SN1 IO Infrastructure Layer.&n; */
DECL|variable|sn1_ioport_num
r_static
r_int
r_int
id|sn1_ioport_num
op_assign
l_int|0x100
suffix:semicolon
multiline_comment|/* Reserve room for Legacy stuff */
r_int
r_int
DECL|function|sn1_allocate_ioports
id|sn1_allocate_ioports
c_func
(paren
r_int
r_int
id|pci_address
)paren
(brace
r_int
r_int
id|ioport_index
suffix:semicolon
multiline_comment|/*&n;&t; * Just some idiot checking ..&n;&t; */
r_if
c_cond
(paren
id|sn1_ioport_num
OG
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sn1_allocate_ioports: No more IO PORTS available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See Section 4.1.1.5 of Intel IA-64 Acrchitecture Software Developer&squot;s&n;&t; * Manual for details.&n;&t; */
id|ioport_index
op_assign
id|sn1_ioport_num
op_div
id|SN1_IOPORTS_UNIT
suffix:semicolon
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ppn
op_assign
id|pci_address
suffix:semicolon
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|p
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Present Bit */
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ma
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* Memory Attributes */
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|a
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set Data Access Bit Fault */
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|d
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Dirty Bit */
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|pl
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Privilege Level - All levels can R/W*/
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ar
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Access Rights - R/W only*/
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Exception Deferral Bit */
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ig
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ignored */
id|printk
c_func
(paren
l_string|&quot;sn1_allocate_ioports: ioport_index 0x%x ioports_to_tlbs 0x%p&bslash;n&quot;
comma
id|ioport_index
comma
id|ioports_to_tlbs
(braket
id|ioport_index
)braket
dot
id|ppn
)paren
suffix:semicolon
id|sn1_ioport_num
op_add_assign
id|SN1_IOPORTS_UNIT
suffix:semicolon
r_return
id|sn1_ioport_num
op_minus
id|SN1_IOPORTS_UNIT
suffix:semicolon
)brace
multiline_comment|/*&n; * sn1_pci_fixup() - This routine is called when platform_pci_fixup() is &n; *&t;invoked at the end of pcibios_init() to link the Linux pci &n; *&t;infrastructure to SGI IO Infrasturcture - ia64/kernel/pci.c&n; *&n; *&t;Other platform specific fixup can also be done here.&n; */
r_void
DECL|function|sn1_pci_fixup
id|sn1_pci_fixup
c_func
(paren
r_int
id|arg
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|device_dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sn1_widget_sysdata
op_star
id|widget_sysdata
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_int
r_int
id|ioport
suffix:semicolon
id|pciio_intr_t
id|intr_handle
suffix:semicolon
r_int
id|cpuid
comma
id|bit
suffix:semicolon
id|devfs_handle_t
op_star
id|device_vertex
suffix:semicolon
id|pciio_intr_line_t
id|lines
suffix:semicolon
r_extern
r_void
id|sn1_pci_find_bios
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
(brace
id|sn1_pci_find_bios
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0
(brace
id|devfs_handle_t
id|bridge_vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|bridge_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Before devreg fixup&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 0 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|0
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 1 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|1
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 2 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|2
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 3 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|3
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 4 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|4
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 5 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|5
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 6 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|6
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 7 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|7
)braket
dot
id|reg
)paren
suffix:semicolon
)brace
macro_line|#endif
id|done_probing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sn1_pci_fixup not supported on simulator.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef REAL_HARDWARE
multiline_comment|/*&n;&t; * Initialize the pci bus vertex in the pci_bus struct.&n;&t; */
r_for
c_loop
(paren
id|ln
op_assign
id|pci_root_buses.next
suffix:semicolon
id|ln
op_ne
op_amp
id|pci_root_buses
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|pci_bus
op_assign
id|pci_bus_b
c_func
(paren
id|ln
)paren
suffix:semicolon
id|widget_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn1_widget_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|widget_sysdata-&gt;vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
id|pci_bus-&gt;number
)paren
suffix:semicolon
id|pci_bus-&gt;sysdata
op_assign
(paren
r_void
op_star
)paren
id|widget_sysdata
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * set the root start and end so that drivers calling check_region()&n;&t; * won&squot;t see a conflict&n;&t; */
id|ioport_resource.start
op_or_assign
id|IO_SWIZ_BASE
suffix:semicolon
id|ioport_resource.end
op_or_assign
(paren
id|HSPEC_SWIZ_BASE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the device vertex in the pci_dev struct.&n;&t; */
id|pci_for_each_dev
c_func
(paren
id|device_dev
)paren
(brace
r_int
r_int
id|irq
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
id|devfs_handle_t
id|vhdl
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|device_dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
op_logical_and
id|device_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
r_extern
r_void
id|pci_fixup_ioc3
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
suffix:semicolon
id|pci_fixup_ioc3
c_func
(paren
id|device_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the device vertex */
id|device_sysdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn1_device_sysdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|device_sysdata-&gt;vhdl
op_assign
id|devfn_to_vertex
c_func
(paren
id|device_dev-&gt;bus-&gt;number
comma
id|device_dev-&gt;devfn
)paren
suffix:semicolon
id|device_sysdata-&gt;isa64
op_assign
l_int|0
suffix:semicolon
id|device_dev-&gt;sysdata
op_assign
(paren
r_void
op_star
)paren
id|device_sysdata
suffix:semicolon
id|set_sn1_pci64
c_func
(paren
id|device_dev
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|device_dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the resources address correctly.  The assumption here &n;&t;&t; * is that the addresses in the resource structure has been&n;&t;&t; * read from the card and it was set in the card by our&n;&t;&t; * Infrastructure ..&n;&t;&t; */
id|vhdl
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|size
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_minus
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|res
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|pciio_config_get
c_func
(paren
id|vhdl
comma
(paren
r_int
)paren
id|PCI_BASE_ADDRESS_0
op_plus
id|idx
comma
l_int|4
)paren
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_WIN
c_func
(paren
id|idx
)paren
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;sn1_pci_fixup: Mapped Address = 0x%p size = 0x%x&bslash;n&quot;, device_dev-&gt;resource[idx].start, size); */
)brace
r_else
r_continue
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_plus
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the addresses to go to the SWIZZLE ..&n;&t;&t;&t; */
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_amp
l_int|0xfffff7ffffffffff
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_amp
l_int|0xfffff7ffffffffff
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|pciio_config_get
c_func
(paren
id|vhdl
comma
(paren
r_int
)paren
id|PCI_BASE_ADDRESS_0
op_plus
id|idx
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
(brace
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|ioport
op_assign
id|sn1_allocate_ioports
c_func
(paren
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
)paren
suffix:semicolon
multiline_comment|/* device_dev-&gt;resource[idx].start = ioport; */
multiline_comment|/* device_dev-&gt;resource[idx].end = ioport + SN1_IOPORTS_UNIT */
)brace
r_else
r_if
c_cond
(paren
id|device_dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now handle the ROM resource ..&n;&t;&t; */
id|size
op_assign
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_minus
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_assign
(paren
r_int
r_int
)paren
id|pciio_pio_addr
c_func
(paren
id|vhdl
comma
l_int|0
comma
id|PCIIO_SPACE_ROM
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|PCIIO_BYTE_STREAM
)paren
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_assign
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_plus
id|size
suffix:semicolon
multiline_comment|/*&n;                 * go through synergy swizzled space&n;                 */
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|start
op_and_assign
l_int|0xfffff7ffffffffffUL
suffix:semicolon
id|device_dev-&gt;resource
(braket
id|PCI_ROM_RESOURCE
)braket
dot
id|end
op_and_assign
l_int|0xfffff7ffffffffffUL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the Command Word on the Card.&n;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
multiline_comment|/* If the device doesn&squot;t support */
multiline_comment|/* bit gets dropped .. no harm */
id|pci_write_config_word
c_func
(paren
id|device_dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|device_dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|lines
)paren
suffix:semicolon
macro_line|#ifdef BRINGUP
r_if
c_cond
(paren
id|device_dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
op_logical_and
id|device_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
id|lines
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|device_dev-&gt;sysdata
suffix:semicolon
id|device_vertex
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
id|intr_handle
op_assign
id|pciio_intr_alloc
c_func
(paren
id|device_vertex
comma
l_int|NULL
comma
id|lines
comma
id|device_vertex
)paren
suffix:semicolon
id|bit
op_assign
id|intr_handle-&gt;pi_irq
suffix:semicolon
id|cpuid
op_assign
id|intr_handle-&gt;pi_cpu
suffix:semicolon
id|irq
op_assign
id|bit_pos_to_irq
c_func
(paren
id|bit
)paren
suffix:semicolon
id|irq
op_assign
id|irq
op_plus
(paren
id|cpuid
op_lshift
l_int|8
)paren
suffix:semicolon
id|pciio_intr_connect
c_func
(paren
id|intr_handle
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|device_dev-&gt;irq
op_assign
id|irq
suffix:semicolon
)brace
macro_line|#endif&t;/* REAL_HARDWARE */
macro_line|#if 0
(brace
id|devfs_handle_t
id|bridge_vhdl
op_assign
id|pci_bus_to_vertex
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pcibr_soft_t
id|pcibr_soft
op_assign
(paren
id|pcibr_soft_t
)paren
id|hwgraph_fastinfo_get
c_func
(paren
id|bridge_vhdl
)paren
suffix:semicolon
id|bridge_t
op_star
id|bridge
op_assign
id|pcibr_soft-&gt;bs_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Before devreg fixup&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 0 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|0
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 1 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|1
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 2 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|2
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 3 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|3
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 4 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|4
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 5 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|5
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 6 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|6
)braket
dot
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_fixup_ioc3: Devreg 7 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_device
(braket
l_int|7
)braket
dot
id|reg
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * pci_bus_map_create() - Called by pci_bus_to_hcl_cvlink() to finish the job.&n; *&n; *&t;Linux PCI Bus numbers are assigned from lowest module_id numbers&n; *&t;(rack/slot etc.) starting from HUB_WIDGET_ID_MAX down to &n; *&t;HUB_WIDGET_ID_MIN:&n; *&t;&t;widgetnum 15 gets lower Bus Number than widgetnum 14 etc.&n; *&n; *&t;Given 2 modules 001c01 and 001c02 we get the following mappings:&n; *&t;&t;001c01, widgetnum 15 = Bus number 0&n; *&t;&t;001c01, widgetnum 14 = Bus number 1&n; *&t;&t;001c02, widgetnum 15 = Bus number 3&n; *&t;&t;001c02, widgetnum 14 = Bus number 4&n; *&t;&t;etc.&n; *&n; * The rational for starting Bus Number 0 with Widget number 15 is because &n; * the system boot disks are always connected via Widget 15 Slot 0 of the &n; * I-brick.  Linux creates /dev/sd* devices(naming) strating from Bus Number 0 &n; * Therefore, /dev/sda1 will be the first disk, on Widget 15 of the lowest &n; * module id(Master Cnode) of the system.&n; *&t;&n; */
r_static
r_int
DECL|function|pci_bus_map_create
id|pci_bus_map_create
c_func
(paren
id|devfs_handle_t
id|xtalk
)paren
(brace
id|devfs_handle_t
id|master_node_vertex
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|xwidget
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
id|hubinfo_t
id|hubinfo
op_assign
l_int|NULL
suffix:semicolon
id|xwidgetnum_t
id|widgetnum
suffix:semicolon
r_char
id|pathname
(braket
l_int|128
)braket
suffix:semicolon
id|graph_error_t
id|rv
suffix:semicolon
multiline_comment|/*&n;&t; * Loop throught this vertex and get the Xwidgets ..&n;&t; */
r_for
c_loop
(paren
id|widgetnum
op_assign
id|HUB_WIDGET_ID_MAX
suffix:semicolon
id|widgetnum
op_ge
id|HUB_WIDGET_ID_MIN
suffix:semicolon
id|widgetnum
op_decrement
)paren
(brace
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|xtalk
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d&quot;
comma
id|widgetnum
)paren
suffix:semicolon
id|xwidget
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Example - /hw/module/001c16/Pbrick/xtalk/8 is the xwidget&n;&t;&t; *&t;     /hw/module/001c16/Pbrick/xtalk/8/pci/1 is device&n;&t;&t; */
id|rv
op_assign
id|hwgraph_traverse
c_func
(paren
id|xtalk
comma
id|pathname
comma
op_amp
id|xwidget
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_ne
id|GRAPH_SUCCESS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xwidget
)paren
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pathname
comma
l_string|&quot;%d/&quot;
id|EDGE_LBL_PCI
comma
id|widgetnum
)paren
suffix:semicolon
id|pci_bus
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hwgraph_traverse
c_func
(paren
id|xtalk
comma
id|pathname
comma
op_amp
id|pci_bus
)paren
op_ne
id|GRAPH_SUCCESS
)paren
r_if
c_cond
(paren
op_logical_neg
id|pci_bus
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Assign the correct bus number and also the nasid of this &n;&t;&t; * pci Xwidget.&n;&t;&t; * &n;&t;&t; * Should not be any race here ...&n;&t;&t; */
id|num_bridges
op_increment
suffix:semicolon
id|busnum_to_pcibr_vhdl
(braket
id|num_bridges
op_minus
l_int|1
)braket
op_assign
id|pci_bus
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the master node and from there get the NASID.&n;&t;&t; */
id|master_node_vertex
op_assign
id|device_master_get
c_func
(paren
id|xwidget
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|master_node_vertex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: pci_bus_map_create: Unable to get .master for vertex 0x%p&bslash;n&quot;
comma
id|xwidget
)paren
suffix:semicolon
)brace
id|hubinfo_get
c_func
(paren
id|master_node_vertex
comma
op_amp
id|hubinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hubinfo
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: pci_bus_map_create: Unable to get hubinfo for master node vertex 0x%p&bslash;n&quot;
comma
id|master_node_vertex
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|busnum_to_nid
(braket
id|num_bridges
op_minus
l_int|1
)braket
op_assign
id|hubinfo-&gt;h_nasid
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Pre assign DMA maps needed for 32 Bits Page Map DMA.&n;&t;&t; */
id|busnum_to_atedmamaps
(braket
id|num_bridges
op_minus
l_int|1
)braket
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sn1_dma_maps_s
)paren
op_star
l_int|512
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|busnum_to_atedmamaps
(braket
id|num_bridges
op_minus
l_int|1
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;WARNING: pci_bus_map_create: Unable to precreate ATE DMA Maps for busnum %d vertex 0x%p&bslash;n&quot;
comma
id|num_bridges
op_minus
l_int|1
comma
id|xwidget
)paren
suffix:semicolon
id|memset
c_func
(paren
id|busnum_to_atedmamaps
(braket
id|num_bridges
op_minus
l_int|1
)braket
comma
l_int|0x0
comma
r_sizeof
(paren
r_struct
id|sn1_dma_maps_s
)paren
op_star
l_int|512
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_bus_to_hcl_cvlink() - This routine is called after SGI IO Infrastructure   &n; *      initialization has completed to set up the mappings between Xbridge&n; *      and logical pci bus numbers.  We also set up the NASID for each of these&n; *      xbridges.&n; *&n; *      Must be called before pci_init() is invoked.&n; */
r_int
DECL|function|pci_bus_to_hcl_cvlink
id|pci_bus_to_hcl_cvlink
c_func
(paren
r_void
)paren
(brace
id|devfs_handle_t
id|devfs_hdl
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|module_comp
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|node
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle_t
id|xtalk
op_assign
l_int|NULL
suffix:semicolon
id|graph_vertex_place_t
id|placeptr
op_assign
id|EDGE_PLACE_WANT_REAL_EDGES
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_char
id|name
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|master_iobrick
suffix:semicolon
id|moduleid_t
id|iobrick_id
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate throught each xtalk links in the system ..&n;&t; * /hw/module/001c01/node/xtalk/ 8|9|10|11|12|13|14|15 &n;&t; *&n;&t; * /hw/module/001c01/node/xtalk/15 -&gt; /hw/module/001c01/Ibrick/xtalk/15&n;&t; *&n;&t; * What if it is not pci?&n;&t; */
id|devfs_hdl
op_assign
id|hwgraph_path_to_vertex
c_func
(paren
l_string|&quot;/dev/hw/module&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To provide consistent(not persistent) device naming, we need to start &n;&t; * bus number allocation from the C-Brick with the lowest module id e.g. 001c01 &n;&t; * with an attached I-Brick.  Find the master_iobrick.&n;&t; */
id|master_iobrick
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nummodules
suffix:semicolon
id|i
op_increment
)paren
(brace
id|moduleid_t
id|iobrick_id
suffix:semicolon
id|iobrick_id
op_assign
id|iobrick_module_get
c_func
(paren
op_amp
id|modules
(braket
id|i
)braket
op_member_access_from_pointer
id|elsc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iobrick_id
OG
l_int|0
)paren
(brace
multiline_comment|/* Valid module id */
r_if
c_cond
(paren
id|MODULE_GET_BTYPE
c_func
(paren
id|iobrick_id
)paren
op_eq
id|MODULE_IBRICK
)paren
(brace
id|master_iobrick
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * The master_iobrick gets bus 0 and 1.&n;&t; */
r_if
c_cond
(paren
id|master_iobrick
op_ge
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|name
comma
id|modules
(braket
id|master_iobrick
)braket
op_member_access_from_pointer
id|id
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
l_string|&quot;/node/xtalk&quot;
)paren
suffix:semicolon
id|xtalk
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|devfs_hdl
comma
id|name
comma
op_amp
id|xtalk
)paren
suffix:semicolon
id|pci_bus_map_create
c_func
(paren
id|xtalk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now go do the rest of the modules, starting from the C-Brick with the lowest &n;&t; * module id, remembering to skip the master_iobrick, which was done above.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nummodules
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|master_iobrick
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* Did the master_iobrick already. */
)brace
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|format_module_id
c_func
(paren
id|name
comma
id|modules
(braket
id|i
)braket
op_member_access_from_pointer
id|id
comma
id|MODULE_FORMAT_BRIEF
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|name
comma
l_string|&quot;/node/xtalk&quot;
)paren
suffix:semicolon
id|xtalk
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|hwgraph_edge_get
c_func
(paren
id|devfs_hdl
comma
id|name
comma
op_amp
id|xtalk
)paren
suffix:semicolon
id|pci_bus_map_create
c_func
(paren
id|xtalk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sgi_pci_intr_support -&n; */
r_int
DECL|function|sgi_pci_intr_support
id|sgi_pci_intr_support
(paren
r_int
r_int
id|requested_irq
comma
id|device_desc_t
op_star
id|dev_desc
comma
id|devfs_handle_t
op_star
id|bus_vertex
comma
id|pciio_intr_line_t
op_star
id|lines
comma
id|devfs_handle_t
op_star
id|device_vertex
)paren
(brace
r_int
r_int
id|bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
r_char
id|intr_pin
op_assign
l_int|0
suffix:semicolon
r_struct
id|sn1_widget_sysdata
op_star
id|widget_sysdata
suffix:semicolon
r_struct
id|sn1_device_sysdata
op_star
id|device_sysdata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_desc
op_logical_or
op_logical_neg
id|bus_vertex
op_logical_or
op_logical_neg
id|device_vertex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: sgi_pci_intr_support: Invalid parameter dev_desc 0x%p, bus_vertex 0x%p, device_vertex 0x%p&bslash;n&quot;
comma
id|dev_desc
comma
id|bus_vertex
comma
id|device_vertex
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|devfn
op_assign
(paren
id|requested_irq
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|bus
op_assign
(paren
id|requested_irq
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|pci_dev
op_assign
id|pci_find_slot
c_func
(paren
id|bus
comma
id|devfn
)paren
suffix:semicolon
id|widget_sysdata
op_assign
(paren
r_struct
id|sn1_widget_sysdata
op_star
)paren
id|pci_dev-&gt;bus-&gt;sysdata
suffix:semicolon
op_star
id|bus_vertex
op_assign
id|widget_sysdata-&gt;vhdl
suffix:semicolon
id|device_sysdata
op_assign
(paren
r_struct
id|sn1_device_sysdata
op_star
)paren
id|pci_dev-&gt;sysdata
suffix:semicolon
op_star
id|device_vertex
op_assign
id|device_sysdata-&gt;vhdl
suffix:semicolon
macro_line|#if 0
(brace
r_int
id|pos
suffix:semicolon
r_char
id|dname
(braket
l_int|256
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
op_star
id|device_vertex
comma
id|dname
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : path= %s pos %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_amp
id|dname
(braket
id|pos
)braket
comma
id|pos
)paren
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP */
multiline_comment|/*&n;&t; * Get the Interrupt PIN.&n;&t; */
id|pci_read_config_byte
c_func
(paren
id|pci_dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|intr_pin
)paren
suffix:semicolon
op_star
id|lines
op_assign
(paren
id|pciio_intr_line_t
)paren
id|intr_pin
suffix:semicolon
macro_line|#ifdef BRINGUP
multiline_comment|/*&n;&t; * ioc3 can&squot;t decode the PCI_INTERRUPT_PIN field of its config&n;&t; * space so we have to set it here&n;&t; */
r_if
c_cond
(paren
id|pci_dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
op_logical_and
id|pci_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_IOC3
)paren
(brace
op_star
id|lines
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* BRINGUP */
multiline_comment|/* Not supported currently */
op_star
id|dev_desc
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
