multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000,2002-2005 Silicon Graphics, Inc. All rights reserved.&n; *&n; * Routines for PCI DMA mapping.  See Documentation/DMA-API.txt for&n; * a description of how these routines should be used.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &quot;pci/pcibus_provider_defs.h&quot;
macro_line|#include &quot;pci/pcidev.h&quot;
macro_line|#include &quot;pci/pcibr_provider.h&quot;
DECL|macro|SG_ENT_VIRT_ADDRESS
mdefine_line|#define SG_ENT_VIRT_ADDRESS(sg)&t;(page_address((sg)-&gt;page) + (sg)-&gt;offset)
DECL|macro|SG_ENT_PHYS_ADDRESS
mdefine_line|#define SG_ENT_PHYS_ADDRESS(SG)&t;virt_to_phys(SG_ENT_VIRT_ADDRESS(SG))
multiline_comment|/**&n; * sn_dma_supported - test a DMA mask&n; * @dev: device to test&n; * @mask: DMA mask to test&n; *&n; * Return whether the given PCI device DMA address mask can be supported&n; * properly.  For example, if your device can only drive the low 24-bits&n; * during PCI bus mastering, then you would pass 0x00ffffff as the mask to&n; * this function.  Of course, SN only supports devices that have 32 or more&n; * address bits when using the PMU.&n; */
DECL|function|sn_dma_supported
r_int
id|sn_dma_supported
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|mask
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
OL
l_int|0x7fffffff
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sn_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_supported
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_set_mask - set the DMA mask&n; * @dev: device to set&n; * @dma_mask: new mask&n; *&n; * Set @dev&squot;s DMA mask if the hw supports it.&n; */
DECL|function|sn_dma_set_mask
r_int
id|sn_dma_set_mask
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|dma_mask
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_dma_supported
c_func
(paren
id|dev
comma
id|dma_mask
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|dev-&gt;dma_mask
op_assign
id|dma_mask
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sn_dma_set_mask
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_set_mask
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_alloc_coherent - allocate memory for coherent DMA&n; * @dev: device to allocate for&n; * @size: size of the region&n; * @dma_handle: DMA (bus) address&n; * @flags: memory allocation flags&n; *&n; * dma_alloc_coherent() returns a pointer to a memory region suitable for&n; * coherent DMA traffic to/from a PCI device.  On SN platforms, this means&n; * that @dma_handle will have the %PCIIO_DMA_CMD flag set.&n; *&n; * This interface is usually used for &quot;command&quot; streams (e.g. the command&n; * queue for a SCSI controller).  See Documentation/DMA-API.txt for&n; * more information.&n; */
DECL|function|sn_dma_alloc_coherent
r_void
op_star
id|sn_dma_alloc_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
comma
r_int
id|flags
)paren
(brace
r_void
op_star
id|cpuaddr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the memory.&n;&t; * FIXME: We should be doing alloc_pages_node for the node closest&n;&t; *        to the PCI device.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpuaddr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|cpuaddr
comma
l_int|0x0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* physical addr. of the memory we just got */
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|cpuaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 64 bit address translations should never fail.&n;&t; * 32 bit translations can fail if there are insufficient mapping&n;&t; * resources.&n;&t; */
op_star
id|dma_handle
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
id|SN_PCIDMA_CONSISTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dma_handle
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: out of ATEs&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|cpuaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|cpuaddr
suffix:semicolon
)brace
DECL|variable|sn_dma_alloc_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_alloc_coherent
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_pci_free_coherent - free memory associated with coherent DMAable region&n; * @dev: device to free for&n; * @size: size to free&n; * @cpu_addr: kernel virtual address to free&n; * @dma_handle: DMA address associated with this region&n; *&n; * Frees the memory allocated by dma_alloc_coherent(), potentially unmapping&n; * any associated IOMMU mappings.&n; */
DECL|function|sn_dma_free_coherent
r_void
id|sn_dma_free_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|dma_handle
comma
l_int|0
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|cpu_addr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_free_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_free_coherent
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_map_single - map a single page for DMA&n; * @dev: device to map for&n; * @cpu_addr: kernel virtual address of the region to map&n; * @size: size of the region&n; * @direction: DMA direction&n; *&n; * Map the region pointed to by @cpu_addr for DMA and return the&n; * DMA address.&n; *&n; * We map this to the one step pcibr_dmamap_trans interface rather than&n; * the two step pcibr_dmamap_alloc/pcibr_dmamap_addr because we have&n; * no way of saving the dmamap handle from the alloc to later free&n; * (which is pretty much unacceptable).&n; *&n; * TODO: simplify our interface;&n; *       figure out how to save dmamap handle so can use two step.&n; */
DECL|function|sn_dma_map_single
id|dma_addr_t
id|sn_dma_map_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|cpu_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|dma_addr_t
id|dma_addr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|cpu_addr
)paren
suffix:semicolon
id|dma_addr
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: out of ATEs&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|dma_addr
suffix:semicolon
)brace
DECL|variable|sn_dma_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_map_single
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_unmap_single - unamp a DMA mapped page&n; * @dev: device to sync&n; * @dma_addr: DMA address to sync&n; * @size: size of region&n; * @direction: DMA direction&n; *&n; * This routine is supposed to sync the DMA region specified&n; * by @dma_handle into the coherence domain.  On SN, we&squot;re always cache&n; * coherent, so we just need to free any ATEs associated with this mapping.&n; */
DECL|function|sn_dma_unmap_single
r_void
id|sn_dma_unmap_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|dma_addr
comma
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_unmap_single
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_unmap_sg - unmap a DMA scatterlist&n; * @dev: device to unmap&n; * @sg: scatterlist to unmap&n; * @nhwentries: number of scatterlist entries&n; * @direction: DMA direction&n; *&n; * Unmap a set of streaming mode DMA translations.&n; */
DECL|function|sn_dma_unmap_sg
r_void
id|sn_dma_unmap_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nhwentries
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nhwentries
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|sg-&gt;dma_address
comma
id|direction
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
(paren
id|dma_addr_t
)paren
l_int|NULL
suffix:semicolon
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|sn_dma_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_unmap_sg
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_dma_map_sg - map a scatterlist for DMA&n; * @dev: device to map for&n; * @sg: scatterlist to map&n; * @nhwentries: number of entries&n; * @direction: direction of the DMA transaction&n; *&n; * Maps each entry of @sg for DMA.&n; */
DECL|function|sn_dma_map_sg
r_int
id|sn_dma_map_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nhwentries
comma
r_int
id|direction
)paren
(brace
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|scatterlist
op_star
id|saved_sg
op_assign
id|sg
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup a DMA address for each entry in the scatterlist.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nhwentries
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|phys_addr
op_assign
id|SG_ENT_PHYS_ADDRESS
c_func
(paren
id|sg
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|sg-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg-&gt;dma_address
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: out of ATEs&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Free any successfully allocated entries.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|sn_dma_unmap_sg
c_func
(paren
id|dev
comma
id|saved_sg
comma
id|i
comma
id|direction
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
)brace
r_return
id|nhwentries
suffix:semicolon
)brace
DECL|variable|sn_dma_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_map_sg
)paren
suffix:semicolon
DECL|function|sn_dma_sync_single_for_cpu
r_void
id|sn_dma_sync_single_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_single_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_single_for_cpu
)paren
suffix:semicolon
DECL|function|sn_dma_sync_single_for_device
r_void
id|sn_dma_sync_single_for_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_single_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_single_for_device
)paren
suffix:semicolon
DECL|function|sn_dma_sync_sg_for_cpu
r_void
id|sn_dma_sync_sg_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_sg_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_sg_for_cpu
)paren
suffix:semicolon
DECL|function|sn_dma_sync_sg_for_device
r_void
id|sn_dma_sync_sg_for_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_sg_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_sg_for_device
)paren
suffix:semicolon
DECL|function|sn_dma_mapping_error
r_int
id|sn_dma_mapping_error
c_func
(paren
id|dma_addr_t
id|dma_addr
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sn_dma_mapping_error
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_mapping_error
)paren
suffix:semicolon
DECL|function|sn_pci_get_legacy_mem
r_char
op_star
id|sn_pci_get_legacy_mem
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
(paren
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_mem
op_or
id|__IA64_UNCACHED_OFFSET
)paren
suffix:semicolon
)brace
DECL|function|sn_pci_legacy_read
r_int
id|sn_pci_legacy_read
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
id|u16
id|port
comma
id|u32
op_star
id|val
comma
id|u8
id|size
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|addr
op_assign
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_io
op_or
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|addr
op_add_assign
id|port
suffix:semicolon
id|ret
op_assign
id|ia64_sn_probe_mem
c_func
(paren
id|addr
comma
(paren
r_int
)paren
id|size
comma
(paren
r_void
op_star
)paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
op_star
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|sn_pci_legacy_write
r_int
id|sn_pci_legacy_write
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
id|u16
id|port
comma
id|u32
id|val
comma
id|u8
id|size
)paren
(brace
r_int
id|ret
op_assign
id|size
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
r_int
r_int
op_star
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Put the phys addr in uncached space */
id|paddr
op_assign
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_io
op_or
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|paddr
op_add_assign
id|port
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
id|paddr
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
(paren
r_volatile
id|u8
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u8
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
r_volatile
id|u16
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u16
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_volatile
id|u32
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u32
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
eof
