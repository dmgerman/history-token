multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000,2002-2004 Silicon Graphics, Inc. All rights reserved.&n; *&n; * Routines for PCI DMA mapping.  See Documentation/DMA-mapping.txt for&n; * a description of how these routines should be used.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &quot;pci/pcibus_provider_defs.h&quot;
macro_line|#include &quot;pci/pcidev.h&quot;
macro_line|#include &quot;pci/pcibr_provider.h&quot;
r_void
id|sn_pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
suffix:semicolon
multiline_comment|/**&n; * sn_pci_alloc_consistent - allocate memory for coherent DMA&n; * @hwdev: device to allocate for&n; * @size: size of the region&n; * @dma_handle: DMA (bus) address&n; *&n; * pci_alloc_consistent() returns a pointer to a memory region suitable for&n; * coherent DMA traffic to/from a PCI device.  On SN platforms, this means&n; * that @dma_handle will have the %PCIIO_DMA_CMD flag set.&n; *&n; * This interface is usually used for &quot;command&quot; streams (e.g. the command&n; * queue for a SCSI controller).  See Documentation/DMA-mapping.txt for&n; * more information.&n; *&n; * Also known as platform_pci_alloc_consistent() by the IA64 machvec code.&n; */
DECL|function|sn_pci_alloc_consistent
r_void
op_star
id|sn_pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_void
op_star
id|cpuaddr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bussoft
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_PCI_BRIDGE_ASIC
c_func
(paren
id|bussoft-&gt;bs_asic_type
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* unsupported asic type */
)brace
multiline_comment|/*&n;&t; * Allocate the memory.&n;&t; * FIXME: We should be doing alloc_pages_node for the node closest&n;&t; *        to the PCI device.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpuaddr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|cpuaddr
comma
l_int|0x0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* physical addr. of the memory we just got */
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|cpuaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 64 bit address translations should never fail.&n;&t; * 32 bit translations can fail if there are insufficient mapping&n;&t; *   resources.&n;&t; */
op_star
id|dma_handle
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
id|SN_PCIDMA_CONSISTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dma_handle
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_pci_alloc_consistent():  failed  *dma_handle = 0x%lx hwdev-&gt;dev.coherent_dma_mask = 0x%lx &bslash;n&quot;
comma
op_star
id|dma_handle
comma
id|hwdev-&gt;dev.coherent_dma_mask
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|cpuaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|cpuaddr
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_free_consistent - free memory associated with coherent DMAable region&n; * @hwdev: device to free for&n; * @size: size to free&n; * @vaddr: kernel virtual address to free&n; * @dma_handle: DMA address associated with this region&n; *&n; * Frees the memory allocated by pci_alloc_consistent().  Also known&n; * as platform_pci_free_consistent() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_free_consistent
id|sn_pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bussoft
)paren
(brace
r_return
suffix:semicolon
)brace
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|dma_handle
comma
l_int|0
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_map_sg - map a scatter-gather list for DMA&n; * @hwdev: device to map for&n; * @sg: scatterlist to map&n; * @nents: number of entries&n; * @direction: direction of the DMA transaction&n; *&n; * Maps each entry of @sg for DMA.  Also known as platform_pci_map_sg by the&n; * IA64 machvec code.&n; */
r_int
DECL|function|sn_pci_map_sg
id|sn_pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|scatterlist
op_star
id|saved_sg
op_assign
id|sg
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
multiline_comment|/* can&squot;t go anywhere w/o a direction in life */
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bussoft
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SN cannot support DMA addresses smaller than 32 bits. */
r_if
c_cond
(paren
id|hwdev-&gt;dma_mask
OL
l_int|0x7fffffff
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Setup a DMA address for each entry in the&n;&t; * scatterlist.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|phys_addr
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|sg-&gt;page
)paren
op_plus
id|sg-&gt;offset
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|sg-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg-&gt;dma_address
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_pci_map_sg: Unable to allocate &quot;
l_string|&quot;anymore page map entries.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We will need to free all previously allocated entries.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|sn_pci_unmap_sg
c_func
(paren
id|hwdev
comma
id|saved_sg
comma
id|i
comma
id|direction
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
)brace
r_return
id|nents
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_unmap_sg - unmap a scatter-gather list&n; * @hwdev: device to unmap&n; * @sg: scatterlist to unmap&n; * @nents: number of scatterlist entries&n; * @direction: DMA direction&n; *&n; * Unmap a set of streaming mode DMA translations.  Again, cpu read rules&n; * concerning calls here are the same as for pci_unmap_single() below.  Also&n; * known as sn_pci_unmap_sg() by the IA64 machvec code.&n; */
r_void
DECL|function|sn_pci_unmap_sg
id|sn_pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
multiline_comment|/* can&squot;t go anywhere w/o a direction in life */
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bussoft
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|sg-&gt;dma_address
comma
id|direction
)paren
suffix:semicolon
id|sg-&gt;dma_address
op_assign
(paren
id|dma_addr_t
)paren
l_int|NULL
suffix:semicolon
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * sn_pci_map_single - map a single region for DMA&n; * @hwdev: device to map for&n; * @ptr: kernel virtual address of the region to map&n; * @size: size of the region&n; * @direction: DMA direction&n; *&n; * Map the region pointed to by @ptr for DMA and return the&n; * DMA address.   Also known as platform_pci_map_single() by&n; * the IA64 machvec code.&n; *&n; * We map this to the one step pcibr_dmamap_trans interface rather than&n; * the two step pcibr_dmamap_alloc/pcibr_dmamap_addr because we have&n; * no way of saving the dmamap handle from the alloc to later free&n; * (which is pretty much unacceptable).&n; *&n; * TODO: simplify our interface;&n; *       get rid of dev_desc and vhdl (seems redundant given a pci_dev);&n; *       figure out how to save dmamap handle so can use two step.&n; */
id|dma_addr_t
DECL|function|sn_pci_map_single
id|sn_pci_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|dma_addr_t
id|dma_addr
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bussoft
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_PCI_BRIDGE_ASIC
c_func
(paren
id|bussoft-&gt;bs_asic_type
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unsupported asic type */
)brace
multiline_comment|/* SN cannot support DMA addresses smaller than 32 bits. */
r_if
c_cond
(paren
id|hwdev-&gt;dma_mask
OL
l_int|0x7fffffff
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Call our dmamap interface&n;&t; */
id|phys_addr
op_assign
id|__pa
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|dma_addr
op_assign
id|pcibr_dma_map
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pci_map_single: Unable to allocate anymore &quot;
l_string|&quot;page map entries.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
(paren
id|dma_addr_t
)paren
id|dma_addr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_pci_dma_sync_single_* - make sure all DMAs or CPU accesses&n; * have completed&n; * @hwdev: device to sync&n; * @dma_handle: DMA address to sync&n; * @size: size of region&n; * @direction: DMA direction&n; *&n; * This routine is supposed to sync the DMA region specified&n; * by @dma_handle into the &squot;coherence domain&squot;.  We do not need to do&n; * anything on our platform.&n; */
r_void
DECL|function|sn_pci_unmap_single
id|sn_pci_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|SN_PCIDEV_INFO
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_struct
id|pcibus_bussoft
op_star
id|bussoft
op_assign
id|SN_PCIDEV_BUSSOFT
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bussoft
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_PCI_BRIDGE_ASIC
c_func
(paren
id|bussoft-&gt;bs_asic_type
)paren
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* unsupported asic type */
)brace
id|pcibr_dma_unmap
c_func
(paren
id|pcidev_info
comma
id|dma_addr
comma
id|direction
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_dma_supported - test a DMA mask&n; * @hwdev: device to test&n; * @mask: DMA mask to test&n; *&n; * Return whether the given PCI device DMA address mask can be supported&n; * properly.  For example, if your device can only drive the low 24-bits&n; * during PCI bus mastering, then you would pass 0x00ffffff as the mask to&n; * this function.  Of course, SN only supports devices that have 32 or more&n; * address bits when using the PMU.  We could theoretically support &lt;32 bit&n; * cards using direct mapping, but we&squot;ll worry about that later--on the off&n; * chance that someone actually wants to use such a card.&n; */
DECL|function|sn_pci_dma_supported
r_int
id|sn_pci_dma_supported
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|u64
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OL
l_int|0x7fffffff
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * New generic DMA routines just wrap sn2 PCI routines until we&n; * support other bus types (if ever).&n; */
DECL|function|sn_dma_supported
r_int
id|sn_dma_supported
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|mask
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_return
id|sn_pci_dma_supported
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|mask
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_supported
)paren
suffix:semicolon
DECL|function|sn_dma_set_mask
r_int
id|sn_dma_set_mask
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|dma_mask
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_dma_supported
c_func
(paren
id|dev
comma
id|dma_mask
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|dev-&gt;dma_mask
op_assign
id|dma_mask
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sn_dma_set_mask
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_set_mask
)paren
suffix:semicolon
DECL|function|sn_dma_alloc_coherent
r_void
op_star
id|sn_dma_alloc_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
comma
r_int
id|flag
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_return
id|sn_pci_alloc_consistent
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|size
comma
id|dma_handle
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_alloc_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_alloc_coherent
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_free_coherent
id|sn_dma_free_coherent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|sn_pci_free_consistent
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|size
comma
id|cpu_addr
comma
id|dma_handle
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_free_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_free_coherent
)paren
suffix:semicolon
id|dma_addr_t
DECL|function|sn_dma_map_single
id|sn_dma_map_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|cpu_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_return
id|sn_pci_map_single
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|cpu_addr
comma
id|size
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_map_single
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_unmap_single
id|sn_dma_unmap_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|sn_pci_unmap_single
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|dma_addr
comma
id|size
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_unmap_single
)paren
suffix:semicolon
id|dma_addr_t
DECL|function|sn_dma_map_page
id|sn_dma_map_page
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_return
id|pci_map_page
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|page
comma
id|offset
comma
id|size
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_map_page
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_map_page
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_unmap_page
id|sn_dma_unmap_page
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_address
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|pci_unmap_page
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|dma_address
comma
id|size
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_unmap_page
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_unmap_page
)paren
suffix:semicolon
r_int
DECL|function|sn_dma_map_sg
id|sn_dma_map_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
r_return
id|sn_pci_map_sg
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|sg
comma
id|nents
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_map_sg
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_unmap_sg
id|sn_dma_unmap_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nhwentries
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
id|sn_pci_unmap_sg
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
comma
id|sg
comma
id|nhwentries
comma
(paren
r_int
)paren
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_unmap_sg
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_sync_single_for_cpu
id|sn_dma_sync_single_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_single_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_single_for_cpu
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_sync_single_for_device
id|sn_dma_sync_single_for_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_single_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_single_for_device
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_sync_sg_for_cpu
id|sn_dma_sync_sg_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_sg_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_sg_for_cpu
)paren
suffix:semicolon
r_void
DECL|function|sn_dma_sync_sg_for_device
id|sn_dma_sync_sg_for_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
id|BUG_ON
c_func
(paren
id|dev-&gt;bus
op_ne
op_amp
id|pci_bus_type
)paren
suffix:semicolon
)brace
DECL|function|sn_dma_mapping_error
r_int
id|sn_dma_mapping_error
c_func
(paren
id|dma_addr_t
id|dma_addr
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sn_dma_sync_sg_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_sync_sg_for_device
)paren
suffix:semicolon
DECL|variable|sn_pci_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_unmap_single
)paren
suffix:semicolon
DECL|variable|sn_pci_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_map_single
)paren
suffix:semicolon
DECL|variable|sn_pci_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_map_sg
)paren
suffix:semicolon
DECL|variable|sn_pci_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_unmap_sg
)paren
suffix:semicolon
DECL|variable|sn_pci_alloc_consistent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_alloc_consistent
)paren
suffix:semicolon
DECL|variable|sn_pci_free_consistent
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_free_consistent
)paren
suffix:semicolon
DECL|variable|sn_pci_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|sn_pci_dma_supported
)paren
suffix:semicolon
DECL|variable|sn_dma_mapping_error
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_mapping_error
)paren
suffix:semicolon
DECL|function|sn_pci_get_legacy_mem
r_char
op_star
id|sn_pci_get_legacy_mem
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
(paren
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_mem
op_or
id|__IA64_UNCACHED_OFFSET
)paren
suffix:semicolon
)brace
DECL|function|sn_pci_legacy_read
r_int
id|sn_pci_legacy_read
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
id|u16
id|port
comma
id|u32
op_star
id|val
comma
id|u8
id|size
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|addr
op_assign
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_io
op_or
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|addr
op_add_assign
id|port
suffix:semicolon
id|ret
op_assign
id|ia64_sn_probe_mem
c_func
(paren
id|addr
comma
(paren
r_int
)paren
id|size
comma
(paren
r_void
op_star
)paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
op_star
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|sn_pci_legacy_write
r_int
id|sn_pci_legacy_write
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
id|u16
id|port
comma
id|u32
id|val
comma
id|u8
id|size
)paren
(brace
r_int
id|ret
op_assign
id|size
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
r_int
r_int
op_star
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Put the phys addr in uncached space */
id|paddr
op_assign
id|SN_PCIBUS_BUSSOFT
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|bs_legacy_io
op_or
id|__IA64_UNCACHED_OFFSET
suffix:semicolon
id|paddr
op_add_assign
id|port
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
id|paddr
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
(paren
r_volatile
id|u8
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u8
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
r_volatile
id|u16
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u16
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_volatile
id|u32
op_star
)paren
(paren
id|addr
)paren
op_assign
(paren
id|u32
)paren
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
eof
