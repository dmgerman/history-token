multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2001-2004 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/geo.h&gt;
macro_line|#include &quot;xtalk/xwidgetdev.h&quot;
macro_line|#include &quot;xtalk/hubdev.h&quot;
macro_line|#include &quot;pci/pcibus_provider_defs.h&quot;
macro_line|#include &quot;pci/pcidev.h&quot;
macro_line|#include &quot;pci/tiocp.h&quot;
macro_line|#include &quot;pci/pic.h&quot;
macro_line|#include &quot;pci/pcibr_provider.h&quot;
macro_line|#include &quot;pci/tiocp.h&quot;
macro_line|#include &quot;tio.h&quot;
macro_line|#include &lt;asm/sn/addrs.h&gt;
r_extern
r_int
id|sn_ioif_inited
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    DMA MANAGEMENT&n; *&n; *      The Bridge ASIC provides three methods of doing DMA: via a &quot;direct map&quot;&n; *      register available in 32-bit PCI space (which selects a contiguous 2G&n; *&t;address space on some other widget), via &quot;direct&quot; addressing via 64-bit&n; *      PCI space (all destination information comes from the PCI address,&n; *      including transfer attributes), and via a &quot;mapped&quot; region that allows &n; *      a bunch of different small mappings to be established with the PMU.&n; *&n; *      For efficiency, we most prefer to use the 32bit direct mapping facility,&n; *      since it requires no resource allocations. The advantage of using the&n; *      PMU over the 64-bit direct is that single-cycle PCI addressing can be&n; *      used; the advantage of using 64-bit direct over PMU addressing is that&n; *      we do not have to allocate entries in the PMU.&n; */
r_static
r_uint64
DECL|function|pcibr_dmamap_ate32
id|pcibr_dmamap_ate32
c_func
(paren
r_struct
id|pcidev_info
op_star
id|info
comma
r_uint64
id|paddr
comma
r_int
id|req_size
comma
r_uint64
id|flags
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|info-&gt;pdi_host_pcidev_info
suffix:semicolon
r_struct
id|pcibus_info
op_star
id|pcibus_info
op_assign
(paren
r_struct
id|pcibus_info
op_star
)paren
id|pcidev_info
op_member_access_from_pointer
id|pdi_pcibus_info
suffix:semicolon
r_uint8
id|internal_device
op_assign
(paren
id|PCI_SLOT
c_func
(paren
id|pcidev_info-&gt;pdi_host_pcidev_info
op_member_access_from_pointer
id|pdi_linux_pcidev-&gt;devfn
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|ate_count
suffix:semicolon
r_int
id|ate_index
suffix:semicolon
r_uint64
id|ate_flags
op_assign
id|flags
op_or
id|PCI32_ATE_V
suffix:semicolon
r_uint64
id|ate
suffix:semicolon
r_uint64
id|pci_addr
suffix:semicolon
r_uint64
id|xio_addr
suffix:semicolon
r_uint64
id|offset
suffix:semicolon
multiline_comment|/* PIC in PCI-X mode does not supports 32bit PageMap mode */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
op_logical_and
id|IS_PCIX
c_func
(paren
id|pcibus_info
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate the number of ATEs needed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|MINIMAL_ATE_FLAG
c_func
(paren
id|paddr
comma
id|req_size
)paren
)paren
)paren
(brace
id|ate_count
op_assign
id|IOPG
c_func
(paren
(paren
id|IOPGSIZE
op_minus
l_int|1
)paren
multiline_comment|/* worst case start offset */
op_plus
id|req_size
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
r_else
(brace
multiline_comment|/* assume requested target is page aligned */
id|ate_count
op_assign
id|IOPG
c_func
(paren
id|req_size
multiline_comment|/* max mapping bytes */
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* round UP */
)brace
multiline_comment|/* Get the number of ATEs required. */
id|ate_index
op_assign
id|pcibr_ate_alloc
c_func
(paren
id|pcibus_info
comma
id|ate_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ate_index
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* In PCI-X mode, Prefetch not supported */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibus_info
)paren
)paren
id|ate_flags
op_and_assign
op_complement
(paren
id|PCI32_ATE_PREF
)paren
suffix:semicolon
id|xio_addr
op_assign
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
ques
c_cond
id|PHYS_TO_DMA
c_func
(paren
id|paddr
)paren
suffix:colon
id|PHYS_TO_TIODMA
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|offset
op_assign
id|IOPGOFF
c_func
(paren
id|xio_addr
)paren
suffix:semicolon
id|ate
op_assign
id|ate_flags
op_or
(paren
id|xio_addr
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* If PIC, put the targetid in the ATE */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
)paren
(brace
id|ate
op_or_assign
(paren
id|pcibus_info-&gt;pbi_hub_xid
op_lshift
id|PIC_ATE_TARGETID_SHFT
)paren
suffix:semicolon
)brace
id|ate_write
c_func
(paren
id|pcibus_info
comma
id|ate_index
comma
id|ate_count
comma
id|ate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the DMA mapped Address.&n;&t; */
id|pci_addr
op_assign
id|PCI32_MAPPED_BASE
op_plus
id|offset
op_plus
id|IOPGSIZE
op_star
id|ate_index
suffix:semicolon
multiline_comment|/*&n;&t; * If swap was set in device in pcibr_endian_set()&n;&t; * we need to turn swapping on.&n;&t; */
r_if
c_cond
(paren
id|pcibus_info-&gt;pbi_devreg
(braket
id|internal_device
)braket
op_amp
id|PCIBR_DEV_SWAP_DIR
)paren
id|ATE_SWAP_ON
c_func
(paren
id|pci_addr
)paren
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_static
r_uint64
DECL|function|pcibr_dmatrans_direct64
id|pcibr_dmatrans_direct64
c_func
(paren
r_struct
id|pcidev_info
op_star
id|info
comma
r_uint64
id|paddr
comma
r_uint64
id|dma_attributes
)paren
(brace
r_struct
id|pcibus_info
op_star
id|pcibus_info
op_assign
(paren
r_struct
id|pcibus_info
op_star
)paren
(paren
(paren
id|info-&gt;pdi_host_pcidev_info
)paren
op_member_access_from_pointer
id|pdi_pcibus_info
)paren
suffix:semicolon
r_uint64
id|pci_addr
suffix:semicolon
multiline_comment|/* Translate to Crosstalk View of Physical Address */
id|pci_addr
op_assign
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
ques
c_cond
id|PHYS_TO_DMA
c_func
(paren
id|paddr
)paren
suffix:colon
id|PHYS_TO_TIODMA
c_func
(paren
id|paddr
)paren
)paren
op_or
id|dma_attributes
suffix:semicolon
multiline_comment|/* Handle Bus mode */
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibus_info
)paren
)paren
id|pci_addr
op_and_assign
op_complement
id|PCI64_ATTR_PREF
suffix:semicolon
multiline_comment|/* Handle Bridge Chipset differences */
r_if
c_cond
(paren
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
)paren
(brace
id|pci_addr
op_or_assign
(paren
(paren
r_uint64
)paren
id|pcibus_info
op_member_access_from_pointer
id|pbi_hub_xid
op_lshift
id|PIC_PCI64_ATTR_TARG_SHFT
)paren
suffix:semicolon
)brace
r_else
id|pci_addr
op_or_assign
id|TIOCP_PCI64_CMDTYPE_MEM
suffix:semicolon
multiline_comment|/* If PCI mode, func zero uses VCHAN0, every other func uses VCHAN1 */
r_if
c_cond
(paren
op_logical_neg
id|IS_PCIX
c_func
(paren
id|pcibus_info
)paren
op_logical_and
id|PCI_FUNC
c_func
(paren
id|info-&gt;pdi_linux_pcidev-&gt;devfn
)paren
)paren
id|pci_addr
op_or_assign
id|PCI64_ATTR_VIRTUAL
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
r_static
r_uint64
DECL|function|pcibr_dmatrans_direct32
id|pcibr_dmatrans_direct32
c_func
(paren
r_struct
id|pcidev_info
op_star
id|info
comma
r_uint64
id|paddr
comma
r_int
id|req_size
comma
r_uint64
id|flags
)paren
(brace
r_struct
id|pcidev_info
op_star
id|pcidev_info
op_assign
id|info-&gt;pdi_host_pcidev_info
suffix:semicolon
r_struct
id|pcibus_info
op_star
id|pcibus_info
op_assign
(paren
r_struct
id|pcibus_info
op_star
)paren
id|pcidev_info
op_member_access_from_pointer
id|pdi_pcibus_info
suffix:semicolon
r_uint64
id|xio_addr
suffix:semicolon
r_uint64
id|xio_base
suffix:semicolon
r_uint64
id|offset
suffix:semicolon
r_uint64
id|endoff
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCIX
c_func
(paren
id|pcibus_info
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|xio_addr
op_assign
id|IS_PIC_SOFT
c_func
(paren
id|pcibus_info
)paren
ques
c_cond
id|PHYS_TO_DMA
c_func
(paren
id|paddr
)paren
suffix:colon
id|PHYS_TO_TIODMA
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|xio_base
op_assign
id|pcibus_info-&gt;pbi_dir_xbase
suffix:semicolon
id|offset
op_assign
id|xio_addr
op_minus
id|xio_base
suffix:semicolon
id|endoff
op_assign
id|req_size
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req_size
OG
(paren
l_int|1ULL
op_lshift
l_int|31
)paren
)paren
op_logical_or
multiline_comment|/* Too Big */
(paren
id|xio_addr
OL
id|xio_base
)paren
op_logical_or
multiline_comment|/* Out of range for mappings */
(paren
id|endoff
OG
(paren
l_int|1ULL
op_lshift
l_int|31
)paren
)paren
)paren
(brace
multiline_comment|/* Too Big */
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|PCI32_DIRECT_BASE
op_or
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper routine for free&squot;ing DMA maps&n; * DMA mappings for Direct 64 and 32 do not have any DMA maps.&n; */
r_void
DECL|function|pcibr_dma_unmap
id|pcibr_dma_unmap
c_func
(paren
r_struct
id|pcidev_info
op_star
id|pcidev_info
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|direction
)paren
(brace
r_struct
id|pcibus_info
op_star
id|pcibus_info
op_assign
(paren
r_struct
id|pcibus_info
op_star
)paren
id|pcidev_info
op_member_access_from_pointer
id|pdi_pcibus_info
suffix:semicolon
r_if
c_cond
(paren
id|IS_PCI32_MAPPED
c_func
(paren
id|dma_handle
)paren
)paren
(brace
r_int
id|ate_index
suffix:semicolon
id|ate_index
op_assign
id|IOPG
c_func
(paren
(paren
id|ATE_SWAP_OFF
c_func
(paren
id|dma_handle
)paren
op_minus
id|PCI32_MAPPED_BASE
)paren
)paren
suffix:semicolon
id|pcibr_ate_free
c_func
(paren
id|pcibus_info
comma
id|ate_index
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * On SN systems there is a race condition between a PIO read response and &n; * DMA&squot;s.  In rare cases, the read response may beat the DMA, causing the&n; * driver to think that data in memory is complete and meaningful.  This code&n; * eliminates that race.  This routine is called by the PIO read routines&n; * after doing the read.  For PIC this routine then forces a fake interrupt&n; * on another line, which is logically associated with the slot that the PIO&n; * is addressed to.  It then spins while watching the memory location that&n; * the interrupt is targetted to.  When the interrupt response arrives, we &n; * are sure that the DMA has landed in memory and it is safe for the driver&n; * to proceed.&t;For TIOCP use the Device(x) Write Request Buffer Flush &n; * Bridge register since it ensures the data has entered the coherence domain,&n; * unlike the PIC Device(x) Write Request Buffer Flush register.&n; */
DECL|function|sn_dma_flush
r_void
id|sn_dma_flush
c_func
(paren
r_uint64
id|addr
)paren
(brace
id|nasid_t
id|nasid
suffix:semicolon
r_int
id|is_tio
suffix:semicolon
r_int
id|wid_num
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|bwin
suffix:semicolon
r_uint64
id|flags
suffix:semicolon
r_struct
id|hubdev_info
op_star
id|hubinfo
suffix:semicolon
r_volatile
r_struct
id|sn_flush_device_list
op_star
id|p
suffix:semicolon
r_struct
id|sn_flush_nasid_entry
op_star
id|flush_nasid_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_ioif_inited
)paren
r_return
suffix:semicolon
id|nasid
op_assign
id|NASID_GET
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
)paren
r_return
suffix:semicolon
id|hubinfo
op_assign
(paren
id|NODEPDA
c_func
(paren
id|nasid_to_cnodeid
c_func
(paren
id|nasid
)paren
)paren
)paren
op_member_access_from_pointer
id|pdinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hubinfo
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|is_tio
op_assign
(paren
id|nasid
op_amp
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_tio
)paren
(brace
id|wid_num
op_assign
id|TIO_SWIN_WIDGETNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bwin
op_assign
id|TIO_BWIN_WINDOWNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|wid_num
op_assign
id|SWIN_WIDGETNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bwin
op_assign
id|BWIN_WINDOWNUM
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
id|flush_nasid_list
op_assign
op_amp
id|hubinfo-&gt;hdi_flush_nasid_list
suffix:semicolon
r_if
c_cond
(paren
id|flush_nasid_list-&gt;widget_p
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bwin
OG
l_int|0
)paren
(brace
r_uint64
id|itte
op_assign
id|flush_nasid_list-&gt;iio_itte
(braket
id|bwin
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_tio
)paren
(brace
id|wid_num
op_assign
(paren
id|itte
op_rshift
id|TIO_ITTE_WIDGET_SHIFT
)paren
op_amp
id|TIO_ITTE_WIDGET_MASK
suffix:semicolon
)brace
r_else
(brace
id|wid_num
op_assign
(paren
id|itte
op_rshift
id|IIO_ITTE_WIDGET_SHIFT
)paren
op_amp
id|IIO_ITTE_WIDGET_MASK
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flush_nasid_list-&gt;widget_p
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|flush_nasid_list-&gt;widget_p
(braket
id|wid_num
)braket
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|p
op_assign
op_amp
id|flush_nasid_list-&gt;widget_p
(braket
id|wid_num
)braket
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* find a matching BAR */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_PER_WIDGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sfdl_bar_list
(braket
id|j
)braket
dot
id|start
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|p-&gt;sfdl_bar_list
(braket
id|j
)braket
dot
id|start
op_logical_and
id|addr
op_le
id|p-&gt;sfdl_bar_list
(braket
id|j
)braket
dot
id|end
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|PCI_ROM_RESOURCE
op_logical_and
id|p-&gt;sfdl_bar_list
(braket
id|j
)braket
dot
id|start
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* if no matching BAR, return without doing anything. */
r_if
c_cond
(paren
id|i
op_eq
id|DEV_PER_WIDGET
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * For TIOCP use the Device(x) Write Request Buffer Flush Bridge&n;&t; * register since it ensures the data has entered the coherence&n;&t; * domain, unlike PIC&n;&t; */
r_if
c_cond
(paren
id|is_tio
)paren
(brace
r_uint32
id|tio_id
op_assign
id|REMOTE_HUB_L
c_func
(paren
id|nasid
comma
id|TIO_NODE_ID
)paren
suffix:semicolon
r_uint32
id|revnum
op_assign
id|XWIDGET_PART_REV_NUM
c_func
(paren
id|tio_id
)paren
suffix:semicolon
multiline_comment|/* TIOCP BRINGUP WAR (PV907516): Don&squot;t write buffer flush reg */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|XWIDGET_PART_REV_NUM_REV
c_func
(paren
id|revnum
)paren
)paren
op_amp
id|PV907516
)paren
(brace
r_return
suffix:semicolon
)brace
r_else
(brace
id|pcireg_wrb_flush_get
c_func
(paren
id|p-&gt;sfdl_pcibus_info
comma
(paren
id|p-&gt;sfdl_slot
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
(paren
r_struct
id|sn_flush_device_list
op_star
)paren
id|p
)paren
op_member_access_from_pointer
id|sfdl_flush_lock
comma
id|flags
)paren
suffix:semicolon
id|p-&gt;sfdl_flush_value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force an interrupt. */
op_star
(paren
r_volatile
r_uint32
op_star
)paren
(paren
id|p-&gt;sfdl_force_int_addr
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for the interrupt to come back. */
r_while
c_loop
(paren
op_star
(paren
id|p-&gt;sfdl_flush_addr
)paren
op_ne
l_int|0x10f
)paren
suffix:semicolon
multiline_comment|/* okay, everything is synched up. */
id|spin_unlock_irqrestore
c_func
(paren
(paren
id|spinlock_t
op_star
)paren
op_amp
id|p-&gt;sfdl_flush_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper DMA interface.  Called from pci_dma.c routines.&n; */
r_uint64
DECL|function|pcibr_dma_map
id|pcibr_dma_map
c_func
(paren
r_struct
id|pcidev_info
op_star
id|pcidev_info
comma
r_int
r_int
id|phys_addr
comma
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
id|pcidev_info-&gt;pdi_linux_pcidev
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SN_PCIDMA_CONSISTENT
)paren
(brace
multiline_comment|/* sn_pci_alloc_consistent interfaces */
r_if
c_cond
(paren
id|pcidev-&gt;dev.coherent_dma_mask
op_eq
op_complement
l_int|0UL
)paren
(brace
id|dma_handle
op_assign
id|pcibr_dmatrans_direct64
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|PCI64_ATTR_BAR
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_handle
op_assign
(paren
id|dma_addr_t
)paren
id|pcibr_dmamap_ate32
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
id|PCI32_ATE_BAR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* map_sg/map_single interfaces */
multiline_comment|/* SN cannot support DMA addresses smaller than 32 bits. */
r_if
c_cond
(paren
id|pcidev-&gt;dma_mask
OL
l_int|0x7fffffff
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcidev-&gt;dma_mask
op_eq
op_complement
l_int|0UL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Handle the most common case: 64 bit cards.  This&n;&t;&t;&t; * call should always succeed.&n;&t;&t;&t; */
id|dma_handle
op_assign
id|pcibr_dmatrans_direct64
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|PCI64_ATTR_PREF
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Handle 32-63 bit cards via direct mapping */
id|dma_handle
op_assign
id|pcibr_dmatrans_direct32
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_handle
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is a 32 bit card and we cannot do direct mapping,&n;&t;&t;&t;&t; * so we use an ATE.&n;&t;&t;&t;&t; */
id|dma_handle
op_assign
id|pcibr_dmamap_ate32
c_func
(paren
id|pcidev_info
comma
id|phys_addr
comma
id|size
comma
id|PCI32_ATE_PREF
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|dma_handle
suffix:semicolon
)brace
DECL|variable|sn_dma_flush
id|EXPORT_SYMBOL
c_func
(paren
id|sn_dma_flush
)paren
suffix:semicolon
eof
