multiline_comment|/* &n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Jack Steiner (steiner@sgi.com)&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
r_void
id|bedrock_init
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|synergy_init
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|sys_fw_init
(paren
r_const
r_char
op_star
id|args
comma
r_int
id|arglen
comma
r_int
id|bsp
)paren
suffix:semicolon
DECL|variable|bootmaster
r_volatile
r_int
id|bootmaster
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used to pick bootmaster */
DECL|variable|nasidmaster
r_volatile
r_int
id|nasidmaster
(braket
l_int|128
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Used to pick node/synergy masters */
DECL|variable|init_done
r_int
id|init_done
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|bsp_lid
suffix:semicolon
DECL|macro|get_bit
mdefine_line|#define get_bit(b,p)&t;(((*p)&gt;&gt;(b))&amp;1)
r_int
DECL|function|fmain
id|fmain
c_func
(paren
r_int
id|lid
comma
r_int
id|bsp
)paren
(brace
r_int
id|syn
comma
id|nasid
comma
id|cpu
suffix:semicolon
multiline_comment|/*&n;&t; * First lets figure out who we are. This is done from the&n;&t; * LID passed to us.&n;&t; */
id|nasid
op_assign
(paren
id|lid
op_rshift
l_int|24
)paren
suffix:semicolon
id|syn
op_assign
(paren
id|lid
op_rshift
l_int|17
)paren
op_amp
l_int|1
suffix:semicolon
id|cpu
op_assign
(paren
id|lid
op_rshift
l_int|16
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Now pick a synergy master to initialize synergy registers.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|syn
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
op_eq
l_int|0
)paren
(brace
id|synergy_init
c_func
(paren
id|nasid
comma
id|syn
)paren
suffix:semicolon
id|test_and_set_bit
c_func
(paren
id|syn
op_plus
l_int|2
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|get_bit
c_func
(paren
id|syn
op_plus
l_int|2
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now pick a nasid master to initialize Bedrock registers.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|8
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
op_eq
l_int|0
)paren
(brace
id|bedrock_init
c_func
(paren
id|nasid
)paren
suffix:semicolon
id|test_and_set_bit
c_func
(paren
l_int|9
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|get_bit
c_func
(paren
l_int|9
comma
op_amp
id|nasidmaster
(braket
id|nasid
)braket
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now pick a BSP &amp; finish init.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|bootmaster
)paren
op_eq
l_int|0
)paren
(brace
id|sys_fw_init
c_func
(paren
l_int|0
comma
l_int|0
comma
id|bsp
)paren
suffix:semicolon
id|test_and_set_bit
c_func
(paren
l_int|1
comma
op_amp
id|bootmaster
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|get_bit
c_func
(paren
l_int|1
comma
op_amp
id|bootmaster
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|lid
op_eq
id|bsp_lid
)paren
suffix:semicolon
)brace
r_void
DECL|function|bedrock_init
id|bedrock_init
c_func
(paren
r_int
id|nasid
)paren
(brace
id|nasid
op_assign
id|nasid
suffix:semicolon
multiline_comment|/* to quiet gcc */
)brace
r_void
DECL|function|synergy_init
id|synergy_init
c_func
(paren
r_int
id|nasid
comma
r_int
id|syn
)paren
(brace
r_int
op_star
id|base
suffix:semicolon
r_int
id|off
suffix:semicolon
multiline_comment|/*&n;&t; * Enable all FSB flashed interrupts.&n;&t; * ZZZ - I&squot;d really like defines for this......&n;&t; */
id|base
op_assign
(paren
r_int
op_star
)paren
l_int|0x80000e0000000000LL
suffix:semicolon
multiline_comment|/* base of synergy regs */
r_for
c_loop
(paren
id|off
op_assign
l_int|0x2a0
suffix:semicolon
id|off
OL
l_int|0x2e0
suffix:semicolon
id|off
op_add_assign
l_int|8
)paren
multiline_comment|/* offset for VEC_MASK_{0-3}_A/B */
op_star
(paren
id|base
op_plus
id|off
op_div
l_int|8
)paren
op_assign
op_minus
l_int|1LL
suffix:semicolon
multiline_comment|/*&n;&t; * Set the NASID in the FSB_CONFIG register.&n;&t; */
id|base
op_assign
(paren
r_int
op_star
)paren
l_int|0x80000e0000000450LL
suffix:semicolon
op_star
id|base
op_assign
(paren
r_int
)paren
(paren
(paren
id|nasid
op_lshift
l_int|16
)paren
op_or
(paren
id|syn
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Why isnt there a bcopy/memcpy in lib64.a */
r_void
op_star
DECL|function|memcpy
id|memcpy
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_char
op_star
id|s
comma
op_star
id|se
comma
op_star
id|d
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|dest
comma
id|s
op_assign
(paren
r_char
op_star
)paren
id|src
comma
id|se
op_assign
id|s
op_plus
id|count
suffix:semicolon
id|s
OL
id|se
suffix:semicolon
id|s
op_increment
comma
id|d
op_increment
)paren
(brace
op_star
id|d
op_assign
op_star
id|s
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
eof
