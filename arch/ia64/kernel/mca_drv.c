multiline_comment|/*&n; * File:&t;mca_drv.c&n; * Purpose:&t;Generic MCA handling layer&n; *&n; * Copyright (C) 2004 FUJITSU LIMITED&n; * Copyright (C) Hidetoshi Seto (seto.hidetoshi@jp.fujitsu.com)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/mca.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &quot;mca_drv.h&quot;
multiline_comment|/* max size of SAL error record (default) */
DECL|variable|sal_rec_max
r_static
r_int
id|sal_rec_max
op_assign
l_int|10000
suffix:semicolon
multiline_comment|/* from mca.c */
DECL|variable|sal_to_os_handoff_state
r_static
id|ia64_mca_sal_to_os_state_t
op_star
id|sal_to_os_handoff_state
suffix:semicolon
DECL|variable|os_to_sal_handoff_state
r_static
id|ia64_mca_os_to_sal_state_t
op_star
id|os_to_sal_handoff_state
suffix:semicolon
multiline_comment|/* from mca_drv_asm.S */
r_extern
r_void
op_star
id|mca_handler_bhhook
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|mca_bh_lock
r_static
id|spinlock_t
id|mca_bh_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|MCA_IS_LOCAL
id|MCA_IS_LOCAL
op_assign
l_int|0
comma
DECL|enumerator|MCA_IS_GLOBAL
id|MCA_IS_GLOBAL
op_assign
l_int|1
DECL|typedef|mca_type_t
)brace
id|mca_type_t
suffix:semicolon
DECL|macro|MAX_PAGE_ISOLATE
mdefine_line|#define MAX_PAGE_ISOLATE 32
DECL|variable|page_isolate
r_static
r_struct
id|page
op_star
id|page_isolate
(braket
id|MAX_PAGE_ISOLATE
)braket
suffix:semicolon
DECL|variable|num_page_isolate
r_static
r_int
id|num_page_isolate
op_assign
l_int|0
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|ISOLATE_NG
id|ISOLATE_NG
op_assign
l_int|0
comma
DECL|enumerator|ISOLATE_OK
id|ISOLATE_OK
op_assign
l_int|1
DECL|typedef|isolate_status_t
)brace
id|isolate_status_t
suffix:semicolon
multiline_comment|/*&n; *  This pool keeps pointers to the section part of SAL error record&n; */
r_static
r_struct
(brace
DECL|member|buffer
id|slidx_list_t
op_star
id|buffer
suffix:semicolon
multiline_comment|/* section pointer list pool */
DECL|member|cur_idx
r_int
id|cur_idx
suffix:semicolon
multiline_comment|/* Current index of section pointer list pool */
DECL|member|max_idx
r_int
id|max_idx
suffix:semicolon
multiline_comment|/* Maximum index of section pointer list pool */
DECL|variable|slidx_pool
)brace
id|slidx_pool
suffix:semicolon
multiline_comment|/**&n; * mca_page_isolate - isolate a poisoned page in order not to use it later&n; * @paddr:&t;poisoned memory location&n; *&n; * Return value:&n; *&t;ISOLATE_OK / ISOLATE_NG&n; */
r_static
id|isolate_status_t
DECL|function|mca_page_isolate
id|mca_page_isolate
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|page
op_star
id|p
suffix:semicolon
multiline_comment|/* whether physical address is valid or not */
r_if
c_cond
(paren
op_logical_neg
id|ia64_phys_addr_valid
c_func
(paren
id|paddr
)paren
)paren
r_return
id|ISOLATE_NG
suffix:semicolon
multiline_comment|/* convert physical address to physical page number */
id|p
op_assign
id|pfn_to_page
c_func
(paren
id|paddr
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* check whether a page number have been already registered or not */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_page_isolate
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|page_isolate
(braket
id|i
)braket
op_eq
id|p
)paren
(brace
r_return
id|ISOLATE_OK
suffix:semicolon
)brace
multiline_comment|/* already listed */
multiline_comment|/* limitation check */
r_if
c_cond
(paren
id|num_page_isolate
op_eq
id|MAX_PAGE_ISOLATE
)paren
(brace
r_return
id|ISOLATE_NG
suffix:semicolon
)brace
multiline_comment|/* kick pages having attribute &squot;SLAB&squot; or &squot;Reserved&squot; */
r_if
c_cond
(paren
id|PageSlab
c_func
(paren
id|p
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|p
)paren
)paren
(brace
r_return
id|ISOLATE_NG
suffix:semicolon
)brace
multiline_comment|/* add attribute &squot;Reserved&squot; and register the page */
id|SetPageReserved
c_func
(paren
id|p
)paren
suffix:semicolon
id|page_isolate
(braket
id|num_page_isolate
op_increment
)braket
op_assign
id|p
suffix:semicolon
r_return
id|ISOLATE_OK
suffix:semicolon
)brace
multiline_comment|/**&n; * mca_hanlder_bh - Kill the process which occurred memory read error&n; * @paddr:&t;poisoned address received from MCA Handler&n; */
r_void
DECL|function|mca_handler_bh
id|mca_handler_bh
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;OS_MCA: process [pid: %d](%s) encounters MCA.&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mca_bh_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mca_page_isolate
c_func
(paren
id|paddr
)paren
op_eq
id|ISOLATE_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Page isolation: ( %lx ) success.&bslash;n&quot;
comma
id|paddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Page isolation: ( %lx ) failure.&bslash;n&quot;
comma
id|paddr
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mca_bh_lock
)paren
suffix:semicolon
multiline_comment|/* This process is about to be killed itself */
id|force_sig
c_func
(paren
id|SIGKILL
comma
id|current
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * mca_make_peidx - Make index of processor error section&n; * @slpi:&t;pointer to record of processor error section&n; * @peidx:&t;pointer to index of processor error section&n; */
r_static
r_void
DECL|function|mca_make_peidx
id|mca_make_peidx
c_func
(paren
id|sal_log_processor_info_t
op_star
id|slpi
comma
id|peidx_table_t
op_star
id|peidx
)paren
(brace
multiline_comment|/* &n;&t; * calculate the start address of&n;&t; *   &quot;struct cpuid_info&quot; and &quot;sal_processor_static_info_t&quot;.&n;&t; */
id|u64
id|total_check_num
op_assign
id|slpi-&gt;valid.num_cache_check
op_plus
id|slpi-&gt;valid.num_tlb_check
op_plus
id|slpi-&gt;valid.num_bus_check
op_plus
id|slpi-&gt;valid.num_reg_file_check
op_plus
id|slpi-&gt;valid.num_ms_check
suffix:semicolon
id|u64
id|head_size
op_assign
r_sizeof
(paren
id|sal_log_mod_error_info_t
)paren
op_star
id|total_check_num
op_plus
r_sizeof
(paren
id|sal_log_processor_info_t
)paren
suffix:semicolon
id|u64
id|mid_size
op_assign
id|slpi-&gt;valid.cpuid_info
op_star
r_sizeof
(paren
r_struct
id|sal_cpuid_info
)paren
suffix:semicolon
id|peidx_head
c_func
(paren
id|peidx
)paren
op_assign
id|slpi
suffix:semicolon
id|peidx_mid
c_func
(paren
id|peidx
)paren
op_assign
(paren
r_struct
id|sal_cpuid_info
op_star
)paren
(paren
id|slpi-&gt;valid.cpuid_info
ques
c_cond
(paren
(paren
r_char
op_star
)paren
id|slpi
op_plus
id|head_size
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|peidx_bottom
c_func
(paren
id|peidx
)paren
op_assign
(paren
id|sal_processor_static_info_t
op_star
)paren
(paren
id|slpi-&gt;valid.psi_static_struct
ques
c_cond
(paren
(paren
r_char
op_star
)paren
id|slpi
op_plus
id|head_size
op_plus
id|mid_size
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * mca_make_slidx -  Make index of SAL error record &n; * @buffer:&t;pointer to SAL error record&n; * @slidx:&t;pointer to index of SAL error record&n; *&n; * Return value:&n; *&t;1 if record has platform error / 0 if not&n; */
DECL|macro|LOG_INDEX_ADD_SECT_PTR
mdefine_line|#define LOG_INDEX_ADD_SECT_PTR(sect, ptr) &bslash;&n;        { slidx_list_t *hl = &amp;slidx_pool.buffer[slidx_pool.cur_idx]; &bslash;&n;          hl-&gt;hdr = ptr; &bslash;&n;          list_add(&amp;hl-&gt;list, &amp;(sect)); &bslash;&n;          slidx_pool.cur_idx = (slidx_pool.cur_idx + 1)%slidx_pool.max_idx; }
r_static
r_int
DECL|function|mca_make_slidx
id|mca_make_slidx
c_func
(paren
r_void
op_star
id|buffer
comma
id|slidx_table_t
op_star
id|slidx
)paren
(brace
r_int
id|platform_err
op_assign
l_int|0
suffix:semicolon
r_int
id|record_len
op_assign
(paren
(paren
id|sal_log_record_header_t
op_star
)paren
id|buffer
)paren
op_member_access_from_pointer
id|len
suffix:semicolon
id|u32
id|ercd_pos
suffix:semicolon
r_int
id|sects
suffix:semicolon
id|sal_log_section_hdr_t
op_star
id|sp
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize index referring current record&n;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;proc_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;mem_dev_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;sel_dev_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;pci_bus_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;smbios_dev_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;pci_comp_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;plat_specific_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;host_ctlr_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;plat_bus_err
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|slidx-&gt;unsupported
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Extract a Record Header&n;&t; */
id|slidx-&gt;header
op_assign
id|buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Extract each section records&n;&t; * (arranged from &quot;int ia64_log_platform_info_print()&quot;)&n;&t; */
r_for
c_loop
(paren
id|ercd_pos
op_assign
r_sizeof
(paren
id|sal_log_record_header_t
)paren
comma
id|sects
op_assign
l_int|0
suffix:semicolon
id|ercd_pos
OL
id|record_len
suffix:semicolon
id|ercd_pos
op_add_assign
id|sp-&gt;len
comma
id|sects
op_increment
)paren
(brace
id|sp
op_assign
(paren
id|sal_log_section_hdr_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|buffer
op_plus
id|ercd_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PROC_DEV_ERR_SECT_GUID
)paren
)paren
(brace
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;proc_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_MEM_DEV_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;mem_dev_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_SEL_DEV_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;sel_dev_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_PCI_BUS_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;pci_bus_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;smbios_dev_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_PCI_COMP_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;pci_comp_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_SPECIFIC_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;plat_specific_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_HOST_CTLR_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;host_ctlr_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|sp-&gt;guid
comma
id|SAL_PLAT_BUS_ERR_SECT_GUID
)paren
)paren
(brace
id|platform_err
op_assign
l_int|1
suffix:semicolon
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;plat_bus_err
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
(brace
id|LOG_INDEX_ADD_SECT_PTR
c_func
(paren
id|slidx-&gt;unsupported
comma
id|sp
)paren
suffix:semicolon
)brace
)brace
id|slidx-&gt;n_sections
op_assign
id|sects
suffix:semicolon
r_return
id|platform_err
suffix:semicolon
)brace
multiline_comment|/**&n; * init_record_index_pools - Initialize pool of lists for SAL record index&n; *&n; * Return value:&n; *&t;0 on Success / -ENOMEM on Failure&n; */
r_static
r_int
DECL|function|init_record_index_pools
id|init_record_index_pools
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rec_max_size
suffix:semicolon
multiline_comment|/* Maximum size of SAL error records */
r_int
id|sect_min_size
suffix:semicolon
multiline_comment|/* Minimum size of SAL error sections */
multiline_comment|/* minimum size table of each section */
r_static
r_int
id|sal_log_sect_min_sizes
(braket
)braket
op_assign
(brace
r_sizeof
(paren
id|sal_log_processor_info_t
)paren
op_plus
r_sizeof
(paren
id|sal_processor_static_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_mem_dev_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_sel_dev_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_pci_bus_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_smbios_dev_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_pci_comp_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_plat_specific_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_host_ctlr_err_info_t
)paren
comma
r_sizeof
(paren
id|sal_log_plat_bus_err_info_t
)paren
comma
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * MCA handler cannot allocate new memory on flight,&n;&t; * so we preallocate enough memory to handle a SAL record.&n;&t; *&n;&t; * Initialize a handling set of slidx_pool:&n;&t; *   1. Pick up the max size of SAL error records&n;&t; *   2. Pick up the min size of SAL error sections&n;&t; *   3. Allocate the pool as enough to 2 SAL records&n;&t; *     (now we can estimate the maxinum of section in a record.)&n;&t; */
multiline_comment|/* - 1 - */
id|rec_max_size
op_assign
id|sal_rec_max
suffix:semicolon
multiline_comment|/* - 2 - */
id|sect_min_size
op_assign
id|sal_log_sect_min_sizes
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
r_sizeof
id|sal_log_sect_min_sizes
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sect_min_size
OG
id|sal_log_sect_min_sizes
(braket
id|i
)braket
)paren
id|sect_min_size
op_assign
id|sal_log_sect_min_sizes
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* - 3 - */
id|slidx_pool.max_idx
op_assign
(paren
id|rec_max_size
op_div
id|sect_min_size
)paren
op_star
l_int|2
op_plus
l_int|1
suffix:semicolon
id|slidx_pool.buffer
op_assign
(paren
id|slidx_list_t
op_star
)paren
id|kmalloc
c_func
(paren
id|slidx_pool.max_idx
op_star
r_sizeof
(paren
id|slidx_list_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_return
id|slidx_pool.buffer
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * Recovery functions                                                        *&n; *****************************************************************************/
multiline_comment|/**&n; * is_mca_global - Check whether this MCA is global or not&n; * @peidx:&t;pointer of index of processor error section&n; * @pbci:&t;pointer to pal_bus_check_info_t&n; *&n; * Return value:&n; *&t;MCA_IS_LOCAL / MCA_IS_GLOBAL&n; */
r_static
id|mca_type_t
DECL|function|is_mca_global
id|is_mca_global
c_func
(paren
id|peidx_table_t
op_star
id|peidx
comma
id|pal_bus_check_info_t
op_star
id|pbci
)paren
(brace
id|pal_processor_state_info_t
op_star
id|psp
op_assign
(paren
id|pal_processor_state_info_t
op_star
)paren
id|peidx_psp
c_func
(paren
id|peidx
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * PAL can request a rendezvous, if the MCA has a global scope.&n;&t; * If &quot;rz_always&quot; flag is set, SAL requests MCA rendezvous &n;&t; * in spite of global MCA.&n;&t; * Therefore it is local MCA when rendezvous has not been requested.&n;&t; * Failed to rendezvous, the system must be down.&n;&t; */
r_switch
c_cond
(paren
id|sal_to_os_handoff_state-&gt;imsto_rendez_state
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* SAL rendezvous unsuccessful */
r_return
id|MCA_IS_GLOBAL
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* SAL rendezvous not required */
r_return
id|MCA_IS_LOCAL
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* SAL rendezvous successful int */
r_case
l_int|2
suffix:colon
multiline_comment|/* SAL rendezvous successful int with init */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If One or more Cache/TLB/Reg_File/Uarch_Check is here,&n;&t; * it would be a local MCA. (i.e. processor internal error)&n;&t; */
r_if
c_cond
(paren
id|psp-&gt;tc
op_logical_or
id|psp-&gt;cc
op_logical_or
id|psp-&gt;rc
op_logical_or
id|psp-&gt;uc
)paren
r_return
id|MCA_IS_LOCAL
suffix:semicolon
multiline_comment|/*&n;&t; * Bus_Check structure with Bus_Check.ib (internal bus error) flag set&n;&t; * would be a global MCA. (e.g. a system bus address parity error)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pbci
op_logical_or
id|pbci-&gt;ib
)paren
r_return
id|MCA_IS_GLOBAL
suffix:semicolon
multiline_comment|/*&n;&t; * Bus_Check structure with Bus_Check.eb (external bus error) flag set&n;&t; * could be either a local MCA or a global MCA.&n;&t; *&n;&t; * Referring Bus_Check.bsi:&n;&t; *   0: Unknown/unclassified&n;&t; *   1: BERR#&n;&t; *   2: BINIT#&n;&t; *   3: Hard Fail&n;&t; * (FIXME: Are these SGI specific or generic bsi values?)&n;&t; */
r_if
c_cond
(paren
id|pbci-&gt;eb
)paren
r_switch
c_cond
(paren
id|pbci-&gt;bsi
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* e.g. a load from poisoned memory */
r_return
id|MCA_IS_LOCAL
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_return
id|MCA_IS_GLOBAL
suffix:semicolon
)brace
r_return
id|MCA_IS_GLOBAL
suffix:semicolon
)brace
multiline_comment|/**&n; * recover_from_read_error - Try to recover the errors which type are &quot;read&quot;s.&n; * @slidx:&t;pointer of index of SAL error record&n; * @peidx:&t;pointer of index of processor error section&n; * @pbci:&t;pointer of pal_bus_check_info&n; *&n; * Return value:&n; *&t;1 on Success / 0 on Failure&n; */
r_static
r_int
DECL|function|recover_from_read_error
id|recover_from_read_error
c_func
(paren
id|slidx_table_t
op_star
id|slidx
comma
id|peidx_table_t
op_star
id|peidx
comma
id|pal_bus_check_info_t
op_star
id|pbci
)paren
(brace
id|sal_log_mod_error_info_t
op_star
id|smei
suffix:semicolon
id|pal_min_state_area_t
op_star
id|pmsa
suffix:semicolon
r_struct
id|ia64_psr
op_star
id|psr1
comma
op_star
id|psr2
suffix:semicolon
id|ia64_fptr_t
op_star
id|mca_hdlr_bh
op_assign
(paren
id|ia64_fptr_t
op_star
)paren
id|mca_handler_bhhook
suffix:semicolon
multiline_comment|/* Is target address valid? */
r_if
c_cond
(paren
op_logical_neg
id|pbci-&gt;tv
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * cpu read or memory-mapped io read&n;&t; *&n;&t; *    offending process  affected process  OS MCA do&n;&t; *     kernel mode        kernel mode       down system&n;&t; *     kernel mode        user   mode       kill the process&n;&t; *     user   mode        kernel mode       down system (*)&n;&t; *     user   mode        user   mode       kill the process&n;&t; *&n;&t; * (*) You could terminate offending user-mode process&n;&t; *    if (pbci-&gt;pv &amp;&amp; pbci-&gt;pl != 0) *and* if you sure&n;&t; *    the process not have any locks of kernel.&n;&t; */
id|psr1
op_assign
(paren
r_struct
id|ia64_psr
op_star
)paren
op_amp
(paren
id|peidx_minstate_area
c_func
(paren
id|peidx
)paren
op_member_access_from_pointer
id|pmsa_ipsr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check the privilege level of interrupted context.&n;&t; *   If it is user-mode, then terminate affected process.&n;&t; */
r_if
c_cond
(paren
id|psr1-&gt;cpl
op_ne
l_int|0
)paren
(brace
id|smei
op_assign
id|peidx_bus_check
c_func
(paren
id|peidx
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smei-&gt;valid.target_identifier
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  setup for resume to bottom half of MCA,&n;&t;&t;&t; * &quot;mca_handler_bhhook&quot;&n;&t;&t;&t; */
id|pmsa
op_assign
(paren
id|pal_min_state_area_t
op_star
)paren
(paren
id|sal_to_os_handoff_state-&gt;pal_min_state
op_or
(paren
l_int|6ul
op_lshift
l_int|61
)paren
)paren
suffix:semicolon
multiline_comment|/* pass to bhhook as 1st argument (gr8) */
id|pmsa-&gt;pmsa_gr
(braket
l_int|8
op_minus
l_int|1
)braket
op_assign
id|smei-&gt;target_identifier
suffix:semicolon
multiline_comment|/* set interrupted return address (but no use) */
id|pmsa-&gt;pmsa_br0
op_assign
id|pmsa-&gt;pmsa_iip
suffix:semicolon
multiline_comment|/* change resume address to bottom half */
id|pmsa-&gt;pmsa_iip
op_assign
id|mca_hdlr_bh-&gt;fp
suffix:semicolon
id|pmsa-&gt;pmsa_gr
(braket
l_int|1
op_minus
l_int|1
)braket
op_assign
id|mca_hdlr_bh-&gt;gp
suffix:semicolon
multiline_comment|/* set cpl with kernel mode */
id|psr2
op_assign
(paren
r_struct
id|ia64_psr
op_star
)paren
op_amp
id|pmsa-&gt;pmsa_ipsr
suffix:semicolon
id|psr2-&gt;cpl
op_assign
l_int|0
suffix:semicolon
id|psr2-&gt;ri
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * recover_from_platform_error - Recover from platform error.&n; * @slidx:&t;pointer of index of SAL error record&n; * @peidx:&t;pointer of index of processor error section&n; * @pbci:&t;pointer of pal_bus_check_info&n; *&n; * Return value:&n; *&t;1 on Success / 0 on Failure&n; */
r_static
r_int
DECL|function|recover_from_platform_error
id|recover_from_platform_error
c_func
(paren
id|slidx_table_t
op_star
id|slidx
comma
id|peidx_table_t
op_star
id|peidx
comma
id|pal_bus_check_info_t
op_star
id|pbci
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|pal_processor_state_info_t
op_star
id|psp
op_assign
(paren
id|pal_processor_state_info_t
op_star
)paren
id|peidx_psp
c_func
(paren
id|peidx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psp-&gt;bc
op_logical_and
id|pbci-&gt;eb
op_logical_and
id|pbci-&gt;bsi
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|pbci-&gt;type
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* partial read */
r_case
l_int|3
suffix:colon
multiline_comment|/* full line(cpu) read */
r_case
l_int|9
suffix:colon
multiline_comment|/* I/O space read */
id|status
op_assign
id|recover_from_read_error
c_func
(paren
id|slidx
comma
id|peidx
comma
id|pbci
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* unknown */
r_case
l_int|2
suffix:colon
multiline_comment|/* partial write */
r_case
l_int|4
suffix:colon
multiline_comment|/* full line write */
r_case
l_int|5
suffix:colon
multiline_comment|/* implicit or explicit write-back operation */
r_case
l_int|6
suffix:colon
multiline_comment|/* snoop probe */
r_case
l_int|7
suffix:colon
multiline_comment|/* incoming or outgoing ptc.g */
r_case
l_int|8
suffix:colon
multiline_comment|/* write coalescing transactions */
r_case
l_int|10
suffix:colon
multiline_comment|/* I/O space write */
r_case
l_int|11
suffix:colon
multiline_comment|/* inter-processor interrupt message(IPI) */
r_case
l_int|12
suffix:colon
multiline_comment|/* interrupt acknowledge or external task priority cycle */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * recover_from_processor_error&n; * @platform:&t;whether there are some platform error section or not&n; * @slidx:&t;pointer of index of SAL error record&n; * @peidx:&t;pointer of index of processor error section&n; * @pbci:&t;pointer of pal_bus_check_info&n; *&n; * Return value:&n; *&t;1 on Success / 0 on Failure&n; */
multiline_comment|/*&n; *  Later we try to recover when below all conditions are satisfied.&n; *   1. Only one processor error section is exist.&n; *   2. BUS_CHECK is exist and the others are not exist.(Except TLB_CHECK)&n; *   3. The entry of BUS_CHECK_INFO is 1.&n; *   4. &quot;External bus error&quot; flag is set and the others are not set.&n; */
r_static
r_int
DECL|function|recover_from_processor_error
id|recover_from_processor_error
c_func
(paren
r_int
id|platform
comma
id|slidx_table_t
op_star
id|slidx
comma
id|peidx_table_t
op_star
id|peidx
comma
id|pal_bus_check_info_t
op_star
id|pbci
)paren
(brace
id|pal_processor_state_info_t
op_star
id|psp
op_assign
(paren
id|pal_processor_state_info_t
op_star
)paren
id|peidx_psp
c_func
(paren
id|peidx
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * We cannot recover errors with other than bus_check.&n;&t; */
r_if
c_cond
(paren
id|psp-&gt;cc
op_logical_or
id|psp-&gt;rc
op_logical_or
id|psp-&gt;uc
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If there is no bus error, record is weird but we need not to recover.&n;&t; */
r_if
c_cond
(paren
id|psp-&gt;bc
op_eq
l_int|0
op_logical_or
id|pbci
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Sorry, we cannot handle so many.&n;&t; */
r_if
c_cond
(paren
id|peidx_bus_check_num
c_func
(paren
id|peidx
)paren
OG
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Well, here is only one bus error.&n;&t; */
r_if
c_cond
(paren
id|pbci-&gt;ib
op_logical_or
id|pbci-&gt;cc
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pbci-&gt;eb
op_logical_and
id|pbci-&gt;bsi
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|psp-&gt;ci
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is a local MCA and estimated as recoverble external bus error.&n;&t; * (e.g. a load from poisoned memory)&n;&t; * This means &quot;there are some platform errors&quot;.&n;&t; */
r_if
c_cond
(paren
id|platform
)paren
r_return
id|recover_from_platform_error
c_func
(paren
id|slidx
comma
id|peidx
comma
id|pbci
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * On account of strange SAL error record, we cannot recover. &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mca_try_to_recover - Try to recover from MCA&n; * @rec:&t;pointer to a SAL error record&n; *&n; * Return value:&n; *&t;1 on Success / 0 on Failure&n; */
r_static
r_int
DECL|function|mca_try_to_recover
id|mca_try_to_recover
c_func
(paren
r_void
op_star
id|rec
comma
id|ia64_mca_sal_to_os_state_t
op_star
id|sal_to_os_state
comma
id|ia64_mca_os_to_sal_state_t
op_star
id|os_to_sal_state
)paren
(brace
r_int
id|platform_err
suffix:semicolon
r_int
id|n_proc_err
suffix:semicolon
id|slidx_table_t
id|slidx
suffix:semicolon
id|peidx_table_t
id|peidx
suffix:semicolon
id|pal_bus_check_info_t
id|pbci
suffix:semicolon
multiline_comment|/* handoff state from/to mca.c */
id|sal_to_os_handoff_state
op_assign
id|sal_to_os_state
suffix:semicolon
id|os_to_sal_handoff_state
op_assign
id|os_to_sal_state
suffix:semicolon
multiline_comment|/* Make index of SAL error record */
id|platform_err
op_assign
id|mca_make_slidx
c_func
(paren
id|rec
comma
op_amp
id|slidx
)paren
suffix:semicolon
multiline_comment|/* Count processor error sections */
id|n_proc_err
op_assign
id|slidx_count
c_func
(paren
op_amp
id|slidx
comma
id|proc_err
)paren
suffix:semicolon
multiline_comment|/* Now, OS can recover when there is one processor error section */
r_if
c_cond
(paren
id|n_proc_err
OG
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n_proc_err
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Weird SAL record ... We need not to recover */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Make index of processor error section */
id|mca_make_peidx
c_func
(paren
(paren
id|sal_log_processor_info_t
op_star
)paren
id|slidx_first_entry
c_func
(paren
op_amp
id|slidx.proc_err
)paren
op_member_access_from_pointer
id|hdr
comma
op_amp
id|peidx
)paren
suffix:semicolon
multiline_comment|/* Extract Processor BUS_CHECK[0] */
op_star
(paren
(paren
id|u64
op_star
)paren
op_amp
id|pbci
)paren
op_assign
id|peidx_check_info
c_func
(paren
op_amp
id|peidx
comma
id|bus_check
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Check whether MCA is global or not */
r_if
c_cond
(paren
id|is_mca_global
c_func
(paren
op_amp
id|peidx
comma
op_amp
id|pbci
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Try to recover a processor error */
r_return
id|recover_from_processor_error
c_func
(paren
id|platform_err
comma
op_amp
id|slidx
comma
op_amp
id|peidx
comma
op_amp
id|pbci
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * =============================================================================&n; */
DECL|function|mca_external_handler_init
r_int
id|__init
id|mca_external_handler_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|init_record_index_pools
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* register external mca handlers */
r_if
c_cond
(paren
id|ia64_reg_MCA_extension
c_func
(paren
id|mca_try_to_recover
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ia64_reg_MCA_extension failed.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|slidx_pool.buffer
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mca_external_handler_exit
r_void
id|__exit
id|mca_external_handler_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* unregister external mca handlers */
id|ia64_unreg_MCA_extension
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|slidx_pool.buffer
)paren
suffix:semicolon
)brace
DECL|variable|mca_external_handler_init
id|module_init
c_func
(paren
id|mca_external_handler_init
)paren
suffix:semicolon
DECL|variable|mca_external_handler_exit
id|module_exit
c_func
(paren
id|mca_external_handler_exit
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|sal_rec_max
comma
r_int
comma
l_int|0644
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sal_rec_max
comma
l_string|&quot;Max size of SAL error record&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ia64 platform dependent mca handler driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
