multiline_comment|/*&n; * EFI Variables - efivars.c&n; *&n; * Copyright (C) 2001 Dell Computer Corporation &lt;Matt_Domsch@dell.com&gt;&n; *&n; * This code takes all variables accessible from EFI runtime and&n; *  exports them via /proc&n; *&n; * Reads to /proc/efi/vars/varname return an efi_variable_t structure.&n; * Writes to /proc/efi/vars/varname must be an efi_variable_t structure.&n; * Writes with DataSize = 0 or Attributes = 0 deletes the variable.&n; * Writes with a new value in VariableName+VendorGuid creates&n; * a new variable.&n; *&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * Changelog:&n; *&n; *  10 Feb 2004 - Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *   Provide FPSWA version number via /proc/efi/fpswa&n; *&n; *  10 Dec 2002 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   fix locking per Peter Chubb&squot;s findings&n; *&n; *  25 Mar 2002 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   move uuid_unparse() to include/asm-ia64/efi.h:efi_guid_unparse()&n; *&n; *  12 Feb 2002 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   use list_for_each_safe when deleting vars.&n; *   remove ifdef CONFIG_SMP around include &lt;linux/smp.h&gt;&n; *   v0.04 release to linux-ia64@linuxia64.org&n; *&n; *  20 April 2001 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   Moved vars from /proc/efi to /proc/efi/vars, and made&n; *   efi.c own the /proc/efi directory.&n; *   v0.03 release to linux-ia64@linuxia64.org&n; *&n; *  26 March 2001 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   At the request of Stephane, moved ownership of /proc/efi&n; *   to efi.c, and now efivars lives under /proc/efi/vars.&n; *&n; *  12 March 2001 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   Feedback received from Stephane Eranian incorporated.&n; *   efivar_write() checks copy_from_user() return value.&n; *   efivar_read/write() returns proper errno.&n; *   v0.02 release to linux-ia64@linuxia64.org&n; *&n; *  26 February 2001 - Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; *   v0.01 release to linux-ia64@linuxia64.org&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;&t;&t;/* for capable() */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &lt;asm/fpswa.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matt Domsch &lt;Matt_Domsch@Dell.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;/proc interface to EFI Variables&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|macro|EFIVARS_VERSION
mdefine_line|#define EFIVARS_VERSION &quot;0.06 2002-Dec-10&quot;
r_static
r_int
id|efivar_read
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|efivar_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; * The maximum size of VariableName + Data = 1024&n; * Therefore, it&squot;s reasonable to save that much&n; * space in each part of the structure,&n; * and we use a page for reading/writing.&n; */
DECL|struct|_efi_variable_t
r_typedef
r_struct
id|_efi_variable_t
(brace
DECL|member|VariableName
id|efi_char16_t
id|VariableName
(braket
l_int|1024
op_div
r_sizeof
(paren
id|efi_char16_t
)paren
)braket
suffix:semicolon
DECL|member|VendorGuid
id|efi_guid_t
id|VendorGuid
suffix:semicolon
DECL|member|DataSize
r_int
r_int
id|DataSize
suffix:semicolon
DECL|member|Data
id|__u8
id|Data
(braket
l_int|1024
)braket
suffix:semicolon
DECL|member|Status
id|efi_status_t
id|Status
suffix:semicolon
DECL|member|Attributes
id|__u32
id|Attributes
suffix:semicolon
DECL|typedef|efi_variable_t
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
id|efi_variable_t
suffix:semicolon
DECL|struct|_efivar_entry_t
r_typedef
r_struct
id|_efivar_entry_t
(brace
DECL|member|var
id|efi_variable_t
id|var
suffix:semicolon
DECL|member|entry
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|typedef|efivar_entry_t
)brace
id|efivar_entry_t
suffix:semicolon
multiline_comment|/*&n;  efivars_lock protects two things:&n;  1) efivar_list - adds, removals, reads, writes&n;  2) efi.[gs]et_variable() calls.&n;  It must not be held when creating proc entries or calling kmalloc.&n;  efi.get_next_variable() is only called from efivars_init(),&n;  which is protected by the BKL, so that path is safe.&n;*/
DECL|variable|efivars_lock
r_static
id|spinlock_t
id|efivars_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|efivar_list
)paren
suffix:semicolon
DECL|variable|efi_vars_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|efi_vars_dir
suffix:semicolon
DECL|macro|efivar_entry
mdefine_line|#define efivar_entry(n) list_entry(n, efivar_entry_t, list)
multiline_comment|/* Return the number of unicode characters in data */
r_static
r_int
r_int
DECL|function|utf8_strlen
id|utf8_strlen
c_func
(paren
id|efi_char16_t
op_star
id|data
comma
r_int
r_int
id|maxlength
)paren
(brace
r_int
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|data
op_increment
op_ne
l_int|0
op_logical_and
id|length
OL
id|maxlength
)paren
id|length
op_increment
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/* Return the number of bytes is the length of this string */
multiline_comment|/* Note: this is NOT the same as the number of unicode characters */
r_static
r_inline
r_int
r_int
DECL|function|utf8_strsize
id|utf8_strsize
c_func
(paren
id|efi_char16_t
op_star
id|data
comma
r_int
r_int
id|maxlength
)paren
(brace
r_return
id|utf8_strlen
c_func
(paren
id|data
comma
id|maxlength
op_div
r_sizeof
(paren
id|efi_char16_t
)paren
)paren
op_star
r_sizeof
(paren
id|efi_char16_t
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_calc_metrics
id|proc_calc_metrics
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * efivar_create_proc_entry()&n; * Requires:&n; *    variable_name_size = number of bytes required to hold&n; *                         variable_name (not counting the NULL&n; *                         character at the end.&n; *    efivars_lock is not held on entry or exit.&n; * Returns 1 on failure, 0 on success&n; */
r_static
r_int
DECL|function|efivar_create_proc_entry
id|efivar_create_proc_entry
c_func
(paren
r_int
r_int
id|variable_name_size
comma
id|efi_char16_t
op_star
id|variable_name
comma
id|efi_guid_t
op_star
id|vendor_guid
)paren
(brace
r_int
id|i
comma
id|short_name_size
op_assign
id|variable_name_size
op_div
r_sizeof
(paren
id|efi_char16_t
)paren
op_plus
l_int|38
suffix:semicolon
r_char
op_star
id|short_name
suffix:semicolon
id|efivar_entry_t
op_star
id|new_efivar
suffix:semicolon
id|short_name
op_assign
id|kmalloc
c_func
(paren
id|short_name_size
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|new_efivar
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|efivar_entry_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|short_name
op_logical_or
op_logical_neg
id|new_efivar
)paren
(brace
r_if
c_cond
(paren
id|short_name
)paren
id|kfree
c_func
(paren
id|short_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_efivar
)paren
id|kfree
c_func
(paren
id|new_efivar
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|short_name
comma
l_int|0
comma
id|short_name_size
op_plus
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_efivar
comma
l_int|0
comma
r_sizeof
(paren
id|efivar_entry_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_efivar-&gt;var.VariableName
comma
id|variable_name
comma
id|variable_name_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|new_efivar-&gt;var.VendorGuid
)paren
comma
id|vendor_guid
comma
r_sizeof
(paren
id|efi_guid_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Convert Unicode to normal chars (assume top bits are 0),&n;&t;   ala UTF-8 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|variable_name_size
op_div
r_sizeof
(paren
id|efi_char16_t
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|short_name
(braket
id|i
)braket
op_assign
id|variable_name
(braket
id|i
)braket
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/* This is ugly, but necessary to separate one vendor&squot;s&n;&t;   private variables from another&squot;s.         */
op_star
(paren
id|short_name
op_plus
id|strlen
c_func
(paren
id|short_name
)paren
)paren
op_assign
l_char|&squot;-&squot;
suffix:semicolon
id|efi_guid_unparse
c_func
(paren
id|vendor_guid
comma
id|short_name
op_plus
id|strlen
c_func
(paren
id|short_name
)paren
)paren
suffix:semicolon
multiline_comment|/* Create the entry in proc */
id|new_efivar-&gt;entry
op_assign
id|create_proc_entry
c_func
(paren
id|short_name
comma
l_int|0600
comma
id|efi_vars_dir
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|short_name
)paren
suffix:semicolon
id|short_name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_efivar-&gt;entry
)paren
r_return
l_int|1
suffix:semicolon
id|new_efivar-&gt;entry-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|new_efivar-&gt;entry-&gt;data
op_assign
id|new_efivar
suffix:semicolon
id|new_efivar-&gt;entry-&gt;read_proc
op_assign
id|efivar_read
suffix:semicolon
id|new_efivar-&gt;entry-&gt;write_proc
op_assign
id|efivar_write
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_efivar-&gt;list
comma
op_amp
id|efivar_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************&n; * efivar_read()&n; * Requires:&n; * Modifies: page&n; * Returns: number of bytes written, or -EINVAL on failure&n; ***********************************************************/
r_static
r_int
DECL|function|efivar_read
id|efivar_read
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
r_sizeof
(paren
id|efi_variable_t
)paren
suffix:semicolon
id|efivar_entry_t
op_star
id|efi_var
op_assign
id|data
suffix:semicolon
id|efi_variable_t
op_star
id|var_data
op_assign
(paren
id|efi_variable_t
op_star
)paren
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
op_logical_neg
id|data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|var_data
comma
op_amp
id|efi_var-&gt;var
comma
id|len
)paren
suffix:semicolon
id|var_data-&gt;DataSize
op_assign
l_int|1024
suffix:semicolon
id|var_data-&gt;Status
op_assign
id|efi
dot
id|get_variable
c_func
(paren
id|var_data-&gt;VariableName
comma
op_amp
id|var_data-&gt;VendorGuid
comma
op_amp
id|var_data-&gt;Attributes
comma
op_amp
id|var_data-&gt;DataSize
comma
id|var_data-&gt;Data
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
r_return
id|proc_calc_metrics
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************&n; * efivar_write()&n; * Requires: data is an efi_setvariable_t data type,&n; *           properly filled in, possibly by a call&n; *           first to efivar_read().&n; *           Caller must have CAP_SYS_ADMIN&n; * Modifies: NVRAM&n; * Returns: var_data-&gt;DataSize on success, errno on failure&n; *&n; ***********************************************************/
r_static
r_int
DECL|function|efivar_write
id|efivar_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
r_int
id|strsize1
comma
id|strsize2
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|n
suffix:semicolon
r_int
r_int
id|size
op_assign
r_sizeof
(paren
id|efi_variable_t
)paren
suffix:semicolon
id|efi_status_t
id|status
suffix:semicolon
id|efivar_entry_t
op_star
id|efivar
op_assign
id|data
comma
op_star
id|search_efivar
op_assign
l_int|NULL
suffix:semicolon
id|efi_variable_t
op_star
id|var_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|count
op_ne
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;efivars: improper struct of size 0x%lx passed.&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|var_data
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|var_data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|var_data
comma
id|buffer
comma
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|var_data
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
multiline_comment|/* Since the data ptr we&squot;ve currently got is probably for&n;&t;   a different variable find the right variable.&n;&t;   This allows any properly formatted data structure to&n;&t;   be written to any of the files in /proc/efi/vars and it will work.&n;&t;*/
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|n
comma
op_amp
id|efivar_list
)paren
(brace
id|search_efivar
op_assign
id|efivar_entry
c_func
(paren
id|pos
)paren
suffix:semicolon
id|strsize1
op_assign
id|utf8_strsize
c_func
(paren
id|search_efivar-&gt;var.VariableName
comma
l_int|1024
)paren
suffix:semicolon
id|strsize2
op_assign
id|utf8_strsize
c_func
(paren
id|var_data-&gt;VariableName
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strsize1
op_eq
id|strsize2
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
op_amp
(paren
id|search_efivar-&gt;var.VariableName
)paren
comma
id|var_data-&gt;VariableName
comma
id|strsize1
)paren
op_logical_and
op_logical_neg
id|efi_guidcmp
c_func
(paren
id|search_efivar-&gt;var.VendorGuid
comma
id|var_data-&gt;VendorGuid
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
id|efivar
op_assign
id|search_efivar
suffix:semicolon
id|status
op_assign
id|efi
dot
id|set_variable
c_func
(paren
id|var_data-&gt;VariableName
comma
op_amp
id|var_data-&gt;VendorGuid
comma
id|var_data-&gt;Attributes
comma
id|var_data-&gt;DataSize
comma
id|var_data-&gt;Data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;set_variable() failed: status=%lx&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|var_data
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|var_data-&gt;DataSize
op_logical_or
op_logical_neg
id|var_data-&gt;Attributes
)paren
(brace
multiline_comment|/* We just deleted the NVRAM variable */
id|remove_proc_entry
c_func
(paren
id|efivar-&gt;entry-&gt;name
comma
id|efi_vars_dir
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|efivar-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|efivar
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
multiline_comment|/* If this is a new variable, set up the proc entry for it. */
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|efivar_create_proc_entry
c_func
(paren
id|utf8_strsize
c_func
(paren
id|var_data-&gt;VariableName
comma
l_int|1024
)paren
comma
id|var_data-&gt;VariableName
comma
op_amp
id|var_data-&gt;VendorGuid
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|var_data
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * The EFI system table contains pointers to the SAL system table,&n; * HCDP, ACPI, SMBIOS, etc, that may be useful to applications.&n; */
r_static
id|ssize_t
DECL|function|efi_systab_read
id|efi_systab_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_void
op_star
id|data
suffix:semicolon
id|u8
op_star
id|proc_buffer
suffix:semicolon
id|ssize_t
id|size
comma
id|length
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_const
r_int
id|max_nr_entries
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* num ptrs to tables we could expose */
r_const
r_int
id|max_line_len
op_assign
l_int|80
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|efi.systab
)paren
r_return
l_int|0
suffix:semicolon
id|proc_buffer
op_assign
id|kmalloc
c_func
(paren
id|max_nr_entries
op_star
id|max_line_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|efi.mps
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;MPS=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.mps
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.acpi20
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;ACPI20=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.acpi20
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.acpi
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;ACPI=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.acpi
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.smbios
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;SMBIOS=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.smbios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.sal_systab
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;SAL=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.sal_systab
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.hcdp
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;HCDP=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.hcdp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.boot_info
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|proc_buffer
op_plus
id|length
comma
l_string|&quot;BOOTINFO=0x%lx&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|efi.boot_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|length
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|data
op_assign
id|proc_buffer
op_plus
id|file-&gt;f_pos
suffix:semicolon
id|size
op_assign
id|length
op_minus
id|file-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|data
comma
id|size
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|ppos
op_add_assign
id|size
suffix:semicolon
id|ret
op_assign
id|size
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|proc_buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|efi_systab_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|efi_systab_entry
suffix:semicolon
DECL|variable|efi_systab_fops
r_static
r_struct
id|file_operations
id|efi_systab_fops
op_assign
(brace
dot
id|read
op_assign
id|efi_systab_read
comma
)brace
suffix:semicolon
r_static
id|ssize_t
DECL|function|efi_fpswa_read
id|efi_fpswa_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|size
comma
id|length
suffix:semicolon
r_char
id|str
(braket
l_int|32
)braket
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|snprintf
c_func
(paren
id|str
comma
r_sizeof
(paren
id|str
)paren
comma
l_string|&quot;revision=%u.%u&bslash;n&quot;
comma
id|fpswa_interface-&gt;revision
op_rshift
l_int|16
comma
id|fpswa_interface-&gt;revision
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|length
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|length
)paren
r_return
l_int|0
suffix:semicolon
id|data
op_assign
id|str
op_plus
id|file-&gt;f_pos
suffix:semicolon
id|size
op_assign
id|length
op_minus
id|file-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|data
comma
id|size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|variable|efi_fpswa_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|efi_fpswa_entry
suffix:semicolon
DECL|variable|efi_fpswa_fops
r_static
r_struct
id|file_operations
id|efi_fpswa_fops
op_assign
(brace
dot
id|read
op_assign
id|efi_fpswa_read
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|efivars_init
id|efivars_init
c_func
(paren
r_void
)paren
(brace
id|efi_status_t
id|status
suffix:semicolon
id|efi_guid_t
id|vendor_guid
suffix:semicolon
id|efi_char16_t
op_star
id|variable_name
op_assign
id|kmalloc
c_func
(paren
l_int|1024
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
r_int
id|variable_name_size
op_assign
l_int|1024
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EFI Variables Facility v%s&bslash;n&quot;
comma
id|EFIVARS_VERSION
)paren
suffix:semicolon
multiline_comment|/* Since efi.c happens before procfs is available,&n;&t;   we create the directory here if it doesn&squot;t&n;&t;   already exist.  There&squot;s probably a better way&n;&t;   to do this.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|efi_dir
)paren
id|efi_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;efi&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|efi_systab_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;systab&quot;
comma
id|S_IRUSR
op_or
id|S_IRGRP
comma
id|efi_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi_systab_entry
)paren
id|efi_systab_entry-&gt;proc_fops
op_assign
op_amp
id|efi_systab_fops
suffix:semicolon
r_if
c_cond
(paren
id|fpswa_interface
)paren
(brace
id|efi_fpswa_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;fpswa&quot;
comma
id|S_IRUGO
comma
id|efi_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi_fpswa_entry
)paren
id|efi_fpswa_entry-&gt;proc_fops
op_assign
op_amp
id|efi_fpswa_fops
suffix:semicolon
)brace
id|efi_vars_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;vars&quot;
comma
id|efi_dir
)paren
suffix:semicolon
multiline_comment|/* Per EFI spec, the maximum storage allocated for both&n;&t;   the variable name and variable data is 1024 bytes.&n;&t;*/
id|memset
c_func
(paren
id|variable_name
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
r_do
(brace
id|variable_name_size
op_assign
l_int|1024
suffix:semicolon
id|status
op_assign
id|efi
dot
id|get_next_variable
c_func
(paren
op_amp
id|variable_name_size
comma
id|variable_name
comma
op_amp
id|vendor_guid
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|EFI_SUCCESS
suffix:colon
id|efivar_create_proc_entry
c_func
(paren
id|variable_name_size
comma
id|variable_name
comma
op_amp
id|vendor_guid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_NOT_FOUND
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;get_next_variable: status=%lx&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|status
op_assign
id|EFI_NOT_FOUND
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|status
op_ne
id|EFI_NOT_FOUND
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|variable_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|efivars_exit
id|efivars_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|n
suffix:semicolon
id|efivar_entry_t
op_star
id|efivar
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi_systab_entry
)paren
id|remove_proc_entry
c_func
(paren
id|efi_systab_entry-&gt;name
comma
id|efi_dir
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|n
comma
op_amp
id|efivar_list
)paren
(brace
id|efivar
op_assign
id|efivar_entry
c_func
(paren
id|pos
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|efivar-&gt;entry-&gt;name
comma
id|efi_vars_dir
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|efivar-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|efivar
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|efivars_lock
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|efi_vars_dir-&gt;name
comma
id|efi_dir
)paren
suffix:semicolon
)brace
DECL|variable|efivars_init
id|module_init
c_func
(paren
id|efivars_init
)paren
suffix:semicolon
DECL|variable|efivars_exit
id|module_exit
c_func
(paren
id|efivars_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
