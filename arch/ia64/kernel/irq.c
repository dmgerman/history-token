multiline_comment|/*&n; *&t;linux/arch/ia64/kernel/irq.c&n; *&n; *&t;Copyright (C) 1992, 1998 Linus Torvalds, Ingo Molnar&n; *&n; * This file contains the code used by various IRQ handling routines:&n; * asking for different IRQ&squot;s should be done through these routines&n; * instead of just grabbing them. Thus setups with different IRQ numbers&n; * shouldn&squot;t result in any weird surprises, and installing new handlers&n; * should be easier.&n; *&n; * Copyright (C) Ashok Raj&lt;ashok.raj@intel.com&gt;, Intel Corporation 2004&n; *&n; * 4/14/2004: Added code to handle cpu migration and do safe irq&n; *&t;&t;&t;migration without lossing interrupts for iosapic&n; *&t;&t;&t;architecture.&n; */
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
multiline_comment|/*&n; * &squot;what should we do if we get a hw irq event on an illegal vector&squot;.&n; * each architecture has to answer this themselves.&n; */
DECL|function|ack_bad_irq
r_void
id|ack_bad_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unexpected irq vector 0x%x on CPU %u!&bslash;n&quot;
comma
id|irq
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IA64_GENERIC
DECL|function|__ia64_local_vector_to_irq
r_int
r_int
id|__ia64_local_vector_to_irq
(paren
id|ia64_vector
id|vec
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|vec
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Interrupt statistics:&n; */
DECL|variable|irq_err_count
id|atomic_t
id|irq_err_count
suffix:semicolon
multiline_comment|/*&n; * /proc/interrupts printing:&n; */
DECL|function|show_interrupts
r_int
id|show_interrupts
c_func
(paren
r_struct
id|seq_file
op_star
id|p
comma
r_void
op_star
id|v
)paren
(brace
r_int
id|i
op_assign
op_star
(paren
id|loff_t
op_star
)paren
id|v
comma
id|j
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;           &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d       &quot;
comma
id|j
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|NR_IRQS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_desc
(braket
id|i
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
id|action
op_assign
id|irq_desc
(braket
id|i
)braket
dot
id|action
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_goto
id|skip
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_cpu
c_func
(paren
id|j
)paren
dot
id|irqs
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot; %14s&quot;
comma
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;  %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;, %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|skip
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_desc
(braket
id|i
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_eq
id|NR_IRQS
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;ERR: %10u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|irq_err_count
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * This is updated when the user sets irq affinity via /proc&n; */
DECL|variable|pending_irq_cpumask
r_static
id|cpumask_t
id|__cacheline_aligned
id|pending_irq_cpumask
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|variable|pending_irq_redir
r_static
r_int
r_int
id|pending_irq_redir
(braket
id|BITS_TO_LONGS
c_func
(paren
id|NR_IRQS
)paren
)braket
suffix:semicolon
DECL|variable|irq_redir
r_static
r_char
id|irq_redir
(braket
id|NR_IRQS
)braket
suffix:semicolon
singleline_comment|// = { [0 ... NR_IRQS-1] = 1 };
multiline_comment|/*&n; * Arch specific routine for deferred write to iosapic rte to reprogram&n; * intr destination.&n; */
DECL|function|proc_set_irq_affinity
r_void
id|proc_set_irq_affinity
c_func
(paren
r_int
r_int
id|irq
comma
id|cpumask_t
id|mask_val
)paren
(brace
id|pending_irq_cpumask
(braket
id|irq
)braket
op_assign
id|mask_val
suffix:semicolon
)brace
DECL|function|set_irq_affinity_info
r_void
id|set_irq_affinity_info
(paren
r_int
r_int
id|irq
comma
r_int
id|hwid
comma
r_int
id|redir
)paren
(brace
id|cpumask_t
id|mask
op_assign
id|CPU_MASK_NONE
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu_logical_id
c_func
(paren
id|hwid
)paren
comma
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
id|NR_IRQS
)paren
(brace
id|irq_affinity
(braket
id|irq
)braket
op_assign
id|mask
suffix:semicolon
id|irq_redir
(braket
id|irq
)braket
op_assign
(paren
r_char
)paren
(paren
id|redir
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
DECL|function|move_irq
r_void
id|move_irq
c_func
(paren
r_int
id|irq
)paren
(brace
multiline_comment|/* note - we hold desc-&gt;lock */
id|cpumask_t
id|tmp
suffix:semicolon
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_descp
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|redir
op_assign
id|test_bit
c_func
(paren
id|irq
comma
id|pending_irq_redir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|desc-&gt;handler-&gt;set_affinity
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|pending_irq_cpumask
(braket
id|irq
)braket
)paren
)paren
(brace
id|cpus_and
c_func
(paren
id|tmp
comma
id|pending_irq_cpumask
(braket
id|irq
)braket
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|tmp
)paren
)paren
)paren
(brace
id|desc-&gt;handler
op_member_access_from_pointer
id|set_affinity
c_func
(paren
id|irq
op_or
(paren
id|redir
ques
c_cond
id|IA64_IRQ_REDIRECTED
suffix:colon
l_int|0
)paren
comma
id|pending_irq_cpumask
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
id|cpus_clear
c_func
(paren
id|pending_irq_cpumask
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|variable|vectors_in_migration
r_int
r_int
id|vectors_in_migration
(braket
id|NR_IRQS
)braket
suffix:semicolon
multiline_comment|/*&n; * Since cpu_online_map is already updated, we just need to check for&n; * affinity that has zeros&n; */
DECL|function|migrate_irqs
r_static
r_void
id|migrate_irqs
c_func
(paren
r_void
)paren
(brace
id|cpumask_t
id|mask
suffix:semicolon
id|irq_desc_t
op_star
id|desc
suffix:semicolon
r_int
id|irq
comma
id|new_cpu
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NR_IRQS
suffix:semicolon
id|irq
op_increment
)paren
(brace
id|desc
op_assign
id|irq_descp
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No handling for now.&n;&t;&t; * TBD: Implement a disable function so we can now&n;&t;&t; * tell CPU not to respond to these local intr sources.&n;&t;&t; * such as ITV,CPEI,MCA etc.&n;&t;&t; */
r_if
c_cond
(paren
id|desc-&gt;status
op_eq
id|IRQ_PER_CPU
)paren
r_continue
suffix:semicolon
id|cpus_and
c_func
(paren
id|mask
comma
id|irq_affinity
(braket
id|irq
)braket
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|any_online_cpu
c_func
(paren
id|mask
)paren
op_eq
id|NR_CPUS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Save it for phase 2 processing&n;&t;&t;&t; */
id|vectors_in_migration
(braket
id|irq
)braket
op_assign
id|irq
suffix:semicolon
id|new_cpu
op_assign
id|any_online_cpu
c_func
(paren
id|cpu_online_map
)paren
suffix:semicolon
id|mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|new_cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Al three are essential, currently WARN_ON.. maybe panic?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|desc-&gt;handler
op_logical_and
id|desc-&gt;handler-&gt;disable
op_logical_and
id|desc-&gt;handler-&gt;enable
op_logical_and
id|desc-&gt;handler-&gt;set_affinity
)paren
(brace
id|desc-&gt;handler
op_member_access_from_pointer
id|disable
c_func
(paren
id|irq
)paren
suffix:semicolon
id|desc-&gt;handler
op_member_access_from_pointer
id|set_affinity
c_func
(paren
id|irq
comma
id|mask
)paren
suffix:semicolon
id|desc-&gt;handler
op_member_access_from_pointer
id|enable
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|WARN_ON
c_func
(paren
(paren
op_logical_neg
(paren
id|desc-&gt;handler
)paren
op_logical_or
op_logical_neg
(paren
id|desc-&gt;handler-&gt;disable
)paren
op_logical_or
op_logical_neg
(paren
id|desc-&gt;handler-&gt;enable
)paren
op_logical_or
op_logical_neg
(paren
id|desc-&gt;handler-&gt;set_affinity
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|fixup_irqs
r_void
id|fixup_irqs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|irq
suffix:semicolon
r_extern
r_void
id|ia64_process_pending_intr
c_func
(paren
r_void
)paren
suffix:semicolon
id|ia64_set_itv
c_func
(paren
l_int|1
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Phase 1: Locate irq&squot;s bound to this cpu and&n;&t; * relocate them for cpu removal.&n;&t; */
id|migrate_irqs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Phase 2: Perform interrupt processing for all entries reported in&n;&t; * local APIC.&n;&t; */
id|ia64_process_pending_intr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Phase 3: Now handle any interrupts not captured in local APIC.&n;&t; * This is to account for cases that device interrupted during the time the&n;&t; * rte was being disabled and re-programmed.&n;&t; */
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NR_IRQS
suffix:semicolon
id|irq
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vectors_in_migration
(braket
id|irq
)braket
)paren
(brace
id|vectors_in_migration
(braket
id|irq
)braket
op_assign
l_int|0
suffix:semicolon
id|__do_IRQ
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now let processor die. We do irq disable and max_xtp() to&n;&t; * ensure there is no more interrupts routed to this processor.&n;&t; * But the local timer interrupt can have 1 pending which we&n;&t; * take care in timer_interrupt().&n;&t; */
id|max_xtp
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
