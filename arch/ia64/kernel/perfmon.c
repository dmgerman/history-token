multiline_comment|/*&n; * This file implements the perfmon subsystem which is used&n; * to program the IA-64 Performance Monitoring Unit (PMU).&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; *&n; * Modifications by Stephane Eranian, Hewlett-Packard Co.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; *&n; * Copyright (C) 1999-2003  Hewlett Packard Co&n; *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *               David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt; /* for ia64_get_itc() */
macro_line|#ifdef CONFIG_PERFMON
multiline_comment|/*&n; * For PMUs which rely on the debug registers for some features, you must&n; * you must enable the following flag to activate the support for&n; * accessing the registers via the perfmonctl() interface.&n; */
macro_line|#if defined(CONFIG_ITANIUM) || defined(CONFIG_MCKINLEY)
DECL|macro|PFM_PMU_USES_DBR
mdefine_line|#define PFM_PMU_USES_DBR&t;1
macro_line|#endif
multiline_comment|/*&n; * perfmon context states&n; */
DECL|macro|PFM_CTX_DISABLED
mdefine_line|#define PFM_CTX_DISABLED&t;0
DECL|macro|PFM_CTX_ENABLED
mdefine_line|#define PFM_CTX_ENABLED&t;&t;1
multiline_comment|/*&n; * Reset register flags&n; */
DECL|macro|PFM_PMD_LONG_RESET
mdefine_line|#define PFM_PMD_LONG_RESET&t;1
DECL|macro|PFM_PMD_SHORT_RESET
mdefine_line|#define PFM_PMD_SHORT_RESET&t;2
multiline_comment|/*&n; * Misc macros and definitions&n; */
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4
DECL|macro|PMU_MAX_PMCS
mdefine_line|#define PMU_MAX_PMCS&t;&t;256
DECL|macro|PMU_MAX_PMDS
mdefine_line|#define PMU_MAX_PMDS&t;&t;256
multiline_comment|/*&n; * type of a PMU register (bitmask).&n; * bitmask structure:&n; * &t;bit0   : register implemented&n; * &t;bit1   : end marker &n; * &t;bit2-3 : reserved&n; * &t;bit4-7 : register type&n; * &t;bit8-31: reserved&n; */
DECL|macro|PFM_REG_IMPL
mdefine_line|#define PFM_REG_IMPL&t;&t;0x1 /* register implemented */
DECL|macro|PFM_REG_END
mdefine_line|#define PFM_REG_END&t;&t;0x2 /* end marker */
DECL|macro|PFM_REG_MONITOR
mdefine_line|#define PFM_REG_MONITOR&t;&t;(0x1&lt;&lt;4|PFM_REG_IMPL) /* a PMC with a pmc.pm field only */
DECL|macro|PFM_REG_COUNTING
mdefine_line|#define PFM_REG_COUNTING&t;(0x2&lt;&lt;4|PFM_REG_IMPL) /* a PMC with a pmc.pm AND pmc.oi, a PMD used as a counter */
DECL|macro|PFM_REG_CONTROL
mdefine_line|#define PFM_REG_CONTROL&t;&t;(0x3&lt;&lt;4|PFM_REG_IMPL) /* PMU control register */
DECL|macro|PFM_REG_CONFIG
mdefine_line|#define&t;PFM_REG_CONFIG&t;&t;(0x4&lt;&lt;4|PFM_REG_IMPL) /* refine configuration */
DECL|macro|PFM_REG_BUFFER
mdefine_line|#define PFM_REG_BUFFER&t; &t;(0x5&lt;&lt;4|PFM_REG_IMPL) /* PMD used as buffer */
DECL|macro|PMC_IS_LAST
mdefine_line|#define PMC_IS_LAST(i)&t;(pmu_conf.pmc_desc[i].type &amp; PFM_REG_END)
DECL|macro|PMD_IS_LAST
mdefine_line|#define PMD_IS_LAST(i)&t;(pmu_conf.pmd_desc[i].type &amp; PFM_REG_END)
DECL|macro|PFM_IS_DISABLED
mdefine_line|#define PFM_IS_DISABLED() pmu_conf.disabled
DECL|macro|PMC_OVFL_NOTIFY
mdefine_line|#define PMC_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_soft_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
DECL|macro|PFM_FL_INHERIT_MASK
mdefine_line|#define PFM_FL_INHERIT_MASK&t;(PFM_FL_INHERIT_NONE|PFM_FL_INHERIT_ONCE|PFM_FL_INHERIT_ALL)
multiline_comment|/* i assume unsigned */
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMCS &amp;&amp; (pmu_conf.pmc_desc[i].type &amp; PFM_REG_IMPL))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMDS &amp;&amp; (pmu_conf.pmd_desc[i].type &amp; PFM_REG_IMPL))
multiline_comment|/* XXX: these three assume that register i is implemented */
DECL|macro|PMD_IS_COUNTING
mdefine_line|#define PMD_IS_COUNTING(i) (pmu_conf.pmd_desc[i].type == PFM_REG_COUNTING)
DECL|macro|PMC_IS_COUNTING
mdefine_line|#define PMC_IS_COUNTING(i) (pmu_conf.pmc_desc[i].type == PFM_REG_COUNTING)
DECL|macro|PMC_IS_MONITOR
mdefine_line|#define PMC_IS_MONITOR(i)  (pmu_conf.pmc_desc[i].type == PFM_REG_MONITOR)
DECL|macro|PMC_DFL_VAL
mdefine_line|#define PMC_DFL_VAL(i)     pmu_conf.pmc_desc[i].default_value
DECL|macro|PMC_RSVD_MASK
mdefine_line|#define PMC_RSVD_MASK(i)   pmu_conf.pmc_desc[i].reserved_mask
DECL|macro|PMD_PMD_DEP
mdefine_line|#define PMD_PMD_DEP(i)&t;   pmu_conf.pmd_desc[i].dep_pmd[0]
DECL|macro|PMC_PMD_DEP
mdefine_line|#define PMC_PMD_DEP(i)&t;   pmu_conf.pmc_desc[i].dep_pmd[0]
multiline_comment|/* k assume unsigned */
DECL|macro|IBR_IS_IMPL
mdefine_line|#define IBR_IS_IMPL(k)&t;  (k&lt;pmu_conf.num_ibrs)
DECL|macro|DBR_IS_IMPL
mdefine_line|#define DBR_IS_IMPL(k)&t;  (k&lt;pmu_conf.num_dbrs)
DECL|macro|CTX_IS_ENABLED
mdefine_line|#define CTX_IS_ENABLED(c) &t;((c)-&gt;ctx_flags.state == PFM_CTX_ENABLED)
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_block == 0)
DECL|macro|CTX_INHERIT_MODE
mdefine_line|#define CTX_INHERIT_MODE(c)&t;((c)-&gt;ctx_fl_inherit)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_psb != NULL)
multiline_comment|/* XXX: does not support more than 64 PMDs */
DECL|macro|CTX_USED_PMD
mdefine_line|#define CTX_USED_PMD(ctx, mask) (ctx)-&gt;ctx_used_pmds[0] |= (mask)
DECL|macro|CTX_IS_USED_PMD
mdefine_line|#define CTX_IS_USED_PMD(ctx, c) (((ctx)-&gt;ctx_used_pmds[0] &amp; (1UL &lt;&lt; (c))) != 0UL)
DECL|macro|CTX_USED_IBR
mdefine_line|#define CTX_USED_IBR(ctx,n) &t;(ctx)-&gt;ctx_used_ibrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_DBR
mdefine_line|#define CTX_USED_DBR(ctx,n) &t;(ctx)-&gt;ctx_used_dbrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USES_DBREGS
mdefine_line|#define CTX_USES_DBREGS(ctx)&t;(((pfm_context_t *)(ctx))-&gt;ctx_fl_using_dbreg==1)
DECL|macro|LOCK_CTX
mdefine_line|#define LOCK_CTX(ctx)&t;spin_lock(&amp;(ctx)-&gt;ctx_lock)
DECL|macro|UNLOCK_CTX
mdefine_line|#define UNLOCK_CTX(ctx)&t;spin_unlock(&amp;(ctx)-&gt;ctx_lock)
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t)    do { pmu_owners[smp_processor_id()].owner = (t); } while(0)
DECL|macro|PMU_OWNER
mdefine_line|#define PMU_OWNER()&t;    pmu_owners[smp_processor_id()].owner
DECL|macro|LOCK_PFS
mdefine_line|#define LOCK_PFS()&t;    spin_lock(&amp;pfm_sessions.pfs_lock)
DECL|macro|UNLOCK_PFS
mdefine_line|#define UNLOCK_PFS()&t;    spin_unlock(&amp;pfm_sessions.pfs_lock)
DECL|macro|PFM_REG_RETFLAG_SET
mdefine_line|#define PFM_REG_RETFLAG_SET(flags, val)&t;do { flags &amp;= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)
DECL|macro|PFM_CPUINFO_CLEAR
mdefine_line|#define PFM_CPUINFO_CLEAR(v)&t;__get_cpu_var(pfm_syst_info) &amp;= ~(v)
DECL|macro|PFM_CPUINFO_SET
mdefine_line|#define PFM_CPUINFO_SET(v)&t;__get_cpu_var(pfm_syst_info) |= (v)
multiline_comment|/*&n; * debugging&n; */
DECL|macro|DBprintk
mdefine_line|#define DBprintk(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (pfm_sysctl.debug &gt;0) { printk(&quot;%s.%d: CPU%d &quot;, __FUNCTION__, __LINE__, smp_processor_id()); printk a; } &bslash;&n;&t;} while (0)
DECL|macro|DBprintk_ovfl
mdefine_line|#define DBprintk_ovfl(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (pfm_sysctl.debug &gt; 0 &amp;&amp; pfm_sysctl.debug_ovfl &gt;0) { printk(&quot;%s.%d: CPU%d &quot;, __FUNCTION__, __LINE__, smp_processor_id()); printk a; } &bslash;&n;&t;} while (0)
multiline_comment|/* &n; * Architected PMC structure&n; */
r_typedef
r_struct
(brace
DECL|member|pmc_plm
r_int
r_int
id|pmc_plm
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* privilege level mask */
DECL|member|pmc_ev
r_int
r_int
id|pmc_ev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* external visibility */
DECL|member|pmc_oi
r_int
r_int
id|pmc_oi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* overflow interrupt */
DECL|member|pmc_pm
r_int
r_int
id|pmc_pm
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* privileged monitor */
DECL|member|pmc_ig1
r_int
r_int
id|pmc_ig1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_es
r_int
r_int
id|pmc_es
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* event select */
DECL|member|pmc_ig2
r_int
r_int
id|pmc_ig2
suffix:colon
l_int|48
suffix:semicolon
multiline_comment|/* reserved */
DECL|typedef|pfm_monitor_t
)brace
id|pfm_monitor_t
suffix:semicolon
multiline_comment|/*&n; * There is one such data structure per perfmon context. It is used to describe the&n; * sampling buffer. It is to be shared among siblings whereas the pfm_context &n; * is not.&n; * Therefore we maintain a refcnt which is incremented on fork().&n; * This buffer is private to the kernel only the actual sampling buffer &n; * including its header are exposed to the user. This construct allows us to &n; * export the buffer read-write, if needed, without worrying about security &n; * problems.&n; */
DECL|struct|_pfm_smpl_buffer_desc
r_typedef
r_struct
id|_pfm_smpl_buffer_desc
(brace
DECL|member|psb_lock
id|spinlock_t
id|psb_lock
suffix:semicolon
multiline_comment|/* protection lock */
DECL|member|psb_refcnt
r_int
r_int
id|psb_refcnt
suffix:semicolon
multiline_comment|/* how many users for the buffer */
DECL|member|psb_flags
r_int
id|psb_flags
suffix:semicolon
multiline_comment|/* bitvector of flags (not yet used) */
DECL|member|psb_addr
r_void
op_star
id|psb_addr
suffix:semicolon
multiline_comment|/* points to location of first entry */
DECL|member|psb_entries
r_int
r_int
id|psb_entries
suffix:semicolon
multiline_comment|/* maximum number of entries */
DECL|member|psb_size
r_int
r_int
id|psb_size
suffix:semicolon
multiline_comment|/* aligned size of buffer */
DECL|member|psb_index
r_int
r_int
id|psb_index
suffix:semicolon
multiline_comment|/* next free entry slot XXX: must use the one in buffer */
DECL|member|psb_entry_size
r_int
r_int
id|psb_entry_size
suffix:semicolon
multiline_comment|/* size of each entry including entry header */
DECL|member|psb_hdr
id|perfmon_smpl_hdr_t
op_star
id|psb_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header */
DECL|member|psb_next
r_struct
id|_pfm_smpl_buffer_desc
op_star
id|psb_next
suffix:semicolon
multiline_comment|/* next psb, used for rvfreeing of psb_hdr */
DECL|typedef|pfm_smpl_buffer_desc_t
)brace
id|pfm_smpl_buffer_desc_t
suffix:semicolon
multiline_comment|/*&n; * psb_flags&n; */
DECL|macro|PSB_HAS_VMA
mdefine_line|#define PSB_HAS_VMA&t;0x1&t;&t;/* a virtual mapping for the buffer exists */
DECL|macro|LOCK_PSB
mdefine_line|#define LOCK_PSB(p)&t;spin_lock(&amp;(p)-&gt;psb_lock)
DECL|macro|UNLOCK_PSB
mdefine_line|#define UNLOCK_PSB(p)&t;spin_unlock(&amp;(p)-&gt;psb_lock)
multiline_comment|/*&n; * 64-bit software counter structure&n; */
r_typedef
r_struct
(brace
DECL|member|val
id|u64
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|lval
id|u64
id|lval
suffix:semicolon
multiline_comment|/* last value */
DECL|member|long_reset
id|u64
id|long_reset
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|short_reset
id|u64
id|short_reset
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|reset_pmds
id|u64
id|reset_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which other pmds to reset when this counter overflows */
DECL|member|seed
id|u64
id|seed
suffix:semicolon
multiline_comment|/* seed for random-number generator */
DECL|member|mask
id|u64
id|mask
suffix:semicolon
multiline_comment|/* mask for random-number generator */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
multiline_comment|/*&n; * perfmon context. One per process, is cloned on fork() depending on &n; * inheritance flags&n; */
r_typedef
r_struct
(brace
DECL|member|state
r_int
r_int
id|state
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0=disabled, 1=enabled */
DECL|member|inherit
r_int
r_int
id|inherit
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* inherit mode */
DECL|member|block
r_int
r_int
id|block
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* when 1, task will blocked on user notifications */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|frozen
r_int
r_int
id|frozen
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* pmu must be kept frozen on ctxsw in */
DECL|member|protected
r_int
r_int
l_int|1
suffix:semicolon
multiline_comment|/* allow access to creator of context only */
DECL|member|using_dbreg
r_int
r_int
id|using_dbreg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* using range restrictions (debug registers) */
DECL|member|excl_idle
r_int
r_int
id|excl_idle
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* exclude idle task in system wide session */
DECL|member|unsecure
r_int
r_int
id|unsecure
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* sp = 0 for non self-monitored task */
DECL|member|trap_reason
r_int
r_int
id|trap_reason
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* reason for going into pfm_block_ovfl_reset() */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|20
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
DECL|macro|PFM_TRAP_REASON_NONE
mdefine_line|#define PFM_TRAP_REASON_NONE&t;&t;0x0&t;/* default value */
DECL|macro|PFM_TRAP_REASON_BLOCKSIG
mdefine_line|#define PFM_TRAP_REASON_BLOCKSIG&t;0x1&t;/* we need to block on overflow and signal user */
DECL|macro|PFM_TRAP_REASON_SIG
mdefine_line|#define PFM_TRAP_REASON_SIG&t;&t;0x2&t;/* we simply need to signal user */
DECL|macro|PFM_TRAP_REASON_RESET
mdefine_line|#define PFM_TRAP_REASON_RESET&t;&t;0x3&t;/* we need to reset PMDs */
multiline_comment|/*&n; * perfmon context: encapsulates all the state of a monitoring session&n; * XXX: probably need to change layout&n; */
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_psb
id|pfm_smpl_buffer_desc_t
op_star
id|ctx_psb
suffix:semicolon
multiline_comment|/* sampling buffer, if any */
DECL|member|ctx_smpl_vaddr
r_int
r_int
id|ctx_smpl_vaddr
suffix:semicolon
multiline_comment|/* user level virtual address of smpl buffer */
DECL|member|ctx_lock
id|spinlock_t
id|ctx_lock
suffix:semicolon
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* block/noblock */
DECL|member|ctx_notify_task
r_struct
id|task_struct
op_star
id|ctx_notify_task
suffix:semicolon
multiline_comment|/* who to notify on overflow */
DECL|member|ctx_owner
r_struct
id|task_struct
op_star
id|ctx_owner
suffix:semicolon
multiline_comment|/* pid of creator (debug) */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers overflowed (notification) */
DECL|member|ctx_smpl_regs
r_int
r_int
id|ctx_smpl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers to record on overflow */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_used_pmds
r_int
r_int
id|ctx_used_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMD used                 */
DECL|member|ctx_reload_pmds
r_int
r_int
id|ctx_reload_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMD to reload on ctxsw   */
DECL|member|ctx_used_pmcs
r_int
r_int
id|ctx_used_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask PMC used by context         */
DECL|member|ctx_reload_pmcs
r_int
r_int
id|ctx_reload_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMC to reload on ctxsw   */
DECL|member|ctx_used_ibrs
r_int
r_int
id|ctx_used_ibrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used IBR (speedup ctxsw) */
DECL|member|ctx_used_dbrs
r_int
r_int
id|ctx_used_dbrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used DBR (speedup ctxsw) */
DECL|member|ctx_soft_pmds
id|pfm_counter_t
id|ctx_soft_pmds
(braket
id|IA64_NUM_PMD_REGS
)braket
suffix:semicolon
multiline_comment|/* XXX: size should be dynamic */
DECL|member|ctx_saved_psr
id|u64
id|ctx_saved_psr
suffix:semicolon
multiline_comment|/* copy of psr used for lazy ctxsw */
DECL|member|ctx_saved_cpus_allowed
r_int
r_int
id|ctx_saved_cpus_allowed
suffix:semicolon
multiline_comment|/* copy of the task cpus_allowed (system wide) */
DECL|member|ctx_cpu
r_int
r_int
id|ctx_cpu
suffix:semicolon
multiline_comment|/* CPU used by system wide session */
DECL|member|ctx_last_cpu
id|atomic_t
id|ctx_last_cpu
suffix:semicolon
multiline_comment|/* CPU id of current or last CPU used */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
DECL|macro|ctx_fl_inherit
mdefine_line|#define ctx_fl_inherit&t;&t;ctx_flags.inherit
DECL|macro|ctx_fl_block
mdefine_line|#define ctx_fl_block&t;&t;ctx_flags.block
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;&t;ctx_flags.system
DECL|macro|ctx_fl_frozen
mdefine_line|#define ctx_fl_frozen&t;&t;ctx_flags.frozen
DECL|macro|ctx_fl_protected
mdefine_line|#define ctx_fl_protected&t;ctx_flags.protected
DECL|macro|ctx_fl_using_dbreg
mdefine_line|#define ctx_fl_using_dbreg&t;ctx_flags.using_dbreg
DECL|macro|ctx_fl_excl_idle
mdefine_line|#define ctx_fl_excl_idle&t;ctx_flags.excl_idle
DECL|macro|ctx_fl_trap_reason
mdefine_line|#define ctx_fl_trap_reason&t;ctx_flags.trap_reason
DECL|macro|ctx_fl_unsecure
mdefine_line|#define ctx_fl_unsecure&t;&t;ctx_flags.unsecure
multiline_comment|/*&n; * global information about all sessions&n; * mostly used to synchronize between system wide and per-process&n; */
r_typedef
r_struct
(brace
DECL|member|pfs_lock
id|spinlock_t
id|pfs_lock
suffix:semicolon
multiline_comment|/* lock the structure */
DECL|member|pfs_task_sessions
r_int
r_int
id|pfs_task_sessions
suffix:semicolon
multiline_comment|/* number of per task sessions */
DECL|member|pfs_sys_sessions
r_int
r_int
id|pfs_sys_sessions
suffix:semicolon
multiline_comment|/* number of per system wide sessions */
DECL|member|pfs_sys_use_dbregs
r_int
r_int
id|pfs_sys_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a system wide session uses debug regs */
DECL|member|pfs_ptrace_use_dbregs
r_int
r_int
id|pfs_ptrace_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a process uses debug regs */
DECL|member|pfs_sys_session
r_struct
id|task_struct
op_star
id|pfs_sys_session
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* point to task owning a system-wide session */
DECL|typedef|pfm_session_t
)brace
id|pfm_session_t
suffix:semicolon
multiline_comment|/*&n; * information about a PMC or PMD.&n; * dep_pmd[]: a bitmask of dependent PMD registers &n; * dep_pmc[]: a bitmask of dependent PMC registers&n; */
r_typedef
r_struct
(brace
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|pm_pos
r_int
id|pm_pos
suffix:semicolon
DECL|member|default_value
r_int
r_int
id|default_value
suffix:semicolon
multiline_comment|/* power-on default value */
DECL|member|reserved_mask
r_int
r_int
id|reserved_mask
suffix:semicolon
multiline_comment|/* bitmask of reserved bits */
DECL|member|read_check
r_int
(paren
op_star
id|read_check
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|cnum
comma
r_int
r_int
op_star
id|val
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|write_check
r_int
(paren
op_star
id|write_check
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|cnum
comma
r_int
r_int
op_star
id|val
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|dep_pmd
r_int
r_int
id|dep_pmd
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|dep_pmc
r_int
r_int
id|dep_pmc
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|pfm_reg_desc_t
)brace
id|pfm_reg_desc_t
suffix:semicolon
multiline_comment|/* assume cnum is a valid monitor */
DECL|macro|PMC_PM
mdefine_line|#define PMC_PM(cnum, val)&t;(((val) &gt;&gt; (pmu_conf.pmc_desc[cnum].pm_pos)) &amp; 0x1)
DECL|macro|PMC_WR_FUNC
mdefine_line|#define PMC_WR_FUNC(cnum)&t;(pmu_conf.pmc_desc[cnum].write_check)
DECL|macro|PMD_WR_FUNC
mdefine_line|#define PMD_WR_FUNC(cnum)&t;(pmu_conf.pmd_desc[cnum].write_check)
DECL|macro|PMD_RD_FUNC
mdefine_line|#define PMD_RD_FUNC(cnum)&t;(pmu_conf.pmd_desc[cnum].read_check)
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristics.&n; */
r_typedef
r_struct
(brace
DECL|member|disabled
r_int
r_int
id|disabled
suffix:semicolon
multiline_comment|/* indicates if perfmon is working properly */
DECL|member|ovfl_val
r_int
r_int
id|ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters   */
DECL|member|impl_pmcs
r_int
r_int
id|impl_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMCS */
DECL|member|impl_pmds
r_int
r_int
id|impl_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMDS */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* number of implemented PMCS */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* number of implemented PMDS */
DECL|member|num_ibrs
r_int
r_int
id|num_ibrs
suffix:semicolon
multiline_comment|/* number of implemented IBRS */
DECL|member|num_dbrs
r_int
r_int
id|num_dbrs
suffix:semicolon
multiline_comment|/* number of implemented DBRS */
DECL|member|num_counters
r_int
r_int
id|num_counters
suffix:semicolon
multiline_comment|/* number of PMD/PMC counters */
DECL|member|pmc_desc
id|pfm_reg_desc_t
op_star
id|pmc_desc
suffix:semicolon
multiline_comment|/* detailed PMC register dependencies descriptions */
DECL|member|pmd_desc
id|pfm_reg_desc_t
op_star
id|pmd_desc
suffix:semicolon
multiline_comment|/* detailed PMD register dependencies descriptions */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
multiline_comment|/*&n; * structure used to pass argument to/from remote CPU &n; * using IPI to check and possibly save the PMU context on SMP systems.&n; *&n; * not used in UP kernels&n; */
r_typedef
r_struct
(brace
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
multiline_comment|/* which task we are interested in */
DECL|member|retval
r_int
id|retval
suffix:semicolon
multiline_comment|/* return value of the call: 0=you can proceed, 1=need to wait for completion */
DECL|typedef|pfm_smp_ipi_arg_t
)brace
id|pfm_smp_ipi_arg_t
suffix:semicolon
multiline_comment|/*&n; * perfmon command descriptions&n; */
r_typedef
r_struct
(brace
DECL|member|cmd_func
r_int
(paren
op_star
id|cmd_func
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|cmd_flags
r_int
id|cmd_flags
suffix:semicolon
DECL|member|cmd_narg
r_int
r_int
id|cmd_narg
suffix:semicolon
DECL|member|cmd_argsize
r_int
id|cmd_argsize
suffix:semicolon
DECL|typedef|pfm_cmd_desc_t
)brace
id|pfm_cmd_desc_t
suffix:semicolon
DECL|macro|PFM_CMD_PID
mdefine_line|#define PFM_CMD_PID&t;&t;0x1&t;/* command requires pid argument */
DECL|macro|PFM_CMD_ARG_READ
mdefine_line|#define PFM_CMD_ARG_READ&t;0x2&t;/* command must read argument(s) */
DECL|macro|PFM_CMD_ARG_RW
mdefine_line|#define PFM_CMD_ARG_RW&t;&t;0x4&t;/* command must read/write argument(s) */
DECL|macro|PFM_CMD_CTX
mdefine_line|#define PFM_CMD_CTX&t;&t;0x8&t;/* command needs a perfmon context */
DECL|macro|PFM_CMD_NOCHK
mdefine_line|#define PFM_CMD_NOCHK&t;&t;0x10&t;/* command does not need to check task&squot;s state */
DECL|macro|PFM_CMD_IDX
mdefine_line|#define PFM_CMD_IDX(cmd)&t;(cmd)
DECL|macro|PFM_CMD_IS_VALID
mdefine_line|#define PFM_CMD_IS_VALID(cmd)&t;((PFM_CMD_IDX(cmd) &gt;= 0) &amp;&amp; (PFM_CMD_IDX(cmd) &lt; PFM_CMD_COUNT) &bslash;&n;&t;&t;&t;&t;  &amp;&amp; pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_func != NULL)
DECL|macro|PFM_CMD_USE_PID
mdefine_line|#define PFM_CMD_USE_PID(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_PID) != 0)
DECL|macro|PFM_CMD_READ_ARG
mdefine_line|#define PFM_CMD_READ_ARG(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_READ) != 0)
DECL|macro|PFM_CMD_RW_ARG
mdefine_line|#define PFM_CMD_RW_ARG(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_RW) != 0)
DECL|macro|PFM_CMD_USE_CTX
mdefine_line|#define PFM_CMD_USE_CTX(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_CTX) != 0)
DECL|macro|PFM_CMD_CHK
mdefine_line|#define PFM_CMD_CHK(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_NOCHK) == 0)
DECL|macro|PFM_CMD_ARG_MANY
mdefine_line|#define PFM_CMD_ARG_MANY&t;-1 /* cannot be zero */
DECL|macro|PFM_CMD_NARG
mdefine_line|#define PFM_CMD_NARG(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_narg)
DECL|macro|PFM_CMD_ARG_SIZE
mdefine_line|#define PFM_CMD_ARG_SIZE(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_argsize)
r_typedef
r_struct
(brace
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* turn on/off debugging via syslog */
DECL|member|debug_ovfl
r_int
id|debug_ovfl
suffix:semicolon
multiline_comment|/* turn on/off debug printk in overflow handler */
DECL|member|fastctxsw
r_int
id|fastctxsw
suffix:semicolon
multiline_comment|/* turn on/off fast (unsecure) ctxsw */
DECL|typedef|pfm_sysctl_t
)brace
id|pfm_sysctl_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|pfm_spurious_ovfl_intr_count
r_int
r_int
id|pfm_spurious_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of spurious ovfl interrupts */
DECL|member|pfm_ovfl_intr_count
r_int
r_int
id|pfm_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of ovfl interrupts */
DECL|member|pfm_recorded_samples_count
r_int
r_int
id|pfm_recorded_samples_count
suffix:semicolon
DECL|member|pfm_full_smpl_buffer_count
r_int
r_int
id|pfm_full_smpl_buffer_count
suffix:semicolon
multiline_comment|/* how many times the sampling buffer was full */
DECL|member|____cacheline_aligned
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
id|____cacheline_aligned
suffix:semicolon
DECL|typedef|pfm_stats_t
)brace
id|pfm_stats_t
suffix:semicolon
multiline_comment|/*&n; * perfmon internal variables&n; */
DECL|variable|pfm_sessions
r_static
id|pfm_session_t
id|pfm_sessions
suffix:semicolon
multiline_comment|/* global sessions information */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|pfm_stats
r_static
id|pfm_stats_t
id|pfm_stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|pfm_alternate_intr_handler
r_static
id|pfm_intr_handler_desc_t
op_star
id|pfm_alternate_intr_handler
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pfm_syst_info
)paren
suffix:semicolon
multiline_comment|/* sysctl() controls */
DECL|variable|pfm_sysctl
r_static
id|pfm_sysctl_t
id|pfm_sysctl
suffix:semicolon
DECL|variable|pfm_ctl_table
r_static
id|ctl_table
id|pfm_ctl_table
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|pfm_sysctl_dir
r_static
id|ctl_table
id|pfm_sysctl_dir
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;perfmon&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_ctl_table
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_root
r_static
id|ctl_table
id|pfm_sysctl_root
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;kernel&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_sysctl_dir
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|pfm_sysctl_header
suffix:semicolon
r_static
r_void
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|variable|pfm_vm_ops
r_static
r_struct
id|vm_operations_struct
id|pfm_vm_ops
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; * keep track of task owning the PMU per CPU.&n; */
r_static
r_struct
(brace
DECL|member|owner
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
DECL|member|____cacheline_aligned
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
id|____cacheline_aligned
suffix:semicolon
DECL|variable|pmu_owners
)brace
id|pmu_owners
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; * forward declarations&n; */
r_static
r_void
id|pfm_reset_pmu
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
suffix:semicolon
macro_line|#if   defined(CONFIG_ITANIUM)
macro_line|#include &quot;perfmon_itanium.h&quot;
macro_line|#elif defined(CONFIG_MCKINLEY)
macro_line|#include &quot;perfmon_mckinley.h&quot;
macro_line|#else
macro_line|#include &quot;perfmon_generic.h&quot;
macro_line|#endif
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_pp
id|pfm_clear_psr_pp
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_pp
id|pfm_set_psr_pp
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ssm psr.pp;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_up
id|pfm_clear_psr_up
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_up
id|pfm_set_psr_up
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;sum psr.up;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_psr
id|pfm_get_psr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_l
id|pfm_set_psr_l
c_func
(paren
r_int
r_int
id|val
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|val
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_freeze_pmu
id|pfm_freeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unfreeze_pmu
id|pfm_unfreeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_read_soft_counter
id|pfm_read_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
)paren
(brace
r_return
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_write_soft_counter
id|pfm_write_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
comma
r_int
r_int
id|val
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * writing to unimplemented part is ignore, so we do not need to&n;&t; * mask off top part&n;&t; */
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates a unique (per CPU) timestamp&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_stamp
id|pfm_get_stamp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * XXX: must find something more efficient&n;&t; */
r_return
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_kvirt_to_pa
id|pfm_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
op_assign
id|ia64_tpa
c_func
(paren
id|adr
)paren
suffix:semicolon
singleline_comment|//DBprintk((&quot;kv2pa(%lx--&gt;%lx)&bslash;n&quot;, adr, pa));
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|pfm_rvmalloc
id|pfm_rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
singleline_comment|//printk(&quot;perfmon: CPU%d pfm_rvmalloc(%ld)=%p&bslash;n&quot;, smp_processor_id(), size, mem);
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|mem_map_reserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_rvfree
id|pfm_rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|size
OG
l_int|0
)paren
(brace
id|mem_map_unreserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called from mm/mmap.c:exit_mmap() only when there is a sampling buffer&n; * attached to the context AND the current task has a mapping for it, i.e., it is the original&n; * creator of the context.&n; *&n; * This function is used to remember the fact that the vma describing the sampling buffer&n; * has now been removed. It can only be called when no other tasks share the same mm context.&n; *&n; */
r_static
r_void
DECL|function|pfm_vm_close
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
(paren
id|pfm_smpl_buffer_desc_t
op_star
)paren
id|vma-&gt;vm_private_data
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: psb is null in [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add PSB to list of buffers to free on release_thread() when no more users&n;&t; *&n;&t; * This call is safe because, once the count is zero is cannot be modified anymore.&n;&t; * This is not because there is no more user of the mm context, that the sampling&n;&t; * buffer is not being used anymore outside of this task. In fact, it can still&n;&t; * be accessed from within the kernel by another task (such as the monitored task).&n;&t; *&n;&t; * Therefore, we only move the psb into the list of buffers to free when we know&n;&t; * nobody else is using it.&n;&t; * The linked list if independent of the perfmon context, because in the case of&n;&t; * multi-threaded processes, the last thread may not have been involved with&n;&t; * monitoring however it will be the one removing the vma and it should therefore&n;&t; * also remove the sampling buffer. This buffer cannot be removed until the vma&n;&t; * is removed.&n;&t; *&n;&t; * This function cannot remove the buffer from here, because exit_mmap() must first&n;&t; * complete. Given that there is no other vma related callback in the generic code,&n;&t; * we have created our own with the linked list of sampling buffers to free. The list&n;&t; * is part of the thread structure. In release_thread() we check if the list is&n;&t; * empty. If not we call into perfmon to free the buffer and psb. That is the only&n;&t; * way to ensure a safe deallocation of the sampling buffer which works when&n;&t; * the buffer is shared between distinct processes or with multi-threaded programs.&n;&t; *&n;&t; * We need to lock the psb because the refcnt test and flag manipulation must&n;&t; * looked like an atomic operation vis a vis pfm_context_exit()&n;&t; */
id|LOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;psb_refcnt
op_eq
l_int|0
)paren
(brace
id|psb-&gt;psb_next
op_assign
id|current-&gt;thread.pfm_smpl_buf_list
suffix:semicolon
id|current-&gt;thread.pfm_smpl_buf_list
op_assign
id|psb
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] add smpl @%p size %lu to smpl_buf_list psb_flags=0x%x&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
comma
id|psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] clearing psb_flags=0x%x smpl @%p size %lu&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_flags
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * decrement the number vma for the buffer&n;&t; */
id|psb-&gt;psb_flags
op_and_assign
op_complement
id|PSB_HAS_VMA
suffix:semicolon
id|UNLOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from pfm_destroy_context() and also from pfm_inherit()&n; * to explicitely remove the sampling buffer mapping from the user level address space.&n; */
r_static
r_int
DECL|function|pfm_remove_smpl_mapping
id|pfm_remove_smpl_mapping
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/*&n;&t; * some sanity checks first&n;&t; */
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
op_logical_or
id|task-&gt;mm
op_eq
l_int|NULL
op_logical_or
id|ctx-&gt;ctx_smpl_vaddr
op_eq
l_int|0
op_logical_or
id|ctx-&gt;ctx_psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: invalid context mm=%p&bslash;n&quot;
comma
id|task-&gt;mm
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|r
op_assign
id|do_munmap
c_func
(paren
id|task-&gt;mm
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: pid %d unable to unmap sampling buffer &quot;
l_string|&quot;@0x%lx size=%ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] do_unmap(0x%lx, %ld)=%d refcnt=%lu psb_flags=0x%x&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
comma
id|r
comma
id|psb-&gt;psb_refcnt
comma
id|psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|pfm_context_t
op_star
DECL|function|pfm_context_alloc
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
multiline_comment|/* allocate context descriptor */
id|ctx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pfm_context_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_context_t
)paren
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_context_free
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
id|kfree
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_remap_buffer
id|pfm_remap_buffer
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;CPU%d buf=0x%lx addr=0x%lx size=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|buf
comma
id|addr
comma
id|size
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|pfm_kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_READONLY
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * counts the number of PMDS to save per entry.&n; * This code is generic enough to accommodate more than 64 PMDS when they become available&n; */
r_static
r_int
r_int
DECL|function|pfm_smpl_entry_size
id|pfm_smpl_entry_size
c_func
(paren
r_int
r_int
op_star
id|which
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
comma
id|which
op_increment
)paren
id|res
op_add_assign
id|hweight64
c_func
(paren
op_star
id|which
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;weight=%ld&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates the sampling buffer and remaps it into caller&squot;s address space&n; */
r_static
r_int
DECL|function|pfm_smpl_buffer_alloc
id|pfm_smpl_buffer_alloc
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|which_pmds
comma
r_int
r_int
id|entries
comma
r_void
op_star
op_star
id|user_vaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
comma
id|regcount
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
multiline_comment|/* note that regcount might be 0, in this case only the header for each&n;&t; * entry will be recorded.&n;&t; */
id|regcount
op_assign
id|pfm_smpl_entry_size
c_func
(paren
id|which_pmds
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
op_plus
id|entries
op_star
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
)paren
op_le
id|entries
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;requested entries %lu is too big&bslash;n&quot;
comma
id|entries
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * 1 buffer hdr and for each entry a header + regcount PMDs to save&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
op_plus
id|entries
op_star
(paren
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling buffer size=%lu bytes&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&t;&n;&t; * Check against address space limit.&n;&t; *&n;&t; * if ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len&gt; current-&gt;rlim[RLIMIT_AS].rlim_cur) &n;&t; * &t;return -ENOMEM;&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/*&n;&t; * We do the easy to undo allocations first.&n; &t; *&n;&t; * pfm_rvmalloc(), clears the buffer, so there is no leak&n;&t; */
id|smpl_buf
op_assign
id|pfm_rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;smpl_buf @%p&bslash;n&quot;
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate sampling buffer descriptor now */
id|psb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|psb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer descriptor&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error_kmalloc
suffix:semicolon
)brace
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error_kmem
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * partially initialize the vma for the sampling buffer&n;&t; *&n;&t; * The VM_DONTCOPY flag is very important as it ensures that the mapping&n;&t; * will never be inherited for any child process (via fork()) which is always &n;&t; * what we want.&n;&t; */
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|VM_READ
op_or
id|VM_MAYREAD
op_or
id|VM_RESERVED
op_or
id|VM_DONTCOPY
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
multiline_comment|/* XXX may need to change */
id|vma-&gt;vm_ops
op_assign
op_amp
id|pfm_vm_ops
suffix:semicolon
multiline_comment|/* necesarry to get the close() callback */
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
id|psb
suffix:semicolon
multiline_comment|/* information needed by the pfm_vm_close() function */
multiline_comment|/*&n;&t; * Now we have everything we need and we can initialize&n;&t; * and connect all the data structures&n;&t; */
id|psb-&gt;psb_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|psb-&gt;psb_addr
op_assign
(paren
(paren
r_char
op_star
)paren
id|smpl_buf
)paren
op_plus
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
suffix:semicolon
multiline_comment|/* first entry */
id|psb-&gt;psb_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
id|psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
id|psb-&gt;psb_entries
op_assign
id|entries
suffix:semicolon
id|psb-&gt;psb_refcnt
op_assign
l_int|1
suffix:semicolon
id|psb-&gt;psb_flags
op_assign
id|PSB_HAS_VMA
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|psb-&gt;psb_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: will need to do cacheline alignment to avoid false sharing in SMP mode and&n;&t; * multitask monitoring.&n;&t; */
id|psb-&gt;psb_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;psb @%p entry_size=%ld hdr=%p addr=%p refcnt=%lu psb_flags=0x%x&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|psb
comma
id|psb-&gt;psb_entry_size
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_hdr
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_addr
comma
id|psb-&gt;psb_refcnt
comma
id|psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some of the fields of user visible buffer header */
id|psb-&gt;psb_hdr-&gt;hdr_version
op_assign
id|PFM_SMPL_VERSION
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_entry_size
op_assign
id|psb-&gt;psb_entry_size
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_pmds
(braket
l_int|0
)braket
op_assign
id|which_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s do the difficult operations next.&n;&t; *&n;&t; * now we atomically find some area in the address space and&n;&t; * remap the buffer in it.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* find some free area in address space, must have mmap sem held */
id|vma-&gt;vm_start
op_assign
id|get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_eq
l_int|0UL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|vma-&gt;vm_start
op_plus
id|size
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;entries=%ld aligned size=%ld, unmapped @0x%lx&bslash;n&quot;
comma
id|entries
comma
id|size
comma
id|vma-&gt;vm_start
)paren
)paren
suffix:semicolon
multiline_comment|/* can only be applied to current, need to have the mm semaphore held when called */
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
id|vma
comma
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|vma-&gt;vm_start
comma
id|size
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process, must be&n;&t; * done with mmap lock held&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* store which PMDS to record */
id|ctx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
op_assign
id|which_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* link to perfmon context */
id|ctx-&gt;ctx_psb
op_assign
id|psb
suffix:semicolon
multiline_comment|/*&n;&t; * keep track of user level virtual address &n;&t; */
id|ctx-&gt;ctx_smpl_vaddr
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|user_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|error_kmem
suffix:colon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|error_kmalloc
suffix:colon
id|pfm_rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_reserve_session
id|pfm_reserve_session
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu_mask
)paren
(brace
r_int
r_int
id|m
comma
id|undo_mask
suffix:semicolon
r_int
r_int
id|n
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
multiline_comment|/* &n;&t;&t; * cannot mix system wide and per-task sessions&n;&t;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_task_sessions
OG
l_int|0UL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;system wide not possible, %u conflicting task_sessions&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|m
op_assign
id|cpu_mask
suffix:semicolon
id|undo_mask
op_assign
l_int|0UL
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cpu_mask=0x%lx&bslash;n&quot;
comma
id|cpu_mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|m
suffix:semicolon
id|i
op_increment
comma
id|m
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_session
(braket
id|i
)braket
)paren
r_goto
id|undo
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reserving CPU%d currently on CPU%d&bslash;n&quot;
comma
id|i
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|pfm_sessions.pfs_sys_session
(braket
id|i
)braket
op_assign
id|task
suffix:semicolon
id|undo_mask
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
id|pfm_sessions.pfs_sys_sessions
op_add_assign
id|n
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_sessions
)paren
r_goto
m_abort
suffix:semicolon
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;task_sessions=%u sys_session[%d]=%d&quot;
comma
id|pfm_sessions.pfs_task_sessions
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|pfm_sessions.pfs_sys_session
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|undo
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;system wide not possible, conflicting session [%d] on CPU%d&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_session
(braket
id|i
)braket
op_member_access_from_pointer
id|pid
comma
id|i
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|undo_mask
suffix:semicolon
id|i
op_increment
comma
id|undo_mask
op_rshift_assign
l_int|1
)paren
(brace
id|pfm_sessions.pfs_sys_session
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
m_abort
suffix:colon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_unreserve_session
id|pfm_unreserve_session
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu_mask
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|m
suffix:semicolon
r_int
r_int
id|n
comma
id|i
suffix:semicolon
id|ctx
op_assign
id|task
ques
c_cond
id|task-&gt;thread.pfm_context
suffix:colon
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu_mask=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu_mask
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
id|m
op_assign
id|cpu_mask
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|m
suffix:semicolon
id|i
op_increment
comma
id|m
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|pfm_sessions.pfs_sys_session
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * would not work with perfmon+more than one bit in cpu_mask&n;&t;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: invalid release for [%d] &quot;
l_string|&quot;sys_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
)brace
id|pfm_sessions.pfs_sys_sessions
op_sub_assign
id|n
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;CPU%d sys_sessions=%u&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|pfm_sessions.pfs_sys_sessions
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_task_sessions
op_decrement
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] task_sessions=%u&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pfm_sessions.pfs_task_sessions
)paren
)paren
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
DECL|function|pfm_bad_permissions
id|pfm_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* stolen from bad_signal() */
r_return
(paren
id|current-&gt;session
op_ne
id|task-&gt;session
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;uid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;uid
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfx_is_sane
id|pfx_is_sane
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_context_t
op_star
id|pfx
)paren
(brace
r_int
r_int
id|smpl_pmds
op_assign
id|pfx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
r_int
id|cpu
suffix:semicolon
multiline_comment|/* valid signal */
multiline_comment|/* cannot send to process 1, 0 means do not notify */
r_if
c_cond
(paren
id|pfx-&gt;ctx_notify_pid
op_eq
l_int|1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid notify_pid %d&bslash;n&quot;
comma
id|pfx-&gt;ctx_notify_pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ctx_flags
op_assign
id|pfx-&gt;ctx_flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
)paren
op_eq
(paren
id|PFM_FL_INHERIT_ONCE
op_or
id|PFM_FL_INHERIT_ALL
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid inherit mask 0x%x&bslash;n&quot;
comma
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cpu_mask=0x%lx&bslash;n&quot;
comma
id|pfx-&gt;ctx_cpu_mask
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cannot block in this mode &n;&t;&t; */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode when in system wide monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * must only have one bit set in the CPU mask&n;&t;&t; */
r_if
c_cond
(paren
id|hweight64
c_func
(paren
id|pfx-&gt;ctx_cpu_mask
)paren
op_ne
l_int|1UL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid CPU mask specified&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * and it must be a valid CPU&n;&t;&t; */
id|cpu
op_assign
id|ffz
c_func
(paren
op_complement
id|pfx-&gt;ctx_cpu_mask
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|cpu
op_ne
l_int|0
)paren
(brace
macro_line|#endif
id|DBprintk
c_func
(paren
(paren
l_string|&quot;CPU%d is not online&bslash;n&quot;
comma
id|cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * check for pre-existing pinning, if conflicting reject&n;&t;&t; */
r_if
c_cond
(paren
id|task-&gt;cpus_allowed
op_ne
op_complement
l_int|0UL
op_logical_and
(paren
id|task-&gt;cpus_allowed
op_amp
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pinned on 0x%lx, mask for CPU%d &bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;cpus_allowed
comma
id|cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * must provide a target for the signal in blocking mode even when&n;&t;&t; * no counter is configured with PFM_FL_REG_OVFL_NOTIFY&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
op_logical_and
id|pfx-&gt;ctx_notify_pid
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;must have notify_pid when blocking for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
op_logical_and
id|pfx-&gt;ctx_notify_pid
op_eq
id|task-&gt;pid
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cannot notify self when blocking for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* verify validity of smpl_regs */
r_if
c_cond
(paren
(paren
id|smpl_pmds
op_amp
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
)paren
op_ne
id|smpl_pmds
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid smpl_regs 0x%lx&bslash;n&quot;
comma
id|smpl_pmds
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* probably more to add here */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_create
id|pfm_context_create
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|req
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_context_t
id|tmp
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
id|pid_t
id|notify_pid
suffix:semicolon
multiline_comment|/* a context has already been defined */
r_if
c_cond
(paren
id|ctx
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * not yet supported&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
id|pfx_is_sane
c_func
(paren
id|task
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ctx_flags
op_assign
id|tmp.ctx_flags
suffix:semicolon
id|ret
op_assign
id|pfm_reserve_session
c_func
(paren
id|task
comma
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
comma
id|tmp.ctx_cpu_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
m_abort
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* record the creator (important for inheritance) */
id|ctx-&gt;ctx_owner
op_assign
id|current
suffix:semicolon
id|notify_pid
op_assign
id|tmp.ctx_notify_pid
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_pid
op_eq
id|current-&gt;pid
)paren
(brace
id|ctx-&gt;ctx_notify_task
op_assign
id|current
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|notify_pid
op_ne
l_int|0
)paren
(brace
r_struct
id|task_struct
op_star
id|notify_task
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|notify_task
op_assign
id|find_task_by_pid
c_func
(paren
id|notify_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_task
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * check if we can send this task a signal&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|notify_task
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; &t; * make visible&n;&t;&t; &t; * must be done inside critical section&n;&t;&t; &t; *&n;&t;&t; &t; * if the initialization does not go through it is still&n;&t;&t; &t; * okay because child will do the scan for nothing which&n;&t;&t; &t; * won&squot;t hurt.&n;&t;&t; &t; */
id|task-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * will cause task to check on exit for monitored&n;&t;&t;&t; * processes that would notify it. see release_thread()&n;&t;&t;&t; * Note: the scan MUST be done in release thread, once the&n;&t;&t;&t; * task has been detached from the tasklist otherwise you are&n;&t;&t;&t; * exposed to race conditions.&n;&t;&t;&t; */
id|atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
id|ctx-&gt;ctx_notify_task
op_assign
id|notify_task
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * notification process does not exist&n;&t; */
r_if
c_cond
(paren
id|notify_pid
op_ne
l_int|0
op_logical_and
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.ctx_smpl_entries
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling entries=%lu&bslash;n&quot;
comma
id|tmp.ctx_smpl_entries
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|ctx
comma
id|tmp.ctx_smpl_regs
comma
id|tmp.ctx_smpl_entries
comma
op_amp
id|uaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|buffer_error
suffix:semicolon
id|tmp.ctx_smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
multiline_comment|/* initialization of context&squot;s flags */
id|ctx-&gt;ctx_fl_inherit
op_assign
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
suffix:semicolon
id|ctx-&gt;ctx_fl_block
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_excl_idle
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_EXCL_IDLE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_unsecure
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_UNSECURE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
multiline_comment|/*&n;&t; * setting this flag to 0 here means, that the creator or the task that the&n;&t; * context is being attached are granted access. Given that a context can only&n;&t; * be created for the calling process this, in effect only allows the creator&n;&t; * to access the context. See pfm_protect() for more.&n;&t; */
id|ctx-&gt;ctx_fl_protected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for system wide mode only (only 1 bit set) */
id|ctx-&gt;ctx_cpu
op_assign
id|ffz
c_func
(paren
op_complement
id|tmp.ctx_cpu_mask
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* SMP only, means no CPU */
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* init this semaphore to locked */
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context=%p, pid=%d notify_task=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context=%p, pid=%d flags=0x%x inherit=%d block=%d system=%d excl_idle=%d unsecure=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_inherit
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_fl_system
comma
id|ctx-&gt;ctx_fl_excl_idle
comma
id|ctx-&gt;ctx_fl_unsecure
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when no notification is required, we can make this visible at the last moment&n;&t; */
r_if
c_cond
(paren
id|notify_pid
op_eq
l_int|0
)paren
id|task-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t; * pin task to CPU and force reschedule on exit to ensure&n;&t; * that when back to user level the task runs on the designated&n;&t; * CPU.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ctx-&gt;ctx_saved_cpus_allowed
op_assign
id|task-&gt;cpus_allowed
suffix:semicolon
id|set_cpus_allowed
c_func
(paren
id|task
comma
id|tmp.ctx_cpu_mask
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] rescheduled allowed=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;cpus_allowed
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|error
suffix:colon
id|pfm_unreserve_session
c_func
(paren
id|task
comma
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
comma
id|tmp.ctx_cpu_mask
)paren
suffix:semicolon
m_abort
suffix:colon
multiline_comment|/* make sure we don&squot;t leave anything behind */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_new_counter_value
id|pfm_new_counter_value
(paren
id|pfm_counter_t
op_star
id|reg
comma
r_int
id|is_long_reset
)paren
(brace
r_int
r_int
id|val
op_assign
id|is_long_reset
ques
c_cond
id|reg-&gt;long_reset
suffix:colon
id|reg-&gt;short_reset
suffix:semicolon
r_int
r_int
id|new_seed
comma
id|old_seed
op_assign
id|reg-&gt;seed
comma
id|mask
op_assign
id|reg-&gt;mask
suffix:semicolon
r_extern
r_int
r_int
id|carta_random32
(paren
r_int
r_int
id|seed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;flags
op_amp
id|PFM_REGFL_RANDOM
)paren
(brace
id|new_seed
op_assign
id|carta_random32
c_func
(paren
id|old_seed
)paren
suffix:semicolon
id|val
op_sub_assign
(paren
id|old_seed
op_amp
id|mask
)paren
suffix:semicolon
multiline_comment|/* counter values are negative numbers! */
r_if
c_cond
(paren
(paren
id|mask
op_rshift
l_int|32
)paren
op_ne
l_int|0
)paren
multiline_comment|/* construct a full 64-bit random value: */
id|new_seed
op_or_assign
id|carta_random32
c_func
(paren
id|old_seed
op_rshift
l_int|32
)paren
op_lshift
l_int|32
suffix:semicolon
id|reg-&gt;seed
op_assign
id|new_seed
suffix:semicolon
)brace
id|reg-&gt;lval
op_assign
id|val
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_regs
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|is_long_reset
op_assign
(paren
id|flag
op_eq
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_soft_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;[%d] %s reset soft_pmd[%d]=%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/* upper part is ignored on rval */
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_soft_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;[%d] %s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmcs
id|pfm_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
comma
id|reset_pmds
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
comma
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.reg_num
suffix:semicolon
id|reg_flags
op_assign
id|tmp.reg_flags
suffix:semicolon
id|value
op_assign
id|tmp.reg_value
suffix:semicolon
id|reset_pmds
op_assign
id|tmp.reg_reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; * we reject all non implemented PMC as well&n;&t;&t; * as attempts to modify PMC[0-3] which are used&n;&t;&t; * as status registers by the PMU&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
op_logical_or
id|cnum
OL
l_int|4
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc[%u] is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A PMC used to configure monitors must be:&n;&t;&t; * &t;- system-wide session: privileged monitor&n;&t;&t; * &t;- per-task : user monitor&n;&t;&t; * any other configuration is rejected.&n;&t;&t; */
r_if
c_cond
(paren
id|PMC_IS_MONITOR
c_func
(paren
id|cnum
)paren
op_logical_or
id|PMC_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc[%u].pm=%ld&bslash;n&quot;
comma
id|cnum
comma
id|PMC_PM
c_func
(paren
id|cnum
comma
id|value
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_xor
id|PMC_PM
c_func
(paren
id|cnum
comma
id|value
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc_pm=%ld fl_system=%d&bslash;n&quot;
comma
id|PMC_PM
c_func
(paren
id|cnum
comma
id|value
)paren
comma
id|ctx-&gt;ctx_fl_system
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|PMC_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
id|pfm_monitor_t
op_star
id|p
op_assign
(paren
id|pfm_monitor_t
op_star
)paren
op_amp
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * enforce generation of overflow interrupt. Necessary on all&n;&t;&t; &t; * CPUs.&n;&t;&t; &t; */
id|p-&gt;pmc_oi
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; &t; * must have a target for the signal&n;&t;&t;&t; &t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cannot set ovfl_notify: no notify_task&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_RANDOM
)paren
id|flags
op_or_assign
id|PFM_REGFL_RANDOM
suffix:semicolon
multiline_comment|/* verify validity of reset_pmds */
r_if
c_cond
(paren
(paren
id|reset_pmds
op_amp
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
)paren
op_ne
id|reset_pmds
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid reset_pmds 0x%lx for pmc%u&bslash;n&quot;
comma
id|reset_pmds
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|reg_flags
op_amp
(paren
id|PFM_REGFL_OVFL_NOTIFY
op_or
id|PFM_REGFL_RANDOM
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cannot set ovfl_notify or random on pmc%u&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMC_WR_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ret
op_assign
id|PMC_WR_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|task
comma
id|cnum
comma
op_amp
id|value
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update register return value, abort all if problem during copy.&n;&t;&t; * we only modify the reg_flags field. no check mode is fine because&n;&t;&t; * access has been verified upfront in sys_perfmonctl().&n;&t;&t; *&n;&t;&t; * If this fails, then the software state is not modified&n;&t;&t; */
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|tmp.reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we commit the changes to the software state&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * full flag update each time a register is programmed&n;&t;&t; */
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|PMC_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
op_assign
id|reset_pmds
suffix:semicolon
multiline_comment|/* mark all PMDS to be accessed as used */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|reset_pmds
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Needed in case the user does not initialize the equivalent&n;&t;&t; * PMD. Clearing is done in reset_pmu() so there is no possible&n;&t;&t; * leak here.&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|pmu_conf.pmc_desc
(braket
id|cnum
)braket
dot
id|dep_pmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * keep copy the pmc, used for register reload&n;&t;&t; */
id|th-&gt;pmc
(braket
id|cnum
)braket
op_assign
id|value
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|value
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx flags=0x%x used_pmds=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cnum
comma
id|value
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|flags
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|tmp.reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx error %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cnum
comma
id|value
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmds
id|pfm_write_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
comma
id|hw_value
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.reg_num
suffix:semicolon
id|value
op_assign
id|tmp.reg_value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmd[%u] is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_WR_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|value
suffix:semicolon
id|ret
op_assign
id|PMD_WR_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|task
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|abort_mission
suffix:semicolon
id|value
op_assign
id|v
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hw_value
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|tmp.reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now commit changes to software state&n;&t;&t; */
multiline_comment|/* update virtualized (64bits) counter */
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|lval
op_assign
id|value
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|val
op_assign
id|value
op_amp
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
id|hw_value
op_assign
id|value
op_amp
id|pmu_conf.ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|long_reset
op_assign
id|tmp.reg_long_reset
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|short_reset
op_assign
id|tmp.reg_short_reset
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|seed
op_assign
id|tmp.reg_random_seed
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|mask
op_assign
id|tmp.reg_random_mask
suffix:semicolon
)brace
multiline_comment|/* keep track of what we use */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|pmu_conf.pmd_desc
(braket
(paren
id|cnum
)paren
)braket
dot
id|dep_pmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* mark this register as used as well */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|RDEP
c_func
(paren
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/* writes to unimplemented part is ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|hw_value
)paren
suffix:semicolon
multiline_comment|/* to go away */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%u]: value=0x%lx hw_value=0x%lx soft_pmd=0x%lx  short_reset=0x%lx &quot;
l_string|&quot;long_reset=0x%lx hw_pmd=%lx notify=%c used_pmds=0x%lx reset_pmds=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cnum
comma
id|value
comma
id|hw_value
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|val
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|short_reset
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|long_reset
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.ovfl_val
comma
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|cnum
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * for now, we have only one possibility for error&n;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we change the return value to EFAULT in case we cannot write register return code.&n;&t; * The caller first must correct this error, then a resubmission of the request will&n;&t; * eventually yield the EINVAL.&n;&t; */
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|tmp.reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx ret %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cnum
comma
id|value
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_read_pmds
id|pfm_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|val
comma
id|lval
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#if __GNUC__ &lt; 3
r_int
id|foo
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: MUST MAKE SURE WE DON&quot;T HAVE ANY PENDING OVERFLOW BEFORE READING&n;&t; * This is required when the monitoring has been stoppped by user or kernel.&n;&t; * If it is still going on, then that&squot;s fine because we a re not guaranteed&n;&t; * to return an accurate value in this case.&n;&t; */
multiline_comment|/* XXX: ctx locking may be required here */
id|DBprintk
c_func
(paren
(paren
l_string|&quot;ctx_last_cpu=%d for [%d]&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
id|me
suffix:semicolon
macro_line|#if __GNUC__ &lt; 3
id|foo
op_assign
id|__get_user
c_func
(paren
id|cnum
comma
op_amp
id|req-&gt;reg_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foo
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|foo
op_assign
id|__get_user
c_func
(paren
id|reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foo
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|cnum
comma
op_amp
id|req-&gt;reg_num
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#endif
id|lval
op_assign
l_int|0UL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we can only read the register that we use. That includes&n;&t;&t; * the one we explicitely initialize AND the one we want included&n;&t;&t; * in the sampling buffer (smpl_regs).&n;&t;&t; *&n;&t;&t; * Having this restriction allows optimization in the ctxsw routine&n;&t;&t; * without compromising security (leaks)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the task is not the current one, then we check if the&n;&t;&t; * PMU state is still in the local live register due to lazy ctxsw.&n;&t;&t; * If true, then we read directly from the registers.&n;&t;&t; */
id|me
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_eq
id|me
)paren
(brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reading pmd[%u]=0x%lx from hw&bslash;n&quot;
comma
id|cnum
comma
id|val
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|th-&gt;pmd
(braket
id|cnum
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX: need to check for overflow&n;&t;&t;&t; */
id|val
op_and_assign
id|pmu_conf.ovfl_val
suffix:semicolon
id|val
op_add_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|val
suffix:semicolon
id|lval
op_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|lval
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * execute read checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_RD_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|val
suffix:semicolon
id|ret
op_assign
id|PMD_RD_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|task
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
id|val
op_assign
id|v
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|reg_flags
comma
id|ret
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;read pmd[%u] ret=%d value=0x%lx pmc=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|ret
comma
id|val
comma
id|ia64_get_pmc
c_func
(paren
id|cnum
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update register return value, abort all if problem during copy.&n;&t;&t; * we only modify the reg_flags field. no check mode is fine because&n;&t;&t; * access has been verified upfront in sys_perfmonctl().&n;&t;&t; */
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|cnum
comma
op_amp
id|req-&gt;reg_num
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|val
comma
op_amp
id|req-&gt;reg_value
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|lval
comma
op_amp
id|req-&gt;reg_last_reset_value
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * XXX: if this fails, we stick with the original failure, flag not updated!&n;&t; */
id|__put_user
c_func
(paren
id|reg_flags
comma
op_amp
id|req-&gt;reg_flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef PFM_PMU_USES_DBR
multiline_comment|/*&n; * Only call this function when a process it trying to&n; * write the debug registers (reading is always allowed)&n; */
r_int
DECL|function|pfm_use_debug_registers
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do it only once&n;&t; */
r_if
c_cond
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Even on SMP, we do not need to use an atomic here because&n;&t; * the only way in is via ptrace() and this is possible only when the&n;&t; * process is stopped. Even in the case where the ctxsw out is not totally&n;&t; * completed by the time we come here, there is no way the &squot;stopped&squot; process&n;&t; * could be in the middle of fiddling with the pfm_write_ibr_dbr() routine.&n;&t; * So this is always safe.&n;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot allow setting breakpoints when system wide monitoring&n;&t; * sessions are using the debug registers.&n;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
OG
l_int|0
)paren
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|pfm_sessions.pfs_ptrace_use_dbregs
op_increment
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;ptrace_use_dbregs=%u  sys_use_dbregs=%u by [%d] ret = %d&bslash;n&quot;
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|task-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for every task that exits with the&n; * IA64_THREAD_DBG_VALID set. This indicates a task which was&n; * able to use the debug registers for debugging purposes via&n; * ptrace(). Therefore we know it was not using them for&n; * perfmormance monitoring, so we only decrement the number&n; * of &quot;ptraced&quot; debug register users to keep the count up to date&n; */
r_int
DECL|function|pfm_release_debug_registers
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|ret
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: invalid release for [%d] ptrace_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_ptrace_use_dbregs
op_decrement
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* PFM_PMU_USES_DBR is true */
multiline_comment|/*&n; * in case, the PMU does not use the debug registers, these two functions are nops.&n; * The first function is called from arch/ia64/kernel/ptrace.c.&n; * The second function is called from arch/ia64/kernel/process.c.&n; */
r_int
DECL|function|pfm_use_debug_registers
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pfm_release_debug_registers
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* PFM_PMU_USES_DBR */
r_static
r_int
DECL|function|pfm_restart
id|pfm_restart
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
op_star
id|sem
op_assign
op_amp
id|ctx-&gt;ctx_restart_sem
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;restarting self %d frozen=%d ovfl_regs=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_fl_frozen
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We ignore block/don&squot;t block because we never block&n;&t;&t; * for a self-monitoring process.&n;&t;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* simply unfreeze */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* restart on another task */
multiline_comment|/*&n;&t; * if blocking, then post the semaphore.&n;&t; * if non-blocking, then we ensure that the task will go into&n;&t; * pfm_overflow_must_block() before returning to user mode. &n;&t; * We cannot explicitely reset another task, it MUST always&n;&t; * be done by the task itself. This works for system wide because&n;&t; * the tool that is controlling the session is doing &quot;self-monitoring&quot;.&n;&t; *&n;&t; * XXX: what if the task never goes back to user?&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;unblocking %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|thread_info
op_star
id|info
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task
op_plus
id|IA64_TASK_SIZE
)paren
suffix:semicolon
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|1
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_RESET
suffix:semicolon
id|set_bit
c_func
(paren
id|TIF_NOTIFY_RESUME
comma
op_amp
id|info-&gt;flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * in case of non blocking mode, then it&squot;s just a matter of&n;&t; * of reseting the sampling buffer (if any) index. The PMU&n;&t; * is already active.&n;&t; */
multiline_comment|/*&n;&t; * must reset the header count first&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;resetting sampling indexes for %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_stop
id|pfm_stop
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] fl_system=%d owner=%p current=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_system
comma
id|PMU_OWNER
c_func
(paren
)paren
comma
id|current
)paren
)paren
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* simply stop monitoring but not the PMU */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* disable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
multiline_comment|/* stop monitoring */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* stop monitoring */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * clear user level psr.up&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_disable
id|pfm_disable
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring, freeze PMU, and save state in context&n;&t; * this call will clear IA64_THREAD_PM_VALID for per-task sessions.&n;&t; */
id|pfm_flush_regs
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * goes back to default behavior: no user level control&n;&t; * no need to change live psr.sp because useless at the kernel level&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;enabling psr.sp for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_flags.state
op_assign
id|PFM_CTX_DISABLED
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_destroy
id|pfm_context_destroy
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * if context was never enabled, then there is not much&n;&t; * to do&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_goto
id|skipped_stop
suffix:semicolon
multiline_comment|/*&n;&t; * Disable context: stop monitoring, flush regs to software state (useless here), &n;&t; * and freeze PMU&n;&t; * &n;&t; * The IA64_THREAD_PM_VALID is cleared by pfm_flush_regs() called from pfm_disable()&n;&t; */
id|pfm_disable
c_func
(paren
id|task
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
id|skipped_stop
suffix:colon
multiline_comment|/*&n;&t; * remove sampling buffer mapping, if any&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_vaddr
)paren
(brace
id|pfm_remove_smpl_mapping
c_func
(paren
id|task
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_vaddr
op_assign
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/* now free context and related state */
id|pfm_context_exit
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * does nothing at the moment&n; */
r_static
r_int
DECL|function|pfm_context_unprotect
id|pfm_context_unprotect
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_protect_context
id|pfm_protect_context
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context from [%d] is protected&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * from now on, only the creator of the context has access to it&n;&t; */
id|ctx-&gt;ctx_fl_protected
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * reinforce secure monitoring: cannot toggle psr.up&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_unsecure
op_eq
l_int|0
)paren
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_debug
id|pfm_debug
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mode
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|arg
suffix:semicolon
id|pfm_sysctl.debug
op_assign
id|mode
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon debugging %s&bslash;n&quot;
comma
id|pfm_sysctl.debug
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef PFM_PMU_USES_DBR
r_typedef
r_struct
(brace
DECL|member|ibr_mask
r_int
r_int
id|ibr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|ibr_plm
r_int
r_int
id|ibr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ibr_ig
r_int
r_int
id|ibr_ig
suffix:colon
l_int|3
suffix:semicolon
DECL|member|ibr_x
r_int
r_int
id|ibr_x
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|ibr_mask_reg_t
)brace
id|ibr_mask_reg_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dbr_mask
r_int
r_int
id|dbr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|dbr_plm
r_int
r_int
id|dbr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dbr_ig
r_int
r_int
id|dbr_ig
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dbr_w
r_int
r_int
id|dbr_w
suffix:colon
l_int|1
suffix:semicolon
DECL|member|dbr_r
r_int
r_int
id|dbr_r
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|dbr_mask_reg_t
)brace
id|dbr_mask_reg_t
suffix:semicolon
r_typedef
r_union
(brace
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
DECL|member|ibr
id|ibr_mask_reg_t
id|ibr
suffix:semicolon
DECL|member|dbr
id|dbr_mask_reg_t
id|dbr
suffix:semicolon
DECL|typedef|dbreg_t
)brace
id|dbreg_t
suffix:semicolon
r_static
r_int
DECL|function|pfm_write_ibr_dbr
id|pfm_write_ibr_dbr
c_func
(paren
r_int
id|mode
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|pfarg_dbreg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_dbreg_t
op_star
)paren
id|arg
suffix:semicolon
id|dbreg_t
id|dbreg
suffix:semicolon
r_int
r_int
id|rnum
suffix:semicolon
r_int
id|first_time
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * we do not need to check for ipsr.db because we do clear ibr.x, dbr.r, and dbr.w&n;&t; * ensuring that no real breakpoint can be installed via this call.&n;&t; */
id|first_time
op_assign
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * check for debug registers in system wide mode&n;&t; *&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|first_time
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|pfm_sessions.pfs_sys_use_dbregs
op_increment
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* we mark ourselves as owner  of the debug registers */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;system-wide setting fl_using_dbreg for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;debug registers already in use for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/* we mark ourselves as owner  of the debug registers */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;setting fl_using_dbreg for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Given debug registers cannot be used for both debugging &n;&t;&t;&t; * and performance monitoring at the same time, we reuse&n;&t;&t;&t; * the storage area to save and restore the registers on ctxsw.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|task-&gt;thread.dbr
comma
l_int|0
comma
r_sizeof
(paren
id|task-&gt;thread.dbr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|task-&gt;thread.ibr
comma
l_int|0
comma
r_sizeof
(paren
id|task-&gt;thread.ibr
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] clearing ibrs,dbrs&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * clear hardware registers to make sure we don&squot;t&n;&t; &t; * pick up stale state. &n;&t;&t; *&n;&t;&t; * for a system wide session, we do not use&n;&t;&t; * thread.dbr, thread.ibr because this process&n;&t;&t; * never leaves the current CPU and the state&n;&t;&t; * is shared by all processes running on it&n;&t; &t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_ibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_dbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Now install the values into the registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
id|rnum
op_assign
id|tmp.dbreg_num
suffix:semicolon
id|dbreg.val
op_assign
id|tmp.dbreg_value
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_eq
l_int|0
op_logical_and
op_logical_neg
id|IBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
op_logical_or
(paren
(paren
id|mode
op_eq
l_int|1
)paren
op_logical_and
op_logical_neg
id|DBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid register %u val=0x%lx mode=%d i=%d count=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|mode
comma
id|i
comma
id|count
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * make sure we do not install enabled breakpoint&n;&t;&t; */
r_if
c_cond
(paren
id|rnum
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
id|dbreg.ibr.ibr_x
op_assign
l_int|0
suffix:semicolon
r_else
id|dbreg.dbr.dbr_r
op_assign
id|dbreg.dbr.dbr_w
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * clear return flags and copy back to user&n;&t;&t; *&n;&t;&t; * XXX: fix once EAGAIN is implemented&n;&t;&t; */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.dbreg_flags
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Debug registers, just like PMC, can only be modified&n;&t;&t; * by a kernel call. Moreover, perfmon() access to those&n;&t;&t; * registers are centralized in this routine. The hardware&n;&t;&t; * does not modify the value of these registers, therefore,&n;&t;&t; * if we save them as they are written, we can avoid having&n;&t;&t; * to save them on context switch out. This is made possible&n;&t;&t; * by the fact that when perfmon uses debug registers, ptrace()&n;&t;&t; * won&squot;t be able to modify them concurrently.&n;&t;&t; */
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
(brace
id|CTX_USED_IBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
id|ia64_set_ibr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|thread-&gt;ibr
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;write ibr%u=0x%lx used_ibrs=0x%lx&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CTX_USED_DBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
id|ia64_set_dbr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|thread-&gt;dbr
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;write dbr%u=0x%lx used_dbrs=0x%lx&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * in case it was our first attempt, we undo the global modifications&n;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * install error return flag&n;&t; */
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EFAULT
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX: for now we can only come here on EINVAL&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.dbreg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|tmp.dbreg_flags
comma
op_amp
id|req-&gt;dbreg_flags
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_ibrs
id|pfm_write_ibrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|pfm_write_ibr_dbr
c_func
(paren
l_int|0
comma
id|task
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_dbrs
id|pfm_write_dbrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|pfm_write_ibr_dbr
c_func
(paren
l_int|1
comma
id|task
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
macro_line|#endif /* PFM_PMU_USES_DBR */
r_static
r_int
DECL|function|pfm_get_features
id|pfm_get_features
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_features_t
id|tmp
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.ft_version
op_assign
id|PFM_VERSION
suffix:semicolon
id|tmp.ft_smpl_version
op_assign
id|PFM_SMPL_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_start
id|pfm_start
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] fl_system=%d owner=%p current=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_system
comma
id|PMU_OWNER
c_func
(paren
)paren
comma
id|current
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|task
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: pfm_start task [%d] not pmu owner&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
multiline_comment|/* set user level psr.pp */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start monitoring at kernel level */
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: pfm_start task flag not set for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* set user level psr.up */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start monitoring at kernel level */
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_enable
id|pfm_enable
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|me
suffix:semicolon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|me
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure we&squot;re not migrated or preempted */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|current
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* reset all registers to stable quiet state */
id|pfm_reset_pmu
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* make sure nothing starts */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to make sure! */
multiline_comment|/* make sure monitoring is stopped */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_excl_idle
)paren
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * needed in case the task was a passive task during&n;&t;&t; * a system wide session and now wants to have its own&n;&t;&t; * session&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to make sure! */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure monitoring is stopped */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;clearing psr.sp for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* allow user level control  */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PMU state will be saved/restored on ctxsw */
id|task-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
id|SET_PMU_OWNER
c_func
(paren
id|task
)paren
suffix:semicolon
id|ctx-&gt;ctx_flags.state
op_assign
id|PFM_CTX_ENABLED
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
id|me
)paren
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_pmc_reset
id|pfm_get_pmc_reset
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.reg_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
id|tmp.reg_value
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc_reset_val pmc[%u]=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|tmp.reg_value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * functions MUST be listed in the increasing order of their index (see permfon.h)&n; */
DECL|variable|pfm_cmd_tab
r_static
id|pfm_cmd_desc_t
id|pfm_cmd_tab
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|PFM_CMD_COUNT
mdefine_line|#define PFM_CMD_COUNT&t;(sizeof(pfm_cmd_tab)/sizeof(pfm_cmd_desc_t))
r_static
r_int
DECL|function|check_task_state
id|check_task_state
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* We must wait until the state has been completely&n;&t; * saved. There can be situations where the reader arrives before&n;&t; * after the task is marked as STOPPED but before pfm_save_regs()&n;&t; * is completed.&n;&t; */
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;before wait_task_inactive [%d] state %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
id|wait_task_inactive
c_func
(paren
id|task
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;after wait_task_inactive [%d] state %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;warning [%d] not in stable state %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
id|pid_t
id|pid
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
op_assign
id|current
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_int
id|ret
comma
id|narg
suffix:semicolon
multiline_comment|/* &n;&t; * reject any call if perfmon was disabled at initialization time&n;&t; */
r_if
c_cond
(paren
id|PFM_IS_DISABLED
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cmd=%d idx=%d valid=%d narg=0x%x&bslash;n&quot;
comma
id|cmd
comma
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* ingore arguments when command has none */
id|narg
op_assign
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|narg
op_eq
id|PFM_CMD_ARG_MANY
op_logical_and
id|count
op_eq
l_int|0
)paren
op_logical_or
(paren
id|narg
OG
l_int|0
op_logical_and
id|narg
op_ne
id|count
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sz
op_assign
id|PFM_CMD_ARG_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_READ_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
id|sz
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_RW_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
id|sz
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_USE_PID
c_func
(paren
id|cmd
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * XXX: may need to fine tune this one&n;&t;&t; */
r_if
c_cond
(paren
id|pid
OL
l_int|2
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|task
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
)paren
id|get_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|abort_call
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|task
)paren
)paren
r_goto
id|abort_call
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_CHK
c_func
(paren
id|cmd
)paren
)paren
(brace
id|ret
op_assign
id|check_task_state
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|abort_call
suffix:semicolon
)brace
)brace
)brace
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_USE_CTX
c_func
(paren
id|cmd
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_call
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t;&t;* we only grant access to the context if:&n;&t;&t;* &t;- the caller is the creator of the context (ctx_owner)&n;&t;&t;*  OR   - the context is attached to the caller AND The context IS NOT &n;&t;&t;*  &t;  in protected mode&n;&t;&t;*/
r_if
c_cond
(paren
id|ctx-&gt;ctx_owner
op_ne
id|current
op_logical_and
(paren
id|ctx-&gt;ctx_fl_protected
op_logical_or
id|task
op_ne
id|current
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context protected, no access for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_call
suffix:semicolon
)brace
)brace
id|ret
op_assign
(paren
op_star
id|pfm_cmd_tab
(braket
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
)braket
dot
id|cmd_func
)paren
(paren
id|task
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|abort_call
suffix:colon
r_if
c_cond
(paren
id|task
op_logical_and
id|task
op_ne
id|current
)paren
id|put_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * send SIGPROF to register task, must be invoked when it&n; * is safe to send a signal, e.g., not holding any runqueue&n; * related locks.&n; */
r_static
r_int
DECL|function|pfm_notify_user
id|pfm_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] no notifier&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|current-&gt;pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_signo
op_assign
id|SIGPROF
suffix:semicolon
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
id|si.si_pfm_ovfl
(braket
l_int|0
)braket
op_assign
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * when the target of the signal is not ourself, we have to be more&n;&t; * careful. The notify_task may being cleared by the target task itself&n;&t; * in release_thread(). We must ensure mutual exclusion here such that&n;&t; * the signal is delivered (even to a dying task) safely.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
multiline_comment|/*&n;&t;&t; * grab the notification lock for this task&n;&t;&t; * This guarantees that the sequence: test + send_signal&n;&t;&t; * is atomic with regards to the ctx_notify_task field.&n;&t;&t; *&n;&t;&t; * We need a spinlock and not just an atomic variable for this.&n;&t;&t; *&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now notify_task cannot be modified until we&squot;re done&n;&t;&t; * if NULL, they it got modified while we were in the handler&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve lost the notified task, then we will run&n;&t;&t;&t; * to completion wbut keep the PMU frozen. Results&n;&t;&t;&t; * will be incorrect anyway. We do not kill task&n;&t;&t;&t; * to leave it possible to attach perfmon context&n;&t;&t;&t; * to already running task.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;perfmon: pfm_notify_user() lost notify_task&bslash;n&quot;
)paren
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;notification task has disappeared !&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* we cannot afford to block now */
id|ctx-&gt;ctx_fl_block
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * required by send_sig_info() to make sure the target&n;&t;&t; * task does not disappear on us.&n;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * in this case, we don&squot;t stop the task, we let it go on. It will&n; &t; * necessarily go to the signal handler (if any) when it goes back to&n; &t; * user mode.&n; &t; */
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;[%d] sending notification to [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * this call is safe in an interrupt handler, so does read_lock() on tasklist_lock&n;&t; */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|SIGPROF
comma
op_amp
id|si
comma
id|ctx-&gt;ctx_notify_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now undo the protections in order&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|pfm_ovfl_block_reset
id|pfm_ovfl_block_reset
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
r_int
r_int
id|reason
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * clear the flag, to make sure we won&squot;t get here&n;&t; * again&n;&t; */
id|th-&gt;pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
id|clear_thread_flag
c_func
(paren
id|TIF_NOTIFY_RESUME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do some sanity checks first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * extract reason for being here and clear&n;&t; */
id|reason
op_assign
id|ctx-&gt;ctx_fl_trap_reason
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] reason=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|reason
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * just here for a reset (non-blocking context only)&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|PFM_TRAP_REASON_RESET
)paren
r_goto
id|non_blocking
suffix:semicolon
multiline_comment|/*&n;&t; * first notify user. This can fail if notify_task has disappeared.&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|PFM_TRAP_REASON_SIG
op_logical_or
id|reason
op_eq
id|PFM_TRAP_REASON_BLOCKSIG
)paren
(brace
id|ret
op_assign
id|pfm_notify_user
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * came here just to signal (non-blocking)&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|PFM_TRAP_REASON_SIG
)paren
r_return
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] before sleeping&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] after sleeping ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|non_blocking
suffix:colon
multiline_comment|/* we reactivate on context switch */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the ovfl_sem is cleared by the restart task and this is safe because we always&n;&t;&t; * use the local reference&n;&t;&t; */
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Unlock sampling buffer and reset index atomically&n;&t;&t; * XXX: not really needed when blocking&n;&t;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* state restored, can go back to work (user mode) */
)brace
)brace
multiline_comment|/*&n; * This function will record an entry in the sampling if it is not full already.&n; * Return:&n; * &t;0 : buffer is not full (did not BECOME full: still space or was already full)&n; * &t;1 : buffer is full (recorded the last entry)&n; */
r_static
r_int
DECL|function|pfm_record_sample
id|pfm_record_sample
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_mask
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
r_int
r_int
op_star
id|e
comma
id|m
comma
id|idx
suffix:semicolon
id|perfmon_smpl_entry_t
op_star
id|h
suffix:semicolon
r_int
id|j
suffix:semicolon
id|idx
op_assign
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_index
)paren
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;recording index=%ld entries=%ld&bslash;n&quot;
comma
id|idx
op_minus
l_int|1
comma
id|psb-&gt;psb_entries
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: there is a small chance that we could run out on index before resetting&n;&t; * but index is unsigned long, so it will take some time.....&n;&t; * We use &gt; instead of == because fetch_and_add() is off by one (see below)&n;&t; *&n;&t; * This case can happen in non-blocking mode or with multiple processes.&n;&t; * For non-blocking, we need to reload and continue.&n; &t; */
r_if
c_cond
(paren
id|idx
OG
id|psb-&gt;psb_entries
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* first entry is really entry 0, not 1 caused by fetch_and_add */
id|idx
op_decrement
suffix:semicolon
id|h
op_assign
(paren
id|perfmon_smpl_entry_t
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|psb-&gt;psb_addr
)paren
op_plus
id|idx
op_star
(paren
id|psb-&gt;psb_entry_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize entry header&n;&t; */
id|h-&gt;pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|h-&gt;cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|h-&gt;last_reset_value
op_assign
id|ovfl_mask
ques
c_cond
id|ctx-&gt;ctx_soft_pmds
(braket
id|ffz
c_func
(paren
op_complement
id|ovfl_mask
)paren
)braket
dot
id|lval
suffix:colon
l_int|0UL
suffix:semicolon
id|h-&gt;ip
op_assign
id|regs
ques
c_cond
id|regs-&gt;cr_iip
op_or
(paren
(paren
id|regs-&gt;cr_ipsr
op_rshift
l_int|41
)paren
op_amp
l_int|0x3
)paren
suffix:colon
l_int|0x0UL
suffix:semicolon
id|h-&gt;regs
op_assign
id|ovfl_mask
suffix:semicolon
multiline_comment|/* which registers overflowed */
multiline_comment|/* guaranteed to monotonically increase on each cpu */
id|h-&gt;stamp
op_assign
id|pfm_get_stamp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* position for first pmd */
id|e
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * selectively store PMDs in increasing index number&n;&t; */
id|m
op_assign
id|ctx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|j
)paren
)paren
(brace
op_star
id|e
op_assign
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|e
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
multiline_comment|/* slow */
)brace
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;e=%p pmd%d =0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|e
comma
id|j
comma
op_star
id|e
)paren
)paren
suffix:semicolon
id|e
op_increment
suffix:semicolon
)brace
id|pfm_stats
(braket
id|h-&gt;cpu
)braket
dot
id|pfm_recorded_samples_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * make the new entry visible to user, needs to be atomic&n;&t; */
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;index=%ld entries=%ld hdr_count=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
comma
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * sampling buffer full ? &n;&t; */
r_if
c_cond
(paren
id|idx
op_eq
(paren
id|psb-&gt;psb_entries
op_minus
l_int|1
)paren
)paren
(brace
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;sampling buffer full&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: must reset buffer in blocking mode and lost notified&n;&t;&t; */
id|pfm_stats
(braket
id|h-&gt;cpu
)braket
dot
id|pfm_full_smpl_buffer_count
op_increment
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; * Arguments:&n; *&t;mode: 0=coming from PMU interrupt, 1=coming from ctxsw &n; *&t;&n; * Return:&n; *&t;new value of pmc[0]. if 0x0 then unfreeze, else keep frozen&n; */
r_static
r_int
r_int
DECL|function|pfm_overflow_handler
id|pfm_overflow_handler
c_func
(paren
r_int
id|mode
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|old_val
suffix:semicolon
r_int
r_int
id|ovfl_notify
op_assign
l_int|0UL
comma
id|ovfl_pmds
op_assign
l_int|0UL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * It is never safe to access the task for which the overflow interrupt is destinated&n;&t; * using the current variable as the interrupt may occur in the middle of a context switch&n;&t; * where current does not hold the task that is running yet.&n;&t; *&n;&t; * For monitoring, however, we do need to get access to the task which caused the overflow&n;&t; * to account for overflow on the counters.&n;&t; *&n;&t; * We accomplish this by maintaining a current owner of the PMU per CPU. During context&n;&t; * switch the ownership is changed in a way such that the reflected owner is always the&n;&t; * valid one, i.e. the one that caused the interrupt.&n;&t; */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: debug test&n;&t; * Don&squot;t think this could happen given upfront tests&n;&t; */
r_if
c_cond
(paren
(paren
id|t-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: Spurious overflow interrupt: process %d not &quot;
l_string|&quot;using perfmon&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: pid %d pmc0=0x%lx assumption error for freeze bit&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pmc0
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0x0
suffix:semicolon
)brace
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d iip=0x%lx, %s&quot;
l_string|&quot; mode used_pmds=0x%lx used_pmcs=0x%lx reload_pmcs=0x%lx&bslash;n&quot;
comma
id|pmc0
comma
id|task-&gt;pid
comma
(paren
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0
)paren
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;nonblocking&quot;
suffix:colon
l_string|&quot;blocking&quot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First we update the virtual counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip pmd which did not overflow */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;pmd[%d] overflowed hw_pmd=0x%lx soft_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that the pmd is not necessarily 0 at this point as qualified events&n;&t;&t; * may have happened before the PMU was frozen. The residual count is not&n;&t;&t; * taken into consideration here but will be with any read of the pmd via&n;&t;&t; * pfm_read_pmds().&n;&t;&t; */
id|old_val
op_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for overflow condition&n;&t;&t; */
r_if
c_cond
(paren
id|old_val
OG
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
(brace
id|ovfl_pmds
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
(brace
id|ovfl_notify
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
)brace
)brace
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;soft_pmd[%d].val=0x%lx old_val=0x%lx pmd=0x%lx ovfl_pmds=0x%lx ovfl_notify=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
comma
id|old_val
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.ovfl_val
comma
id|ovfl_pmds
comma
id|ovfl_notify
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for sampling buffer&n;&t; *&n;&t; * if present, record sample only when a 64-bit counter has overflowed.&n;&t; * We propagate notification ONLY when buffer becomes full.&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
op_logical_and
id|ovfl_pmds
)paren
(brace
id|ret
op_assign
id|pfm_record_sample
c_func
(paren
id|task
comma
id|ctx
comma
id|ovfl_pmds
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Sampling buffer became full&n;&t;&t;&t; * If no notication was requested, then we reset buffer index&n;&t;&t;&t; * and reset registers (done below) and resume.&n;&t;&t;&t; * If notification requested, then defer reset until pfm_restart()&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ovfl_notify
op_eq
l_int|0UL
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0UL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * sample recorded in buffer, no need to notify user&n;&t;&t;&t; */
id|ovfl_notify
op_assign
l_int|0UL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * No overflow requiring a user level notification&n;&t; */
r_if
c_cond
(paren
id|ovfl_notify
op_eq
l_int|0UL
)paren
(brace
r_if
c_cond
(paren
id|ovfl_pmds
)paren
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|ovfl_pmds
comma
id|PFM_PMD_SHORT_RESET
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0x0UL
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * keep track of what to reset when unblocking &n;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;block=%d notify [%d] current [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_notify_task
ques
c_cond
id|ctx-&gt;ctx_notify_task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * ctx_notify_task could already be NULL, checked in pfm_notify_user() &n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_notify_task
op_ne
id|task
)paren
(brace
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_BLOCKSIG
suffix:semicolon
)brace
r_else
(brace
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_SIG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we cannot block in system wide mode and we do not go&n;&t; * through the PMU ctxsw code. Therefore we can generate&n;&t; * the notification here. In system wide mode, the current&n;&t; * task maybe different from the task controlling the session&n;&t; * on this CPU, therefore owner can be different from current.&n;&t; *&n;&t; * In per-process mode, this function gets called from &n;&t; * the interrupt handler or pfm_load_regs(). The mode argument&n;&t; * tells where we are coming from. When coming from the interrupt&n;&t; * handler, it is safe to notify (send signal) right here because&n;&t; * we do not hold any runqueue locks needed by send_sig_info(). &n;&t; *&n;&t; * However when coming from ctxsw, we cannot send the signal here.&n;&t; * It must be deferred until we are sure we do not hold any runqueue&n;&t; * related locks. The current task maybe different from the owner&n;&t; * only in UP mode. The deferral is implemented using the &n;&t; * TIF_NOTIFY_RESUME mechanism. In this case, the pending work&n;&t; * is checked when the task is about to leave the kernel (see&n;&t; * entry.S). As of this version of perfmon, a kernel only&n;&t; * task cannot be monitored in per-process mode. Therefore,&n;&t; * when this function gets called from pfm_load_regs(), we know&n;&t; * we have a user level task which will eventually either exit&n;&t; * or leave the kernel, and thereby go through the checkpoint&n;&t; * for TIF_*.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_or
id|mode
op_eq
l_int|0
)paren
(brace
id|pfm_notify_user
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
)brace
r_else
(brace
r_struct
id|thread_info
op_star
id|info
suffix:semicolon
multiline_comment|/*&n;&t;&t; * given that TIF_NOTIFY_RESUME is not specific to&n;&t;&t; * perfmon, we need to have a second level check to&n;&t;&t; * verify the source of the notification.&n;&t;&t; */
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * when coming from ctxsw, current still points to the&n;&t;&t; * previous task, therefore we must work with task and not current.&n;&t;&t; */
id|info
op_assign
(paren
(paren
r_struct
id|thread_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task
op_plus
id|IA64_TASK_SIZE
)paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TIF_NOTIFY_RESUME
comma
op_amp
id|info-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * keep the PMU frozen until either pfm_restart() or &n;&t; * task completes (non-blocking or notify_task gone).&n;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|1
suffix:semicolon
id|DBprintk_ovfl
c_func
(paren
(paren
l_string|&quot;current [%d] owner [%d] mode=%d return pmc0=0x%x must_block=%ld reason=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|PMU_OWNER
c_func
(paren
)paren
ques
c_cond
id|PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
comma
id|mode
comma
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
comma
id|t-&gt;pfm_ovfl_block_reset
comma
id|ctx-&gt;ctx_fl_trap_reason
)paren
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0x1UL
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_interrupt_handler
id|pfm_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|pfm_stats
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|pfm_ovfl_intr_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * if an alternate handler is registered, just bypass the default one&n;&t; */
r_if
c_cond
(paren
id|pfm_alternate_intr_handler
)paren
(brace
(paren
op_star
id|pfm_alternate_intr_handler-&gt;handler
)paren
(paren
id|irq
comma
id|arg
comma
id|regs
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * srlz.d done before arriving here&n;&t; *&n;&t; * This is slow&n;&t; */
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PM[0].bit[63-1] is set, then PMC[0].fr = 1&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
op_complement
l_int|0x1UL
)paren
op_ne
l_int|0UL
op_logical_and
(paren
id|task
op_assign
id|PMU_OWNER
c_func
(paren
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* &n;&t;&t; * we assume that pmc0.fr is always set here&n;&t;&t; */
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: Spurious overflow interrupt: process %d has &quot;
l_string|&quot;no PFM context&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * assume PMC[0].fr = 1 at this point &n;&t;&t; */
id|pmc0
op_assign
id|pfm_overflow_handler
c_func
(paren
l_int|0
comma
id|task
comma
id|ctx
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we can only update pmc0 when the overflow&n;&t;&t; * is for the current context or we are in system&n;&t;&t; * wide mode. In UP (per-task) the current&n;&t;&t; * task may not be the one owning the PMU,&n;&t;&t; * same thing for system-wide.&n;&t;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * We always clear the overflow status bits and either unfreeze&n;&t;&t; &t; * or keep the PMU frozen.&n;&t;&t; &t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
id|pmc0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|task-&gt;thread.pmc
(braket
l_int|0
)braket
op_assign
id|pmc0
suffix:semicolon
)brace
)brace
r_else
(brace
id|pfm_stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|pfm_spurious_ovfl_intr_count
op_increment
suffix:semicolon
)brace
id|put_cpu_no_resched
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|pfm_proc_info
id|pfm_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;fastctxsw              : %s&bslash;n&quot;
comma
id|pfm_sysctl.fastctxsw
OG
l_int|0
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;ovfl_mask              : 0x%lx&bslash;n&quot;
comma
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d overflow intrs   : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d spurious intrs   : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_spurious_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d recorded samples : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_recorded_samples_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d smpl buffer full : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_full_smpl_buffer_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d syst_wide        : %d&bslash;n&quot;
comma
id|i
comma
id|per_cpu
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_SYST_WIDE
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d dcr_pp           : %d&bslash;n&quot;
comma
id|i
comma
id|per_cpu
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d exclude idle     : %d&bslash;n&quot;
comma
id|i
comma
id|per_cpu
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_EXCL_IDLE
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d owner            : %d&bslash;n&quot;
comma
id|i
comma
id|pmu_owners
(braket
id|i
)braket
dot
id|owner
ques
c_cond
id|pmu_owners
(braket
id|i
)braket
dot
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;proc_sessions          : %u&bslash;n&quot;
l_string|&quot;sys_sessions           : %u&bslash;n&quot;
l_string|&quot;sys_use_dbregs         : %u&bslash;n&quot;
l_string|&quot;ptrace_use_dbregs      : %u&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/* /proc interface, for debug only */
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|pfm_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * we come here as soon as PFM_CPUINFO_SYST_WIDE is set. This happens&n; * during pfm_enable() hence before pfm_start(). We cannot assume monitoring&n; * is active or inactive based on mode. We must rely on the value in &n; * cpu_data(i)-&gt;pfm_syst_info&n; */
r_void
DECL|function|pfm_syst_wide_update_task
id|pfm_syst_wide_update_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|info
comma
r_int
id|is_ctxswin
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|dcr
suffix:semicolon
r_int
r_int
id|dcr_pp
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|dcr_pp
op_assign
id|info
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * pid 0 is guaranteed to be the idle task. There is one such task with pid 0 &n;&t; * on every CPU, so we can rely on the pid to identify the idle task.&n;&t; */
r_if
c_cond
(paren
(paren
id|info
op_amp
id|PFM_CPUINFO_EXCL_IDLE
)paren
op_eq
l_int|0
op_logical_or
id|task-&gt;pid
)paren
(brace
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|task
op_plus
id|IA64_STK_OFFSET
)paren
suffix:semicolon
id|regs
op_decrement
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|is_ctxswin
ques
c_cond
id|dcr_pp
suffix:colon
l_int|0
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if monitoring has started&n;&t; */
r_if
c_cond
(paren
id|dcr_pp
)paren
(brace
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * context switching in? &n;&t;&t; */
r_if
c_cond
(paren
id|is_ctxswin
)paren
(brace
multiline_comment|/* mask monitoring for the idle task */
id|ia64_set_dcr
c_func
(paren
id|dcr
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * context switching out&n;&t;&t; * restore monitoring for next task &n;&t;&t; *&n;&t;&t; * Due to inlining this odd if-then-else construction generates &n;&t;&t; * better code.&n;&t;&t; */
id|ia64_set_dcr
c_func
(paren
id|dcr
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|u64
id|psr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which can generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_saved_psr
op_assign
id|psr
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * We do not use a lazy scheme in SMP because&n;&t; * of the new scheduler which masks interrupts&n;&t; * during low-level context switch. So we save&n;&t; * all the PMD register we use and restore on&n;&t; * ctxsw in.&n;&t; *&n;&t; * release ownership of this PMU.&n;&t; * must be done before we save the registers.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save PMDs&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|task-&gt;thread.pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * save pmc0 &n;&t; */
id|task-&gt;thread.pmc
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * force a full reload &n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_lazy_save_regs
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;on [%d] by [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * do not own the PMU&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* save pmc0 */
id|t-&gt;pmc
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* not owned by this CPU */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|u64
id|psr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|owner
op_assign
id|PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: pfm_load_regs: null ctx for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we restore ALL the debug registers to avoid picking up &n;&t; * stale state.&n;&t; *&n;&t; * This must be done even when the task is still the owner&n;&t; * as the registers may have been modified via ptrace()&n;&t; * (not perfmon) by the previous task. &n;&t; *&n;&t; * XXX: dealing with this in a lazy fashion requires modifications&n;&t; * to the way the the debug registers are managed. This is will done&n;&t; * in the next version of perfmon.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_ibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
id|t-&gt;ibr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_dbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
id|t-&gt;dbr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if we were the last user, then nothing to do except restore psr&n;&t; * this path cannot be used in SMP&n;&t; */
r_if
c_cond
(paren
id|owner
op_eq
id|task
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid last_cpu=%d for [%d]&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * someone else is still using the PMU, first push it out and&n;&t; * then we&squot;ll be able to install our stuff !&n;&t; *&n;&t; * not possible in SMP&n;&t; */
r_if
c_cond
(paren
id|owner
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid leaking information to the user level when psr.sp=0,&n;&t; * we must reload ALL implemented pmds (even the ones we don&squot;t use).&n;&t; * In the kernel we only allow PFM_READ_PMDS on registers which&n;&t; * we initialized or requested (sampling) so there is no risk there.&n;&t; *&n;&t; * As an optimization, we will only reload the PMD that we use when &n;&t; * the context is in protected mode, i.e. psr.sp=1 because then there&n;&t; * is no leak possible.&n;&t; */
id|mask
op_assign
id|pfm_sysctl.fastctxsw
op_logical_or
id|ctx-&gt;ctx_fl_protected
ques
c_cond
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:colon
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|t-&gt;pmd
(braket
id|i
)braket
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * PMC0 is never set in the mask because it is always restored&n;&t; * separately.  &n;&t; *&n;&t; * ALL PMCs are systematically reloaded, unused registers&n;&t; * get their default (PAL reset) values to avoid picking up &n;&t; * stale configuration.&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * manually invoke core interrupt handler&n;&t; * if the task had a pending overflow when it was ctxsw out.&n;&t; * Side effect on ctx_fl_frozen is possible.&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmc
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
)paren
(brace
id|t-&gt;pmc
(braket
l_int|0
)braket
op_assign
id|pfm_overflow_handler
c_func
(paren
l_int|1
comma
id|task
comma
id|ctx
comma
id|t-&gt;pmc
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * unfreeze PMU if possible&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr we changed in pfm_save_regs()&n;&t; */
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: make this routine able to work with non current context&n; */
r_static
r_void
DECL|function|pfm_reset_pmu
id|pfm_reset_pmu
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|t-&gt;pfm_context
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: invalid task in pfm_reset_pmu()&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s make sure the PMU is frozen */
id|pfm_freeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * install reset values for PMC. We skip PMC0 (done above)&n;&t; * XX: good up to 64 PMCS&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
(paren
id|pmu_conf.pmc_desc
(braket
id|i
)braket
dot
id|type
op_amp
id|PFM_REG_END
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pmu_conf.pmc_desc
(braket
id|i
)braket
dot
id|type
op_amp
id|PFM_REG_IMPL
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When restoring context, we must restore ALL pmcs, even the ones &n;&t;&t; * that the task does not use to avoid leaks and possibly corruption&n;&t;&t; * of the sesion because of configuration conflicts. So here, we &n;&t;&t; * initialize the entire set used in the context switch restore routine.&n;&t; &t; */
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear reset values for PMD. &n;&t; * XXX: good up to 64 PMDS.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|pmu_conf.pmd_desc
(braket
id|i
)braket
dot
id|type
op_amp
id|PFM_REG_END
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pmu_conf.pmd_desc
(braket
id|i
)braket
dot
id|type
op_amp
id|PFM_REG_IMPL
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * On context switched restore, we must restore ALL pmc and ALL pmd even&n;&t; * when they are not actively used by the task. In UP, the incoming process &n;&t; * may otherwise pick up left over PMC, PMD state from the previous process.&n;&t; * As opposed to PMD, stale PMC can cause harm to the incoming&n;&t; * process because they may change what is being measured. &n;&t; * Therefore, we must systematically reinstall the entire&n;&t; * PMC state. In SMP, the same thing is possible on the &n;&t; * same CPU but also on between 2 CPUs. &n;&t; *&n;&t; * The problem with PMD is information leaking especially&n;&t; * to user level when psr.sp=0&n;&t; *&n;&t; * There is unfortunately no easy way to avoid this problem&n;&t; * on either UP or SMP. This definitively slows down the&n;&t; * pfm_load_regs() function. &n;&t; */
multiline_comment|/*&n;&t;  * We must include all the PMC in this mask to make sure we don&squot;t&n;&t;  * see any side effect of a stale state, such as opcode matching&n;&t;  * or range restrictions, for instance.&n;&t;  *&n;&t;  * We never directly restore PMC0 so we do not include it in the mask.&n;&t;  */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
id|pmu_conf.impl_pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
suffix:semicolon
multiline_comment|/*&n;&t; * We must include all the PMD in this mask to avoid picking&n;&t; * up stale value and leak information, especially directly&n;&t; * at the user level when psr.sp=0&n;&t; */
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_assign
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* &n;&t; * Keep track of the pmds we want to sample&n;&t; * XXX: may be we don&squot;t need to save/restore the DEAR/IEAR pmds&n;&t; * but we do need the BTB for sure. This is because of a hardware&n;&t; * buffer of 1 only for non-BTB pmds.&n;&t; *&n;&t; * We ignore the unimplemented pmds specified by the user&n;&t; */
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_assign
id|ctx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
suffix:semicolon
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always save/restore PMC[0] */
multiline_comment|/*&n;&t; * useful in case of re-enable after disable&n;&t; */
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when a thread exits (from exit_thread()).&n; * This is a simplified pfm_save_regs() that simply flushes the current&n; * register state into the save area taking into account any pending&n; * overflow. This time no notification is sent because the task is dying&n; * anyway. The inline processing of overflows avoids loosing some counts.&n; * The PMU is frozen on exit from this call and is to never be reenabled&n; * again for this task.&n; *&n; */
r_void
DECL|function|pfm_flush_regs
id|pfm_flush_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|pmc0
suffix:semicolon
r_int
r_int
id|mask2
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; * that&squot;s it if context already disabled&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_flags.state
op_eq
id|PFM_CTX_DISABLED
)paren
r_return
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* disable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
multiline_comment|/* stop monitoring */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* stop monitoring */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no more save/restore on ctxsw */
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control on overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|pfm_freeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t need to restore psr, because we are on our way out&n;&t; */
multiline_comment|/*&n;&t; * This loop flushes the PMD into the PFM context.&n;&t; * It also processes overflow inline.&n;&t; *&n;&t; * IMPORTANT: No notification is sent at this point as the process is dying.&n;&t; * The implicit notification will come from a SIGCHILD or a return from a&n;&t; * waitpid().&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: [%d] last_cpu=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we save all the used pmds&n;&t; * we take care of overflows for pmds used as counters&n;&t; */
id|mask2
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask2
suffix:semicolon
id|i
op_increment
comma
id|mask2
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask2
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] soft_pmd=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* collect latest results */
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
id|val
op_amp
id|pmu_conf.ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now everything is in ctx_soft_pmds[] and we need&n;&t;&t;&t; * to clear the saved context from save_regs() such that&n;&t;&t;&t; * pfm_read_pmds() gets the correct value&n;&t;&t;&t; */
id|task-&gt;thread.pmd
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * take care of overflow inline&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pmc0
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.ovfl_val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] overflowed soft_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * not a counter, just save value as is&n;&t;&t;&t; */
id|task-&gt;thread.pmd
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * indicates that context has been saved&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * task is the newly created task, pt_regs for new child&n; */
r_int
DECL|function|pfm_inherit
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|pfm_context_t
op_star
id|nctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|thread
suffix:semicolon
r_int
r_int
id|m
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * the new task was copied from parent and therefore points&n;&t; * to the parent&squot;s context at this point&n;&t; */
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * for secure sessions, make sure child cannot mess up &n;&t; * the monitoring session.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_unsecure
op_eq
l_int|0
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;enabling psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;psr.sp=%d [%d]&bslash;n&quot;
comma
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if there was a virtual mapping for the sampling buffer&n;&t; * the mapping is NOT inherited across fork() (see VM_DONTCOPY), &n;&t; * so we don&squot;t have to explicitely remove it here. &n;&t; *&n;&t; *&n;&t; * Part of the clearing of fields is also done in&n;&t; * copy_thread() because the fiels are outside the&n;&t; * pfm_context structure and can affect tasks not&n;&t; * using perfmon.&n;&t; */
multiline_comment|/* clear pending notification */
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * clear cpu pinning restriction for child&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|set_cpus_allowed
c_func
(paren
id|task
comma
id|ctx-&gt;ctx_saved_cpus_allowed
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;setting cpus_allowed for [%d] to 0x%lx from 0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_saved_cpus_allowed
comma
id|current-&gt;cpus_allowed
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * takes care of easiest case first&n;&t; */
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_NONE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;removing PFM context for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t;&t; * we must clear psr.up because the new child does&n;&t;&t; * not have a context and the PM_VALID flag is cleared&n;&t;&t; * in copy_thread().&n;&t;&t; *&n;&t;&t; * we do not clear psr.pp because it is always&n;&t;&t; * controlled by the system wide logic and we should&n;&t;&t; * never be here when system wide is running anyway&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* copy_thread() clears IA64_THREAD_PM_VALID */
r_return
l_int|0
suffix:semicolon
)brace
id|nctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* copy content */
op_star
id|nctx
op_assign
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_ONCE
)paren
(brace
id|nctx-&gt;ctx_fl_inherit
op_assign
id|PFM_FL_INHERIT_NONE
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;downgrading to INHERIT_NONE for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * task is not yet visible in the tasklist, so we do &n;&t; * not need to lock the newly created context.&n;&t; * However, we must grab the tasklist_lock to ensure&n;&t; * that the ctx_owner or ctx_notify_task do not disappear&n;&t; * while we increment their check counters.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx-&gt;ctx_notify_task
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx-&gt;ctx_owner
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize counters in new context */
id|m
op_assign
id|nctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_logical_and
id|pmu_conf.pmd_desc
(braket
id|i
)braket
dot
id|type
op_eq
id|PFM_REG_COUNTING
)paren
(brace
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|lval
op_amp
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
id|thread-&gt;pmd
(braket
id|i
)braket
op_assign
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|lval
op_amp
id|pmu_conf.ovfl_val
suffix:semicolon
)brace
r_else
(brace
id|thread-&gt;pmd
(braket
id|i
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/* reset to initial state */
)brace
)brace
id|nctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|nctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|nctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|nctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * here nctx-&gt;ctx_psb == ctx-&gt;ctx_psb&n;&t; *&n;&t; * increment reference count to sampling&n;&t; * buffer, if any. Note that this is independent&n;&t; * from the virtual mapping. The latter is never&n;&t; * inherited while the former will be if context&n;&t; * is setup to something different from PFM_FL_INHERIT_NONE&n;&t; */
r_if
c_cond
(paren
id|nctx-&gt;ctx_psb
)paren
(brace
id|LOCK_PSB
c_func
(paren
id|nctx-&gt;ctx_psb
)paren
suffix:semicolon
id|nctx-&gt;ctx_psb-&gt;psb_refcnt
op_increment
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;updated smpl @ %p refcnt=%lu psb_flags=0x%x&bslash;n&quot;
comma
id|ctx-&gt;ctx_psb-&gt;psb_hdr
comma
id|ctx-&gt;ctx_psb-&gt;psb_refcnt
comma
id|ctx-&gt;ctx_psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
id|UNLOCK_PSB
c_func
(paren
id|nctx-&gt;ctx_psb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * remove any pointer to sampling buffer mapping&n;&t; &t; */
id|nctx-&gt;ctx_smpl_vaddr
op_assign
l_int|0
suffix:semicolon
)brace
id|sema_init
c_func
(paren
op_amp
id|nctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset this semaphore to locked */
multiline_comment|/*&n;&t; * propagate kernel psr in new context (used for first ctxsw in&n;&t; */
id|nctx-&gt;ctx_saved_psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * propagate kernel psr in new context (used for first ctxsw in&n;&t; */
id|nctx-&gt;ctx_saved_psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* link with new task */
id|thread-&gt;pfm_context
op_assign
id|nctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;nctx=%p for process [%d]&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|nctx
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the copy_thread routine automatically clears&n;&t; * IA64_THREAD_PM_VALID, so we need to reenable it, if it was used by the caller&n;&t; */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;setting PM_VALID for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|thread-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&n; * We cannot touch any of the PMU registers at this point as we may&n; * not be running on the same CPU the task was last run on.  Therefore&n; * it is assumed that the PMU has been stopped appropriately in&n; * pfm_flush_regs() called from exit_thread(). &n; *&n; * The function is called in the context of the parent via a release_thread()&n; * and wait4(). The task is not in the tasklist anymore.&n; */
r_void
DECL|function|pfm_context_exit
id|pfm_context_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * check sampling buffer&n;&t; */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_psb
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
id|LOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling buffer from [%d] @%p size %ld refcnt=%lu psb_flags=0x%x&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
comma
id|psb-&gt;psb_refcnt
comma
id|psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in the case where we are the last user, we may be able to free&n;&t;&t; * the buffer&n;&t;&t; */
id|psb-&gt;psb_refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;psb_refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The flag is cleared in pfm_vm_close(). which gets &n;&t;&t;&t; * called from do_exit() via exit_mm(). &n;&t;&t;&t; * By the time we come here, the task has no more mm context.&n;&t;&t;&t; *&n;&t;&t;&t; * We can only free the psb and buffer here after the vm area&n;&t;&t;&t; * describing the buffer has been removed. This normally happens &n;&t;&t;&t; * as part of do_exit() but the entire mm context is ONLY removed&n;&t;&t;&t; * once its reference counts goes to zero. This is typically&n;&t;&t;&t; * the case except for multi-threaded (several tasks) processes.&n;&t;&t;&t; *&n;&t;&t;&t; * See pfm_vm_close() and pfm_cleanup_smpl_buf() for more details.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|psb-&gt;psb_flags
op_amp
id|PSB_HAS_VMA
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cleaning sampling buffer from [%d] @%p size %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * free the buffer and psb &n;&t;&t;&t;&t; */
id|pfm_rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|psb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* psb may have been deleted */
r_if
c_cond
(paren
id|psb
)paren
id|UNLOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cleaning [%d] pfm_context @%p notify_task=%p check=%d mm=%p&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx
comma
id|ctx-&gt;ctx_notify_task
comma
id|atomic_read
c_func
(paren
op_amp
id|task-&gt;thread.pfm_notifiers_check
)paren
comma
id|task-&gt;mm
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid getting the notified task or owner task scan the entire process &n;&t; * list when they exit, we decrement notifiers_check and owners_check respectively.&n;&t; *&n;&t; * Of course, there is race condition between decreasing the value and the &n;&t; * task exiting. The danger comes from the fact that, in both cases, we have a &n;&t; * direct pointer to a task structure thereby bypassing the tasklist. &n;&t; * We must make sure that, if we have task!= NULL, the target task is still &n;&t; * present and is identical to the initial task specified &n;&t; * during pfm_context_create(). It may already be detached from the tasklist but &n;&t; * that&squot;s okay. Note that it is okay if we miss the deadline and the task scans &n;&t; * the list for nothing, it will affect performance but not correctness. &n;&t; * The correctness is ensured by using the ctx_lock which prevents the &n;&t; * notify_task from changing the fields in our context.&n;&t; * Once holdhing this lock, if we see task!= NULL, then it will stay like&n;&t; * that until we release the lock. If it is NULL already then we came too late.&n;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d], [%d] atomic_sub on [%d] notifiers=%u&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_owner
op_ne
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d], [%d] atomic_sub on [%d] owners=%u&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_owner-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
suffix:semicolon
)brace
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|pfm_unreserve_session
c_func
(paren
id|task
comma
id|ctx-&gt;ctx_fl_system
comma
l_int|1UL
op_lshift
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t; &t; * remove any CPU pinning&n;&t; &t; */
id|set_cpus_allowed
c_func
(paren
id|task
comma
id|ctx-&gt;ctx_saved_cpus_allowed
)paren
suffix:semicolon
)brace
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  clean pfm state in thread structure,&n;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pfm_notifiers is cleaned in pfm_cleanup_notifiers() */
)brace
multiline_comment|/*&n; * function invoked from release_thread when pfm_smpl_buf_list is not NULL&n; */
r_int
DECL|function|pfm_cleanup_smpl_buf
id|pfm_cleanup_smpl_buf
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|tmp
comma
op_star
id|psb
op_assign
id|task-&gt;thread.pfm_smpl_buf_list
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: psb is null in [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Walk through the list and free the sampling buffer and psb&n;&t; */
r_while
c_loop
(paren
id|psb
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] freeing smpl @%p size %ld&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
id|pfm_rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|tmp
op_assign
id|psb-&gt;psb_next
suffix:semicolon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|psb
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* just in case */
id|task-&gt;thread.pfm_smpl_buf_list
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * function invoked from release_thread to make sure that the ctx_owner field does not&n; * point to an unexisting task.&n; */
r_void
DECL|function|pfm_cleanup_owners
id|pfm_cleanup_owners
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called by [%d] for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to do the 2-step test here, because thread.ctx&n;&t;&t; * is cleaned up only in release_thread() and at that point&n;&t;&t; * the task has been detached from the tasklist which is an&n;&t;&t; * operation which uses the write_lock() on the tasklist_lock&n;&t;&t; * so it cannot run concurrently to this loop. So we have the&n;&t;&t; * guarantee that if we find p and it has a perfmon ctx then&n;&t;&t; * it is going to stay like this for the entire execution of this&n;&t;&t; * loop.&n;&t;&t; */
id|ctx
op_assign
id|p-&gt;thread.pfm_context
suffix:semicolon
singleline_comment|//DBprintk((&quot;[%d] scanning task [%d] ctx=%p&bslash;n&quot;, task-&gt;pid, p-&gt;pid, ctx));
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_owner
op_eq
id|task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;trying for owner [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the spinlock is required to take care of a race condition&n;&t;&t;&t; * with the send_sig_info() call. We must make sure that &n;&t;&t;&t; * either the send_sig_info() completes using a valid task,&n;&t;&t;&t; * or the notify_task is cleared before the send_sig_info()&n;&t;&t;&t; * can pick up a stale value. Note that by the time this&n;&t;&t;&t; * function is executed the &squot;task&squot; is already detached from the&n;&t;&t;&t; * tasklist. The problem is that the notifiers have a direct&n;&t;&t;&t; * pointer to it. It is okay to send a signal to a task in this&n;&t;&t;&t; * stage, it simply will have no effect. But it is better than sending&n;&t;&t;&t; * to a completely destroyed task or worse to a new task using the same&n;&t;&t;&t; * task_struct address.&n;&t;&t;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_owner
op_assign
l_int|NULL
suffix:semicolon
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;done for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|task-&gt;thread.pfm_owners_check
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function called from release_thread to make sure that the ctx_notify_task is not pointing&n; * to an unexisting task&n; */
r_void
DECL|function|pfm_cleanup_notifiers
id|pfm_cleanup_notifiers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called by [%d] for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to do the 2-step test here, because thread.ctx is cleaned up&n;&t;&t; * only in release_thread() and at that point the task has been detached&n;&t;&t; * from the tasklist which is an operation which uses the write_lock() on&n;&t;&t; * the tasklist_lock so it cannot run concurrently to this loop. So we&n;&t;&t; * have the guarantee that if we find p and it has a perfmon ctx then it&n;&t;&t; * is going to stay like this for the entire execution of this loop.&n;&t;&t; */
id|ctx
op_assign
id|p-&gt;thread.pfm_context
suffix:semicolon
singleline_comment|//DBprintk((&quot;[%d] scanning task [%d] ctx=%p&bslash;n&quot;, task-&gt;pid, p-&gt;pid, ctx));
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_notify_task
op_eq
id|task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;trying for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the spinlock is required to take care of a race condition&n;&t;&t;&t; * with the send_sig_info() call. We must make sure that &n;&t;&t;&t; * either the send_sig_info() completes using a valid task,&n;&t;&t;&t; * or the notify_task is cleared before the send_sig_info()&n;&t;&t;&t; * can pick up a stale value. Note that by the time this&n;&t;&t;&t; * function is executed the &squot;task&squot; is already detached from the&n;&t;&t;&t; * tasklist. The problem is that the notifiers have a direct&n;&t;&t;&t; * pointer to it. It is okay to send a signal to a task in this&n;&t;&t;&t; * stage, it simply will have no effect. But it is better than sending&n;&t;&t;&t; * to a completely destroyed task or worse to a new task using the same&n;&t;&t;&t; * task_struct address.&n;&t;&t;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_notify_task
op_assign
l_int|NULL
suffix:semicolon
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;done for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|task-&gt;thread.pfm_notifiers_check
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|pfm_interrupt_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
r_int
DECL|function|pfm_install_alternate_syswide_subsystem
id|pfm_install_alternate_syswide_subsystem
c_func
(paren
id|pfm_intr_handler_desc_t
op_star
id|hdl
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* some sanity checks */
r_if
c_cond
(paren
id|hdl
op_eq
l_int|NULL
op_logical_or
id|hdl-&gt;handler
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* do the easy test first */
r_if
c_cond
(paren
id|pfm_alternate_intr_handler
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reserve our session */
id|ret
op_assign
id|pfm_reserve_session
c_func
(paren
l_int|NULL
comma
l_int|1
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_alternate_intr_handler
)paren
(brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;perfmon: install_alternate, intr_handler not NULL &quot;
l_string|&quot;after reserve&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pfm_alternate_intr_handler
op_assign
id|hdl
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pfm_remove_alternate_syswide_subsystem
id|pfm_remove_alternate_syswide_subsystem
c_func
(paren
id|pfm_intr_handler_desc_t
op_star
id|hdl
)paren
(brace
r_if
c_cond
(paren
id|hdl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* cannot remove someone else&squot;s handler! */
r_if
c_cond
(paren
id|pfm_alternate_intr_handler
op_ne
id|hdl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|pfm_alternate_intr_handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t; * XXX: assume cpu_online_map has not changed since reservation &n;&t; */
id|pfm_unreserve_session
c_func
(paren
l_int|NULL
comma
l_int|1
comma
id|cpu_online_map
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * perfmon initialization routine, called from the initcall() table&n; */
r_int
id|__init
DECL|function|pfm_init
id|pfm_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|n
comma
id|n_counters
comma
id|i
suffix:semicolon
id|pmu_conf.disabled
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: version %u.%u IRQ %u&bslash;n&quot;
comma
id|PFM_VERSION_MAJ
comma
id|PFM_VERSION_MIN
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * compute the number of implemented PMD/PMC from the&n;&t; * description tables&n;&t; */
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf.impl_pmcs
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
id|pmu_conf.num_pmcs
op_assign
id|n
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|n_counters
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf.impl_pmds
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
id|n_counters
op_increment
suffix:semicolon
)brace
id|pmu_conf.num_pmds
op_assign
id|n
suffix:semicolon
id|pmu_conf.num_counters
op_assign
id|n_counters
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: %u PMCs, %u PMDs, %u counters (%lu bits)&bslash;n&quot;
comma
id|pmu_conf.num_pmcs
comma
id|pmu_conf.num_pmds
comma
id|pmu_conf.num_counters
comma
id|ffz
c_func
(paren
id|pmu_conf.ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf.num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf.num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: not enough pmc/pmd, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perfmon_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: cannot create /proc entry, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * create /proc/perfmon&n;&t; */
id|pfm_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|pfm_sysctl_root
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize all our spinlocks&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_sessions.pfs_lock
)paren
suffix:semicolon
multiline_comment|/* we are all set */
id|pmu_conf.disabled
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfm_init
id|__initcall
c_func
(paren
id|pfm_init
)paren
suffix:semicolon
r_void
DECL|function|pfm_init_percpu
id|pfm_init_percpu
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|me
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|me
op_eq
l_int|0
)paren
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we first initialize the PMU to a stable state.&n;&t; * the values may have been changed from their power-up&n;&t; * values by software executed before the kernel took over.&n;&t; *&n;&t; * At this point, pmu_conf has not yet been initialized&n;&t; *&n;&t; * On McKinley, this code is ineffective until PMC4 is initialized.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
id|pfm_freeze_pmu
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_void
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
