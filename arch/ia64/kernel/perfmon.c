multiline_comment|/*&n; * This file implements the perfmon-2 subsystem which is used&n; * to program the IA-64 Performance Monitoring Unit (PMU).&n; *&n; * The initial version of perfmon.c was written by&n; * Ganesh Venkitachalam, IBM Corp.&n; *&n; * Then it was modified for perfmon-1.x by Stephane Eranian and &n; * David Mosberger, Hewlett Packard Co.&n; * &n; * Version Perfmon-2.x is a rewrite of perfmon-1.x&n; * by Stephane Eranian, Hewlett Packard Co. &n; *&n; * Copyright (C) 1999-2003  Hewlett Packard Co&n; *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *               David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * More information about perfmon available at:&n; * &t;http://www.hpl.hp.com/research/linux/perfmon&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#ifdef CONFIG_PERFMON
multiline_comment|/*&n; * perfmon context state&n; */
DECL|macro|PFM_CTX_UNLOADED
mdefine_line|#define PFM_CTX_UNLOADED&t;1&t;/* context is not loaded onto any task */
DECL|macro|PFM_CTX_LOADED
mdefine_line|#define PFM_CTX_LOADED&t;&t;2&t;/* context is loaded onto a task */
DECL|macro|PFM_CTX_MASKED
mdefine_line|#define PFM_CTX_MASKED&t;&t;3&t;/* context is loaded but monitoring is masked due to overflow */
DECL|macro|PFM_CTX_ZOMBIE
mdefine_line|#define PFM_CTX_ZOMBIE&t;&t;4&t;/* owner of the context is closing it */
DECL|macro|PFM_CTX_TERMINATED
mdefine_line|#define PFM_CTX_TERMINATED&t;5&t;/* the task the context was loaded onto is gone */
DECL|macro|CTX_LOADED
mdefine_line|#define CTX_LOADED(c)        (c)-&gt;ctx_state = PFM_CTX_LOADED
DECL|macro|CTX_UNLOADED
mdefine_line|#define CTX_UNLOADED(c)      (c)-&gt;ctx_state = PFM_CTX_UNLOADED
DECL|macro|CTX_ZOMBIE
mdefine_line|#define CTX_ZOMBIE(c)        (c)-&gt;ctx_state = PFM_CTX_ZOMBIE
DECL|macro|CTX_DESTROYED
mdefine_line|#define CTX_DESTROYED(c)     (c)-&gt;ctx_state = PFM_CTX_DESTROYED
DECL|macro|CTX_MASKED
mdefine_line|#define CTX_MASKED(c)        (c)-&gt;ctx_state = PFM_CTX_MASKED
DECL|macro|CTX_TERMINATED
mdefine_line|#define CTX_TERMINATED(c)    (c)-&gt;ctx_state = PFM_CTX_TERMINATED
DECL|macro|CTX_IS_UNLOADED
mdefine_line|#define CTX_IS_UNLOADED(c)   ((c)-&gt;ctx_state == PFM_CTX_UNLOADED)
DECL|macro|CTX_IS_LOADED
mdefine_line|#define CTX_IS_LOADED(c)     ((c)-&gt;ctx_state == PFM_CTX_LOADED)
DECL|macro|CTX_IS_ZOMBIE
mdefine_line|#define CTX_IS_ZOMBIE(c)     ((c)-&gt;ctx_state == PFM_CTX_ZOMBIE)
DECL|macro|CTX_IS_MASKED
mdefine_line|#define CTX_IS_MASKED(c)     ((c)-&gt;ctx_state == PFM_CTX_MASKED)
DECL|macro|CTX_IS_TERMINATED
mdefine_line|#define CTX_IS_TERMINATED(c) ((c)-&gt;ctx_state == PFM_CTX_TERMINATED)
DECL|macro|CTX_IS_DEAD
mdefine_line|#define CTX_IS_DEAD(c)&t;     ((c)-&gt;ctx_state == PFM_CTX_TERMINATED || (c)-&gt;ctx_state == PFM_CTX_ZOMBIE)
DECL|macro|PFM_INVALID_ACTIVATION
mdefine_line|#define PFM_INVALID_ACTIVATION&t;(~0UL)
multiline_comment|/*&n; * depth of message queue&n; */
DECL|macro|PFM_MAX_MSGS
mdefine_line|#define PFM_MAX_MSGS&t;&t;32
DECL|macro|PFM_CTXQ_EMPTY
mdefine_line|#define PFM_CTXQ_EMPTY(g)&t;((g)-&gt;ctx_msgq_head == (g)-&gt;ctx_msgq_tail)
multiline_comment|/*&n; * type of a PMU register (bitmask).&n; * bitmask structure:&n; * &t;bit0   : register implemented&n; * &t;bit1   : end marker&n; * &t;bit2-3 : reserved&n; * &t;bit4   : pmc has pmc.pm&n; * &t;bit5   : pmc controls a counter (has pmc.oi), pmd is used as counter&n; * &t;bit6-7 : register type&n; * &t;bit8-31: reserved&n; */
DECL|macro|PFM_REG_NOTIMPL
mdefine_line|#define PFM_REG_NOTIMPL&t;&t;0x0 /* not implemented at all */
DECL|macro|PFM_REG_IMPL
mdefine_line|#define PFM_REG_IMPL&t;&t;0x1 /* register implemented */
DECL|macro|PFM_REG_END
mdefine_line|#define PFM_REG_END&t;&t;0x2 /* end marker */
DECL|macro|PFM_REG_MONITOR
mdefine_line|#define PFM_REG_MONITOR&t;&t;(0x1&lt;&lt;4|PFM_REG_IMPL) /* a PMC with a pmc.pm field only */
DECL|macro|PFM_REG_COUNTING
mdefine_line|#define PFM_REG_COUNTING&t;(0x2&lt;&lt;4|PFM_REG_MONITOR|PFM_REG_IMPL) /* a monitor + pmc.oi+ PMD used as a counter */
DECL|macro|PFM_REG_CONTROL
mdefine_line|#define PFM_REG_CONTROL&t;&t;(0x4&lt;&lt;4|PFM_REG_IMPL) /* PMU control register */
DECL|macro|PFM_REG_CONFIG
mdefine_line|#define&t;PFM_REG_CONFIG&t;&t;(0x8&lt;&lt;4|PFM_REG_IMPL) /* configuration register */
DECL|macro|PFM_REG_BUFFER
mdefine_line|#define PFM_REG_BUFFER&t; &t;(0xc&lt;&lt;4|PFM_REG_IMPL) /* PMD used as buffer */
DECL|macro|PMC_IS_LAST
mdefine_line|#define PMC_IS_LAST(i)&t;(pmu_conf.pmc_desc[i].type &amp; PFM_REG_END)
DECL|macro|PMD_IS_LAST
mdefine_line|#define PMD_IS_LAST(i)&t;(pmu_conf.pmd_desc[i].type &amp; PFM_REG_END)
DECL|macro|PFM_IS_DISABLED
mdefine_line|#define PFM_IS_DISABLED() (pmu_conf.enabled == 0)
DECL|macro|PMC_OVFL_NOTIFY
mdefine_line|#define PMC_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
multiline_comment|/* i assumed unsigned */
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMCS &amp;&amp; (pmu_conf.pmc_desc[i].type &amp; PFM_REG_IMPL))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMDS &amp;&amp; (pmu_conf.pmd_desc[i].type &amp; PFM_REG_IMPL))
multiline_comment|/* XXX: these assume that register i is implemented */
DECL|macro|PMD_IS_COUNTING
mdefine_line|#define PMD_IS_COUNTING(i) ((pmu_conf.pmd_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)
DECL|macro|PMC_IS_COUNTING
mdefine_line|#define PMC_IS_COUNTING(i) ((pmu_conf.pmc_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)
DECL|macro|PMC_IS_MONITOR
mdefine_line|#define PMC_IS_MONITOR(i)  ((pmu_conf.pmc_desc[i].type &amp; PFM_REG_MONITOR)  == PFM_REG_MONITOR)
DECL|macro|PMC_DFL_VAL
mdefine_line|#define PMC_DFL_VAL(i)     pmu_conf.pmc_desc[i].default_value
DECL|macro|PMC_RSVD_MASK
mdefine_line|#define PMC_RSVD_MASK(i)   pmu_conf.pmc_desc[i].reserved_mask
DECL|macro|PMD_PMD_DEP
mdefine_line|#define PMD_PMD_DEP(i)&t;   pmu_conf.pmd_desc[i].dep_pmd[0]
DECL|macro|PMC_PMD_DEP
mdefine_line|#define PMC_PMD_DEP(i)&t;   pmu_conf.pmc_desc[i].dep_pmd[0]
multiline_comment|/* k assumed unsigned (up to 64 registers) */
DECL|macro|IBR_IS_IMPL
mdefine_line|#define IBR_IS_IMPL(k)&t;  (k&lt; IA64_NUM_DBG_REGS)
DECL|macro|DBR_IS_IMPL
mdefine_line|#define DBR_IS_IMPL(k)&t;  (k&lt; IA64_NUM_DBG_REGS)
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_block == 0)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_fl_is_sampling)
DECL|macro|PFM_CTX_TASK
mdefine_line|#define PFM_CTX_TASK(h)&t;&t;(h)-&gt;ctx_task
multiline_comment|/* XXX: does not support more than 64 PMDs */
DECL|macro|CTX_USED_PMD
mdefine_line|#define CTX_USED_PMD(ctx, mask) (ctx)-&gt;ctx_used_pmds[0] |= (mask)
DECL|macro|CTX_IS_USED_PMD
mdefine_line|#define CTX_IS_USED_PMD(ctx, c) (((ctx)-&gt;ctx_used_pmds[0] &amp; (1UL &lt;&lt; (c))) != 0UL)
DECL|macro|CTX_USED_MONITOR
mdefine_line|#define CTX_USED_MONITOR(ctx, mask) (ctx)-&gt;ctx_used_monitors[0] |= (mask)
DECL|macro|CTX_USED_IBR
mdefine_line|#define CTX_USED_IBR(ctx,n) &t;(ctx)-&gt;ctx_used_ibrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_DBR
mdefine_line|#define CTX_USED_DBR(ctx,n) &t;(ctx)-&gt;ctx_used_dbrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USES_DBREGS
mdefine_line|#define CTX_USES_DBREGS(ctx)&t;(((pfm_context_t *)(ctx))-&gt;ctx_fl_using_dbreg==1)
DECL|macro|PFM_CODE_RR
mdefine_line|#define PFM_CODE_RR&t;0&t;/* requesting code range restriction */
DECL|macro|PFM_DATA_RR
mdefine_line|#define PFM_DATA_RR&t;1&t;/* requestion data range restriction */
DECL|macro|PFM_CPUINFO_CLEAR
mdefine_line|#define PFM_CPUINFO_CLEAR(v)&t;pfm_get_cpu_var(pfm_syst_info) &amp;= ~(v)
DECL|macro|PFM_CPUINFO_SET
mdefine_line|#define PFM_CPUINFO_SET(v)&t;pfm_get_cpu_var(pfm_syst_info) |= (v)
DECL|macro|PFM_CPUINFO_GET
mdefine_line|#define PFM_CPUINFO_GET()&t;pfm_get_cpu_var(pfm_syst_info)
multiline_comment|/*&n; * context protection macros&n; * in SMP:&n; * &t;- we need to protect against CPU concurrency (spin_lock)&n; * &t;- we need to protect against PMU overflow interrupts (local_irq_disable)&n; * in UP:&n; * &t;- we need to protect against PMU overflow interrupts (local_irq_disable)&n; *&n; * spin_lock_irqsave()/spin_lock_irqrestore():&n; * &t;in SMP: local_irq_disable + spin_lock&n; * &t;in UP : local_irq_disable&n; *&n; * spin_lock()/spin_lock():&n; * &t;in UP : removed automatically&n; * &t;in SMP: protect against context accesses from other CPU. interrupts&n; * &t;        are not masked. This is useful for the PMU interrupt handler&n; * &t;        because we know we will not get PMU concurrency in that code.&n; */
DECL|macro|PROTECT_CTX
mdefine_line|#define PROTECT_CTX(c, f) &bslash;&n;&t;do {  &bslash;&n;&t;&t;DPRINT((&quot;spinlock_irq_save ctx %p by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;&t;spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;&t;DPRINT((&quot;spinlocked ctx %p  by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX
mdefine_line|#define UNPROTECT_CTX(c, f) &bslash;&n;&t;do { &bslash;&n;&t;&t;DPRINT((&quot;spinlock_irq_restore ctx %p by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|PROTECT_CTX_NOPRINT
mdefine_line|#define PROTECT_CTX_NOPRINT(c, f) &bslash;&n;&t;do {  &bslash;&n;&t;&t;spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX_NOPRINT
mdefine_line|#define UNPROTECT_CTX_NOPRINT(c, f) &bslash;&n;&t;do { &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|PROTECT_CTX_NOIRQ
mdefine_line|#define PROTECT_CTX_NOIRQ(c) &bslash;&n;&t;do {  &bslash;&n;&t;&t;spin_lock(&amp;(c)-&gt;ctx_lock); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX_NOIRQ
mdefine_line|#define UNPROTECT_CTX_NOIRQ(c) &bslash;&n;&t;do { &bslash;&n;&t;&t;spin_unlock(&amp;(c)-&gt;ctx_lock); &bslash;&n;&t;} while(0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|GET_ACTIVATION
mdefine_line|#define GET_ACTIVATION()&t;pfm_get_cpu_var(pmu_activation_number)
DECL|macro|INC_ACTIVATION
mdefine_line|#define INC_ACTIVATION()&t;pfm_get_cpu_var(pmu_activation_number)++
DECL|macro|SET_ACTIVATION
mdefine_line|#define SET_ACTIVATION(c)&t;(c)-&gt;ctx_last_activation = GET_ACTIVATION()
macro_line|#else /* !CONFIG_SMP */
DECL|macro|SET_ACTIVATION
mdefine_line|#define SET_ACTIVATION(t) &t;do {} while(0)
DECL|macro|GET_ACTIVATION
mdefine_line|#define GET_ACTIVATION(t) &t;do {} while(0)
DECL|macro|INC_ACTIVATION
mdefine_line|#define INC_ACTIVATION(t) &t;do {} while(0)
macro_line|#endif /* CONFIG_SMP */
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t, c)&t;do { pfm_get_cpu_var(pmu_owner) = (t); pfm_get_cpu_var(pmu_ctx) = (c); } while(0)
DECL|macro|GET_PMU_OWNER
mdefine_line|#define GET_PMU_OWNER()&t;&t;pfm_get_cpu_var(pmu_owner)
DECL|macro|GET_PMU_CTX
mdefine_line|#define GET_PMU_CTX()&t;&t;pfm_get_cpu_var(pmu_ctx)
DECL|macro|LOCK_PFS
mdefine_line|#define LOCK_PFS()&t;    &t;spin_lock(&amp;pfm_sessions.pfs_lock)
DECL|macro|UNLOCK_PFS
mdefine_line|#define UNLOCK_PFS()&t;    &t;spin_unlock(&amp;pfm_sessions.pfs_lock)
DECL|macro|PFM_REG_RETFLAG_SET
mdefine_line|#define PFM_REG_RETFLAG_SET(flags, val)&t;do { flags &amp;= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|PFM_CPU_ONLINE_MAP
mdefine_line|#define PFM_CPU_ONLINE_MAP&t;cpu_online_map
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;(PFM_CPU_ONLINE_MAP &amp; (1UL &lt;&lt; i))
macro_line|#else
DECL|macro|PFM_CPU_ONLINE_MAP
mdefine_line|#define PFM_CPU_ONLINE_MAP&t; 1UL
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;(i==0)
macro_line|#endif
multiline_comment|/*&n; * cmp0 must be the value of pmc0&n; */
DECL|macro|PMC0_HAS_OVFL
mdefine_line|#define PMC0_HAS_OVFL(cmp0)  (cmp0 &amp; ~0x1UL)
multiline_comment|/*&n; * debugging&n; */
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (unlikely(pfm_sysctl.debug &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __FUNCTION__, __LINE__, smp_processor_id(), current-&gt;pid); printk a; } &bslash;&n;&t;} while (0)
DECL|macro|DPRINT_ovfl
mdefine_line|#define DPRINT_ovfl(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (unlikely(pfm_sysctl.debug &gt; 0 &amp;&amp; pfm_sysctl.debug_ovfl &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __FUNCTION__, __LINE__, smp_processor_id(), current-&gt;pid); printk a; } &bslash;&n;&t;} while (0)
multiline_comment|/*&n; * Architected PMC structure&n; */
r_typedef
r_struct
(brace
DECL|member|pmc_plm
r_int
r_int
id|pmc_plm
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* privilege level mask */
DECL|member|pmc_ev
r_int
r_int
id|pmc_ev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* external visibility */
DECL|member|pmc_oi
r_int
r_int
id|pmc_oi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* overflow interrupt */
DECL|member|pmc_pm
r_int
r_int
id|pmc_pm
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* privileged monitor */
DECL|member|pmc_ig1
r_int
r_int
id|pmc_ig1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_es
r_int
r_int
id|pmc_es
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* event select */
DECL|member|pmc_ig2
r_int
r_int
id|pmc_ig2
suffix:colon
l_int|48
suffix:semicolon
multiline_comment|/* reserved */
DECL|typedef|pfm_monitor_t
)brace
id|pfm_monitor_t
suffix:semicolon
multiline_comment|/*&n; * 64-bit software counter structure&n; */
r_typedef
r_struct
(brace
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|lval
r_int
r_int
id|lval
suffix:semicolon
multiline_comment|/* last reset value */
DECL|member|long_reset
r_int
r_int
id|long_reset
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|short_reset
r_int
r_int
id|short_reset
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|reset_pmds
r_int
r_int
id|reset_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which other pmds to reset when this counter overflows */
DECL|member|smpl_pmds
r_int
r_int
id|smpl_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which pmds are accessed when counter overflow */
DECL|member|seed
r_int
r_int
id|seed
suffix:semicolon
multiline_comment|/* seed for random-number generator */
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
multiline_comment|/* mask for random-number generator */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:semicolon
multiline_comment|/* for future use */
DECL|member|eventid
r_int
r_int
id|eventid
suffix:semicolon
multiline_comment|/* overflow event identifier */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
multiline_comment|/*&n; * context flags&n; */
r_typedef
r_struct
(brace
DECL|member|block
r_int
r_int
id|block
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* when 1, task will blocked on user notifications */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|using_dbreg
r_int
r_int
id|using_dbreg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* using range restrictions (debug registers) */
DECL|member|is_sampling
r_int
r_int
id|is_sampling
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* true if using a custom format */
DECL|member|excl_idle
r_int
r_int
id|excl_idle
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* exclude idle task in system wide session */
DECL|member|unsecure
r_int
r_int
id|unsecure
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* exclude idle task in system wide session */
DECL|member|going_zombie
r_int
r_int
id|going_zombie
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* context is zombie (MASKED+blocking) */
DECL|member|trap_reason
r_int
r_int
id|trap_reason
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* reason for going into pfm_handle_work() */
DECL|member|no_msg
r_int
r_int
id|no_msg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* no message sent on overflow */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|22
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
DECL|macro|PFM_TRAP_REASON_NONE
mdefine_line|#define PFM_TRAP_REASON_NONE&t;&t;0x0&t;/* default value */
DECL|macro|PFM_TRAP_REASON_BLOCK
mdefine_line|#define PFM_TRAP_REASON_BLOCK&t;&t;0x1&t;/* we need to block on overflow */
DECL|macro|PFM_TRAP_REASON_RESET
mdefine_line|#define PFM_TRAP_REASON_RESET&t;&t;0x2&t;/* we need to reset PMDs */
multiline_comment|/*&n; * perfmon context: encapsulates all the state of a monitoring session&n; */
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_lock
id|spinlock_t
id|ctx_lock
suffix:semicolon
multiline_comment|/* context protection */
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* bitmask of flags  (block reason incl.) */
DECL|member|ctx_state
r_int
r_int
id|ctx_state
suffix:semicolon
multiline_comment|/* state: active/inactive (no bitfield) */
DECL|member|ctx_task
r_struct
id|task_struct
op_star
id|ctx_task
suffix:semicolon
multiline_comment|/* task to which context is attached */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers overflowed (notification) */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_used_pmds
r_int
r_int
id|ctx_used_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMD used            */
DECL|member|ctx_all_pmds
r_int
r_int
id|ctx_all_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of all accessible PMDs */
DECL|member|ctx_reload_pmds
r_int
r_int
id|ctx_reload_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of force reload PMD on ctxsw in */
DECL|member|ctx_all_pmcs
r_int
r_int
id|ctx_all_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of all accessible PMCs */
DECL|member|ctx_reload_pmcs
r_int
r_int
id|ctx_reload_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of force reload PMC on ctxsw in */
DECL|member|ctx_used_monitors
r_int
r_int
id|ctx_used_monitors
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of monitor PMC being used */
DECL|member|ctx_pmcs
r_int
r_int
id|ctx_pmcs
(braket
id|IA64_NUM_PMC_REGS
)braket
suffix:semicolon
multiline_comment|/*  saved copies of PMC values */
DECL|member|ctx_used_ibrs
r_int
r_int
id|ctx_used_ibrs
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bitmask of used IBR (speedup ctxsw in) */
DECL|member|ctx_used_dbrs
r_int
r_int
id|ctx_used_dbrs
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bitmask of used DBR (speedup ctxsw in) */
DECL|member|ctx_dbrs
r_int
r_int
id|ctx_dbrs
(braket
id|IA64_NUM_DBG_REGS
)braket
suffix:semicolon
multiline_comment|/* DBR values (cache) when not loaded */
DECL|member|ctx_ibrs
r_int
r_int
id|ctx_ibrs
(braket
id|IA64_NUM_DBG_REGS
)braket
suffix:semicolon
multiline_comment|/* IBR values (cache) when not loaded */
DECL|member|ctx_pmds
id|pfm_counter_t
id|ctx_pmds
(braket
id|IA64_NUM_PMD_REGS
)braket
suffix:semicolon
multiline_comment|/* software state for PMDS */
DECL|member|ctx_saved_psr
id|u64
id|ctx_saved_psr
suffix:semicolon
multiline_comment|/* copy of psr used for ctxsw */
DECL|member|ctx_last_activation
r_int
r_int
id|ctx_last_activation
suffix:semicolon
multiline_comment|/* context last activation number for last_cpu */
DECL|member|ctx_last_cpu
r_int
r_int
id|ctx_last_cpu
suffix:semicolon
multiline_comment|/* CPU id of current or last CPU used (SMP only) */
DECL|member|ctx_cpu
r_int
r_int
id|ctx_cpu
suffix:semicolon
multiline_comment|/* cpu to which perfmon is applied (system wide) */
DECL|member|ctx_fd
r_int
id|ctx_fd
suffix:semicolon
multiline_comment|/* file descriptor used my this context */
DECL|member|ctx_buf_fmt
id|pfm_buffer_fmt_t
op_star
id|ctx_buf_fmt
suffix:semicolon
multiline_comment|/* buffer format callbacks */
DECL|member|ctx_smpl_hdr
r_void
op_star
id|ctx_smpl_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header kernel vaddr */
DECL|member|ctx_smpl_size
r_int
r_int
id|ctx_smpl_size
suffix:semicolon
multiline_comment|/* size of sampling buffer */
DECL|member|ctx_smpl_vaddr
r_void
op_star
id|ctx_smpl_vaddr
suffix:semicolon
multiline_comment|/* user level virtual address of smpl buffer */
DECL|member|ctx_msgq_wait
id|wait_queue_head_t
id|ctx_msgq_wait
suffix:semicolon
DECL|member|ctx_msgq
id|pfm_msg_t
id|ctx_msgq
(braket
id|PFM_MAX_MSGS
)braket
suffix:semicolon
DECL|member|ctx_msgq_head
r_int
id|ctx_msgq_head
suffix:semicolon
DECL|member|ctx_msgq_tail
r_int
id|ctx_msgq_tail
suffix:semicolon
DECL|member|ctx_async_queue
r_struct
id|fasync_struct
op_star
id|ctx_async_queue
suffix:semicolon
DECL|member|ctx_zombieq
id|wait_queue_head_t
id|ctx_zombieq
suffix:semicolon
multiline_comment|/* termination cleanup wait queue */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
multiline_comment|/*&n; * magic number used to verify that structure is really&n; * a perfmon context&n; */
DECL|macro|PFM_IS_FILE
mdefine_line|#define PFM_IS_FILE(f)&t;&t;((f)-&gt;f_op == &amp;pfm_file_ops)
DECL|macro|PFM_GET_CTX
mdefine_line|#define PFM_GET_CTX(t)&t; &t;((pfm_context_t *)(t)-&gt;thread.pfm_context)
macro_line|#ifdef CONFIG_SMP
DECL|macro|SET_LAST_CPU
mdefine_line|#define SET_LAST_CPU(ctx, v)&t;(ctx)-&gt;ctx_last_cpu = (v)
DECL|macro|GET_LAST_CPU
mdefine_line|#define GET_LAST_CPU(ctx)&t;(ctx)-&gt;ctx_last_cpu
macro_line|#else
DECL|macro|SET_LAST_CPU
mdefine_line|#define SET_LAST_CPU(ctx, v)&t;do {} while(0)
DECL|macro|GET_LAST_CPU
mdefine_line|#define GET_LAST_CPU(ctx)&t;do {} while(0)
macro_line|#endif
DECL|macro|ctx_fl_block
mdefine_line|#define ctx_fl_block&t;&t;ctx_flags.block
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;&t;ctx_flags.system
DECL|macro|ctx_fl_using_dbreg
mdefine_line|#define ctx_fl_using_dbreg&t;ctx_flags.using_dbreg
DECL|macro|ctx_fl_is_sampling
mdefine_line|#define ctx_fl_is_sampling&t;ctx_flags.is_sampling
DECL|macro|ctx_fl_excl_idle
mdefine_line|#define ctx_fl_excl_idle&t;ctx_flags.excl_idle
DECL|macro|ctx_fl_unsecure
mdefine_line|#define ctx_fl_unsecure&t;&t;ctx_flags.unsecure
DECL|macro|ctx_fl_going_zombie
mdefine_line|#define ctx_fl_going_zombie&t;ctx_flags.going_zombie
DECL|macro|ctx_fl_trap_reason
mdefine_line|#define ctx_fl_trap_reason&t;ctx_flags.trap_reason
DECL|macro|ctx_fl_no_msg
mdefine_line|#define ctx_fl_no_msg&t;&t;ctx_flags.no_msg
DECL|macro|PFM_SET_WORK_PENDING
mdefine_line|#define PFM_SET_WORK_PENDING(t, v)&t;do { (t)-&gt;thread.pfm_needs_checking = v; } while(0);
DECL|macro|PFM_GET_WORK_PENDING
mdefine_line|#define PFM_GET_WORK_PENDING(t)&t;&t;(t)-&gt;thread.pfm_needs_checking
multiline_comment|/*&n; * global information about all sessions&n; * mostly used to synchronize between system wide and per-process&n; */
r_typedef
r_struct
(brace
DECL|member|pfs_lock
id|spinlock_t
id|pfs_lock
suffix:semicolon
multiline_comment|/* lock the structure */
DECL|member|pfs_task_sessions
r_int
r_int
id|pfs_task_sessions
suffix:semicolon
multiline_comment|/* number of per task sessions */
DECL|member|pfs_sys_sessions
r_int
r_int
id|pfs_sys_sessions
suffix:semicolon
multiline_comment|/* number of per system wide sessions */
DECL|member|pfs_sys_use_dbregs
r_int
r_int
id|pfs_sys_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a system wide session uses debug regs */
DECL|member|pfs_ptrace_use_dbregs
r_int
r_int
id|pfs_ptrace_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a process uses debug regs */
DECL|member|pfs_sys_session
r_struct
id|task_struct
op_star
id|pfs_sys_session
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* point to task owning a system-wide session */
DECL|typedef|pfm_session_t
)brace
id|pfm_session_t
suffix:semicolon
multiline_comment|/*&n; * information about a PMC or PMD.&n; * dep_pmd[]: a bitmask of dependent PMD registers&n; * dep_pmc[]: a bitmask of dependent PMC registers&n; */
r_typedef
r_struct
(brace
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|pm_pos
r_int
id|pm_pos
suffix:semicolon
DECL|member|default_value
r_int
r_int
id|default_value
suffix:semicolon
multiline_comment|/* power-on default value */
DECL|member|reserved_mask
r_int
r_int
id|reserved_mask
suffix:semicolon
multiline_comment|/* bitmask of reserved bits */
DECL|member|read_check
r_int
(paren
op_star
id|read_check
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|cnum
comma
r_int
r_int
op_star
id|val
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|write_check
r_int
(paren
op_star
id|write_check
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|cnum
comma
r_int
r_int
op_star
id|val
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|dep_pmd
r_int
r_int
id|dep_pmd
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|dep_pmc
r_int
r_int
id|dep_pmc
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|pfm_reg_desc_t
)brace
id|pfm_reg_desc_t
suffix:semicolon
multiline_comment|/* assume cnum is a valid monitor */
DECL|macro|PMC_PM
mdefine_line|#define PMC_PM(cnum, val)&t;(((val) &gt;&gt; (pmu_conf.pmc_desc[cnum].pm_pos)) &amp; 0x1)
DECL|macro|PMC_WR_FUNC
mdefine_line|#define PMC_WR_FUNC(cnum)&t;(pmu_conf.pmc_desc[cnum].write_check)
DECL|macro|PMD_WR_FUNC
mdefine_line|#define PMD_WR_FUNC(cnum)&t;(pmu_conf.pmd_desc[cnum].write_check)
DECL|macro|PMD_RD_FUNC
mdefine_line|#define PMD_RD_FUNC(cnum)&t;(pmu_conf.pmd_desc[cnum].read_check)
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristics.&n; */
r_typedef
r_struct
(brace
DECL|member|ovfl_val
r_int
r_int
id|ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for counters */
DECL|member|pmc_desc
id|pfm_reg_desc_t
op_star
id|pmc_desc
suffix:semicolon
multiline_comment|/* detailed PMC register dependencies descriptions */
DECL|member|pmd_desc
id|pfm_reg_desc_t
op_star
id|pmd_desc
suffix:semicolon
multiline_comment|/* detailed PMD register dependencies descriptions */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* number of PMCS: computed at init time */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* number of PMDS: computed at init time */
DECL|member|impl_pmcs
r_int
r_int
id|impl_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMCS */
DECL|member|impl_pmds
r_int
r_int
id|impl_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMDS */
DECL|member|pmu_name
r_char
op_star
id|pmu_name
suffix:semicolon
multiline_comment|/* PMU family name */
DECL|member|enabled
r_int
r_int
id|enabled
suffix:semicolon
multiline_comment|/* indicates if perfmon initialized properly */
DECL|member|pmu_family
r_int
r_int
id|pmu_family
suffix:semicolon
multiline_comment|/* cpuid family pattern used to identify pmu */
DECL|member|num_ibrs
r_int
r_int
id|num_ibrs
suffix:semicolon
multiline_comment|/* number of IBRS: computed at init time */
DECL|member|num_dbrs
r_int
r_int
id|num_dbrs
suffix:semicolon
multiline_comment|/* number of DBRS: computed at init time */
DECL|member|num_counters
r_int
r_int
id|num_counters
suffix:semicolon
multiline_comment|/* PMC/PMD counting pairs : computed at init time */
DECL|member|use_rr_dbregs
r_int
r_int
id|use_rr_dbregs
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* set if debug registers used for range restriction */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
multiline_comment|/*&n; * debug register related type definitions&n; */
r_typedef
r_struct
(brace
DECL|member|ibr_mask
r_int
r_int
id|ibr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|ibr_plm
r_int
r_int
id|ibr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ibr_ig
r_int
r_int
id|ibr_ig
suffix:colon
l_int|3
suffix:semicolon
DECL|member|ibr_x
r_int
r_int
id|ibr_x
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|ibr_mask_reg_t
)brace
id|ibr_mask_reg_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dbr_mask
r_int
r_int
id|dbr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|dbr_plm
r_int
r_int
id|dbr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dbr_ig
r_int
r_int
id|dbr_ig
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dbr_w
r_int
r_int
id|dbr_w
suffix:colon
l_int|1
suffix:semicolon
DECL|member|dbr_r
r_int
r_int
id|dbr_r
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|dbr_mask_reg_t
)brace
id|dbr_mask_reg_t
suffix:semicolon
r_typedef
r_union
(brace
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
DECL|member|ibr
id|ibr_mask_reg_t
id|ibr
suffix:semicolon
DECL|member|dbr
id|dbr_mask_reg_t
id|dbr
suffix:semicolon
DECL|typedef|dbreg_t
)brace
id|dbreg_t
suffix:semicolon
multiline_comment|/*&n; * perfmon command descriptions&n; */
r_typedef
r_struct
(brace
DECL|member|cmd_func
r_int
(paren
op_star
id|cmd_func
)paren
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|cmd_name
r_char
op_star
id|cmd_name
suffix:semicolon
DECL|member|cmd_flags
r_int
id|cmd_flags
suffix:semicolon
DECL|member|cmd_narg
r_int
r_int
id|cmd_narg
suffix:semicolon
DECL|member|cmd_argsize
r_int
id|cmd_argsize
suffix:semicolon
DECL|member|cmd_getsize
r_int
(paren
op_star
id|cmd_getsize
)paren
(paren
r_void
op_star
id|arg
comma
r_int
op_star
id|sz
)paren
suffix:semicolon
DECL|typedef|pfm_cmd_desc_t
)brace
id|pfm_cmd_desc_t
suffix:semicolon
DECL|macro|PFM_CMD_FD
mdefine_line|#define PFM_CMD_FD&t;&t;0x01&t;/* command requires a file descriptor */
DECL|macro|PFM_CMD_ARG_READ
mdefine_line|#define PFM_CMD_ARG_READ&t;0x02&t;/* command must read argument(s) */
DECL|macro|PFM_CMD_ARG_RW
mdefine_line|#define PFM_CMD_ARG_RW&t;&t;0x04&t;/* command must read/write argument(s) */
DECL|macro|PFM_CMD_STOP
mdefine_line|#define PFM_CMD_STOP&t;&t;0x08&t;/* command does not work on zombie context */
DECL|macro|PFM_CMD_IDX
mdefine_line|#define PFM_CMD_IDX(cmd)&t;(cmd)
DECL|macro|PFM_CMD_IS_VALID
mdefine_line|#define PFM_CMD_IS_VALID(cmd)&t;((PFM_CMD_IDX(cmd) &gt;= 0) &amp;&amp; (PFM_CMD_IDX(cmd) &lt; PFM_CMD_COUNT) &bslash;&n;&t;&t;&t;&t;  &amp;&amp; pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_func != NULL)
DECL|macro|PFM_CMD_NAME
mdefine_line|#define PFM_CMD_NAME(cmd)&t;pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_name
DECL|macro|PFM_CMD_READ_ARG
mdefine_line|#define PFM_CMD_READ_ARG(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_READ)
DECL|macro|PFM_CMD_RW_ARG
mdefine_line|#define PFM_CMD_RW_ARG(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_RW)
DECL|macro|PFM_CMD_USE_FD
mdefine_line|#define PFM_CMD_USE_FD(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_FD)
DECL|macro|PFM_CMD_STOPPED
mdefine_line|#define PFM_CMD_STOPPED(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_STOP)
DECL|macro|PFM_CMD_ARG_MANY
mdefine_line|#define PFM_CMD_ARG_MANY&t;-1 /* cannot be zero */
DECL|macro|PFM_CMD_NARG
mdefine_line|#define PFM_CMD_NARG(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_narg)
DECL|macro|PFM_CMD_ARG_SIZE
mdefine_line|#define PFM_CMD_ARG_SIZE(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_argsize)
DECL|macro|PFM_CMD_GETSIZE
mdefine_line|#define PFM_CMD_GETSIZE(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_getsize)
r_typedef
r_struct
(brace
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* turn on/off debugging via syslog */
DECL|member|debug_ovfl
r_int
id|debug_ovfl
suffix:semicolon
multiline_comment|/* turn on/off debug printk in overflow handler */
DECL|member|fastctxsw
r_int
id|fastctxsw
suffix:semicolon
multiline_comment|/* turn on/off fast (unsecure) ctxsw */
DECL|member|debug_pfm_read
r_int
id|debug_pfm_read
suffix:semicolon
DECL|typedef|pfm_sysctl_t
)brace
id|pfm_sysctl_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|pfm_spurious_ovfl_intr_count
r_int
r_int
id|pfm_spurious_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of spurious ovfl interrupts */
DECL|member|pfm_ovfl_intr_count
r_int
r_int
id|pfm_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles
r_int
r_int
id|pfm_ovfl_intr_cycles
suffix:semicolon
multiline_comment|/* cycles spent processing ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles_min
r_int
r_int
id|pfm_ovfl_intr_cycles_min
suffix:semicolon
multiline_comment|/* min cycles spent processing ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles_max
r_int
r_int
id|pfm_ovfl_intr_cycles_max
suffix:semicolon
multiline_comment|/* max cycles spent processing ovfl interrupts */
DECL|member|pfm_sysupdt_count
r_int
r_int
id|pfm_sysupdt_count
suffix:semicolon
DECL|member|pfm_sysupdt_cycles
r_int
r_int
id|pfm_sysupdt_cycles
suffix:semicolon
DECL|member|pfm_smpl_handler_calls
r_int
r_int
id|pfm_smpl_handler_calls
suffix:semicolon
DECL|member|pfm_smpl_handler_cycles
r_int
r_int
id|pfm_smpl_handler_cycles
suffix:semicolon
DECL|member|____cacheline_aligned
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
id|____cacheline_aligned
suffix:semicolon
DECL|typedef|pfm_stats_t
)brace
id|pfm_stats_t
suffix:semicolon
multiline_comment|/*&n; * perfmon internal variables&n; */
DECL|variable|pfm_stats
r_static
id|pfm_stats_t
id|pfm_stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|pfm_sessions
r_static
id|pfm_session_t
id|pfm_sessions
suffix:semicolon
multiline_comment|/* global sessions information */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
DECL|variable|pfm_null_uuid
r_static
id|pfm_uuid_t
id|pfm_null_uuid
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|pfm_smpl_fmt_lock
r_static
id|spinlock_t
id|pfm_smpl_fmt_lock
suffix:semicolon
DECL|variable|pfm_buffer_fmt_list
r_static
id|pfm_buffer_fmt_t
op_star
id|pfm_buffer_fmt_list
suffix:semicolon
DECL|macro|LOCK_BUF_FMT_LIST
mdefine_line|#define LOCK_BUF_FMT_LIST()&t;    spin_lock(&amp;pfm_smpl_fmt_lock)
DECL|macro|UNLOCK_BUF_FMT_LIST
mdefine_line|#define UNLOCK_BUF_FMT_LIST()&t;    spin_unlock(&amp;pfm_smpl_fmt_lock)
multiline_comment|/* sysctl() controls */
DECL|variable|pfm_sysctl
r_static
id|pfm_sysctl_t
id|pfm_sysctl
suffix:semicolon
DECL|variable|pfm_debug_var
r_int
id|pfm_debug_var
suffix:semicolon
DECL|variable|pfm_ctl_table
r_static
id|ctl_table
id|pfm_ctl_table
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|pfm_sysctl_dir
r_static
id|ctl_table
id|pfm_sysctl_dir
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;perfmon&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_ctl_table
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_root
r_static
id|ctl_table
id|pfm_sysctl_root
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;kernel&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_sysctl_dir
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|pfm_sysctl_header
suffix:semicolon
r_static
r_void
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|variable|pfm_vm_ops
r_static
r_struct
id|vm_operations_struct
id|pfm_vm_ops
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; * Linux 2.5 vs. 2.4 helper macros and definitions&n; *&n; * if not at least 2.5.69, then assume 2.4.x.&n; */
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,69)
DECL|macro|PFM_COMPILED_FOR_2_4
mdefine_line|#define PFM_COMPILED_FOR_2_4 1
macro_line|#include &lt;linux/wrapper.h&gt;
DECL|macro|pfm_get_cpu_var
mdefine_line|#define pfm_get_cpu_var(v)&t;local_cpu_data-&gt;v
DECL|macro|pfm_get_cpu_data
mdefine_line|#define pfm_get_cpu_data(a,b)&t;cpu_data((b))-&gt;a
DECL|typedef|pfm_irq_handler_t
r_typedef
r_void
id|pfm_irq_handler_t
suffix:semicolon
DECL|macro|PFM_IRQ_HANDLER_RET
mdefine_line|#define PFM_IRQ_HANDLER_RET(v)
DECL|macro|DEFINE_PER_CPU
mdefine_line|#define DEFINE_PER_CPU(a,b)
r_static
r_inline
r_int
DECL|function|pfm_wait_task_inactive
id|pfm_wait_task_inactive
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Make sure the child gets off its CPU.. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|task_lock
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task_has_cpu
c_func
(paren
id|task
)paren
)paren
r_break
suffix:semicolon
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|task_has_cpu
c_func
(paren
id|task
)paren
)paren
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_put_task
id|pfm_put_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
id|free_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_task_notify
id|pfm_set_task_notify
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_task_notify
id|pfm_clear_task_notify
c_func
(paren
r_void
)paren
(brace
)brace
r_static
r_inline
r_void
DECL|function|pfm_reserve_page
id|pfm_reserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|page
op_assign
id|ia64_tpa
c_func
(paren
id|a
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unreserve_page
id|pfm_unreserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|page
op_assign
id|ia64_tpa
c_func
(paren
id|a
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_remap_page_range
id|pfm_remap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
r_return
id|remap_page_range
c_func
(paren
id|from
comma
id|phys_addr
comma
id|size
comma
id|prot
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_protect_ctx_ctxsw
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
)paren
(brace
r_int
r_int
id|f
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_unprotect_ctx_ctxsw
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
comma
r_int
r_int
id|f
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
)brace
macro_line|#else /* 2.5.69 or higher */
DECL|macro|pfm_wait_task_inactive
mdefine_line|#define pfm_wait_task_inactive(t)&t;wait_task_inactive(t)
DECL|macro|pfm_get_cpu_var
mdefine_line|#define pfm_get_cpu_var(v)&t;&t;__get_cpu_var(v)
DECL|macro|pfm_get_cpu_data
mdefine_line|#define pfm_get_cpu_data(a,b)&t;&t;per_cpu(a, b)
DECL|typedef|pfm_irq_handler_t
r_typedef
id|irqreturn_t
id|pfm_irq_handler_t
suffix:semicolon
DECL|macro|PFM_IRQ_HANDLER_RET
mdefine_line|#define PFM_IRQ_HANDLER_RET(v)&t;do {  &bslash;&n;&t;&t;put_cpu_no_resched(); &bslash;&n;&t;&t;return IRQ_HANDLED;   &bslash;&n;&t;} while(0);
r_static
r_inline
r_void
DECL|function|pfm_put_task
id|pfm_put_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
id|put_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_task_notify
id|pfm_set_task_notify
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_info
op_star
id|info
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task
op_plus
id|IA64_TASK_SIZE
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TIF_NOTIFY_RESUME
comma
op_amp
id|info-&gt;flags
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_task_notify
id|pfm_clear_task_notify
c_func
(paren
r_void
)paren
(brace
id|clear_thread_flag
c_func
(paren
id|TIF_NOTIFY_RESUME
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_reserve_page
id|pfm_reserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
id|SetPageReserved
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unreserve_page
id|pfm_unreserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_remap_page_range
id|pfm_remap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
r_return
id|remap_page_range
c_func
(paren
id|vma
comma
id|from
comma
id|phys_addr
comma
id|size
comma
id|prot
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_protect_ctx_ctxsw
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
)paren
(brace
r_int
r_int
id|f
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
r_return
l_int|0UL
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_unprotect_ctx_ctxsw
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
comma
r_int
r_int
id|f
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
)brace
macro_line|#endif /* 2.5 vs. 2.4 */
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pfm_syst_info
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|task_struct
op_star
comma
id|pmu_owner
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
id|pfm_context_t
op_star
comma
id|pmu_ctx
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pmu_activation_number
)paren
suffix:semicolon
multiline_comment|/* forward declaration */
DECL|variable|pfm_file_ops
r_static
r_struct
id|file_operations
id|pfm_file_ops
suffix:semicolon
multiline_comment|/*&n; * forward declarations&n; */
macro_line|#ifndef CONFIG_SMP
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if   defined(CONFIG_ITANIUM)
macro_line|#include &quot;perfmon_itanium.h&quot;
macro_line|#elif defined(CONFIG_MCKINLEY)
macro_line|#include &quot;perfmon_mckinley.h&quot;
macro_line|#else
macro_line|#include &quot;perfmon_generic.h&quot;
macro_line|#endif
r_static
r_int
id|pfm_end_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_pp
id|pfm_clear_psr_pp
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_pp
id|pfm_set_psr_pp
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ssm psr.pp;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_up
id|pfm_clear_psr_up
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_up
id|pfm_set_psr_up
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;sum psr.up;; srlz.i;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_psr
id|pfm_get_psr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_l
id|pfm_set_psr_l
c_func
(paren
r_int
r_int
id|val
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|val
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_freeze_pmu
id|pfm_freeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unfreeze_pmu
id|pfm_unfreeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PMD[i] must be a counter. no check is made&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_read_soft_counter
id|pfm_read_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
)paren
(brace
r_return
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PMD[i] must be a counter. no check is made&n; */
r_static
r_inline
r_void
DECL|function|pfm_write_soft_counter
id|pfm_write_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
comma
r_int
r_int
id|val
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * writing to unimplemented part is ignore, so we do not need to&n;&t; * mask off top part&n;&t; */
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
r_static
id|pfm_msg_t
op_star
DECL|function|pfm_get_new_msg
id|pfm_get_new_msg
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|idx
comma
id|next
suffix:semicolon
id|next
op_assign
(paren
id|ctx-&gt;ctx_msgq_tail
op_plus
l_int|1
)paren
op_mod
id|PFM_MAX_MSGS
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_fd=%p head=%d tail=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
id|ctx-&gt;ctx_msgq_head
)paren
r_return
l_int|NULL
suffix:semicolon
id|idx
op_assign
id|ctx-&gt;ctx_msgq_tail
suffix:semicolon
id|ctx-&gt;ctx_msgq_tail
op_assign
id|next
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d msg=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|idx
)paren
)paren
suffix:semicolon
r_return
id|ctx-&gt;ctx_msgq
op_plus
id|idx
suffix:semicolon
)brace
r_static
id|pfm_msg_t
op_star
DECL|function|pfm_get_next_msg
id|pfm_get_next_msg
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * get oldest message&n;&t; */
id|msg
op_assign
id|ctx-&gt;ctx_msgq
op_plus
id|ctx-&gt;ctx_msgq_head
suffix:semicolon
multiline_comment|/*&n;&t; * and move forward&n;&t; */
id|ctx-&gt;ctx_msgq_head
op_assign
(paren
id|ctx-&gt;ctx_msgq_head
op_plus
l_int|1
)paren
op_mod
id|PFM_MAX_MSGS
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d type=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|msg-&gt;pfm_gen_msg.msg_type
)paren
)paren
suffix:semicolon
r_return
id|msg
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_msgq
id|pfm_reset_msgq
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|ctx-&gt;ctx_msgq_head
op_assign
id|ctx-&gt;ctx_msgq_tail
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p msgq reset&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_kvirt_to_pa
id|pfm_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
op_assign
id|ia64_tpa
c_func
(paren
id|adr
)paren
suffix:semicolon
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|pfm_rvmalloc
id|pfm_rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
singleline_comment|//printk(&quot;perfmon: CPU%d pfm_rvmalloc(%ld)=%p&bslash;n&quot;, smp_processor_id(), size, mem);
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|pfm_reserve_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_rvfree
id|pfm_rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;freeing physical buffer @%p size=%lu&bslash;n&quot;
comma
id|mem
comma
id|size
)paren
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|size
OG
l_int|0
)paren
(brace
id|pfm_unreserve_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
id|pfm_context_t
op_star
DECL|function|pfm_context_alloc
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
multiline_comment|/* allocate context descriptor */
id|ctx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pfm_context_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_context_t
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;alloc ctx @%p&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
)brace
r_return
id|ctx
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_context_free
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;free ctx @%p&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|pfm_mask_monitoring
id|pfm_mask_monitoring
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] masking monitoring for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * monitoring can only be masked as a result of a valid&n;&t; * counter overflow. In UP, it means that the PMU still&n;&t; * has an owner. Note that the owner can be different&n;&t; * from the current task. However the PMU state belongs&n;&t; * to the owner.&n;&t; * In SMP, a valid overflow only happens when task is&n;&t; * current. Therefore if we come here, we know that&n;&t; * the PMU state belongs to the current task, therefore&n;&t; * we can access the live registers.&n;&t; *&n;&t; * So in both cases, the live register contains the owner&squot;s&n;&t; * state. We can ONLY touch the PMU registers and NOT the PSR.&n;&t; *&n;&t; * As a consequence to this call, the thread-&gt;pmds[] array&n;&t; * contains stale information which must be ignored&n;&t; * when context is reloaded AND monitoring is active (see&n;&t; * pfm_restart).&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * we rebuild the full 64 bit value of the counter&n;&t;&t; &t; */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
(paren
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * mask monitoring by setting the privilege level to 0&n;&t; * we cannot use psr.pp/psr.up for this, it is controlled by&n;&t; * the user&n;&t; *&n;&t; * if task is current, modify actual registers, otherwise modify&n;&t; * thread save state, i.e., what will be restored in pfm_load_regs()&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
op_amp
op_complement
l_int|0xfUL
)paren
suffix:semicolon
id|th-&gt;pmcs
(braket
id|i
)braket
op_and_assign
op_complement
l_int|0xfUL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make all of this visible&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * must always be done with task == current&n; *&n; * context must be in MASKED state when calling&n; */
r_static
r_void
DECL|function|pfm_restore_monitoring
id|pfm_restore_monitoring
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|psr
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon.%d: invalid task[%d] current[%d]&bslash;n&quot;
comma
id|__LINE__
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon.%d: task[%d] current[%d] invalid state=%d&bslash;n&quot;
comma
id|__LINE__
comma
id|task-&gt;pid
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * monitoring is masked via the PMC.&n;&t; * As we restore their value, we do not want each counter to&n;&t; * restart right away. We stop monitoring using the PSR,&n;&t; * restore the PMC (and PMD) and then re-establish the psr&n;&t; * as it was. Note that there can be no pending overflow at&n;&t; * this point, because monitoring was MASKED.&n;&t; *&n;&t; * system-wide session are pinned and self-monitoring&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
(paren
id|PFM_CPUINFO_GET
c_func
(paren
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
)paren
)paren
(brace
multiline_comment|/* disable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * first, we restore the PMD&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we split the 64bit value according to&n;&t;&t;&t; * counter width&n;&t;&t;&t; */
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_amp
id|pmu_conf.ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_and_assign
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
)brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restore the PMCs&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|th-&gt;pmcs
(braket
id|i
)braket
op_assign
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%d]=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now restore PSR&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
(paren
id|PFM_CPUINFO_GET
c_func
(paren
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
)paren
)paren
(brace
multiline_comment|/* enable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_save_pmds
id|pfm_save_pmds
c_func
(paren
r_int
r_int
op_star
id|pmds
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|pmds
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * reload from thread state (used for ctxw only)&n; */
r_static
r_inline
r_void
DECL|function|pfm_restore_pmds
id|pfm_restore_pmds
c_func
(paren
r_int
r_int
op_star
id|pmds
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|val
comma
id|ovfl_val
op_assign
id|pmu_conf.ovfl_val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
ques
c_cond
id|pmds
(braket
id|i
)braket
op_amp
id|ovfl_val
suffix:colon
id|pmds
(braket
id|i
)braket
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * propagate PMD from context to thread-state&n; */
r_static
r_inline
r_void
DECL|function|pfm_copy_pmds
id|pfm_copy_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|ovfl_val
op_assign
id|pmu_conf.ovfl_val
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We break up the 64 bit value into 2 pieces&n;&t;&t; * the lower bits go to the machine state in the&n;&t;&t; * thread (will be reloaded on ctxsw in).&n;&t;&t; * The upper part stays in the soft-counter.&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|ovfl_val
suffix:semicolon
id|val
op_and_assign
id|ovfl_val
suffix:semicolon
)brace
id|thread-&gt;pmds
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx soft_val=0x%lx&bslash;n&quot;
comma
id|i
comma
id|thread-&gt;pmds
(braket
id|i
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * propagate PMC from context to thread-state&n; */
r_static
r_inline
r_void
DECL|function|pfm_copy_pmcs
id|pfm_copy_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* masking 0 with ovfl_val yields 0 */
id|thread-&gt;pmcs
(braket
id|i
)braket
op_assign
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|thread-&gt;pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_pmcs
id|pfm_restore_pmcs
c_func
(paren
r_int
r_int
op_star
id|pmcs
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_ibrs
id|pfm_restore_ibrs
c_func
(paren
r_int
r_int
op_star
id|ibrs
comma
r_int
r_int
id|nibrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
id|ibrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_dbrs
id|pfm_restore_dbrs
c_func
(paren
r_int
r_int
op_star
id|dbrs
comma
r_int
r_int
id|ndbrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
id|dbrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_uuid_cmp
id|pfm_uuid_cmp
c_func
(paren
id|pfm_uuid_t
id|a
comma
id|pfm_uuid_t
id|b
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|a
comma
id|b
comma
r_sizeof
(paren
id|pfm_uuid_t
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_exit
id|pfm_buf_fmt_exit
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_exit
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_exit
)paren
(paren
id|task
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_getsize
id|pfm_buf_fmt_getsize
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_getsize
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_getsize
)paren
(paren
id|task
comma
id|flags
comma
id|cpu
comma
id|arg
comma
id|size
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_validate
id|pfm_buf_fmt_validate
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_validate
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_validate
)paren
(paren
id|task
comma
id|flags
comma
id|cpu
comma
id|arg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_init
id|pfm_buf_fmt_init
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_init
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_init
)paren
(paren
id|task
comma
id|buf
comma
id|flags
comma
id|cpu
comma
id|arg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_restart
id|pfm_buf_fmt_restart
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_ovfl_ctrl_t
op_star
id|ctrl
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_restart
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_restart
)paren
(paren
id|task
comma
id|ctrl
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_restart_active
id|pfm_buf_fmt_restart_active
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_ovfl_ctrl_t
op_star
id|ctrl
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_restart_active
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_restart_active
)paren
(paren
id|task
comma
id|ctrl
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|pfm_register_buffer_fmt
id|pfm_register_buffer_fmt
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some sanity checks */
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
op_logical_or
id|fmt-&gt;fmt_name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we need at least a handler */
r_if
c_cond
(paren
id|fmt-&gt;fmt_handler
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: need check validity of fmt_arg_size&n;&t; */
id|LOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|pfm_buffer_fmt_list
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|pfm_uuid_cmp
c_func
(paren
id|fmt-&gt;fmt_uuid
comma
id|p-&gt;fmt_uuid
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|p
op_assign
id|p-&gt;fmt_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: duplicate sampling format: %s&bslash;n&quot;
comma
id|fmt-&gt;fmt_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|fmt-&gt;fmt_prev
op_assign
l_int|NULL
suffix:semicolon
id|fmt-&gt;fmt_next
op_assign
id|pfm_buffer_fmt_list
suffix:semicolon
id|pfm_buffer_fmt_list
op_assign
id|fmt
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: added sampling format %s&bslash;n&quot;
comma
id|fmt-&gt;fmt_name
)paren
suffix:semicolon
)brace
id|UNLOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|pfm_unregister_buffer_fmt
id|pfm_unregister_buffer_fmt
c_func
(paren
id|pfm_uuid_t
id|uuid
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|LOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|pfm_buffer_fmt_list
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|uuid
comma
id|p-&gt;fmt_uuid
comma
r_sizeof
(paren
id|pfm_uuid_t
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|p
op_assign
id|p-&gt;fmt_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;fmt_prev
)paren
id|p-&gt;fmt_prev-&gt;fmt_next
op_assign
id|p-&gt;fmt_next
suffix:semicolon
r_else
id|pfm_buffer_fmt_list
op_assign
id|p-&gt;fmt_next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;fmt_next
)paren
id|p-&gt;fmt_next-&gt;fmt_prev
op_assign
id|p-&gt;fmt_prev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: removed sampling format: %s&bslash;n&quot;
comma
id|p-&gt;fmt_name
)paren
suffix:semicolon
id|p-&gt;fmt_next
op_assign
id|p-&gt;fmt_prev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: cannot unregister format, not found&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|UNLOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * find a buffer format based on its uuid&n; */
r_static
id|pfm_buffer_fmt_t
op_star
DECL|function|pfm_find_buffer_fmt
id|pfm_find_buffer_fmt
c_func
(paren
id|pfm_uuid_t
id|uuid
comma
r_int
id|nolock
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|p
suffix:semicolon
id|LOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|pfm_buffer_fmt_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;fmt_next
)paren
(brace
r_if
c_cond
(paren
id|pfm_uuid_cmp
c_func
(paren
id|uuid
comma
id|p-&gt;fmt_uuid
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|UNLOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_reserve_session
id|pfm_reserve_session
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu
)paren
(brace
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
multiline_comment|/*&n;&t;&t; * cannot mix system wide and per-task sessions&n;&t;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_task_sessions
OG
l_int|0UL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide not possible, %u conflicting task_sessions&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
)paren
r_goto
id|error_conflict
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;reserving system wide session on CPU%u currently on CPU%u&bslash;n&quot;
comma
id|cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
id|task
suffix:semicolon
id|pfm_sessions.pfs_sys_sessions
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_sessions
)paren
r_goto
m_abort
suffix:semicolon
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_conflict
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide not possible, conflicting session [%d] on CPU%d&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_member_access_from_pointer
id|pid
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
m_abort
suffix:colon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_unreserve_session
id|pfm_unreserve_session
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu
)paren
(brace
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * would not work with perfmon+more than one bit in cpu_mask&n;&t;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: invalid release for ctx %p sys_use_dbregs=0&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
)brace
id|pfm_sessions.pfs_sys_sessions
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_task_sessions
op_decrement
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * removes virtual mapping of the sampling buffer.&n; * IMPORTANT: cannot be called with interrupts disable, e.g. inside&n; * a PROTECT_CTX() section.&n; */
r_static
r_int
DECL|function|pfm_remove_smpl_mapping
id|pfm_remove_smpl_mapping
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|vaddr
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|task-&gt;mm
op_eq
l_int|NULL
op_logical_or
id|size
op_eq
l_int|0UL
op_logical_or
id|vaddr
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_remove_smpl_mapping [%d] invalid context mm=%p&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;mm
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;smpl_vaddr=%p size=%lu&bslash;n&quot;
comma
id|vaddr
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * does the actual unmapping&n;&t; */
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;down_write done smpl_vaddr=%p size=%lu&bslash;n&quot;
comma
id|vaddr
comma
id|size
)paren
)paren
suffix:semicolon
id|r
op_assign
id|do_munmap
c_func
(paren
id|task-&gt;mm
comma
(paren
r_int
r_int
)paren
id|vaddr
comma
id|size
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] unable to unmap sampling buffer @%p size=%lu&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|vaddr
comma
id|size
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_unmap(%p, %lu)=%d&bslash;n&quot;
comma
id|vaddr
comma
id|size
comma
id|r
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * free actual physical storage used by sampling buffer&n; */
macro_line|#if 0
r_static
r_int
id|pfm_free_smpl_buffer
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_hdr
op_eq
l_int|NULL
)paren
r_goto
id|invalid_free
suffix:semicolon
multiline_comment|/*&n;&t; * we won&squot;t use the buffer format anymore&n;&t; */
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;sampling buffer @%p size %lu vaddr=%p&bslash;n&quot;
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_smpl_size
comma
id|ctx-&gt;ctx_smpl_vaddr
)paren
)paren
suffix:semicolon
id|pfm_buf_fmt_exit
c_func
(paren
id|fmt
comma
id|current
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free the buffer&n;&t; */
id|pfm_rvfree
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_smpl_size
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_hdr
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_smpl_size
op_assign
l_int|0UL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|invalid_free
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_free_smpl_buffer [%d] no buffer&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
r_void
DECL|function|pfm_exit_smpl_buffer
id|pfm_exit_smpl_buffer
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
)paren
(brace
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|pfm_buf_fmt_exit
c_func
(paren
id|fmt
comma
id|current
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pfmfs should _never_ be mounted by userland - too much of security hassle,&n; * no real gain from having the whole whorehouse mounted. So we don&squot;t need&n; * any operations on the root directory. However, we need a non-trivial&n; * d_name - pfm: will go nicely and kill the special-casing in procfs.&n; */
DECL|variable|pfmfs_mnt
r_static
r_struct
id|vfsmount
op_star
id|pfmfs_mnt
suffix:semicolon
DECL|macro|PFMFS_MAGIC
mdefine_line|#define PFMFS_MAGIC 0xa0b4d889
macro_line|#ifdef PFM_COMPILED_FOR_2_4
r_static
r_int
DECL|function|pfmfs_statfs
id|pfmfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|buf-&gt;f_type
op_assign
id|PFMFS_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
l_int|1024
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
l_int|255
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfmfs_ops
r_static
r_struct
id|super_operations
id|pfmfs_ops
op_assign
(brace
id|statfs
suffix:colon
id|pfmfs_statfs
comma
)brace
suffix:semicolon
r_static
r_struct
id|super_block
op_star
DECL|function|pfmfs_read_super
id|pfmfs_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|root
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
r_return
l_int|NULL
suffix:semicolon
id|root-&gt;i_mode
op_assign
id|S_IFDIR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|root-&gt;i_uid
op_assign
id|root-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
id|root-&gt;i_atime
op_assign
id|root-&gt;i_mtime
op_assign
id|root-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
l_int|1024
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
l_int|10
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|PFMFS_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|pfmfs_ops
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|d_alloc
c_func
(paren
l_int|NULL
comma
op_amp
(paren
r_const
r_struct
id|qstr
)paren
(brace
l_string|&quot;pfm:&quot;
comma
l_int|4
comma
l_int|0
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
(brace
id|iput
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;s_root-&gt;d_sb
op_assign
id|sb
suffix:semicolon
id|sb-&gt;s_root-&gt;d_parent
op_assign
id|sb-&gt;s_root
suffix:semicolon
id|d_instantiate
c_func
(paren
id|sb-&gt;s_root
comma
id|root
)paren
suffix:semicolon
r_return
id|sb
suffix:semicolon
)brace
singleline_comment|//static DECLARE_FSTYPE(pfm_fs_type, &quot;pfmfs&quot;, pfmfs_read_super, FS_NOMOUNT);
DECL|variable|pfm_fs_type
r_static
r_struct
id|file_system_type
id|pfm_fs_type
op_assign
(brace
id|name
suffix:colon
l_string|&quot;pfmfs&quot;
comma
id|read_super
suffix:colon
id|pfmfs_read_super
comma
id|fs_flags
suffix:colon
id|FS_NOMOUNT
comma
)brace
suffix:semicolon
macro_line|#else /* ! COMPILED_FOR_2_4 */
r_static
r_struct
id|super_block
op_star
DECL|function|pfmfs_get_sb
id|pfmfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_pseudo
c_func
(paren
id|fs_type
comma
l_string|&quot;pfm:&quot;
comma
l_int|NULL
comma
id|PFMFS_MAGIC
)paren
suffix:semicolon
)brace
DECL|variable|pfm_fs_type
r_static
r_struct
id|file_system_type
id|pfm_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;pfmfs&quot;
comma
dot
id|get_sb
op_assign
id|pfmfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
macro_line|#endif /* COMPILED_FOR_2_4 */
r_static
r_int
id|__init
DECL|function|init_pfm_fs
id|init_pfm_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|pfmfs_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pfmfs_mnt
)paren
)paren
id|unregister_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
r_else
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|exit_pfm_fs
id|exit_pfm_fs
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
)brace
r_static
id|loff_t
DECL|function|pfm_lseek
id|pfm_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|whence
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_lseek called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|pfm_do_read
id|pfm_do_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_read: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check even when there is no message&n;&t; */
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;message is too small ctx=%p (&gt;=%ld)&bslash;n&quot;
comma
id|ctx
comma
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * seeks are not allowed on message queues&n;&t; */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|filp-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * put ourselves on the wait queue&n;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * check wait queue&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;head=%d tail=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check non-blocking read&n;&t;&t; */
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * check pending signals&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no message, so wait&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] back to running ret=%ld&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
m_abort
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
id|pfm_get_next_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_read no msg for ctx=%p [%d]&bslash;n&quot;
comma
id|ctx
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_goto
id|abort_locked
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] fd=%d type=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|msg-&gt;pfm_gen_msg.msg_ctx_fd
comma
id|msg-&gt;pfm_gen_msg.msg_type
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|msg
comma
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
r_sizeof
(paren
id|pfm_msg_t
)paren
suffix:semicolon
)brace
id|abort_locked
suffix:colon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|pfm_read
id|pfm_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|oldvar
comma
id|ret
suffix:semicolon
id|oldvar
op_assign
id|pfm_debug_var
suffix:semicolon
id|pfm_debug_var
op_assign
id|pfm_sysctl.debug_pfm_read
suffix:semicolon
id|ret
op_assign
id|pfm_do_read
c_func
(paren
id|filp
comma
id|buf
comma
id|size
comma
id|ppos
)paren
suffix:semicolon
id|pfm_debug_var
op_assign
id|oldvar
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|pfm_write
id|pfm_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_write called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|pfm_poll
id|pfm_poll
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_poll ctx_fd=%d before poll_wait&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
)paren
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
id|wait
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
id|mask
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_poll ctx_fd=%d mask=0x%x&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ioctl
id|pfm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_ioctl called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * context is locked when coming here&n; */
r_static
r_inline
r_int
DECL|function|pfm_do_fasync
id|pfm_do_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|on
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|fasync_helper
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|ctx-&gt;ctx_async_queue
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_fasync called by [%d] on ctx_fd=%d on=%d async_queue=%p ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
comma
id|on
comma
id|ctx-&gt;ctx_async_queue
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_fasync
id|pfm_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_fasync bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_fasync NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_do_fasync
c_func
(paren
id|fd
comma
id|filp
comma
id|ctx
comma
id|on
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_fasync called by [%d] on ctx_fd=%d on=%d async_queue=%p ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
comma
id|on
comma
id|ctx-&gt;ctx_async_queue
comma
id|ret
)paren
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * this function is exclusively called from pfm_close().&n; * The context is not protected at that time, nor are interrupts&n; * on the remote CPU. That&squot;s necessary to avoid deadlocks.&n; */
r_static
r_void
DECL|function|pfm_syswide_force_stop
id|pfm_syswide_force_stop
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|info
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|current
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop for CPU%d  but on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|owner
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|owner
op_ne
id|ctx-&gt;ctx_task
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected owner [%d] instead of [%d]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|owner-&gt;pid
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_PMU_CTX
c_func
(paren
)paren
op_ne
id|ctx
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected ctx %p instead of %p&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|GET_PMU_CTX
c_func
(paren
)paren
comma
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] on CPU%d forcing system wide stop for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update local PMU&n;&t; */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * update local cpuinfo&n;&t; */
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * also stop monitoring in the local interrupted task&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_syswide_cleanup_other_cpu
id|pfm_syswide_cleanup_other_cpu
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|ret
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] calling CPU%d for cleanup&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|smp_call_function_single
c_func
(paren
id|ctx-&gt;ctx_cpu
comma
id|pfm_syswide_force_stop
comma
id|ctx
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] called CPU%d for cleanup ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * called either on explicit close() or from exit_files().&n; *&n; * IMPORTANT: we get called ONLY when the refcnt on the file gets to zero (fput()),i.e,&n; * last task to access the file. Nobody else can access the file at this point.&n; *&n; * When called from exit_files(), the VMA has been freed because exit_mm()&n; * is executed before exit_files().&n; *&n; * When called from exit_files(), the current task is not yet ZOMBIE but we will&n; * flush the PMU state to the context. This means * that when we see the context&n; * state as TERMINATED we are guranteed to have the latest PMU state available,&n; * even if the task itself is in the middle of being ctxsw out.&n; */
r_static
r_int
id|pfm_context_unload
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
DECL|function|pfm_close
id|pfm_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|smpl_buf_size
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|smpl_buf_vaddr
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|smpl_buf_addr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|free_possible
op_assign
l_int|1
suffix:semicolon
(brace
id|u64
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
op_eq
l_int|0UL
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_close called private=%p&bslash;n&quot;
comma
id|filp-&gt;private_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pfm_close: NULL inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_close: bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_close: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * remove our file from the async queue, if we use it&n;&t; */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|FASYNC
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] before async_queue=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_async_queue
)paren
)paren
suffix:semicolon
id|pfm_do_fasync
(paren
op_minus
l_int|1
comma
id|filp
comma
id|ctx
comma
l_int|0
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] after async_queue=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_async_queue
)paren
)paren
suffix:semicolon
)brace
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] ctx_state=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_UNLOADED
c_func
(paren
id|ctx
)paren
op_logical_or
id|CTX_IS_TERMINATED
c_func
(paren
id|ctx
)paren
)paren
(brace
r_goto
id|doit
suffix:semicolon
)brace
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * context still loaded/masked and self monitoring,&n;&t; * we stop/unload and we destroy right here&n;&t; *&n;&t; * We always go here for system-wide sessions&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t; * the task IS the owner but it migrated to another CPU: that&squot;s bad&n;&t;&t; * but we must handle this cleanly. Unfortunately, the kernel does&n;&t;&t; * not provide a mechanism to block migration (while the context is loaded).&n;&t;&t; *&n;&t;&t; * We need to release the resource on the ORIGINAL cpu.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_syswide_cleanup_other_cpu
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * short circuit pfm_context_unload();&n;&t;&t;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
id|CTX_UNLOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
l_int|1
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* CONFIG_SMP */
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;forcing unload on [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t;* stop and unload, returning with state UNLOADED&n;&t;&t; &t;* and session unreserved.&n;&t;&t; &t;*/
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
id|CTX_TERMINATED
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] ctx_state=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
)brace
r_goto
id|doit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The task is currently blocked or will block after an overflow.&n;&t; * we must force it to wakeup to get out of the&n;&t; * MASKED state and transition to the unloaded state by itself&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
op_logical_and
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * set a &quot;partial&quot; zombie state to be checked&n;&t;&t; * upon return from down() in pfm_handle_work().&n;&t;&t; *&n;&t;&t; * We cannot use the ZOMBIE state, because it is checked&n;&t;&t; * by pfm_load_regs() which is called upon wakeup from down().&n;&t;&t; * In such cas, it would free the context and then we would&n;&t;&t; * return to pfm_handle_work() which would access the&n;&t;&t; * stale context. Instead, we set a flag invisible to pfm_load_regs()&n;&t;&t; * but visible to pfm_handle_work().&n;&t;&t; *&n;&t;&t; * For some window of time, we have a zombie context with&n;&t;&t; * ctx_state = MASKED  and not ZOMBIE&n;&t;&t; */
id|ctx-&gt;ctx_fl_going_zombie
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * force task to wake up from MASKED state&n;&t;&t; */
id|up
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;waking up ctx_state=%d for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * put ourself to sleep waiting for the other&n;&t;&t; * task to report completion&n;&t;&t; *&n;&t;&t; * the context is protected by mutex, therefore there&n;&t;&t; * is no risk of being notified of completion before&n;&t;&t; * begin actually on the waitq.&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: check for signals :&n;&t;&t; * &t;- ok of explicit close&n;&t;&t; * &t;- not ok when coming from exit_files()&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;woken up ctx_state=%d for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * context is terminated at this point&n;&t;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;after zombie wakeup ctx_state=%d for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; &t; * switch context to zombie state&n;&t; &t; */
id|CTX_ZOMBIE
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;zombie ctx for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cannot free the context on the spot. deferred until&n;&t;&t; * the task notices the ZOMBIE state&n;&t;&t; */
id|free_possible
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
id|doit
suffix:colon
multiline_comment|/* cannot assume task is defined from now on */
multiline_comment|/*&n;&t; * the context is still attached to a task (possibly current)&n;&t; * we cannot destroy it right now&n;&t; */
multiline_comment|/*&n;&t; * remove virtual mapping, if any. will be NULL when&n;&t; * called from exit_files().&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_vaddr
)paren
(brace
id|smpl_buf_vaddr
op_assign
id|ctx-&gt;ctx_smpl_vaddr
suffix:semicolon
id|smpl_buf_size
op_assign
id|ctx-&gt;ctx_smpl_size
suffix:semicolon
id|ctx-&gt;ctx_smpl_vaddr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we must fre the sampling buffer right here because&n;&t; * we cannot rely on it being cleaned up later by the&n;&t; * monitored task. It is not possible to free vmalloc&squot;ed&n;&t; * memory in pfm_load_regs(). Instead, we remove the buffer&n;&t; * now. should there be subsequent PMU overflow originally&n;&t; * meant for sampling, the will be converted to spurious&n;&t; * and that&squot;s fine because the monitoring tools is gone anyway.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
(brace
id|smpl_buf_addr
op_assign
id|ctx-&gt;ctx_smpl_hdr
suffix:semicolon
id|smpl_buf_size
op_assign
id|ctx-&gt;ctx_smpl_size
suffix:semicolon
multiline_comment|/* no more sampling */
id|ctx-&gt;ctx_smpl_hdr
op_assign
l_int|NULL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] ctx_state=%d free_possible=%d vaddr=%p addr=%p size=%lu&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
comma
id|free_possible
comma
id|smpl_buf_vaddr
comma
id|smpl_buf_addr
comma
id|smpl_buf_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf_addr
)paren
id|pfm_exit_smpl_buffer
c_func
(paren
id|ctx-&gt;ctx_buf_fmt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * UNLOADED and TERMINATED mean that the session has already been&n;&t; * unreserved.&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
(brace
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_fl_system
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disconnect file descriptor from context must be done&n;&t; * before we unlock.&n;&t; */
id|filp-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * if we free on the spot, the context is now completely unreacheable&n;&t; * from the callers side. The monitored task side is also cut, so we&n;&t; * can freely cut.&n;&t; *&n;&t; * If we have a deferred free, only the caller side is disconnected.&n;&t; */
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if there was a mapping, then we systematically remove it&n;&t; * at this point. Cannot be done inside critical section&n;&t; * because some VM function reenables interrupts.&n;&t; *&n;&t; * All memory free operations (especially for vmalloc&squot;ed memory)&n;&t; * MUST be done with interrupts ENABLED.&n;&t; */
r_if
c_cond
(paren
id|smpl_buf_vaddr
)paren
id|pfm_remove_smpl_mapping
c_func
(paren
id|current
comma
id|smpl_buf_vaddr
comma
id|smpl_buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf_addr
)paren
id|pfm_rvfree
c_func
(paren
id|smpl_buf_addr
comma
id|smpl_buf_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * return the memory used by the context&n;&t; */
r_if
c_cond
(paren
id|free_possible
)paren
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_no_open
id|pfm_no_open
c_func
(paren
r_struct
id|inode
op_star
id|irrelevant
comma
r_struct
id|file
op_star
id|dontcare
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_no_open called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|variable|pfm_file_ops
r_static
r_struct
id|file_operations
id|pfm_file_ops
op_assign
(brace
dot
id|llseek
op_assign
id|pfm_lseek
comma
dot
id|read
op_assign
id|pfm_read
comma
dot
id|write
op_assign
id|pfm_write
comma
dot
id|poll
op_assign
id|pfm_poll
comma
dot
id|ioctl
op_assign
id|pfm_ioctl
comma
dot
id|open
op_assign
id|pfm_no_open
comma
multiline_comment|/* special open code to disallow open via /proc */
dot
id|fasync
op_assign
id|pfm_fasync
comma
dot
id|release
op_assign
id|pfm_close
)brace
suffix:semicolon
r_static
r_int
DECL|function|pfmfs_delete_dentry
id|pfmfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|pfmfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|pfmfs_dentry_operations
op_assign
(brace
id|d_delete
suffix:colon
id|pfmfs_delete_dentry
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|pfm_alloc_fd
id|pfm_alloc_fd
c_func
(paren
r_struct
id|file
op_star
op_star
id|cfile
)paren
(brace
r_int
id|fd
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
id|fd
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
id|ret
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a new inode&n;&t; */
id|inode
op_assign
id|new_inode
c_func
(paren
id|pfmfs_mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;new inode ino=%ld @%p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode
)paren
)paren
suffix:semicolon
id|inode-&gt;i_sb
op_assign
id|pfmfs_mnt-&gt;mnt_sb
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IFCHR
op_or
id|S_IRUGO
suffix:semicolon
id|inode-&gt;i_sock
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a new dcache entry&n;&t; */
id|file-&gt;f_dentry
op_assign
id|d_alloc
c_func
(paren
id|pfmfs_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_dentry
)paren
r_goto
id|out
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_op
op_assign
op_amp
id|pfmfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|file-&gt;f_dentry
comma
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|pfm_file_ops
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_READ
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * may have to delay until context is attached?&n;&t; */
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the file structure we will use&n;&t; */
op_star
id|cfile
op_assign
id|file
suffix:semicolon
r_return
id|fd
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|file
)paren
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_free_fd
id|pfm_free_fd
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|file
)paren
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called from mm/mmap.c:exit_mmap() only when there is a sampling buffer&n; * attached to the context AND the current task has a mapping for it, i.e., it is the original&n; * creator of the context.&n; *&n; * This function is used to remember the fact that the vma describing the sampling buffer&n; * has now been removed. It can only be called when no other tasks share the same mm context.&n; *&n; */
r_static
r_void
DECL|function|pfm_vm_close
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|vma-&gt;vm_private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_vaddr
op_assign
l_int|NULL
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] clearing vaddr for ctx %p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_remap_buffer
id|pfm_remap_buffer
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;CPU%d buf=0x%lx addr=0x%lx size=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|buf
comma
id|addr
comma
id|size
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|pfm_kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_remap_page_range
c_func
(paren
id|vma
comma
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_READONLY
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * allocate a sampling buffer and remaps it into the user address space of the task&n; */
r_static
r_int
DECL|function|pfm_smpl_buffer_alloc
id|pfm_smpl_buffer_alloc
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|rsize
comma
r_void
op_star
op_star
id|user_vaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|task-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
multiline_comment|/*&n;&t; * the fixed header + requested size and align to page boundary&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|rsize
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;sampling buffer rsize=%lu size=%lu bytes&bslash;n&quot;
comma
id|rsize
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&n;&t; * Check against address space limit.&n;&t; *&n;&t; * if ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len&gt; task-&gt;rlim[RLIMIT_AS].rlim_cur)&n;&t; * &t;return -ENOMEM;&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|task-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/*&n;&t; * We do the easy to undo allocations first.&n; &t; *&n;&t; * pfm_rvmalloc(), clears the buffer, so there is no leak&n;&t; */
id|smpl_buf
op_assign
id|pfm_rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d]  smpl_buf @%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error_kmem
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * partially initialize the vma for the sampling buffer&n;&t; *&n;&t; * The VM_DONTCOPY flag is very important as it ensures that the mapping&n;&t; * will never be inherited for any child process (via fork()) which is always&n;&t; * what we want.&n;&t; */
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|VM_READ
op_or
id|VM_MAYREAD
op_or
id|VM_RESERVED
op_or
id|VM_DONTCOPY
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
multiline_comment|/* XXX may need to change */
id|vma-&gt;vm_ops
op_assign
op_amp
id|pfm_vm_ops
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
id|ctx
suffix:semicolon
multiline_comment|/* information needed by the pfm_vm_close() function */
multiline_comment|/*&n;&t; * Now we have everything we need and we can initialize&n;&t; * and connect all the data structures&n;&t; */
id|ctx-&gt;ctx_smpl_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|ctx-&gt;ctx_smpl_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
multiline_comment|/*&n;&t; * Let&squot;s do the difficult operations next.&n;&t; *&n;&t; * now we atomically find some area in the address space and&n;&t; * remap the buffer in it.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* find some free area in address space, must have mmap sem held */
id|vma-&gt;vm_start
op_assign
id|get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_eq
l_int|0UL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|vma-&gt;vm_start
op_plus
id|size
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;aligned size=%ld, hdr=%p mapped @0x%lx&bslash;n&quot;
comma
id|size
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|vma-&gt;vm_start
)paren
)paren
suffix:semicolon
multiline_comment|/* can only be applied to current task, need to have the mm semaphore held when called */
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
id|vma
comma
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|vma-&gt;vm_start
comma
id|size
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process, must be&n;&t; * done with mmap lock held&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep track of user level virtual address&n;&t; */
id|ctx-&gt;ctx_smpl_vaddr
op_assign
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|user_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|error_kmem
suffix:colon
id|pfm_rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
DECL|function|pfm_bad_permissions
id|pfm_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* stolen from bad_signal() */
r_return
(paren
id|current-&gt;session
op_ne
id|task-&gt;session
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;uid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;uid
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfarg_is_sane
id|pfarg_is_sane
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_context_t
op_star
id|pfx
)paren
(brace
r_int
id|ctx_flags
suffix:semicolon
multiline_comment|/* valid signal */
id|ctx_flags
op_assign
id|pfx-&gt;ctx_flags
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
multiline_comment|/*&n;&t;&t; * cannot block in this mode&n;&t;&t; */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode when in system wide monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
)brace
multiline_comment|/* probably more to add here */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_setup_buffer_fmt
id|pfm_setup_buffer_fmt
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ctx_flags
comma
r_int
r_int
id|cpu
comma
id|pfarg_context_t
op_star
id|arg
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|fmt_arg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
DECL|macro|PFM_CTXARG_BUF_ARG
mdefine_line|#define PFM_CTXARG_BUF_ARG(a)&t;(pfm_buffer_fmt_t *)(a+1)
multiline_comment|/* invoke and lock buffer format, if found */
id|fmt
op_assign
id|pfm_find_buffer_fmt
c_func
(paren
id|arg-&gt;ctx_smpl_buf_id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot find buffer format&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * buffer argument MUST be contiguous to pfarg_context_t&n;&t; */
r_if
c_cond
(paren
id|fmt-&gt;fmt_arg_size
)paren
id|fmt_arg
op_assign
id|PFM_CTXARG_BUF_ARG
c_func
(paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_buf_fmt_validate
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] after validate(0x%x,%d,%p)=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* link buffer format and context */
id|ctx-&gt;ctx_buf_fmt
op_assign
id|fmt
suffix:semicolon
multiline_comment|/*&n;&t; * check if buffer format wants to use perfmon buffer allocation/mapping service&n;&t; */
id|ret
op_assign
id|pfm_buf_fmt_getsize
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
multiline_comment|/*&n;&t;&t; * buffer is always remapped into the caller&squot;s address space&n;&t;&t; */
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|current
comma
id|ctx
comma
id|size
comma
op_amp
id|uaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* keep track of user address of buffer */
id|arg-&gt;ctx_smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_buf_fmt_init
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_pmu_state
id|pfm_reset_pmu_state
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * install reset values for PMC.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * PMD registers are set to 0UL when the context in memset()&n;&t; */
multiline_comment|/*&n;&t; * On context switched restore, we must restore ALL pmc and ALL pmd even&n;&t; * when they are not actively used by the task. In UP, the incoming process&n;&t; * may otherwise pick up left over PMC, PMD state from the previous process.&n;&t; * As opposed to PMD, stale PMC can cause harm to the incoming&n;&t; * process because they may change what is being measured.&n;&t; * Therefore, we must systematically reinstall the entire&n;&t; * PMC state. In SMP, the same thing is possible on the&n;&t; * same CPU but also on between 2 CPUs.&n;&t; *&n;&t; * The problem with PMD is information leaking especially&n;&t; * to user level when psr.sp=0&n;&t; *&n;&t; * There is unfortunately no easy way to avoid this problem&n;&t; * on either UP or SMP. This definitively slows down the&n;&t; * pfm_load_regs() function.&n;&t; */
multiline_comment|/*&n;&t;  * bitmask of all PMCs accessible to this context&n;&t;  *&n;&t;  * PMC0 is treated differently.&n;&t;  */
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
op_assign
id|pmu_conf.impl_pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
suffix:semicolon
multiline_comment|/*&n;&t; * bitmask of all PMDs that are accesible to this context&n;&t; */
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
op_assign
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;&lt;%d&gt; all_pmcs=0x%lx all_pmds=0x%lx&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * useful in case of re-enable after disable&n;&t; */
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ctx_getsize
id|pfm_ctx_getsize
c_func
(paren
r_void
op_star
id|arg
comma
r_int
op_star
id|sz
)paren
(brace
id|pfarg_context_t
op_star
id|req
op_assign
(paren
id|pfarg_context_t
op_star
)paren
id|arg
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
op_star
id|sz
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfm_uuid_cmp
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
comma
id|pfm_null_uuid
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no buffer locking here, will be called again */
id|fmt
op_assign
id|pfm_find_buffer_fmt
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot find buffer format&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* get just enough to copy in user parameters */
op_star
id|sz
op_assign
id|fmt-&gt;fmt_arg_size
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;arg_size=%lu&bslash;n&quot;
comma
op_star
id|sz
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cannot attach if :&n; * &t;- kernel task&n; * &t;- task not owned by caller&n; * &t;- task incompatible with context mode&n; */
r_static
r_int
DECL|function|pfm_task_incompatible
id|pfm_task_incompatible
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/*&n;&t; * no kernel task or task not owner by caller&n;&t; */
r_if
c_cond
(paren
id|task-&gt;mm
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] task [%d] has not memory context (kernel thread)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|task
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] no permission to attach to  [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * cannot block in self-monitoring mode&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|task
op_eq
id|current
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot load a blocking context on self for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;state
op_eq
id|TASK_ZOMBIE
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot attach to  zombie task [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * always ok for self&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot attach to non-stopped task [%d] state=%ld&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make sure the task is off any CPU&n;&t; */
id|pfm_wait_task_inactive
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* more to come... */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_task
id|pfm_get_task
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
id|pid_t
id|pid
comma
r_struct
id|task_struct
op_star
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* XXX: need to add more checks here */
r_if
c_cond
(paren
id|pid
OL
l_int|2
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
multiline_comment|/* make sure task cannot go away while we operate on it */
r_if
c_cond
(paren
id|p
)paren
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_task_incompatible
c_func
(paren
id|ctx
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
id|task
op_assign
id|p
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_ne
id|current
)paren
(brace
id|pfm_put_task
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_create
id|pfm_context_create
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_context_t
op_star
id|req
op_assign
(paren
id|pfarg_context_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* let&squot;s check the arguments first */
id|ret
op_assign
id|pfarg_is_sane
c_func
(paren
id|current
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ctx_flags
op_assign
id|req-&gt;ctx_flags
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|error
suffix:semicolon
id|req-&gt;ctx_fd
op_assign
id|ctx-&gt;ctx_fd
op_assign
id|pfm_alloc_fd
c_func
(paren
op_amp
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;ctx_fd
OL
l_int|0
)paren
r_goto
id|error_file
suffix:semicolon
multiline_comment|/*&n;&t; * attach context to file&n;&t; */
id|filp-&gt;private_data
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t; * does the user want to sample?&n;&t; */
r_if
c_cond
(paren
id|pfm_uuid_cmp
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
comma
id|pfm_null_uuid
)paren
)paren
(brace
id|ret
op_assign
id|pfm_setup_buffer_fmt
c_func
(paren
id|current
comma
id|ctx
comma
id|ctx_flags
comma
l_int|0
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|buffer_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * init context protection lock&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * context is unloaded&n;&t; */
id|CTX_UNLOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialization of context&squot;s flags&n;&t; */
id|ctx-&gt;ctx_fl_block
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_unsecure
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_UNSECURE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_is_sampling
op_assign
id|ctx-&gt;ctx_buf_fmt
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* assume record() is defined */
id|ctx-&gt;ctx_fl_no_msg
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_OVFL_NO_MSG
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * will move to set properties&n;&t; * ctx-&gt;ctx_fl_excl_idle   = (ctx_flags &amp; PFM_FL_EXCL_IDLE) ? 1: 0;&n;&t; */
multiline_comment|/*&n;&t; * init restart semaphore to locked&n;&t; */
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * activation is used in SMP only&n;&t; */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize notification message queue&n;&t; */
id|ctx-&gt;ctx_msgq_head
op_assign
id|ctx-&gt;ctx_msgq_tail
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d unsecure=%d no_msg=%d ctx_fd=%d &bslash;n&quot;
comma
id|ctx
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_system
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_fl_excl_idle
comma
id|ctx-&gt;ctx_fl_unsecure
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize soft PMU state&n;&t; */
id|pfm_reset_pmu_state
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|pfm_free_fd
c_func
(paren
id|ctx-&gt;ctx_fd
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_buf_fmt
)paren
(brace
id|pfm_buf_fmt_exit
c_func
(paren
id|ctx-&gt;ctx_buf_fmt
comma
id|current
comma
l_int|NULL
comma
id|regs
)paren
suffix:semicolon
)brace
id|error_file
suffix:colon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_new_counter_value
id|pfm_new_counter_value
(paren
id|pfm_counter_t
op_star
id|reg
comma
r_int
id|is_long_reset
)paren
(brace
r_int
r_int
id|val
op_assign
id|is_long_reset
ques
c_cond
id|reg-&gt;long_reset
suffix:colon
id|reg-&gt;short_reset
suffix:semicolon
r_int
r_int
id|new_seed
comma
id|old_seed
op_assign
id|reg-&gt;seed
comma
id|mask
op_assign
id|reg-&gt;mask
suffix:semicolon
r_extern
r_int
r_int
id|carta_random32
(paren
r_int
r_int
id|seed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;flags
op_amp
id|PFM_REGFL_RANDOM
)paren
(brace
id|new_seed
op_assign
id|carta_random32
c_func
(paren
id|old_seed
)paren
suffix:semicolon
id|val
op_sub_assign
(paren
id|old_seed
op_amp
id|mask
)paren
suffix:semicolon
multiline_comment|/* counter values are negative numbers! */
r_if
c_cond
(paren
(paren
id|mask
op_rshift
l_int|32
)paren
op_ne
l_int|0
)paren
multiline_comment|/* construct a full 64-bit random value: */
id|new_seed
op_or_assign
id|carta_random32
c_func
(paren
id|old_seed
op_rshift
l_int|32
)paren
op_lshift
l_int|32
suffix:semicolon
id|reg-&gt;seed
op_assign
id|new_seed
suffix:semicolon
)brace
id|reg-&gt;lval
op_assign
id|val
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_regs_masked
id|pfm_reset_regs_masked
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|is_long_reset
op_assign
(paren
id|flag
op_eq
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;ovfl_regs=0x%lx flag=%d&bslash;n&quot;
comma
id|ovfl_regs
(braket
l_int|0
)braket
comma
id|flag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|PFM_PMD_NO_RESET
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot; %s reset ctx_pmds[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;%s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|pfm_reset_regs
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|is_long_reset
op_assign
(paren
id|flag
op_eq
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;ovfl_regs=0x%lx flag=%d&bslash;n&quot;
comma
id|ovfl_regs
(braket
l_int|0
)braket
comma
id|flag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|PFM_PMD_NO_RESET
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
(brace
id|pfm_reset_regs_masked
c_func
(paren
id|ctx
comma
id|ovfl_regs
comma
id|flag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot; %s reset ctx_pmds[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;%s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmcs
id|pfm_write_pmcs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_int
r_int
id|smpl_pmds
comma
id|reset_pmds
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
comma
id|flags
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
comma
id|is_loaded
suffix:semicolon
r_int
id|is_monitor
comma
id|is_counting
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
DECL|macro|PFM_CHECK_PMC_PM
mdefine_line|#define PFM_CHECK_PMC_PM(x, y, z) ((x)-&gt;ctx_fl_system ^ PMC_PM(y, z))
r_if
c_cond
(paren
id|CTX_IS_DEAD
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|is_loaded
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|ctx-&gt;ctx_task-&gt;thread
suffix:semicolon
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|ctx-&gt;ctx_task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|reg_flags
op_assign
id|req-&gt;reg_flags
suffix:semicolon
id|value
op_assign
id|req-&gt;reg_value
suffix:semicolon
id|smpl_pmds
op_assign
id|req-&gt;reg_smpl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|reset_pmds
op_assign
id|req-&gt;reg_reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|is_counting
op_assign
id|PMC_IS_COUNTING
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|is_monitor
op_assign
id|PMC_IS_MONITOR
c_func
(paren
id|cnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we reject all non implemented PMC as well&n;&t;&t; * as attempts to modify PMC[0-3] which are used&n;&t;&t; * as status registers by the PMU&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
op_logical_or
id|cnum
OL
l_int|4
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc%u is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the PMC is a monitor, then if the value is not the default:&n;&t;&t; * &t;- system-wide session: PMCx.pm=1 (privileged monitor)&n;&t;&t; * &t;- per-task           : PMCx.pm=0 (user monitor)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|is_monitor
op_logical_or
id|is_counting
)paren
op_logical_and
id|value
op_ne
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
op_logical_and
id|PFM_CHECK_PMC_PM
c_func
(paren
id|ctx
comma
id|cnum
comma
id|value
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc%u pmc_pm=%ld fl_system=%d&bslash;n&quot;
comma
id|cnum
comma
id|PMC_PM
c_func
(paren
id|cnum
comma
id|value
)paren
comma
id|ctx-&gt;ctx_fl_system
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_counting
)paren
(brace
id|pfm_monitor_t
op_star
id|p
op_assign
(paren
id|pfm_monitor_t
op_star
)paren
op_amp
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * enforce generation of overflow interrupt. Necessary on all&n;&t;&t; &t; * CPUs.&n;&t;&t; &t; */
id|p-&gt;pmc_oi
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
(brace
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_RANDOM
)paren
id|flags
op_or_assign
id|PFM_REGFL_RANDOM
suffix:semicolon
multiline_comment|/* verify validity of smpl_pmds */
r_if
c_cond
(paren
(paren
id|smpl_pmds
op_amp
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
)paren
op_ne
id|smpl_pmds
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid smpl_pmds 0x%lx for pmc%u&bslash;n&quot;
comma
id|smpl_pmds
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* verify validity of reset_pmds */
r_if
c_cond
(paren
(paren
id|reset_pmds
op_amp
id|pmu_conf.impl_pmds
(braket
l_int|0
)braket
)paren
op_ne
id|reset_pmds
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid reset_pmds 0x%lx for pmc%u&bslash;n&quot;
comma
id|smpl_pmds
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|reg_flags
op_amp
(paren
id|PFM_REGFL_OVFL_NOTIFY
op_or
id|PFM_REGFL_RANDOM
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot set ovfl_notify or random on pmc%u&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* eventid on non-counting monitors are ignored */
)brace
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMC_WR_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ret
op_assign
id|PMC_WR_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|ctx-&gt;ctx_task
comma
l_int|NULL
comma
id|cnum
comma
op_amp
id|value
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we commit the changes to the software state&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * update overflow information&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * full flag update each time a register is programmed&n;&t;&t; &t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
op_assign
id|reset_pmds
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|smpl_pmds
(braket
l_int|0
)braket
op_assign
id|smpl_pmds
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|eventid
op_assign
id|req-&gt;reg_smpl_eventid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mark all PMDS to be accessed as used.&n;&t;&t;&t; *&n;&t;&t;&t; * We do not keep track of PMC because we have to&n;&t;&t;&t; * systematically restore ALL of them.&n;&t;&t;&t; *&n;&t;&t;&t; * We do not update the used_monitors mask, because&n;&t;&t;&t; * if we have not programmed them, then will be in&n;&t;&t;&t; * a quiescent state, therefore we will not need to&n;&t;&t;&t; * mask/restore then when context is MASKED.&n;&t;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|reset_pmds
)paren
suffix:semicolon
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|smpl_pmds
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * make sure we do not try to reset on&n;&t;&t; &t; * restart because we have established new values&n;&t;&t; &t; */
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Needed in case the user does not initialize the equivalent&n;&t;&t; * PMD. Clearing is done indirectly via pfm_reset_pmu_state() so there is no&n;&t;&t; * possible leak here.&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|pmu_conf.pmc_desc
(braket
id|cnum
)braket
dot
id|dep_pmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * keep track of the monitor PMC that we are using.&n;&t;&t; * we save the value of the pmc in ctx_pmcs[] and if&n;&t;&t; * the monitoring is not stopped for the context we also&n;&t;&t; * place it in the saved state area so that it will be&n;&t;&t; * picked up later by the context switch code.&n;&t;&t; *&n;&t;&t; * The value in ctx_pmcs[] can only be changed in pfm_write_pmcs().&n;&t;&t; *&n;&t;&t; * The value in t-&gt;pmc[] may be modified on overflow, i.e.,  when&n;&t;&t; * monitoring needs to be stopped.&n;&t;&t; */
r_if
c_cond
(paren
id|is_monitor
)paren
id|CTX_USED_MONITOR
c_func
(paren
id|ctx
comma
l_int|1UL
op_lshift
id|cnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update context state&n;&t;&t; */
id|ctx-&gt;ctx_pmcs
(braket
id|cnum
)braket
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * write thread state&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|thread-&gt;pmcs
(braket
id|cnum
)braket
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * write hardware register if we can&n;&t;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * per-task SMP only here&n;&t;&t;&t;&t; *&n;&t;&t;&t; &t; * we are guaranteed that the task is not running on the other CPU,&n;&t;&t;&t; &t; * we indicate that this PMD will need to be reloaded if the task&n;&t;&t;&t; &t; * is rescheduled on the CPU it ran last on.&n;&t;&t;&t; &t; */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_or_assign
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
macro_line|#endif
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%u]=0x%lx loaded=%d access_pmu=%d all_pmcs=0x%lx used_pmds=0x%lx eventid=%ld smpl_pmds=0x%lx reset_pmds=0x%lx reloads_pmcs=0x%lx used_monitors=0x%lx ovfl_regs=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|eventid
comma
id|smpl_pmds
comma
id|reset_pmds
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make sure the changes are visible&n;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
id|req-&gt;reg_flags
op_assign
id|PFM_REG_RETFL_EINVAL
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%u]=0x%lx error %d&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmds
id|pfm_write_pmds
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
comma
id|hw_value
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
suffix:semicolon
r_int
id|is_counting
comma
id|is_loaded
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_DEAD
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|is_loaded
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only write to the PMC when the task is&n;&t; * the owner of the local PMU.&n;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|ctx-&gt;ctx_task-&gt;thread
suffix:semicolon
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|ctx-&gt;ctx_task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|value
op_assign
id|req-&gt;reg_value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u] is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
id|is_counting
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_WR_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|value
suffix:semicolon
id|ret
op_assign
id|PMD_WR_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|ctx-&gt;ctx_task
comma
l_int|NULL
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|abort_mission
suffix:semicolon
id|value
op_assign
id|v
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now commit changes to software state&n;&t;&t; */
id|hw_value
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update virtualized (64bits) counter&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * write context state&n;&t;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|lval
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * when context is load we use the split value&n;&t;&t;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|hw_value
op_assign
id|value
op_amp
id|pmu_conf.ovfl_val
suffix:semicolon
id|value
op_assign
id|value
op_amp
op_complement
id|pmu_conf.ovfl_val
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * update sampling periods&n;&t;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|long_reset
op_assign
id|req-&gt;reg_long_reset
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|short_reset
op_assign
id|req-&gt;reg_short_reset
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * update randomization parameters&n;&t;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|seed
op_assign
id|req-&gt;reg_random_seed
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|mask
op_assign
id|req-&gt;reg_random_mask
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * update context value&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Keep track of what we use&n;&t;&t; *&n;&t;&t; * We do not keep track of PMC because we have to&n;&t;&t; * systematically restore ALL of them.&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|PMD_PMD_DEP
c_func
(paren
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * mark this PMD register used as well&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|RDEP
c_func
(paren
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * make sure we do not try to reset on&n;&t;&t; * restart because we have established new values&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
op_logical_and
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * write thread state&n;&t;&t; &t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|thread-&gt;pmds
(braket
id|cnum
)braket
op_assign
id|hw_value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * write hardware register if we can&n;&t;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|hw_value
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t;&t; &t; * we are guaranteed that the task is not running on the other CPU,&n;&t;&t;&t; &t; * we indicate that this PMD will need to be reloaded if the task&n;&t;&t;&t; &t; * is rescheduled on the CPU it ran last on.&n;&t;&t;&t; &t; */
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_or_assign
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
macro_line|#endif
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u]=0x%lx loaded=%d access_pmu=%d, hw_value=0x%lx ctx_pmd=0x%lx  short_reset=0x%lx &quot;
l_string|&quot;long_reset=0x%lx notify=%c used_pmds=0x%lx reset_pmds=0x%lx reload_pmds=0x%lx all_pmds=0x%lx ovfl_regs=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|hw_value
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|short_reset
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|long_reset
comma
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|cnum
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make changes visible&n;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * for now, we have only one possibility for error&n;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we change the return value to EFAULT in case we cannot write register return code.&n;&t; * The caller first must correct this error, then a resubmission of the request will&n;&t; * eventually yield the EINVAL.&n;&t; */
id|req-&gt;reg_flags
op_assign
id|PFM_REG_RETFL_EINVAL
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u]=0x%lx ret %d&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * By the way of PROTECT_CONTEXT(), interrupts are masked while we are in this function.&n; * Therefore we know, we do not have to worry about the PMU overflow interrupt. If an&n; * interrupt is delivered during the call, it will be kept pending until we leave, making&n; * it appears as if it had been generated at the UNPROTECT_CONTEXT(). At least we are&n; * guaranteed to return consistent data to the user, it may simply be old. It is not&n; * trivial to treat the overflow while inside the call because you may end up in&n; * some module sampling buffer code causing deadlocks.&n; */
r_static
r_int
DECL|function|pfm_read_pmds
id|pfm_read_pmds
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0UL
comma
id|lval
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|is_loaded
comma
id|can_access_pmu
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * access is possible when loaded only for&n;&t; * self-monitoring tasks or in UP mode&n;&t; */
id|is_loaded
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|ctx-&gt;ctx_task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this can be true when not self-monitoring only in UP&n;&t;&t; */
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|ctx-&gt;ctx_task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;enter loaded=%d access_pmu=%d ctx_state=%d&bslash;n&quot;
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only read the PMD from the hardware register when&n;&t; * the task is the owner of the local PMU.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|lval
op_assign
l_int|0UL
suffix:semicolon
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|reg_flags
op_assign
id|req-&gt;reg_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we can only read the register that we use. That includes&n;&t;&t; * the one we explicitely initialize AND the one we want included&n;&t;&t; * in the sampling buffer (smpl_regs).&n;&t;&t; *&n;&t;&t; * Having this restriction allows optimization in the ctxsw routine&n;&t;&t; * without compromising security (leaks)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the task is not the current one, then we check if the&n;&t;&t; * PMU state is still in the local live register due to lazy ctxsw.&n;&t;&t; * If true, then we read directly from the registers.&n;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * context has been saved&n;&t;&t;&t; * if context is zombie, then task does not exist anymore.&n;&t;&t;&t; * In this case, we use the full value saved in the context (pfm_flush_regs()).&n;&t;&t;&t; */
id|val
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
ques
c_cond
id|thread-&gt;pmds
(braket
id|cnum
)braket
suffix:colon
l_int|0UL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX: need to check for overflow when loaded&n;&t;&t;&t; */
id|val
op_and_assign
id|pmu_conf.ovfl_val
suffix:semicolon
id|val
op_add_assign
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
suffix:semicolon
id|lval
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|lval
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * execute read checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_RD_FUNC
c_func
(paren
id|cnum
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|val
suffix:semicolon
id|ret
op_assign
id|PMD_RD_FUNC
c_func
(paren
id|cnum
)paren
(paren
id|ctx-&gt;ctx_task
comma
l_int|NULL
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
id|val
op_assign
id|v
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u]=0x%lx loaded=%d access_pmu=%d ctx_state=%d&bslash;n&quot;
comma
id|cnum
comma
id|val
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update register return value, abort all if problem during copy.&n;&t;&t; * we only modify the reg_flags field. no check mode is fine because&n;&t;&t; * access has been verified upfront in sys_perfmonctl().&n;&t;&t; */
id|req-&gt;reg_value
op_assign
id|val
suffix:semicolon
id|req-&gt;reg_flags
op_assign
id|reg_flags
suffix:semicolon
id|req-&gt;reg_last_reset_val
op_assign
id|lval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
id|req-&gt;reg_flags
op_assign
id|PFM_REG_RETFL_EINVAL
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;error pmd[%u]=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|val
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|pfm_mod_write_pmcs
id|pfm_mod_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_reg_t
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
op_logical_or
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_write_pmcs
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
r_int
DECL|function|pfm_mod_read_pmds
id|pfm_mod_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_reg_t
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
op_logical_or
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|//ctx = task-&gt;thread.pfm_context;
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_read_pmds
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
r_int
DECL|function|pfm_mod_fast_read_pmds
id|pfm_mod_fast_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|mask
(braket
l_int|4
)braket
comma
r_int
r_int
op_star
id|addr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|m
comma
id|val
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
op_logical_or
id|addr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|//ctx = task-&gt;thread.pfm_context;
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|m
op_assign
id|mask
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PMD_IS_IMPL
c_func
(paren
id|j
)paren
op_logical_and
id|CTX_IS_USED_PMD
c_func
(paren
id|ctx
comma
id|j
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|j
)paren
)paren
(brace
id|val
op_assign
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
)brace
op_star
id|addr
op_increment
op_assign
id|val
suffix:semicolon
multiline_comment|/* XXX: should call read checker routine? */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;single_read_pmd[%u]=0x%lx&bslash;n&quot;
comma
id|j
comma
id|val
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Only call this function when a process it trying to&n; * write the debug registers (reading is always allowed)&n; */
r_int
DECL|function|pfm_use_debug_registers
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf.use_rr_dbregs
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;called for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do it only once&n;&t; */
r_if
c_cond
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Even on SMP, we do not need to use an atomic here because&n;&t; * the only way in is via ptrace() and this is possible only when the&n;&t; * process is stopped. Even in the case where the ctxsw out is not totally&n;&t; * completed by the time we come here, there is no way the &squot;stopped&squot; process&n;&t; * could be in the middle of fiddling with the pfm_write_ibr_dbr() routine.&n;&t; * So this is always safe.&n;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot allow setting breakpoints when system wide monitoring&n;&t; * sessions are using the debug registers.&n;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
OG
l_int|0
)paren
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|pfm_sessions.pfs_ptrace_use_dbregs
op_increment
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ptrace_use_dbregs=%u  sys_use_dbregs=%u by [%d] ret = %d&bslash;n&quot;
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|task-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for every task that exits with the&n; * IA64_THREAD_DBG_VALID set. This indicates a task which was&n; * able to use the debug registers for debugging purposes via&n; * ptrace(). Therefore we know it was not using them for&n; * perfmormance monitoring, so we only decrement the number&n; * of &quot;ptraced&quot; debug register users to keep the count up to date&n; */
r_int
DECL|function|pfm_release_debug_registers
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf.use_rr_dbregs
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: invalid release for [%d] ptrace_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_ptrace_use_dbregs
op_decrement
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_restart
id|pfm_restart
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|rst_ctrl
suffix:semicolon
r_int
id|is_loaded
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|is_loaded
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
op_logical_and
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
op_logical_and
id|fmt-&gt;fmt_restart_active
)paren
r_goto
id|proceed
suffix:semicolon
multiline_comment|/*&n;&t; * restarting a terminated context is a nop&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|CTX_IS_TERMINATED
c_func
(paren
id|ctx
)paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context is terminated, nothing to do&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * LOADED, UNLOADED, ZOMBIE&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|proceed
suffix:colon
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|task
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] pfm_restart no task&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * this test is always true in system wide mode&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;restarting self %d ovfl=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|prefetch
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|rst_ctrl.stop_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.reset_pmds
op_assign
id|PFM_PMD_NO_RESET
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
id|ret
op_assign
id|pfm_buf_fmt_restart_active
c_func
(paren
id|fmt
comma
id|task
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|pfm_buf_fmt_restart
c_func
(paren
id|fmt
comma
id|task
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|rst_ctrl.stop_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.reset_pmds
op_assign
id|PFM_PMD_LONG_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rst_ctrl.reset_pmds
)paren
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|rst_ctrl.reset_pmds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rst_ctrl.stop_monitoring
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;resuming monitoring for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
id|pfm_restore_monitoring
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;keeping monitoring stopped for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
singleline_comment|// cannot use pfm_stop_monitoring(task, regs);
)brace
)brace
multiline_comment|/*&n;&t;&t; * clear overflowed PMD mask to remove any stale information&n;&t;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * back to LOADED state&n;&t;&t; */
id|CTX_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* restart another task */
multiline_comment|/*&n;&t; * if blocking, then post the semaphore.&n;&t; * if non-blocking, then we ensure that the task will go into&n;&t; * pfm_handle_work() before returning to user mode.&n;&t; * We cannot explicitely reset another task, it MUST always&n;&t; * be done by the task itself. This works for system wide because&n;&t; * the tool that is controlling the session is doing &quot;self-monitoring&quot;.&n;&t; *&n;&t; * XXX: what if the task never goes back to user?&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;unblocking [%d] &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] armed exit trap&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_RESET
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|1
)paren
suffix:semicolon
id|pfm_set_task_notify
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: send reschedule if task runs on another CPU&n;&t;&t; */
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_debug
id|pfm_debug
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|m
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|arg
suffix:semicolon
id|pfm_sysctl.debug
op_assign
id|m
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|pfm_debug_var
op_assign
id|pfm_sysctl.debug
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon debugging %s (timing reset)&bslash;n&quot;
comma
id|pfm_sysctl.debug
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pfm_stats
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_stats
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|NR_CPUS
suffix:semicolon
id|m
op_increment
)paren
(brace
id|pfm_stats
(braket
id|m
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_ibr_dbr
id|pfm_write_ibr_dbr
c_func
(paren
r_int
id|mode
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
id|pfarg_dbreg_t
op_star
id|req
op_assign
(paren
id|pfarg_dbreg_t
op_star
)paren
id|arg
suffix:semicolon
id|dbreg_t
id|dbreg
suffix:semicolon
r_int
r_int
id|rnum
suffix:semicolon
r_int
id|first_time
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
comma
id|is_loaded
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf.use_rr_dbregs
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_DEAD
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|is_loaded
op_assign
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only write to the PMC when the task is&n;&t; * the owner of the local PMU.&n;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|ctx-&gt;ctx_task-&gt;thread
suffix:semicolon
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|ctx-&gt;ctx_task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * we do not need to check for ipsr.db because we do clear ibr.x, dbr.r, and dbr.w&n;&t; * ensuring that no real breakpoint can be installed via this call.&n;&t; *&n;&t; * IMPORTANT: regs can be NULL in this function&n;&t; */
id|first_time
op_assign
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t bother if we are loaded and task is being debugged&n;&t; */
r_if
c_cond
(paren
id|is_loaded
op_logical_and
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;debug registers already in use for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for debug registers in system wide mode&n;&t; *&n;&t; * We make the reservation even when context is not loaded&n;&t; * to make sure we get our slot. Note that the PFM_LOAD_CONTEXT&n;&t; * may still fail if the task has DBG_VALID set.&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_time
op_logical_and
id|ctx-&gt;ctx_fl_system
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|pfm_sessions.pfs_sys_use_dbregs
op_increment
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * mark ourself as user of the debug registers for&n;&t; * perfmon purposes.&n;&t; */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; &t; * clear hardware registers to make sure we don&squot;t&n; &t; * pick up stale state.&n;&t; *&n;&t; * for a system wide session, we do not use&n;&t; * thread.dbr, thread.ibr because this process&n;&t; * never leaves the current CPU and the state&n;&t; * is shared by all processes running on it&n; &t; */
r_if
c_cond
(paren
id|first_time
op_logical_and
id|can_access_pmu
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] clearing ibrs, dbrs&bslash;n&quot;
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_ibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_dbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now install the values into the registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|rnum
op_assign
id|req-&gt;dbreg_num
suffix:semicolon
id|dbreg.val
op_assign
id|req-&gt;dbreg_value
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_eq
id|PFM_CODE_RR
op_logical_and
op_logical_neg
id|IBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
op_logical_or
(paren
(paren
id|mode
op_eq
id|PFM_DATA_RR
)paren
op_logical_and
op_logical_neg
id|DBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid register %u val=0x%lx mode=%d i=%d count=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|mode
comma
id|i
comma
id|count
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * make sure we do not install enabled breakpoint&n;&t;&t; */
r_if
c_cond
(paren
id|rnum
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|PFM_CODE_RR
)paren
id|dbreg.ibr.ibr_x
op_assign
l_int|0
suffix:semicolon
r_else
id|dbreg.dbr.dbr_r
op_assign
id|dbreg.dbr.dbr_w
op_assign
l_int|0
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;dbreg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Debug registers, just like PMC, can only be modified&n;&t;&t; * by a kernel call. Moreover, perfmon() access to those&n;&t;&t; * registers are centralized in this routine. The hardware&n;&t;&t; * does not modify the value of these registers, therefore,&n;&t;&t; * if we save them as they are written, we can avoid having&n;&t;&t; * to save them on context switch out. This is made possible&n;&t;&t; * by the fact that when perfmon uses debug registers, ptrace()&n;&t;&t; * won&squot;t be able to modify them concurrently.&n;&t;&t; */
r_if
c_cond
(paren
id|mode
op_eq
id|PFM_CODE_RR
)paren
(brace
id|CTX_USED_IBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_set_ibr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ctx-&gt;ctx_ibrs
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;write ibr%u=0x%lx used_ibrs=0x%x is_loaded=%d access_pmu=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
comma
id|is_loaded
comma
id|can_access_pmu
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CTX_USED_DBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_set_dbr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ctx-&gt;ctx_dbrs
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;write dbr%u=0x%lx used_dbrs=0x%x is_loaded=%d access_pmu=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
comma
id|is_loaded
comma
id|can_access_pmu
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * in case it was our first attempt, we undo the global modifications&n;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * install error return flag&n;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;dbreg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_ibrs
id|pfm_write_ibrs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|pfm_write_ibr_dbr
c_func
(paren
id|PFM_CODE_RR
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_dbrs
id|pfm_write_dbrs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|pfm_write_ibr_dbr
c_func
(paren
id|PFM_DATA_RR
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_features
id|pfm_get_features
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_features_t
op_star
id|req
op_assign
(paren
id|pfarg_features_t
op_star
)paren
id|arg
suffix:semicolon
id|req-&gt;ft_version
op_assign
id|PFM_VERSION
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_stop
id|pfm_stop
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * Update local PMU first&n;&t;&t; *&n;&t;&t; * disable dcr pp&n;&t;&t; */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update local cpuinfo&n;&t;&t; */
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * stop monitoring, does srlz.i&n;&t;&t; */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * stop monitoring in the caller&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-task mode&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_task
op_eq
id|current
)paren
(brace
multiline_comment|/* stop monitoring  at kernel level */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * stop monitoring at the user level&n;&t; &t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tregs
op_assign
id|ia64_task_regs
c_func
(paren
id|ctx-&gt;ctx_task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * stop monitoring at the user level&n;&t; &t; */
id|ia64_psr
c_func
(paren
id|tregs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * monitoring disabled in kernel at next reschedule&n;&t;&t; */
id|ctx-&gt;ctx_saved_psr
op_and_assign
op_complement
id|IA64_PSR_UP
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pfm_stop: current [%d] task=[%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_start
id|pfm_start
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * set user level psr.pp for the caller&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now update the local PMU and cpuinfo&n;&t;&t; */
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * start monitoring at kernel level&n;&t;&t; */
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-process mode&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_task
op_eq
id|current
)paren
(brace
multiline_comment|/* start monitoring at kernel level */
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * activate monitoring at user level&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|tregs
op_assign
id|ia64_task_regs
c_func
(paren
id|ctx-&gt;ctx_task
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * start monitoring at the kernel level the next&n;&t;&t; * time the task is scheduled&n;&t;&t; */
id|ctx-&gt;ctx_saved_psr
op_or_assign
id|IA64_PSR_UP
suffix:semicolon
multiline_comment|/*&n;&t;&t; * activate monitoring at user level&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|tregs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_pmc_reset
id|pfm_get_pmc_reset
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
id|req-&gt;reg_value
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc_reset_val pmc[%u]=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|req-&gt;reg_value
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_load
id|pfm_context_load
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|thread_struct
op_star
id|thread
suffix:semicolon
r_struct
id|pfm_context_t
op_star
id|old
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
r_struct
id|task_struct
op_star
id|owner_task
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|pfarg_load_t
op_star
id|req
op_assign
(paren
id|pfarg_load_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
op_star
id|pmcs_source
comma
op_star
id|pmds_source
suffix:semicolon
r_int
id|the_cpu
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * can only load from unloaded or terminated state&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_UNLOADED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|CTX_IS_TERMINATED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot load to [%d], invalid ctx_state=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|req-&gt;load_pid
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d]&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|req-&gt;load_pid
op_eq
id|current-&gt;pid
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode on self for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_get_task
c_func
(paren
id|ctx
comma
id|req-&gt;load_pid
comma
op_amp
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] get_task=%d&bslash;n&quot;
comma
id|req-&gt;load_pid
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * system wide is self monitoring only&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|task
op_ne
id|current
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide is self monitoring only current=%d load_pid=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * cannot load a context which is using range restrictions,&n;&t; * into a task that is being debugged.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
op_logical_and
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] task is debugged, cannot load range restrictions&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * SMP system-wide monitoring implies self-monitoring.&n;&t; *&n;&t; * The programming model expects the task to&n;&t; * be pinned on a CPU throughout the session.&n;&t; * Here we take note of the current CPU at the&n;&t; * time the context is loaded. No call from&n;&t; * another CPU will be allowed.&n;&t; *&n;&t; * The pinning via shed_setaffinity()&n;&t; * must be done by the calling task prior&n;&t; * to this call.&n;&t; *&n;&t; * systemwide: keep track of CPU this session is supposed to run on&n;&t; */
id|the_cpu
op_assign
id|ctx-&gt;ctx_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now reserve the session&n;&t; */
id|ret
op_assign
id|pfm_reserve_session
c_func
(paren
id|current
comma
id|ctx-&gt;ctx_fl_system
comma
id|the_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * task is necessarily stopped at this point.&n;&t; *&n;&t; * If the previous context was zombie, then it got removed in&n;&t; * pfm_save_regs(). Therefore we should not see it here.&n;&t; * If we see a context, then this is an active context&n;&t; *&n;&t; * XXX: needs to be atomic&n;&t; */
id|old
op_assign
id|ia64_cmpxchg
c_func
(paren
l_string|&quot;acq&quot;
comma
op_amp
id|thread-&gt;pfm_context
comma
l_int|NULL
comma
id|ctx
comma
r_sizeof
(paren
id|pfm_context_t
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] already has a context&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error_unres
suffix:semicolon
)brace
id|pfm_reset_msgq
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|CTX_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * link context to task&n;&t; */
id|ctx-&gt;ctx_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * we load as stopped&n;&t;&t; */
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_excl_idle
)paren
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
)brace
r_else
(brace
id|thread-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * propagate into thread-state&n;&t; */
id|pfm_copy_pmds
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|pfm_copy_pmcs
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|pmcs_source
op_assign
id|thread-&gt;pmcs
suffix:semicolon
id|pmds_source
op_assign
id|thread-&gt;pmds
suffix:semicolon
multiline_comment|/*&n;&t; * always the case for system-wide&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
(brace
multiline_comment|/* allow user level control */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;clearing psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|INC_ACTIVATION
c_func
(paren
)paren
suffix:semicolon
id|SET_ACTIVATION
c_func
(paren
id|ctx
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
multiline_comment|/*&n;&t;&t;&t; * push the other task out, if any&n;&t;&t;&t; */
id|owner_task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|owner_task
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner_task
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t; * load all PMD from ctx to PMU (as opposed to thread state)&n;&t;&t; * restore all PMC from ctx to PMU&n;&t;&t; */
id|pfm_restore_pmds
c_func
(paren
id|pmds_source
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|pfm_restore_pmcs
c_func
(paren
id|pmcs_source
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * guaranteed safe by earlier check against DBG_VALID&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf.num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf.num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * set new ownership&n;&t;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context loaded on PMU for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * when not current, task MUST be stopped, so this is safe&n;&t;&t; */
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* force a full reload */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* initial saved psr (stopped) */
id|ctx-&gt;ctx_saved_psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
op_amp
op_complement
(paren
id|IA64_PSR_PP
op_or
id|IA64_PSR_UP
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_unsecure
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context unsecured for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|error_unres
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_fl_system
comma
id|the_cpu
)paren
suffix:semicolon
id|error
suffix:colon
multiline_comment|/*&n;&t; * release task, there is now a link with the context&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
op_logical_and
id|task
op_ne
id|current
)paren
id|pfm_put_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * in this function, we do not need to increase the use count&n; * for the task via get_task_struct(), because we hold the&n; * context lock. If the task were to disappear while having&n; * a context attached, it would go through pfm_exit_thread()&n; * which also grabs the context lock  and would therefore be blocked&n; * until we are here.&n; */
r_static
r_void
id|pfm_flush_pmds
c_func
(paren
r_struct
id|task_struct
op_star
comma
id|pfm_context_t
op_star
id|ctx
)paren
suffix:semicolon
r_static
r_int
DECL|function|pfm_context_unload
id|pfm_context_unload
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d task [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * unload only when necessary&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_TERMINATED
c_func
(paren
id|ctx
)paren
op_logical_or
id|CTX_IS_UNLOADED
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] ctx_state=%d, nothing to do&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In system wide and when the context is loaded, access can only happen&n;&t; * when the caller is running on the CPU being monitored by the session.&n;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] should be running on CPU%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear psr and dcr bits&n;&t; */
id|pfm_stop
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
id|CTX_UNLOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * Update cpuinfo&n;&t;&t; *&n;&t;&t; * local PMU is taken care of in pfm_stop()&n;&t;&t; */
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * save PMDs in context&n;&t;&t; * release ownership&n;&t;&t; */
id|pfm_flush_pmds
c_func
(paren
id|current
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * at this point we are done with the PMU&n;&t;&t; * so we can unreserve the resource.&n;&t;&t; */
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
l_int|1
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disconnect context from task&n;&t;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disconnect task from context&n;&t;&t; */
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There is nothing more to cleanup here.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-task mode&n;&t; */
id|tregs
op_assign
id|task
op_eq
id|current
ques
c_cond
id|regs
suffix:colon
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|ctx-&gt;ctx_fl_unsecure
)paren
(brace
multiline_comment|/*&n;&t;&t; * cancel user level control&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;setting psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * save PMDs to context&n;&t; * release ownership&n;&t; */
id|pfm_flush_pmds
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * at this point we are done with the PMU&n;&t; * so we can unreserve the resource.&n;&t; */
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
l_int|0
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset activation counter and psr&n;&t; */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * PMU state will not be restored&n;&t; */
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
multiline_comment|/*&n;&t; * break links between context and task&n;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;disconnected [%d] from context&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_force_cleanup
id|pfm_force_cleanup
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cleared ownership for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disconnect the task from the context and vice-versa&n;&t; */
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context &lt;%d&gt; force cleanup for [%d] by [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called only from exit_thread(): task == current&n; */
r_void
DECL|function|pfm_exit_thread
id|pfm_exit_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|free_ok
op_assign
l_int|0
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;state=%d task [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * come here only if attached&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|CTX_IS_UNLOADED
c_func
(paren
id|ctx
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] ctx unloaded&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_goto
id|skip_all
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
op_logical_or
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ret
op_assign
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] state=%d unload failed %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_state
comma
id|ret
)paren
suffix:semicolon
)brace
id|CTX_TERMINATED
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx terminated by [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|pfm_end_notify_user
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
(brace
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|pfm_force_cleanup
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
id|free_ok
op_assign
l_int|1
suffix:semicolon
)brace
(brace
id|u64
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_UP
op_or
id|IA64_PSR_PP
)paren
)paren
suffix:semicolon
)brace
id|skip_all
suffix:colon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All memory free operations (especially for vmalloc&squot;ed memory)&n;&t; * MUST be done with interrupts ENABLED.&n;&t; */
r_if
c_cond
(paren
id|free_ok
)paren
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * functions MUST be listed in the increasing order of their index (see permfon.h)&n; */
DECL|macro|PFM_CMD
mdefine_line|#define PFM_CMD(name, flags, arg_count, arg_type, getsz) { name, #name, flags, arg_count, sizeof(arg_type), getsz }
DECL|macro|PFM_CMD_S
mdefine_line|#define PFM_CMD_S(name, flags) { name, #name, flags, 0, 0, NULL }
DECL|macro|PFM_CMD_PCLRWS
mdefine_line|#define PFM_CMD_PCLRWS&t;(PFM_CMD_FD|PFM_CMD_ARG_RW|PFM_CMD_STOP)
DECL|macro|PFM_CMD_PCLRW
mdefine_line|#define PFM_CMD_PCLRW&t;(PFM_CMD_FD|PFM_CMD_ARG_RW)
DECL|macro|PFM_CMD_NONE
mdefine_line|#define PFM_CMD_NONE&t;{ NULL, &quot;no-cmd&quot;, 0, 0, 0, NULL}
DECL|variable|pfm_cmd_tab
r_static
id|pfm_cmd_desc_t
id|pfm_cmd_tab
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|PFM_CMD_COUNT
mdefine_line|#define PFM_CMD_COUNT&t;(sizeof(pfm_cmd_tab)/sizeof(pfm_cmd_desc_t))
r_static
r_int
DECL|function|pfm_check_task_state
id|pfm_check_task_state
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context %d no task, state=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context %d state=%d [%d] task_state=%ld must_stop=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|ctx-&gt;ctx_state
comma
id|task-&gt;pid
comma
id|task-&gt;state
comma
id|PFM_CMD_STOPPED
c_func
(paren
id|cmd
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * self-monitoring always ok.&n;&t; *&n;&t; * for system-wide the caller can either be the creator of the&n;&t; * context (to one to which the context is attached to) OR&n;&t; * a task running on the same CPU as the session.&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|ctx-&gt;ctx_fl_system
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * context is UNLOADED, MASKED, TERMINATED we are safe to go&n;&t; */
r_if
c_cond
(paren
id|CTX_IS_LOADED
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * context is loaded, we must make sure the task is stopped&n;&t; * We could lift this restriction for UP but it would mean that&n;&t; * the user has no guarantee the task would not run between&n;&t; * two successive calls to perfmonctl(). That&squot;s probably OK.&n;&t; * If this user wants to ensure the task does not run, then&n;&t; * the task must be stopped.&n;&t; */
r_if
c_cond
(paren
id|PFM_CMD_STOPPED
c_func
(paren
id|cmd
)paren
op_logical_and
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] task not in stopped state&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_wait_task_inactive
c_func
(paren
id|task
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * system-call entry point (must return long)&n; */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|fd
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|args_k
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* will expand int return types */
r_int
id|base_sz
comma
id|sz
comma
id|xtra_sz
op_assign
l_int|0
suffix:semicolon
r_int
id|narg
comma
id|completed_args
op_assign
l_int|0
comma
id|call_made
op_assign
l_int|0
suffix:semicolon
DECL|macro|PFM_MAX_ARGSIZE
mdefine_line|#define PFM_MAX_ARGSIZE&t;4096
multiline_comment|/*&n;&t; * reject any call if perfmon was disabled at initialization time&n;&t; */
r_if
c_cond
(paren
id|PFM_IS_DISABLED
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] invalid cmd=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cmd=%s idx=%d valid=%d narg=0x%x argsz=%lu count=%d&bslash;n&quot;
comma
id|PFM_CMD_NAME
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_ARG_SIZE
c_func
(paren
id|cmd
)paren
comma
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if number of arguments matches what the command expects&n;&t; */
id|narg
op_assign
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|narg
op_eq
id|PFM_CMD_ARG_MANY
op_logical_and
id|count
op_le
l_int|0
)paren
op_logical_or
(paren
id|narg
OG
l_int|0
op_logical_and
id|narg
op_ne
id|count
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* get single argument size */
id|base_sz
op_assign
id|PFM_CMD_ARG_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restart_args
suffix:colon
id|sz
op_assign
id|xtra_sz
op_plus
id|base_sz
op_star
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * limit abuse to min page size&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sz
OG
id|PFM_MAX_ARGSIZE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] argument too big %lu&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sz
)paren
suffix:semicolon
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate default-sized argument buffer&n;&t; */
r_if
c_cond
(paren
id|count
op_logical_and
id|args_k
op_eq
l_int|NULL
)paren
(brace
id|args_k
op_assign
id|kmalloc
c_func
(paren
id|PFM_MAX_ARGSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args_k
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * copy arguments&n;&t; *&n;&t; * assume sz = 0 for command without parameters&n;&t; */
r_if
c_cond
(paren
id|sz
op_logical_and
id|copy_from_user
c_func
(paren
id|args_k
comma
id|arg
comma
id|sz
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot copy_from_user %lu bytes @%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sz
comma
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if command supports extra parameters&n;&t; */
r_if
c_cond
(paren
id|completed_args
op_eq
l_int|0
op_logical_and
id|PFM_CMD_GETSIZE
c_func
(paren
id|cmd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * get extra parameters size (based on main argument)&n;&t;&t; */
id|ret
op_assign
id|PFM_CMD_GETSIZE
c_func
(paren
id|cmd
)paren
(paren
id|args_k
comma
op_amp
id|xtra_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error_args
suffix:semicolon
id|completed_args
op_assign
l_int|1
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] restart_args sz=%lu xtra_sz=%lu&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sz
comma
id|xtra_sz
)paren
)paren
suffix:semicolon
multiline_comment|/* retry if necessary */
r_if
c_cond
(paren
id|xtra_sz
)paren
r_goto
id|restart_args
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PFM_CMD_USE_FD
c_func
(paren
id|cmd
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] invalid fd %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|file
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] fd %d not related to perfmon&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] no context for fd %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check task is stopped&n;&t;&t; */
id|ret
op_assign
id|pfm_check_task_state
c_func
(paren
id|ctx
comma
id|cmd
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|abort_locked
suffix:semicolon
)brace
id|ret
op_assign
(paren
op_star
id|pfm_cmd_tab
(braket
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
)braket
dot
id|cmd_func
)paren
(paren
id|ctx
comma
id|args_k
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|call_made
op_assign
l_int|1
suffix:semicolon
id|abort_locked
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] context unlocked&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
multiline_comment|/* copy argument back to user, if needed */
r_if
c_cond
(paren
id|call_made
op_logical_and
id|PFM_CMD_RW_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
id|args_k
comma
id|base_sz
op_star
id|count
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|error_args
suffix:colon
r_if
c_cond
(paren
id|args_k
)paren
id|kfree
c_func
(paren
id|args_k
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_resume_after_ovfl
id|pfm_resume_after_ovfl
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_regs
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|rst_ctrl
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock sampling buffer and reset index atomically&n;&t; * XXX: not really needed when blocking&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|rst_ctrl.stop_monitoring
op_assign
l_int|1
suffix:semicolon
id|rst_ctrl.reset_pmds
op_assign
id|PFM_PMD_NO_RESET
suffix:semicolon
multiline_comment|/* XXX: check return value */
r_if
c_cond
(paren
id|fmt-&gt;fmt_restart
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_restart
)paren
(paren
id|current
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|rst_ctrl.stop_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.reset_pmds
op_assign
id|PFM_PMD_LONG_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rst_ctrl.reset_pmds
op_ne
id|PFM_PMD_NO_RESET
)paren
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|ovfl_regs
comma
id|rst_ctrl.reset_pmds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rst_ctrl.stop_monitoring
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;resuming monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_MASKED
c_func
(paren
id|ctx
)paren
)paren
id|pfm_restore_monitoring
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;stopping monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|//pfm_stop_monitoring(current, regs);
)brace
id|CTX_LOADED
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * context MUST BE LOCKED when calling&n; * can only be called for current&n; */
r_static
r_void
DECL|function|pfm_context_force_terminate
id|pfm_context_force_terminate
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_context_force_terminate [%d] is system-wide&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we stop the whole thing, we do no need to flush&n;&t; * we know we WERE masked&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * disconnect the task from the context and vice-versa&n;&t; */
id|current-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * switch to terminated state&n;&t; */
id|CTX_TERMINATED
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context &lt;%d&gt; terminated for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and wakeup controlling task, indicating we are now disconnected&n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * given that context is still locked, the controlling&n;&t; * task will only get access when we return from&n;&t; * pfm_handle_work().&n;&t; */
)brace
r_static
r_int
id|pfm_ovfl_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_pmds
)paren
suffix:semicolon
r_void
DECL|function|pfm_handle_work
id|pfm_handle_work
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ovfl_regs
suffix:semicolon
r_int
r_int
id|reason
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|current
comma
l_int|0
)paren
suffix:semicolon
id|pfm_clear_task_notify
c_func
(paren
)paren
suffix:semicolon
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * extract reason for being here and clear&n;&t; */
id|reason
op_assign
id|ctx-&gt;ctx_fl_trap_reason
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] reason=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|reason
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * must be done before we check non-blocking mode&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_going_zombie
op_logical_or
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
r_goto
id|do_zombie
suffix:semicolon
id|ovfl_regs
op_assign
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
singleline_comment|//if (CTX_OVFL_NOBLOCK(ctx)) goto skip_blocking;
r_if
c_cond
(paren
id|reason
op_eq
id|PFM_TRAP_REASON_RESET
)paren
r_goto
id|skip_blocking
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;before block sleeping&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;after block sleeping ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_going_zombie
)paren
(brace
id|do_zombie
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context is zombie, bailing out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pfm_context_force_terminate
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
r_goto
id|nothing_to_do
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|nothing_to_do
suffix:semicolon
id|skip_blocking
suffix:colon
id|pfm_resume_after_ovfl
c_func
(paren
id|ctx
comma
id|ovfl_regs
comma
id|regs
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|nothing_to_do
suffix:colon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_notify_user
id|pfm_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
id|pfm_msg_t
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ignoring overflow notification, owner is zombie&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] waking up somebody&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * safe, we are not in intr handler, nor in ctxsw when&n;&t; * we come here&n;&t; */
id|kill_fasync
(paren
op_amp
id|ctx-&gt;ctx_async_queue
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ovfl_notify_user
id|pfm_ovfl_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_pmds
)paren
(brace
id|pfm_msg_t
op_star
id|msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_no_msg
op_eq
l_int|0
)paren
(brace
id|msg
op_assign
id|pfm_get_new_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_ovfl_notify_user no more notification msgs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg-&gt;pfm_ovfl_msg.msg_type
op_assign
id|PFM_MSG_OVFL
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ctx_fd
op_assign
id|ctx-&gt;ctx_fd
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_tstamp
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* relevant on UP only */
id|msg-&gt;pfm_ovfl_msg.msg_active_set
op_assign
l_int|0
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|1
)braket
op_assign
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|2
)braket
op_assign
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|3
)braket
op_assign
l_int|0UL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ovfl msg: msg=%p no_msg=%d fd=%d pid=%d ovfl_pmds=0x%lx&bslash;n&quot;
comma
id|msg
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
comma
id|current-&gt;pid
comma
id|ovfl_pmds
)paren
)paren
suffix:semicolon
r_return
id|pfm_notify_user
c_func
(paren
id|ctx
comma
id|msg
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_end_notify_user
id|pfm_end_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|msg
op_assign
id|pfm_get_new_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_end_notify_user no more notification msgs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg-&gt;pfm_end_msg.msg_type
op_assign
id|PFM_MSG_END
suffix:semicolon
id|msg-&gt;pfm_end_msg.msg_ctx_fd
op_assign
id|ctx-&gt;ctx_fd
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_tstamp
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* relevant on UP only */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;end msg: msg=%p no_msg=%d ctx_fd=%d pid=%d&bslash;n&quot;
comma
id|msg
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_return
id|pfm_notify_user
c_func
(paren
id|ctx
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; */
r_static
r_void
DECL|function|pfm_overflow_handler
id|pfm_overflow_handler
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_ovfl_arg_t
id|ovfl_arg
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|old_val
suffix:semicolon
r_int
r_int
id|ovfl_notify
op_assign
l_int|0UL
comma
id|ovfl_pmds
op_assign
l_int|0UL
comma
id|smpl_pmds
op_assign
l_int|0UL
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|ovfl_ctrl
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|has_smpl
comma
id|first_pmd
op_assign
op_complement
l_int|0U
suffix:semicolon
r_int
id|must_notify
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
)paren
r_goto
id|stop_monitoring
suffix:semicolon
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
)paren
r_goto
id|sanity_check
suffix:semicolon
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d iip=0x%lx, %s&quot;
l_string|&quot;used_pmds=0x%lx reload_pmcs=0x%lx&bslash;n&quot;
comma
id|pmc0
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
(paren
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0
)paren
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;nonblocking&quot;
suffix:colon
l_string|&quot;blocking&quot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|has_smpl
op_assign
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first we update the virtual counters&n;&t; * assume there was a prior ia64_srlz_d() issued&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip pmd which did not overflow */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;pmd[%d] overflowed hw_pmd=0x%lx ctx_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that the pmd is not necessarily 0 at this point as qualified events&n;&t;&t; * may have happened before the PMU was frozen. The residual count is not&n;&t;&t; * taken into consideration here but will be with any read of the pmd via&n;&t;&t; * pfm_read_pmds().&n;&t;&t; */
id|old_val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for overflow condition&n;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|old_val
OG
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
(brace
id|ovfl_pmds
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * keep track of pmds of interest for samples&n;&t;&t;&t; */
r_if
c_cond
(paren
id|has_smpl
)paren
(brace
r_if
c_cond
(paren
id|first_pmd
op_eq
op_complement
l_int|0U
)paren
id|first_pmd
op_assign
id|i
suffix:semicolon
id|smpl_pmds
op_or_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_pmds
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
id|ovfl_notify
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;ctx_pmd[%d].val=0x%lx old_val=0x%lx pmd=0x%lx ovfl_pmds=0x%lx ovfl_notify=0x%lx first_pmd=%u smpl_pmds=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|old_val
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.ovfl_val
comma
id|ovfl_pmds
comma
id|ovfl_notify
comma
id|first_pmd
comma
id|smpl_pmds
)paren
)paren
suffix:semicolon
)brace
id|ovfl_ctrl.notify_user
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_ctrl.reset_pmds
op_assign
id|ovfl_pmds
op_logical_and
id|ovfl_notify
op_eq
l_int|0UL
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_ctrl.block
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_ctrl.stop_monitoring
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * when a overflow is detected, check for sampling buffer, if present, invoke&n;&t; * record() callback.&n;&t; */
r_if
c_cond
(paren
id|ovfl_pmds
op_logical_and
id|has_smpl
)paren
(brace
r_int
r_int
id|start_cycles
suffix:semicolon
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|ovfl_arg.ovfl_pmds
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
id|ovfl_arg.ovfl_notify
(braket
l_int|0
)braket
op_assign
id|ovfl_notify
suffix:semicolon
id|ovfl_arg.ovfl_ctrl
op_assign
id|ovfl_ctrl
suffix:semicolon
id|ovfl_arg.smpl_pmds
(braket
l_int|0
)braket
op_assign
id|smpl_pmds
suffix:semicolon
id|prefetch
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|ovfl_arg.pmd_value
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|first_pmd
)braket
dot
id|val
suffix:semicolon
id|ovfl_arg.pmd_last_reset
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|first_pmd
)braket
dot
id|lval
suffix:semicolon
id|ovfl_arg.pmd_eventid
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|first_pmd
)braket
dot
id|eventid
suffix:semicolon
multiline_comment|/*&n;&t;&t; * copy values of pmds of interest. Sampling format may copy them&n;&t;&t; * into sampling buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|smpl_pmds
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|smpl_pmds
suffix:semicolon
id|i
op_increment
comma
id|smpl_pmds
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|smpl_pmds
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ovfl_arg.smpl_pmds_values
(braket
id|j
op_increment
)braket
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
ques
c_cond
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|i
)paren
suffix:colon
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_smpl_handler_calls
op_increment
suffix:semicolon
id|start_cycles
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * call custom buffer format record (handler) routine&n;&t;&t; */
(paren
op_star
id|ctx-&gt;ctx_buf_fmt-&gt;fmt_handler
)paren
(paren
id|task
comma
id|ctx-&gt;ctx_smpl_hdr
comma
op_amp
id|ovfl_arg
comma
id|regs
)paren
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_smpl_handler_cycles
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start_cycles
suffix:semicolon
id|ovfl_pmds
op_assign
id|ovfl_arg.ovfl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|ovfl_notify
op_assign
id|ovfl_arg.ovfl_notify
(braket
l_int|0
)braket
suffix:semicolon
id|ovfl_ctrl
op_assign
id|ovfl_arg.ovfl_ctrl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ovfl_pmds
op_logical_and
id|ovfl_ctrl.reset_pmds
)paren
(brace
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|ovfl_pmds
comma
id|ovfl_ctrl.reset_pmds
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ovfl_notify
op_logical_and
id|ovfl_ctrl.notify_user
)paren
(brace
multiline_comment|/*&n;&t;&t; * keep track of what to reset when unblocking&n;&t;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ovfl_ctrl.block
)paren
(brace
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_BLOCK
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * set the perfmon specific checking pending work&n;&t;&t;&t; */
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * when coming from ctxsw, current still points to the&n;&t;&t;&t; * previous task, therefore we must work with task and not current.&n;&t;&t;&t; */
id|pfm_set_task_notify
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * defer until state is changed (shorten spin window). the context is locked&n;&t;&t; * anyway, so the signal receiver would come spin for nothing.&n;&t;&t; */
id|must_notify
op_assign
l_int|1
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;current [%d] owner [%d] pending=%ld reason=%u ovfl_pmds=0x%lx ovfl_notify=0x%lx stopped=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|GET_PMU_OWNER
c_func
(paren
)paren
ques
c_cond
id|GET_PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
comma
id|PFM_GET_WORK_PENDING
c_func
(paren
id|task
)paren
comma
id|ctx-&gt;ctx_fl_trap_reason
comma
id|ovfl_pmds
comma
id|ovfl_notify
comma
id|ovfl_ctrl.stop_monitoring
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case monitoring must be stopped, we toggle the psr bits&n;&t; */
r_if
c_cond
(paren
id|ovfl_ctrl.stop_monitoring
)paren
(brace
id|pfm_mask_monitoring
c_func
(paren
id|task
)paren
suffix:semicolon
id|CTX_MASKED
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * send notification now&n;&t; */
r_if
c_cond
(paren
id|must_notify
)paren
id|pfm_ovfl_notify_user
c_func
(paren
id|ctx
comma
id|ovfl_notify
)paren
suffix:semicolon
r_return
suffix:semicolon
id|sanity_check
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: CPU%d overflow handler [%d] pmc0=0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|pmc0
)paren
suffix:semicolon
r_return
suffix:semicolon
id|stop_monitoring
suffix:colon
multiline_comment|/*&n;&t; * in SMP, zombie context is never restored but reclaimed in pfm_load_regs().&n;&t; * Moreover, zombies are also reclaimed in pfm_save_regs(). Therefore we can&n;&t; * come here as zombie only if the task is the current task. In which case, we&n;&t; * can access the PMU  hardware directly.&n;&t; *&n;&t; * Note that zombies do have PM_VALID set. So here we do the minimal.&n;&t; *&n;&t; * In case the context was zombified it could not be reclaimed at the time&n;&t; * the monitoring program exited. At this point, the PMU reservation has been&n;&t; * returned, the sampiing buffer has been freed. We must convert this call&n;&t; * into a spurious interrupt. However, we must also avoid infinite overflows&n;&t; * by stopping monitoring for this task. We can only come here for a per-task&n;&t; * context. All we need to do is to stop monitoring using the psr bits which&n;&t; * are always task private. By re-enabling secure montioring, we ensure that&n;&t; * the monitored task will not be able to re-activate monitoring.&n;&t; * The task will eventually be context switched out, at which point the context&n;&t; * will be reclaimed (that includes releasing ownership of the PMU).&n;&t; *&n;&t; * So there might be a window of time where the number of per-task session is zero&n;&t; * yet one PMU might have a owner and get at most one overflow interrupt for a zombie&n;&t; * context. This is safe because if a per-task session comes in, it will push this one&n;&t; * out and by the virtue on pfm_save_regs(), this one will disappear. If a system wide&n;&t; * session is force on that CPU, given that we use task pinning, pfm_save_regs() will&n;&t; * also push our zombie context out.&n;&t; *&n;&t; * Overall pretty hairy stuff....&n;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx is zombie for [%d], converted to spurious&bslash;n&quot;
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_do_interrupt_handler
id|pfm_do_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|pmc0
suffix:semicolon
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * srlz.d done before arriving here&n;&t; */
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PMC0.bit[63-1] is set, then PMC0.fr = 1&n;&t; */
r_if
c_cond
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|pmc0
)paren
op_logical_and
id|task
)paren
(brace
multiline_comment|/*&n;&t;&t; * we assume that pmc0.fr is always set here&n;&t;&t; */
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|report_spurious
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
op_logical_and
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: current [%d] owner = [%d] PMVALID=0 state=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
suffix:semicolon
r_goto
id|report_spurious
suffix:semicolon
)brace
id|PROTECT_CTX_NOPRINT
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|ctx
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
id|UNPROTECT_CTX_NOPRINT
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_spurious_ovfl_intr_count
op_increment
suffix:semicolon
id|retval
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * keep it unfrozen at all times&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|report_spurious
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: spurious overflow interrupt on CPU%d: process %d has no PFM context&bslash;n&quot;
comma
id|this_cpu
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
id|pfm_irq_handler_t
DECL|function|pfm_interrupt_handler
id|pfm_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|m
suffix:semicolon
r_int
r_int
id|min
comma
id|max
suffix:semicolon
r_int
id|this_cpu
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|min
op_assign
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_min
suffix:semicolon
id|max
op_assign
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_max
suffix:semicolon
id|m
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_do_interrupt_handler
c_func
(paren
id|irq
comma
id|arg
comma
id|regs
)paren
suffix:semicolon
id|m
op_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|m
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t measure spurious interrupts&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|m
OL
id|min
)paren
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|max
)paren
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_max
op_assign
id|m
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles
op_add_assign
id|m
suffix:semicolon
)brace
id|PFM_IRQ_HANDLER_RET
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|pfm_proc_info
id|pfm_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|b
suffix:semicolon
r_int
r_int
id|psr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;model                     : %s&bslash;n&quot;
comma
id|pmu_conf.pmu_name
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;fastctxsw                 : %s&bslash;n&quot;
comma
id|pfm_sysctl.fastctxsw
OG
l_int|0
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;ovfl_mask                 : 0x%lx&bslash;n&quot;
comma
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_online
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d overflow intrs      : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d overflow cycles     : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_cycles
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d overflow min        : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_cycles_min
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d overflow max        : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_cycles_max
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d smpl handler calls  : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_smpl_handler_calls
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d smpl handler cycles : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_smpl_handler_cycles
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d spurious intrs      : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_spurious_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d sysupdt count       : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_sysupdt_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d sysupdt cycles      : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_sysupdt_cycles
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d syst_wide           : %d&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_SYST_WIDE
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d dcr_pp              : %d&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d exclude idle        : %d&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|i
)paren
op_amp
id|PFM_CPUINFO_EXCL_IDLE
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d owner               : %d&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_owner
comma
id|i
)paren
ques
c_cond
id|pfm_get_cpu_data
c_func
(paren
id|pmu_owner
comma
id|i
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d context             : %p&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_ctx
comma
id|i
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d activations         : %lu&bslash;n&quot;
comma
id|i
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_activation_number
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hweight64
c_func
(paren
id|PFM_CPU_ONLINE_MAP
)paren
op_eq
l_int|1
)paren
(brace
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d psr                 : 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|psr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d pmc0                : 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d pmc%u                : 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|i
comma
id|ia64_get_pmc
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%-2d pmd%u                : 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;proc_sessions             : %u&bslash;n&quot;
l_string|&quot;sys_sessions              : %u&bslash;n&quot;
l_string|&quot;sys_use_dbregs            : %u&bslash;n&quot;
l_string|&quot;ptrace_use_dbregs         : %u&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|LOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|pfm_buffer_fmt_list
suffix:semicolon
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;fmt_next
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;format                    : %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x %s&bslash;n&quot;
comma
id|b-&gt;fmt_uuid
(braket
l_int|0
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|1
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|2
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|3
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|4
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|5
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|6
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|7
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|8
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|9
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|10
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|11
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|12
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|13
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|14
)braket
comma
id|b-&gt;fmt_uuid
(braket
l_int|15
)braket
comma
id|b-&gt;fmt_name
)paren
suffix:semicolon
)brace
id|UNLOCK_BUF_FMT_LIST
c_func
(paren
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/* /proc interface, for debug only */
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|pfm_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * we come here as soon as local_cpu_data-&gt;pfm_syst_wide is set. this happens&n; * during pfm_enable() hence before pfm_start(). We cannot assume monitoring&n; * is active or inactive based on mode. We must rely on the value in&n; * local_cpu_data-&gt;pfm_syst_info&n; */
r_void
DECL|function|pfm_do_syst_wide_update_task
id|pfm_do_syst_wide_update_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|info
comma
r_int
id|is_ctxswin
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|dcr
suffix:semicolon
r_int
r_int
id|dcr_pp
suffix:semicolon
id|dcr_pp
op_assign
id|info
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * pid 0 is guaranteed to be the idle task. There is one such task with pid 0&n;&t; * on every CPU, so we can rely on the pid to identify the idle task.&n;&t; */
r_if
c_cond
(paren
(paren
id|info
op_amp
id|PFM_CPUINFO_EXCL_IDLE
)paren
op_eq
l_int|0
op_logical_or
id|task-&gt;pid
)paren
(brace
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|is_ctxswin
ques
c_cond
id|dcr_pp
suffix:colon
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if monitoring has started&n;&t; */
r_if
c_cond
(paren
id|dcr_pp
)paren
(brace
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * context switching in?&n;&t;&t; */
r_if
c_cond
(paren
id|is_ctxswin
)paren
(brace
multiline_comment|/* mask monitoring for the idle task */
id|ia64_set_dcr
c_func
(paren
id|dcr
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * context switching out&n;&t;&t; * restore monitoring for next task&n;&t;&t; *&n;&t;&t; * Due to inlining this odd if-then-else construction generates&n;&t;&t; * better code.&n;&t;&t; */
id|ia64_set_dcr
c_func
(paren
id|dcr
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|pfm_syst_wide_update_task
id|pfm_syst_wide_update_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|info
comma
r_int
id|is_ctxswin
)paren
(brace
r_int
r_int
id|start
comma
id|end
suffix:semicolon
id|pfm_stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|pfm_sysupdt_count
op_increment
suffix:semicolon
id|start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
id|pfm_do_syst_wide_update_task
c_func
(paren
id|task
comma
id|info
comma
id|is_ctxswin
)paren
suffix:semicolon
id|end
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
id|pfm_stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|pfm_sysupdt_cycles
op_add_assign
id|end
op_minus
id|start
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_goto
id|save_error
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n; &t; * we always come here with interrupts ALREADY disabled by&n; &t; * the scheduler. So we simply need to protect against concurrent&n;&t; * access, not CPU concurrency.&n;&t; */
id|flags
op_assign
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx zombie, forcing cleanup for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|pfm_force_cleanup
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity check&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_last_activation
op_ne
id|GET_ACTIVATION
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_activation=%lu activation=%lu state=%d: no save&bslash;n&quot;
comma
id|ctx-&gt;ctx_last_activation
comma
id|GET_ACTIVATION
c_func
(paren
)paren
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which may generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep a copy of the saved psr (for reload)&n;&t; */
id|ctx-&gt;ctx_saved_psr
op_assign
id|psr
suffix:semicolon
multiline_comment|/*&n;&t; * release ownership of this PMU.&n;&t; * PM interrupts are masked, so nothing&n;&t; * can happen.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we systematically save the PMD as we have no&n;&t; * guarantee we will be schedule at that same&n;&t; * CPU again.&n;&t; */
id|pfm_save_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save pmc0 ia64_srlz_d() done in pfm_save_pmds()&n;&t; * we will need it on the restore path to check&n;&t; * for pending overflow.&n;&t; */
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * unfreeze PMU if had pending overflows&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|1UL
)paren
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * finally, unmask interrupts and allow context&n;&t; * access.&n;&t; * Any pended overflow interrupt may be delivered&n;&t; * here and will be treated as spurious because we&n;&t; * have have no PMU owner anymore.&n;&t; */
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|save_error
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_save_regs CPU%d [%d] NULL context PM_VALID=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|task-&gt;pid
comma
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_SMP */
multiline_comment|/*&n; * in 2.5, interrupts are masked when we come here&n; */
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_goto
id|save_error
suffix:semicolon
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which may generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep a copy of the saved psr (for reload)&n;&t; */
id|ctx-&gt;ctx_saved_psr
op_assign
id|psr
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psr
op_amp
id|IA64_PSR_UP
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; perfmon: pfm_save_regs: psr.up set current [%d] owner [%d] psr=0x%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|GET_PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
comma
id|psr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; perfmon: pfm_save_regs: psr.i set current [%d] owner [%d] psr=0x%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|GET_PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
comma
id|psr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|save_error
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_save_regs CPU%d [%d] NULL context PM_VALID=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|task-&gt;pid
comma
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_lazy_save_regs
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|psr
suffix:semicolon
macro_line|#if 1
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psr
op_amp
id|IA64_PSR_UP
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; perfmon: pfm_lazy_save_regs: psr.up set current [%d] owner [%d] psr=0x%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|psr
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;on [%d] used_pmds=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we need to mask PMU overflow here to&n;&t; * make sure that we maintain pmc0 until&n;&t; * we save it. overflow interrupts are&n;&t; * treated as spurious if there is no&n;&t; * owner.&n;&t; *&n;&t; * XXX: I don&squot;t think this is necessary&n;&t; */
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * release ownership of this PMU.&n;&t; * must be done before we save the registers.&n;&t; *&n;&t; * after this call any PMU interrupt is treated&n;&t; * as spurious.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save all the pmds we use&n;&t; */
id|pfm_save_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save pmc0 ia64_srlz_d() done in pfm_save_pmds()&n;&t; * it is needed to check for pended overflow&n;&t; * on the restore path&n;&t; */
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * unfreeze PMU if had pending overflows&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|1UL
)paren
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now get can unmask PMU interrupts, they will&n;&t; * be treated as purely spurious and we will not&n;&t; * lose any information&n;&t; */
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef CONFIG_SMP
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|pmc_mask
op_assign
l_int|0UL
comma
id|pmd_mask
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_load_regs() null context&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|owner
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
macro_line|#if 1
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
id|IA64_PSR_UP
)paren
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * possible on unload&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|t-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] PM_VALID=0, nothing to do&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * we always come here with interrupts ALREADY disabled by&n; &t; * the scheduler. So we simply need to protect against concurrent&n;&t; * access, not CPU concurrency.&n;&t; */
id|flags
op_assign
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|CTX_IS_ZOMBIE
c_func
(paren
id|ctx
)paren
)paren
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx zombie, forcing cleanup for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|pfm_force_cleanup
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this one (kmalloc&squot;ed) is fine with interrupts disabled&n;&t;&t; */
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we restore ALL the debug registers to avoid picking up&n;&t; * stale state.&n;&t; *&n;&t; * This must be done even when the task is still the owner&n;&t; * as the registers may have been modified via ptrace()&n;&t; * (not perfmon) by the previous task.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf.num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf.num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * retrieve saved psr&n;&t; */
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
multiline_comment|/*&n;&t; * if we were the last user of the PMU on that CPU,&n;&t; * then nothing to do except restore psr&n;&t; */
r_if
c_cond
(paren
id|GET_LAST_CPU
c_func
(paren
id|ctx
)paren
op_eq
id|smp_processor_id
c_func
(paren
)paren
op_logical_and
id|ctx-&gt;ctx_last_activation
op_eq
id|GET_ACTIVATION
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * retrieve partial reload masks (due to user modifications)&n;&t;&t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
suffix:semicolon
id|pmd_mask
op_assign
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pmc_mask
op_logical_or
id|pmd_mask
)paren
id|DPRINT
c_func
(paren
(paren
l_string|&quot;partial reload [%d] pmd_mask=0x%lx pmc_mask=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pmd_mask
comma
id|pmc_mask
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t; &t; * To avoid leaking information to the user level when psr.sp=0,&n;&t; &t; * we must reload ALL implemented pmds (even the ones we don&squot;t use).&n;&t; &t; * In the kernel we only allow PFM_READ_PMDS on registers which&n;&t; &t; * we initialized or requested (sampling) so there is no risk there.&n;&t; &t; */
id|pmd_mask
op_assign
id|pfm_sysctl.fastctxsw
ques
c_cond
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:colon
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; &t; * ALL accessible PMCs are systematically reloaded, unused registers&n;&t; &t; * get their default (from pfm_reset_pmu_state()) values to avoid picking&n;&t; &t; * up stale configuration.&n;&t; &t; *&n;&t; &t; * PMC0 is never in the mask. It is always restored separately.&n;&t; &t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;full reload for [%d] owner=%d activation=%lu last_activation=%lu last_cpu=%d pmd_mask=0x%lx pmc_mask=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|owner
ques
c_cond
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|GET_ACTIVATION
c_func
(paren
)paren
comma
id|ctx-&gt;ctx_last_activation
comma
id|GET_LAST_CPU
c_func
(paren
id|ctx
)paren
comma
id|pmd_mask
comma
id|pmc_mask
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * when context is MASKED, we will restore PMC with plm=0&n;&t; * and PMD with stale information, but that&squot;s ok, nothing&n;&t; * will be captured.&n;&t; *&n;&t; * XXX: optimize here&n;&t; */
r_if
c_cond
(paren
id|pmd_mask
)paren
id|pfm_restore_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|pmd_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmc_mask
)paren
id|pfm_restore_pmcs
c_func
(paren
id|t-&gt;pmcs
comma
id|pmc_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for pending overflow at the time the state&n;&t; * was saved.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
)paren
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|ctx
comma
id|t-&gt;pmcs
(braket
l_int|0
)braket
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we clear PMC0, to ensure that any in flight interrupt&n;&t; * will not be attributed to the new context we are installing&n;&t; * because the actual overflow has been processed above already.&n;&t; * No real effect until we unmask interrupts at the end of the&n;&t; * function.&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we just did a reload, so we reset the partial reload fields&n;&t; */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dump activation value for this PMU&n;&t; */
id|INC_ACTIVATION
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * record current activation for this context&n;&t; */
id|SET_ACTIVATION
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * establish new ownership. Interrupts&n;&t; * are still masked at this point.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr we changed&n;&t; */
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allow concurrent access to context&n;&t; */
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else /*  !CONFIG_SMP */
multiline_comment|/*&n; * reload PMU state for UP kernels&n; * in 2.5 we come here with interrupts disabled&n; */
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|pmd_mask
comma
id|pmc_mask
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|owner
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
macro_line|#if 1
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psr
op_amp
id|IA64_PSR_UP
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; perfmon: pfm_load_regs: psr.up set current [%d] owner [%d] psr=0x%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|owner-&gt;pid
comma
id|psr
)paren
suffix:semicolon
)brace
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; perfmon: pfm_load_regs: psr.i set current [%d] owner [%d] psr=0x%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|owner-&gt;pid
comma
id|psr
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * we restore ALL the debug registers to avoid picking up&n;&t; * stale state.&n;&t; *&n;&t; * This must be done even when the task is still the owner&n;&t; * as the registers may have been modified via ptrace()&n;&t; * (not perfmon) by the previous task.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf.num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf.num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * retrieved save psr&n;&t; */
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
multiline_comment|/*&n;&t; * short path, our state is still there, just&n;&t; * need to restore psr and we go&n;&t; *&n;&t; * we do not touch either PMC nor PMD. the psr is not touched&n;&t; * by the overflow_handler. So we are safe w.r.t. to interrupt&n;&t; * concurrency even without interrupt masking.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|owner
op_eq
id|task
)paren
)paren
(brace
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;reload for [%d] owner=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|owner
ques
c_cond
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * someone else is still using the PMU, first push it out and&n;&t; * then we&squot;ll be able to install our stuff !&n;&t; *&n;&t; * Upon return, there will be no owner for the current PMU&n;&t; */
r_if
c_cond
(paren
id|owner
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid leaking information to the user level when psr.sp=0,&n;&t; * we must reload ALL implemented pmds (even the ones we don&squot;t use).&n;&t; * In the kernel we only allow PFM_READ_PMDS on registers which&n;&t; * we initialized or requested (sampling) so there is no risk there.&n;&t; */
id|pmd_mask
op_assign
id|pfm_sysctl.fastctxsw
ques
c_cond
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:colon
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * ALL accessible PMCs are systematically reloaded, unused registers&n;&t; * get their default (from pfm_reset_pmu_state()) values to avoid picking&n;&t; * up stale configuration.&n;&t; *&n;&t; * PMC0 is never in the mask. It is always restored separately&n;&t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
id|pfm_restore_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|pmd_mask
)paren
suffix:semicolon
id|pfm_restore_pmcs
c_func
(paren
id|t-&gt;pmcs
comma
id|pmc_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for pending overflow when state was last saved.&n;&t; * invoked handler is overflow status bits set.&n;&t; *&n;&t; * Any PMU overflow in flight at this point, will still&n;&t; * be treated as spurious because we have no declared&n;&t; * owner. Note that the first level interrupt handler&n;&t; * DOES NOT TOUCH any PMC except PMC0 for which we have&n;&t; * a copy already.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
)paren
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|ctx
comma
id|t-&gt;pmcs
(braket
l_int|0
)braket
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we clear PMC0, to ensure that any in flight interrupt&n;&t; * will not be attributed to the new context we are installing&n;&t; * because the actual overflow has been processed above already.&n;&t; *&n;&t; * This is an atomic operation.&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * establish new ownership. If there was an in-flight&n;&t; * overflow interrupt, it will be treated as spurious&n;&t; * before and after the call, because no overflow&n;&t; * status bit can possibly be set. No new overflow&n;&t; * can be generated because, at this point, psr.up&n;&t; * is still cleared.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr. This is the point at which&n;&t; * new overflow interrupts can be generated again.&n;&t; */
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * this function assumes monitoring is stopped&n; */
r_static
r_void
DECL|function|pfm_flush_pmds
id|pfm_flush_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_int
r_int
id|mask2
comma
id|val
comma
id|pmd_val
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
suffix:semicolon
r_int
id|is_self
suffix:semicolon
multiline_comment|/*&n;&t; * is the caller the task being monitored (or which initiated the&n;&t; * session for system wide measurements)&n;&t; */
id|is_self
op_assign
id|ctx-&gt;ctx_task
op_eq
id|task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
macro_line|#else
multiline_comment|/*&n;&t; * in UP, the state can still be in the registers&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
)paren
(brace
macro_line|#endif
id|can_access_pmu
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark the PMU as not owned&n;&t;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t;&t; * interrupt was in-flight&n;&t;&t; * This also guarantees that pmc0 will contain the final state&n;&t;&t; * It virtually gives us full control on overflow processing from that point&n;&t;&t; * on.&n;&t;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read current overflow status:&n;&t;&t; *&n;&t;&t; * we are guaranteed to read the final stable state&n;&t;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t;&t; * reset freeze bit, overflow status information destroyed&n;&t;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pmc0
op_assign
id|task-&gt;thread.pmcs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * clear whatever overflow status bits there were&n;&t;&t; */
id|task-&gt;thread.pmcs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|0x1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we save all the used pmds&n;&t; * we take care of overflows for counting PMDs&n;&t; *&n;&t; * XXX: sampling situation is not taken into account here&n;&t; */
id|mask2
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask2
suffix:semicolon
id|i
op_increment
comma
id|mask2
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask2
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * can access PMU always true in system wide mode&n;&t;&t; */
id|val
op_assign
id|pmd_val
op_assign
id|can_access_pmu
ques
c_cond
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:colon
id|task-&gt;thread.pmds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] ctx_pmd=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we rebuild the full 64 bit value of the counter&n;&t;&t;&t; */
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|val
op_amp
id|pmu_conf.ovfl_val
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now everything is in ctx_pmds[] and we need&n;&t;&t;&t; * to clear the saved context from save_regs() such that&n;&t;&t;&t; * pfm_read_pmds() gets the correct value&n;&t;&t;&t; */
id|pmd_val
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * take care of overflow inline&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pmc0
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.ovfl_val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] overflowed&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] is_self=%d ctx_pmd[%d]=0x%lx  pmd_val=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|is_self
comma
id|i
comma
id|val
comma
id|pmd_val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_self
)paren
id|task-&gt;thread.pmds
(braket
id|i
)braket
op_assign
id|pmd_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
suffix:semicolon
)brace
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|pfm_interrupt_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * perfmon initialization routine, called from the initcall() table&n; */
r_static
r_int
id|init_pfm_fs
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|__init
DECL|function|pfm_init
id|pfm_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|n
comma
id|n_counters
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: version %u.%u IRQ %u&bslash;n&quot;
comma
id|PFM_VERSION_MAJ
comma
id|PFM_VERSION_MIN
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * PMU type sanity check&n;&t; * XXX: maybe better to implement autodetection (but then we have a larger kernel)&n;&t; */
r_if
c_cond
(paren
id|local_cpu_data-&gt;family
op_ne
id|pmu_conf.pmu_family
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: disabled, kernel only supports %s PMU family&bslash;n&quot;
comma
id|pmu_conf.pmu_name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * compute the number of implemented PMD/PMC from the&n;&t; * description tables&n;&t; */
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf.impl_pmcs
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
id|pmu_conf.num_pmcs
op_assign
id|n
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|n_counters
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf.impl_pmds
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
id|n_counters
op_increment
suffix:semicolon
)brace
id|pmu_conf.num_pmds
op_assign
id|n
suffix:semicolon
id|pmu_conf.num_counters
op_assign
id|n_counters
suffix:semicolon
multiline_comment|/*&n;&t; * sanity checks on the number of debug registers&n;&t; */
r_if
c_cond
(paren
id|pmu_conf.use_rr_dbregs
)paren
(brace
r_if
c_cond
(paren
id|pmu_conf.num_ibrs
OG
id|IA64_NUM_DBG_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: unsupported number of code debug registers (%u)&bslash;n&quot;
comma
id|pmu_conf.num_ibrs
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmu_conf.num_dbrs
OG
id|IA64_NUM_DBG_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: unsupported number of data debug registers (%u)&bslash;n&quot;
comma
id|pmu_conf.num_ibrs
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;perfmon: %s PMU detected, %u PMCs, %u PMDs, %u counters (%lu bits)&bslash;n&quot;
comma
id|pmu_conf.pmu_name
comma
id|pmu_conf.num_pmcs
comma
id|pmu_conf.num_pmds
comma
id|pmu_conf.num_counters
comma
id|ffz
c_func
(paren
id|pmu_conf.ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf.num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf.num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: not enough pmc/pmd, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * create /proc/perfmon (mostly for debugging purposes)&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perfmon_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: cannot create /proc entry, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * create /proc/sys/kernel/perfmon (for debugging purposes)&n;&t; */
id|pfm_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|pfm_sysctl_root
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize all our spinlocks&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_sessions.pfs_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_smpl_fmt_lock
)paren
suffix:semicolon
id|init_pfm_fs
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/* we are all set */
id|pmu_conf.enabled
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfm_init
id|__initcall
c_func
(paren
id|pfm_init
)paren
suffix:semicolon
r_void
DECL|function|pfm_init_percpu
id|pfm_init_percpu
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * make sure no measurement is active&n;&t; * (may inherit programmed PMCs from EFI).&n;&t; */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_eq
l_int|0
)paren
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we first initialize the PMU to a stable state.&n;&t; * the values may have been changed from their power-up&n;&t; * values by software executed before the kernel took over.&n;&t; *&n;&t; * At this point, pmu_conf has not yet been initialized&n;&t; *&n;&t; * On McKinley, this code is ineffective until PMC4 is initialized&n;&t; * but that&squot;s all right because we take care of pmc0 later.&n;&t; *&n;&t; * XXX: potential problems with pmc1.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we run with the PMU not frozen at all times&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used for debug purposes only&n; */
r_void
DECL|function|dump_pmu_state
id|dump_pmu_state
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|psr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current [%d] %s&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;owner [%d] ctx=%p&bslash;n&quot;
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|ctx
)paren
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psr.pp=%ld psr.up=%ld&bslash;n&quot;
comma
(paren
id|psr
op_rshift
id|IA64_PSR_PP_BIT
)paren
op_amp
l_int|0x1UL
comma
(paren
id|psr
op_rshift
id|IA64_PSR_PP_BIT
)paren
op_amp
l_int|0x1UL
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pmc[%d]=0x%lx tpmc=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ia64_get_pmc
c_func
(paren
id|i
)paren
comma
id|t-&gt;pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pmd[%d]=0x%lx tpmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
comma
id|t-&gt;pmds
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ctx_state=%d vaddr=%p addr=%p fd=%d ctx_task=[%d] saved_psr=0x%lx&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|ctx-&gt;ctx_saved_psr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * called from process.c:copy_thread(). task is new child.&n; */
r_void
DECL|function|pfm_inherit
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;perfmon: pfm_inherit clearing state for [%d] current [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * cut links inherited from parent (current)&n;&t; */
id|thread-&gt;pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore default psr settings&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
id|pfm_ctxid_t
id|ctxid
comma
r_int
id|cmd
comma
r_void
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
