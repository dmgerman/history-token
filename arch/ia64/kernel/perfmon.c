multiline_comment|/*&n; * This file implements the perfmon-2 subsystem which is used&n; * to program the IA-64 Performance Monitoring Unit (PMU).&n; *&n; * The initial version of perfmon.c was written by&n; * Ganesh Venkitachalam, IBM Corp.&n; *&n; * Then it was modified for perfmon-1.x by Stephane Eranian and &n; * David Mosberger, Hewlett Packard Co.&n; * &n; * Version Perfmon-2.x is a rewrite of perfmon-1.x&n; * by Stephane Eranian, Hewlett Packard Co. &n; *&n; * Copyright (C) 1999-2003  Hewlett Packard Co&n; *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *               David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * More information about perfmon available at:&n; * &t;http://www.hpl.hp.com/research/linux/perfmon&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/intrinsics.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#ifdef CONFIG_PERFMON
multiline_comment|/*&n; * perfmon context state&n; */
DECL|macro|PFM_CTX_UNLOADED
mdefine_line|#define PFM_CTX_UNLOADED&t;1&t;/* context is not loaded onto any task */
DECL|macro|PFM_CTX_LOADED
mdefine_line|#define PFM_CTX_LOADED&t;&t;2&t;/* context is loaded onto a task */
DECL|macro|PFM_CTX_MASKED
mdefine_line|#define PFM_CTX_MASKED&t;&t;3&t;/* context is loaded but monitoring is masked due to overflow */
DECL|macro|PFM_CTX_ZOMBIE
mdefine_line|#define PFM_CTX_ZOMBIE&t;&t;4&t;/* owner of the context is closing it */
DECL|macro|PFM_INVALID_ACTIVATION
mdefine_line|#define PFM_INVALID_ACTIVATION&t;(~0UL)
multiline_comment|/*&n; * depth of message queue&n; */
DECL|macro|PFM_MAX_MSGS
mdefine_line|#define PFM_MAX_MSGS&t;&t;32
DECL|macro|PFM_CTXQ_EMPTY
mdefine_line|#define PFM_CTXQ_EMPTY(g)&t;((g)-&gt;ctx_msgq_head == (g)-&gt;ctx_msgq_tail)
multiline_comment|/*&n; * type of a PMU register (bitmask).&n; * bitmask structure:&n; * &t;bit0   : register implemented&n; * &t;bit1   : end marker&n; * &t;bit2-3 : reserved&n; * &t;bit4   : pmc has pmc.pm&n; * &t;bit5   : pmc controls a counter (has pmc.oi), pmd is used as counter&n; * &t;bit6-7 : register type&n; * &t;bit8-31: reserved&n; */
DECL|macro|PFM_REG_NOTIMPL
mdefine_line|#define PFM_REG_NOTIMPL&t;&t;0x0 /* not implemented at all */
DECL|macro|PFM_REG_IMPL
mdefine_line|#define PFM_REG_IMPL&t;&t;0x1 /* register implemented */
DECL|macro|PFM_REG_END
mdefine_line|#define PFM_REG_END&t;&t;0x2 /* end marker */
DECL|macro|PFM_REG_MONITOR
mdefine_line|#define PFM_REG_MONITOR&t;&t;(0x1&lt;&lt;4|PFM_REG_IMPL) /* a PMC with a pmc.pm field only */
DECL|macro|PFM_REG_COUNTING
mdefine_line|#define PFM_REG_COUNTING&t;(0x2&lt;&lt;4|PFM_REG_MONITOR) /* a monitor + pmc.oi+ PMD used as a counter */
DECL|macro|PFM_REG_CONTROL
mdefine_line|#define PFM_REG_CONTROL&t;&t;(0x4&lt;&lt;4|PFM_REG_IMPL) /* PMU control register */
DECL|macro|PFM_REG_CONFIG
mdefine_line|#define&t;PFM_REG_CONFIG&t;&t;(0x8&lt;&lt;4|PFM_REG_IMPL) /* configuration register */
DECL|macro|PFM_REG_BUFFER
mdefine_line|#define PFM_REG_BUFFER&t; &t;(0xc&lt;&lt;4|PFM_REG_IMPL) /* PMD used as buffer */
DECL|macro|PMC_IS_LAST
mdefine_line|#define PMC_IS_LAST(i)&t;(pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_END)
DECL|macro|PMD_IS_LAST
mdefine_line|#define PMD_IS_LAST(i)&t;(pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_END)
DECL|macro|PMC_OVFL_NOTIFY
mdefine_line|#define PMC_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
multiline_comment|/* i assumed unsigned */
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMCS &amp;&amp; (pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_IMPL))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;  (i&lt; PMU_MAX_PMDS &amp;&amp; (pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_IMPL))
multiline_comment|/* XXX: these assume that register i is implemented */
DECL|macro|PMD_IS_COUNTING
mdefine_line|#define PMD_IS_COUNTING(i) ((pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)
DECL|macro|PMC_IS_COUNTING
mdefine_line|#define PMC_IS_COUNTING(i) ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)
DECL|macro|PMC_IS_MONITOR
mdefine_line|#define PMC_IS_MONITOR(i)  ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_MONITOR)  == PFM_REG_MONITOR)
DECL|macro|PMC_IS_CONTROL
mdefine_line|#define PMC_IS_CONTROL(i)  ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_CONTROL)  == PFM_REG_CONTROL)
DECL|macro|PMC_DFL_VAL
mdefine_line|#define PMC_DFL_VAL(i)     pmu_conf-&gt;pmc_desc[i].default_value
DECL|macro|PMC_RSVD_MASK
mdefine_line|#define PMC_RSVD_MASK(i)   pmu_conf-&gt;pmc_desc[i].reserved_mask
DECL|macro|PMD_PMD_DEP
mdefine_line|#define PMD_PMD_DEP(i)&t;   pmu_conf-&gt;pmd_desc[i].dep_pmd[0]
DECL|macro|PMC_PMD_DEP
mdefine_line|#define PMC_PMD_DEP(i)&t;   pmu_conf-&gt;pmc_desc[i].dep_pmd[0]
DECL|macro|PFM_NUM_IBRS
mdefine_line|#define PFM_NUM_IBRS&t;  IA64_NUM_DBG_REGS
DECL|macro|PFM_NUM_DBRS
mdefine_line|#define PFM_NUM_DBRS&t;  IA64_NUM_DBG_REGS
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_block == 0)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_fl_is_sampling)
DECL|macro|PFM_CTX_TASK
mdefine_line|#define PFM_CTX_TASK(h)&t;&t;(h)-&gt;ctx_task
DECL|macro|PMU_PMC_OI
mdefine_line|#define PMU_PMC_OI&t;&t;5 /* position of pmc.oi bit */
multiline_comment|/* XXX: does not support more than 64 PMDs */
DECL|macro|CTX_USED_PMD
mdefine_line|#define CTX_USED_PMD(ctx, mask) (ctx)-&gt;ctx_used_pmds[0] |= (mask)
DECL|macro|CTX_IS_USED_PMD
mdefine_line|#define CTX_IS_USED_PMD(ctx, c) (((ctx)-&gt;ctx_used_pmds[0] &amp; (1UL &lt;&lt; (c))) != 0UL)
DECL|macro|CTX_USED_MONITOR
mdefine_line|#define CTX_USED_MONITOR(ctx, mask) (ctx)-&gt;ctx_used_monitors[0] |= (mask)
DECL|macro|CTX_USED_IBR
mdefine_line|#define CTX_USED_IBR(ctx,n) &t;(ctx)-&gt;ctx_used_ibrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_DBR
mdefine_line|#define CTX_USED_DBR(ctx,n) &t;(ctx)-&gt;ctx_used_dbrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USES_DBREGS
mdefine_line|#define CTX_USES_DBREGS(ctx)&t;(((pfm_context_t *)(ctx))-&gt;ctx_fl_using_dbreg==1)
DECL|macro|PFM_CODE_RR
mdefine_line|#define PFM_CODE_RR&t;0&t;/* requesting code range restriction */
DECL|macro|PFM_DATA_RR
mdefine_line|#define PFM_DATA_RR&t;1&t;/* requestion data range restriction */
DECL|macro|PFM_CPUINFO_CLEAR
mdefine_line|#define PFM_CPUINFO_CLEAR(v)&t;pfm_get_cpu_var(pfm_syst_info) &amp;= ~(v)
DECL|macro|PFM_CPUINFO_SET
mdefine_line|#define PFM_CPUINFO_SET(v)&t;pfm_get_cpu_var(pfm_syst_info) |= (v)
DECL|macro|PFM_CPUINFO_GET
mdefine_line|#define PFM_CPUINFO_GET()&t;pfm_get_cpu_var(pfm_syst_info)
DECL|macro|RDEP
mdefine_line|#define RDEP(x)&t;(1UL&lt;&lt;(x))
multiline_comment|/*&n; * context protection macros&n; * in SMP:&n; * &t;- we need to protect against CPU concurrency (spin_lock)&n; * &t;- we need to protect against PMU overflow interrupts (local_irq_disable)&n; * in UP:&n; * &t;- we need to protect against PMU overflow interrupts (local_irq_disable)&n; *&n; * spin_lock_irqsave()/spin_lock_irqrestore():&n; * &t;in SMP: local_irq_disable + spin_lock&n; * &t;in UP : local_irq_disable&n; *&n; * spin_lock()/spin_lock():&n; * &t;in UP : removed automatically&n; * &t;in SMP: protect against context accesses from other CPU. interrupts&n; * &t;        are not masked. This is useful for the PMU interrupt handler&n; * &t;        because we know we will not get PMU concurrency in that code.&n; */
DECL|macro|PROTECT_CTX
mdefine_line|#define PROTECT_CTX(c, f) &bslash;&n;&t;do {  &bslash;&n;&t;&t;DPRINT((&quot;spinlock_irq_save ctx %p by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;&t;spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;&t;DPRINT((&quot;spinlocked ctx %p  by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX
mdefine_line|#define UNPROTECT_CTX(c, f) &bslash;&n;&t;do { &bslash;&n;&t;&t;DPRINT((&quot;spinlock_irq_restore ctx %p by [%d]&bslash;n&quot;, c, current-&gt;pid)); &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|PROTECT_CTX_NOPRINT
mdefine_line|#define PROTECT_CTX_NOPRINT(c, f) &bslash;&n;&t;do {  &bslash;&n;&t;&t;spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX_NOPRINT
mdefine_line|#define UNPROTECT_CTX_NOPRINT(c, f) &bslash;&n;&t;do { &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); &bslash;&n;&t;} while(0)
DECL|macro|PROTECT_CTX_NOIRQ
mdefine_line|#define PROTECT_CTX_NOIRQ(c) &bslash;&n;&t;do {  &bslash;&n;&t;&t;spin_lock(&amp;(c)-&gt;ctx_lock); &bslash;&n;&t;} while(0)
DECL|macro|UNPROTECT_CTX_NOIRQ
mdefine_line|#define UNPROTECT_CTX_NOIRQ(c) &bslash;&n;&t;do { &bslash;&n;&t;&t;spin_unlock(&amp;(c)-&gt;ctx_lock); &bslash;&n;&t;} while(0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|GET_ACTIVATION
mdefine_line|#define GET_ACTIVATION()&t;pfm_get_cpu_var(pmu_activation_number)
DECL|macro|INC_ACTIVATION
mdefine_line|#define INC_ACTIVATION()&t;pfm_get_cpu_var(pmu_activation_number)++
DECL|macro|SET_ACTIVATION
mdefine_line|#define SET_ACTIVATION(c)&t;(c)-&gt;ctx_last_activation = GET_ACTIVATION()
macro_line|#else /* !CONFIG_SMP */
DECL|macro|SET_ACTIVATION
mdefine_line|#define SET_ACTIVATION(t) &t;do {} while(0)
DECL|macro|GET_ACTIVATION
mdefine_line|#define GET_ACTIVATION(t) &t;do {} while(0)
DECL|macro|INC_ACTIVATION
mdefine_line|#define INC_ACTIVATION(t) &t;do {} while(0)
macro_line|#endif /* CONFIG_SMP */
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t, c)&t;do { pfm_get_cpu_var(pmu_owner) = (t); pfm_get_cpu_var(pmu_ctx) = (c); } while(0)
DECL|macro|GET_PMU_OWNER
mdefine_line|#define GET_PMU_OWNER()&t;&t;pfm_get_cpu_var(pmu_owner)
DECL|macro|GET_PMU_CTX
mdefine_line|#define GET_PMU_CTX()&t;&t;pfm_get_cpu_var(pmu_ctx)
DECL|macro|LOCK_PFS
mdefine_line|#define LOCK_PFS(g)&t;    &t;spin_lock_irqsave(&amp;pfm_sessions.pfs_lock, g)
DECL|macro|UNLOCK_PFS
mdefine_line|#define UNLOCK_PFS(g)&t;    &t;spin_unlock_irqrestore(&amp;pfm_sessions.pfs_lock, g)
DECL|macro|PFM_REG_RETFLAG_SET
mdefine_line|#define PFM_REG_RETFLAG_SET(flags, val)&t;do { flags &amp;= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)
multiline_comment|/*&n; * cmp0 must be the value of pmc0&n; */
DECL|macro|PMC0_HAS_OVFL
mdefine_line|#define PMC0_HAS_OVFL(cmp0)  (cmp0 &amp; ~0x1UL)
DECL|macro|PFMFS_MAGIC
mdefine_line|#define PFMFS_MAGIC 0xa0b4d889
multiline_comment|/*&n; * debugging&n; */
DECL|macro|PFM_DEBUGGING
mdefine_line|#define PFM_DEBUGGING 1
macro_line|#ifdef PFM_DEBUGGING
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (unlikely(pfm_sysctl.debug &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __FUNCTION__, __LINE__, smp_processor_id(), current-&gt;pid); printk a; } &bslash;&n;&t;} while (0)
DECL|macro|DPRINT_ovfl
mdefine_line|#define DPRINT_ovfl(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (unlikely(pfm_sysctl.debug &gt; 0 &amp;&amp; pfm_sysctl.debug_ovfl &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __FUNCTION__, __LINE__, smp_processor_id(), current-&gt;pid); printk a; } &bslash;&n;&t;} while (0)
macro_line|#endif
multiline_comment|/*&n; * 64-bit software counter structure&n; *&n; * the next_reset_type is applied to the next call to pfm_reset_regs()&n; */
r_typedef
r_struct
(brace
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|lval
r_int
r_int
id|lval
suffix:semicolon
multiline_comment|/* last reset value */
DECL|member|long_reset
r_int
r_int
id|long_reset
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|short_reset
r_int
r_int
id|short_reset
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|reset_pmds
r_int
r_int
id|reset_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which other pmds to reset when this counter overflows */
DECL|member|smpl_pmds
r_int
r_int
id|smpl_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which pmds are accessed when counter overflow */
DECL|member|seed
r_int
r_int
id|seed
suffix:semicolon
multiline_comment|/* seed for random-number generator */
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
multiline_comment|/* mask for random-number generator */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|member|eventid
r_int
r_int
id|eventid
suffix:semicolon
multiline_comment|/* overflow event identifier */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
multiline_comment|/*&n; * context flags&n; */
r_typedef
r_struct
(brace
DECL|member|block
r_int
r_int
id|block
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* when 1, task will blocked on user notifications */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|using_dbreg
r_int
r_int
id|using_dbreg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* using range restrictions (debug registers) */
DECL|member|is_sampling
r_int
r_int
id|is_sampling
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* true if using a custom format */
DECL|member|excl_idle
r_int
r_int
id|excl_idle
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* exclude idle task in system wide session */
DECL|member|going_zombie
r_int
r_int
id|going_zombie
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* context is zombie (MASKED+blocking) */
DECL|member|trap_reason
r_int
r_int
id|trap_reason
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* reason for going into pfm_handle_work() */
DECL|member|no_msg
r_int
r_int
id|no_msg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* no message sent on overflow */
DECL|member|can_restart
r_int
r_int
id|can_restart
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* allowed to issue a PFM_RESTART */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|22
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
DECL|macro|PFM_TRAP_REASON_NONE
mdefine_line|#define PFM_TRAP_REASON_NONE&t;&t;0x0&t;/* default value */
DECL|macro|PFM_TRAP_REASON_BLOCK
mdefine_line|#define PFM_TRAP_REASON_BLOCK&t;&t;0x1&t;/* we need to block on overflow */
DECL|macro|PFM_TRAP_REASON_RESET
mdefine_line|#define PFM_TRAP_REASON_RESET&t;&t;0x2&t;/* we need to reset PMDs */
multiline_comment|/*&n; * perfmon context: encapsulates all the state of a monitoring session&n; */
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_lock
id|spinlock_t
id|ctx_lock
suffix:semicolon
multiline_comment|/* context protection */
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* bitmask of flags  (block reason incl.) */
DECL|member|ctx_state
r_int
r_int
id|ctx_state
suffix:semicolon
multiline_comment|/* state: active/inactive (no bitfield) */
DECL|member|ctx_task
r_struct
id|task_struct
op_star
id|ctx_task
suffix:semicolon
multiline_comment|/* task to which context is attached */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers overflowed (notification) */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_used_pmds
r_int
r_int
id|ctx_used_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMD used            */
DECL|member|ctx_all_pmds
r_int
r_int
id|ctx_all_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of all accessible PMDs */
DECL|member|ctx_reload_pmds
r_int
r_int
id|ctx_reload_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of force reload PMD on ctxsw in */
DECL|member|ctx_all_pmcs
r_int
r_int
id|ctx_all_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of all accessible PMCs */
DECL|member|ctx_reload_pmcs
r_int
r_int
id|ctx_reload_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of force reload PMC on ctxsw in */
DECL|member|ctx_used_monitors
r_int
r_int
id|ctx_used_monitors
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of monitor PMC being used */
DECL|member|ctx_pmcs
r_int
r_int
id|ctx_pmcs
(braket
id|IA64_NUM_PMC_REGS
)braket
suffix:semicolon
multiline_comment|/*  saved copies of PMC values */
DECL|member|ctx_used_ibrs
r_int
r_int
id|ctx_used_ibrs
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bitmask of used IBR (speedup ctxsw in) */
DECL|member|ctx_used_dbrs
r_int
r_int
id|ctx_used_dbrs
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bitmask of used DBR (speedup ctxsw in) */
DECL|member|ctx_dbrs
r_int
r_int
id|ctx_dbrs
(braket
id|IA64_NUM_DBG_REGS
)braket
suffix:semicolon
multiline_comment|/* DBR values (cache) when not loaded */
DECL|member|ctx_ibrs
r_int
r_int
id|ctx_ibrs
(braket
id|IA64_NUM_DBG_REGS
)braket
suffix:semicolon
multiline_comment|/* IBR values (cache) when not loaded */
DECL|member|ctx_pmds
id|pfm_counter_t
id|ctx_pmds
(braket
id|IA64_NUM_PMD_REGS
)braket
suffix:semicolon
multiline_comment|/* software state for PMDS */
DECL|member|ctx_saved_psr_up
id|u64
id|ctx_saved_psr_up
suffix:semicolon
multiline_comment|/* only contains psr.up value */
DECL|member|ctx_last_activation
r_int
r_int
id|ctx_last_activation
suffix:semicolon
multiline_comment|/* context last activation number for last_cpu */
DECL|member|ctx_last_cpu
r_int
r_int
id|ctx_last_cpu
suffix:semicolon
multiline_comment|/* CPU id of current or last CPU used (SMP only) */
DECL|member|ctx_cpu
r_int
r_int
id|ctx_cpu
suffix:semicolon
multiline_comment|/* cpu to which perfmon is applied (system wide) */
DECL|member|ctx_fd
r_int
id|ctx_fd
suffix:semicolon
multiline_comment|/* file descriptor used my this context */
DECL|member|ctx_ovfl_arg
id|pfm_ovfl_arg_t
id|ctx_ovfl_arg
suffix:semicolon
multiline_comment|/* argument to custom buffer format handler */
DECL|member|ctx_buf_fmt
id|pfm_buffer_fmt_t
op_star
id|ctx_buf_fmt
suffix:semicolon
multiline_comment|/* buffer format callbacks */
DECL|member|ctx_smpl_hdr
r_void
op_star
id|ctx_smpl_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header kernel vaddr */
DECL|member|ctx_smpl_size
r_int
r_int
id|ctx_smpl_size
suffix:semicolon
multiline_comment|/* size of sampling buffer */
DECL|member|ctx_smpl_vaddr
r_void
op_star
id|ctx_smpl_vaddr
suffix:semicolon
multiline_comment|/* user level virtual address of smpl buffer */
DECL|member|ctx_msgq_wait
id|wait_queue_head_t
id|ctx_msgq_wait
suffix:semicolon
DECL|member|ctx_msgq
id|pfm_msg_t
id|ctx_msgq
(braket
id|PFM_MAX_MSGS
)braket
suffix:semicolon
DECL|member|ctx_msgq_head
r_int
id|ctx_msgq_head
suffix:semicolon
DECL|member|ctx_msgq_tail
r_int
id|ctx_msgq_tail
suffix:semicolon
DECL|member|ctx_async_queue
r_struct
id|fasync_struct
op_star
id|ctx_async_queue
suffix:semicolon
DECL|member|ctx_zombieq
id|wait_queue_head_t
id|ctx_zombieq
suffix:semicolon
multiline_comment|/* termination cleanup wait queue */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
multiline_comment|/*&n; * magic number used to verify that structure is really&n; * a perfmon context&n; */
DECL|macro|PFM_IS_FILE
mdefine_line|#define PFM_IS_FILE(f)&t;&t;((f)-&gt;f_op == &amp;pfm_file_ops)
DECL|macro|PFM_GET_CTX
mdefine_line|#define PFM_GET_CTX(t)&t; &t;((pfm_context_t *)(t)-&gt;thread.pfm_context)
macro_line|#ifdef CONFIG_SMP
DECL|macro|SET_LAST_CPU
mdefine_line|#define SET_LAST_CPU(ctx, v)&t;(ctx)-&gt;ctx_last_cpu = (v)
DECL|macro|GET_LAST_CPU
mdefine_line|#define GET_LAST_CPU(ctx)&t;(ctx)-&gt;ctx_last_cpu
macro_line|#else
DECL|macro|SET_LAST_CPU
mdefine_line|#define SET_LAST_CPU(ctx, v)&t;do {} while(0)
DECL|macro|GET_LAST_CPU
mdefine_line|#define GET_LAST_CPU(ctx)&t;do {} while(0)
macro_line|#endif
DECL|macro|ctx_fl_block
mdefine_line|#define ctx_fl_block&t;&t;ctx_flags.block
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;&t;ctx_flags.system
DECL|macro|ctx_fl_using_dbreg
mdefine_line|#define ctx_fl_using_dbreg&t;ctx_flags.using_dbreg
DECL|macro|ctx_fl_is_sampling
mdefine_line|#define ctx_fl_is_sampling&t;ctx_flags.is_sampling
DECL|macro|ctx_fl_excl_idle
mdefine_line|#define ctx_fl_excl_idle&t;ctx_flags.excl_idle
DECL|macro|ctx_fl_going_zombie
mdefine_line|#define ctx_fl_going_zombie&t;ctx_flags.going_zombie
DECL|macro|ctx_fl_trap_reason
mdefine_line|#define ctx_fl_trap_reason&t;ctx_flags.trap_reason
DECL|macro|ctx_fl_no_msg
mdefine_line|#define ctx_fl_no_msg&t;&t;ctx_flags.no_msg
DECL|macro|ctx_fl_can_restart
mdefine_line|#define ctx_fl_can_restart&t;ctx_flags.can_restart
DECL|macro|PFM_SET_WORK_PENDING
mdefine_line|#define PFM_SET_WORK_PENDING(t, v)&t;do { (t)-&gt;thread.pfm_needs_checking = v; } while(0);
DECL|macro|PFM_GET_WORK_PENDING
mdefine_line|#define PFM_GET_WORK_PENDING(t)&t;&t;(t)-&gt;thread.pfm_needs_checking
multiline_comment|/*&n; * global information about all sessions&n; * mostly used to synchronize between system wide and per-process&n; */
r_typedef
r_struct
(brace
DECL|member|pfs_lock
id|spinlock_t
id|pfs_lock
suffix:semicolon
multiline_comment|/* lock the structure */
DECL|member|pfs_task_sessions
r_int
r_int
id|pfs_task_sessions
suffix:semicolon
multiline_comment|/* number of per task sessions */
DECL|member|pfs_sys_sessions
r_int
r_int
id|pfs_sys_sessions
suffix:semicolon
multiline_comment|/* number of per system wide sessions */
DECL|member|pfs_sys_use_dbregs
r_int
r_int
id|pfs_sys_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a system wide session uses debug regs */
DECL|member|pfs_ptrace_use_dbregs
r_int
r_int
id|pfs_ptrace_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a process uses debug regs */
DECL|member|pfs_sys_session
r_struct
id|task_struct
op_star
id|pfs_sys_session
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* point to task owning a system-wide session */
DECL|typedef|pfm_session_t
)brace
id|pfm_session_t
suffix:semicolon
multiline_comment|/*&n; * information about a PMC or PMD.&n; * dep_pmd[]: a bitmask of dependent PMD registers&n; * dep_pmc[]: a bitmask of dependent PMC registers&n; */
DECL|typedef|pfm_reg_check_t
r_typedef
r_int
(paren
op_star
id|pfm_reg_check_t
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|cnum
comma
r_int
r_int
op_star
id|val
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|pm_pos
r_int
id|pm_pos
suffix:semicolon
DECL|member|default_value
r_int
r_int
id|default_value
suffix:semicolon
multiline_comment|/* power-on default value */
DECL|member|reserved_mask
r_int
r_int
id|reserved_mask
suffix:semicolon
multiline_comment|/* bitmask of reserved bits */
DECL|member|read_check
id|pfm_reg_check_t
id|read_check
suffix:semicolon
DECL|member|write_check
id|pfm_reg_check_t
id|write_check
suffix:semicolon
DECL|member|dep_pmd
r_int
r_int
id|dep_pmd
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|dep_pmc
r_int
r_int
id|dep_pmc
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|pfm_reg_desc_t
)brace
id|pfm_reg_desc_t
suffix:semicolon
multiline_comment|/* assume cnum is a valid monitor */
DECL|macro|PMC_PM
mdefine_line|#define PMC_PM(cnum, val)&t;(((val) &gt;&gt; (pmu_conf-&gt;pmc_desc[cnum].pm_pos)) &amp; 0x1)
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristics.&n; *&n; * If the probe function is defined, detection is based&n; * on its return value: &n; * &t;- 0 means recognized PMU&n; * &t;- anything else means not supported&n; * When the probe function is not defined, then the pmu_family field&n; * is used and it must match the host CPU family such that:&n; * &t;- cpu-&gt;family &amp; config-&gt;pmu_family != 0&n; */
r_typedef
r_struct
(brace
DECL|member|ovfl_val
r_int
r_int
id|ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for counters */
DECL|member|pmc_desc
id|pfm_reg_desc_t
op_star
id|pmc_desc
suffix:semicolon
multiline_comment|/* detailed PMC register dependencies descriptions */
DECL|member|pmd_desc
id|pfm_reg_desc_t
op_star
id|pmd_desc
suffix:semicolon
multiline_comment|/* detailed PMD register dependencies descriptions */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* number of PMCS: computed at init time */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* number of PMDS: computed at init time */
DECL|member|impl_pmcs
r_int
r_int
id|impl_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMCS */
DECL|member|impl_pmds
r_int
r_int
id|impl_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of implemented PMDS */
DECL|member|pmu_name
r_char
op_star
id|pmu_name
suffix:semicolon
multiline_comment|/* PMU family name */
DECL|member|pmu_family
r_int
r_int
id|pmu_family
suffix:semicolon
multiline_comment|/* cpuid family pattern used to identify pmu */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* pmu specific flags */
DECL|member|num_ibrs
r_int
r_int
id|num_ibrs
suffix:semicolon
multiline_comment|/* number of IBRS: computed at init time */
DECL|member|num_dbrs
r_int
r_int
id|num_dbrs
suffix:semicolon
multiline_comment|/* number of DBRS: computed at init time */
DECL|member|num_counters
r_int
r_int
id|num_counters
suffix:semicolon
multiline_comment|/* PMC/PMD counting pairs : computed at init time */
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* customized probe routine */
DECL|member|use_rr_dbregs
r_int
r_int
id|use_rr_dbregs
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* set if debug registers used for range restriction */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
multiline_comment|/*&n; * PMU specific flags&n; */
DECL|macro|PFM_PMU_IRQ_RESEND
mdefine_line|#define PFM_PMU_IRQ_RESEND&t;1&t;/* PMU needs explicit IRQ resend */
multiline_comment|/*&n; * debug register related type definitions&n; */
r_typedef
r_struct
(brace
DECL|member|ibr_mask
r_int
r_int
id|ibr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|ibr_plm
r_int
r_int
id|ibr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ibr_ig
r_int
r_int
id|ibr_ig
suffix:colon
l_int|3
suffix:semicolon
DECL|member|ibr_x
r_int
r_int
id|ibr_x
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|ibr_mask_reg_t
)brace
id|ibr_mask_reg_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dbr_mask
r_int
r_int
id|dbr_mask
suffix:colon
l_int|56
suffix:semicolon
DECL|member|dbr_plm
r_int
r_int
id|dbr_plm
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dbr_ig
r_int
r_int
id|dbr_ig
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dbr_w
r_int
r_int
id|dbr_w
suffix:colon
l_int|1
suffix:semicolon
DECL|member|dbr_r
r_int
r_int
id|dbr_r
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|dbr_mask_reg_t
)brace
id|dbr_mask_reg_t
suffix:semicolon
r_typedef
r_union
(brace
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
DECL|member|ibr
id|ibr_mask_reg_t
id|ibr
suffix:semicolon
DECL|member|dbr
id|dbr_mask_reg_t
id|dbr
suffix:semicolon
DECL|typedef|dbreg_t
)brace
id|dbreg_t
suffix:semicolon
multiline_comment|/*&n; * perfmon command descriptions&n; */
r_typedef
r_struct
(brace
DECL|member|cmd_func
r_int
(paren
op_star
id|cmd_func
)paren
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|cmd_name
r_char
op_star
id|cmd_name
suffix:semicolon
DECL|member|cmd_flags
r_int
id|cmd_flags
suffix:semicolon
DECL|member|cmd_narg
r_int
r_int
id|cmd_narg
suffix:semicolon
DECL|member|cmd_argsize
r_int
id|cmd_argsize
suffix:semicolon
DECL|member|cmd_getsize
r_int
(paren
op_star
id|cmd_getsize
)paren
(paren
r_void
op_star
id|arg
comma
r_int
op_star
id|sz
)paren
suffix:semicolon
DECL|typedef|pfm_cmd_desc_t
)brace
id|pfm_cmd_desc_t
suffix:semicolon
DECL|macro|PFM_CMD_FD
mdefine_line|#define PFM_CMD_FD&t;&t;0x01&t;/* command requires a file descriptor */
DECL|macro|PFM_CMD_ARG_READ
mdefine_line|#define PFM_CMD_ARG_READ&t;0x02&t;/* command must read argument(s) */
DECL|macro|PFM_CMD_ARG_RW
mdefine_line|#define PFM_CMD_ARG_RW&t;&t;0x04&t;/* command must read/write argument(s) */
DECL|macro|PFM_CMD_STOP
mdefine_line|#define PFM_CMD_STOP&t;&t;0x08&t;/* command does not work on zombie context */
DECL|macro|PFM_CMD_NAME
mdefine_line|#define PFM_CMD_NAME(cmd)&t;pfm_cmd_tab[(cmd)].cmd_name
DECL|macro|PFM_CMD_READ_ARG
mdefine_line|#define PFM_CMD_READ_ARG(cmd)&t;(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_ARG_READ)
DECL|macro|PFM_CMD_RW_ARG
mdefine_line|#define PFM_CMD_RW_ARG(cmd)&t;(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_ARG_RW)
DECL|macro|PFM_CMD_USE_FD
mdefine_line|#define PFM_CMD_USE_FD(cmd)&t;(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_FD)
DECL|macro|PFM_CMD_STOPPED
mdefine_line|#define PFM_CMD_STOPPED(cmd)&t;(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_STOP)
DECL|macro|PFM_CMD_ARG_MANY
mdefine_line|#define PFM_CMD_ARG_MANY&t;-1 /* cannot be zero */
r_typedef
r_struct
(brace
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* turn on/off debugging via syslog */
DECL|member|debug_ovfl
r_int
id|debug_ovfl
suffix:semicolon
multiline_comment|/* turn on/off debug printk in overflow handler */
DECL|member|fastctxsw
r_int
id|fastctxsw
suffix:semicolon
multiline_comment|/* turn on/off fast (unsecure) ctxsw */
DECL|member|expert_mode
r_int
id|expert_mode
suffix:semicolon
multiline_comment|/* turn on/off value checking */
DECL|member|debug_pfm_read
r_int
id|debug_pfm_read
suffix:semicolon
DECL|typedef|pfm_sysctl_t
)brace
id|pfm_sysctl_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|pfm_spurious_ovfl_intr_count
r_int
r_int
id|pfm_spurious_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of spurious ovfl interrupts */
DECL|member|pfm_replay_ovfl_intr_count
r_int
r_int
id|pfm_replay_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of replayed ovfl interrupts */
DECL|member|pfm_ovfl_intr_count
r_int
r_int
id|pfm_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles
r_int
r_int
id|pfm_ovfl_intr_cycles
suffix:semicolon
multiline_comment|/* cycles spent processing ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles_min
r_int
r_int
id|pfm_ovfl_intr_cycles_min
suffix:semicolon
multiline_comment|/* min cycles spent processing ovfl interrupts */
DECL|member|pfm_ovfl_intr_cycles_max
r_int
r_int
id|pfm_ovfl_intr_cycles_max
suffix:semicolon
multiline_comment|/* max cycles spent processing ovfl interrupts */
DECL|member|pfm_smpl_handler_calls
r_int
r_int
id|pfm_smpl_handler_calls
suffix:semicolon
DECL|member|pfm_smpl_handler_cycles
r_int
r_int
id|pfm_smpl_handler_cycles
suffix:semicolon
DECL|member|____cacheline_aligned
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
id|____cacheline_aligned
suffix:semicolon
DECL|typedef|pfm_stats_t
)brace
id|pfm_stats_t
suffix:semicolon
multiline_comment|/*&n; * perfmon internal variables&n; */
DECL|variable|pfm_stats
r_static
id|pfm_stats_t
id|pfm_stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|pfm_sessions
r_static
id|pfm_session_t
id|pfm_sessions
suffix:semicolon
multiline_comment|/* global sessions information */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
DECL|variable|pfm_null_uuid
r_static
id|pfm_uuid_t
id|pfm_null_uuid
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|pfm_buffer_fmt_lock
r_static
id|spinlock_t
id|pfm_buffer_fmt_lock
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|pfm_buffer_fmt_list
)paren
suffix:semicolon
DECL|variable|pmu_conf
r_static
id|pmu_config_t
op_star
id|pmu_conf
suffix:semicolon
multiline_comment|/* sysctl() controls */
DECL|variable|pfm_sysctl
r_static
id|pfm_sysctl_t
id|pfm_sysctl
suffix:semicolon
DECL|variable|pfm_debug_var
r_int
id|pfm_debug_var
suffix:semicolon
DECL|variable|pfm_ctl_table
r_static
id|ctl_table
id|pfm_ctl_table
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|pfm_sysctl_dir
r_static
id|ctl_table
id|pfm_sysctl_dir
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;perfmon&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_ctl_table
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_root
r_static
id|ctl_table
id|pfm_sysctl_root
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;kernel&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0755
comma
id|pfm_sysctl_dir
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|pfm_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|pfm_sysctl_header
suffix:semicolon
r_static
r_int
id|pfm_context_unload
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|pfm_flush
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
DECL|macro|pfm_get_cpu_var
mdefine_line|#define pfm_get_cpu_var(v)&t;&t;__ia64_per_cpu_var(v)
DECL|macro|pfm_get_cpu_data
mdefine_line|#define pfm_get_cpu_data(a,b)&t;&t;per_cpu(a, b)
r_static
r_inline
r_void
DECL|function|pfm_put_task
id|pfm_put_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
id|put_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_task_notify
id|pfm_set_task_notify
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_info
op_star
id|info
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task
op_plus
id|IA64_TASK_SIZE
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TIF_NOTIFY_RESUME
comma
op_amp
id|info-&gt;flags
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_task_notify
id|pfm_clear_task_notify
c_func
(paren
r_void
)paren
(brace
id|clear_thread_flag
c_func
(paren
id|TIF_NOTIFY_RESUME
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_reserve_page
id|pfm_reserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
id|SetPageReserved
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unreserve_page
id|pfm_unreserve_page
c_func
(paren
r_int
r_int
id|a
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_remap_page_range
id|pfm_remap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
r_return
id|remap_page_range
c_func
(paren
id|vma
comma
id|from
comma
id|phys_addr
comma
id|size
comma
id|prot
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_protect_ctx_ctxsw
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
r_return
l_int|0UL
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_unprotect_ctx_ctxsw
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|pfm_context_t
op_star
id|x
comma
r_int
r_int
id|f
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|x
)paren
op_member_access_from_pointer
id|ctx_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_do_munmap
id|pfm_do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_int
id|acct
)paren
(brace
r_return
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_unmapped_area
id|pfm_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|exec
)paren
(brace
r_return
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_struct
id|super_block
op_star
DECL|function|pfmfs_get_sb
id|pfmfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_pseudo
c_func
(paren
id|fs_type
comma
l_string|&quot;pfm:&quot;
comma
l_int|NULL
comma
id|PFMFS_MAGIC
)paren
suffix:semicolon
)brace
DECL|variable|pfm_fs_type
r_static
r_struct
id|file_system_type
id|pfm_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;pfmfs&quot;
comma
dot
id|get_sb
op_assign
id|pfmfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pfm_syst_info
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|task_struct
op_star
comma
id|pmu_owner
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
id|pfm_context_t
op_star
comma
id|pmu_ctx
)paren
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pmu_activation_number
)paren
suffix:semicolon
multiline_comment|/* forward declaration */
DECL|variable|pfm_file_ops
r_static
r_struct
id|file_operations
id|pfm_file_ops
suffix:semicolon
multiline_comment|/*&n; * forward declarations&n; */
macro_line|#ifndef CONFIG_SMP
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
suffix:semicolon
macro_line|#endif
r_void
id|dump_pmu_state
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_static
r_int
id|pfm_write_ibr_dbr
c_func
(paren
r_int
id|mode
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#include &quot;perfmon_itanium.h&quot;
macro_line|#include &quot;perfmon_mckinley.h&quot;
macro_line|#include &quot;perfmon_generic.h&quot;
DECL|variable|pmu_confs
r_static
id|pmu_config_t
op_star
id|pmu_confs
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
id|pfm_end_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_pp
id|pfm_clear_psr_pp
c_func
(paren
r_void
)paren
(brace
id|ia64_rsm
c_func
(paren
id|IA64_PSR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_pp
id|pfm_set_psr_pp
c_func
(paren
r_void
)paren
(brace
id|ia64_ssm
c_func
(paren
id|IA64_PSR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_clear_psr_up
id|pfm_clear_psr_up
c_func
(paren
r_void
)paren
(brace
id|ia64_rsm
c_func
(paren
id|IA64_PSR_UP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_up
id|pfm_set_psr_up
c_func
(paren
r_void
)paren
(brace
id|ia64_ssm
c_func
(paren
id|IA64_PSR_UP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_psr
id|pfm_get_psr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_PSR
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_set_psr_l
id|pfm_set_psr_l
c_func
(paren
r_int
r_int
id|val
)paren
(brace
id|ia64_setreg
c_func
(paren
id|_IA64_REG_PSR_L
comma
id|val
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_freeze_pmu
id|pfm_freeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_unfreeze_pmu
id|pfm_unfreeze_pmu
c_func
(paren
r_void
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_ibrs
id|pfm_restore_ibrs
c_func
(paren
r_int
r_int
op_star
id|ibrs
comma
r_int
r_int
id|nibrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
id|ibrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|ia64_dv_serialize_instruction
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_dbrs
id|pfm_restore_dbrs
c_func
(paren
r_int
r_int
op_star
id|dbrs
comma
r_int
r_int
id|ndbrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
id|dbrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|ia64_dv_serialize_data
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PMD[i] must be a counter. no check is made&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_read_soft_counter
id|pfm_read_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
)paren
(brace
r_return
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf-&gt;ovfl_val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PMD[i] must be a counter. no check is made&n; */
r_static
r_inline
r_void
DECL|function|pfm_write_soft_counter
id|pfm_write_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|ovfl_val
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * writing to unimplemented part is ignore, so we do not need to&n;&t; * mask off top part&n;&t; */
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
op_amp
id|ovfl_val
)paren
suffix:semicolon
)brace
r_static
id|pfm_msg_t
op_star
DECL|function|pfm_get_new_msg
id|pfm_get_new_msg
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|idx
comma
id|next
suffix:semicolon
id|next
op_assign
(paren
id|ctx-&gt;ctx_msgq_tail
op_plus
l_int|1
)paren
op_mod
id|PFM_MAX_MSGS
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_fd=%p head=%d tail=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
id|ctx-&gt;ctx_msgq_head
)paren
r_return
l_int|NULL
suffix:semicolon
id|idx
op_assign
id|ctx-&gt;ctx_msgq_tail
suffix:semicolon
id|ctx-&gt;ctx_msgq_tail
op_assign
id|next
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d msg=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|idx
)paren
)paren
suffix:semicolon
r_return
id|ctx-&gt;ctx_msgq
op_plus
id|idx
suffix:semicolon
)brace
r_static
id|pfm_msg_t
op_star
DECL|function|pfm_get_next_msg
id|pfm_get_next_msg
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * get oldest message&n;&t; */
id|msg
op_assign
id|ctx-&gt;ctx_msgq
op_plus
id|ctx-&gt;ctx_msgq_head
suffix:semicolon
multiline_comment|/*&n;&t; * and move forward&n;&t; */
id|ctx-&gt;ctx_msgq_head
op_assign
(paren
id|ctx-&gt;ctx_msgq_head
op_plus
l_int|1
)paren
op_mod
id|PFM_MAX_MSGS
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p head=%d tail=%d type=%d&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|msg-&gt;pfm_gen_msg.msg_type
)paren
)paren
suffix:semicolon
r_return
id|msg
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_msgq
id|pfm_reset_msgq
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|ctx-&gt;ctx_msgq_head
op_assign
id|ctx-&gt;ctx_msgq_tail
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p msgq reset&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_kvirt_to_pa
id|pfm_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
op_assign
id|ia64_tpa
c_func
(paren
id|adr
)paren
suffix:semicolon
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|pfm_rvmalloc
id|pfm_rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
singleline_comment|//printk(&quot;perfmon: CPU%d pfm_rvmalloc(%ld)=%p&bslash;n&quot;, smp_processor_id(), size, mem);
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|pfm_reserve_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_rvfree
id|pfm_rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;freeing physical buffer @%p size=%lu&bslash;n&quot;
comma
id|mem
comma
id|size
)paren
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|size
OG
l_int|0
)paren
(brace
id|pfm_unreserve_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
id|pfm_context_t
op_star
DECL|function|pfm_context_alloc
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
multiline_comment|/* &n;&t; * allocate context descriptor &n;&t; * must be able to free with interrupts disabled&n;&t; */
id|ctx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pfm_context_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_context_t
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;alloc ctx @%p&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
)brace
r_return
id|ctx
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_context_free
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;free ctx @%p&bslash;n&quot;
comma
id|ctx
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|pfm_mask_monitoring
id|pfm_mask_monitoring
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
comma
id|val
comma
id|ovfl_mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;masking monitoring for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ovfl_mask
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * monitoring can only be masked as a result of a valid&n;&t; * counter overflow. In UP, it means that the PMU still&n;&t; * has an owner. Note that the owner can be different&n;&t; * from the current task. However the PMU state belongs&n;&t; * to the owner.&n;&t; * In SMP, a valid overflow only happens when task is&n;&t; * current. Therefore if we come here, we know that&n;&t; * the PMU state belongs to the current task, therefore&n;&t; * we can access the live registers.&n;&t; *&n;&t; * So in both cases, the live register contains the owner&squot;s&n;&t; * state. We can ONLY touch the PMU registers and NOT the PSR.&n;&t; *&n;&t; * As a consequence to this call, the thread-&gt;pmds[] array&n;&t; * contains stale information which must be ignored&n;&t; * when context is reloaded AND monitoring is active (see&n;&t; * pfm_restart).&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * we rebuild the full 64 bit value of the counter&n;&t;&t; &t; */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
(paren
id|val
op_amp
id|ovfl_mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|ovfl_mask
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * mask monitoring by setting the privilege level to 0&n;&t; * we cannot use psr.pp/psr.up for this, it is controlled by&n;&t; * the user&n;&t; *&n;&t; * if task is current, modify actual registers, otherwise modify&n;&t; * thread save state, i.e., what will be restored in pfm_load_regs()&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
op_amp
op_complement
l_int|0xfUL
)paren
suffix:semicolon
id|th-&gt;pmcs
(braket
id|i
)braket
op_and_assign
op_complement
l_int|0xfUL
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make all of this visible&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * must always be done with task == current&n; *&n; * context must be in MASKED state when calling&n; */
r_static
r_void
DECL|function|pfm_restore_monitoring
id|pfm_restore_monitoring
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
comma
id|ovfl_mask
suffix:semicolon
r_int
r_int
id|psr
comma
id|val
suffix:semicolon
r_int
id|i
comma
id|is_system
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|ovfl_mask
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon.%d: invalid task[%d] current[%d]&bslash;n&quot;
comma
id|__LINE__
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_ne
id|PFM_CTX_MASKED
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon.%d: task[%d] current[%d] invalid state=%d&bslash;n&quot;
comma
id|__LINE__
comma
id|task-&gt;pid
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * monitoring is masked via the PMC.&n;&t; * As we restore their value, we do not want each counter to&n;&t; * restart right away. We stop monitoring using the PSR,&n;&t; * restore the PMC (and PMD) and then re-establish the psr&n;&t; * as it was. Note that there can be no pending overflow at&n;&t; * this point, because monitoring was MASKED.&n;&t; *&n;&t; * system-wide session are pinned and self-monitoring&n;&t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
(paren
id|PFM_CPUINFO_GET
c_func
(paren
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
)paren
)paren
(brace
multiline_comment|/* disable dcr pp */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * first, we restore the PMD&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we split the 64bit value according to&n;&t;&t;&t; * counter width&n;&t;&t;&t; */
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_amp
id|ovfl_mask
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_and_assign
op_complement
id|ovfl_mask
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
)brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restore the PMCs&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|th-&gt;pmcs
(braket
id|i
)braket
op_assign
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%d]=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|th-&gt;pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * must restore DBR/IBR because could be modified while masked&n;&t; * XXX: need to optimize &n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf-&gt;num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now restore PSR&n;&t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
(paren
id|PFM_CPUINFO_GET
c_func
(paren
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
)paren
)paren
(brace
multiline_comment|/* enable dcr pp */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
id|pfm_set_psr_l
c_func
(paren
id|psr
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_save_pmds
id|pfm_save_pmds
c_func
(paren
r_int
r_int
op_star
id|pmds
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|pmds
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * reload from thread state (used for ctxw only)&n; */
r_static
r_inline
r_void
DECL|function|pfm_restore_pmds
id|pfm_restore_pmds
c_func
(paren
r_int
r_int
op_star
id|pmds
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|val
comma
id|ovfl_val
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
ques
c_cond
id|pmds
(braket
id|i
)braket
op_amp
id|ovfl_val
suffix:colon
id|pmds
(braket
id|i
)braket
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * propagate PMD from context to thread-state&n; */
r_static
r_inline
r_void
DECL|function|pfm_copy_pmds
id|pfm_copy_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|ovfl_val
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We break up the 64 bit value into 2 pieces&n;&t;&t; * the lower bits go to the machine state in the&n;&t;&t; * thread (will be reloaded on ctxsw in).&n;&t;&t; * The upper part stays in the soft-counter.&n;&t;&t; */
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|ovfl_val
suffix:semicolon
id|val
op_and_assign
id|ovfl_val
suffix:semicolon
)brace
id|thread-&gt;pmds
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%d]=0x%lx soft_val=0x%lx&bslash;n&quot;
comma
id|i
comma
id|thread-&gt;pmds
(braket
id|i
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * propagate PMC from context to thread-state&n; */
r_static
r_inline
r_void
DECL|function|pfm_copy_pmcs
id|pfm_copy_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;mask=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* masking 0 with ovfl_val yields 0 */
id|thread-&gt;pmcs
(braket
id|i
)braket
op_assign
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|thread-&gt;pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|pfm_restore_pmcs
id|pfm_restore_pmcs
c_func
(paren
r_int
r_int
op_star
id|pmcs
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_uuid_cmp
id|pfm_uuid_cmp
c_func
(paren
id|pfm_uuid_t
id|a
comma
id|pfm_uuid_t
id|b
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|a
comma
id|b
comma
r_sizeof
(paren
id|pfm_uuid_t
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_exit
id|pfm_buf_fmt_exit
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_exit
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_exit
)paren
(paren
id|task
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_getsize
id|pfm_buf_fmt_getsize
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_getsize
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_getsize
)paren
(paren
id|task
comma
id|flags
comma
id|cpu
comma
id|arg
comma
id|size
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_validate
id|pfm_buf_fmt_validate
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_validate
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_validate
)paren
(paren
id|task
comma
id|flags
comma
id|cpu
comma
id|arg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_init
id|pfm_buf_fmt_init
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|flags
comma
r_int
id|cpu
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_init
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_init
)paren
(paren
id|task
comma
id|buf
comma
id|flags
comma
id|cpu
comma
id|arg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_restart
id|pfm_buf_fmt_restart
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_ovfl_ctrl_t
op_star
id|ctrl
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_restart
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_restart
)paren
(paren
id|task
comma
id|ctrl
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|pfm_buf_fmt_restart_active
id|pfm_buf_fmt_restart_active
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_ovfl_ctrl_t
op_star
id|ctrl
comma
r_void
op_star
id|buf
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmt-&gt;fmt_restart_active
)paren
id|ret
op_assign
(paren
op_star
id|fmt-&gt;fmt_restart_active
)paren
(paren
id|task
comma
id|ctrl
comma
id|buf
comma
id|regs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
id|pfm_buffer_fmt_t
op_star
DECL|function|__pfm_find_buffer_fmt
id|__pfm_find_buffer_fmt
c_func
(paren
id|pfm_uuid_t
id|uuid
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|entry
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|pfm_buffer_fmt_list
)paren
(brace
id|entry
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|pfm_buffer_fmt_t
comma
id|fmt_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_uuid_cmp
c_func
(paren
id|uuid
comma
id|entry-&gt;fmt_uuid
)paren
op_eq
l_int|0
)paren
r_return
id|entry
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * find a buffer format based on its uuid&n; */
r_static
id|pfm_buffer_fmt_t
op_star
DECL|function|pfm_find_buffer_fmt
id|pfm_find_buffer_fmt
c_func
(paren
id|pfm_uuid_t
id|uuid
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
id|fmt
op_assign
id|__pfm_find_buffer_fmt
c_func
(paren
id|uuid
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
r_return
id|fmt
suffix:semicolon
)brace
r_int
DECL|function|pfm_register_buffer_fmt
id|pfm_register_buffer_fmt
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some sanity checks */
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
op_logical_or
id|fmt-&gt;fmt_name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we need at least a handler */
r_if
c_cond
(paren
id|fmt-&gt;fmt_handler
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: need check validity of fmt_arg_size&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__pfm_find_buffer_fmt
c_func
(paren
id|fmt-&gt;fmt_uuid
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: duplicate sampling format: %s&bslash;n&quot;
comma
id|fmt-&gt;fmt_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|fmt-&gt;fmt_list
comma
op_amp
id|pfm_buffer_fmt_list
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: added sampling format %s&bslash;n&quot;
comma
id|fmt-&gt;fmt_name
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|pfm_register_buffer_fmt
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_register_buffer_fmt
)paren
suffix:semicolon
r_int
DECL|function|pfm_unregister_buffer_fmt
id|pfm_unregister_buffer_fmt
c_func
(paren
id|pfm_uuid_t
id|uuid
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
id|fmt
op_assign
id|__pfm_find_buffer_fmt
c_func
(paren
id|uuid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: cannot unregister format, not found&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|list_del_init
c_func
(paren
op_amp
id|fmt-&gt;fmt_list
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: removed sampling format: %s&bslash;n&quot;
comma
id|fmt-&gt;fmt_name
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|pfm_unregister_buffer_fmt
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_unregister_buffer_fmt
)paren
suffix:semicolon
r_static
r_int
DECL|function|pfm_reserve_session
id|pfm_reserve_session
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
multiline_comment|/*&n;&t;&t; * cannot mix system wide and per-task sessions&n;&t;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_task_sessions
OG
l_int|0UL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide not possible, %u conflicting task_sessions&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
)paren
r_goto
id|error_conflict
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;reserving system wide session on CPU%u currently on CPU%u&bslash;n&quot;
comma
id|cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
id|task
suffix:semicolon
id|pfm_sessions.pfs_sys_sessions
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_sessions
)paren
r_goto
m_abort
suffix:semicolon
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_conflict
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide not possible, conflicting session [%d] on CPU%d&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_member_access_from_pointer
id|pid
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
m_abort
suffix:colon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_unreserve_session
id|pfm_unreserve_session
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|is_syswide
comma
r_int
r_int
id|cpu
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * validy checks on cpu_mask have been done upstream&n;&t; */
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_syswide
)paren
(brace
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * would not work with perfmon+more than one bit in cpu_mask&n;&t;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: invalid release for ctx %p sys_use_dbregs=0&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
)brace
id|pfm_sessions.pfs_sys_sessions
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_task_sessions
op_decrement
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|is_syswide
comma
id|cpu
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * removes virtual mapping of the sampling buffer.&n; * IMPORTANT: cannot be called with interrupts disable, e.g. inside&n; * a PROTECT_CTX() section.&n; */
r_static
r_int
DECL|function|pfm_remove_smpl_mapping
id|pfm_remove_smpl_mapping
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|vaddr
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|task-&gt;mm
op_eq
l_int|NULL
op_logical_or
id|size
op_eq
l_int|0UL
op_logical_or
id|vaddr
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_remove_smpl_mapping [%d] invalid context mm=%p&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;mm
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;smpl_vaddr=%p size=%lu&bslash;n&quot;
comma
id|vaddr
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * does the actual unmapping&n;&t; */
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;down_write done smpl_vaddr=%p size=%lu&bslash;n&quot;
comma
id|vaddr
comma
id|size
)paren
)paren
suffix:semicolon
id|r
op_assign
id|pfm_do_munmap
c_func
(paren
id|task-&gt;mm
comma
(paren
r_int
r_int
)paren
id|vaddr
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] unable to unmap sampling buffer @%p size=%lu&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|vaddr
comma
id|size
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_unmap(%p, %lu)=%d&bslash;n&quot;
comma
id|vaddr
comma
id|size
comma
id|r
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * free actual physical storage used by sampling buffer&n; */
macro_line|#if 0
r_static
r_int
id|pfm_free_smpl_buffer
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_hdr
op_eq
l_int|NULL
)paren
r_goto
id|invalid_free
suffix:semicolon
multiline_comment|/*&n;&t; * we won&squot;t use the buffer format anymore&n;&t; */
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;sampling buffer @%p size %lu vaddr=%p&bslash;n&quot;
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_smpl_size
comma
id|ctx-&gt;ctx_smpl_vaddr
)paren
)paren
suffix:semicolon
id|pfm_buf_fmt_exit
c_func
(paren
id|fmt
comma
id|current
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free the buffer&n;&t; */
id|pfm_rvfree
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_smpl_size
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_hdr
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_smpl_size
op_assign
l_int|0UL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|invalid_free
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_free_smpl_buffer [%d] no buffer&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
r_void
DECL|function|pfm_exit_smpl_buffer
id|pfm_exit_smpl_buffer
c_func
(paren
id|pfm_buffer_fmt_t
op_star
id|fmt
)paren
(brace
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|pfm_buf_fmt_exit
c_func
(paren
id|fmt
comma
id|current
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pfmfs should _never_ be mounted by userland - too much of security hassle,&n; * no real gain from having the whole whorehouse mounted. So we don&squot;t need&n; * any operations on the root directory. However, we need a non-trivial&n; * d_name - pfm: will go nicely and kill the special-casing in procfs.&n; */
DECL|variable|pfmfs_mnt
r_static
r_struct
id|vfsmount
op_star
id|pfmfs_mnt
suffix:semicolon
r_static
r_int
id|__init
DECL|function|init_pfm_fs
id|init_pfm_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|pfmfs_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pfmfs_mnt
)paren
)paren
id|unregister_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
r_else
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|exit_pfm_fs
id|exit_pfm_fs
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|pfm_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|pfm_read
id|pfm_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_read: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check even when there is no message&n;&t; */
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;message is too small ctx=%p (&gt;=%ld)&bslash;n&quot;
comma
id|ctx
comma
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * put ourselves on the wait queue&n;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * check wait queue&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;head=%d tail=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check non-blocking read&n;&t;&t; */
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * check pending signals&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no message, so wait&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] back to running ret=%ld&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
m_abort
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
id|pfm_get_next_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_read no msg for ctx=%p [%d]&bslash;n&quot;
comma
id|ctx
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_goto
id|abort_locked
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] fd=%d type=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|msg-&gt;pfm_gen_msg.msg_ctx_fd
comma
id|msg-&gt;pfm_gen_msg.msg_type
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|msg
comma
r_sizeof
(paren
id|pfm_msg_t
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
r_sizeof
(paren
id|pfm_msg_t
)paren
suffix:semicolon
)brace
id|abort_locked
suffix:colon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|pfm_write
id|pfm_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_write called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|pfm_poll
id|pfm_poll
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_poll: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_poll ctx_fd=%d before poll_wait&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
)paren
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|ctx-&gt;ctx_msgq_wait
comma
id|wait
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CTXQ_EMPTY
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
id|mask
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_poll ctx_fd=%d mask=0x%x&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ioctl
id|pfm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_ioctl called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * context is locked when coming here and interrupts are disabled&n; */
r_static
r_inline
r_int
DECL|function|pfm_do_fasync
id|pfm_do_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|on
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|fasync_helper
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|ctx-&gt;ctx_async_queue
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_fasync called by [%d] on ctx_fd=%d on=%d async_queue=%p ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|fd
comma
id|on
comma
id|ctx-&gt;ctx_async_queue
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_fasync
id|pfm_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_fasync bad magic [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_fasync NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we cannot mask interrupts during this call because this may&n;&t; * may go to sleep if memory is not readily avalaible.&n;&t; *&n;&t; * We are protected from the conetxt disappearing by the get_fd()/put_fd()&n;&t; * done in caller. Serialization of this function is ensured by caller.&n;&t; */
id|ret
op_assign
id|pfm_do_fasync
c_func
(paren
id|fd
comma
id|filp
comma
id|ctx
comma
id|on
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_fasync called on ctx_fd=%d on=%d async_queue=%p ret=%d&bslash;n&quot;
comma
id|fd
comma
id|on
comma
id|ctx-&gt;ctx_async_queue
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * this function is exclusively called from pfm_close().&n; * The context is not protected at that time, nor are interrupts&n; * on the remote CPU. That&squot;s necessary to avoid deadlocks.&n; */
r_static
r_void
DECL|function|pfm_syswide_force_stop
id|pfm_syswide_force_stop
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|info
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|current
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop for CPU%d  but on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|owner
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|owner
op_ne
id|ctx-&gt;ctx_task
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected owner [%d] instead of [%d]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|owner-&gt;pid
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_PMU_CTX
c_func
(paren
)paren
op_ne
id|ctx
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected ctx %p instead of %p&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|GET_PMU_CTX
c_func
(paren
)paren
comma
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;on CPU%d forcing system wide stop for [%d]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the context is already protected in pfm_close(), we simply&n;&t; * need to mask interrupts to avoid a PMU interrupt race on&n;&t; * this CPU&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context_unload returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * unmask interrupts, PMU interrupts are now spurious here&n;&t; */
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_syswide_cleanup_other_cpu
id|pfm_syswide_cleanup_other_cpu
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|ret
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;calling CPU%d for cleanup&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|smp_call_function_single
c_func
(paren
id|ctx-&gt;ctx_cpu
comma
id|pfm_syswide_force_stop
comma
id|ctx
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;called CPU%d for cleanup ret=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * called for each close(). Partially free resources.&n; * When caller is self-monitoring, the context is unloaded.&n; */
r_static
r_int
DECL|function|pfm_flush
id|pfm_flush
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|smpl_buf_size
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|smpl_buf_vaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|state
comma
id|is_system
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;bad magic for&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_flush: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * remove our file from the async queue, if we use this mode.&n;&t; * This can be done without the context being protected. We come&n;&t; * here when the context has become unreacheable by other tasks.&n;&t; *&n;&t; * We may still have active monitoring at this point and we may&n;&t; * end up in pfm_overflow_handler(). However, fasync_helper()&n;&t; * operates with interrupts disabled and it cleans up the&n;&t; * queue. If the PMU handler is called prior to entering&n;&t; * fasync_helper() then it will send a signal. If it is&n;&t; * invoked after, it will find an empty queue and no&n;&t; * signal will be sent. In both case, we are safe&n;&t; */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|FASYNC
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cleaning up async_queue=%p&bslash;n&quot;
comma
id|ctx-&gt;ctx_async_queue
)paren
)paren
suffix:semicolon
id|pfm_do_fasync
(paren
op_minus
l_int|1
comma
id|filp
comma
id|ctx
comma
l_int|0
)paren
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d is_current=%d&bslash;n&quot;
comma
id|state
comma
id|task
op_eq
id|current
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if state == UNLOADED, then task is NULL&n;&t; */
multiline_comment|/*&n;&t; * we must stop and unload because we are losing access to the context.&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t; * the task IS the owner but it migrated to another CPU: that&squot;s bad&n;&t;&t; * but we must handle this cleanly. Unfortunately, the kernel does&n;&t;&t; * not provide a mechanism to block migration (while the context is loaded).&n;&t;&t; *&n;&t;&t; * We need to release the resource on the ORIGINAL cpu.&n;&t;&t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * keep context protected but unmask interrupt for IPI&n;&t;&t;&t; */
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|pfm_syswide_cleanup_other_cpu
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * restore interrupt masking&n;&t;&t;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * context is unloaded at this point&n;&t;&t;&t; */
)brace
r_else
macro_line|#endif /* CONFIG_SMP */
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;forcing unload&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t;* stop and unload, returning with state UNLOADED&n;&t;&t; &t;* and session unreserved.&n;&t;&t; &t;*/
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * remove virtual mapping, if any, for the calling task.&n;&t; * cannot reset ctx field until last user is calling close().&n;&t; *&n;&t; * ctx_smpl_vaddr must never be cleared because it is needed&n;&t; * by every task with access to the context&n;&t; *&n;&t; * When called from do_exit(), the mm context is gone already, therefore&n;&t; * mm is NULL, i.e., the VMA is already gone  and we do not have to&n;&t; * do anything here&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_vaddr
op_logical_and
id|current-&gt;mm
)paren
(brace
id|smpl_buf_vaddr
op_assign
id|ctx-&gt;ctx_smpl_vaddr
suffix:semicolon
id|smpl_buf_size
op_assign
id|ctx-&gt;ctx_smpl_size
suffix:semicolon
)brace
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if there was a mapping, then we systematically remove it&n;&t; * at this point. Cannot be done inside critical section&n;&t; * because some VM function reenables interrupts.&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|smpl_buf_vaddr
)paren
id|pfm_remove_smpl_mapping
c_func
(paren
id|current
comma
id|smpl_buf_vaddr
comma
id|smpl_buf_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * called either on explicit close() or from exit_files(). &n; * Only the LAST user of the file gets to this point, i.e., it is&n; * called only ONCE.&n; *&n; * IMPORTANT: we get called ONLY when the refcnt on the file gets to zero &n; * (fput()),i.e, last task to access the file. Nobody else can access the &n; * file at this point.&n; *&n; * When called from exit_files(), the VMA has been freed because exit_mm()&n; * is executed before exit_files().&n; *&n; * When called from exit_files(), the current task is not yet ZOMBIE but we&n; * flush the PMU state to the context. &n; */
r_static
r_int
DECL|function|pfm_close
id|pfm_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|smpl_buf_size
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|smpl_buf_addr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|free_possible
op_assign
l_int|1
suffix:semicolon
r_int
id|state
comma
id|is_system
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_close called private=%p&bslash;n&quot;
comma
id|filp-&gt;private_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_IS_FILE
c_func
(paren
id|filp
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;bad magic&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_close: NULL ctx [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d is_current=%d&bslash;n&quot;
comma
id|state
comma
id|task
op_eq
id|current
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if task == current, then pfm_flush() unloaded the context&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_UNLOADED
)paren
r_goto
id|doit
suffix:semicolon
multiline_comment|/*&n;&t; * context is loaded/masked and task != current, we need to&n;&t; * either force an unload or go zombie&n;&t; */
multiline_comment|/*&n;&t; * The task is currently blocked or will block after an overflow.&n;&t; * we must force it to wakeup to get out of the&n;&t; * MASKED state and transition to the unloaded state by itself.&n;&t; *&n;&t; * This situation is only possible for per-task mode&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_MASKED
op_logical_and
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * set a &quot;partial&quot; zombie state to be checked&n;&t;&t; * upon return from down() in pfm_handle_work().&n;&t;&t; *&n;&t;&t; * We cannot use the ZOMBIE state, because it is checked&n;&t;&t; * by pfm_load_regs() which is called upon wakeup from down().&n;&t;&t; * In such case, it would free the context and then we would&n;&t;&t; * return to pfm_handle_work() which would access the&n;&t;&t; * stale context. Instead, we set a flag invisible to pfm_load_regs()&n;&t;&t; * but visible to pfm_handle_work().&n;&t;&t; *&n;&t;&t; * For some window of time, we have a zombie context with&n;&t;&t; * ctx_state = MASKED  and not ZOMBIE&n;&t;&t; */
id|ctx-&gt;ctx_fl_going_zombie
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * force task to wake up from MASKED state&n;&t;&t; */
id|up
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;waking up ctx_state=%d&bslash;n&quot;
comma
id|state
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * put ourself to sleep waiting for the other&n;&t;&t; * task to report completion&n;&t;&t; *&n;&t;&t; * the context is protected by mutex, therefore there&n;&t;&t; * is no risk of being notified of completion before&n;&t;&t; * begin actually on the waitq.&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: check for signals :&n;&t;&t; * &t;- ok of explicit close&n;&t;&t; * &t;- not ok when coming from exit_files()&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * context is unloaded at this point&n;&t;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;after zombie wakeup ctx_state=%d for&bslash;n&quot;
comma
id|state
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; &t; * switch context to zombie state&n;&t; &t; */
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_ZOMBIE
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;zombie ctx for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cannot free the context on the spot. deferred until&n;&t;&t; * the task notices the ZOMBIE state&n;&t;&t; */
id|free_possible
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
id|doit
suffix:colon
multiline_comment|/* reload state, may have changed during  opening of critical section */
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
multiline_comment|/*&n;&t; * the context is still attached to a task (possibly current)&n;&t; * we cannot destroy it right now&n;&t; */
multiline_comment|/*&n;&t; * we must free the sampling buffer right here because&n;&t; * we cannot rely on it being cleaned up later by the&n;&t; * monitored task. It is not possible to free vmalloc&squot;ed&n;&t; * memory in pfm_load_regs(). Instead, we remove the buffer&n;&t; * now. should there be subsequent PMU overflow originally&n;&t; * meant for sampling, the will be converted to spurious&n;&t; * and that&squot;s fine because the monitoring tools is gone anyway.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
(brace
id|smpl_buf_addr
op_assign
id|ctx-&gt;ctx_smpl_hdr
suffix:semicolon
id|smpl_buf_size
op_assign
id|ctx-&gt;ctx_smpl_size
suffix:semicolon
multiline_comment|/* no more sampling */
id|ctx-&gt;ctx_smpl_hdr
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_fl_is_sampling
op_assign
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d free_possible=%d addr=%p size=%lu&bslash;n&quot;
comma
id|state
comma
id|free_possible
comma
id|smpl_buf_addr
comma
id|smpl_buf_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf_addr
)paren
id|pfm_exit_smpl_buffer
c_func
(paren
id|ctx-&gt;ctx_buf_fmt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * UNLOADED that the session has already been unreserved.&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
(brace
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_fl_system
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disconnect file descriptor from context must be done&n;&t; * before we unlock.&n;&t; */
id|filp-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * if we free on the spot, the context is now completely unreacheable&n;&t; * from the callers side. The monitored task side is also cut, so we&n;&t; * can freely cut.&n;&t; *&n;&t; * If we have a deferred free, only the caller side is disconnected.&n;&t; */
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All memory free operations (especially for vmalloc&squot;ed memory)&n;&t; * MUST be done with interrupts ENABLED.&n;&t; */
r_if
c_cond
(paren
id|smpl_buf_addr
)paren
id|pfm_rvfree
c_func
(paren
id|smpl_buf_addr
comma
id|smpl_buf_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * return the memory used by the context&n;&t; */
r_if
c_cond
(paren
id|free_possible
)paren
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_no_open
id|pfm_no_open
c_func
(paren
r_struct
id|inode
op_star
id|irrelevant
comma
r_struct
id|file
op_star
id|dontcare
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_no_open called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|variable|pfm_file_ops
r_static
r_struct
id|file_operations
id|pfm_file_ops
op_assign
(brace
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|pfm_read
comma
dot
id|write
op_assign
id|pfm_write
comma
dot
id|poll
op_assign
id|pfm_poll
comma
dot
id|ioctl
op_assign
id|pfm_ioctl
comma
dot
id|open
op_assign
id|pfm_no_open
comma
multiline_comment|/* special open code to disallow open via /proc */
dot
id|fasync
op_assign
id|pfm_fasync
comma
dot
id|release
op_assign
id|pfm_close
comma
dot
id|flush
op_assign
id|pfm_flush
)brace
suffix:semicolon
r_static
r_int
DECL|function|pfmfs_delete_dentry
id|pfmfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|pfmfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|pfmfs_dentry_operations
op_assign
(brace
dot
id|d_delete
op_assign
id|pfmfs_delete_dentry
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|pfm_alloc_fd
id|pfm_alloc_fd
c_func
(paren
r_struct
id|file
op_star
op_star
id|cfile
)paren
(brace
r_int
id|fd
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
id|fd
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
id|ret
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a new inode&n;&t; */
id|inode
op_assign
id|new_inode
c_func
(paren
id|pfmfs_mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;new inode ino=%ld @%p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode
)paren
)paren
suffix:semicolon
id|inode-&gt;i_sb
op_assign
id|pfmfs_mnt-&gt;mnt_sb
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IFCHR
op_or
id|S_IRUGO
suffix:semicolon
id|inode-&gt;i_sock
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a new dcache entry&n;&t; */
id|file-&gt;f_dentry
op_assign
id|d_alloc
c_func
(paren
id|pfmfs_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_dentry
)paren
r_goto
id|out
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_op
op_assign
op_amp
id|pfmfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|file-&gt;f_dentry
comma
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|pfmfs_mnt
)paren
suffix:semicolon
id|file-&gt;f_mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|pfm_file_ops
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_READ
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * may have to delay until context is attached?&n;&t; */
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the file structure we will use&n;&t; */
op_star
id|cfile
op_assign
id|file
suffix:semicolon
r_return
id|fd
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|file
)paren
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_free_fd
id|pfm_free_fd
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|files_struct
op_star
id|files
op_assign
id|current-&gt;files
suffix:semicolon
multiline_comment|/* &n;&t; * there ie no fd_uninstall(), so we do it here&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|files-&gt;file_lock
)paren
suffix:semicolon
id|files-&gt;fd
(braket
id|fd
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|files-&gt;file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_remap_buffer
id|pfm_remap_buffer
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;CPU%d buf=0x%lx addr=0x%lx size=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|buf
comma
id|addr
comma
id|size
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|pfm_kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_remap_page_range
c_func
(paren
id|vma
comma
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_READONLY
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * allocate a sampling buffer and remaps it into the user address space of the task&n; */
r_static
r_int
DECL|function|pfm_smpl_buffer_alloc
id|pfm_smpl_buffer_alloc
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|rsize
comma
r_void
op_star
op_star
id|user_vaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|task-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
multiline_comment|/*&n;&t; * the fixed header + requested size and align to page boundary&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|rsize
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;sampling buffer rsize=%lu size=%lu bytes&bslash;n&quot;
comma
id|rsize
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&n;&t; * Check against address space limit.&n;&t; *&n;&t; * if ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len&gt; task-&gt;rlim[RLIMIT_AS].rlim_cur)&n;&t; * &t;return -ENOMEM;&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|task-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * We do the easy to undo allocations first.&n; &t; *&n;&t; * pfm_rvmalloc(), clears the buffer, so there is no leak&n;&t; */
id|smpl_buf
op_assign
id|pfm_rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;smpl_buf @%p&bslash;n&quot;
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error_kmem
suffix:semicolon
)brace
id|memset
c_func
(paren
id|vma
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vma
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * partially initialize the vma for the sampling buffer&n;&t; *&n;&t; * The VM_DONTCOPY flag is very important as it ensures that the mapping&n;&t; * will never be inherited for any child process (via fork()) which is always&n;&t; * what we want.&n;&t; */
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|VM_READ
op_or
id|VM_MAYREAD
op_or
id|VM_RESERVED
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
multiline_comment|/* XXX may need to change */
multiline_comment|/*&n;&t; * Now we have everything we need and we can initialize&n;&t; * and connect all the data structures&n;&t; */
id|ctx-&gt;ctx_smpl_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|ctx-&gt;ctx_smpl_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
multiline_comment|/*&n;&t; * Let&squot;s do the difficult operations next.&n;&t; *&n;&t; * now we atomically find some area in the address space and&n;&t; * remap the buffer in it.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* find some free area in address space, must have mmap sem held */
id|vma-&gt;vm_start
op_assign
id|pfm_get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_eq
l_int|0UL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|vma-&gt;vm_start
op_plus
id|size
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;aligned size=%ld, hdr=%p mapped @0x%lx&bslash;n&quot;
comma
id|size
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|vma-&gt;vm_start
)paren
)paren
suffix:semicolon
multiline_comment|/* can only be applied to current task, need to have the mm semaphore held when called */
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
id|vma
comma
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|vma-&gt;vm_start
comma
id|size
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process, must be&n;&t; * done with mmap lock held&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|vm_stat_account
c_func
(paren
id|vma
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep track of user level virtual address&n;&t; */
id|ctx-&gt;ctx_smpl_vaddr
op_assign
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|user_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|error_kmem
suffix:colon
id|pfm_rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
DECL|function|pfm_bad_permissions
id|pfm_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* inspired by ptrace_attach() */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cur: uid=%d gid=%d task: euid=%d suid=%d uid=%d egid=%d sgid=%d&bslash;n&quot;
comma
id|current-&gt;uid
comma
id|current-&gt;gid
comma
id|task-&gt;euid
comma
id|task-&gt;suid
comma
id|task-&gt;uid
comma
id|task-&gt;egid
comma
id|task-&gt;sgid
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|current-&gt;uid
op_ne
id|task-&gt;euid
)paren
op_logical_or
(paren
id|current-&gt;uid
op_ne
id|task-&gt;suid
)paren
op_logical_or
(paren
id|current-&gt;uid
op_ne
id|task-&gt;uid
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|task-&gt;egid
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|task-&gt;sgid
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|task-&gt;gid
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_PTRACE
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfarg_is_sane
id|pfarg_is_sane
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_context_t
op_star
id|pfx
)paren
(brace
r_int
id|ctx_flags
suffix:semicolon
multiline_comment|/* valid signal */
id|ctx_flags
op_assign
id|pfx-&gt;ctx_flags
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
multiline_comment|/*&n;&t;&t; * cannot block in this mode&n;&t;&t; */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode when in system wide monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
)brace
multiline_comment|/* probably more to add here */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_setup_buffer_fmt
id|pfm_setup_buffer_fmt
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ctx_flags
comma
r_int
r_int
id|cpu
comma
id|pfarg_context_t
op_star
id|arg
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|fmt_arg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
DECL|macro|PFM_CTXARG_BUF_ARG
mdefine_line|#define PFM_CTXARG_BUF_ARG(a)&t;(pfm_buffer_fmt_t *)(a+1)
multiline_comment|/* invoke and lock buffer format, if found */
id|fmt
op_assign
id|pfm_find_buffer_fmt
c_func
(paren
id|arg-&gt;ctx_smpl_buf_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] cannot find buffer format&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * buffer argument MUST be contiguous to pfarg_context_t&n;&t; */
r_if
c_cond
(paren
id|fmt-&gt;fmt_arg_size
)paren
id|fmt_arg
op_assign
id|PFM_CTXARG_BUF_ARG
c_func
(paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_buf_fmt_validate
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] after validate(0x%x,%d,%p)=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* link buffer format and context */
id|ctx-&gt;ctx_buf_fmt
op_assign
id|fmt
suffix:semicolon
multiline_comment|/*&n;&t; * check if buffer format wants to use perfmon buffer allocation/mapping service&n;&t; */
id|ret
op_assign
id|pfm_buf_fmt_getsize
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
multiline_comment|/*&n;&t;&t; * buffer is always remapped into the caller&squot;s address space&n;&t;&t; */
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|current
comma
id|ctx
comma
id|size
comma
op_amp
id|uaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* keep track of user address of buffer */
id|arg-&gt;ctx_smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_buf_fmt_init
c_func
(paren
id|fmt
comma
id|task
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx_flags
comma
id|cpu
comma
id|fmt_arg
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_pmu_state
id|pfm_reset_pmu_state
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * install reset values for PMC.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|i
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%d]=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmcs
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * PMD registers are set to 0UL when the context in memset()&n;&t; */
multiline_comment|/*&n;&t; * On context switched restore, we must restore ALL pmc and ALL pmd even&n;&t; * when they are not actively used by the task. In UP, the incoming process&n;&t; * may otherwise pick up left over PMC, PMD state from the previous process.&n;&t; * As opposed to PMD, stale PMC can cause harm to the incoming&n;&t; * process because they may change what is being measured.&n;&t; * Therefore, we must systematically reinstall the entire&n;&t; * PMC state. In SMP, the same thing is possible on the&n;&t; * same CPU but also on between 2 CPUs.&n;&t; *&n;&t; * The problem with PMD is information leaking especially&n;&t; * to user level when psr.sp=0&n;&t; *&n;&t; * There is unfortunately no easy way to avoid this problem&n;&t; * on either UP or SMP. This definitively slows down the&n;&t; * pfm_load_regs() function.&n;&t; */
multiline_comment|/*&n;&t;  * bitmask of all PMCs accessible to this context&n;&t;  *&n;&t;  * PMC0 is treated differently.&n;&t;  */
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
op_assign
id|pmu_conf-&gt;impl_pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
suffix:semicolon
multiline_comment|/*&n;&t; * bitmask of all PMDs that are accesible to this context&n;&t; */
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
op_assign
id|pmu_conf-&gt;impl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;&lt;%d&gt; all_pmcs=0x%lx all_pmds=0x%lx&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * useful in case of re-enable after disable&n;&t; */
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ctx_getsize
id|pfm_ctx_getsize
c_func
(paren
r_void
op_star
id|arg
comma
r_int
op_star
id|sz
)paren
(brace
id|pfarg_context_t
op_star
id|req
op_assign
(paren
id|pfarg_context_t
op_star
)paren
id|arg
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
op_star
id|sz
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfm_uuid_cmp
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
comma
id|pfm_null_uuid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fmt
op_assign
id|pfm_find_buffer_fmt
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot find buffer format&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* get just enough to copy in user parameters */
op_star
id|sz
op_assign
id|fmt-&gt;fmt_arg_size
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;arg_size=%lu&bslash;n&quot;
comma
op_star
id|sz
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cannot attach if :&n; * &t;- kernel task&n; * &t;- task not owned by caller&n; * &t;- task incompatible with context mode&n; */
r_static
r_int
DECL|function|pfm_task_incompatible
id|pfm_task_incompatible
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/*&n;&t; * no kernel task or task not owner by caller&n;&t; */
r_if
c_cond
(paren
id|task-&gt;mm
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;task [%d] has not memory context (kernel thread)&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|task
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;no permission to attach to  [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * cannot block in self-monitoring mode&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|task
op_eq
id|current
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot load a blocking context on self for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;state
op_eq
id|TASK_ZOMBIE
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot attach to  zombie task [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * always ok for self&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
op_logical_and
(paren
id|task-&gt;state
op_ne
id|TASK_TRACED
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot attach to non-stopped task [%d] state=%ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make sure the task is off any CPU&n;&t; */
id|wait_task_inactive
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* more to come... */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_task
id|pfm_get_task
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
id|pid_t
id|pid
comma
r_struct
id|task_struct
op_star
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* XXX: need to add more checks here */
r_if
c_cond
(paren
id|pid
OL
l_int|2
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
multiline_comment|/* make sure task cannot go away while we operate on it */
r_if
c_cond
(paren
id|p
)paren
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_task_incompatible
c_func
(paren
id|ctx
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
id|task
op_assign
id|p
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_ne
id|current
)paren
(brace
id|pfm_put_task
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_create
id|pfm_context_create
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_context_t
op_star
id|req
op_assign
(paren
id|pfarg_context_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* let&squot;s check the arguments first */
id|ret
op_assign
id|pfarg_is_sane
c_func
(paren
id|current
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ctx_flags
op_assign
id|req-&gt;ctx_flags
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
id|pfm_alloc_fd
c_func
(paren
op_amp
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error_file
suffix:semicolon
id|req-&gt;ctx_fd
op_assign
id|ctx-&gt;ctx_fd
op_assign
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * attach context to file&n;&t; */
id|filp-&gt;private_data
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t; * does the user want to sample?&n;&t; */
r_if
c_cond
(paren
id|pfm_uuid_cmp
c_func
(paren
id|req-&gt;ctx_smpl_buf_id
comma
id|pfm_null_uuid
)paren
)paren
(brace
id|ret
op_assign
id|pfm_setup_buffer_fmt
c_func
(paren
id|current
comma
id|ctx
comma
id|ctx_flags
comma
l_int|0
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|buffer_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * init context protection lock&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * context is unloaded&n;&t; */
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_UNLOADED
suffix:semicolon
multiline_comment|/*&n;&t; * initialization of context&squot;s flags&n;&t; */
id|ctx-&gt;ctx_fl_block
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_is_sampling
op_assign
id|ctx-&gt;ctx_buf_fmt
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* assume record() is defined */
id|ctx-&gt;ctx_fl_no_msg
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_OVFL_NO_MSG
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * will move to set properties&n;&t; * ctx-&gt;ctx_fl_excl_idle   = (ctx_flags &amp; PFM_FL_EXCL_IDLE) ? 1: 0;&n;&t; */
multiline_comment|/*&n;&t; * init restart semaphore to locked&n;&t; */
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * activation is used in SMP only&n;&t; */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize notification message queue&n;&t; */
id|ctx-&gt;ctx_msgq_head
op_assign
id|ctx-&gt;ctx_msgq_tail
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d no_msg=%d ctx_fd=%d &bslash;n&quot;
comma
id|ctx
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_system
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_fl_excl_idle
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize soft PMU state&n;&t; */
id|pfm_reset_pmu_state
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|pfm_free_fd
c_func
(paren
id|ctx-&gt;ctx_fd
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_buf_fmt
)paren
(brace
id|pfm_buf_fmt_exit
c_func
(paren
id|ctx-&gt;ctx_buf_fmt
comma
id|current
comma
l_int|NULL
comma
id|regs
)paren
suffix:semicolon
)brace
id|error_file
suffix:colon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pfm_new_counter_value
id|pfm_new_counter_value
(paren
id|pfm_counter_t
op_star
id|reg
comma
r_int
id|is_long_reset
)paren
(brace
r_int
r_int
id|val
op_assign
id|is_long_reset
ques
c_cond
id|reg-&gt;long_reset
suffix:colon
id|reg-&gt;short_reset
suffix:semicolon
r_int
r_int
id|new_seed
comma
id|old_seed
op_assign
id|reg-&gt;seed
comma
id|mask
op_assign
id|reg-&gt;mask
suffix:semicolon
r_extern
r_int
r_int
id|carta_random32
(paren
r_int
r_int
id|seed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;flags
op_amp
id|PFM_REGFL_RANDOM
)paren
(brace
id|new_seed
op_assign
id|carta_random32
c_func
(paren
id|old_seed
)paren
suffix:semicolon
id|val
op_sub_assign
(paren
id|old_seed
op_amp
id|mask
)paren
suffix:semicolon
multiline_comment|/* counter values are negative numbers! */
r_if
c_cond
(paren
(paren
id|mask
op_rshift
l_int|32
)paren
op_ne
l_int|0
)paren
multiline_comment|/* construct a full 64-bit random value: */
id|new_seed
op_or_assign
id|carta_random32
c_func
(paren
id|old_seed
op_rshift
l_int|32
)paren
op_lshift
l_int|32
suffix:semicolon
id|reg-&gt;seed
op_assign
id|new_seed
suffix:semicolon
)brace
id|reg-&gt;lval
op_assign
id|val
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_regs_masked
id|pfm_reset_regs_masked
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|is_long_reset
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1UL
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot; %s reset ctx_pmds[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;%s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|pfm_reset_regs
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|is_long_reset
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;ovfl_regs=0x%lx is_long_reset=%d&bslash;n&quot;
comma
id|ovfl_regs
(braket
l_int|0
)braket
comma
id|is_long_reset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_MASKED
)paren
(brace
id|pfm_reset_regs_masked
c_func
(paren
id|ctx
comma
id|ovfl_regs
comma
id|is_long_reset
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1UL
)paren
op_eq
l_int|0UL
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot; %s reset ctx_pmds[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|pfm_new_counter_value
c_func
(paren
id|ctx-&gt;ctx_pmds
op_plus
id|i
comma
id|is_long_reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;%s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|is_long_reset
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmcs
id|pfm_write_pmcs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
comma
id|pmc_pm
suffix:semicolon
r_int
r_int
id|smpl_pmds
comma
id|reset_pmds
comma
id|impl_pmds
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
comma
id|flags
comma
id|pmc_type
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
comma
id|is_loaded
comma
id|is_system
comma
id|expert_mode
suffix:semicolon
r_int
id|is_monitor
comma
id|is_counting
comma
id|state
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|pfm_reg_check_t
id|wr_func
suffix:semicolon
DECL|macro|PFM_CHECK_PMC_PM
mdefine_line|#define PFM_CHECK_PMC_PM(x, y, z) ((x)-&gt;ctx_fl_system ^ PMC_PM(y, z))
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_loaded
op_assign
id|state
op_eq
id|PFM_CTX_LOADED
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
id|impl_pmds
op_assign
id|pmu_conf-&gt;impl_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
op_logical_or
id|is_system
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
id|expert_mode
op_assign
id|pfm_sysctl.expert_mode
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|reg_flags
op_assign
id|req-&gt;reg_flags
suffix:semicolon
id|value
op_assign
id|req-&gt;reg_value
suffix:semicolon
id|smpl_pmds
op_assign
id|req-&gt;reg_smpl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|reset_pmds
op_assign
id|req-&gt;reg_reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cnum
op_ge
id|PMU_MAX_PMCS
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc%u is invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|pmc_type
op_assign
id|pmu_conf-&gt;pmc_desc
(braket
id|cnum
)braket
dot
id|type
suffix:semicolon
id|pmc_pm
op_assign
(paren
id|value
op_rshift
id|pmu_conf-&gt;pmc_desc
(braket
id|cnum
)braket
dot
id|pm_pos
)paren
op_amp
l_int|0x1
suffix:semicolon
id|is_counting
op_assign
(paren
id|pmc_type
op_amp
id|PFM_REG_COUNTING
)paren
op_eq
id|PFM_REG_COUNTING
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|is_monitor
op_assign
(paren
id|pmc_type
op_amp
id|PFM_REG_MONITOR
)paren
op_eq
id|PFM_REG_MONITOR
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we reject all non implemented PMC as well&n;&t;&t; * as attempts to modify PMC[0-3] which are used&n;&t;&t; * as status registers by the PMU&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pmc_type
op_amp
id|PFM_REG_IMPL
)paren
op_eq
l_int|0
op_logical_or
(paren
id|pmc_type
op_amp
id|PFM_REG_CONTROL
)paren
op_eq
id|PFM_REG_CONTROL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc%u is unimplemented or no-access pmc_type=%x&bslash;n&quot;
comma
id|cnum
comma
id|pmc_type
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|wr_func
op_assign
id|pmu_conf-&gt;pmc_desc
(braket
id|cnum
)braket
dot
id|write_check
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the PMC is a monitor, then if the value is not the default:&n;&t;&t; * &t;- system-wide session: PMCx.pm=1 (privileged monitor)&n;&t;&t; * &t;- per-task           : PMCx.pm=0 (user monitor)&n;&t;&t; */
r_if
c_cond
(paren
id|is_monitor
op_logical_and
id|value
op_ne
id|PMC_DFL_VAL
c_func
(paren
id|cnum
)paren
op_logical_and
id|is_system
op_xor
id|pmc_pm
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc%u pmc_pm=%lu is_system=%d&bslash;n&quot;
comma
id|cnum
comma
id|pmc_pm
comma
id|is_system
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * enforce generation of overflow interrupt. Necessary on all&n;&t;&t; &t; * CPUs.&n;&t;&t; &t; */
id|value
op_or_assign
l_int|1
op_lshift
id|PMU_PMC_OI
suffix:semicolon
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
(brace
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg_flags
op_amp
id|PFM_REGFL_RANDOM
)paren
id|flags
op_or_assign
id|PFM_REGFL_RANDOM
suffix:semicolon
multiline_comment|/* verify validity of smpl_pmds */
r_if
c_cond
(paren
(paren
id|smpl_pmds
op_amp
id|impl_pmds
)paren
op_ne
id|smpl_pmds
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid smpl_pmds 0x%lx for pmc%u&bslash;n&quot;
comma
id|smpl_pmds
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* verify validity of reset_pmds */
r_if
c_cond
(paren
(paren
id|reset_pmds
op_amp
id|impl_pmds
)paren
op_ne
id|reset_pmds
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid reset_pmds 0x%lx for pmc%u&bslash;n&quot;
comma
id|reset_pmds
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|reg_flags
op_amp
(paren
id|PFM_REGFL_OVFL_NOTIFY
op_or
id|PFM_REGFL_RANDOM
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot set ovfl_notify or random on pmc%u&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* eventid on non-counting monitors are ignored */
)brace
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|expert_mode
op_eq
l_int|0
op_logical_and
id|wr_func
)paren
)paren
(brace
id|ret
op_assign
(paren
op_star
id|wr_func
)paren
(paren
id|task
comma
id|ctx
comma
id|cnum
comma
op_amp
id|value
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we commit the changes to the software state&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * update overflow information&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * full flag update each time a register is programmed&n;&t;&t; &t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
op_assign
id|reset_pmds
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|smpl_pmds
(braket
l_int|0
)braket
op_assign
id|smpl_pmds
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|eventid
op_assign
id|req-&gt;reg_smpl_eventid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mark all PMDS to be accessed as used.&n;&t;&t;&t; *&n;&t;&t;&t; * We do not keep track of PMC because we have to&n;&t;&t;&t; * systematically restore ALL of them.&n;&t;&t;&t; *&n;&t;&t;&t; * We do not update the used_monitors mask, because&n;&t;&t;&t; * if we have not programmed them, then will be in&n;&t;&t;&t; * a quiescent state, therefore we will not need to&n;&t;&t;&t; * mask/restore then when context is MASKED.&n;&t;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|reset_pmds
)paren
suffix:semicolon
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|smpl_pmds
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * make sure we do not try to reset on&n;&t;&t; &t; * restart because we have established new values&n;&t;&t; &t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_MASKED
)paren
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Needed in case the user does not initialize the equivalent&n;&t;&t; * PMD. Clearing is done indirectly via pfm_reset_pmu_state() so there is no&n;&t;&t; * possible leak here.&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|pmu_conf-&gt;pmc_desc
(braket
id|cnum
)braket
dot
id|dep_pmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * keep track of the monitor PMC that we are using.&n;&t;&t; * we save the value of the pmc in ctx_pmcs[] and if&n;&t;&t; * the monitoring is not stopped for the context we also&n;&t;&t; * place it in the saved state area so that it will be&n;&t;&t; * picked up later by the context switch code.&n;&t;&t; *&n;&t;&t; * The value in ctx_pmcs[] can only be changed in pfm_write_pmcs().&n;&t;&t; *&n;&t;&t; * The value in thread-&gt;pmcs[] may be modified on overflow, i.e.,  when&n;&t;&t; * monitoring needs to be stopped.&n;&t;&t; */
r_if
c_cond
(paren
id|is_monitor
)paren
id|CTX_USED_MONITOR
c_func
(paren
id|ctx
comma
l_int|1UL
op_lshift
id|cnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update context state&n;&t;&t; */
id|ctx-&gt;ctx_pmcs
(braket
id|cnum
)braket
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * write thread state&n;&t;&t;&t; */
r_if
c_cond
(paren
id|is_system
op_eq
l_int|0
)paren
id|thread-&gt;pmcs
(braket
id|cnum
)braket
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * write hardware register if we can&n;&t;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * per-task SMP only here&n;&t;&t;&t;&t; *&n;&t;&t;&t; &t; * we are guaranteed that the task is not running on the other CPU,&n;&t;&t;&t; &t; * we indicate that this PMD will need to be reloaded if the task&n;&t;&t;&t; &t; * is rescheduled on the CPU it ran last on.&n;&t;&t;&t; &t; */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_or_assign
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
macro_line|#endif
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc[%u]=0x%lx loaded=%d access_pmu=%d all_pmcs=0x%lx used_pmds=0x%lx eventid=%ld smpl_pmds=0x%lx reset_pmds=0x%lx reloads_pmcs=0x%lx used_monitors=0x%lx ovfl_regs=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|eventid
comma
id|smpl_pmds
comma
id|reset_pmds
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_monitors
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make sure the changes are visible&n;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmds
id|pfm_write_pmds
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|value
comma
id|hw_value
comma
id|ovfl_mask
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
comma
id|state
suffix:semicolon
r_int
id|is_counting
comma
id|is_loaded
comma
id|is_system
comma
id|expert_mode
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|pfm_reg_check_t
id|wr_func
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_loaded
op_assign
id|state
op_eq
id|PFM_CTX_LOADED
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|ovfl_mask
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only write to the PMC when the task is&n;&t; * the owner of the local PMU.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|is_loaded
)paren
)paren
(brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
op_logical_or
id|is_system
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
id|expert_mode
op_assign
id|pfm_sysctl.expert_mode
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|value
op_assign
id|req-&gt;reg_value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u] is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
id|is_counting
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|wr_func
op_assign
id|pmu_conf-&gt;pmd_desc
(braket
id|cnum
)braket
dot
id|write_check
suffix:semicolon
multiline_comment|/*&n;&t;&t; * execute write checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|expert_mode
op_eq
l_int|0
op_logical_and
id|wr_func
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|value
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|wr_func
)paren
(paren
id|task
comma
id|ctx
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|abort_mission
suffix:semicolon
id|value
op_assign
id|v
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no error on this register&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now commit changes to software state&n;&t;&t; */
id|hw_value
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update virtualized (64bits) counter&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * write context state&n;&t;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|lval
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * when context is load we use the split value&n;&t;&t;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|hw_value
op_assign
id|value
op_amp
id|ovfl_mask
suffix:semicolon
id|value
op_assign
id|value
op_amp
op_complement
id|ovfl_mask
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * update reset values (not just for counters)&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|long_reset
op_assign
id|req-&gt;reg_long_reset
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|short_reset
op_assign
id|req-&gt;reg_short_reset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update randomization parameters (not just for counters)&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|seed
op_assign
id|req-&gt;reg_random_seed
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|mask
op_assign
id|req-&gt;reg_random_mask
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update context value&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
op_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Keep track of what we use&n;&t;&t; *&n;&t;&t; * We do not keep track of PMC because we have to&n;&t;&t; * systematically restore ALL of them.&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|PMD_PMD_DEP
c_func
(paren
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * mark this PMD register used as well&n;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|RDEP
c_func
(paren
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * make sure we do not try to reset on&n;&t;&t; * restart because we have established new values&n;&t;&t; */
r_if
c_cond
(paren
id|is_counting
op_logical_and
id|state
op_eq
id|PFM_CTX_MASKED
)paren
(brace
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * write thread state&n;&t;&t; &t; */
r_if
c_cond
(paren
id|is_system
op_eq
l_int|0
)paren
id|thread-&gt;pmds
(braket
id|cnum
)braket
op_assign
id|hw_value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * write hardware register if we can&n;&t;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|hw_value
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t;&t; &t; * we are guaranteed that the task is not running on the other CPU,&n;&t;&t;&t; &t; * we indicate that this PMD will need to be reloaded if the task&n;&t;&t;&t; &t; * is rescheduled on the CPU it ran last on.&n;&t;&t;&t; &t; */
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_or_assign
l_int|1UL
op_lshift
id|cnum
suffix:semicolon
macro_line|#endif
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u]=0x%lx loaded=%d access_pmu=%d, hw_value=0x%lx ctx_pmd=0x%lx  short_reset=0x%lx &quot;
l_string|&quot;long_reset=0x%lx notify=%c used_pmds=0x%lx reset_pmds=0x%lx reload_pmds=0x%lx all_pmds=0x%lx ovfl_regs=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|value
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|hw_value
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|short_reset
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|long_reset
comma
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|cnum
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make changes visible&n;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * for now, we have only one possibility for error&n;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * By the way of PROTECT_CONTEXT(), interrupts are masked while we are in this function.&n; * Therefore we know, we do not have to worry about the PMU overflow interrupt. If an&n; * interrupt is delivered during the call, it will be kept pending until we leave, making&n; * it appears as if it had been generated at the UNPROTECT_CONTEXT(). At least we are&n; * guaranteed to return consistent data to the user, it may simply be old. It is not&n; * trivial to treat the overflow while inside the call because you may end up in&n; * some module sampling buffer code causing deadlocks.&n; */
r_static
r_int
DECL|function|pfm_read_pmds
id|pfm_read_pmds
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0UL
comma
id|lval
comma
id|ovfl_mask
comma
id|sval
suffix:semicolon
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
comma
id|reg_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
comma
id|state
suffix:semicolon
r_int
id|is_loaded
comma
id|is_system
comma
id|is_counting
comma
id|expert_mode
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|pfm_reg_check_t
id|rd_func
suffix:semicolon
multiline_comment|/*&n;&t; * access is possible when loaded only for&n;&t; * self-monitoring tasks or in UP mode&n;&t; */
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_loaded
op_assign
id|state
op_eq
id|PFM_CTX_LOADED
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|ovfl_mask
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|is_loaded
)paren
)paren
(brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * this can be true when not self-monitoring only in UP&n;&t;&t; */
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
op_logical_or
id|is_system
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
id|expert_mode
op_assign
id|pfm_sysctl.expert_mode
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;loaded=%d access_pmu=%d ctx_state=%d&bslash;n&quot;
comma
id|is_loaded
comma
id|can_access_pmu
comma
id|state
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only read the PMD from the hardware register when&n;&t; * the task is the owner of the local PMU.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
id|reg_flags
op_assign
id|req-&gt;reg_flags
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we can only read the register that we use. That includes&n;&t;&t; * the one we explicitely initialize AND the one we want included&n;&t;&t; * in the sampling buffer (smpl_regs).&n;&t;&t; *&n;&t;&t; * Having this restriction allows optimization in the ctxsw routine&n;&t;&t; * without compromising security (leaks)&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|CTX_IS_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
id|sval
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|val
suffix:semicolon
id|lval
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|cnum
)braket
dot
id|lval
suffix:semicolon
id|is_counting
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the task is not the current one, then we check if the&n;&t;&t; * PMU state is still in the local live register due to lazy ctxsw.&n;&t;&t; * If true, then we read directly from the registers.&n;&t;&t; */
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * context has been saved&n;&t;&t;&t; * if context is zombie, then task does not exist anymore.&n;&t;&t;&t; * In this case, we use the full value saved in the context (pfm_flush_regs()).&n;&t;&t;&t; */
id|val
op_assign
id|is_loaded
ques
c_cond
id|thread-&gt;pmds
(braket
id|cnum
)braket
suffix:colon
l_int|0UL
suffix:semicolon
)brace
id|rd_func
op_assign
id|pmu_conf-&gt;pmd_desc
(braket
id|cnum
)braket
dot
id|read_check
suffix:semicolon
r_if
c_cond
(paren
id|is_counting
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX: need to check for overflow when loaded&n;&t;&t;&t; */
id|val
op_and_assign
id|ovfl_mask
suffix:semicolon
id|val
op_add_assign
id|sval
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * execute read checker, if any&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|expert_mode
op_eq
l_int|0
op_logical_and
id|rd_func
)paren
)paren
(brace
r_int
r_int
id|v
op_assign
id|val
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|rd_func
)paren
(paren
id|ctx-&gt;ctx_task
comma
id|ctx
comma
id|cnum
comma
op_amp
id|v
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
id|val
op_assign
id|v
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmd[%u]=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update register return value, abort all if problem during copy.&n;&t;&t; * we only modify the reg_flags field. no check mode is fine because&n;&t;&t; * access has been verified upfront in sys_perfmonctl().&n;&t;&t; */
id|req-&gt;reg_value
op_assign
id|val
suffix:semicolon
id|req-&gt;reg_flags
op_assign
id|reg_flags
suffix:semicolon
id|req-&gt;reg_last_reset_val
op_assign
id|lval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|pfm_mod_write_pmcs
id|pfm_mod_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_write_pmcs
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|pfm_mod_write_pmcs
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_mod_write_pmcs
)paren
suffix:semicolon
r_int
DECL|function|pfm_mod_read_pmds
id|pfm_mod_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_read_pmds
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|pfm_mod_read_pmds
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_mod_read_pmds
)paren
suffix:semicolon
multiline_comment|/*&n; * Only call this function when a process it trying to&n; * write the debug registers (reading is always allowed)&n; */
r_int
DECL|function|pfm_use_debug_registers
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf-&gt;use_rr_dbregs
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;called for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do it only once&n;&t; */
r_if
c_cond
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Even on SMP, we do not need to use an atomic here because&n;&t; * the only way in is via ptrace() and this is possible only when the&n;&t; * process is stopped. Even in the case where the ctxsw out is not totally&n;&t; * completed by the time we come here, there is no way the &squot;stopped&squot; process&n;&t; * could be in the middle of fiddling with the pfm_write_ibr_dbr() routine.&n;&t; * So this is always safe.&n;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot allow setting breakpoints when system wide monitoring&n;&t; * sessions are using the debug registers.&n;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
OG
l_int|0
)paren
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|pfm_sessions.pfs_ptrace_use_dbregs
op_increment
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ptrace_use_dbregs=%u  sys_use_dbregs=%u by [%d] ret = %d&bslash;n&quot;
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|task-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for every task that exits with the&n; * IA64_THREAD_DBG_VALID set. This indicates a task which was&n; * able to use the debug registers for debugging purposes via&n; * ptrace(). Therefore we know it was not using them for&n; * perfmormance monitoring, so we only decrement the number&n; * of &quot;ptraced&quot; debug register users to keep the count up to date&n; */
r_int
DECL|function|pfm_release_debug_registers
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf-&gt;use_rr_dbregs
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: invalid release for [%d] ptrace_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_ptrace_use_dbregs
op_decrement
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_restart
id|pfm_restart
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|fmt
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|rst_ctrl
suffix:semicolon
r_int
id|state
comma
id|is_system
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|PFM_CTX_MASKED
suffix:colon
r_break
suffix:semicolon
r_case
id|PFM_CTX_LOADED
suffix:colon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
op_logical_and
id|fmt-&gt;fmt_restart_active
)paren
r_break
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|PFM_CTX_UNLOADED
suffix:colon
r_case
id|PFM_CTX_ZOMBIE
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid state=%d&bslash;n&quot;
comma
id|state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
r_default
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;state=%d, cannot operate (no active_restart handler)&bslash;n&quot;
comma
id|state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|task
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] pfm_restart no task&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|is_system
)paren
(brace
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;restarting self %d ovfl=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|prefetch
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|rst_ctrl.bits.mask_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.bits.reset_ovfl_pmds
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_LOADED
)paren
id|ret
op_assign
id|pfm_buf_fmt_restart_active
c_func
(paren
id|fmt
comma
id|task
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|pfm_buf_fmt_restart
c_func
(paren
id|fmt
comma
id|task
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|rst_ctrl.bits.mask_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.bits.reset_ovfl_pmds
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rst_ctrl.bits.reset_ovfl_pmds
)paren
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rst_ctrl.bits.mask_monitoring
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;resuming monitoring for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_MASKED
)paren
id|pfm_restore_monitoring
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;keeping monitoring stopped for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
singleline_comment|// cannot use pfm_stop_monitoring(task, regs);
)brace
)brace
multiline_comment|/*&n;&t;&t; * clear overflowed PMD mask to remove any stale information&n;&t;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * back to LOADED state&n;&t;&t; */
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_LOADED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: not really useful for self monitoring&n;&t;&t; */
id|ctx-&gt;ctx_fl_can_restart
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * restart another task&n;&t; */
multiline_comment|/*&n;&t; * When PFM_CTX_MASKED, we cannot issue a restart before the previous &n;&t; * one is seen by the task.&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_MASKED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_can_restart
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * will prevent subsequent restart before this one is&n;&t;&t; * seen by other task&n;&t;&t; */
id|ctx-&gt;ctx_fl_can_restart
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if blocking, then post the semaphore is PFM_CTX_MASKED, i.e.&n;&t; * the task is blocked or on its way to block. That&squot;s the normal&n;&t; * restart path. If the monitoring is not masked, then the task&n;&t; * can be actively monitoring and we cannot directly intervene.&n;&t; * Therefore we use the trap mechanism to catch the task and&n;&t; * force it to reset the buffer/reset PMDs.&n;&t; *&n;&t; * if non-blocking, then we ensure that the task will go into&n;&t; * pfm_handle_work() before returning to user mode.&n;&t; *&n;&t; * We cannot explicitely reset another task, it MUST always&n;&t; * be done by the task itself. This works for system wide because&n;&t; * the tool that is controlling the session is logically doing &n;&t; * &quot;self-monitoring&quot;.&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|state
op_eq
id|PFM_CTX_MASKED
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;unblocking [%d] &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] armed exit trap&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_RESET
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|1
)paren
suffix:semicolon
id|pfm_set_task_notify
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: send reschedule if task runs on another CPU&n;&t;&t; */
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_debug
id|pfm_debug
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|m
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|arg
suffix:semicolon
id|pfm_sysctl.debug
op_assign
id|m
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|pfm_debug_var
op_assign
id|pfm_sysctl.debug
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon debugging %s (timing reset)&bslash;n&quot;
comma
id|pfm_sysctl.debug
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pfm_stats
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_stats
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|NR_CPUS
suffix:semicolon
id|m
op_increment
)paren
(brace
id|pfm_stats
(braket
id|m
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * arg can be NULL and count can be zero for this function&n; */
r_static
r_int
DECL|function|pfm_write_ibr_dbr
id|pfm_write_ibr_dbr
c_func
(paren
r_int
id|mode
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfarg_dbreg_t
op_star
id|req
op_assign
(paren
id|pfarg_dbreg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbreg_t
id|dbreg
suffix:semicolon
r_int
r_int
id|rnum
suffix:semicolon
r_int
id|first_time
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|state
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
suffix:semicolon
r_int
id|is_system
comma
id|is_loaded
suffix:semicolon
r_if
c_cond
(paren
id|pmu_conf-&gt;use_rr_dbregs
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_loaded
op_assign
id|state
op_eq
id|PFM_CTX_LOADED
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * on both UP and SMP, we can only write to the PMC when the task is&n;&t; * the owner of the local PMU.&n;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In system wide and when the context is loaded, access can only happen&n;&t;&t; * when the caller is running on the CPU being monitored by the session.&n;&t;&t; * It does not have to be the owner (ctx_task) of the context per se.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|can_access_pmu
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
op_logical_or
id|is_system
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we do not need to check for ipsr.db because we do clear ibr.x, dbr.r, and dbr.w&n;&t; * ensuring that no real breakpoint can be installed via this call.&n;&t; *&n;&t; * IMPORTANT: regs can be NULL in this function&n;&t; */
id|first_time
op_assign
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t bother if we are loaded and task is being debugged&n;&t; */
r_if
c_cond
(paren
id|is_loaded
op_logical_and
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;debug registers already in use for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for debug registers in system wide mode&n;&t; *&n;&t; * If though a check is done in pfm_context_load(),&n;&t; * we must repeat it here, in case the registers are&n;&t; * written after the context is loaded&n;&t; */
r_if
c_cond
(paren
id|is_loaded
)paren
(brace
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_time
op_logical_and
id|is_system
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|pfm_sessions.pfs_sys_use_dbregs
op_increment
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * mark ourself as user of the debug registers for&n;&t; * perfmon purposes.&n;&t; */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; &t; * clear hardware registers to make sure we don&squot;t&n; &t; * pick up stale state.&n;&t; *&n;&t; * for a system wide session, we do not use&n;&t; * thread.dbr, thread.ibr because this process&n;&t; * never leaves the current CPU and the state&n;&t; * is shared by all processes running on it&n; &t; */
r_if
c_cond
(paren
id|first_time
op_logical_and
id|can_access_pmu
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] clearing ibrs, dbrs&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf-&gt;num_ibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_dv_serialize_instruction
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf-&gt;num_dbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_dv_serialize_data
c_func
(paren
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now install the values into the registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|rnum
op_assign
id|req-&gt;dbreg_num
suffix:semicolon
id|dbreg.val
op_assign
id|req-&gt;dbreg_value
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_eq
id|PFM_CODE_RR
op_logical_and
id|rnum
op_ge
id|PFM_NUM_IBRS
)paren
op_logical_or
(paren
(paren
id|mode
op_eq
id|PFM_DATA_RR
)paren
op_logical_and
id|rnum
op_ge
id|PFM_NUM_DBRS
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid register %u val=0x%lx mode=%d i=%d count=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|mode
comma
id|i
comma
id|count
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * make sure we do not install enabled breakpoint&n;&t;&t; */
r_if
c_cond
(paren
id|rnum
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|PFM_CODE_RR
)paren
id|dbreg.ibr.ibr_x
op_assign
l_int|0
suffix:semicolon
r_else
id|dbreg.dbr.dbr_r
op_assign
id|dbreg.dbr.dbr_w
op_assign
l_int|0
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;dbreg_flags
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Debug registers, just like PMC, can only be modified&n;&t;&t; * by a kernel call. Moreover, perfmon() access to those&n;&t;&t; * registers are centralized in this routine. The hardware&n;&t;&t; * does not modify the value of these registers, therefore,&n;&t;&t; * if we save them as they are written, we can avoid having&n;&t;&t; * to save them on context switch out. This is made possible&n;&t;&t; * by the fact that when perfmon uses debug registers, ptrace()&n;&t;&t; * won&squot;t be able to modify them concurrently.&n;&t;&t; */
r_if
c_cond
(paren
id|mode
op_eq
id|PFM_CODE_RR
)paren
(brace
id|CTX_USED_IBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ia64_dv_serialize_instruction
c_func
(paren
)paren
suffix:semicolon
)brace
id|ctx-&gt;ctx_ibrs
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;write ibr%u=0x%lx used_ibrs=0x%x is_loaded=%d access_pmu=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
comma
id|is_loaded
comma
id|can_access_pmu
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CTX_USED_DBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|ia64_dv_serialize_data
c_func
(paren
)paren
suffix:semicolon
)brace
id|ctx-&gt;ctx_dbrs
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;write dbr%u=0x%lx used_dbrs=0x%x is_loaded=%d access_pmu=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
comma
id|is_loaded
comma
id|can_access_pmu
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * in case it was our first attempt, we undo the global modifications&n;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * install error return flag&n;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;dbreg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_ibrs
id|pfm_write_ibrs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|pfm_write_ibr_dbr
c_func
(paren
id|PFM_CODE_RR
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_dbrs
id|pfm_write_dbrs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|pfm_write_ibr_dbr
c_func
(paren
id|PFM_DATA_RR
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_int
DECL|function|pfm_mod_write_ibrs
id|pfm_mod_write_ibrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_write_ibrs
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|pfm_mod_write_ibrs
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_mod_write_ibrs
)paren
suffix:semicolon
r_int
DECL|function|pfm_mod_write_dbrs
id|pfm_mod_write_dbrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|req
comma
r_int
r_int
id|nreq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * for now limit to current task, which is enough when calling&n;&t; * from overflow handler&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|pfm_write_dbrs
c_func
(paren
id|ctx
comma
id|req
comma
id|nreq
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|pfm_mod_write_dbrs
id|EXPORT_SYMBOL
c_func
(paren
id|pfm_mod_write_dbrs
)paren
suffix:semicolon
r_static
r_int
DECL|function|pfm_get_features
id|pfm_get_features
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_features_t
op_star
id|req
op_assign
(paren
id|pfarg_features_t
op_star
)paren
id|arg
suffix:semicolon
id|req-&gt;ft_version
op_assign
id|PFM_VERSION
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_stop
id|pfm_stop
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_int
id|state
comma
id|is_system
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
multiline_comment|/*&n;&t; * context must be attached to issue the stop command (includes LOADED,MASKED,ZOMBIE)&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_UNLOADED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;task [%d] ctx_state=%d is_system=%d&bslash;n&quot;
comma
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
op_member_access_from_pointer
id|pid
comma
id|state
comma
id|is_system
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|is_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * Update local PMU first&n;&t;&t; *&n;&t;&t; * disable dcr pp&n;&t;&t; */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update local cpuinfo&n;&t;&t; */
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * stop monitoring, does srlz.i&n;&t;&t; */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * stop monitoring in the caller&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-task mode&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
multiline_comment|/* stop monitoring  at kernel level */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * stop monitoring at the user level&n;&t; &t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tregs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * stop monitoring at the user level&n;&t; &t; */
id|ia64_psr
c_func
(paren
id|tregs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * monitoring disabled in kernel at next reschedule&n;&t;&t; */
id|ctx-&gt;ctx_saved_psr_up
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;task=[%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_start
id|pfm_start
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
r_int
id|state
comma
id|is_system
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|PFM_CTX_LOADED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n; &t; * In system wide and when the context is loaded, access can only happen&n; &t; * when the caller is running on the CPU being monitored by the session.&n; &t; * It does not have to be the owner (ctx_task) of the context per se.&n; &t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;should be running on CPU%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|is_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * set user level psr.pp for the caller&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now update the local PMU and cpuinfo&n;&t;&t; */
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * start monitoring at kernel level&n;&t;&t; */
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable dcr pp */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-process mode&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_task
op_eq
id|current
)paren
(brace
multiline_comment|/* start monitoring at kernel level */
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * activate monitoring at user level&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|tregs
op_assign
id|ia64_task_regs
c_func
(paren
id|ctx-&gt;ctx_task
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * start monitoring at the kernel level the next&n;&t;&t; * time the task is scheduled&n;&t;&t; */
id|ctx-&gt;ctx_saved_psr_up
op_assign
id|IA64_PSR_UP
suffix:semicolon
multiline_comment|/*&n;&t;&t; * activate monitoring at user level&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|tregs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_get_pmc_reset
id|pfm_get_pmc_reset
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_reg_t
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|cnum
op_assign
id|req-&gt;reg_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
id|req-&gt;reg_value
op_assign
id|PMC_DFL_VAL
c_func
(paren
id|cnum
)paren
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pmc_reset_val pmc[%u]=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|req-&gt;reg_value
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|req-&gt;reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_check_task_exist
id|pfm_check_task_exist
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|t
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
(paren
id|g
comma
id|t
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;thread.pfm_context
op_eq
id|ctx
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|while_each_thread
(paren
id|g
comma
id|t
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;pfm_check_task_exist: ret=%d ctx=%p&bslash;n&quot;
comma
id|ret
comma
id|ctx
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_load
id|pfm_context_load
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|thread_struct
op_star
id|thread
suffix:semicolon
r_struct
id|pfm_context_t
op_star
id|old
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
r_struct
id|task_struct
op_star
id|owner_task
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|pfarg_load_t
op_star
id|req
op_assign
(paren
id|pfarg_load_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
op_star
id|pmcs_source
comma
op_star
id|pmds_source
suffix:semicolon
r_int
id|the_cpu
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|state
comma
id|is_system
comma
id|set_dbregs
op_assign
l_int|0
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
multiline_comment|/*&n;&t; * can only load from unloaded or terminated state&n;&t; */
r_if
c_cond
(paren
id|state
op_ne
id|PFM_CTX_UNLOADED
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot load to [%d], invalid ctx_state=%d&bslash;n&quot;
comma
id|req-&gt;load_pid
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] using_dbreg=%d&bslash;n&quot;
comma
id|req-&gt;load_pid
comma
id|ctx-&gt;ctx_fl_using_dbreg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|req-&gt;load_pid
op_eq
id|current-&gt;pid
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode on self&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|pfm_get_task
c_func
(paren
id|ctx
comma
id|req-&gt;load_pid
comma
op_amp
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] get_task=%d&bslash;n&quot;
comma
id|req-&gt;load_pid
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * system wide is self monitoring only&n;&t; */
r_if
c_cond
(paren
id|is_system
op_logical_and
id|task
op_ne
id|current
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;system wide is self monitoring only load_pid=%d&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * cannot load a context which is using range restrictions,&n;&t; * into a task that is being debugged.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_if
c_cond
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] task is debugged, cannot load range restrictions&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_system
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot load [%d] dbregs in use&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_increment
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load [%d] increased sys_use_dbreg=%u&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pfm_sessions.pfs_sys_use_dbregs
)paren
)paren
suffix:semicolon
id|set_dbregs
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * SMP system-wide monitoring implies self-monitoring.&n;&t; *&n;&t; * The programming model expects the task to&n;&t; * be pinned on a CPU throughout the session.&n;&t; * Here we take note of the current CPU at the&n;&t; * time the context is loaded. No call from&n;&t; * another CPU will be allowed.&n;&t; *&n;&t; * The pinning via shed_setaffinity()&n;&t; * must be done by the calling task prior&n;&t; * to this call.&n;&t; *&n;&t; * systemwide: keep track of CPU this session is supposed to run on&n;&t; */
id|the_cpu
op_assign
id|ctx-&gt;ctx_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * now reserve the session&n;&t; */
id|ret
op_assign
id|pfm_reserve_session
c_func
(paren
id|current
comma
id|is_system
comma
id|the_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * task is necessarily stopped at this point.&n;&t; *&n;&t; * If the previous context was zombie, then it got removed in&n;&t; * pfm_save_regs(). Therefore we should not see it here.&n;&t; * If we see a context, then this is an active context&n;&t; *&n;&t; * XXX: needs to be atomic&n;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;before cmpxchg() old_ctx=%p new_ctx=%p&bslash;n&quot;
comma
id|thread-&gt;pfm_context
comma
id|ctx
)paren
)paren
suffix:semicolon
id|old
op_assign
id|ia64_cmpxchg
c_func
(paren
id|acq
comma
op_amp
id|thread-&gt;pfm_context
comma
l_int|NULL
comma
id|ctx
comma
r_sizeof
(paren
id|pfm_context_t
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;load_pid [%d] already has a context&bslash;n&quot;
comma
id|req-&gt;load_pid
)paren
)paren
suffix:semicolon
r_goto
id|error_unres
suffix:semicolon
)brace
id|pfm_reset_msgq
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_LOADED
suffix:semicolon
multiline_comment|/*&n;&t; * link context to task&n;&t; */
id|ctx-&gt;ctx_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
id|is_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * we load as stopped&n;&t;&t; */
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_DCR_PP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_excl_idle
)paren
id|PFM_CPUINFO_SET
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
)brace
r_else
(brace
id|thread-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * propagate into thread-state&n;&t; */
id|pfm_copy_pmds
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|pfm_copy_pmcs
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|pmcs_source
op_assign
id|thread-&gt;pmcs
suffix:semicolon
id|pmds_source
op_assign
id|thread-&gt;pmds
suffix:semicolon
multiline_comment|/*&n;&t; * always the case for system-wide&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
r_if
c_cond
(paren
id|is_system
op_eq
l_int|0
)paren
(brace
multiline_comment|/* allow user level control */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;clearing psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|INC_ACTIVATION
c_func
(paren
)paren
suffix:semicolon
id|SET_ACTIVATION
c_func
(paren
id|ctx
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
multiline_comment|/*&n;&t;&t;&t; * push the other task out, if any&n;&t;&t;&t; */
id|owner_task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|owner_task
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner_task
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t; * load all PMD from ctx to PMU (as opposed to thread state)&n;&t;&t; * restore all PMC from ctx to PMU&n;&t;&t; */
id|pfm_restore_pmds
c_func
(paren
id|pmds_source
comma
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|pfm_restore_pmcs
c_func
(paren
id|pmcs_source
comma
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * guaranteed safe by earlier check against DBG_VALID&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf-&gt;num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * set new ownership&n;&t;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context loaded on PMU for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * when not current, task MUST be stopped, so this is safe&n;&t;&t; */
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* force a full reload */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* initial saved psr (stopped) */
id|ctx-&gt;ctx_saved_psr_up
op_assign
l_int|0UL
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|error_unres
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_fl_system
comma
id|the_cpu
)paren
suffix:semicolon
id|error
suffix:colon
multiline_comment|/*&n;&t; * we must undo the dbregs setting (for system-wide)&n;&t; */
r_if
c_cond
(paren
id|ret
op_logical_and
id|set_dbregs
)paren
(brace
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * release task, there is now a link with the context&n;&t; */
r_if
c_cond
(paren
id|is_system
op_eq
l_int|0
op_logical_and
id|task
op_ne
id|current
)paren
(brace
id|pfm_put_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|pfm_check_task_exist
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_UNLOADED
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * in this function, we do not need to increase the use count&n; * for the task via get_task_struct(), because we hold the&n; * context lock. If the task were to disappear while having&n; * a context attached, it would go through pfm_exit_thread()&n; * which also grabs the context lock  and would therefore be blocked&n; * until we are here.&n; */
r_static
r_void
id|pfm_flush_pmds
c_func
(paren
r_struct
id|task_struct
op_star
comma
id|pfm_context_t
op_star
id|ctx
)paren
suffix:semicolon
r_static
r_int
DECL|function|pfm_context_unload
id|pfm_context_unload
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
op_assign
id|PFM_CTX_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_struct
id|pt_regs
op_star
id|tregs
suffix:semicolon
r_int
id|prev_state
comma
id|is_system
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d task [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|prev_state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|is_system
op_assign
id|ctx-&gt;ctx_fl_system
suffix:semicolon
multiline_comment|/*&n;&t; * unload only when necessary&n;&t; */
r_if
c_cond
(paren
id|prev_state
op_eq
id|PFM_CTX_UNLOADED
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx_state=%d, nothing to do&bslash;n&quot;
comma
id|prev_state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear psr and dcr bits&n;&t; */
id|ret
op_assign
id|pfm_stop
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_UNLOADED
suffix:semicolon
multiline_comment|/*&n;&t; * in system mode, we need to update the PMU directly&n;&t; * and the user level state of the caller, which may not&n;&t; * necessarily be the creator of the context.&n;&t; */
r_if
c_cond
(paren
id|is_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * Update cpuinfo&n;&t;&t; *&n;&t;&t; * local PMU is taken care of in pfm_stop()&n;&t;&t; */
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_SYST_WIDE
)paren
suffix:semicolon
id|PFM_CPUINFO_CLEAR
c_func
(paren
id|PFM_CPUINFO_EXCL_IDLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * save PMDs in context&n;&t;&t; * release ownership&n;&t;&t; */
id|pfm_flush_pmds
c_func
(paren
id|current
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * at this point we are done with the PMU&n;&t;&t; * so we can unreserve the resource.&n;&t;&t; */
r_if
c_cond
(paren
id|prev_state
op_ne
id|PFM_CTX_ZOMBIE
)paren
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
l_int|1
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disconnect context from task&n;&t;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disconnect task from context&n;&t;&t; */
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There is nothing more to cleanup here.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * per-task mode&n;&t; */
id|tregs
op_assign
id|task
op_eq
id|current
ques
c_cond
id|regs
suffix:colon
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
multiline_comment|/*&n;&t;&t; * cancel user level control&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;setting psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * save PMDs to context&n;&t; * release ownership&n;&t; */
id|pfm_flush_pmds
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * at this point we are done with the PMU&n;&t; * so we can unreserve the resource.&n;&t; *&n;&t; * when state was ZOMBIE, we have already unreserved.&n;&t; */
r_if
c_cond
(paren
id|prev_state
op_ne
id|PFM_CTX_ZOMBIE
)paren
id|pfm_unreserve_session
c_func
(paren
id|ctx
comma
l_int|0
comma
id|ctx-&gt;ctx_cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset activation counter and psr&n;&t; */
id|ctx-&gt;ctx_last_activation
op_assign
id|PFM_INVALID_ACTIVATION
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * PMU state will not be restored&n;&t; */
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
multiline_comment|/*&n;&t; * break links between context and task&n;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|ctx-&gt;ctx_fl_can_restart
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_going_zombie
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;disconnected [%d] from context&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * called only from exit_thread(): task == current&n; * we come here only if current has a context attached (loaded or masked)&n; */
r_void
DECL|function|pfm_exit_thread
id|pfm_exit_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
r_int
id|ret
comma
id|state
suffix:semicolon
r_int
id|free_ok
op_assign
l_int|0
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;state=%d task [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_state
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|PFM_CTX_UNLOADED
suffix:colon
multiline_comment|/*&n;&t; &t;&t; * only comes to thios function if pfm_context is not NULL, i.e., cannot&n;&t;&t;&t; * be in unloaded state&n;&t; &t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] ctx unloaded&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_CTX_LOADED
suffix:colon
r_case
id|PFM_CTX_MASKED
suffix:colon
id|ret
op_assign
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] state=%d unload failed %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|state
comma
id|ret
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx unloaded for current state was %d&bslash;n&quot;
comma
id|state
)paren
)paren
suffix:semicolon
id|pfm_end_notify_user
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_CTX_ZOMBIE
suffix:colon
id|ret
op_assign
id|pfm_context_unload
c_func
(paren
id|ctx
comma
l_int|NULL
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] state=%d unload failed %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|state
comma
id|ret
)paren
suffix:semicolon
)brace
id|free_ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_exit_thread [%d] unexpected state=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
(brace
id|u64
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_UP
op_or
id|IA64_PSR_PP
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|GET_PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * All memory free operations (especially for vmalloc&squot;ed memory)&n;&t; * MUST be done with interrupts ENABLED.&n;&t; */
r_if
c_cond
(paren
id|free_ok
)paren
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * functions MUST be listed in the increasing order of their index (see permfon.h)&n; */
DECL|macro|PFM_CMD
mdefine_line|#define PFM_CMD(name, flags, arg_count, arg_type, getsz) { name, #name, flags, arg_count, sizeof(arg_type), getsz }
DECL|macro|PFM_CMD_S
mdefine_line|#define PFM_CMD_S(name, flags) { name, #name, flags, 0, 0, NULL }
DECL|macro|PFM_CMD_PCLRWS
mdefine_line|#define PFM_CMD_PCLRWS&t;(PFM_CMD_FD|PFM_CMD_ARG_RW|PFM_CMD_STOP)
DECL|macro|PFM_CMD_PCLRW
mdefine_line|#define PFM_CMD_PCLRW&t;(PFM_CMD_FD|PFM_CMD_ARG_RW)
DECL|macro|PFM_CMD_NONE
mdefine_line|#define PFM_CMD_NONE&t;{ NULL, &quot;no-cmd&quot;, 0, 0, 0, NULL}
DECL|variable|pfm_cmd_tab
r_static
id|pfm_cmd_desc_t
id|pfm_cmd_tab
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|PFM_CMD_COUNT
mdefine_line|#define PFM_CMD_COUNT&t;(sizeof(pfm_cmd_tab)/sizeof(pfm_cmd_desc_t))
r_static
r_int
DECL|function|pfm_check_task_state
id|pfm_check_task_state
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_int
id|state
comma
id|old_state
suffix:semicolon
id|recheck
suffix:colon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context %d no task, state=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context %d state=%d [%d] task_state=%ld must_stop=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_fd
comma
id|state
comma
id|task-&gt;pid
comma
id|task-&gt;state
comma
id|PFM_CMD_STOPPED
c_func
(paren
id|cmd
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * self-monitoring always ok.&n;&t; *&n;&t; * for system-wide the caller can either be the creator of the&n;&t; * context (to one to which the context is attached to) OR&n;&t; * a task running on the same CPU as the session.&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
id|current
op_logical_or
id|ctx-&gt;ctx_fl_system
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * if context is UNLOADED we are safe to go&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_UNLOADED
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * no command can operate on a zombie context&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_ZOMBIE
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cmd %d state zombie cannot operate on context&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * context is LOADED or MASKED. Some commands may need to have &n;&t; * the task stopped.&n;&t; *&n;&t; * We could lift this restriction for UP but it would mean that&n;&t; * the user has no guarantee the task would not run between&n;&t; * two successive calls to perfmonctl(). That&squot;s probably OK.&n;&t; * If this user wants to ensure the task does not run, then&n;&t; * the task must be stopped.&n;&t; */
r_if
c_cond
(paren
id|PFM_CMD_STOPPED
c_func
(paren
id|cmd
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
op_logical_and
(paren
id|task-&gt;state
op_ne
id|TASK_TRACED
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] task not in stopped state&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * task is now stopped, wait for ctxsw out&n;&t;&t; *&n;&t;&t; * This is an interesting point in the code.&n;&t;&t; * We need to unprotect the context because&n;&t;&t; * the pfm_save_regs() routines needs to grab&n;&t;&t; * the same lock. There are danger in doing&n;&t;&t; * this because it leaves a window open for&n;&t;&t; * another task to get access to the context&n;&t;&t; * and possibly change its state. The one thing&n;&t;&t; * that is not possible is for the context to disappear&n;&t;&t; * because we are protected by the VFS layer, i.e.,&n;&t;&t; * get_fd()/put_fd().&n;&t;&t; */
id|old_state
op_assign
id|state
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|wait_task_inactive
c_func
(paren
id|task
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we must recheck to verify if state has changed&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_ne
id|old_state
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;old_state=%d new_state=%d&bslash;n&quot;
comma
id|old_state
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
r_goto
id|recheck
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * system-call entry point (must return long)&n; */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|fd
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0UL
suffix:semicolon
r_void
op_star
id|args_k
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* will expand int return types */
r_int
id|base_sz
comma
id|sz
comma
id|xtra_sz
op_assign
l_int|0
suffix:semicolon
r_int
id|narg
comma
id|completed_args
op_assign
l_int|0
comma
id|call_made
op_assign
l_int|0
comma
id|cmd_flags
suffix:semicolon
r_int
(paren
op_star
id|func
)paren
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_int
(paren
op_star
id|getsize
)paren
(paren
r_void
op_star
id|arg
comma
r_int
op_star
id|sz
)paren
suffix:semicolon
DECL|macro|PFM_MAX_ARGSIZE
mdefine_line|#define PFM_MAX_ARGSIZE&t;4096
multiline_comment|/*&n;&t; * reject any call if perfmon was disabled at initialization&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pmu_conf
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cmd
OL
l_int|0
op_logical_or
id|cmd
op_ge
id|PFM_CMD_COUNT
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|func
op_assign
id|pfm_cmd_tab
(braket
id|cmd
)braket
dot
id|cmd_func
suffix:semicolon
id|narg
op_assign
id|pfm_cmd_tab
(braket
id|cmd
)braket
dot
id|cmd_narg
suffix:semicolon
id|base_sz
op_assign
id|pfm_cmd_tab
(braket
id|cmd
)braket
dot
id|cmd_argsize
suffix:semicolon
id|getsize
op_assign
id|pfm_cmd_tab
(braket
id|cmd
)braket
dot
id|cmd_getsize
suffix:semicolon
id|cmd_flags
op_assign
id|pfm_cmd_tab
(braket
id|cmd
)braket
dot
id|cmd_flags
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|func
op_eq
l_int|NULL
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cmd=%s idx=%d narg=0x%x argsz=%lu count=%d&bslash;n&quot;
comma
id|PFM_CMD_NAME
c_func
(paren
id|cmd
)paren
comma
id|cmd
comma
id|narg
comma
id|base_sz
comma
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if number of arguments matches what the command expects&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|narg
op_eq
id|PFM_CMD_ARG_MANY
op_logical_and
id|count
op_le
l_int|0
)paren
op_logical_or
(paren
id|narg
OG
l_int|0
op_logical_and
id|narg
op_ne
id|count
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|restart_args
suffix:colon
id|sz
op_assign
id|xtra_sz
op_plus
id|base_sz
op_star
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * limit abuse to min page size&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sz
OG
id|PFM_MAX_ARGSIZE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] argument too big %lu&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sz
)paren
suffix:semicolon
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate default-sized argument buffer&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|count
op_logical_and
id|args_k
op_eq
l_int|NULL
)paren
)paren
(brace
id|args_k
op_assign
id|kmalloc
c_func
(paren
id|PFM_MAX_ARGSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args_k
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * copy arguments&n;&t; *&n;&t; * assume sz = 0 for command without parameters&n;&t; */
r_if
c_cond
(paren
id|sz
op_logical_and
id|copy_from_user
c_func
(paren
id|args_k
comma
id|arg
comma
id|sz
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cannot copy_from_user %lu bytes @%p&bslash;n&quot;
comma
id|sz
comma
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if command supports extra parameters&n;&t; */
r_if
c_cond
(paren
id|completed_args
op_eq
l_int|0
op_logical_and
id|getsize
)paren
(brace
multiline_comment|/*&n;&t;&t; * get extra parameters size (based on main argument)&n;&t;&t; */
id|ret
op_assign
(paren
op_star
id|getsize
)paren
(paren
id|args_k
comma
op_amp
id|xtra_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error_args
suffix:semicolon
id|completed_args
op_assign
l_int|1
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;restart_args sz=%lu xtra_sz=%lu&bslash;n&quot;
comma
id|sz
comma
id|xtra_sz
)paren
)paren
suffix:semicolon
multiline_comment|/* retry if necessary */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|xtra_sz
)paren
)paren
r_goto
id|restart_args
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|cmd_flags
op_amp
id|PFM_CMD_FD
)paren
op_eq
l_int|0
)paren
)paren
r_goto
id|skip_fd
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|file
op_eq
l_int|NULL
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;invalid fd %d&bslash;n&quot;
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PFM_IS_FILE
c_func
(paren
id|file
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd %d not related to perfmon&bslash;n&quot;
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
id|ctx
op_assign
(paren
id|pfm_context_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx
op_eq
l_int|NULL
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;no context for fd %d&bslash;n&quot;
comma
id|fd
)paren
)paren
suffix:semicolon
r_goto
id|error_args
suffix:semicolon
)brace
id|prefetch
c_func
(paren
op_amp
id|ctx-&gt;ctx_state
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check task is stopped&n;&t; */
id|ret
op_assign
id|pfm_check_task_state
c_func
(paren
id|ctx
comma
id|cmd
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
r_goto
id|abort_locked
suffix:semicolon
id|skip_fd
suffix:colon
id|ret
op_assign
(paren
op_star
id|func
)paren
(paren
id|ctx
comma
id|args_k
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|call_made
op_assign
l_int|1
suffix:semicolon
id|abort_locked
suffix:colon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context unlocked&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
multiline_comment|/* copy argument back to user, if needed */
r_if
c_cond
(paren
id|call_made
op_logical_and
id|PFM_CMD_RW_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
id|args_k
comma
id|base_sz
op_star
id|count
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|error_args
suffix:colon
r_if
c_cond
(paren
id|args_k
)paren
id|kfree
c_func
(paren
id|args_k
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cmd=%s ret=%ld&bslash;n&quot;
comma
id|PFM_CMD_NAME
c_func
(paren
id|cmd
)paren
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_resume_after_ovfl
id|pfm_resume_after_ovfl
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_regs
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_buffer_fmt_t
op_star
id|fmt
op_assign
id|ctx-&gt;ctx_buf_fmt
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|rst_ctrl
suffix:semicolon
r_int
id|state
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|state
op_assign
id|ctx-&gt;ctx_state
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock sampling buffer and reset index atomically&n;&t; * XXX: not really needed when blocking&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|rst_ctrl.bits.mask_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.bits.reset_ovfl_pmds
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|PFM_CTX_LOADED
)paren
id|ret
op_assign
id|pfm_buf_fmt_restart_active
c_func
(paren
id|fmt
comma
id|current
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|pfm_buf_fmt_restart
c_func
(paren
id|fmt
comma
id|current
comma
op_amp
id|rst_ctrl
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|rst_ctrl.bits.mask_monitoring
op_assign
l_int|0
suffix:semicolon
id|rst_ctrl.bits.reset_ovfl_pmds
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rst_ctrl.bits.reset_ovfl_pmds
)paren
(brace
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|ovfl_regs
comma
id|PFM_PMD_LONG_RESET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rst_ctrl.bits.mask_monitoring
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;resuming monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_MASKED
)paren
id|pfm_restore_monitoring
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;stopping monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|//pfm_stop_monitoring(current, regs);
)brace
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_LOADED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * context MUST BE LOCKED when calling&n; * can only be called for current&n; */
r_static
r_void
DECL|function|pfm_context_force_terminate
id|pfm_context_force_terminate
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_context_force_terminate [%d] is system-wide&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we stop the whole thing, we do no need to flush&n;&t; * we know we WERE masked&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * disconnect the task from the context and vice-versa&n;&t; */
id|current-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|ctx-&gt;ctx_task
op_assign
l_int|NULL
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context terminated&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and wakeup controlling task, indicating we are now disconnected&n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_zombieq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * given that context is still locked, the controlling&n;&t; * task will only get access when we return from&n;&t; * pfm_handle_work().&n;&t; */
)brace
r_static
r_int
id|pfm_ovfl_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_pmds
)paren
suffix:semicolon
r_void
DECL|function|pfm_handle_work
id|pfm_handle_work
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ovfl_regs
suffix:semicolon
r_int
r_int
id|reason
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: [%d] has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|current
comma
l_int|0
)paren
suffix:semicolon
id|pfm_clear_task_notify
c_func
(paren
)paren
suffix:semicolon
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * extract reason for being here and clear&n;&t; */
id|reason
op_assign
id|ctx-&gt;ctx_fl_trap_reason
suffix:semicolon
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_NONE
suffix:semicolon
id|ovfl_regs
op_assign
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;reason=%d state=%d&bslash;n&quot;
comma
id|reason
comma
id|ctx-&gt;ctx_state
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * must be done before we check for simple-reset mode&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_going_zombie
op_logical_or
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_ZOMBIE
)paren
r_goto
id|do_zombie
suffix:semicolon
singleline_comment|//if (CTX_OVFL_NOBLOCK(ctx)) goto skip_blocking;
r_if
c_cond
(paren
id|reason
op_eq
id|PFM_TRAP_REASON_RESET
)paren
r_goto
id|skip_blocking
suffix:semicolon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;before block sleeping&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;after block sleeping ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we need to read the ovfl_regs only after wake-up&n;&t; * because we may have had pfm_write_pmds() in between&n;&t; * and that can changed PMD values and therefore &n;&t; * ovfl_regs is reset for these new PMD values.&n;&t; */
id|ovfl_regs
op_assign
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_going_zombie
)paren
(brace
id|do_zombie
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;context is zombie, bailing out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pfm_context_force_terminate
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
r_goto
id|nothing_to_do
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|nothing_to_do
suffix:semicolon
id|skip_blocking
suffix:colon
id|pfm_resume_after_ovfl
c_func
(paren
id|ctx
comma
id|ovfl_regs
comma
id|regs
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|nothing_to_do
suffix:colon
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_notify_user
id|pfm_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
id|pfm_msg_t
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_ZOMBIE
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ignoring overflow notification, owner is zombie&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;waking up somebody&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_msgq_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * safe, we are not in intr handler, nor in ctxsw when&n;&t; * we come here&n;&t; */
id|kill_fasync
(paren
op_amp
id|ctx-&gt;ctx_async_queue
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_ovfl_notify_user
id|pfm_ovfl_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_pmds
)paren
(brace
id|pfm_msg_t
op_star
id|msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_no_msg
op_eq
l_int|0
)paren
(brace
id|msg
op_assign
id|pfm_get_new_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_ovfl_notify_user no more notification msgs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msg-&gt;pfm_ovfl_msg.msg_type
op_assign
id|PFM_MSG_OVFL
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ctx_fd
op_assign
id|ctx-&gt;ctx_fd
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_active_set
op_assign
l_int|0
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|1
)braket
op_assign
l_int|0UL
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|2
)braket
op_assign
l_int|0UL
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_ovfl_pmds
(braket
l_int|3
)braket
op_assign
l_int|0UL
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_tstamp
op_assign
l_int|0UL
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ovfl msg: msg=%p no_msg=%d fd=%d ovfl_pmds=0x%lx&bslash;n&quot;
comma
id|msg
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
comma
id|ovfl_pmds
)paren
)paren
suffix:semicolon
r_return
id|pfm_notify_user
c_func
(paren
id|ctx
comma
id|msg
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_end_notify_user
id|pfm_end_notify_user
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_msg_t
op_star
id|msg
suffix:semicolon
id|msg
op_assign
id|pfm_get_new_msg
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: pfm_end_notify_user no more notification msgs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* no leak */
id|memset
c_func
(paren
id|msg
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|msg
)paren
)paren
suffix:semicolon
id|msg-&gt;pfm_end_msg.msg_type
op_assign
id|PFM_MSG_END
suffix:semicolon
id|msg-&gt;pfm_end_msg.msg_ctx_fd
op_assign
id|ctx-&gt;ctx_fd
suffix:semicolon
id|msg-&gt;pfm_ovfl_msg.msg_tstamp
op_assign
l_int|0UL
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;end msg: msg=%p no_msg=%d ctx_fd=%d&bslash;n&quot;
comma
id|msg
comma
id|ctx-&gt;ctx_fl_no_msg
comma
id|ctx-&gt;ctx_fd
)paren
)paren
suffix:semicolon
r_return
id|pfm_notify_user
c_func
(paren
id|ctx
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; */
r_static
r_void
DECL|function|pfm_overflow_handler
id|pfm_overflow_handler
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_ovfl_arg_t
op_star
id|ovfl_arg
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|old_val
comma
id|ovfl_val
comma
id|new_val
suffix:semicolon
r_int
r_int
id|ovfl_notify
op_assign
l_int|0UL
comma
id|ovfl_pmds
op_assign
l_int|0UL
comma
id|smpl_pmds
op_assign
l_int|0UL
comma
id|reset_pmds
suffix:semicolon
r_int
r_int
id|tstamp
suffix:semicolon
id|pfm_ovfl_ctrl_t
id|ovfl_ctrl
suffix:semicolon
r_int
r_int
id|i
comma
id|has_smpl
suffix:semicolon
r_int
id|must_notify
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_ZOMBIE
)paren
)paren
r_goto
id|stop_monitoring
suffix:semicolon
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
)paren
r_goto
id|sanity_check
suffix:semicolon
id|tstamp
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|ovfl_val
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
id|has_smpl
op_assign
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d iip=0x%lx, %s &quot;
l_string|&quot;used_pmds=0x%lx&bslash;n&quot;
comma
id|pmc0
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
(paren
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0
)paren
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;nonblocking&quot;
suffix:colon
l_string|&quot;blocking&quot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first we update the virtual counters&n;&t; * assume there was a prior ia64_srlz_d() issued&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip pmd which did not overflow */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that the pmd is not necessarily 0 at this point as qualified events&n;&t;&t; * may have happened before the PMU was frozen. The residual count is not&n;&t;&t; * taken into consideration here but will be with any read of the pmd via&n;&t;&t; * pfm_read_pmds().&n;&t;&t; */
id|old_val
op_assign
id|new_val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|new_val
op_add_assign
l_int|1
op_plus
id|ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|new_val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for overflow condition&n;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|old_val
OG
id|new_val
)paren
)paren
(brace
id|ovfl_pmds
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
id|ovfl_notify
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;ctx_pmd[%d].val=0x%lx old_val=0x%lx pmd=0x%lx ovfl_pmds=0x%lx ovfl_notify=0x%lx&bslash;n&quot;
comma
id|i
comma
id|new_val
comma
id|old_val
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|ovfl_val
comma
id|ovfl_pmds
comma
id|ovfl_notify
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * there was no 64-bit overflow, nothing else to do&n;&t; */
r_if
c_cond
(paren
id|ovfl_pmds
op_eq
l_int|0UL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; * reset all control bits&n;&t; */
id|ovfl_ctrl.val
op_assign
l_int|0
suffix:semicolon
id|reset_pmds
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t; * if a sampling format module exists, then we &quot;cache&quot; the overflow by &n;&t; * calling the module&squot;s handler() routine.&n;&t; */
r_if
c_cond
(paren
id|has_smpl
)paren
(brace
r_int
r_int
id|start_cycles
comma
id|end_cycles
suffix:semicolon
r_int
r_int
id|pmd_mask
suffix:semicolon
r_int
id|j
comma
id|k
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|pmd_mask
op_assign
id|ovfl_pmds
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|ovfl_arg
op_assign
op_amp
id|ctx-&gt;ctx_ovfl_arg
suffix:semicolon
id|prefetch
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|pmd_mask
op_logical_and
id|ret
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
comma
id|pmd_mask
op_rshift_assign
l_int|1
)paren
(brace
id|mask
op_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmd_mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ovfl_arg-&gt;ovfl_pmd
op_assign
(paren
r_int
r_char
)paren
id|i
suffix:semicolon
id|ovfl_arg-&gt;ovfl_notify
op_assign
id|ovfl_notify
op_amp
id|mask
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_arg-&gt;active_set
op_assign
l_int|0
suffix:semicolon
id|ovfl_arg-&gt;ovfl_ctrl.val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* module must fill in all fields */
id|ovfl_arg-&gt;smpl_pmds
(braket
l_int|0
)braket
op_assign
id|smpl_pmds
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|ovfl_arg-&gt;pmd_value
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|ovfl_arg-&gt;pmd_last_reset
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|lval
suffix:semicolon
id|ovfl_arg-&gt;pmd_eventid
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|eventid
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * copy values of pmds of interest. Sampling format may copy them&n;&t;&t; &t; * into sampling buffer.&n;&t;&t; &t; */
r_if
c_cond
(paren
id|smpl_pmds
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|smpl_pmds
suffix:semicolon
id|j
op_increment
comma
id|smpl_pmds
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|smpl_pmds
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ovfl_arg-&gt;smpl_pmds_values
(braket
id|k
op_increment
)braket
op_assign
id|PMD_IS_COUNTING
c_func
(paren
id|j
)paren
ques
c_cond
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|j
)paren
suffix:colon
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;smpl_pmd[%d]=pmd%u=0x%lx&bslash;n&quot;
comma
id|k
op_minus
l_int|1
comma
id|j
comma
id|ovfl_arg-&gt;smpl_pmds_values
(braket
id|k
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_smpl_handler_calls
op_increment
suffix:semicolon
id|start_cycles
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; * call custom buffer format record (handler) routine&n;&t;&t; &t; */
id|ret
op_assign
(paren
op_star
id|ctx-&gt;ctx_buf_fmt-&gt;fmt_handler
)paren
(paren
id|task
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ovfl_arg
comma
id|regs
comma
id|tstamp
)paren
suffix:semicolon
id|end_cycles
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * For those controls, we take the union because they have&n;&t;&t;&t; * an all or nothing behavior.&n;&t;&t;&t; */
id|ovfl_ctrl.bits.notify_user
op_or_assign
id|ovfl_arg-&gt;ovfl_ctrl.bits.notify_user
suffix:semicolon
id|ovfl_ctrl.bits.block_task
op_or_assign
id|ovfl_arg-&gt;ovfl_ctrl.bits.block_task
suffix:semicolon
id|ovfl_ctrl.bits.mask_monitoring
op_or_assign
id|ovfl_arg-&gt;ovfl_ctrl.bits.mask_monitoring
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * build the bitmask of pmds to reset now&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ovfl_arg-&gt;ovfl_ctrl.bits.reset_ovfl_pmds
)paren
id|reset_pmds
op_or_assign
id|mask
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_smpl_handler_cycles
op_add_assign
id|end_cycles
op_minus
id|start_cycles
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * when the module cannot handle the rest of the overflows, we abort right here&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_logical_and
id|pmd_mask
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;handler aborts leftover ovfl_pmds=0x%lx&bslash;n&quot;
comma
id|pmd_mask
op_lshift
id|PMU_FIRST_COUNTER
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * remove the pmds we reset now from the set of pmds to reset in pfm_restart()&n;&t;&t; */
id|ovfl_pmds
op_and_assign
op_complement
id|reset_pmds
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * when no sampling module is used, then the default&n;&t;&t; * is to notify on overflow if requested by user&n;&t;&t; */
id|ovfl_ctrl.bits.notify_user
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_ctrl.bits.block_task
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ovfl_ctrl.bits.mask_monitoring
op_assign
id|ovfl_notify
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* XXX: change for saturation */
id|ovfl_ctrl.bits.reset_ovfl_pmds
op_assign
id|ovfl_notify
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if needed, we reset all overflowed pmds&n;&t;&t; */
r_if
c_cond
(paren
id|ovfl_notify
op_eq
l_int|0
)paren
id|reset_pmds
op_assign
id|ovfl_pmds
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ovfl_pmds=0x%lx reset_pmds=0x%lx&bslash;n&quot;
comma
id|ovfl_pmds
comma
id|reset_pmds
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset the requested PMD registers using the short reset values&n;&t; */
r_if
c_cond
(paren
id|reset_pmds
)paren
(brace
r_int
r_int
id|bm
op_assign
id|reset_pmds
suffix:semicolon
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|bm
comma
id|PFM_PMD_SHORT_RESET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ovfl_notify
op_logical_and
id|ovfl_ctrl.bits.notify_user
)paren
(brace
multiline_comment|/*&n;&t;&t; * keep track of what to reset when unblocking&n;&t;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for blocking context &n;&t;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ovfl_ctrl.bits.block_task
)paren
(brace
id|ctx-&gt;ctx_fl_trap_reason
op_assign
id|PFM_TRAP_REASON_BLOCK
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * set the perfmon specific checking pending work for the task&n;&t;&t;&t; */
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * when coming from ctxsw, current still points to the&n;&t;&t;&t; * previous task, therefore we must work with task and not current.&n;&t;&t;&t; */
id|pfm_set_task_notify
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * defer until state is changed (shorten spin window). the context is locked&n;&t;&t; * anyway, so the signal receiver would come spin for nothing.&n;&t;&t; */
id|must_notify
op_assign
l_int|1
suffix:semicolon
)brace
id|DPRINT_ovfl
c_func
(paren
(paren
l_string|&quot;owner [%d] pending=%ld reason=%u ovfl_pmds=0x%lx ovfl_notify=0x%lx masked=%d&bslash;n&quot;
comma
id|GET_PMU_OWNER
c_func
(paren
)paren
ques
c_cond
id|GET_PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
comma
id|PFM_GET_WORK_PENDING
c_func
(paren
id|task
)paren
comma
id|ctx-&gt;ctx_fl_trap_reason
comma
id|ovfl_pmds
comma
id|ovfl_notify
comma
id|ovfl_ctrl.bits.mask_monitoring
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case monitoring must be stopped, we toggle the psr bits&n;&t; */
r_if
c_cond
(paren
id|ovfl_ctrl.bits.mask_monitoring
)paren
(brace
id|pfm_mask_monitoring
c_func
(paren
id|task
)paren
suffix:semicolon
id|ctx-&gt;ctx_state
op_assign
id|PFM_CTX_MASKED
suffix:semicolon
id|ctx-&gt;ctx_fl_can_restart
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * send notification now&n;&t; */
r_if
c_cond
(paren
id|must_notify
)paren
id|pfm_ovfl_notify_user
c_func
(paren
id|ctx
comma
id|ovfl_notify
)paren
suffix:semicolon
r_return
suffix:semicolon
id|sanity_check
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: CPU%d overflow handler [%d] pmc0=0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|pmc0
)paren
suffix:semicolon
r_return
suffix:semicolon
id|stop_monitoring
suffix:colon
multiline_comment|/*&n;&t; * in SMP, zombie context is never restored but reclaimed in pfm_load_regs().&n;&t; * Moreover, zombies are also reclaimed in pfm_save_regs(). Therefore we can&n;&t; * come here as zombie only if the task is the current task. In which case, we&n;&t; * can access the PMU  hardware directly.&n;&t; *&n;&t; * Note that zombies do have PM_VALID set. So here we do the minimal.&n;&t; *&n;&t; * In case the context was zombified it could not be reclaimed at the time&n;&t; * the monitoring program exited. At this point, the PMU reservation has been&n;&t; * returned, the sampiing buffer has been freed. We must convert this call&n;&t; * into a spurious interrupt. However, we must also avoid infinite overflows&n;&t; * by stopping monitoring for this task. We can only come here for a per-task&n;&t; * context. All we need to do is to stop monitoring using the psr bits which&n;&t; * are always task private. By re-enabling secure montioring, we ensure that&n;&t; * the monitored task will not be able to re-activate monitoring.&n;&t; * The task will eventually be context switched out, at which point the context&n;&t; * will be reclaimed (that includes releasing ownership of the PMU).&n;&t; *&n;&t; * So there might be a window of time where the number of per-task session is zero&n;&t; * yet one PMU might have a owner and get at most one overflow interrupt for a zombie&n;&t; * context. This is safe because if a per-task session comes in, it will push this one&n;&t; * out and by the virtue on pfm_save_regs(), this one will disappear. If a system wide&n;&t; * session is force on that CPU, given that we use task pinning, pfm_save_regs() will&n;&t; * also push our zombie context out.&n;&t; *&n;&t; * Overall pretty hairy stuff....&n;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ctx is zombie for [%d], converted to spurious&bslash;n&quot;
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_do_interrupt_handler
id|pfm_do_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|pmc0
suffix:semicolon
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * srlz.d done before arriving here&n;&t; */
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PMC0.bit[63-1] is set, then PMC0.fr = 1&n;&t; */
r_if
c_cond
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|pmc0
)paren
op_logical_and
id|task
)paren
(brace
multiline_comment|/*&n;&t;&t; * we assume that pmc0.fr is always set here&n;&t;&t; */
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|report_spurious1
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
op_logical_and
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
r_goto
id|report_spurious2
suffix:semicolon
id|PROTECT_CTX_NOPRINT
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|ctx
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
id|UNPROTECT_CTX_NOPRINT
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_spurious_ovfl_intr_count
op_increment
suffix:semicolon
id|retval
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * keep it unfrozen at all times&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|report_spurious1
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: spurious overflow interrupt on CPU%d: process %d has no PFM context&bslash;n&quot;
comma
id|this_cpu
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|report_spurious2
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: spurious overflow interrupt on CPU%d: process %d, invalid flag&bslash;n&quot;
comma
id|this_cpu
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
id|irqreturn_t
DECL|function|pfm_interrupt_handler
id|pfm_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|start_cycles
comma
id|total_cycles
suffix:semicolon
r_int
r_int
id|min
comma
id|max
suffix:semicolon
r_int
id|this_cpu
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|this_cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|min
op_assign
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_min
suffix:semicolon
id|max
op_assign
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_max
suffix:semicolon
id|start_cycles
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_do_interrupt_handler
c_func
(paren
id|irq
comma
id|arg
comma
id|regs
)paren
suffix:semicolon
id|total_cycles
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t measure spurious interrupts&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ret
op_eq
l_int|0
)paren
)paren
(brace
id|total_cycles
op_sub_assign
id|start_cycles
suffix:semicolon
r_if
c_cond
(paren
id|total_cycles
OL
id|min
)paren
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
id|total_cycles
suffix:semicolon
r_if
c_cond
(paren
id|total_cycles
OG
id|max
)paren
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles_max
op_assign
id|total_cycles
suffix:semicolon
id|pfm_stats
(braket
id|this_cpu
)braket
dot
id|pfm_ovfl_intr_cycles
op_add_assign
id|total_cycles
suffix:semicolon
)brace
id|put_cpu_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * /proc/perfmon interface, for debug only&n; */
DECL|macro|PFM_PROC_SHOW_HEADER
mdefine_line|#define PFM_PROC_SHOW_HEADER&t;((void *)NR_CPUS+1)
r_static
r_void
op_star
DECL|function|pfm_proc_start
id|pfm_proc_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_if
c_cond
(paren
op_star
id|pos
op_eq
l_int|0
)paren
(brace
r_return
id|PFM_PROC_SHOW_HEADER
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|pos
op_le
id|NR_CPUS
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
op_star
id|pos
op_minus
l_int|1
)paren
)paren
(brace
r_return
(paren
r_void
op_star
)paren
op_star
id|pos
suffix:semicolon
)brace
op_increment
op_star
id|pos
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|pfm_proc_next
id|pfm_proc_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|pfm_proc_start
c_func
(paren
id|m
comma
id|pos
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_proc_stop
id|pfm_proc_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
)brace
r_static
r_void
DECL|function|pfm_proc_show_header
id|pfm_proc_show_header
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|pfm_buffer_fmt_t
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;perfmon version           : %u.%u&bslash;n&quot;
l_string|&quot;model                     : %s&bslash;n&quot;
l_string|&quot;fastctxsw                 : %s&bslash;n&quot;
l_string|&quot;expert mode               : %s&bslash;n&quot;
l_string|&quot;ovfl_mask                 : 0x%lx&bslash;n&quot;
l_string|&quot;PMU flags                 : 0x%x&bslash;n&quot;
comma
id|PFM_VERSION_MAJ
comma
id|PFM_VERSION_MIN
comma
id|pmu_conf-&gt;pmu_name
comma
id|pfm_sysctl.fastctxsw
OG
l_int|0
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
comma
id|pfm_sysctl.expert_mode
OG
l_int|0
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
comma
id|pmu_conf-&gt;ovfl_val
comma
id|pmu_conf-&gt;flags
)paren
suffix:semicolon
id|LOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;proc_sessions             : %u&bslash;n&quot;
l_string|&quot;sys_sessions              : %u&bslash;n&quot;
l_string|&quot;sys_use_dbregs            : %u&bslash;n&quot;
l_string|&quot;ptrace_use_dbregs         : %u&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|pfm_buffer_fmt_list
)paren
(brace
id|entry
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|pfm_buffer_fmt_t
comma
id|fmt_list
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;format                    : %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x %s&bslash;n&quot;
comma
id|entry-&gt;fmt_uuid
(braket
l_int|0
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|1
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|2
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|3
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|4
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|5
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|6
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|7
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|8
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|9
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|10
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|11
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|12
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|13
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|14
)braket
comma
id|entry-&gt;fmt_uuid
(braket
l_int|15
)braket
comma
id|entry-&gt;fmt_name
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_proc_show
id|pfm_proc_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|psr
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|PFM_PROC_SHOW_HEADER
)paren
(brace
id|pfm_proc_show_header
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* show info for CPU (v - 1) */
id|cpu
op_assign
(paren
r_int
)paren
id|v
op_minus
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;CPU%-2d overflow intrs      : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d overflow cycles     : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d overflow min        : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d overflow max        : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d smpl handler calls  : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d smpl handler cycles : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d spurious intrs      : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d replay   intrs      : %lu&bslash;n&quot;
l_string|&quot;CPU%-2d syst_wide           : %d&bslash;n&quot;
l_string|&quot;CPU%-2d dcr_pp              : %d&bslash;n&quot;
l_string|&quot;CPU%-2d exclude idle        : %d&bslash;n&quot;
l_string|&quot;CPU%-2d owner               : %d&bslash;n&quot;
l_string|&quot;CPU%-2d context             : %p&bslash;n&quot;
l_string|&quot;CPU%-2d activations         : %lu&bslash;n&quot;
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_ovfl_intr_count
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_ovfl_intr_cycles
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_ovfl_intr_cycles_min
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_ovfl_intr_cycles_max
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_smpl_handler_calls
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_smpl_handler_cycles
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_spurious_ovfl_intr_count
comma
id|cpu
comma
id|pfm_stats
(braket
id|cpu
)braket
dot
id|pfm_replay_ovfl_intr_count
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|cpu
)paren
op_amp
id|PFM_CPUINFO_SYST_WIDE
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|cpu
)paren
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pfm_syst_info
comma
id|cpu
)paren
op_amp
id|PFM_CPUINFO_EXCL_IDLE
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_owner
comma
id|cpu
)paren
ques
c_cond
id|pfm_get_cpu_data
c_func
(paren
id|pmu_owner
comma
id|cpu
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_ctx
comma
id|cpu
)paren
comma
id|cpu
comma
id|pfm_get_cpu_data
c_func
(paren
id|pmu_activation_number
comma
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
op_eq
l_int|1
op_logical_and
id|pfm_sysctl.debug
OG
l_int|0
)paren
(brace
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;CPU%-2d psr                 : 0x%lx&bslash;n&quot;
l_string|&quot;CPU%-2d pmc0                : 0x%lx&bslash;n&quot;
comma
id|cpu
comma
id|psr
comma
id|cpu
comma
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_COUNTING
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;CPU%-2d pmc%u                : 0x%lx&bslash;n&quot;
l_string|&quot;CPU%-2d pmd%u                : 0x%lx&bslash;n&quot;
comma
id|cpu
comma
id|i
comma
id|ia64_get_pmc
c_func
(paren
id|i
)paren
comma
id|cpu
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfm_seq_ops
r_struct
id|seq_operations
id|pfm_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|pfm_proc_start
comma
dot
id|next
op_assign
id|pfm_proc_next
comma
dot
id|stop
op_assign
id|pfm_proc_stop
comma
dot
id|show
op_assign
id|pfm_proc_show
)brace
suffix:semicolon
r_static
r_int
DECL|function|pfm_proc_open
id|pfm_proc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|pfm_seq_ops
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * we come here as soon as local_cpu_data-&gt;pfm_syst_wide is set. this happens&n; * during pfm_enable() hence before pfm_start(). We cannot assume monitoring&n; * is active or inactive based on mode. We must rely on the value in&n; * local_cpu_data-&gt;pfm_syst_info&n; */
r_void
DECL|function|pfm_syst_wide_update_task
id|pfm_syst_wide_update_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|info
comma
r_int
id|is_ctxswin
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|dcr
suffix:semicolon
r_int
r_int
id|dcr_pp
suffix:semicolon
id|dcr_pp
op_assign
id|info
op_amp
id|PFM_CPUINFO_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * pid 0 is guaranteed to be the idle task. There is one such task with pid 0&n;&t; * on every CPU, so we can rely on the pid to identify the idle task.&n;&t; */
r_if
c_cond
(paren
(paren
id|info
op_amp
id|PFM_CPUINFO_EXCL_IDLE
)paren
op_eq
l_int|0
op_logical_or
id|task-&gt;pid
)paren
(brace
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|is_ctxswin
ques
c_cond
id|dcr_pp
suffix:colon
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if monitoring has started&n;&t; */
r_if
c_cond
(paren
id|dcr_pp
)paren
(brace
id|dcr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * context switching in?&n;&t;&t; */
r_if
c_cond
(paren
id|is_ctxswin
)paren
(brace
multiline_comment|/* mask monitoring for the idle task */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|dcr
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * context switching out&n;&t;&t; * restore monitoring for next task&n;&t;&t; *&n;&t;&t; * Due to inlining this odd if-then-else construction generates&n;&t;&t; * better code.&n;&t;&t; */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_DCR
comma
id|dcr
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|pfm_set_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
r_static
r_void
DECL|function|pfm_force_cleanup
id|pfm_force_cleanup
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|task
op_assign
id|ctx-&gt;ctx_task
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cleared ownership for [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_task-&gt;pid
)paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disconnect the task from the context and vice-versa&n;&t; */
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;force cleanup for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * in 2.6, interrupts are masked when we come here and the runqueue lock is held&n; */
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n; &t; * we always come here with interrupts ALREADY disabled by&n; &t; * the scheduler. So we simply need to protect against concurrent&n;&t; * access, not CPU concurrency.&n;&t; */
id|flags
op_assign
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_ZOMBIE
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
id|pfm_force_cleanup
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity check&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_last_activation
op_ne
id|GET_ACTIVATION
c_func
(paren
)paren
)paren
(brace
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_I
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which may generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep a copy of psr.up (for reload)&n;&t; */
id|ctx-&gt;ctx_saved_psr_up
op_assign
id|psr
op_amp
id|IA64_PSR_UP
suffix:semicolon
multiline_comment|/*&n;&t; * release ownership of this PMU.&n;&t; * PM interrupts are masked, so nothing&n;&t; * can happen.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we systematically save the PMD as we have no&n;&t; * guarantee we will be schedule at that same&n;&t; * CPU again.&n;&t; */
id|pfm_save_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save pmc0 ia64_srlz_d() done in pfm_save_pmds()&n;&t; * we will need it on the restore path to check&n;&t; * for pending overflow.&n;&t; */
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * unfreeze PMU if had pending overflows&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1UL
)paren
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * finally, allow context access.&n;&t; * interrupts will still be masked after this call.&n;&t; */
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_SMP */
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_I
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which may generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * keep a copy of psr.up (for reload)&n;&t; */
id|ctx-&gt;ctx_saved_psr_up
op_assign
id|psr
op_amp
id|IA64_PSR_UP
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_lazy_save_regs
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
(brace
id|u64
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
id|IA64_PSR_UP
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * we need to mask PMU overflow here to&n;&t; * make sure that we maintain pmc0 until&n;&t; * we save it. overflow interrupts are&n;&t; * treated as spurious if there is no&n;&t; * owner.&n;&t; *&n;&t; * XXX: I don&squot;t think this is necessary&n;&t; */
id|PROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * release ownership of this PMU.&n;&t; * must be done before we save the registers.&n;&t; *&n;&t; * after this call any PMU interrupt is treated&n;&t; * as spurious.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save all the pmds we use&n;&t; */
id|pfm_save_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * save pmc0 ia64_srlz_d() done in pfm_save_pmds()&n;&t; * it is needed to check for pended overflow&n;&t; * on the restore path&n;&t; */
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * unfreeze PMU if had pending overflows&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1UL
)paren
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now get can unmask PMU interrupts, they will&n;&t; * be treated as purely spurious and we will not&n;&t; * lose any information&n;&t; */
id|UNPROTECT_CTX
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * in 2.6, interrupts are masked when we come here and the runqueue lock is held&n; */
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|pmc_mask
op_assign
l_int|0UL
comma
id|pmd_mask
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u64
id|psr
comma
id|psr_up
suffix:semicolon
r_int
id|need_irq_resend
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
id|BUG_ON
c_func
(paren
id|GET_PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * possible on unload&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|t-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; &t; * we always come here with interrupts ALREADY disabled by&n; &t; * the scheduler. So we simply need to protect against concurrent&n;&t; * access, not CPU concurrency.&n;&t; */
id|flags
op_assign
id|pfm_protect_ctx_ctxsw
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|need_irq_resend
op_assign
id|pmu_conf-&gt;flags
op_amp
id|PFM_PMU_IRQ_RESEND
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_UP
op_or
id|IA64_PSR_PP
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;ctx_state
op_eq
id|PFM_CTX_ZOMBIE
)paren
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|task
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ctx-&gt;ctx_smpl_hdr
)paren
suffix:semicolon
id|pfm_force_cleanup
c_func
(paren
id|ctx
comma
id|regs
)paren
suffix:semicolon
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this one (kmalloc&squot;ed) is fine with interrupts disabled&n;&t;&t; */
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we restore ALL the debug registers to avoid picking up&n;&t; * stale state.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf-&gt;num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * retrieve saved psr.up&n;&t; */
id|psr_up
op_assign
id|ctx-&gt;ctx_saved_psr_up
suffix:semicolon
multiline_comment|/*&n;&t; * if we were the last user of the PMU on that CPU,&n;&t; * then nothing to do except restore psr&n;&t; */
r_if
c_cond
(paren
id|GET_LAST_CPU
c_func
(paren
id|ctx
)paren
op_eq
id|smp_processor_id
c_func
(paren
)paren
op_logical_and
id|ctx-&gt;ctx_last_activation
op_eq
id|GET_ACTIVATION
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * retrieve partial reload masks (due to user modifications)&n;&t;&t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
suffix:semicolon
id|pmd_mask
op_assign
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t; &t; * To avoid leaking information to the user level when psr.sp=0,&n;&t; &t; * we must reload ALL implemented pmds (even the ones we don&squot;t use).&n;&t; &t; * In the kernel we only allow PFM_READ_PMDS on registers which&n;&t; &t; * we initialized or requested (sampling) so there is no risk there.&n;&t; &t; */
id|pmd_mask
op_assign
id|pfm_sysctl.fastctxsw
ques
c_cond
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:colon
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; &t; * ALL accessible PMCs are systematically reloaded, unused registers&n;&t; &t; * get their default (from pfm_reset_pmu_state()) values to avoid picking&n;&t; &t; * up stale configuration.&n;&t; &t; *&n;&t; &t; * PMC0 is never in the mask. It is always restored separately.&n;&t; &t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * when context is MASKED, we will restore PMC with plm=0&n;&t; * and PMD with stale information, but that&squot;s ok, nothing&n;&t; * will be captured.&n;&t; *&n;&t; * XXX: optimize here&n;&t; */
r_if
c_cond
(paren
id|pmd_mask
)paren
id|pfm_restore_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|pmd_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmc_mask
)paren
id|pfm_restore_pmcs
c_func
(paren
id|t-&gt;pmcs
comma
id|pmc_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for pending overflow at the time the state&n;&t; * was saved.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * reload pmc0 with the overflow information&n;&t;&t; * On McKinley PMU, this will trigger a PMU interrupt&n;&t;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * will replay the PMU interrupt&n;&t;&t; */
r_if
c_cond
(paren
id|need_irq_resend
)paren
id|hw_resend_irq
c_func
(paren
l_int|NULL
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|pfm_stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|pfm_replay_ovfl_intr_count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we just did a reload, so we reset the partial reload fields&n;&t; */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_reload_pmds
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|SET_LAST_CPU
c_func
(paren
id|ctx
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dump activation value for this PMU&n;&t; */
id|INC_ACTIVATION
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * record current activation for this context&n;&t; */
id|SET_ACTIVATION
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * establish new ownership. &n;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr.up bit. measurement&n;&t; * is active again.&n;&t; * no PMU interrupt can happen at this point&n;&t; * because we still have interrupts disabled.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|psr_up
)paren
)paren
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allow concurrent access to context&n;&t; */
id|pfm_unprotect_ctx_ctxsw
c_func
(paren
id|ctx
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else /*  !CONFIG_SMP */
multiline_comment|/*&n; * reload PMU state for UP kernels&n; * in 2.5 we come here with interrupts disabled&n; */
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|pmd_mask
comma
id|pmc_mask
suffix:semicolon
id|u64
id|psr
comma
id|psr_up
suffix:semicolon
r_int
id|need_irq_resend
suffix:semicolon
id|owner
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|PFM_GET_CTX
c_func
(paren
id|task
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
(paren
id|IA64_PSR_UP
op_or
id|IA64_PSR_PP
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|psr
op_amp
id|IA64_PSR_I
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we restore ALL the debug registers to avoid picking up&n;&t; * stale state.&n;&t; *&n;&t; * This must be done even when the task is still the owner&n;&t; * as the registers may have been modified via ptrace()&n;&t; * (not perfmon) by the previous task.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
id|pfm_restore_ibrs
c_func
(paren
id|ctx-&gt;ctx_ibrs
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pfm_restore_dbrs
c_func
(paren
id|ctx-&gt;ctx_dbrs
comma
id|pmu_conf-&gt;num_dbrs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * retrieved saved psr.up&n;&t; */
id|psr_up
op_assign
id|ctx-&gt;ctx_saved_psr_up
suffix:semicolon
id|need_irq_resend
op_assign
id|pmu_conf-&gt;flags
op_amp
id|PFM_PMU_IRQ_RESEND
suffix:semicolon
multiline_comment|/*&n;&t; * short path, our state is still there, just&n;&t; * need to restore psr and we go&n;&t; *&n;&t; * we do not touch either PMC nor PMD. the psr is not touched&n;&t; * by the overflow_handler. So we are safe w.r.t. to interrupt&n;&t; * concurrency even without interrupt masking.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|owner
op_eq
id|task
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|psr_up
)paren
)paren
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * someone else is still using the PMU, first push it out and&n;&t; * then we&squot;ll be able to install our stuff !&n;&t; *&n;&t; * Upon return, there will be no owner for the current PMU&n;&t; */
r_if
c_cond
(paren
id|owner
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid leaking information to the user level when psr.sp=0,&n;&t; * we must reload ALL implemented pmds (even the ones we don&squot;t use).&n;&t; * In the kernel we only allow PFM_READ_PMDS on registers which&n;&t; * we initialized or requested (sampling) so there is no risk there.&n;&t; */
id|pmd_mask
op_assign
id|pfm_sysctl.fastctxsw
ques
c_cond
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:colon
id|ctx-&gt;ctx_all_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * ALL accessible PMCs are systematically reloaded, unused registers&n;&t; * get their default (from pfm_reset_pmu_state()) values to avoid picking&n;&t; * up stale configuration.&n;&t; *&n;&t; * PMC0 is never in the mask. It is always restored separately&n;&t; */
id|pmc_mask
op_assign
id|ctx-&gt;ctx_all_pmcs
(braket
l_int|0
)braket
suffix:semicolon
id|pfm_restore_pmds
c_func
(paren
id|t-&gt;pmds
comma
id|pmd_mask
)paren
suffix:semicolon
id|pfm_restore_pmcs
c_func
(paren
id|t-&gt;pmcs
comma
id|pmc_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for pending overflow at the time the state&n;&t; * was saved.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PMC0_HAS_OVFL
c_func
(paren
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * reload pmc0 with the overflow information&n;&t;&t; * On McKinley PMU, this will trigger a PMU interrupt&n;&t;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
id|t-&gt;pmcs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;pmcs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * will replay the PMU interrupt&n;&t;&t; */
r_if
c_cond
(paren
id|need_irq_resend
)paren
id|hw_resend_irq
c_func
(paren
l_int|NULL
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|pfm_stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|pfm_replay_ovfl_intr_count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * establish new ownership. &n;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|task
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr.up bit. measurement&n;&t; * is active again.&n;&t; * no PMU interrupt can happen at this point&n;&t; * because we still have interrupts disabled.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|psr_up
)paren
)paren
id|pfm_set_psr_up
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * this function assumes monitoring is stopped&n; */
r_static
r_void
DECL|function|pfm_flush_pmds
id|pfm_flush_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_int
r_int
id|mask2
comma
id|val
comma
id|pmd_val
comma
id|ovfl_val
suffix:semicolon
r_int
id|i
comma
id|can_access_pmu
op_assign
l_int|0
suffix:semicolon
r_int
id|is_self
suffix:semicolon
multiline_comment|/*&n;&t; * is the caller the task being monitored (or which initiated the&n;&t; * session for system wide measurements)&n;&t; */
id|is_self
op_assign
id|ctx-&gt;ctx_task
op_eq
id|task
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * can access PMU is task is the owner of the PMU state on the current CPU&n;&t; * or if we are running on the CPU bound to the context in system-wide mode&n;&t; * (that is not necessarily the task the context is attached to in this mode).&n;&t; * In system-wide we always have can_access_pmu true because a task running on an&n;&t; * invalid processor is flagged earlier in the call stack (see pfm_stop).&n;&t; */
id|can_access_pmu
op_assign
(paren
id|GET_PMU_OWNER
c_func
(paren
)paren
op_eq
id|task
)paren
op_logical_or
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|ctx-&gt;ctx_cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_access_pmu
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mark the PMU as not owned&n;&t;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t;&t; * interrupt was in-flight&n;&t;&t; * This also guarantees that pmc0 will contain the final state&n;&t;&t; * It virtually gives us full control on overflow processing from that point&n;&t;&t; * on.&n;&t;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;releasing ownership&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read current overflow status:&n;&t;&t; *&n;&t;&t; * we are guaranteed to read the final stable state&n;&t;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t;&t; * reset freeze bit, overflow status information destroyed&n;&t;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pmc0
op_assign
id|task-&gt;thread.pmcs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * clear whatever overflow status bits there were&n;&t;&t; */
id|task-&gt;thread.pmcs
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|ovfl_val
op_assign
id|pmu_conf-&gt;ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * we save all the used pmds&n;&t; * we take care of overflows for counting PMDs&n;&t; *&n;&t; * XXX: sampling situation is not taken into account here&n;&t; */
id|mask2
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask2
suffix:semicolon
id|i
op_increment
comma
id|mask2
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask2
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * can access PMU always true in system wide mode&n;&t;&t; */
id|val
op_assign
id|pmd_val
op_assign
id|can_access_pmu
ques
c_cond
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:colon
id|task-&gt;thread.pmds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] ctx_pmd=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we rebuild the full 64 bit value of the counter&n;&t;&t;&t; */
id|val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|val
op_amp
id|ovfl_val
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now everything is in ctx_pmds[] and we need&n;&t;&t;&t; * to clear the saved context from save_regs() such that&n;&t;&t;&t; * pfm_read_pmds() gets the correct value&n;&t;&t;&t; */
id|pmd_val
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * take care of overflow inline&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pmc0
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|val
op_add_assign
l_int|1
op_plus
id|ovfl_val
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] overflowed&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;[%d] is_self=%d ctx_pmd[%d]=0x%lx  pmd_val=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|is_self
comma
id|i
comma
id|val
comma
id|pmd_val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_self
)paren
id|task-&gt;thread.pmds
(braket
id|i
)braket
op_assign
id|pmd_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
suffix:semicolon
)brace
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|pfm_interrupt_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * perfmon initialization routine, called from the initcall() table&n; */
r_static
r_int
id|init_pfm_fs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|pfm_probe_pmu
id|pfm_probe_pmu
c_func
(paren
r_void
)paren
(brace
id|pmu_config_t
op_star
op_star
id|p
suffix:semicolon
r_int
id|family
suffix:semicolon
id|family
op_assign
id|local_cpu_data-&gt;family
suffix:semicolon
id|p
op_assign
id|pmu_confs
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|probe
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|probe
c_func
(paren
)paren
op_eq
l_int|0
)paren
r_goto
id|found
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|pmu_family
op_eq
id|family
op_logical_or
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|pmu_family
op_eq
l_int|0xff
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
id|pmu_conf
op_assign
op_star
id|p
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfm_proc_fops
r_static
r_struct
id|file_operations
id|pfm_proc_fops
op_assign
(brace
dot
id|open
op_assign
id|pfm_proc_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
r_int
id|__init
DECL|function|pfm_init
id|pfm_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|n
comma
id|n_counters
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: version %u.%u IRQ %u&bslash;n&quot;
comma
id|PFM_VERSION_MAJ
comma
id|PFM_VERSION_MIN
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_probe_pmu
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: disabled, there is no support for processor family %d&bslash;n&quot;
comma
id|local_cpu_data-&gt;family
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * compute the number of implemented PMD/PMC from the&n;&t; * description tables&n;&t; */
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf-&gt;impl_pmcs
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
id|pmu_conf-&gt;num_pmcs
op_assign
id|n
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|n_counters
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pmu_conf-&gt;impl_pmds
(braket
id|i
op_rshift
l_int|6
)braket
op_or_assign
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|63
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
id|n_counters
op_increment
suffix:semicolon
)brace
id|pmu_conf-&gt;num_pmds
op_assign
id|n
suffix:semicolon
id|pmu_conf-&gt;num_counters
op_assign
id|n_counters
suffix:semicolon
multiline_comment|/*&n;&t; * sanity checks on the number of debug registers&n;&t; */
r_if
c_cond
(paren
id|pmu_conf-&gt;use_rr_dbregs
)paren
(brace
r_if
c_cond
(paren
id|pmu_conf-&gt;num_ibrs
OG
id|IA64_NUM_DBG_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: unsupported number of code debug registers (%u)&bslash;n&quot;
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pmu_conf
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmu_conf-&gt;num_dbrs
OG
id|IA64_NUM_DBG_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;perfmon: unsupported number of data debug registers (%u)&bslash;n&quot;
comma
id|pmu_conf-&gt;num_ibrs
)paren
suffix:semicolon
id|pmu_conf
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;perfmon: %s PMU detected, %u PMCs, %u PMDs, %u counters (%lu bits)&bslash;n&quot;
comma
id|pmu_conf-&gt;pmu_name
comma
id|pmu_conf-&gt;num_pmcs
comma
id|pmu_conf-&gt;num_pmds
comma
id|pmu_conf-&gt;num_counters
comma
id|ffz
c_func
(paren
id|pmu_conf-&gt;ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf-&gt;num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf-&gt;num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: not enough pmc/pmd, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
id|pmu_conf
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * create /proc/perfmon (mostly for debugging purposes)&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;perfmon&quot;
comma
id|S_IRUGO
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perfmon_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: cannot create /proc entry, perfmon disabled&bslash;n&quot;
)paren
suffix:semicolon
id|pmu_conf
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * install customized file operations for /proc/perfmon entry&n; &t; */
id|perfmon_dir-&gt;proc_fops
op_assign
op_amp
id|pfm_proc_fops
suffix:semicolon
multiline_comment|/*&n;&t; * create /proc/sys/kernel/perfmon (for debugging purposes)&n;&t; */
id|pfm_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|pfm_sysctl_root
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize all our spinlocks&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_sessions.pfs_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_buffer_fmt_lock
)paren
suffix:semicolon
id|init_pfm_fs
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pfm_stats
(braket
id|i
)braket
dot
id|pfm_ovfl_intr_cycles_min
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfm_init
id|__initcall
c_func
(paren
id|pfm_init
)paren
suffix:semicolon
multiline_comment|/*&n; * this function is called before pfm_init()&n; */
r_void
DECL|function|pfm_init_percpu
id|pfm_init_percpu
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * make sure no measurement is active&n;&t; * (may inherit programmed PMCs from EFI).&n;&t; */
id|pfm_clear_psr_pp
c_func
(paren
)paren
suffix:semicolon
id|pfm_clear_psr_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we run with the PMU not frozen at all times&n;&t; */
id|pfm_unfreeze_pmu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_eq
l_int|0
)paren
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_PMV
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used for debug purposes only&n; */
r_void
DECL|function|dump_pmu_state
id|dump_pmu_state
c_func
(paren
r_const
r_char
op_star
id|from
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|psr
comma
id|dcr
comma
id|info
comma
id|flags
suffix:semicolon
r_int
id|i
comma
id|this_cpu
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|regs
op_assign
id|ia64_task_regs
c_func
(paren
id|current
)paren
suffix:semicolon
id|info
op_assign
id|PFM_CPUINFO_GET
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_DCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|0
op_logical_and
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_eq
l_int|0
op_logical_and
(paren
id|dcr
op_amp
id|IA64_DCR_PP
)paren
op_eq
l_int|0
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU%d from %s() current [%d] iip=0x%lx %s&bslash;n&quot;
comma
id|this_cpu
comma
id|from
comma
id|current-&gt;pid
comma
id|regs-&gt;cr_iip
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|task
op_assign
id|GET_PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|GET_PMU_CTX
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-&gt;CPU%d owner [%d] ctx=%p&bslash;n&quot;
comma
id|this_cpu
comma
id|task
ques
c_cond
id|task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|ctx
)paren
suffix:semicolon
id|psr
op_assign
id|pfm_get_psr
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-&gt;CPU%d pmc0=0x%lx psr.pp=%d psr.up=%d dcr.pp=%d syst_info=0x%lx user_psr.up=%d user_psr.pp=%d&bslash;n&quot;
comma
id|this_cpu
comma
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
comma
id|psr
op_amp
id|IA64_PSR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|psr
op_amp
id|IA64_PSR_UP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|dcr
op_amp
id|IA64_DCR_PP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|info
comma
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
comma
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMC_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMC_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-&gt;CPU%d pmc[%d]=0x%lx thread_pmc[%d]=0x%lx&bslash;n&quot;
comma
id|this_cpu
comma
id|i
comma
id|ia64_get_pmc
c_func
(paren
id|i
)paren
comma
id|i
comma
id|t-&gt;pmcs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|PMD_IS_LAST
c_func
(paren
id|i
)paren
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-&gt;CPU%d pmd[%d]=0x%lx thread_pmd[%d]=0x%lx&bslash;n&quot;
comma
id|this_cpu
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
comma
id|i
comma
id|t-&gt;pmds
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-&gt;CPU%d ctx_state=%d vaddr=%p addr=%p fd=%d ctx_task=[%d] saved_psr_up=0x%lx&bslash;n&quot;
comma
id|this_cpu
comma
id|ctx-&gt;ctx_state
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|ctx-&gt;ctx_smpl_hdr
comma
id|ctx-&gt;ctx_msgq_head
comma
id|ctx-&gt;ctx_msgq_tail
comma
id|ctx-&gt;ctx_saved_psr_up
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called from process.c:copy_thread(). task is new child.&n; */
r_void
DECL|function|pfm_inherit
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;perfmon: pfm_inherit clearing state for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * cut links inherited from parent (current)&n;&t; */
id|thread-&gt;pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|PFM_SET_WORK_PENDING
c_func
(paren
id|task
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the psr bits are already set properly in copy_threads()&n;&t; */
)brace
macro_line|#else  /* !CONFIG_PERFMON */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|fd
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PERFMON */
eof
