multiline_comment|/*&n; * This file contains the code to configure and read/write the ia64 performance&n; * monitoring stuff.&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; * Modifications by Stephane Eranian, Hewlett-Packard Co.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; * Copyright (C) 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; * Copyright (C) 2000-2001 Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/efi.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt; /* for ia64_get_itc() */
macro_line|#ifdef CONFIG_PERFMON
DECL|macro|PFM_VERSION
mdefine_line|#define PFM_VERSION&t;&t;&quot;0.3&quot;
DECL|macro|PFM_SMPL_HDR_VERSION
mdefine_line|#define PFM_SMPL_HDR_VERSION&t;1
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4&t;/* first generic counter */
DECL|macro|PFM_WRITE_PMCS
mdefine_line|#define PFM_WRITE_PMCS&t;&t;0xa0
DECL|macro|PFM_WRITE_PMDS
mdefine_line|#define PFM_WRITE_PMDS&t;&t;0xa1
DECL|macro|PFM_READ_PMDS
mdefine_line|#define PFM_READ_PMDS&t;&t;0xa2
DECL|macro|PFM_STOP
mdefine_line|#define PFM_STOP&t;&t;0xa3
DECL|macro|PFM_START
mdefine_line|#define PFM_START&t;&t;0xa4
DECL|macro|PFM_ENABLE
mdefine_line|#define PFM_ENABLE&t;&t;0xa5&t;/* unfreeze only */
DECL|macro|PFM_DISABLE
mdefine_line|#define PFM_DISABLE&t;&t;0xa6&t;/* freeze only */
DECL|macro|PFM_RESTART
mdefine_line|#define PFM_RESTART&t;&t;0xcf
DECL|macro|PFM_CREATE_CONTEXT
mdefine_line|#define PFM_CREATE_CONTEXT&t;0xa7
DECL|macro|PFM_DESTROY_CONTEXT
mdefine_line|#define PFM_DESTROY_CONTEXT&t;0xa8
multiline_comment|/*&n; * Those 2 are just meant for debugging. I considered using sysctl() for&n; * that but it is a little bit too pervasive. This solution is at least&n; * self-contained.&n; */
DECL|macro|PFM_DEBUG_ON
mdefine_line|#define PFM_DEBUG_ON&t;&t;0xe0
DECL|macro|PFM_DEBUG_OFF
mdefine_line|#define PFM_DEBUG_OFF&t;&t;0xe1
DECL|macro|PFM_DEBUG_BASE
mdefine_line|#define PFM_DEBUG_BASE&t;&t;PFM_DEBUG_ON
multiline_comment|/*&n; * perfmon API flags&n; */
DECL|macro|PFM_FL_INHERIT_NONE
mdefine_line|#define PFM_FL_INHERIT_NONE&t; 0x00&t;/* never inherit a context across fork (default) */
DECL|macro|PFM_FL_INHERIT_ONCE
mdefine_line|#define PFM_FL_INHERIT_ONCE&t; 0x01&t;/* clone pfm_context only once across fork() */
DECL|macro|PFM_FL_INHERIT_ALL
mdefine_line|#define PFM_FL_INHERIT_ALL&t; 0x02&t;/* always clone pfm_context across fork() */
DECL|macro|PFM_FL_SMPL_OVFL_NOBLOCK
mdefine_line|#define PFM_FL_SMPL_OVFL_NOBLOCK 0x04&t;/* do not block on sampling buffer overflow */
DECL|macro|PFM_FL_SYSTEM_WIDE
mdefine_line|#define PFM_FL_SYSTEM_WIDE&t; 0x08&t;/* create a system wide context */
DECL|macro|PFM_FL_EXCL_INTR
mdefine_line|#define PFM_FL_EXCL_INTR&t; 0x10&t;/* exclude interrupt from system wide monitoring */
multiline_comment|/*&n; * PMC API flags&n; */
DECL|macro|PFM_REGFL_OVFL_NOTIFY
mdefine_line|#define PFM_REGFL_OVFL_NOTIFY&t;1&t;&t;/* send notification on overflow */
multiline_comment|/*&n; * Private flags and masks&n; */
DECL|macro|PFM_FL_INHERIT_MASK
mdefine_line|#define PFM_FL_INHERIT_MASK&t;(PFM_FL_INHERIT_NONE|PFM_FL_INHERIT_ONCE|PFM_FL_INHERIT_ALL)
macro_line|#ifdef CONFIG_SMP
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i) (cpu_online_map &amp; (1UL &lt;&lt; i))
macro_line|#else
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;1
macro_line|#endif
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;&t;(i &lt; pmu_conf.num_pmcs &amp;&amp; pmu_conf.impl_regs[i&gt;&gt;6] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;&t;(i &lt; pmu_conf.num_pmds &amp;&amp;  pmu_conf.impl_regs[4+(i&gt;&gt;6)] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_COUNTER
mdefine_line|#define PMD_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
DECL|macro|PMC_IS_COUNTER
mdefine_line|#define PMC_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
multiline_comment|/* This is the Itanium-specific PMC layout for counter config */
r_typedef
r_struct
(brace
DECL|member|pmc_plm
r_int
r_int
id|pmc_plm
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* privilege level mask */
DECL|member|pmc_ev
r_int
r_int
id|pmc_ev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* external visibility */
DECL|member|pmc_oi
r_int
r_int
id|pmc_oi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* overflow interrupt */
DECL|member|pmc_pm
r_int
r_int
id|pmc_pm
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* privileged monitor */
DECL|member|pmc_ig1
r_int
r_int
id|pmc_ig1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_es
r_int
r_int
id|pmc_es
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* event select */
DECL|member|pmc_ig2
r_int
r_int
id|pmc_ig2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_umask
r_int
r_int
id|pmc_umask
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* unit mask */
DECL|member|pmc_thres
r_int
r_int
id|pmc_thres
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* threshold */
DECL|member|pmc_ig3
r_int
r_int
id|pmc_ig3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved (missing from table on p6-17) */
DECL|member|pmc_ism
r_int
r_int
id|pmc_ism
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* instruction set mask */
DECL|member|pmc_ig4
r_int
r_int
id|pmc_ig4
suffix:colon
l_int|38
suffix:semicolon
multiline_comment|/* reserved */
DECL|typedef|pmc_counter_reg_t
)brace
id|pmc_counter_reg_t
suffix:semicolon
multiline_comment|/* test for EAR/BTB configuration */
DECL|macro|PMU_DEAR_EVENT
mdefine_line|#define PMU_DEAR_EVENT&t;0x67
DECL|macro|PMU_IEAR_EVENT
mdefine_line|#define PMU_IEAR_EVENT&t;0x23
DECL|macro|PMU_BTB_EVENT
mdefine_line|#define PMU_BTB_EVENT&t;0x11
DECL|macro|PMC_IS_DEAR
mdefine_line|#define PMC_IS_DEAR(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_DEAR_EVENT)
DECL|macro|PMC_IS_IEAR
mdefine_line|#define PMC_IS_IEAR(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_IEAR_EVENT)
DECL|macro|PMC_IS_BTB
mdefine_line|#define PMC_IS_BTB(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_BTB_EVENT)
multiline_comment|/*&n; * This header is at the beginning of the sampling buffer returned to the user.&n; * It is exported as Read-Only at this point. It is directly followed with the&n; * first record.&n; */
r_typedef
r_struct
(brace
DECL|member|hdr_version
r_int
id|hdr_version
suffix:semicolon
multiline_comment|/* could be used to differentiate formats */
DECL|member|hdr_reserved
r_int
id|hdr_reserved
suffix:semicolon
DECL|member|hdr_entry_size
r_int
r_int
id|hdr_entry_size
suffix:semicolon
multiline_comment|/* size of one entry in bytes */
DECL|member|hdr_count
r_int
r_int
id|hdr_count
suffix:semicolon
multiline_comment|/* how many valid entries */
DECL|member|hdr_pmds
r_int
r_int
id|hdr_pmds
suffix:semicolon
multiline_comment|/* which pmds are recorded */
DECL|typedef|perfmon_smpl_hdr_t
)brace
id|perfmon_smpl_hdr_t
suffix:semicolon
multiline_comment|/*&n; * Header entry in the buffer as a header as follows.&n; * The header is directly followed with the PMDS to saved in increasing index order:&n; * PMD4, PMD5, .... How many PMDs are present is determined by the tool which must&n; * keep track of it when generating the final trace file.&n; */
r_typedef
r_struct
(brace
DECL|member|pid
r_int
id|pid
suffix:semicolon
multiline_comment|/* identification of process */
DECL|member|cpu
r_int
id|cpu
suffix:semicolon
multiline_comment|/* which cpu was used */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
multiline_comment|/* initial value of this counter */
DECL|member|stamp
r_int
r_int
id|stamp
suffix:semicolon
multiline_comment|/* timestamp */
DECL|member|ip
r_int
r_int
id|ip
suffix:semicolon
multiline_comment|/* where did the overflow interrupt happened */
DECL|member|regs
r_int
r_int
id|regs
suffix:semicolon
multiline_comment|/* which registers overflowed (up to 64)*/
DECL|typedef|perfmon_smpl_entry_t
)brace
id|perfmon_smpl_entry_t
suffix:semicolon
multiline_comment|/*&n; * There is one such data structure per perfmon context. It is used to describe the&n; * sampling buffer. It is to be shared among siblings whereas the pfm_context isn&squot;t.&n; * Therefore we maintain a refcnt which is incremented on fork().&n; * This buffer is private to the kernel only the actual sampling buffer including its&n; * header are exposed to the user. This construct allows us to export the buffer read-write,&n; * if needed, without worrying about security problems.&n; */
r_typedef
r_struct
(brace
DECL|member|psb_refcnt
id|atomic_t
id|psb_refcnt
suffix:semicolon
multiline_comment|/* how many users for the buffer */
DECL|member|reserved
r_int
id|reserved
suffix:semicolon
DECL|member|psb_addr
r_void
op_star
id|psb_addr
suffix:semicolon
multiline_comment|/* points to location of first entry */
DECL|member|psb_entries
r_int
r_int
id|psb_entries
suffix:semicolon
multiline_comment|/* maximum number of entries */
DECL|member|psb_size
r_int
r_int
id|psb_size
suffix:semicolon
multiline_comment|/* aligned size of buffer */
DECL|member|psb_index
r_int
r_int
id|psb_index
suffix:semicolon
multiline_comment|/* next free entry slot */
DECL|member|psb_entry_size
r_int
r_int
id|psb_entry_size
suffix:semicolon
multiline_comment|/* size of each entry including entry header */
DECL|member|psb_hdr
id|perfmon_smpl_hdr_t
op_star
id|psb_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header */
DECL|typedef|pfm_smpl_buffer_desc_t
)brace
id|pfm_smpl_buffer_desc_t
suffix:semicolon
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristic as indicated&n; * by PAL&n; */
r_typedef
r_struct
(brace
DECL|member|pfm_is_disabled
r_int
r_int
id|pfm_is_disabled
suffix:semicolon
multiline_comment|/* indicates if perfmon is working properly */
DECL|member|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters   */
DECL|member|max_counters
r_int
r_int
id|max_counters
suffix:semicolon
multiline_comment|/* upper limit on counter pair (PMC/PMD) */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* highest PMC implemented (may have holes) */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* highest PMD implemented (may have holes) */
DECL|member|impl_regs
r_int
r_int
id|impl_regs
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* buffer used to hold implememted PMC/PMD mask */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
DECL|macro|PERFMON_IS_DISABLED
mdefine_line|#define PERFMON_IS_DISABLED() pmu_conf.pfm_is_disabled
r_typedef
r_struct
(brace
DECL|member|val
id|__u64
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|ival
id|__u64
id|ival
suffix:semicolon
multiline_comment|/* initial value from user */
DECL|member|smpl_rval
id|__u64
id|smpl_rval
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|ovfl_rval
id|__u64
id|ovfl_rval
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
DECL|macro|PMD_OVFL_NOTIFY
mdefine_line|#define PMD_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
multiline_comment|/*&n; * perfmon context. One per process, is cloned on fork() depending on inheritance flags&n; */
r_typedef
r_struct
(brace
DECL|member|inherit
r_int
r_int
id|inherit
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* inherit mode */
DECL|member|noblock
r_int
r_int
id|noblock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* block/don&squot;t block on overflow with notification */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|frozen
r_int
r_int
id|frozen
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* pmu must be kept frozen on ctxsw in */
DECL|member|exclintr
r_int
r_int
id|exclintr
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* exlcude interrupts from system wide monitoring */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|26
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_smpl_buf
id|pfm_smpl_buffer_desc_t
op_star
id|ctx_smpl_buf
suffix:semicolon
multiline_comment|/* sampling buffer descriptor, if any */
DECL|member|ctx_dear_counter
r_int
r_int
id|ctx_dear_counter
suffix:semicolon
multiline_comment|/* which PMD holds D-EAR */
DECL|member|ctx_iear_counter
r_int
r_int
id|ctx_iear_counter
suffix:semicolon
multiline_comment|/* which PMD holds I-EAR */
DECL|member|ctx_btb_counter
r_int
r_int
id|ctx_btb_counter
suffix:semicolon
multiline_comment|/* which PMD holds BTB */
DECL|member|ctx_notify_lock
id|spinlock_t
id|ctx_notify_lock
suffix:semicolon
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* block/noblock */
DECL|member|ctx_notify_sig
r_int
id|ctx_notify_sig
suffix:semicolon
multiline_comment|/* XXX: SIGPROF or other */
DECL|member|ctx_notify_task
r_struct
id|task_struct
op_star
id|ctx_notify_task
suffix:semicolon
multiline_comment|/* who to notify on overflow */
DECL|member|ctx_creator
r_struct
id|task_struct
op_star
id|ctx_creator
suffix:semicolon
multiline_comment|/* pid of creator (debug) */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
suffix:semicolon
multiline_comment|/* which registers just overflowed (notification) */
DECL|member|ctx_smpl_regs
r_int
r_int
id|ctx_smpl_regs
suffix:semicolon
multiline_comment|/* which registers to record on overflow */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_used_pmds
r_int
r_int
id|ctx_used_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used PMD (speedup ctxsw) */
DECL|member|ctx_used_pmcs
r_int
r_int
id|ctx_used_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used PMC (speedup ctxsw) */
DECL|member|ctx_pmds
id|pfm_counter_t
id|ctx_pmds
(braket
id|IA64_NUM_PMD_COUNTERS
)braket
suffix:semicolon
multiline_comment|/* XXX: size should be dynamic */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
DECL|macro|CTX_USED_PMD
mdefine_line|#define CTX_USED_PMD(ctx,n) (ctx)-&gt;ctx_used_pmds[(n)&gt;&gt;6] |= 1&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_PMC
mdefine_line|#define CTX_USED_PMC(ctx,n) (ctx)-&gt;ctx_used_pmcs[(n)&gt;&gt;6] |= 1&lt;&lt; ((n) % 64)
DECL|macro|ctx_fl_inherit
mdefine_line|#define ctx_fl_inherit&t;ctx_flags.inherit
DECL|macro|ctx_fl_noblock
mdefine_line|#define ctx_fl_noblock&t;ctx_flags.noblock
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;ctx_flags.system
DECL|macro|ctx_fl_frozen
mdefine_line|#define ctx_fl_frozen&t;ctx_flags.frozen
DECL|macro|ctx_fl_exclintr
mdefine_line|#define ctx_fl_exclintr&t;ctx_flags.exclintr
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_noblock == 1)
DECL|macro|CTX_INHERIT_MODE
mdefine_line|#define CTX_INHERIT_MODE(c)&t;((c)-&gt;ctx_fl_inherit)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_smpl_buf != NULL)
DECL|variable|pmu_conf
r_static
id|pmu_config_t
id|pmu_conf
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|pfm_debug
r_static
r_int
id|pfm_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0= nodebug, &gt;0= debug output on */
DECL|macro|DBprintk
mdefine_line|#define DBprintk(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (pfm_debug &gt;0) { printk(__FUNCTION__&quot; %d: &quot;, __LINE__); printk a; } &bslash;&n;&t;} while (0);
r_static
r_void
id|ia64_reset_pmu
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * structure used to pass information between the interrupt handler&n; * and the tasklet.&n; */
r_typedef
r_struct
(brace
DECL|member|to_pid
id|pid_t
id|to_pid
suffix:semicolon
multiline_comment|/* which process to notify */
DECL|member|from_pid
id|pid_t
id|from_pid
suffix:semicolon
multiline_comment|/* which process is source of overflow */
DECL|member|sig
r_int
id|sig
suffix:semicolon
multiline_comment|/* with which signal */
DECL|member|bitvect
r_int
r_int
id|bitvect
suffix:semicolon
multiline_comment|/* which counters have overflowed */
DECL|typedef|notification_info_t
)brace
id|notification_info_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|pfs_proc_sessions
r_int
r_int
id|pfs_proc_sessions
suffix:semicolon
DECL|member|pfs_sys_session
r_int
r_int
id|pfs_sys_session
suffix:semicolon
multiline_comment|/* can only be 0/1 */
DECL|member|pfs_dfl_dcr
r_int
r_int
id|pfs_dfl_dcr
suffix:semicolon
multiline_comment|/* XXX: hack */
DECL|member|pfs_pp
r_int
r_int
id|pfs_pp
suffix:semicolon
DECL|typedef|pfm_session_t
)brace
id|pfm_session_t
suffix:semicolon
r_struct
(brace
DECL|member|owner
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
DECL|variable|pmu_owners
)brace
id|____cacheline_aligned
id|pmu_owners
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* &n; * helper macros&n; */
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t)&t;do { pmu_owners[smp_processor_id()].owner = (t); } while(0);
DECL|macro|PMU_OWNER
mdefine_line|#define PMU_OWNER()&t;&t;pmu_owners[smp_processor_id()].owner
macro_line|#ifdef CONFIG_SMP
DECL|macro|PFM_CAN_DO_LAZY
mdefine_line|#define PFM_CAN_DO_LAZY()&t;(smp_num_cpus==1 &amp;&amp; pfs_info.pfs_sys_session==0)
macro_line|#else
DECL|macro|PFM_CAN_DO_LAZY
mdefine_line|#define PFM_CAN_DO_LAZY()&t;(pfs_info.pfs_sys_session==0)
macro_line|#endif
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
multiline_comment|/*&n; * XXX: hack to indicate that a system wide monitoring session is active&n; */
DECL|variable|pfs_info
r_static
id|pfm_session_t
id|pfs_info
suffix:semicolon
multiline_comment|/*&n; * finds the number of PM(C|D) registers given&n; * the bitvector returned by PAL&n; */
r_static
r_int
r_int
id|__init
DECL|function|find_num_pm_regs
id|find_num_pm_regs
c_func
(paren
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 words/per bitvector */
multiline_comment|/* start from the most significant word */
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|buffer
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: No bit set in pm_buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
op_plus
id|ia64_fls
c_func
(paren
id|buffer
(braket
id|i
)braket
)paren
op_plus
l_int|64
op_star
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates a unique (per CPU) timestamp&n; */
r_static
r_inline
r_int
r_int
DECL|function|perfmon_get_stamp
id|perfmon_get_stamp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * XXX: maybe find something more efficient&n;&t; */
r_return
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Given PGD from the address space&squot;s page table, return the kernel&n; * virtual mapping of the physical memory mapped at ADR.&n; */
r_static
r_inline
r_int
r_int
DECL|function|uvirt_to_kva
id|uvirt_to_kva
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0UL
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|adr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|adr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|ret
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|ret
op_or_assign
(paren
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;uv2kva(%lx--&gt;%lx)&bslash;n&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
r_static
r_inline
r_int
r_int
DECL|function|kvirt_to_pa
id|kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
op_assign
id|ia64_tpa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;kv2pa(%lx--&gt;%lx)&bslash;n&quot;
comma
id|adr
comma
id|pa
)paren
)paren
suffix:semicolon
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|rvmalloc
id|rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
multiline_comment|/* XXX: may have to revisit this part because&n;&t; * vmalloc() does not necessarily return a page-aligned buffer.&n;&t; * This maybe a security problem when mapped at user level&n;&t; */
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|rvfree
id|rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
)brace
r_static
id|pfm_context_t
op_star
DECL|function|pfm_context_alloc
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|pfc
suffix:semicolon
multiline_comment|/* allocate context descriptor */
id|pfc
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pfc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfc
)paren
id|memset
c_func
(paren
id|pfc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pfc
)paren
)paren
suffix:semicolon
r_return
id|pfc
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_context_free
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|pfc
)paren
(brace
r_if
c_cond
(paren
id|pfc
)paren
id|vfree
c_func
(paren
id|pfc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_remap_buffer
id|pfm_remap_buffer
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * counts the number of PMDS to save per entry.&n; * This code is generic enough to accomodate more than 64 PMDS when they become available&n; */
r_static
r_int
r_int
DECL|function|pfm_smpl_entry_size
id|pfm_smpl_entry_size
c_func
(paren
r_int
r_int
op_star
id|which
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
comma
id|which
op_increment
)paren
id|res
op_add_assign
id|hweight64
c_func
(paren
op_star
id|which
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; res=%ld&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates the sampling buffer and remaps it into caller&squot;s address space&n; */
r_static
r_int
DECL|function|pfm_smpl_buffer_alloc
id|pfm_smpl_buffer_alloc
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|which_pmds
comma
r_int
r_int
id|entries
comma
r_void
op_star
op_star
id|user_addr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|addr
comma
id|size
comma
id|regcount
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
id|regcount
op_assign
id|pfm_smpl_entry_size
c_func
(paren
op_amp
id|which_pmds
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* note that regcount might be 0, in this case only the header for each&n;&t; * entry will be recorded.&n;&t; */
multiline_comment|/*&n;&t; * 1 buffer hdr and for each entry a header + regcount PMDs to save&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
op_plus
id|entries
op_star
(paren
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* find some free area in address space */
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|MAP_PRIVATE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_goto
id|no_addr
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; entries=%ld aligned size=%ld, unmapped @0x%lx&bslash;n&quot;
comma
id|entries
comma
id|size
comma
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|no_vma
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the vma for the sampling buffer&n;&t; */
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|VM_READ
op_or
id|VM_MAYREAD
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
multiline_comment|/* XXX may need to change */
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX: see rvmalloc() for page alignment problem */
id|smpl_buf
op_assign
id|rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
r_goto
id|no_buffer
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; smpl_buf @%p&bslash;n&quot;
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
id|vma
comma
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|addr
comma
id|size
)paren
)paren
r_goto
id|cant_remap
suffix:semicolon
multiline_comment|/* allocate sampling buffer descriptor now */
id|psb
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|psb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
r_goto
id|no_buffer_desc
suffix:semicolon
multiline_comment|/* start with something clean */
id|memset
c_func
(paren
id|smpl_buf
comma
l_int|0x0
comma
id|size
)paren
suffix:semicolon
id|psb-&gt;psb_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|psb-&gt;psb_addr
op_assign
(paren
r_char
op_star
)paren
id|smpl_buf
op_plus
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
suffix:semicolon
multiline_comment|/* first entry */
id|psb-&gt;psb_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
id|psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
id|psb-&gt;psb_entries
op_assign
id|entries
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|psb-&gt;psb_refcnt
comma
l_int|1
)paren
suffix:semicolon
id|psb-&gt;psb_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; psb @%p entry_size=%ld hdr=%p addr=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|psb
comma
id|psb-&gt;psb_entry_size
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_hdr
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some of the fields of header */
id|psb-&gt;psb_hdr-&gt;hdr_version
op_assign
id|PFM_SMPL_HDR_VERSION
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_pmds
op_assign
id|which_pmds
suffix:semicolon
multiline_comment|/* store which PMDS to record */
id|ctx-&gt;ctx_smpl_regs
op_assign
id|which_pmds
suffix:semicolon
multiline_comment|/* link to perfmon context */
id|ctx-&gt;ctx_smpl_buf
op_assign
id|psb
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
id|ctx
suffix:semicolon
multiline_comment|/* link to pfm_context(not yet used) */
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * that&squot;s the address returned to the user&n;&t; */
op_star
id|user_addr
op_assign
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* outlined error handling */
id|no_addr
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|no_vma
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|cant_remap
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
id|no_buffer
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|no_buffer_desc
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer descriptor&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfx_is_sane
id|pfx_is_sane
c_func
(paren
id|pfreq_context_t
op_star
id|pfx
)paren
(brace
r_int
id|ctx_flags
suffix:semicolon
multiline_comment|/* valid signal */
singleline_comment|//if (pfx-&gt;notify_sig &lt; 1 || pfx-&gt;notify_sig &gt;= _NSIG) return -EINVAL;
r_if
c_cond
(paren
id|pfx-&gt;notify_sig
op_ne
l_int|0
op_logical_and
id|pfx-&gt;notify_sig
op_ne
id|SIGPROF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* cannot send to process 1, 0 means do not notify */
r_if
c_cond
(paren
id|pfx-&gt;notify_pid
OL
l_int|0
op_logical_or
id|pfx-&gt;notify_pid
op_eq
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx_flags
op_assign
id|pfx-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|smp_num_cpus
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: system wide monitoring on SMP not yet supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|ctx_flags
op_amp
id|PFM_FL_SMPL_OVFL_NOBLOCK
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: system wide monitoring cannot use blocking notification mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* probably more to add here */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_create
id|pfm_context_create
c_func
(paren
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
op_assign
l_int|NULL
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
id|pid_t
id|pid
suffix:semicolon
multiline_comment|/* to go away */
r_if
c_cond
(paren
id|flags
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: use context flags instead of perfmon() flags. Obsoleted API&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
id|pfx_is_sane
c_func
(paren
op_amp
id|tmp.pfr_ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ctx_flags
op_assign
id|tmp.pfr_ctx.flags
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX: This is not AT ALL SMP safe&n;&t;&t; */
r_if
c_cond
(paren
id|pfs_info.pfs_proc_sessions
OG
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|pfs_info.pfs_sys_session
OG
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|pfs_info.pfs_sys_session
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfs_info.pfs_sys_session
OG
l_int|0
)paren
(brace
multiline_comment|/* no per-process monitoring while there is a system wide session */
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
id|pfs_info.pfs_proc_sessions
op_increment
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* record the creator (debug only) */
id|ctx-&gt;ctx_creator
op_assign
id|current
suffix:semicolon
id|pid
op_assign
id|tmp.pfr_ctx.notify_pid
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_eq
id|current-&gt;pid
)paren
(brace
id|ctx-&gt;ctx_notify_task
op_assign
id|task
op_assign
id|current
suffix:semicolon
id|current-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|current-&gt;thread.pfm_notifiers_check
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pid
op_ne
l_int|0
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|task
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
)paren
(brace
multiline_comment|/*&n;&t;&t; &t; * record who to notify&n;&t;&t; &t; */
id|ctx-&gt;ctx_notify_task
op_assign
id|task
suffix:semicolon
multiline_comment|/* &n;&t;&t; &t; * make visible&n;&t;&t; &t; * must be done inside critical section&n;&t;&t; &t; *&n;&t;&t; &t; * if the initialization does not go through it is still&n;&t;&t; &t; * okay because child will do the scan for nothing which&n;&t;&t; &t; * won&squot;t hurt.&n;&t;&t; &t; */
id|current-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * will cause task to check on exit for monitored&n;&t;&t;&t; * processes that would notify it. see release_thread()&n;&t;&t;&t; * Note: the scan MUST be done in release thread, once the&n;&t;&t;&t; * task has been detached from the tasklist otherwise you are&n;&t;&t;&t; * exposed to race conditions.&n;&t;&t;&t; */
id|atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * notification process does not exist&n;&t; */
r_if
c_cond
(paren
id|pid
op_ne
l_int|0
op_logical_and
id|task
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
id|ctx-&gt;ctx_notify_sig
op_assign
id|SIGPROF
suffix:semicolon
multiline_comment|/* siginfo imposes a fixed signal */
r_if
c_cond
(paren
id|tmp.pfr_ctx.smpl_entries
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; sampling entries=%ld&bslash;n&quot;
comma
id|tmp.pfr_ctx.smpl_entries
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|ctx
comma
id|tmp.pfr_ctx.smpl_regs
comma
id|tmp.pfr_ctx.smpl_entries
comma
op_amp
id|uaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|buffer_error
suffix:semicolon
id|tmp.pfr_ctx.smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
multiline_comment|/* initialization of context&squot;s flags */
id|ctx-&gt;ctx_fl_inherit
op_assign
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
suffix:semicolon
id|ctx-&gt;ctx_fl_noblock
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SMPL_OVFL_NOBLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_exclintr
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_EXCL_INTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Keep track of the pmds we want to sample&n;&t; * XXX: may be we don&squot;t need to save/restore the DEAR/IEAR pmds&n;&t; * but we do need the BTB for sure. This is because of a hardware&n;&t; * buffer of 1 only for non-BTB pmds.&n;&t; */
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_assign
id|tmp.pfr_ctx.smpl_regs
suffix:semicolon
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always save/restore PMC[0] */
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* init this semaphore to locked */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; context=%p, pid=%d notify_sig %d notify_task=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_notify_sig
comma
id|ctx-&gt;ctx_notify_task
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; context=%p, pid=%d flags=0x%x inherit=%d noblock=%d system=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|current-&gt;pid
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_inherit
comma
id|ctx-&gt;ctx_fl_noblock
comma
id|ctx-&gt;ctx_fl_system
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when no notification is required, we can make this visible at the last moment&n;&t; */
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
)paren
id|current-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t; * by default, we always include interrupts for system wide&n;&t; * DCR.pp is set by default to zero by kernel  in cpu_init()&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_exclintr
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;* keep track of the kernel default value&n;&t;&t;&t; */
id|pfs_info.pfs_dfl_dcr
op_assign
id|dcr
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; dcr.pp is set&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|error
suffix:colon
multiline_comment|/*&n;&t; * undo session reservation&n;&t; */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
id|pfs_info.pfs_sys_session
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|pfs_info.pfs_proc_sessions
op_decrement
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_regs
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_ovfl_regs
suffix:semicolon
r_int
id|i
comma
id|cnum
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; ovfl_regs=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
comma
id|cnum
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; reseting PMD[%d]=%lx&bslash;n&quot;
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* upper part is ignored on rval */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we must reset BTB index (clears pmd16.full to make&n;&t;&t;&t; * sure we do not report the same branches twice.&n;&t;&t;&t; * The non-blocking case in handled in update_counters()&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cnum
op_eq
id|ctx-&gt;ctx_btb_counter
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reseting PMD16&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|16
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* just in case ! */
id|ctx-&gt;ctx_ovfl_regs
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmcs
id|pfm_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.pfr_reg.reg_num
suffix:semicolon
multiline_comment|/* XXX needs to check validity of the data maybe */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; invalid pmc[%ld]&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMC_IS_COUNTER
c_func
(paren
id|cnum
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we keep track of EARS/BTB to speed up sampling later&n;&t;&t;&t; */
r_if
c_cond
(paren
id|PMC_IS_DEAR
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_dear_counter
op_assign
id|cnum
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PMC_IS_IEAR
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_iear_counter
op_assign
id|cnum
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PMC_IS_BTB
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_btb_counter
op_assign
id|cnum
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|tmp.pfr_reg.reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
id|ctx-&gt;ctx_pmds
(braket
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* keep track of what we use */
id|CTX_USED_PMC
c_func
(paren
id|ctx
comma
id|cnum
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|tmp.pfr_reg.reg_value
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; setting PMC[%ld]=0x%lx flags=0x%x used_pmcs=0%lx&bslash;n&quot;
comma
id|cnum
comma
id|tmp.pfr_reg.reg_value
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|flags
comma
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t; * because we may be context switched out&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmds
id|pfm_write_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.pfr_reg.reg_num
suffix:semicolon
id|k
op_assign
id|cnum
op_minus
id|PMU_FIRST_COUNTER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* update virtualized (64bits) counter */
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ival
op_assign
id|tmp.pfr_reg.reg_value
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|val
op_assign
id|tmp.pfr_reg.reg_value
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|smpl_rval
op_assign
id|tmp.pfr_reg.reg_smpl_reset
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ovfl_rval
op_assign
id|tmp.pfr_reg.reg_ovfl_reset
suffix:semicolon
r_if
c_cond
(paren
id|tmp.pfr_reg.reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
id|ctx-&gt;ctx_pmds
(braket
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
multiline_comment|/* keep track of what we use */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
suffix:semicolon
multiline_comment|/* writes to unimplemented part is ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|tmp.pfr_reg.reg_value
)paren
suffix:semicolon
multiline_comment|/* to go away */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; setting PMD[%ld]:  ovfl_notify=%d pmd.val=0x%lx pmd.ovfl_rval=0x%lx pmd.smpl_rval=0x%lx pmd=%lx used_pmds=0%lx&bslash;n&quot;
comma
id|cnum
comma
id|PMD_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|val
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ovfl_rval
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|smpl_rval
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t; * because we may be context switched out&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_read_pmds
id|pfm_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: MUST MAKE SURE WE DON&quot;T HAVE ANY PENDING OVERFLOW BEFORE READING&n;&t; * This is required when the monitoring has been stoppped by user of kernel.&n;&t; * If ity is still going on, then that&squot;s fine because we a re not gauranteed&n;&t; * to return an accurate value in this case&n;&t; */
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
r_int
id|reg_val
op_assign
op_complement
l_int|0
comma
id|ctx_val
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
)paren
(brace
r_if
c_cond
(paren
id|ta
op_eq
id|current
)paren
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|reg_val
op_assign
id|th-&gt;pmd
(braket
id|tmp.pfr_reg.reg_num
)braket
suffix:semicolon
)brace
id|val
op_and_assign
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * lower part of .val may not be zero, so we must be an addition because of&n;&t;&t;&t; * residual count (see update_counters).&n;&t;&t;&t; */
id|val
op_add_assign
id|ctx_val
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|tmp.pfr_reg.reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* for now */
r_if
c_cond
(paren
id|ta
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
suffix:semicolon
)brace
id|tmp.pfr_reg.reg_value
op_assign
id|val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; reading PMD[%ld]=0x%lx reg=0x%lx ctx_val=0x%lx pmc=0x%lx&bslash;n&quot;
comma
id|tmp.pfr_reg.reg_num
comma
id|val
comma
id|reg_val
comma
id|ctx_val
comma
id|ia64_get_pmc
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_do_restart
id|pfm_do_restart
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
r_void
op_star
id|sem
op_assign
op_amp
id|ctx-&gt;ctx_restart_sem
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; restarting self %d frozen=%d &bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_frozen
)paren
)paren
suffix:semicolon
id|pfm_reset_regs
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We ignore block/don&squot;t block because we never block&n;&t;&t; * for a self-monitoring process.&n;&t;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* pfm_reset_smpl_buffers(ctx,th-&gt;pfm_ovfl_regs);*/
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check if blocking */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; unblocking %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in case of non blocking mode, then it&squot;s just a matter of&n;&t; * of reseting the sampling buffer (if any) index. The PMU&n;&t; * is already active.&n;&t; */
multiline_comment|/*&n;&t; * must reset the header count first&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; resetting sampling indexes for %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * system-wide mode: propagate activation/desactivation throughout the tasklist&n; *&n; * XXX: does not work for SMP, of course&n; */
r_static
r_void
DECL|function|pfm_process_tasklist
id|pfm_process_tasklist
c_func
(paren
r_int
id|cmd
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|p
op_plus
id|IA64_STK_OFFSET
)paren
suffix:semicolon
id|regs
op_decrement
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|cmd
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|do_perfmonctl
id|do_perfmonctl
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|perfmon_req_t
id|tmp
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
op_logical_and
id|cmd
op_ne
id|PFM_CREATE_CONTEXT
op_logical_and
id|cmd
OL
id|PFM_DEBUG_BASE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_WRITE_PMCS: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PFM_CREATE_CONTEXT
suffix:colon
multiline_comment|/* a context has already been defined */
r_if
c_cond
(paren
id|ctx
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * cannot directly create a context in another process&n;&t;&t;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
op_logical_or
id|count
op_ne
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|pfm_context_create
c_func
(paren
id|flags
comma
id|req
)paren
suffix:semicolon
r_case
id|PFM_WRITE_PMCS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|pfm_write_pmcs
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_WRITE_PMDS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|pfm_write_pmds
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_START
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|current
op_logical_and
id|PFM_CAN_DO_LAZY
c_func
(paren
)paren
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* will start monitoring right after rfi */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_process_tasklist
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|pfs_info.pfs_pp
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * mark the state as valid.&n;&t;&t;&t; * this will trigger save/restore at context switch&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_ENABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|current
op_logical_and
id|PFM_CAN_DO_LAZY
c_func
(paren
)paren
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* reset all registers to stable quiet state */
id|ia64_reset_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure nothing starts */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do it on the live register as well */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp|psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * mark the state as valid.&n;&t;&t;&t; * this will trigger save/restore at context switch&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DISABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* simply freeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * XXX: cannot really toggle IA64_THREAD_PM_VALID&n;&t;&t;&t; * but context is still considered valid, so any &n;&t;&t;&t; * read request would return something valid. Same&n;&t;&t;&t; * thing when this task terminates (pfm_flush_regs()).&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|PFM_READ_PMDS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|pfm_read_pmds
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_STOP
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* simply stop monitors, not PMU */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_process_tasklist
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pfs_info.pfs_pp
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PFM_RESTART
suffix:colon
multiline_comment|/* temporary, will most likely end up as a PFM_ENABLE */
r_if
c_cond
(paren
(paren
id|th-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; PFM_RESTART not monitoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task %d without pmu_frozen set&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|pfm_do_restart
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* we only look at first entry */
r_case
id|PFM_DESTROY_CONTEXT
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* first stop monitors */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* then freeze PMU */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t save/restore on context switch */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* now free context and related state */
id|pfm_context_exit
c_func
(paren
id|task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_ON
suffix:colon
id|printk
c_func
(paren
l_string|&quot;perfmon debugging on&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_OFF
suffix:colon
id|printk
c_func
(paren
l_string|&quot;perfmon debugging off&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; UNknown command 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
DECL|function|perfmon_bad_permissions
id|perfmon_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* stolen from bad_signal() */
r_return
(paren
id|current-&gt;session
op_ne
id|task-&gt;session
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;uid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;uid
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|task_struct
op_star
id|child
op_assign
id|current
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
multiline_comment|/* sanity check:&n;&t; *&n;&t; * ensures that we don&squot;t do bad things in case the OS&n;&t; * does not have enough storage to save/restore PMC/PMD&n;&t; */
r_if
c_cond
(paren
id|PERFMON_IS_DISABLED
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* XXX: pid interface is going away in favor of pfm context */
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|child
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child
)paren
r_goto
id|abort_call
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|perfmon_bad_permissions
c_func
(paren
id|child
)paren
)paren
r_goto
id|abort_call
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: need to do more checking here&n;&t;&t; */
r_if
c_cond
(paren
id|child-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|child-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; warning process %d not in stable state %ld&bslash;n&quot;
comma
id|pid
comma
id|child-&gt;state
)paren
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|do_perfmonctl
c_func
(paren
id|child
comma
id|cmd
comma
id|flags
comma
id|req
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|abort_call
suffix:colon
r_if
c_cond
(paren
id|child
op_ne
id|current
)paren
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if __GNUC__ &gt;= 3
r_void
id|asmlinkage
DECL|function|pfm_block_on_overflow
id|pfm_block_on_overflow
c_func
(paren
r_void
)paren
macro_line|#else
r_void
id|asmlinkage
id|pfm_block_on_overflow
c_func
(paren
id|u64
id|arg0
comma
id|u64
id|arg1
comma
id|u64
id|arg2
comma
id|u64
id|arg3
comma
id|u64
id|arg4
comma
id|u64
id|arg5
comma
id|u64
id|arg6
comma
id|u64
id|arg7
)paren
macro_line|#endif
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * NO matter what notify_pid is,&n;&t; * we clear overflow, won&squot;t notify again&n;&t; */
id|th-&gt;pfm_must_block
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * do some sanity checks first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: process %d has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: process %d has no task to notify&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; current=%d task=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* should not happen */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: process %d non-blocking ctx should not be here&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d before sleep&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d after sleep ret=%d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
multiline_comment|/* we reactivate on context switch */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the ovfl_sem is cleared by the restart task and this is safe because we always&n;&t;&t; * use the local reference&n;&t;&t; */
id|pfm_reset_regs
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Unlock sampling buffer and reset index atomically&n;&t;&t; * XXX: not really needed when blocking&n;&t;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d unfreeze PMU&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* state restored, can go back to work (user mode) */
)brace
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; * Return:&n; *&t;new value of pmc[0]. if 0x0 then unfreeze, else keep frozen&n; */
r_int
r_int
DECL|function|update_counters
id|update_counters
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
comma
id|i
comma
id|cnum
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|bv
op_assign
l_int|0
suffix:semicolon
r_int
id|my_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
comma
id|buffer_is_full
op_assign
l_int|0
suffix:semicolon
r_int
id|ovfl_has_long_recovery
comma
id|can_notify
comma
id|need_reset_pmd16
op_assign
l_int|0
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * It is never safe to access the task for which the overflow interrupt is destinated&n;&t; * using the current variable as the interrupt may occur in the middle of a context switch&n;&t; * where current does not hold the task that is running yet.&n;&t; *&n;&t; * For monitoring, however, we do need to get access to the task which caused the overflow&n;&t; * to account for overflow on the counters.&n;&t; *&n;&t; * We accomplish this by maintaining a current owner of the PMU per CPU. During context&n;&t; * switch the ownership is changed in a way such that the reflected owner is always the&n;&t; * valid one, i.e. the one that caused the interrupt.&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; owners[%d]=NULL&bslash;n&quot;
comma
id|my_cpu
)paren
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: debug test&n;&t; * Don&squot;t think this could happen given upfront tests&n;&t; */
r_if
c_cond
(paren
(paren
id|th-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d not using perfmon&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d has no PFM context&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pid %d pmc0=0x%lx assumption error for freeze bit&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pmc0
)paren
suffix:semicolon
r_return
l_int|0x0
suffix:semicolon
)brace
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d owner=%d iip=0x%lx, ctx is in %s mode used_pmds=0x%lx used_pmcs=0x%lx&bslash;n&quot;
comma
id|pmc0
comma
id|task-&gt;pid
comma
id|PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
comma
id|regs-&gt;cr_iip
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;NO-BLOCK&quot;
suffix:colon
l_string|&quot;BLOCK&quot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: need to record sample only when an EAR/BTB has overflowed&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_smpl_buf
suffix:semicolon
r_int
r_int
op_star
id|e
comma
id|m
comma
id|idx
op_assign
l_int|0
suffix:semicolon
id|perfmon_smpl_entry_t
op_star
id|h
suffix:semicolon
r_int
id|j
suffix:semicolon
id|idx
op_assign
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_index
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; recording index=%ld entries=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: there is a small chance that we could run out on index before resetting&n;&t;&t; * but index is unsigned long, so it will take some time.....&n;&t;&t; * We use &gt; instead of == because fetch_and_add() is off by one (see below)&n;&t;&t; *&n;&t;&t; * This case can happen in non-blocking mode or with multiple processes.&n;&t;&t; * For non-blocking, we need to reload and continue.&n;&t;&t; */
r_if
c_cond
(paren
id|idx
OG
id|psb-&gt;psb_entries
)paren
(brace
id|buffer_is_full
op_assign
l_int|1
suffix:semicolon
r_goto
id|reload_pmds
suffix:semicolon
)brace
multiline_comment|/* first entry is really entry 0, not 1 caused by fetch_and_add */
id|idx
op_decrement
suffix:semicolon
id|h
op_assign
(paren
id|perfmon_smpl_entry_t
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|psb-&gt;psb_addr
)paren
op_plus
id|idx
op_star
(paren
id|psb-&gt;psb_entry_size
)paren
)paren
suffix:semicolon
id|h-&gt;pid
op_assign
id|task-&gt;pid
suffix:semicolon
id|h-&gt;cpu
op_assign
id|my_cpu
suffix:semicolon
id|h-&gt;rate
op_assign
l_int|0
suffix:semicolon
id|h-&gt;ip
op_assign
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0x0
suffix:semicolon
multiline_comment|/* where did the fault happened */
id|h-&gt;regs
op_assign
id|mask
suffix:semicolon
multiline_comment|/* which registers overflowed */
multiline_comment|/* guaranteed to monotonically increase on each cpu */
id|h-&gt;stamp
op_assign
id|perfmon_get_stamp
c_func
(paren
)paren
suffix:semicolon
id|e
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * selectively store PMDs in increasing index number&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|m
op_assign
id|ctx-&gt;ctx_smpl_regs
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|m
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|j
)paren
)paren
op_star
id|e
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|j
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|j
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
r_else
(brace
op_star
id|e
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
multiline_comment|/* slow */
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; e=%p pmd%d =0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|e
comma
id|j
comma
op_star
id|e
)paren
)paren
suffix:semicolon
id|e
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * make the new entry visible to user, needs to be atomic&n;&t;&t; */
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; index=%ld entries=%ld hdr_count=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
comma
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * sampling buffer full ? &n;&t;&t; */
r_if
c_cond
(paren
id|idx
op_eq
(paren
id|psb-&gt;psb_entries
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * will cause notification, cannot be 0&n;&t;&t;&t; */
id|bv
op_assign
id|mask
op_lshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|buffer_is_full
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; sampling buffer full must notify bv=0x%lx&bslash;n&quot;
comma
id|bv
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we do not reload here, when context is blocking&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
r_goto
id|no_reload
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * here, we have a full buffer but we are in non-blocking mode&n;&t;&t;&t; * so we need to reload overflowed PMDs with sampling reset values&n;&t;&t;&t; * and restart right away.&n;&t;&t;&t; */
)brace
multiline_comment|/* FALL THROUGH */
)brace
id|reload_pmds
suffix:colon
multiline_comment|/*&n;&t; * in the case of a non-blocking context, we reload&n;&t; * with the ovfl_rval when no user notification is taking place (short recovery)&n;&t; * otherwise when the buffer is full which requires user interaction) then we use&n;&t; * smpl_rval which is the long_recovery path (disturbance introduce by user execution).&n;&t; *&n;&t; * XXX: implies that when buffer is full then there is always notification.&n;&t; */
id|ovfl_has_long_recovery
op_assign
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_logical_and
id|buffer_is_full
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: CTX_HAS_SMPL() should really be something like CTX_HAS_SMPL() and is activated,i.e.,&n;&t; * one of the PMC is configured for EAR/BTB.&n;&t; *&n;&t; * When sampling, we can only notify when the sampling buffer is full.&n;&t; */
id|can_notify
op_assign
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_notify_task
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; ovfl_has_long_recovery=%d can_notify=%d&bslash;n&quot;
comma
id|ovfl_has_long_recovery
comma
id|can_notify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PMD[%ld] overflowed pmd=0x%lx pmod.val=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Because we sometimes (EARS/BTB) reset to a specific value, we cannot simply use&n;&t;&t; * val to count the number of times we overflowed. Otherwise we would loose the current value&n;&t;&t; * in the PMD (which can be &gt;0). So to make sure we don&squot;t loose&n;&t;&t; * the residual counts we set val to contain full 64bits value of the counter.&n;&t;&t; *&n;&t;&t; * XXX: is this needed for EARS/BTB ?&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
multiline_comment|/* slow */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pmod[%ld].val=0x%lx pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_notify
op_logical_and
id|PMD_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d should notify task %p with signal %d&bslash;n&quot;
comma
id|my_cpu
comma
id|ctx-&gt;ctx_notify_task
comma
id|ctx-&gt;ctx_notify_sig
)paren
)paren
suffix:semicolon
id|bv
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] overflow, no notification&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * In case no notification is requested, we reload the reset value right away&n;&t;&t;&t; * otherwise we wait until the notify_pid process has been called and has&n;&t;&t;&t; * has finished processing data. Check out pfm_overflow_notify()&n;&t;&t;&t; */
multiline_comment|/* writes to upper part are ignored, so this is safe */
r_if
c_cond
(paren
id|ovfl_has_long_recovery
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] reload with smpl_val=%lx&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] reload with ovfl_val=%lx&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ovfl_rval
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnum
op_eq
id|ctx-&gt;ctx_btb_counter
)paren
id|need_reset_pmd16
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In case of BTB overflow we need to reset the BTB index.&n;&t; */
r_if
c_cond
(paren
id|need_reset_pmd16
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reset PMD16&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|16
comma
l_int|0
)paren
suffix:semicolon
)brace
id|no_reload
suffix:colon
multiline_comment|/*&n;&t; * some counters overflowed, but they did not require&n;&t; * user notification, so after having reloaded them above&n;&t; * we simply restart&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bv
)paren
r_return
l_int|0x0
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
op_assign
id|bv
suffix:semicolon
multiline_comment|/* keep track of what to reset when unblocking */
multiline_comment|/*&n;&t; * Now we know that:&n;&t; * &t;- we have some counters which overflowed (contains in bv)&n;&t; * &t;- someone has asked to be notified on overflow. &n;&t; */
multiline_comment|/*&n;&t; * If the notification task is still present, then notify_task is non&n;&t; * null. It is clean by that task if it ever exits before we do. &n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
)paren
(brace
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|task-&gt;pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_signo
op_assign
id|ctx-&gt;ctx_notify_sig
suffix:semicolon
multiline_comment|/* is SIGPROF */
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
multiline_comment|/* goes to user */
id|si.si_pfm_ovfl
op_assign
id|bv
suffix:semicolon
multiline_comment|/*&n;&t;&t; * when the target of the signal is not ourself, we have to be more&n;&t;&t; * careful. The notify_task may being cleared by the target task itself&n;&t;&t; * in release_thread(). We must ensure mutual exclusion here such that&n;&t;&t; * the signal is delivered (even to a dying task) safely.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * grab the notification lock for this task&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now notify_task cannot be modified until we&squot;re done&n;&t;&t;&t; * if NULL, they it got modified while we were in the handler&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
r_goto
id|lost_notify
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * required by send_sig_info() to make sure the target&n;&t;&t;&t; * task does not disappear on us.&n;&t;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; &t; * in this case, we don&squot;t stop the task, we let it go on. It will&n;&t; &t; * necessarily go to the signal handler (if any) when it goes back to&n;&t; &t; * user mode.&n;&t; &t; */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; %d sending %d notification to %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|si.si_signo
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * this call is safe in an interrupt handler, so does read_lock() on tasklist_lock&n;&t;&t; */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|ctx-&gt;ctx_notify_sig
comma
op_amp
id|si
comma
id|ctx-&gt;ctx_notify_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now undo the protections in order&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if we block set the pfm_must_block bit&n;&t;&t; * when in block mode, we can effectively block only when the notified&n;&t;&t; * task is not self, otherwise we would deadlock. &n;&t;&t; * in this configuration, the notification is sent, the task will not &n;&t;&t; * block on the way back to user mode, but the PMU will be kept frozen&n;&t;&t; * until PFM_RESTART.&n;&t;&t; * Note that here there is still a race condition with notify_task&n;&t;&t; * possibly being nullified behind our back, but this is fine because&n;&t;&t; * it can only be changed to NULL which by construction, can only be&n;&t;&t; * done when notify_task != current. So if it was already different&n;&t;&t; * before, changing it to NULL will still maintain this invariant.&n;&t;&t; * Of course, when it is equal to current it cannot change at this point.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_logical_and
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
id|th-&gt;pfm_must_block
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* will cause blocking */
)brace
)brace
r_else
(brace
id|lost_notify
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; notification task has disappeared !&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * for a non-blocking context, we make sure we do not fall into the pfm_overflow_notify()&n;&t;&t; * trap. Also in the case of a blocking context with lost notify process, then we do not&n;&t;&t; * want to block either (even though it is interruptible). In this case, the PMU will be kept&n;&t;&t; * frozen and the process will run to completion without monitoring enabled.&n;&t;&t; *&n;&t;&t; * Of course, we cannot loose notify process when self-monitoring.&n;&t;&t; */
id|th-&gt;pfm_must_block
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if we block, we keep the PMU frozen. If non-blocking we restart.&n;&t; * in the case of non-blocking were the notify process is lost, we also &n;&t; * restart. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|1
suffix:semicolon
r_else
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; reload pmc0=0x%x must_block=%ld&bslash;n&quot;
comma
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
comma
id|th-&gt;pfm_must_block
)paren
)paren
suffix:semicolon
r_return
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
suffix:semicolon
)brace
r_static
r_void
DECL|function|perfmon_interrupt
id|perfmon_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_struct
id|task_struct
op_star
id|ta
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PM[0].bit[63-1] is set, then PMC[0].fr = 1&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
op_complement
l_int|0x1
)paren
op_logical_and
(paren
id|ta
op_assign
id|PMU_OWNER
c_func
(paren
)paren
)paren
)paren
(brace
multiline_comment|/* assumes, PMC[0].fr = 1 at this point */
id|pmc0
op_assign
id|update_counters
c_func
(paren
id|ta
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if pmu_frozen = 0&n;&t;&t; *&t;pmc0 = 0 and we resume monitoring right away&n;&t;&t; * else&n;&t;&t; *&t;pmc0 = 0x1 frozen but all pending bits are cleared&n;&t;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
id|pmc0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious PMU overflow interrupt: pmc0=0x%lx owner=%p&bslash;n&quot;
comma
id|pmc0
comma
(paren
r_void
op_star
)paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|perfmon_proc_info
id|perfmon_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.pmc[0]=%lx&bslash;nPerfmon debug: %s&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|pmc0
comma
id|pfm_debug
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;proc_sessions=%lu sys_sessions=%lu&bslash;n&quot;
comma
id|pfs_info.pfs_proc_sessions
comma
id|pfs_info.pfs_sys_session
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_online
c_func
(paren
id|i
)paren
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.pmu_owner: %-6d&bslash;n&quot;
comma
id|i
comma
id|pmu_owners
(braket
id|i
)braket
dot
id|owner
ques
c_cond
id|pmu_owners
(braket
id|i
)braket
dot
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|perfmon_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
id|handler
suffix:colon
id|perfmon_interrupt
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
r_void
id|__init
DECL|function|perfmon_init
id|perfmon_init
(paren
r_void
)paren
(brace
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmu_conf.pfm_is_disabled
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: version %s (sampling format v%d)&bslash;n&quot;
comma
id|PFM_VERSION
comma
id|PFM_SMPL_HDR_VERSION
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Interrupt vectored to %u&bslash;n&quot;
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_perf_mon_info
c_func
(paren
id|pmu_conf.impl_regs
comma
op_amp
id|pm_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: PAL call failed (%ld)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmu_conf.perf_ovfl_val
op_assign
(paren
l_int|1L
op_lshift
id|pm_info.pal_perf_mon_info_s.width
)paren
op_minus
l_int|1
suffix:semicolon
id|pmu_conf.max_counters
op_assign
id|pm_info.pal_perf_mon_info_s.generic
suffix:semicolon
id|pmu_conf.num_pmcs
op_assign
id|find_num_pm_regs
c_func
(paren
id|pmu_conf.impl_regs
)paren
suffix:semicolon
id|pmu_conf.num_pmds
op_assign
id|find_num_pm_regs
c_func
(paren
op_amp
id|pmu_conf.impl_regs
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %d bits counters (max value 0x%lx)&bslash;n&quot;
comma
id|pm_info.pal_perf_mon_info_s.width
comma
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %ld PMC/PMD pairs, %ld PMCs, %ld PMDs&bslash;n&quot;
comma
id|pmu_conf.max_counters
comma
id|pmu_conf.num_pmcs
comma
id|pmu_conf.num_pmds
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf.num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf.num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: ERROR not enough PMC/PMD storage in kernel, perfmon is DISABLED&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* no need to continue anyway */
)brace
multiline_comment|/* we are all set */
id|pmu_conf.pfm_is_disabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Insert the tasklet in the list.&n;&t; * It is still disabled at this point, so it won&squot;t run&n;&t;printk(__FUNCTION__&quot; tasklet is %p state=%d, count=%d&bslash;n&quot;, &amp;perfmon_tasklet, perfmon_tasklet.state, perfmon_tasklet.count);&n;&t; */
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|perfmon_init_percpu
id|perfmon_init_percpu
(paren
r_void
)paren
(brace
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|u64
id|pmc0
comma
id|psr
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * We must make sure that we don&squot;t loose any potential overflow&n;&t; * interrupt while saving PMU context. In this code, external&n;&t; * interrupts are always enabled.&n;&t; */
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.up|psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control over overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|owner
op_assign
id|PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for overflow bits and proceed manually if needed&n;&t; *&n;&t; * It is safe to call the interrupt handler now because it does&n;&t; * not try to block the task right away. Instead it will set a&n;&t; * flag and let the task proceed. The blocking will only occur&n;&t; * next time the task exits from the kernel.&n;&t; */
r_if
c_cond
(paren
id|pmc0
op_amp
op_complement
l_int|0x1
)paren
(brace
id|update_counters
c_func
(paren
id|owner
comma
id|pmc0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we will save the updated version of pmc0 */
)brace
multiline_comment|/*&n;&t; * restore PSR for context switch to save&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we do not save registers if we can do lazy&n;&t; */
r_if
c_cond
(paren
id|PFM_CAN_DO_LAZY
c_func
(paren
)paren
)paren
(brace
id|SET_PMU_OWNER
c_func
(paren
id|owner
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* skip PMC[0], we handle it separately */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Throughout this code we could have gotten an overflow interrupt. It is transformed&n;&t; * into a spurious interrupt as soon as we give up pmu ownership.&n;&t; */
)brace
r_static
r_void
DECL|function|pfm_lazy_save_regs
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;  on [%d] by [%d]&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* skip PMC[0], we handle it separately */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|owner
op_assign
id|PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|owner
op_eq
id|ta
)paren
r_goto
id|skip_restore
suffix:semicolon
r_if
c_cond
(paren
id|owner
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|ta
)paren
suffix:semicolon
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|t-&gt;pmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* skip PMC[0] to avoid side effects */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmcs
(braket
l_int|0
)braket
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|skip_restore
suffix:colon
multiline_comment|/*&n;&t; * unfreeze only when possible&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* place where we potentially (kernel level) start monitoring again */
)brace
)brace
multiline_comment|/*&n; * This function is called when a thread exits (from exit_thread()).&n; * This is a simplified pfm_save_regs() that simply flushes the current&n; * register state into the save area taking into account any pending&n; * overflow. This time no notification is sent because the taks is dying&n; * anyway. The inline processing of overflows avoids loosing some counts.&n; * The PMU is frozen on exit from this call and is to never be reenabled&n; * again for this task.&n; */
r_void
DECL|function|pfm_flush_regs
id|pfm_flush_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|pmc0
comma
id|psr
comma
id|mask
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|ta
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
id|__FUNCTION__
l_string|&quot; task is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
id|__FUNCTION__
l_string|&quot; no PFM ctx is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must make sure that we don&squot;t loose any potential overflow&n;&t; * interrupt while saving PMU context. In this code, external&n;&t; * interrupts are always enabled.&n;&t; */
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control on overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore PSR for context switch to save&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;;srlz.i;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This loop flushes the PMD into the PFM context.&n;&t; * IT also processes overflow inline.&n;&t; *&n;&t; * IMPORTANT: No notification is sent at this point as the process is dying.&n;&t; * The implicit notification will come from a SIGCHILD or a return from a&n;&t; * waitpid().&n;&t; *&n;&t; * XXX: must take holes into account&n;&t; */
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
multiline_comment|/* collect latest results */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now everything is in ctx_pmds[] and we need&n;&t;&t; * to clear the saved context from save_regs() such that&n;&t;&t; * pfm_read_pmds() gets the correct value&n;&t;&t; */
id|ta-&gt;thread.pmd
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* take care of overflow inline */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PMD[%d] overflowed pmd=0x%lx pmds.val=0x%lx&bslash;n&quot;
comma
id|j
comma
id|ia64_get_pmd
c_func
(paren
id|j
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XXX: this routine is not very portable for PMCs&n; * XXX: make this routine able to work with non current context&n; */
r_static
r_void
DECL|function|ia64_reset_pmu
id|ia64_reset_pmu
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* PMU is frozen, no pending overflow bits */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* extra overflow bits + counter configs cleared */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|PMU_FIRST_COUNTER
op_plus
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmc
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* opcode matcher set to all 1s */
id|ia64_set_pmc
c_func
(paren
l_int|8
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|9
comma
op_complement
l_int|0
)paren
suffix:semicolon
multiline_comment|/* I-EAR config cleared, plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|10
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* D-EAR config cleared, PMC[11].pt must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|11
comma
l_int|1
op_lshift
l_int|28
)paren
suffix:semicolon
multiline_comment|/* BTB config. plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|12
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Instruction address range, PMC[13].ta must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|13
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clears all PMD registers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmds
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
)paren
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * task is the newly created task&n; */
r_int
DECL|function|pfm_inherit
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
id|pfm_context_t
op_star
id|nctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
id|i
comma
id|cnum
suffix:semicolon
multiline_comment|/*&n;&t; * bypass completely for system wide&n;&t; */
r_if
c_cond
(paren
id|pfs_info.pfs_sys_session
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; enabling psr.pp for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|pfs_info.pfs_pp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * takes care of easiest case first&n;&t; */
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_NONE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; removing PFM context for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_must_block
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|task-&gt;thread.pfm_notifiers_check
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy_thread() clears IA64_THREAD_PM_VALID */
r_return
l_int|0
suffix:semicolon
)brace
id|nctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* copy content */
op_star
id|nctx
op_assign
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_ONCE
)paren
(brace
id|nctx-&gt;ctx_fl_inherit
op_assign
id|PFM_FL_INHERIT_NONE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|task-&gt;thread.pfm_notifiers_check
comma
l_int|0
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; downgrading to INHERIT_NONE for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|pfs_info.pfs_proc_sessions
op_increment
suffix:semicolon
)brace
multiline_comment|/* initialize counters in new context */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
)paren
(brace
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|th-&gt;pmd
(braket
id|cnum
)braket
op_assign
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
)brace
multiline_comment|/* clear BTB index register */
id|th-&gt;pmd
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if sampling then increment number of users of buffer */
r_if
c_cond
(paren
id|nctx-&gt;ctx_smpl_buf
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_smpl_buf-&gt;psb_refcnt
)paren
suffix:semicolon
)brace
id|nctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|nctx-&gt;ctx_ovfl_regs
op_assign
l_int|0
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|nctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset this semaphore to locked */
multiline_comment|/* clear pending notification */
id|th-&gt;pfm_must_block
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* link with new task */
id|th-&gt;pfm_context
op_assign
id|nctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; nctx=%p for process %d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|nctx
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the copy_thread routine automatically clears&n;&t; * IA64_THREAD_PM_VALID, so we need to reenable it, if it was used by the caller&n;&t; */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;  setting PM_VALID for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * called from release_thread(), at this point this task is not in the &n; * tasklist anymore&n; */
r_void
DECL|function|pfm_context_exit
id|pfm_context_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; invalid context for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check is we have a sampling buffer attached */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_buf
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_smpl_buf
suffix:semicolon
multiline_comment|/* if only user left, then remove */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] [%d] psb-&gt;refcnt=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_refcnt.counter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|psb-&gt;psb_refcnt
)paren
)paren
(brace
id|rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] cleaning [%d] sampling buffer&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] cleaning [%d] pfm_context @%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
(paren
r_void
op_star
)paren
id|ctx
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid getting the notified task scan the entire process list&n;&t; * when it exits because it would have pfm_notifiers_check set, we &n;&t; * decrease it by 1 to inform the task, that one less task is going&n;&t; * to send it notification. each new notifer increases this field by&n;&t; * 1 in pfm_context_create(). Of course, there is race condition between&n;&t; * decreasing the value and the notified task exiting. The danger comes&n;&t; * from the fact that we have a direct pointer to its task structure&n;&t; * thereby bypassing the tasklist. We must make sure that if we have &n;&t; * notify_task!= NULL, the target task is still somewhat present. It may&n;&t; * already be detached from the tasklist but that&squot;s okay. Note that it is&n;&t; * okay if we &squot;miss the deadline&squot; and the task scans the list for nothing,&n;&t; * it will affect performance but not correctness. The correctness is ensured&n;&t; * by using the notify_lock whic prevents the notify_task from changing on us.&n;&t; * Once holdhing this lock, if we see notify_task!= NULL, then it will stay like&n;&t; * that until we release the lock. If it is NULL already then we came too late.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] [%d] atomic_sub on [%d] notifiers=%u&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
)paren
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
l_int|1
comma
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/*&n;&t;&t; * if included interrupts (true by default), then reset&n;&t;&t; * to get default value&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_exclintr
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * reload kernel default DCR value&n;&t;&t;&t; */
id|ia64_set_dcr
c_func
(paren
id|pfs_info.pfs_dfl_dcr
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; restored dcr to 0x%lx&bslash;n&quot;
comma
id|pfs_info.pfs_dfl_dcr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * free system wide session slot&n;&t;&t; */
id|pfs_info.pfs_sys_session
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|pfs_info.pfs_proc_sessions
op_decrement
suffix:semicolon
)brace
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  clean pfm state in thread structure,&n;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_must_block
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pfm_notifiers is cleaned in pfm_cleanup_notifiers() */
)brace
r_void
DECL|function|pfm_cleanup_notifiers
id|pfm_cleanup_notifiers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] called&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to do the 2-step test here, because thread.ctx&n;&t;&t; * is cleaned up only in release_thread() and at that point&n;&t;&t; * the task has been detached from the tasklist which is an&n;&t;&t; * operation which uses the write_lock() on the tasklist_lock&n;&t;&t; * so it cannot run concurrently to this loop. So we have the&n;&t;&t; * guarantee that if we find p and it has a perfmon ctx then&n;&t;&t; * it is going to stay like this for the entire execution of this&n;&t;&t; * loop.&n;&t;&t; */
id|ctx
op_assign
id|p-&gt;thread.pfm_context
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; [%d] scanning task [%d] ctx=%p&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
comma
id|ctx
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_notify_task
op_eq
id|task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; trying for notifier %d in %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the spinlock is required to take care of a race condition&n;&t;&t;&t; * with the send_sig_info() call. We must make sure that &n;&t;&t;&t; * either the send_sig_info() completes using a valid task,&n;&t;&t;&t; * or the notify_task is cleared before the send_sig_info()&n;&t;&t;&t; * can pick up a stale value. Note that by the time this&n;&t;&t;&t; * function is executed the &squot;task&squot; is already detached from the&n;&t;&t;&t; * tasklist. The problem is that the notifiers have a direct&n;&t;&t;&t; * pointer to it. It is okay to send a signal to a task in this&n;&t;&t;&t; * stage, it simply will have no effect. But it is better than sending&n;&t;&t;&t; * to a completely destroyed task or worse to a new task using the same&n;&t;&t;&t; * task_struct address.&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
id|ctx-&gt;ctx_notify_task
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_lock
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; done for notifier %d in %d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
