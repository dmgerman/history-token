multiline_comment|/*&n; * This file contains the code to configure and read/write the ia64 performance&n; * monitoring stuff.&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; * Modifications by Stephane Eranian, Hewlett-Packard Co.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; * Copyright (C) 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; * Copyright (C) 2000-2001 Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/efi.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt; /* for ia64_get_itc() */
macro_line|#ifdef CONFIG_PERFMON
DECL|macro|PFM_VERSION
mdefine_line|#define PFM_VERSION&t;&t;&quot;0.2&quot;
DECL|macro|PFM_SMPL_HDR_VERSION
mdefine_line|#define PFM_SMPL_HDR_VERSION&t;1
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4&t;/* first generic counter */
DECL|macro|PFM_WRITE_PMCS
mdefine_line|#define PFM_WRITE_PMCS&t;&t;0xa0
DECL|macro|PFM_WRITE_PMDS
mdefine_line|#define PFM_WRITE_PMDS&t;&t;0xa1
DECL|macro|PFM_READ_PMDS
mdefine_line|#define PFM_READ_PMDS&t;&t;0xa2
DECL|macro|PFM_STOP
mdefine_line|#define PFM_STOP&t;&t;0xa3
DECL|macro|PFM_START
mdefine_line|#define PFM_START&t;&t;0xa4
DECL|macro|PFM_ENABLE
mdefine_line|#define PFM_ENABLE&t;&t;0xa5&t;/* unfreeze only */
DECL|macro|PFM_DISABLE
mdefine_line|#define PFM_DISABLE&t;&t;0xa6&t;/* freeze only */
DECL|macro|PFM_RESTART
mdefine_line|#define PFM_RESTART&t;&t;0xcf
DECL|macro|PFM_CREATE_CONTEXT
mdefine_line|#define PFM_CREATE_CONTEXT&t;0xa7
multiline_comment|/*&n; * Those 2 are just meant for debugging. I considered using sysctl() for&n; * that but it is a little bit too pervasive. This solution is at least&n; * self-contained.&n; */
DECL|macro|PFM_DEBUG_ON
mdefine_line|#define PFM_DEBUG_ON&t;&t;0xe0
DECL|macro|PFM_DEBUG_OFF
mdefine_line|#define PFM_DEBUG_OFF&t;&t;0xe1
multiline_comment|/*&n; * perfmon API flags&n; */
DECL|macro|PFM_FL_INHERIT_NONE
mdefine_line|#define PFM_FL_INHERIT_NONE&t; 0x00&t;/* never inherit a context across fork (default) */
DECL|macro|PFM_FL_INHERIT_ONCE
mdefine_line|#define PFM_FL_INHERIT_ONCE&t; 0x01&t;/* clone pfm_context only once across fork() */
DECL|macro|PFM_FL_INHERIT_ALL
mdefine_line|#define PFM_FL_INHERIT_ALL&t; 0x02&t;/* always clone pfm_context across fork() */
DECL|macro|PFM_FL_SMPL_OVFL_NOBLOCK
mdefine_line|#define PFM_FL_SMPL_OVFL_NOBLOCK 0x04&t;/* do not block on sampling buffer overflow */
DECL|macro|PFM_FL_SYSTEMWIDE
mdefine_line|#define PFM_FL_SYSTEMWIDE&t; 0x08&t;/* create a systemwide context */
multiline_comment|/*&n; * PMC API flags&n; */
DECL|macro|PFM_REGFL_OVFL_NOTIFY
mdefine_line|#define PFM_REGFL_OVFL_NOTIFY&t;1&t;&t;/* send notification on overflow */
multiline_comment|/*&n; * Private flags and masks&n; */
DECL|macro|PFM_FL_INHERIT_MASK
mdefine_line|#define PFM_FL_INHERIT_MASK&t;(PFM_FL_INHERIT_NONE|PFM_FL_INHERIT_ONCE|PFM_FL_INHERIT_ALL)
macro_line|#ifdef CONFIG_SMP
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i) (cpu_online_map &amp; (1UL &lt;&lt; i))
macro_line|#else
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;1
macro_line|#endif
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;&t;(i &lt; pmu_conf.num_pmcs &amp;&amp; pmu_conf.impl_regs[i&gt;&gt;6] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;(i &lt; pmu_conf.num_pmds &amp;&amp;  pmu_conf.impl_regs[4+(i&gt;&gt;6)] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_COUNTER
mdefine_line|#define PMD_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
DECL|macro|PMC_IS_COUNTER
mdefine_line|#define PMC_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
multiline_comment|/* This is the Itanium-specific PMC layout for counter config */
r_typedef
r_struct
(brace
DECL|member|pmc_plm
r_int
r_int
id|pmc_plm
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* privilege level mask */
DECL|member|pmc_ev
r_int
r_int
id|pmc_ev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* external visibility */
DECL|member|pmc_oi
r_int
r_int
id|pmc_oi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* overflow interrupt */
DECL|member|pmc_pm
r_int
r_int
id|pmc_pm
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* privileged monitor */
DECL|member|pmc_ig1
r_int
r_int
id|pmc_ig1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_es
r_int
r_int
id|pmc_es
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* event select */
DECL|member|pmc_ig2
r_int
r_int
id|pmc_ig2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_umask
r_int
r_int
id|pmc_umask
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* unit mask */
DECL|member|pmc_thres
r_int
r_int
id|pmc_thres
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* threshold */
DECL|member|pmc_ig3
r_int
r_int
id|pmc_ig3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved (missing from table on p6-17) */
DECL|member|pmc_ism
r_int
r_int
id|pmc_ism
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* instruction set mask */
DECL|member|pmc_ig4
r_int
r_int
id|pmc_ig4
suffix:colon
l_int|38
suffix:semicolon
multiline_comment|/* reserved */
DECL|typedef|pmc_counter_reg_t
)brace
id|pmc_counter_reg_t
suffix:semicolon
multiline_comment|/* test for EAR/BTB configuration */
DECL|macro|PMU_DEAR_EVENT
mdefine_line|#define PMU_DEAR_EVENT&t;0x67
DECL|macro|PMU_IEAR_EVENT
mdefine_line|#define PMU_IEAR_EVENT&t;0x23
DECL|macro|PMU_BTB_EVENT
mdefine_line|#define PMU_BTB_EVENT&t;0x11
DECL|macro|PMC_IS_DEAR
mdefine_line|#define PMC_IS_DEAR(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_DEAR_EVENT)
DECL|macro|PMC_IS_IEAR
mdefine_line|#define PMC_IS_IEAR(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_IEAR_EVENT)
DECL|macro|PMC_IS_BTB
mdefine_line|#define PMC_IS_BTB(a)&t;&t;(((pmc_counter_reg_t *)(a))-&gt;pmc_es == PMU_BTB_EVENT)
multiline_comment|/*&n; * This header is at the beginning of the sampling buffer returned to the user.&n; * It is exported as Read-Only at this point. It is directly followed with the&n; * first record.&n; */
r_typedef
r_struct
(brace
DECL|member|hdr_version
r_int
id|hdr_version
suffix:semicolon
multiline_comment|/* could be used to differentiate formats */
DECL|member|hdr_reserved
r_int
id|hdr_reserved
suffix:semicolon
DECL|member|hdr_entry_size
r_int
r_int
id|hdr_entry_size
suffix:semicolon
multiline_comment|/* size of one entry in bytes */
DECL|member|hdr_count
r_int
r_int
id|hdr_count
suffix:semicolon
multiline_comment|/* how many valid entries */
DECL|member|hdr_pmds
r_int
r_int
id|hdr_pmds
suffix:semicolon
multiline_comment|/* which pmds are recorded */
DECL|typedef|perfmon_smpl_hdr_t
)brace
id|perfmon_smpl_hdr_t
suffix:semicolon
multiline_comment|/*&n; * Header entry in the buffer as a header as follows.&n; * The header is directly followed with the PMDS to saved in increasing index order:&n; * PMD4, PMD5, .... How many PMDs are present is determined by the tool which must&n; * keep track of it when generating the final trace file.&n; */
r_typedef
r_struct
(brace
DECL|member|pid
r_int
id|pid
suffix:semicolon
multiline_comment|/* identification of process */
DECL|member|cpu
r_int
id|cpu
suffix:semicolon
multiline_comment|/* which cpu was used */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
multiline_comment|/* initial value of this counter */
DECL|member|stamp
r_int
r_int
id|stamp
suffix:semicolon
multiline_comment|/* timestamp */
DECL|member|ip
r_int
r_int
id|ip
suffix:semicolon
multiline_comment|/* where did the overflow interrupt happened */
DECL|member|regs
r_int
r_int
id|regs
suffix:semicolon
multiline_comment|/* which registers overflowed (up to 64)*/
DECL|typedef|perfmon_smpl_entry_t
)brace
id|perfmon_smpl_entry_t
suffix:semicolon
multiline_comment|/*&n; * There is one such data structure per perfmon context. It is used to describe the&n; * sampling buffer. It is to be shared among siblings whereas the pfm_context isn&squot;t.&n; * Therefore we maintain a refcnt which is incremented on fork().&n; * This buffer is private to the kernel only the actual sampling buffer including its&n; * header are exposed to the user. This construct allows us to export the buffer read-write,&n; * if needed, without worrying about security problems.&n; */
r_typedef
r_struct
(brace
DECL|member|psb_refcnt
id|atomic_t
id|psb_refcnt
suffix:semicolon
multiline_comment|/* how many users for the buffer */
DECL|member|reserved
r_int
id|reserved
suffix:semicolon
DECL|member|psb_addr
r_void
op_star
id|psb_addr
suffix:semicolon
multiline_comment|/* points to location of first entry */
DECL|member|psb_entries
r_int
r_int
id|psb_entries
suffix:semicolon
multiline_comment|/* maximum number of entries */
DECL|member|psb_size
r_int
r_int
id|psb_size
suffix:semicolon
multiline_comment|/* aligned size of buffer */
DECL|member|psb_index
r_int
r_int
id|psb_index
suffix:semicolon
multiline_comment|/* next free entry slot */
DECL|member|psb_entry_size
r_int
r_int
id|psb_entry_size
suffix:semicolon
multiline_comment|/* size of each entry including entry header */
DECL|member|psb_hdr
id|perfmon_smpl_hdr_t
op_star
id|psb_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header */
DECL|typedef|pfm_smpl_buffer_desc_t
)brace
id|pfm_smpl_buffer_desc_t
suffix:semicolon
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristic as indicated&n; * by PAL&n; */
r_typedef
r_struct
(brace
DECL|member|pfm_is_disabled
r_int
r_int
id|pfm_is_disabled
suffix:semicolon
multiline_comment|/* indicates if perfmon is working properly */
DECL|member|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters   */
DECL|member|max_counters
r_int
r_int
id|max_counters
suffix:semicolon
multiline_comment|/* upper limit on counter pair (PMC/PMD) */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* highest PMC implemented (may have holes) */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* highest PMD implemented (may have holes) */
DECL|member|impl_regs
r_int
r_int
id|impl_regs
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* buffer used to hold implememted PMC/PMD mask */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
DECL|macro|PERFMON_IS_DISABLED
mdefine_line|#define PERFMON_IS_DISABLED() pmu_conf.pfm_is_disabled
r_typedef
r_struct
(brace
DECL|member|val
id|__u64
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|ival
id|__u64
id|ival
suffix:semicolon
multiline_comment|/* initial value from user */
DECL|member|smpl_rval
id|__u64
id|smpl_rval
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|ovfl_rval
id|__u64
id|ovfl_rval
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
DECL|macro|PMD_OVFL_NOTIFY
mdefine_line|#define PMD_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
multiline_comment|/*&n; * perfmon context. One per process, is cloned on fork() depending on inheritance flags&n; */
r_typedef
r_struct
(brace
DECL|member|inherit
r_int
r_int
id|inherit
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* inherit mode */
DECL|member|noblock
r_int
r_int
id|noblock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* block/don&squot;t block on overflow with notification */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|frozen
r_int
r_int
id|frozen
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* pmu must be kept frozen on ctxsw in */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|27
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_smpl_buf
id|pfm_smpl_buffer_desc_t
op_star
id|ctx_smpl_buf
suffix:semicolon
multiline_comment|/* sampling buffer descriptor, if any */
DECL|member|ctx_dear_counter
r_int
r_int
id|ctx_dear_counter
suffix:semicolon
multiline_comment|/* which PMD holds D-EAR */
DECL|member|ctx_iear_counter
r_int
r_int
id|ctx_iear_counter
suffix:semicolon
multiline_comment|/* which PMD holds I-EAR */
DECL|member|ctx_btb_counter
r_int
r_int
id|ctx_btb_counter
suffix:semicolon
multiline_comment|/* which PMD holds BTB */
DECL|member|ctx_notify_pid
id|pid_t
id|ctx_notify_pid
suffix:semicolon
multiline_comment|/* who to notify on overflow */
DECL|member|ctx_notify_sig
r_int
id|ctx_notify_sig
suffix:semicolon
multiline_comment|/* XXX: SIGPROF or other */
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* block/noblock */
DECL|member|ctx_creator
id|pid_t
id|ctx_creator
suffix:semicolon
multiline_comment|/* pid of creator (debug) */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
suffix:semicolon
multiline_comment|/* which registers just overflowed (notification) */
DECL|member|ctx_smpl_regs
r_int
r_int
id|ctx_smpl_regs
suffix:semicolon
multiline_comment|/* which registers to record on overflow */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_pmds
id|pfm_counter_t
id|ctx_pmds
(braket
id|IA64_NUM_PMD_COUNTERS
)braket
suffix:semicolon
multiline_comment|/* XXX: size should be dynamic */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
DECL|macro|ctx_fl_inherit
mdefine_line|#define ctx_fl_inherit&t;ctx_flags.inherit
DECL|macro|ctx_fl_noblock
mdefine_line|#define ctx_fl_noblock&t;ctx_flags.noblock
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;ctx_flags.system
DECL|macro|ctx_fl_frozen
mdefine_line|#define ctx_fl_frozen&t;ctx_flags.frozen
DECL|macro|CTX_IS_DEAR
mdefine_line|#define CTX_IS_DEAR(c,n)&t;((c)-&gt;ctx_dear_counter == (n))
DECL|macro|CTX_IS_IEAR
mdefine_line|#define CTX_IS_IEAR(c,n)&t;((c)-&gt;ctx_iear_counter == (n))
DECL|macro|CTX_IS_BTB
mdefine_line|#define CTX_IS_BTB(c,n)&t;&t;((c)-&gt;ctx_btb_counter == (n))
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_noblock == 1)
DECL|macro|CTX_INHERIT_MODE
mdefine_line|#define CTX_INHERIT_MODE(c)&t;((c)-&gt;ctx_fl_inherit)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_smpl_buf != NULL)
DECL|variable|pmu_conf
r_static
id|pmu_config_t
id|pmu_conf
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|pfm_debug
r_static
r_int
r_int
id|pfm_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0= nodebug, &gt;0= debug output on */
DECL|macro|DBprintk
mdefine_line|#define DBprintk(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (pfm_debug &gt;0) { printk(__FUNCTION__&quot; &quot;); printk a; } &bslash;&n;&t;} while (0);
r_static
r_void
id|perfmon_softint
c_func
(paren
r_int
r_int
id|ignored
)paren
suffix:semicolon
r_static
r_void
id|ia64_reset_pmu
c_func
(paren
r_void
)paren
suffix:semicolon
id|DECLARE_TASKLET
c_func
(paren
id|pfm_tasklet
comma
id|perfmon_softint
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * structure used to pass information between the interrupt handler&n; * and the tasklet.&n; */
r_typedef
r_struct
(brace
DECL|member|to_pid
id|pid_t
id|to_pid
suffix:semicolon
multiline_comment|/* which process to notify */
DECL|member|from_pid
id|pid_t
id|from_pid
suffix:semicolon
multiline_comment|/* which process is source of overflow */
DECL|member|sig
r_int
id|sig
suffix:semicolon
multiline_comment|/* with which signal */
DECL|member|bitvect
r_int
r_int
id|bitvect
suffix:semicolon
multiline_comment|/* which counters have overflowed */
DECL|typedef|notification_info_t
)brace
id|notification_info_t
suffix:semicolon
DECL|macro|notification_is_invalid
mdefine_line|#define notification_is_invalid(i)&t;(i-&gt;to_pid &lt; 2)
multiline_comment|/* will need to be cache line padded */
DECL|variable|notify_info
r_static
id|notification_info_t
id|notify_info
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; * We force cache line alignment to avoid false sharing&n; * given that we have one entry per CPU.&n; */
r_static
r_struct
(brace
DECL|member|owner
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
DECL|variable|pmu_owners
)brace
id|____cacheline_aligned
id|pmu_owners
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* helper macros */
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t)&t;do { pmu_owners[smp_processor_id()].owner = (t); } while(0);
DECL|macro|PMU_OWNER
mdefine_line|#define PMU_OWNER()&t;&t;pmu_owners[smp_processor_id()].owner
multiline_comment|/* for debug only */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
multiline_comment|/*&n; * finds the number of PM(C|D) registers given&n; * the bitvector returned by PAL&n; */
r_static
r_int
r_int
id|__init
DECL|function|find_num_pm_regs
id|find_num_pm_regs
c_func
(paren
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 words/per bitvector */
multiline_comment|/* start from the most significant word */
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|buffer
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: No bit set in pm_buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
op_plus
id|ia64_fls
c_func
(paren
id|buffer
(braket
id|i
)braket
)paren
op_plus
l_int|64
op_star
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates a unique (per CPU) timestamp&n; */
r_static
r_inline
r_int
r_int
DECL|function|perfmon_get_stamp
id|perfmon_get_stamp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * XXX: maybe find something more efficient&n;&t; */
r_return
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Given PGD from the address space&squot;s page table, return the kernel&n; * virtual mapping of the physical memory mapped at ADR.&n; */
r_static
r_inline
r_int
r_int
DECL|function|uvirt_to_kva
id|uvirt_to_kva
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0UL
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|adr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|adr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|ret
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|ret
op_or_assign
(paren
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;uv2kva(%lx--&gt;%lx)&bslash;n&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
r_static
r_inline
r_int
r_int
DECL|function|kvirt_to_pa
id|kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;tpa %0 = %1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pa
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|adr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;kv2pa(%lx--&gt;%lx)&bslash;n&quot;
comma
id|adr
comma
id|pa
)paren
)paren
suffix:semicolon
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|rvmalloc
id|rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
multiline_comment|/* XXX: may have to revisit this part because&n;&t; * vmalloc() does not necessarily return a page-aligned buffer.&n;&t; * This maybe a security problem when mapped at user level&n;&t; */
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|rvfree
id|rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
)brace
r_static
id|pfm_context_t
op_star
DECL|function|pfm_context_alloc
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|pfc
suffix:semicolon
multiline_comment|/* allocate context descriptor */
id|pfc
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pfc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfc
)paren
id|memset
c_func
(paren
id|pfc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pfc
)paren
)paren
suffix:semicolon
r_return
id|pfc
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_context_free
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|pfc
)paren
(brace
r_if
c_cond
(paren
id|pfc
)paren
id|vfree
c_func
(paren
id|pfc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_remap_buffer
id|pfm_remap_buffer
c_func
(paren
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * counts the number of PMDS to save per entry.&n; * This code is generic enough to accomodate more than 64 PMDS when they become available&n; */
r_static
r_int
r_int
DECL|function|pfm_smpl_entry_size
id|pfm_smpl_entry_size
c_func
(paren
r_int
r_int
op_star
id|which
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
comma
id|which
op_increment
)paren
id|res
op_add_assign
id|hweight64
c_func
(paren
op_star
id|which
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; res=%ld&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates the sampling buffer and remaps it into caller&squot;s address space&n; */
r_static
r_int
DECL|function|pfm_smpl_buffer_alloc
id|pfm_smpl_buffer_alloc
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|which_pmds
comma
r_int
r_int
id|entries
comma
r_void
op_star
op_star
id|user_addr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|addr
comma
id|size
comma
id|regcount
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
id|regcount
op_assign
id|pfm_smpl_entry_size
c_func
(paren
op_amp
id|which_pmds
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* note that regcount might be 0, in this case only the header for each&n;&t; * entry will be recorded.&n;&t; */
multiline_comment|/*&n;&t; * 1 buffer hdr and for each entry a header + regcount PMDs to save&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
op_plus
id|entries
op_star
(paren
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* find some free area in address space */
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_goto
id|no_addr
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; entries=%ld aligned size=%ld, unmapped @0x%lx&bslash;n&quot;
comma
id|entries
comma
id|size
comma
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|no_vma
suffix:semicolon
multiline_comment|/* XXX: see rvmalloc() for page alignment problem */
id|smpl_buf
op_assign
id|rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
r_goto
id|no_buffer
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; smpl_buf @%p&bslash;n&quot;
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|addr
comma
id|size
)paren
)paren
r_goto
id|cant_remap
suffix:semicolon
multiline_comment|/* allocate sampling buffer descriptor now */
id|psb
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|psb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
r_goto
id|no_buffer_desc
suffix:semicolon
multiline_comment|/* start with something clean */
id|memset
c_func
(paren
id|smpl_buf
comma
l_int|0x0
comma
id|size
)paren
suffix:semicolon
id|psb-&gt;psb_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|psb-&gt;psb_addr
op_assign
(paren
r_char
op_star
)paren
id|smpl_buf
op_plus
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
suffix:semicolon
multiline_comment|/* first entry */
id|psb-&gt;psb_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
id|psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
id|psb-&gt;psb_entries
op_assign
id|entries
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|psb-&gt;psb_refcnt
comma
l_int|1
)paren
suffix:semicolon
id|psb-&gt;psb_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; psb @%p entry_size=%ld hdr=%p addr=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|psb
comma
id|psb-&gt;psb_entry_size
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_hdr
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some of the fields of header */
id|psb-&gt;psb_hdr-&gt;hdr_version
op_assign
id|PFM_SMPL_HDR_VERSION
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_pmds
op_assign
id|which_pmds
suffix:semicolon
multiline_comment|/* store which PMDS to record */
id|ctx-&gt;ctx_smpl_regs
op_assign
id|which_pmds
suffix:semicolon
multiline_comment|/* link to perfmon context */
id|ctx-&gt;ctx_smpl_buf
op_assign
id|psb
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the vma for the sampling buffer&n;&t; */
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|VM_READ
op_or
id|VM_MAYREAD
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
multiline_comment|/* XXX may need to change */
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
id|ctx
suffix:semicolon
multiline_comment|/* link to pfm_context(not yet used) */
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * that&squot;s the address returned to the user&n;&t; */
op_star
id|user_addr
op_assign
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* outlined error handling */
id|no_addr
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|no_vma
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|cant_remap
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
id|no_buffer
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|no_buffer_desc
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer descriptor&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfx_is_sane
id|pfx_is_sane
c_func
(paren
id|pfreq_context_t
op_star
id|pfx
)paren
(brace
multiline_comment|/* valid signal */
r_if
c_cond
(paren
id|pfx-&gt;notify_sig
OL
l_int|1
op_logical_or
id|pfx-&gt;notify_sig
op_ge
id|_NSIG
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* cannot send to process 1, 0 means do not notify */
r_if
c_cond
(paren
id|pfx-&gt;notify_pid
OL
l_int|0
op_logical_or
id|pfx-&gt;notify_pid
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* asked for sampling, but nothing to record ! */
r_if
c_cond
(paren
id|pfx-&gt;smpl_entries
OG
l_int|0
op_logical_and
id|pfm_smpl_entry_size
c_func
(paren
op_amp
id|pfx-&gt;smpl_regs
comma
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* probably more to add here */
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_context_create
id|pfm_context_create
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
multiline_comment|/* to go away */
r_if
c_cond
(paren
id|flags
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: use context flags instead of perfmon() flags. Obsoleted API&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ctx_flags
op_assign
id|tmp.pfr_ctx.flags
suffix:semicolon
multiline_comment|/* not yet supported */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEMWIDE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfx_is_sane
c_func
(paren
op_amp
id|tmp.pfr_ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* record who the creator is (for debug) */
id|ctx-&gt;ctx_creator
op_assign
id|task-&gt;pid
suffix:semicolon
id|ctx-&gt;ctx_notify_pid
op_assign
id|tmp.pfr_ctx.notify_pid
suffix:semicolon
id|ctx-&gt;ctx_notify_sig
op_assign
id|SIGPROF
suffix:semicolon
multiline_comment|/* siginfo imposes a fixed signal */
r_if
c_cond
(paren
id|tmp.pfr_ctx.smpl_entries
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; sampling entries=%ld&bslash;n&quot;
comma
id|tmp.pfr_ctx.smpl_entries
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|ctx
comma
id|tmp.pfr_ctx.smpl_regs
comma
id|tmp.pfr_ctx.smpl_entries
comma
op_amp
id|uaddr
)paren
)paren
)paren
r_goto
id|buffer_error
suffix:semicolon
id|tmp.pfr_ctx.smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
multiline_comment|/* initialization of context&squot;s flags */
id|ctx-&gt;ctx_fl_inherit
op_assign
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
suffix:semicolon
id|ctx-&gt;ctx_fl_noblock
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SMPL_OVFL_NOBLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEMWIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* init this semaphore to locked */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|buffer_error
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; context=%p, pid=%d notify_sig %d notify_pid=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_sig
comma
id|ctx-&gt;ctx_notify_pid
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; context=%p, pid=%d flags=0x%x inherit=%d noblock=%d system=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_inherit
comma
id|ctx-&gt;ctx_fl_noblock
comma
id|ctx-&gt;ctx_fl_system
)paren
)paren
suffix:semicolon
multiline_comment|/* link with task */
id|task-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|vfree
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_reset_regs
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ctx-&gt;ctx_ovfl_regs
suffix:semicolon
r_int
id|i
comma
id|cnum
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; ovfl_regs=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
comma
id|cnum
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; reseting PMD[%d]=%lx&bslash;n&quot;
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* upper part is ignored on rval */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|pfm_write_pmcs
id|pfm_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.pfr_reg.reg_num
suffix:semicolon
multiline_comment|/* XXX needs to check validity of the data maybe */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; invalid pmc[%ld]&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMC_IS_COUNTER
c_func
(paren
id|cnum
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we keep track of EARS/BTB to speed up sampling later&n;&t;&t;&t; */
r_if
c_cond
(paren
id|PMC_IS_DEAR
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_dear_counter
op_assign
id|cnum
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PMC_IS_IEAR
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_iear_counter
op_assign
id|cnum
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PMC_IS_BTB
c_func
(paren
op_amp
id|tmp.pfr_reg.reg_value
)paren
)paren
(brace
id|ctx-&gt;ctx_btb_counter
op_assign
id|cnum
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.pfr_reg.reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
id|ctx-&gt;ctx_pmds
(braket
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|tmp.pfr_reg.reg_value
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; setting PMC[%ld]=0x%lx flags=0x%x&bslash;n&quot;
comma
id|cnum
comma
id|tmp.pfr_reg.reg_value
comma
id|ctx-&gt;ctx_pmds
(braket
id|cnum
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t; * because we may be context switched out&n;&t; */
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_write_pmds
id|pfm_write_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.pfr_reg.reg_num
suffix:semicolon
id|k
op_assign
id|cnum
op_minus
id|PMU_FIRST_COUNTER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* update virtualized (64bits) counter */
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ival
op_assign
id|tmp.pfr_reg.reg_value
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|val
op_assign
id|tmp.pfr_reg.reg_value
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|smpl_rval
op_assign
id|tmp.pfr_reg.reg_smpl_reset
suffix:semicolon
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ovfl_rval
op_assign
id|tmp.pfr_reg.reg_ovfl_reset
suffix:semicolon
)brace
multiline_comment|/* writes to unimplemented part is ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|tmp.pfr_reg.reg_value
)paren
suffix:semicolon
multiline_comment|/* to go away */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; setting PMD[%ld]:  pmd.val=0x%lx pmd.ovfl_rval=0x%lx pmd.smpl_rval=0x%lx pmd=%lx&bslash;n&quot;
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|val
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|ovfl_rval
comma
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|smpl_rval
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t; * because we may be context switched out&n;&t; */
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_read_pmds
id|pfm_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: MUST MAKE SURE WE DON&quot;T HAVE ANY PENDING OVERFLOW BEFORE READING&n;&t; * This is required when the monitoring has been stoppped by user of kernel.&n;&t; * If ity is still going on, then that&squot;s fine because we a re not gauranteed&n;&t; * to return an accurate value in this case&n;&t; */
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|k
op_assign
id|tmp.pfr_reg.reg_num
op_minus
id|PMU_FIRST_COUNTER
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
)paren
(brace
r_if
c_cond
(paren
id|ta
op_eq
id|current
)paren
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|th-&gt;pmd
(braket
id|k
)braket
suffix:semicolon
)brace
id|val
op_and_assign
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * lower part of .val may not be zero, so we must be an addition because of&n;&t;&t;&t; * residual count (see update_counters).&n;&t;&t;&t; */
id|val
op_add_assign
id|ctx-&gt;ctx_pmds
(braket
id|k
)braket
dot
id|val
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* for now */
r_if
c_cond
(paren
id|ta
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg.reg_num
)paren
suffix:semicolon
)brace
id|tmp.pfr_reg.reg_value
op_assign
id|val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; reading PMD[%ld]=0x%lx&bslash;n&quot;
comma
id|tmp.pfr_reg.reg_num
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfm_do_restart
id|pfm_do_restart
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
r_void
op_star
id|sem
op_assign
op_amp
id|ctx-&gt;ctx_restart_sem
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; restartig self %d frozen=%d &bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_frozen
)paren
)paren
suffix:semicolon
id|pfm_reset_regs
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We ignore block/don&squot;t block because we never block&n;&t;&t; * for a self-monitoring process.&n;&t;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* pfm_reset_smpl_buffers(ctx,th-&gt;pfm_ovfl_regs);*/
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check if blocking */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; unblocking %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in case of non blocking mode, then it&squot;s just a matter of&n;&t; * of reseting the sampling buffer (if any) index. The PMU&n;&t; * is already active.&n;&t; */
multiline_comment|/*&n;&t; * must reset the header count first&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; resetting sampling indexes for %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_perfmonctl
id|do_perfmonctl
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|perfmon_req_t
id|tmp
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PFM_CREATE_CONTEXT
suffix:colon
multiline_comment|/* a context has already been defined */
r_if
c_cond
(paren
id|ctx
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* may be a temporary limitation */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
op_logical_or
id|count
op_ne
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|pfm_context_create
c_func
(paren
id|task
comma
id|flags
comma
id|req
)paren
suffix:semicolon
r_case
id|PFM_WRITE_PMCS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_WRITE_PMCS: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|pfm_write_pmcs
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_WRITE_PMDS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_WRITE_PMDS: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|pfm_write_pmds
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_START
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_START: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|SET_PMU_OWNER
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* will start monitoring right after rfi */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * mark the state as valid.&n;&t;&t;&t; * this will trigger save/restore at context switch&n;&t;&t;&t; */
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_ENABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_ENABLE: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* reset all registers to stable quiet state */
id|ia64_reset_pmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure nothing starts */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do it on the live register as well */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp|psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * mark the state as valid.&n;&t;&t;&t; * this will trigger save/restore at context switch&n;&t;&t;&t; */
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DISABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* simply freeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_READ_PMDS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PFM_READ_PMDS: no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|pfm_read_pmds
c_func
(paren
id|task
comma
id|req
comma
id|count
)paren
suffix:semicolon
r_case
id|PFM_STOP
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|th-&gt;flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we probably will need some more cleanup here */
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_ON
suffix:colon
id|printk
c_func
(paren
l_string|&quot; debugging on&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_OFF
suffix:colon
id|printk
c_func
(paren
l_string|&quot; debugging off&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_RESTART
suffix:colon
multiline_comment|/* temporary, will most likely end up as a PFM_ENABLE */
r_if
c_cond
(paren
(paren
id|th-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; PFM_RESTART not monitoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; PFM_RESTART no ctx for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task %d without pmu_frozen set&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|pfm_do_restart
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* we only look at first entry */
r_default
suffix:colon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; UNknown command 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
DECL|function|perfmon_bad_permissions
id|perfmon_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* stolen from bad_signal() */
r_return
(paren
id|current-&gt;session
op_ne
id|task-&gt;session
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;uid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;uid
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|task_struct
op_star
id|child
op_assign
id|current
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
multiline_comment|/* sanity check:&n;&t; *&n;&t; * ensures that we don&squot;t do bad things in case the OS&n;&t; * does not have enough storage to save/restore PMC/PMD&n;&t; */
r_if
c_cond
(paren
id|PERFMON_IS_DISABLED
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* XXX: pid interface is going away in favor of pfm context */
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
(brace
id|child
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
)paren
id|get_task_struct
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|child
)paren
r_goto
id|abort_call
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|perfmon_bad_permissions
c_func
(paren
id|child
)paren
)paren
r_goto
id|abort_call
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: need to do more checking here&n;&t;&t; */
r_if
c_cond
(paren
id|child-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|child-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; warning process %d not in stable state %ld&bslash;n&quot;
comma
id|pid
comma
id|child-&gt;state
)paren
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|do_perfmonctl
c_func
(paren
id|child
comma
id|cmd
comma
id|flags
comma
id|req
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|abort_call
suffix:colon
r_if
c_cond
(paren
id|child
op_ne
id|current
)paren
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is invoked on the exit path of the kernel. Therefore it must make sure&n; * it does does modify the caller&squot;s input registers (in0-in7) in case of entry by system call&n; * which can be restarted. That&squot;s why it&squot;s declared as a system call and all 8 possible args&n; * are declared even though not used.&n; */
macro_line|#if __GNUC__ &gt;= 3
r_void
id|asmlinkage
DECL|function|pfm_overflow_notify
id|pfm_overflow_notify
c_func
(paren
r_void
)paren
macro_line|#else
r_void
id|asmlinkage
id|pfm_overflow_notify
c_func
(paren
id|u64
id|arg0
comma
id|u64
id|arg1
comma
id|u64
id|arg2
comma
id|u64
id|arg3
comma
id|u64
id|arg4
comma
id|u64
id|arg5
comma
id|u64
id|arg6
comma
id|u64
id|arg7
)paren
macro_line|#endif
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * do some sanity checks first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: process %d has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_pid
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: process %d invalid notify_pid=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_notify_pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; current=%d ctx=%p bv=0%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NO matter what notify_pid is,&n;&t; * we clear overflow, won&squot;t notify again&n;&t; */
id|th-&gt;pfm_pend_notify
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * When measuring in kernel mode and non-blocking fashion, it is possible to&n;&t; * get an overflow while executing this code. Therefore the state of pend_notify&n;&t; * and ovfl_regs can be altered. The important point is not to loose any notification.&n;&t; * It is fine to get called for nothing. To make sure we do collect as much state as&n;&t; * possible, update_counters() always uses |= to add bit to the ovfl_regs field.&n;&t; *&n;&t; * In certain cases, it is possible to come here, with ovfl_regs == 0;&n;&t; *&n;&t; * XXX: pend_notify and ovfl_regs could be merged maybe !&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_ovfl_regs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: spurious overflow notification from pid %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|task
op_assign
id|find_task_by_pid
c_func
(paren
id|ctx-&gt;ctx_notify_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
)paren
(brace
id|si.si_signo
op_assign
id|ctx-&gt;ctx_notify_sig
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
multiline_comment|/* goes to user */
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|current-&gt;pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_pfm_ovfl
op_assign
id|ctx-&gt;ctx_ovfl_regs
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; SIGPROF to %d @ %p&bslash;n&quot;
comma
id|task-&gt;pid
comma
(paren
r_void
op_star
)paren
id|task
)paren
)paren
suffix:semicolon
multiline_comment|/* must be done with tasklist_lock locked */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|ctx-&gt;ctx_notify_sig
comma
op_amp
id|si
comma
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_notify_pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* will cause return */
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: notify_pid %d not found&bslash;n&quot;
comma
id|ctx-&gt;ctx_notify_pid
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/* now that we have released the lock handle error condition */
r_if
c_cond
(paren
op_logical_neg
id|task
op_logical_or
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
(brace
multiline_comment|/* we clear all pending overflow bits in noblock mode */
id|ctx-&gt;ctx_ovfl_regs
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d before sleep&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d after sleep ret=%d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
multiline_comment|/* we reactivate on context switch */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the ovfl_sem is cleared by the restart task and this is safe because we always&n;&t;&t; * use the local reference&n;&t;&t; */
id|pfm_reset_regs
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* now we can clear this mask */
id|ctx-&gt;ctx_ovfl_regs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Unlock sampling buffer and reset index atomically&n;&t;&t; * XXX: not really needed when blocking&n;&t;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_smpl_buf-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_smpl_buf-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d %d unfreeze PMU&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* state restored, can go back to work (user mode) */
)brace
)brace
r_static
r_void
DECL|function|perfmon_softint
id|perfmon_softint
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
id|notification_info_t
op_star
id|info
suffix:semicolon
r_int
id|my_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
id|info
op_assign
id|notify_info
op_plus
id|my_cpu
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d current=%d to_pid=%d from_pid=%d bv=0x%lx&bslash;n&quot;
comma
"&bslash;"
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
comma
id|info-&gt;to_pid
comma
id|info-&gt;from_pid
comma
id|info-&gt;bitvect
)paren
)paren
suffix:semicolon
multiline_comment|/* assumption check */
r_if
c_cond
(paren
id|info-&gt;from_pid
op_eq
id|info-&gt;to_pid
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; Tasklet assumption error: from=%d tor=%d&bslash;n&quot;
comma
id|info-&gt;from_pid
comma
id|info-&gt;to_pid
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notification_is_invalid
c_func
(paren
id|info
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; invalid notification information&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|info-&gt;to_pid
op_eq
l_int|1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; cannot notify init&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX: needs way more checks here to make sure we send to a task we have control over&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|task
op_assign
id|find_task_by_pid
c_func
(paren
id|info-&gt;to_pid
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; after find %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|task
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task
)paren
(brace
r_int
id|ret
suffix:semicolon
id|si.si_signo
op_assign
id|SIGPROF
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
multiline_comment|/* goes to user */
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|info-&gt;from_pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_pfm_ovfl
op_assign
id|info-&gt;bitvect
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; SIGPROF to %d @ %p&bslash;n&quot;
comma
id|task-&gt;pid
comma
(paren
r_void
op_star
)paren
id|task
)paren
)paren
suffix:semicolon
multiline_comment|/* must be done with tasklist_lock locked */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|SIGPROF
comma
op_amp
id|si
comma
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|DBprintk
c_func
(paren
(paren
l_string|&quot; send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|info-&gt;to_pid
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* invalidate notification */
id|info-&gt;to_pid
op_assign
id|info-&gt;from_pid
op_assign
l_int|0
suffix:semicolon
id|info-&gt;bitvect
op_assign
l_int|0
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; after unlock %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|task
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: CPU%d cannot find process %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|info-&gt;to_pid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; * Return:&n; *&t;0 : do not unfreeze the PMU&n; *&t;1 : PMU can be unfrozen&n; */
r_static
r_int
r_int
DECL|function|update_counters
id|update_counters
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
comma
id|i
comma
id|cnum
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|bv
op_assign
l_int|0
suffix:semicolon
r_int
id|my_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
comma
id|buffer_is_full
op_assign
l_int|0
suffix:semicolon
r_int
id|ovfl_is_smpl
comma
id|can_notify
comma
id|need_reset_pmd16
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * It is never safe to access the task for which the overflow interrupt is destinated&n;&t; * using the current variable as the interrupt may occur in the middle of a context switch&n;&t; * where current does not hold the task that is running yet.&n;&t; *&n;&t; * For monitoring, however, we do need to get access to the task which caused the overflow&n;&t; * to account for overflow on the counters.&n;&t; *&n;&t; * We accomplish this by maintaining a current owner of the PMU per CPU. During context&n;&t; * switch the ownership is changed in a way such that the reflected owner is always the&n;&t; * valid one, i.e. the one that caused the interrupt.&n;&t; */
r_if
c_cond
(paren
id|ta
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; owners[%d]=NULL&bslash;n&quot;
comma
id|my_cpu
)paren
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|th-&gt;pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: debug test&n;&t; * Don&squot;t think this could happen given upfront tests&n;&t; */
r_if
c_cond
(paren
(paren
id|th-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d not using perfmon&bslash;n&quot;
comma
id|ta-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d has no PFM context&bslash;n&quot;
comma
id|ta-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pid %d pmc0=0x%lx assumption error for freeze bit&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|pmc0
)paren
suffix:semicolon
r_return
l_int|0x0
suffix:semicolon
)brace
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d&bslash;n&quot;
comma
id|pmc0
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;ctx is in %s mode&bslash;n&quot;
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;NO-BLOCK&quot;
suffix:colon
l_string|&quot;BLOCK&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_smpl_buf
suffix:semicolon
r_int
r_int
op_star
id|e
comma
id|m
comma
id|idx
op_assign
l_int|0
suffix:semicolon
id|perfmon_smpl_entry_t
op_star
id|h
suffix:semicolon
r_int
id|j
suffix:semicolon
id|idx
op_assign
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_index
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; trying to record index=%ld entries=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: there is a small chance that we could run out on index before resetting&n;&t;&t; * but index is unsigned long, so it will take some time.....&n;&t;&t; */
r_if
c_cond
(paren
id|idx
OG
id|psb-&gt;psb_entries
)paren
(brace
id|buffer_is_full
op_assign
l_int|1
suffix:semicolon
r_goto
id|reload_pmds
suffix:semicolon
)brace
multiline_comment|/* first entry is really entry 0, not 1 caused by fetch_and_add */
id|idx
op_decrement
suffix:semicolon
id|h
op_assign
(paren
id|perfmon_smpl_entry_t
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|psb-&gt;psb_addr
)paren
op_plus
id|idx
op_star
(paren
id|psb-&gt;psb_entry_size
)paren
)paren
suffix:semicolon
id|h-&gt;pid
op_assign
id|ta-&gt;pid
suffix:semicolon
id|h-&gt;cpu
op_assign
id|my_cpu
suffix:semicolon
id|h-&gt;rate
op_assign
l_int|0
suffix:semicolon
id|h-&gt;ip
op_assign
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0x0
suffix:semicolon
multiline_comment|/* where did the fault happened */
id|h-&gt;regs
op_assign
id|mask
suffix:semicolon
multiline_comment|/* which registers overflowed */
multiline_comment|/* guaranteed to monotonically increase on each cpu */
id|h-&gt;stamp
op_assign
id|perfmon_get_stamp
c_func
(paren
)paren
suffix:semicolon
id|e
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * selectively store PMDs in increasing index number&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|m
op_assign
id|ctx-&gt;ctx_smpl_regs
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|m
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|j
)paren
)paren
op_star
id|e
op_assign
id|ctx-&gt;ctx_pmds
(braket
id|j
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|j
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
r_else
op_star
id|e
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
multiline_comment|/* slow */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; e=%p pmd%d =0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|e
comma
id|j
comma
op_star
id|e
)paren
)paren
suffix:semicolon
id|e
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* make the new entry visible to user, needs to be atomic */
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; index=%ld entries=%ld hdr_count=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
comma
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
)paren
suffix:semicolon
multiline_comment|/* sampling buffer full ? */
r_if
c_cond
(paren
id|idx
op_eq
(paren
id|psb-&gt;psb_entries
op_minus
l_int|1
)paren
)paren
(brace
id|bv
op_assign
id|mask
suffix:semicolon
id|buffer_is_full
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; sampling buffer full must notify bv=0x%lx&bslash;n&quot;
comma
id|bv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
r_goto
id|buffer_full
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * here, we have a full buffer but we are in non-blocking mode&n;&t;&t;&t; * so we need to reloads overflowed PMDs with sampling reset values&n;&t;&t;&t; * and restart&n;&t;&t;&t; */
)brace
)brace
id|reload_pmds
suffix:colon
id|ovfl_is_smpl
op_assign
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_logical_and
id|buffer_is_full
suffix:semicolon
id|can_notify
op_assign
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_notify_pid
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PMD[%ld] overflowed pmd=0x%lx pmod.val=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Because we sometimes (EARS/BTB) reset to a specific value, we cannot simply use&n;&t;&t; * val to count the number of times we overflowed. Otherwise we would loose the current value&n;&t;&t; * in the PMD (which can be &gt;0). So to make sure we don&squot;t loose&n;&t;&t; * the residual counts we set val to contain full 64bits value of the counter.&n;&t;&t; *&n;&t;&t; * XXX: is this needed for EARS/BTB ?&n;&t;&t; */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
multiline_comment|/* slow */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pmod[%ld].val=0x%lx pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_notify
op_logical_and
id|PMD_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d should notify process %d with signal %d&bslash;n&quot;
comma
id|my_cpu
comma
id|ctx-&gt;ctx_notify_pid
comma
id|ctx-&gt;ctx_notify_sig
)paren
)paren
suffix:semicolon
id|bv
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] overflow, no notification&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * In case no notification is requested, we reload the reset value right away&n;&t;&t;&t; * otherwise we wait until the notify_pid process has been called and has&n;&t;&t;&t; * has finished processing data. Check out pfm_overflow_notify()&n;&t;&t;&t; */
multiline_comment|/* writes to upper part are ignored, so this is safe */
r_if
c_cond
(paren
id|ovfl_is_smpl
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] reloaded with smpl_val=%lx&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; CPU%d PMD[%ld] reloaded with ovfl_val=%lx&bslash;n&quot;
comma
id|my_cpu
comma
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|smpl_rval
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ovfl_rval
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnum
op_eq
id|ctx-&gt;ctx_btb_counter
)paren
id|need_reset_pmd16
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In case of BTB, overflow&n;&t; * we need to reset the BTB index.&n;&t; */
r_if
c_cond
(paren
id|need_reset_pmd16
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reset PMD16&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|16
comma
l_int|0
)paren
suffix:semicolon
)brace
id|buffer_full
suffix:colon
multiline_comment|/* see pfm_overflow_notify() on details for why we use |= here */
id|ctx-&gt;ctx_ovfl_regs
op_or_assign
id|bv
suffix:semicolon
multiline_comment|/* nobody to notify, return and unfreeze */
r_if
c_cond
(paren
op_logical_neg
id|bv
)paren
r_return
l_int|0x0
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_pid
op_eq
id|ta-&gt;pid
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|ta-&gt;pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_signo
op_assign
id|ctx-&gt;ctx_notify_sig
suffix:semicolon
multiline_comment|/* is SIGPROF */
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
multiline_comment|/* goes to user */
id|si.si_pfm_ovfl
op_assign
id|bv
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in this case, we don&squot;t stop the task, we let it go on. It will&n;&t;&t; * necessarily go to the signal handler (if any) when it goes back to&n;&t;&t; * user mode.&n;&t;&t; */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; sending %d notification to self %d&bslash;n&quot;
comma
id|si.si_signo
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* this call is safe in an interrupt handler */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|ctx-&gt;ctx_notify_sig
comma
op_amp
id|si
comma
id|ta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * no matter if we block or not, we keep PMU frozen and do not unfreeze on ctxsw&n;&t;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
multiline_comment|/*&n;&t;&t;&t; * The tasklet is guaranteed to be scheduled for this CPU only&n;&t;&t;&t; */
id|notify_info
(braket
id|my_cpu
)braket
dot
id|to_pid
op_assign
id|ctx-&gt;notify_pid
suffix:semicolon
id|notify_info
(braket
id|my_cpu
)braket
dot
id|from_pid
op_assign
id|ta-&gt;pid
suffix:semicolon
multiline_comment|/* for debug only */
id|notify_info
(braket
id|my_cpu
)braket
dot
id|bitvect
op_assign
id|bv
suffix:semicolon
multiline_comment|/* tasklet is inserted and active */
id|tasklet_schedule
c_func
(paren
op_amp
id|pfm_tasklet
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * stored the vector of overflowed registers for use in notification&n;&t;&t;&t; * mark that a notification/blocking is pending (arm the trap)&n;&t;&t;&t; */
id|th-&gt;pfm_pend_notify
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if we do block, then keep PMU frozen until restart&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; process %d notify ovfl_regs=0x%lx&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|bv
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * keep PMU frozen (and overflowed bits cleared) when we have to stop,&n;&t; * otherwise return a resume &squot;value&squot; for PMC[0]&n;&t; *&n;&t; * XXX: maybe that&squot;s enough to get rid of ctx_fl_frozen ?&n;&t; */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; will return pmc0=0x%x&bslash;n&quot;
comma
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
)paren
)paren
suffix:semicolon
r_return
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
suffix:semicolon
)brace
r_static
r_void
DECL|function|perfmon_interrupt
id|perfmon_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_struct
id|task_struct
op_star
id|ta
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PM[0].bit[63-1] is set, then PMC[0].fr = 1&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
op_complement
l_int|0x1
)paren
op_logical_and
(paren
id|ta
op_assign
id|PMU_OWNER
c_func
(paren
)paren
)paren
)paren
(brace
multiline_comment|/* assumes, PMC[0].fr = 1 at this point */
id|pmc0
op_assign
id|update_counters
c_func
(paren
id|ta
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if pmu_frozen = 0&n;&t;&t; *&t;pmc0 = 0 and we resume monitoring right away&n;&t;&t; * else&n;&t;&t; *&t;pmc0 = 0x1 frozen but all pending bits are cleared&n;&t;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
id|pmc0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious PMU overflow interrupt: pmc0=0x%lx owner=%p&bslash;n&quot;
comma
id|pmc0
comma
(paren
r_void
op_star
)paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|perfmon_proc_info
id|perfmon_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PMC[0]=%lx&bslash;nPerfmon debug: %s&bslash;n&quot;
comma
id|pmc0
comma
id|pfm_debug
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_online
c_func
(paren
id|i
)paren
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.PMU %d&bslash;n&quot;
comma
id|i
comma
id|pmu_owners
(braket
id|i
)braket
dot
id|owner
ques
c_cond
id|pmu_owners
(braket
id|i
)braket
dot
id|owner-&gt;pid
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/* for debug only */
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|perfmon_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
id|handler
suffix:colon
id|perfmon_interrupt
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
r_void
id|__init
DECL|function|perfmon_init
id|perfmon_init
(paren
r_void
)paren
(brace
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmu_conf.pfm_is_disabled
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: version %s&bslash;n&quot;
comma
id|PFM_VERSION
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Interrupt vectored to %u&bslash;n&quot;
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_perf_mon_info
c_func
(paren
id|pmu_conf.impl_regs
comma
op_amp
id|pm_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: PAL call failed (%ld)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmu_conf.perf_ovfl_val
op_assign
(paren
l_int|1L
op_lshift
id|pm_info.pal_perf_mon_info_s.width
)paren
op_minus
l_int|1
suffix:semicolon
id|pmu_conf.max_counters
op_assign
id|pm_info.pal_perf_mon_info_s.generic
suffix:semicolon
id|pmu_conf.num_pmds
op_assign
id|find_num_pm_regs
c_func
(paren
id|pmu_conf.impl_regs
)paren
suffix:semicolon
id|pmu_conf.num_pmcs
op_assign
id|find_num_pm_regs
c_func
(paren
op_amp
id|pmu_conf.impl_regs
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Counters are %d bits&bslash;n&quot;
comma
id|pm_info.pal_perf_mon_info_s.width
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Maximum counter value 0x%lx&bslash;n&quot;
comma
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %ld PMC/PMD pairs&bslash;n&quot;
comma
id|pmu_conf.max_counters
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %ld PMCs, %ld PMDs&bslash;n&quot;
comma
id|pmu_conf.num_pmcs
comma
id|pmu_conf.num_pmds
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Sampling format v%d&bslash;n&quot;
comma
id|PFM_SMPL_HDR_VERSION
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf.num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf.num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: ERROR not enough PMC/PMD storage in kernel, perfmon is DISABLED&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* no need to continue anyway */
)brace
multiline_comment|/* we are all set */
id|pmu_conf.pfm_is_disabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Insert the tasklet in the list.&n;&t; * It is still disabled at this point, so it won&squot;t run&n;&t;printk(__FUNCTION__&quot; tasklet is %p state=%d, count=%d&bslash;n&quot;, &amp;perfmon_tasklet, perfmon_tasklet.state, perfmon_tasklet.count);&n;&t; */
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|perfmon_init_percpu
id|perfmon_init_percpu
(paren
r_void
)paren
(brace
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: for system wide this function MUST never be called&n; */
r_void
DECL|function|pfm_save_regs
id|pfm_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|u64
id|pmc0
comma
id|psr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ta
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
id|__FUNCTION__
l_string|&quot; task is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * We must make sure that we don&squot;t loose any potential overflow&n;&t; * interrupt while saving PMU context. In this code, external&n;&t; * interrupts are always enabled.&n;&t; */
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control over overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|owner
op_assign
id|PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for overflow bits and proceed manually if needed&n;&t; *&n;&t; * It is safe to call the interrupt handler now because it does&n;&t; * not try to block the task right away. Instead it will set a&n;&t; * flag and let the task proceed. The blocking will only occur&n;&t; * next time the task exits from the kernel.&n;&t; */
r_if
c_cond
(paren
id|pmc0
op_amp
op_complement
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|owner
op_ne
id|ta
)paren
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; owner=%p task=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|owner
comma
(paren
r_void
op_star
)paren
id|ta
)paren
suffix:semicolon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; Warning: pmc[0]=0x%lx explicit call&bslash;n&quot;
comma
id|pmc0
)paren
suffix:semicolon
id|pmc0
op_assign
id|update_counters
c_func
(paren
id|owner
comma
id|pmc0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we will save the updated version of pmc0 */
)brace
multiline_comment|/*&n;&t; * restore PSR for context switch to save&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* skip PMC[0], we handle it separately */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmcs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Throughout this code we could have gotten an overflow interrupt. It is transformed&n;&t; * into a spurious interrupt as soon as we give up pmu ownership.&n;&t; */
)brace
r_void
DECL|function|pfm_load_regs
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|t-&gt;pmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* skip PMC[0] to avoid side effects */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmcs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we first restore ownership of the PMU to the &squot;soon to be current&squot;&n;&t; * context. This way, if, as soon as we unfreeze the PMU at the end&n;&t; * of this function, we get an interrupt, we attribute it to the correct&n;&t; * task&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
id|ta
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * check if we had pending overflow before context switching out&n;&t; * If so, we invoke the handler manually, i.e. simulate interrupt.&n;&t; *&n;&t; * XXX: given that we do not use the tasklet anymore to stop, we can&n;&t; * move this back to the pfm_save_regs() routine.&n;&t; */
r_if
c_cond
(paren
id|t-&gt;pmc
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
)paren
(brace
multiline_comment|/* freeze set in pfm_save_regs() */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pmc[0]=0x%lx manual interrupt&bslash;n&quot;
comma
id|t-&gt;pmc
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|update_counters
c_func
(paren
id|ta
comma
id|t-&gt;pmc
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * unfreeze only when possible&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is called when a thread exits (from exit_thread()).&n; * This is a simplified pfm_save_regs() that simply flushes hthe current&n; * register state into the save area taking into account any pending&n; * overflow. This time no notification is sent because the taks is dying&n; * anyway. The inline processing of overflows avoids loosing some counts.&n; * The PMU is frozen on exit from this call and is to never be reenabled&n; * again for this task.&n; */
r_void
DECL|function|pfm_flush_regs
id|pfm_flush_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|pmc0
comma
id|psr
comma
id|mask
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|ta
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
id|__FUNCTION__
l_string|&quot; task is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|ta-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
id|__FUNCTION__
l_string|&quot; no PFM ctx is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must make sure that we don&squot;t loose any potential overflow&n;&t; * interrupt while saving PMU context. In this code, external&n;&t; * interrupts are always enabled.&n;&t; */
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control on overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore PSR for context switch to save&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;;srlz.i;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This loop flushes the PMD into the PFM context.&n;&t; * IT also processes overflow inline.&n;&t; *&n;&t; * IMPORTANT: No notification is sent at this point as the process is dying.&n;&t; * The implicit notification will come from a SIGCHILD or a return from a&n;&t; * waitpid().&n;&t; *&n;&t; * XXX: must take holes into account&n;&t; */
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
multiline_comment|/* collect latest results */
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/* take care of overflow inline */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; PMD[%d] overflowed pmd=0x%lx pmds.val=0x%lx&bslash;n&quot;
comma
id|j
comma
id|ia64_get_pmd
c_func
(paren
id|j
)paren
comma
id|ctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * XXX: this routine is not very portable for PMCs&n; * XXX: make this routine able to work with non current context&n; */
r_static
r_void
DECL|function|ia64_reset_pmu
id|ia64_reset_pmu
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* PMU is frozen, no pending overflow bits */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* extra overflow bits + counter configs cleared */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|PMU_FIRST_COUNTER
op_plus
id|pmu_conf.max_counters
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmc
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* opcode matcher set to all 1s */
id|ia64_set_pmc
c_func
(paren
l_int|8
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|9
comma
op_complement
l_int|0
)paren
suffix:semicolon
multiline_comment|/* I-EAR config cleared, plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|10
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* D-EAR config cleared, PMC[11].pt must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|11
comma
l_int|1
op_lshift
l_int|28
)paren
suffix:semicolon
multiline_comment|/* BTB config. plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|12
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Instruction address range, PMC[13].ta must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|13
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clears all PMD registers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_pmds
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PMD_IS_IMPL
c_func
(paren
id|i
)paren
)paren
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * task is the newly created task&n; */
r_int
DECL|function|pfm_inherit
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
id|pfm_context_t
op_star
id|nctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
id|i
comma
id|cnum
suffix:semicolon
multiline_comment|/*&n;&t; * takes care of easiest case first&n;&t; */
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_NONE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; removing PFM context for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_pend_notify
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy_thread() clears IA64_THREAD_PM_VALID */
r_return
l_int|0
suffix:semicolon
)brace
id|nctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* copy content */
op_star
id|nctx
op_assign
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_inherit
op_eq
id|PFM_FL_INHERIT_ONCE
)paren
(brace
id|nctx-&gt;ctx_fl_inherit
op_assign
id|PFM_FL_INHERIT_NONE
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; downgrading to INHERIT_NONE for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize counters in new context */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
)paren
(brace
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|th-&gt;pmd
(braket
id|cnum
)braket
op_assign
id|nctx-&gt;ctx_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
)brace
multiline_comment|/* clear BTB index register */
id|th-&gt;pmd
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if sampling then increment number of users of buffer */
r_if
c_cond
(paren
id|nctx-&gt;ctx_smpl_buf
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_smpl_buf-&gt;psb_refcnt
)paren
suffix:semicolon
)brace
id|nctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|nctx-&gt;ctx_ovfl_regs
op_assign
l_int|0
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|nctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset this semaphore to locked */
multiline_comment|/* clear pending notification */
id|th-&gt;pfm_pend_notify
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* link with new task */
id|th-&gt;pfm_context
op_assign
id|nctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; nctx=%p for process %d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|nctx
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the copy_thread routine automatically clears&n;&t; * IA64_THREAD_PM_VALID, so we need to reenable it, if it was used by the caller&n;&t; */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;  setting PM_VALID for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* called from exit_thread() */
r_void
DECL|function|pfm_context_exit
id|pfm_context_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; invalid context for %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check is we have a sampling buffer attached */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_buf
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_smpl_buf
suffix:semicolon
multiline_comment|/* if only user left, then remove */
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pid %d: task %d sampling psb-&gt;refcnt=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_refcnt.counter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|psb-&gt;psb_refcnt
)paren
)paren
(brace
id|rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pid %d: cleaning task %d sampling buffer&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot; pid %d: task %d pfm_context is freed @%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
(paren
r_void
op_star
)paren
id|ctx
)paren
)paren
suffix:semicolon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
