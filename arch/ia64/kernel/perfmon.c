multiline_comment|/*&n; * This file implements the perfmon subsystem which is used&n; * to program the IA-64 Performance Monitoring Unit (PMU).&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; *&n; * Modifications by Stephane Eranian, Hewlett-Packard Co.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; *&n; * Copyright (C) 1999-2002  Hewlett Packard Co&n; *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *               David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
macro_line|#include &lt;asm/perfmon.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt; /* for ia64_get_itc() */
macro_line|#ifdef CONFIG_PERFMON
multiline_comment|/*&n; * For PMU which rely on the debug registers for some features, you must&n; * you must enable the following flag to activate the support for&n; * accessing the registers via the perfmonctl() interface.&n; */
macro_line|#ifdef CONFIG_ITANIUM
DECL|macro|PFM_PMU_USES_DBR
mdefine_line|#define PFM_PMU_USES_DBR&t;1
macro_line|#endif
multiline_comment|/*&n; * perfmon context states&n; */
DECL|macro|PFM_CTX_DISABLED
mdefine_line|#define PFM_CTX_DISABLED&t;0
DECL|macro|PFM_CTX_ENABLED
mdefine_line|#define PFM_CTX_ENABLED&t;&t;1
multiline_comment|/*&n; * Reset register flags&n; */
DECL|macro|PFM_RELOAD_LONG_RESET
mdefine_line|#define PFM_RELOAD_LONG_RESET&t;1
DECL|macro|PFM_RELOAD_SHORT_RESET
mdefine_line|#define PFM_RELOAD_SHORT_RESET&t;2
multiline_comment|/*&n; * Misc macros and definitions&n; */
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4
DECL|macro|PFM_IS_DISABLED
mdefine_line|#define PFM_IS_DISABLED() pmu_conf.pfm_is_disabled
DECL|macro|PMC_OVFL_NOTIFY
mdefine_line|#define PMC_OVFL_NOTIFY(ctx, i)&t;((ctx)-&gt;ctx_soft_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)
DECL|macro|PFM_FL_INHERIT_MASK
mdefine_line|#define PFM_FL_INHERIT_MASK&t;(PFM_FL_INHERIT_NONE|PFM_FL_INHERIT_ONCE|PFM_FL_INHERIT_ALL)
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;  (i&lt;pmu_conf.num_pmcs &amp;&amp; pmu_conf.impl_regs[i&gt;&gt;6] &amp; (1UL&lt;&lt; (i) %64))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)&t;  (i&lt;pmu_conf.num_pmds &amp;&amp;  pmu_conf.impl_regs[4+(i&gt;&gt;6)] &amp; (1UL&lt;&lt;(i) % 64))
DECL|macro|PMD_IS_COUNTING
mdefine_line|#define PMD_IS_COUNTING(i) (i &gt;=0  &amp;&amp; i &lt; 256 &amp;&amp; pmu_conf.counter_pmds[i&gt;&gt;6] &amp; (1UL &lt;&lt;(i) % 64))
DECL|macro|PMC_IS_COUNTING
mdefine_line|#define PMC_IS_COUNTING(i) PMD_IS_COUNTING(i)
DECL|macro|IBR_IS_IMPL
mdefine_line|#define IBR_IS_IMPL(k)&t;  (k&lt;pmu_conf.num_ibrs)
DECL|macro|DBR_IS_IMPL
mdefine_line|#define DBR_IS_IMPL(k)&t;  (k&lt;pmu_conf.num_dbrs)
DECL|macro|PMC_IS_BTB
mdefine_line|#define PMC_IS_BTB(a)&t;  (((pfm_monitor_t *)(a))-&gt;pmc_es == PMU_BTB_EVENT)
DECL|macro|LSHIFT
mdefine_line|#define LSHIFT(x)&t;&t;(1UL&lt;&lt;(x))
DECL|macro|PMM
mdefine_line|#define PMM(x)&t;&t;&t;LSHIFT(x)
DECL|macro|PMC_IS_MONITOR
mdefine_line|#define PMC_IS_MONITOR(c)&t;((pmu_conf.monitor_pmcs[0] &amp; PMM((c))) != 0)
DECL|macro|CTX_IS_ENABLED
mdefine_line|#define CTX_IS_ENABLED(c) &t;((c)-&gt;ctx_flags.state == PFM_CTX_ENABLED)
DECL|macro|CTX_OVFL_NOBLOCK
mdefine_line|#define CTX_OVFL_NOBLOCK(c)&t;((c)-&gt;ctx_fl_block == 0)
DECL|macro|CTX_INHERIT_MODE
mdefine_line|#define CTX_INHERIT_MODE(c)&t;((c)-&gt;ctx_fl_inherit)
DECL|macro|CTX_HAS_SMPL
mdefine_line|#define CTX_HAS_SMPL(c)&t;&t;((c)-&gt;ctx_psb != NULL)
DECL|macro|CTX_USED_PMD
mdefine_line|#define CTX_USED_PMD(ctx,n) &t;(ctx)-&gt;ctx_used_pmds[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_IBR
mdefine_line|#define CTX_USED_IBR(ctx,n) &t;(ctx)-&gt;ctx_used_ibrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USED_DBR
mdefine_line|#define CTX_USED_DBR(ctx,n) &t;(ctx)-&gt;ctx_used_dbrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)
DECL|macro|CTX_USES_DBREGS
mdefine_line|#define CTX_USES_DBREGS(ctx)&t;(((pfm_context_t *)(ctx))-&gt;ctx_fl_using_dbreg==1)
DECL|macro|LOCK_CTX
mdefine_line|#define LOCK_CTX(ctx)&t;spin_lock(&amp;(ctx)-&gt;ctx_lock)
DECL|macro|UNLOCK_CTX
mdefine_line|#define UNLOCK_CTX(ctx)&t;spin_unlock(&amp;(ctx)-&gt;ctx_lock)
DECL|macro|SET_PMU_OWNER
mdefine_line|#define SET_PMU_OWNER(t)    do { pmu_owners[smp_processor_id()].owner = (t); } while(0)
DECL|macro|PMU_OWNER
mdefine_line|#define PMU_OWNER()&t;    pmu_owners[smp_processor_id()].owner
DECL|macro|LOCK_PFS
mdefine_line|#define LOCK_PFS()&t;    spin_lock(&amp;pfm_sessions.pfs_lock)
DECL|macro|UNLOCK_PFS
mdefine_line|#define UNLOCK_PFS()&t;    spin_unlock(&amp;pfm_sessions.pfs_lock)
DECL|macro|PFM_REG_RETFLAG_SET
mdefine_line|#define PFM_REG_RETFLAG_SET(flags, val)&t;do { flags &amp;= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)
multiline_comment|/*&n; * debugging&n; */
DECL|macro|DBprintk
mdefine_line|#define DBprintk(a) &bslash;&n;&t;do { &bslash;&n;&t;&t;if (pfm_debug_mode &gt;0) { printk(&quot;%s.%d: CPU%d &quot;, __FUNCTION__, __LINE__, smp_processor_id()); printk a; } &bslash;&n;&t;} while (0)
multiline_comment|/* &n; * These are some helpful architected PMC and IBR/DBR register layouts&n; */
r_typedef
r_struct
(brace
DECL|member|pmc_plm
r_int
r_int
id|pmc_plm
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* privilege level mask */
DECL|member|pmc_ev
r_int
r_int
id|pmc_ev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* external visibility */
DECL|member|pmc_oi
r_int
r_int
id|pmc_oi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* overflow interrupt */
DECL|member|pmc_pm
r_int
r_int
id|pmc_pm
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* privileged monitor */
DECL|member|pmc_ig1
r_int
r_int
id|pmc_ig1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reserved */
DECL|member|pmc_es
r_int
r_int
id|pmc_es
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* event select */
DECL|member|pmc_ig2
r_int
r_int
id|pmc_ig2
suffix:colon
l_int|48
suffix:semicolon
multiline_comment|/* reserved */
DECL|typedef|pfm_monitor_t
)brace
id|pfm_monitor_t
suffix:semicolon
multiline_comment|/*&n; * There is one such data structure per perfmon context. It is used to describe the&n; * sampling buffer. It is to be shared among siblings whereas the pfm_context &n; * is not.&n; * Therefore we maintain a refcnt which is incremented on fork().&n; * This buffer is private to the kernel only the actual sampling buffer &n; * including its header are exposed to the user. This construct allows us to &n; * export the buffer read-write, if needed, without worrying about security &n; * problems.&n; */
DECL|struct|_pfm_smpl_buffer_desc
r_typedef
r_struct
id|_pfm_smpl_buffer_desc
(brace
DECL|member|psb_lock
id|spinlock_t
id|psb_lock
suffix:semicolon
multiline_comment|/* protection lock */
DECL|member|psb_refcnt
r_int
r_int
id|psb_refcnt
suffix:semicolon
multiline_comment|/* how many users for the buffer */
DECL|member|psb_flags
r_int
id|psb_flags
suffix:semicolon
multiline_comment|/* bitvector of flags */
DECL|member|psb_addr
r_void
op_star
id|psb_addr
suffix:semicolon
multiline_comment|/* points to location of first entry */
DECL|member|psb_entries
r_int
r_int
id|psb_entries
suffix:semicolon
multiline_comment|/* maximum number of entries */
DECL|member|psb_size
r_int
r_int
id|psb_size
suffix:semicolon
multiline_comment|/* aligned size of buffer */
DECL|member|psb_index
r_int
r_int
id|psb_index
suffix:semicolon
multiline_comment|/* next free entry slot XXX: must use the one in buffer */
DECL|member|psb_entry_size
r_int
r_int
id|psb_entry_size
suffix:semicolon
multiline_comment|/* size of each entry including entry header */
DECL|member|psb_hdr
id|perfmon_smpl_hdr_t
op_star
id|psb_hdr
suffix:semicolon
multiline_comment|/* points to sampling buffer header */
DECL|member|psb_next
r_struct
id|_pfm_smpl_buffer_desc
op_star
id|psb_next
suffix:semicolon
multiline_comment|/* next psb, used for rvfreeing of psb_hdr */
DECL|typedef|pfm_smpl_buffer_desc_t
)brace
id|pfm_smpl_buffer_desc_t
suffix:semicolon
DECL|macro|LOCK_PSB
mdefine_line|#define LOCK_PSB(p)&t;spin_lock(&amp;(p)-&gt;psb_lock)
DECL|macro|UNLOCK_PSB
mdefine_line|#define UNLOCK_PSB(p)&t;spin_unlock(&amp;(p)-&gt;psb_lock)
DECL|macro|PFM_PSB_VMA
mdefine_line|#define PFM_PSB_VMA&t;0x1&t;&t;&t;/* a VMA is describing the buffer */
multiline_comment|/*&n; * This structure is initialized at boot time and contains&n; * a description of the PMU main characteristic as indicated&n; * by PAL&n; */
r_typedef
r_struct
(brace
DECL|member|pfm_is_disabled
r_int
r_int
id|pfm_is_disabled
suffix:semicolon
multiline_comment|/* indicates if perfmon is working properly */
DECL|member|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters   */
DECL|member|max_counters
r_int
r_int
id|max_counters
suffix:semicolon
multiline_comment|/* upper limit on counter pair (PMC/PMD) */
DECL|member|num_pmcs
r_int
r_int
id|num_pmcs
suffix:semicolon
multiline_comment|/* highest PMC implemented (may have holes) */
DECL|member|num_pmds
r_int
r_int
id|num_pmds
suffix:semicolon
multiline_comment|/* highest PMD implemented (may have holes) */
DECL|member|impl_regs
r_int
r_int
id|impl_regs
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* buffer used to hold implememted PMC/PMD mask */
DECL|member|num_ibrs
r_int
r_int
id|num_ibrs
suffix:semicolon
multiline_comment|/* number of instruction debug registers */
DECL|member|num_dbrs
r_int
r_int
id|num_dbrs
suffix:semicolon
multiline_comment|/* number of data debug registers */
DECL|member|monitor_pmcs
r_int
r_int
id|monitor_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which pmc are controlling monitors */
DECL|member|counter_pmds
r_int
r_int
id|counter_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which pmd are used as counters */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
multiline_comment|/*&n; * 64-bit software counter structure&n; */
r_typedef
r_struct
(brace
DECL|member|val
id|u64
id|val
suffix:semicolon
multiline_comment|/* virtual 64bit counter value */
DECL|member|ival
id|u64
id|ival
suffix:semicolon
multiline_comment|/* initial value from user */
DECL|member|long_reset
id|u64
id|long_reset
suffix:semicolon
multiline_comment|/* reset value on sampling overflow */
DECL|member|short_reset
id|u64
id|short_reset
suffix:semicolon
multiline_comment|/* reset value on overflow */
DECL|member|reset_pmds
id|u64
id|reset_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which other pmds to reset when this counter overflows */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* notify/do not notify */
DECL|typedef|pfm_counter_t
)brace
id|pfm_counter_t
suffix:semicolon
multiline_comment|/*&n; * perfmon context. One per process, is cloned on fork() depending on &n; * inheritance flags&n; */
r_typedef
r_struct
(brace
DECL|member|state
r_int
r_int
id|state
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0=disabled, 1=enabled */
DECL|member|inherit
r_int
r_int
id|inherit
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* inherit mode */
DECL|member|block
r_int
r_int
id|block
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* when 1, task will blocked on user notifications */
DECL|member|system
r_int
r_int
id|system
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* do system wide monitoring */
DECL|member|frozen
r_int
r_int
id|frozen
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* pmu must be kept frozen on ctxsw in */
DECL|member|protected
r_int
r_int
l_int|1
suffix:semicolon
multiline_comment|/* allow access to creator of context only */
DECL|member|using_dbreg
r_int
r_int
id|using_dbreg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* using range restrictions (debug registers) */
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|24
suffix:semicolon
DECL|typedef|pfm_context_flags_t
)brace
id|pfm_context_flags_t
suffix:semicolon
multiline_comment|/*&n; * perfmon context: encapsulates all the state of a monitoring session&n; * XXX: probably need to change layout&n; */
DECL|struct|pfm_context
r_typedef
r_struct
id|pfm_context
(brace
DECL|member|ctx_psb
id|pfm_smpl_buffer_desc_t
op_star
id|ctx_psb
suffix:semicolon
multiline_comment|/* sampling buffer, if any */
DECL|member|ctx_smpl_vaddr
r_int
r_int
id|ctx_smpl_vaddr
suffix:semicolon
multiline_comment|/* user level virtual address of smpl buffer */
DECL|member|ctx_lock
id|spinlock_t
id|ctx_lock
suffix:semicolon
DECL|member|ctx_flags
id|pfm_context_flags_t
id|ctx_flags
suffix:semicolon
multiline_comment|/* block/noblock */
DECL|member|ctx_notify_task
r_struct
id|task_struct
op_star
id|ctx_notify_task
suffix:semicolon
multiline_comment|/* who to notify on overflow */
DECL|member|ctx_owner
r_struct
id|task_struct
op_star
id|ctx_owner
suffix:semicolon
multiline_comment|/* pid of creator (debug) */
DECL|member|ctx_ovfl_regs
r_int
r_int
id|ctx_ovfl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers overflowed (notification) */
DECL|member|ctx_smpl_regs
r_int
r_int
id|ctx_smpl_regs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* which registers to record on overflow */
DECL|member|ctx_restart_sem
r_struct
id|semaphore
id|ctx_restart_sem
suffix:semicolon
multiline_comment|/* use for blocking notification mode */
DECL|member|ctx_used_pmds
r_int
r_int
id|ctx_used_pmds
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used PMD (speedup ctxsw) */
DECL|member|ctx_saved_pmcs
r_int
r_int
id|ctx_saved_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMC to save on ctxsw */
DECL|member|ctx_reload_pmcs
r_int
r_int
id|ctx_reload_pmcs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of PMC to reload on ctxsw (SMP) */
DECL|member|ctx_used_ibrs
r_int
r_int
id|ctx_used_ibrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used IBR (speedup ctxsw) */
DECL|member|ctx_used_dbrs
r_int
r_int
id|ctx_used_dbrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* bitmask of used DBR (speedup ctxsw) */
DECL|member|ctx_soft_pmds
id|pfm_counter_t
id|ctx_soft_pmds
(braket
id|IA64_NUM_PMD_REGS
)braket
suffix:semicolon
multiline_comment|/* XXX: size should be dynamic */
DECL|member|ctx_saved_psr
id|u64
id|ctx_saved_psr
suffix:semicolon
multiline_comment|/* copy of psr used for lazy ctxsw */
DECL|member|ctx_saved_cpus_allowed
r_int
r_int
id|ctx_saved_cpus_allowed
suffix:semicolon
multiline_comment|/* copy of the task cpus_allowed (system wide) */
DECL|member|ctx_cpu
r_int
r_int
id|ctx_cpu
suffix:semicolon
multiline_comment|/* cpu to which perfmon is applied (system wide) */
DECL|member|ctx_saving_in_progress
id|atomic_t
id|ctx_saving_in_progress
suffix:semicolon
multiline_comment|/* flag indicating actual save in progress */
DECL|member|ctx_last_cpu
id|atomic_t
id|ctx_last_cpu
suffix:semicolon
multiline_comment|/* CPU id of current or last CPU used */
DECL|typedef|pfm_context_t
)brace
id|pfm_context_t
suffix:semicolon
DECL|macro|ctx_fl_inherit
mdefine_line|#define ctx_fl_inherit&t;&t;ctx_flags.inherit
DECL|macro|ctx_fl_block
mdefine_line|#define ctx_fl_block&t;&t;ctx_flags.block
DECL|macro|ctx_fl_system
mdefine_line|#define ctx_fl_system&t;&t;ctx_flags.system
DECL|macro|ctx_fl_frozen
mdefine_line|#define ctx_fl_frozen&t;&t;ctx_flags.frozen
DECL|macro|ctx_fl_protected
mdefine_line|#define ctx_fl_protected&t;ctx_flags.protected
DECL|macro|ctx_fl_using_dbreg
mdefine_line|#define ctx_fl_using_dbreg&t;ctx_flags.using_dbreg
multiline_comment|/*&n; * global information about all sessions&n; * mostly used to synchronize between system wide and per-process&n; */
r_typedef
r_struct
(brace
DECL|member|pfs_lock
id|spinlock_t
id|pfs_lock
suffix:semicolon
multiline_comment|/* lock the structure */
DECL|member|pfs_task_sessions
r_int
r_int
id|pfs_task_sessions
suffix:semicolon
multiline_comment|/* number of per task sessions */
DECL|member|pfs_sys_sessions
r_int
r_int
id|pfs_sys_sessions
suffix:semicolon
multiline_comment|/* number of per system wide sessions */
DECL|member|pfs_sys_use_dbregs
r_int
r_int
id|pfs_sys_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a system wide session uses debug regs */
DECL|member|pfs_ptrace_use_dbregs
r_int
r_int
id|pfs_ptrace_use_dbregs
suffix:semicolon
multiline_comment|/* incremented when a process uses debug regs */
DECL|member|pfs_sys_session
r_struct
id|task_struct
op_star
id|pfs_sys_session
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* point to task owning a system-wide session */
DECL|typedef|pfm_session_t
)brace
id|pfm_session_t
suffix:semicolon
multiline_comment|/*&n; * structure used to pass argument to/from remote CPU &n; * using IPI to check and possibly save the PMU context on SMP systems.&n; *&n; * not used in UP kernels&n; */
r_typedef
r_struct
(brace
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
multiline_comment|/* which task we are interested in */
DECL|member|retval
r_int
id|retval
suffix:semicolon
multiline_comment|/* return value of the call: 0=you can proceed, 1=need to wait for completion */
DECL|typedef|pfm_smp_ipi_arg_t
)brace
id|pfm_smp_ipi_arg_t
suffix:semicolon
multiline_comment|/*&n; * perfmon command descriptions&n; */
r_typedef
r_struct
(brace
DECL|member|cmd_func
r_int
(paren
op_star
id|cmd_func
)paren
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|cmd_flags
r_int
id|cmd_flags
suffix:semicolon
DECL|member|cmd_narg
r_int
r_int
id|cmd_narg
suffix:semicolon
DECL|member|cmd_argsize
r_int
id|cmd_argsize
suffix:semicolon
DECL|typedef|pfm_cmd_desc_t
)brace
id|pfm_cmd_desc_t
suffix:semicolon
DECL|macro|PFM_CMD_PID
mdefine_line|#define PFM_CMD_PID&t;&t;0x1&t;/* command requires pid argument */
DECL|macro|PFM_CMD_ARG_READ
mdefine_line|#define PFM_CMD_ARG_READ&t;0x2&t;/* command must read argument(s) */
DECL|macro|PFM_CMD_ARG_WRITE
mdefine_line|#define PFM_CMD_ARG_WRITE&t;0x4&t;/* command must write argument(s) */
DECL|macro|PFM_CMD_CTX
mdefine_line|#define PFM_CMD_CTX&t;&t;0x8&t;/* command needs a perfmon context */
DECL|macro|PFM_CMD_NOCHK
mdefine_line|#define PFM_CMD_NOCHK&t;&t;0x10&t;/* command does not need to check task&squot;s state */
DECL|macro|PFM_CMD_IDX
mdefine_line|#define PFM_CMD_IDX(cmd)&t;(cmd)
DECL|macro|PFM_CMD_IS_VALID
mdefine_line|#define PFM_CMD_IS_VALID(cmd)&t;((PFM_CMD_IDX(cmd) &gt;= 0) &amp;&amp; (PFM_CMD_IDX(cmd) &lt; PFM_CMD_COUNT) &bslash;&n;&t;&t;&t;&t;  &amp;&amp; pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_func != NULL)
DECL|macro|PFM_CMD_USE_PID
mdefine_line|#define PFM_CMD_USE_PID(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_PID) != 0)
DECL|macro|PFM_CMD_READ_ARG
mdefine_line|#define PFM_CMD_READ_ARG(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_READ) != 0)
DECL|macro|PFM_CMD_WRITE_ARG
mdefine_line|#define PFM_CMD_WRITE_ARG(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_ARG_WRITE) != 0)
DECL|macro|PFM_CMD_USE_CTX
mdefine_line|#define PFM_CMD_USE_CTX(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_CTX) != 0)
DECL|macro|PFM_CMD_CHK
mdefine_line|#define PFM_CMD_CHK(cmd)&t;((pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_flags &amp; PFM_CMD_NOCHK) == 0)
DECL|macro|PFM_CMD_ARG_MANY
mdefine_line|#define PFM_CMD_ARG_MANY&t;-1 /* cannot be zero */
DECL|macro|PFM_CMD_NARG
mdefine_line|#define PFM_CMD_NARG(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_narg)
DECL|macro|PFM_CMD_ARG_SIZE
mdefine_line|#define PFM_CMD_ARG_SIZE(cmd)&t;(pfm_cmd_tab[PFM_CMD_IDX(cmd)].cmd_argsize)
multiline_comment|/*&n; * perfmon internal variables&n; */
DECL|variable|pmu_conf
r_static
id|pmu_config_t
id|pmu_conf
suffix:semicolon
multiline_comment|/* PMU configuration */
DECL|variable|pfm_debug_mode
r_static
r_int
id|pfm_debug_mode
suffix:semicolon
multiline_comment|/* 0= nodebug, &gt;0= debug output on */
DECL|variable|pfm_sessions
r_static
id|pfm_session_t
id|pfm_sessions
suffix:semicolon
multiline_comment|/* global sessions information */
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|pfm_spurious_ovfl_intr_count
r_static
r_int
r_int
id|pfm_spurious_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of spurious ovfl interrupts */
DECL|variable|pfm_ovfl_intr_count
r_static
r_int
r_int
id|pfm_ovfl_intr_count
suffix:semicolon
multiline_comment|/* keep track of spurious ovfl interrupts */
DECL|variable|pfm_recorded_samples_count
r_static
r_int
r_int
id|pfm_recorded_samples_count
suffix:semicolon
r_static
r_void
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|variable|pfm_vm_ops
r_static
r_struct
id|vm_operations_struct
id|pfm_vm_ops
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; * keep track of task owning the PMU per CPU.&n; */
r_static
r_struct
(brace
DECL|member|owner
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
DECL|variable|pmu_owners
)brace
id|____cacheline_aligned
id|pmu_owners
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; * forward declarations&n; */
r_static
r_void
id|ia64_reset_pmu
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pfm_fetch_regs
c_func
(paren
r_int
id|cpu
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
suffix:semicolon
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
suffix:semicolon
r_static
r_inline
r_int
r_int
DECL|function|pfm_read_soft_counter
id|pfm_read_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
)paren
(brace
r_return
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|pfm_write_soft_counter
id|pfm_write_soft_counter
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
id|i
comma
r_int
r_int
id|val
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|val
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t; * writing to unimplemented part is ignore, so we do not need to&n;&t; * mask off top part&n;&t; */
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * finds the number of PM(C|D) registers given&n; * the bitvector returned by PAL&n; */
r_static
r_int
r_int
id|__init
DECL|function|find_num_pm_regs
id|find_num_pm_regs
c_func
(paren
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 words/per bitvector */
multiline_comment|/* start from the most significant word */
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|buffer
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: No bit set in pm_buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
op_plus
id|ia64_fls
c_func
(paren
id|buffer
(braket
id|i
)braket
)paren
op_plus
l_int|64
op_star
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates a unique (per CPU) timestamp&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_get_stamp
id|pfm_get_stamp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * XXX: must find something more efficient&n;&t; */
r_return
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the area.&n; */
r_static
r_inline
r_int
r_int
DECL|function|pfm_kvirt_to_pa
id|pfm_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|__u64
id|pa
op_assign
id|ia64_tpa
c_func
(paren
id|adr
)paren
suffix:semicolon
singleline_comment|//DBprintk((&quot;kv2pa(%lx--&gt;%lx)&bslash;n&quot;, adr, pa));
r_return
id|pa
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|pfm_rvmalloc
id|pfm_rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
singleline_comment|//printk(&quot;perfmon: CPU%d pfm_rvmalloc(%ld)=%p&bslash;n&quot;, smp_processor_id(), size, mem);
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|mem_map_reserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfm_rvfree
id|pfm_rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|size
OG
l_int|0
)paren
id|mem_map_unreserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called from mm/mmap.c:exit_mmap() only when there is a sampling buffer&n; * attached to the context AND the current task has a mapping for it, i.e., it is the original&n; * creator of the context.&n; *&n; * This function is used to remember the fact that the vma describing the sampling buffer&n; * has now been removed. It can only be called when no other tasks share the same mm context.&n; *&n; */
r_static
r_void
id|pfm_vm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
(paren
id|pfm_smpl_buffer_desc_t
op_star
)paren
id|vma-&gt;vm_private_data
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: psb is null in [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add PSB to list of buffers to free on release_thread() when no more users&n;&t; *&n;&t; * This call is safe because, once the count is zero is cannot be modified anymore.&n;&t; * This is not because there is no more user of the mm context, that the sampling&n;&t; * buffer is not being used anymore outside of this task. In fact, it can still&n;&t; * be accessed from within the kernel by another task (such as the monitored task).&n;&t; *&n;&t; * Therefore, we only move the psb into the list of buffers to free when we know&n;&t; * nobody else is using it.&n;&t; * The linked list if independent of the perfmon context, because in the case of&n;&t; * multi-threaded processes, the last thread may not have been involved with&n;&t; * monitoring however it will be the one removing the vma and it should therefore&n;&t; * also remove the sampling buffer. This buffer cannot be removed until the vma&n;&t; * is removed.&n;&t; *&n;&t; * This function cannot remove the buffer from here, because exit_mmap() must first&n;&t; * complete. Given that there is no other vma related callback in the generic code,&n;&t; * we have created on own with the linked list of sampling buffer to free which&n;&t; * is part of the thread structure. In release_thread() we check if the list is&n;&t; * empty. If not we call into perfmon to free the buffer and psb. That is the only&n;&t; * way to ensure a safe deallocation of the sampling buffer which works when&n;&t; * the buffer is shared between distinct processes or with multi-threaded programs.&n;&t; *&n;&t; * We need to lock the psb because the refcnt test and flag manipulation must&n;&t; * looked like an atomic operation vis a vis pfm_context_exit()&n;&t; */
id|LOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;psb_refcnt
op_eq
l_int|0
)paren
(brace
id|psb-&gt;psb_next
op_assign
id|current-&gt;thread.pfm_smpl_buf_list
suffix:semicolon
id|current-&gt;thread.pfm_smpl_buf_list
op_assign
id|psb
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;psb for [%d] smpl @%p size %ld inserted into list&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;psb vma flag cleared for [%d] smpl @%p size %ld inserted into list&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * indicate to pfm_context_exit() that the vma has been removed. &n;&t; */
id|psb-&gt;psb_flags
op_and_assign
op_complement
id|PFM_PSB_VMA
suffix:semicolon
id|UNLOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from pfm_destroy_context() and also from pfm_inherit()&n; * to explicitely remove the sampling buffer mapping from the user level address space.&n; */
r_static
r_int
id|pfm_remove_smpl_mapping
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/*&n;&t; * some sanity checks first&n;&t; */
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
op_logical_or
id|task-&gt;mm
op_eq
l_int|NULL
op_logical_or
id|ctx-&gt;ctx_smpl_vaddr
op_eq
l_int|0
op_logical_or
id|ctx-&gt;ctx_psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: invalid context mm=%p&bslash;n&quot;
comma
id|task-&gt;mm
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|r
op_assign
id|do_munmap
c_func
(paren
id|task-&gt;mm
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|task-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pid %d unable to unmap sampling buffer @0x%lx size=%ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] do_unmap(0x%lx, %ld)=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_smpl_vaddr
comma
id|psb-&gt;psb_size
comma
id|r
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * make sure we suppress all traces of this buffer&n;&t; * (important for pfm_inherit)&n;&t; */
id|ctx-&gt;ctx_smpl_vaddr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|pfm_context_t
op_star
id|pfm_context_alloc
c_func
(paren
r_void
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
multiline_comment|/* allocate context descriptor */
id|ctx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pfm_context_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
id|pfm_context_t
)paren
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
r_static
r_void
id|pfm_context_free
c_func
(paren
id|pfm_context_t
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
id|kfree
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
r_static
r_int
id|pfm_remap_buffer
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|buf
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;CPU%d buf=0x%lx addr=0x%lx size=%ld&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|buf
comma
id|addr
comma
id|size
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|pfm_kvirt_to_pa
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|addr
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * counts the number of PMDS to save per entry.&n; * This code is generic enough to accomodate more than 64 PMDS when they become available&n; */
r_static
r_int
r_int
id|pfm_smpl_entry_size
c_func
(paren
r_int
r_int
op_star
id|which
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
comma
id|which
op_increment
)paren
id|res
op_add_assign
id|hweight64
c_func
(paren
op_star
id|which
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;weight=%ld&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates the sampling buffer and remaps it into caller&squot;s address space&n; */
r_static
r_int
id|pfm_smpl_buffer_alloc
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|which_pmds
comma
r_int
r_int
id|entries
comma
r_void
op_star
op_star
id|user_vaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
comma
id|regcount
suffix:semicolon
r_void
op_star
id|smpl_buf
suffix:semicolon
id|pfm_smpl_buffer_desc_t
op_star
id|psb
suffix:semicolon
id|regcount
op_assign
id|pfm_smpl_entry_size
c_func
(paren
id|which_pmds
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* note that regcount might be 0, in this case only the header for each&n;&t; * entry will be recorded.&n;&t; */
multiline_comment|/*&n;&t; * 1 buffer hdr and for each entry a header + regcount PMDs to save&n;&t; */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
op_plus
id|entries
op_star
(paren
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check requested size to avoid Denial-of-service attacks&n;&t; * XXX: may have to refine this test&t;&n;&t; * Check against address space limit.&n;&t; *&n;&t; * if ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len&gt; current-&gt;rlim[RLIMIT_AS].rlim_cur) &n;&t; * &t;return -ENOMEM;&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/*&n;&t; * We do the easy to undo allocations first.&n; &t; *&n;&t; * pfm_rvmalloc(), clears the buffer, so there is no leak&n;&t; */
id|smpl_buf
op_assign
id|pfm_rvmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smpl_buf
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;smpl_buf @%p&bslash;n&quot;
comma
id|smpl_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate sampling buffer descriptor now */
id|psb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|psb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t allocate sampling buffer descriptor&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pfm_rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* allocate vma */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot allocate vma&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * partially initialize the vma for the sampling buffer&n;&t; */
id|psb-&gt;psb_hdr
op_assign
id|smpl_buf
suffix:semicolon
id|psb-&gt;psb_addr
op_assign
(paren
(paren
r_char
op_star
)paren
id|smpl_buf
)paren
op_plus
r_sizeof
(paren
id|perfmon_smpl_hdr_t
)paren
suffix:semicolon
multiline_comment|/* first entry */
id|psb-&gt;psb_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* aligned size */
id|psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
id|psb-&gt;psb_entries
op_assign
id|entries
suffix:semicolon
id|psb-&gt;psb_flags
op_assign
id|PFM_PSB_VMA
suffix:semicolon
multiline_comment|/* remember that there is a vma describing the buffer */
id|psb-&gt;psb_refcnt
op_assign
l_int|1
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|psb-&gt;psb_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: will need to do cacheline alignment to avoid false sharing in SMP mode and&n;&t; * multitask monitoring.&n;&t; */
id|psb-&gt;psb_entry_size
op_assign
r_sizeof
(paren
id|perfmon_smpl_entry_t
)paren
op_plus
id|regcount
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;psb @%p entry_size=%ld hdr=%p addr=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|psb
comma
id|psb-&gt;psb_entry_size
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_hdr
comma
(paren
r_void
op_star
)paren
id|psb-&gt;psb_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some of the fields of user visible buffer header */
id|psb-&gt;psb_hdr-&gt;hdr_version
op_assign
id|PFM_SMPL_VERSION
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_entry_size
op_assign
id|psb-&gt;psb_entry_size
suffix:semicolon
id|psb-&gt;psb_hdr-&gt;hdr_pmds
(braket
l_int|0
)braket
op_assign
id|which_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s do the difficult operations next.&n;&t; *&n;&t; * now we atomically find some area in the address space and&n;&t; * remap the buffer in it.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* find some free area in address space, must have mmap sem held */
id|vma-&gt;vm_start
op_assign
id|get_unmapped_area
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|size
comma
l_int|0
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_eq
l_int|0UL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Cannot find unmapped area for size %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|vma-&gt;vm_start
op_plus
id|size
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;entries=%ld aligned size=%ld, unmapped @0x%lx&bslash;n&quot;
comma
id|entries
comma
id|size
comma
id|vma-&gt;vm_start
)paren
)paren
suffix:semicolon
multiline_comment|/* can only be applied to current, need to have the mm semaphore held when called */
r_if
c_cond
(paren
id|pfm_remap_buffer
c_func
(paren
id|vma
comma
(paren
r_int
r_int
)paren
id|smpl_buf
comma
id|vma-&gt;vm_start
comma
id|size
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;Can&squot;t remap buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now insert the vma in the vm list for the process, must be&n;&t; * done with mmap lock held&n;&t; */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* store which PMDS to record */
id|ctx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
op_assign
id|which_pmds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* link to perfmon context */
id|ctx-&gt;ctx_psb
op_assign
id|psb
suffix:semicolon
multiline_comment|/*&n;&t; * keep track of user level virtual address &n;&t; */
id|ctx-&gt;ctx_smpl_vaddr
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|user_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|pfm_rvfree
c_func
(paren
id|smpl_buf
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: do something better here&n; */
r_static
r_int
id|pfm_bad_permissions
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
multiline_comment|/* stolen from bad_signal() */
r_return
(paren
id|current-&gt;session
op_ne
id|task-&gt;session
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_xor
id|task-&gt;uid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;suid
)paren
op_logical_and
(paren
id|current-&gt;uid
op_xor
id|task-&gt;uid
)paren
suffix:semicolon
)brace
r_static
r_int
id|pfx_is_sane
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfarg_context_t
op_star
id|pfx
)paren
(brace
r_int
id|ctx_flags
suffix:semicolon
r_int
id|cpu
suffix:semicolon
multiline_comment|/* valid signal */
multiline_comment|/* cannot send to process 1, 0 means do not notify */
r_if
c_cond
(paren
id|pfx-&gt;ctx_notify_pid
op_eq
l_int|1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid notify_pid %d&bslash;n&quot;
comma
id|pfx-&gt;ctx_notify_pid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ctx_flags
op_assign
id|pfx-&gt;ctx_flags
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cpu_mask=0x%lx&bslash;n&quot;
comma
id|pfx-&gt;ctx_cpu_mask
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cannot block in this mode &n;&t;&t; */
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cannot use blocking mode when in system wide monitoring&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * must only have one bit set in the CPU mask&n;&t;&t; */
r_if
c_cond
(paren
id|hweight64
c_func
(paren
id|pfx-&gt;ctx_cpu_mask
)paren
op_ne
l_int|1UL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid CPU mask specified&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * and it must be a valid CPU&n;&t;&t; */
id|cpu
op_assign
id|ffs
c_func
(paren
id|pfx-&gt;ctx_cpu_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
OG
id|smp_num_cpus
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;CPU%d is not online&bslash;n&quot;
comma
id|cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * check for pre-existing pinning, if conflicting reject&n;&t;&t; */
r_if
c_cond
(paren
id|task-&gt;cpus_allowed
op_ne
op_complement
l_int|0UL
op_logical_and
(paren
id|task-&gt;cpus_allowed
op_amp
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pinned on 0x%lx, mask for CPU%d &bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;cpus_allowed
comma
id|cpu
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * must provide a target for the signal in blocking mode even when&n;&t;&t; * no counter is configured with PFM_FL_REG_OVFL_NOTIFY&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
op_logical_and
id|pfx-&gt;ctx_notify_pid
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* probably more to add here */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_create_context
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|req
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_context_t
id|tmp
suffix:semicolon
r_void
op_star
id|uaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
comma
id|cpu
op_assign
l_int|0
suffix:semicolon
r_int
id|ctx_flags
suffix:semicolon
id|pid_t
id|notify_pid
suffix:semicolon
multiline_comment|/* a context has already been defined */
r_if
c_cond
(paren
id|ctx
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * not yet supported&n;&t; */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
id|pfx_is_sane
c_func
(paren
id|task
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ctx_flags
op_assign
id|tmp.ctx_flags
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
multiline_comment|/* at this point, we know there is at least one bit set */
id|cpu
op_assign
id|ffs
c_func
(paren
id|tmp.ctx_cpu_mask
)paren
op_minus
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;requesting CPU%d currently on CPU%d&bslash;n&quot;
comma
id|cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_task_sessions
OG
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;system wide not possible, task_sessions=%ld&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;system wide not possible, conflicting session [%d] on CPU%d&bslash;n&quot;
comma
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_member_access_from_pointer
id|pid
comma
id|cpu
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
id|task
suffix:semicolon
multiline_comment|/*&n;&t;&t; * count the number of system wide sessions&n;&t;&t; */
id|pfm_sessions.pfs_sys_sessions
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_sessions
op_eq
l_int|0
)paren
(brace
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no per-process monitoring while there is a system wide session */
r_goto
m_abort
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* record the creator (important for inheritance) */
id|ctx-&gt;ctx_owner
op_assign
id|current
suffix:semicolon
id|notify_pid
op_assign
id|tmp.ctx_notify_pid
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_pid
op_eq
id|current-&gt;pid
)paren
(brace
id|ctx-&gt;ctx_notify_task
op_assign
id|task
op_assign
id|current
suffix:semicolon
id|current-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|notify_pid
op_ne
l_int|0
)paren
(brace
r_struct
id|task_struct
op_star
id|notify_task
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|notify_task
op_assign
id|find_task_by_pid
c_func
(paren
id|notify_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_task
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * check if we can send this task a signal&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|notify_task
)paren
)paren
r_goto
id|buffer_error
suffix:semicolon
multiline_comment|/* &n;&t;&t; &t; * make visible&n;&t;&t; &t; * must be done inside critical section&n;&t;&t; &t; *&n;&t;&t; &t; * if the initialization does not go through it is still&n;&t;&t; &t; * okay because child will do the scan for nothing which&n;&t;&t; &t; * won&squot;t hurt.&n;&t;&t; &t; */
id|current-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * will cause task to check on exit for monitored&n;&t;&t;&t; * processes that would notify it. see release_thread()&n;&t;&t;&t; * Note: the scan MUST be done in release thread, once the&n;&t;&t;&t; * task has been detached from the tasklist otherwise you are&n;&t;&t;&t; * exposed to race conditions.&n;&t;&t;&t; */
id|atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
id|ctx-&gt;ctx_notify_task
op_assign
id|notify_task
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * notification process does not exist&n;&t; */
r_if
c_cond
(paren
id|notify_pid
op_ne
l_int|0
op_logical_and
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.ctx_smpl_entries
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling entries=%ld&bslash;n&quot;
comma
id|tmp.ctx_smpl_entries
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|pfm_smpl_buffer_alloc
c_func
(paren
id|ctx
comma
id|tmp.ctx_smpl_regs
comma
id|tmp.ctx_smpl_entries
comma
op_amp
id|uaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|buffer_error
suffix:semicolon
id|tmp.ctx_smpl_vaddr
op_assign
id|uaddr
suffix:semicolon
)brace
multiline_comment|/* initialization of context&squot;s flags */
id|ctx-&gt;ctx_fl_inherit
op_assign
id|ctx_flags
op_amp
id|PFM_FL_INHERIT_MASK
suffix:semicolon
id|ctx-&gt;ctx_fl_block
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_NOTIFY_BLOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_system
op_assign
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * setting this flag to 0 here means, that the creator or the task that the&n;&t; * context is being attached are granted access. Given that a context can only&n;&t; * be created for the calling process this, in effect only allows the creator&n;&t; * to access the context. See pfm_protect() for more.&n;&t; */
id|ctx-&gt;ctx_fl_protected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for system wide mode only (only 1 bit set) */
id|ctx-&gt;ctx_cpu
op_assign
id|cpu
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* SMP only, means no CPU */
multiline_comment|/* &n;&t; * Keep track of the pmds we want to sample&n;&t; * XXX: may be we don&squot;t need to save/restore the DEAR/IEAR pmds&n;&t; * but we do need the BTB for sure. This is because of a hardware&n;&t; * buffer of 1 only for non-BTB pmds.&n;&t; *&n;&t; * We ignore the unimplemented pmds specified by the user&n;&t; */
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_assign
id|tmp.ctx_smpl_regs
(braket
l_int|0
)braket
op_amp
id|pmu_conf.impl_regs
(braket
l_int|4
)braket
suffix:semicolon
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always save/restore PMC[0] */
id|sema_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* init this semaphore to locked */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|buffer_error
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context=%p, pid=%d notify_task=%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context=%p, pid=%d flags=0x%x inherit=%d block=%d system=%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ctx
comma
id|task-&gt;pid
comma
id|ctx_flags
comma
id|ctx-&gt;ctx_fl_inherit
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_fl_system
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when no notification is required, we can make this visible at the last moment&n;&t; */
r_if
c_cond
(paren
id|notify_pid
op_eq
l_int|0
)paren
id|task-&gt;thread.pfm_context
op_assign
id|ctx
suffix:semicolon
multiline_comment|/*&n;&t; * pin task to CPU and force reschedule on exit to ensure&n;&t; * that when back to user level the task runs on the designated&n;&t; * CPU.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ctx-&gt;ctx_saved_cpus_allowed
op_assign
id|task-&gt;cpus_allowed
suffix:semicolon
id|set_cpus_allowed
c_func
(paren
id|task
comma
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] rescheduled allowed=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;cpus_allowed
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|buffer_error
suffix:colon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|error
suffix:colon
multiline_comment|/*&n;&t; * undo session reservation&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx_flags
op_amp
id|PFM_FL_SYSTEM_WIDE
)paren
(brace
id|pfm_sessions.pfs_sys_session
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
id|pfm_sessions.pfs_sys_sessions
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_task_sessions
op_decrement
suffix:semicolon
)brace
m_abort
suffix:colon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
id|pfm_reset_regs
c_func
(paren
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
op_star
id|ovfl_regs
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|mask
op_assign
id|ovfl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|reset_others
op_assign
l_int|0UL
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;masks=0x%lx&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now restore reset value on sampling overflowed counters&n;&t; */
id|mask
op_rshift_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|val
op_assign
id|flag
op_eq
id|PFM_RELOAD_LONG_RESET
ques
c_cond
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|long_reset
suffix:colon
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|short_reset
suffix:semicolon
id|reset_others
op_or_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] %s reset soft_pmd[%d]=%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|flag
op_eq
id|PFM_RELOAD_LONG_RESET
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/* upper part is ignored on rval */
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now take care of resetting the other registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|reset_others
suffix:semicolon
id|i
op_increment
comma
id|reset_others
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|reset_others
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|flag
op_eq
id|PFM_RELOAD_LONG_RESET
ques
c_cond
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|long_reset
suffix:colon
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|short_reset
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|pfm_write_soft_counter
c_func
(paren
id|ctx
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|val
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] %s reset_others pmd[%d]=%lx&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|flag
op_eq
id|PFM_RELOAD_LONG_RESET
ques
c_cond
l_string|&quot;long&quot;
suffix:colon
l_string|&quot;short&quot;
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* just in case ! */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
)brace
r_static
r_int
id|pfm_write_pmcs
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|reg_retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|ta
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.reg_num
suffix:semicolon
multiline_comment|/* &n;&t;&t; * we reject all non implemented PMC as well&n;&t;&t; * as attempts to modify PMC[0-3] which are used&n;&t;&t; * as status registers by the PMU&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|cnum
)paren
op_logical_or
id|cnum
OL
l_int|4
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc[%u] is unimplemented or invalid&bslash;n&quot;
comma
id|cnum
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A PMC used to configure monitors must be:&n;&t;&t; * &t;- system-wide session: privileged monitor&n;&t;&t; * &t;- per-task : user monitor&n;&t;&t; * any other configuration is rejected.&n;&t;&t; */
r_if
c_cond
(paren
id|PMC_IS_MONITOR
c_func
(paren
id|cnum
)paren
)paren
(brace
id|pfm_monitor_t
op_star
id|p
op_assign
(paren
id|pfm_monitor_t
op_star
)paren
op_amp
id|tmp.reg_value
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc[%u].pm = %d&bslash;n&quot;
comma
id|cnum
comma
id|p-&gt;pmc_pm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_xor
id|p-&gt;pmc_pm
)paren
(brace
singleline_comment|//if ((ctx-&gt;ctx_fl_system == 1 &amp;&amp; p-&gt;pmc_pm == 0)
singleline_comment|//  ||(ctx-&gt;ctx_fl_system == 0 &amp;&amp; p-&gt;pmc_pm == 1)) {
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * enforce generation of overflow interrupt. Necessary on all&n;&t;&t;&t; * CPUs which do not implement 64-bit hardware counters.&n;&t;&t;&t; */
id|p-&gt;pmc_oi
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMC_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp.reg_flags
op_amp
id|PFM_REGFL_OVFL_NOTIFY
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * must have a target for the signal&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|flags
op_or_assign
id|PFM_REGFL_OVFL_NOTIFY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * copy reset vector&n;&t;&t;&t; */
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
op_assign
id|tmp.reg_reset_pmds
(braket
l_int|0
)braket
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|1
)braket
op_assign
id|tmp.reg_reset_pmds
(braket
l_int|1
)braket
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|2
)braket
op_assign
id|tmp.reg_reset_pmds
(braket
l_int|2
)braket
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|3
)braket
op_assign
id|tmp.reg_reset_pmds
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * needed in case the user does not initialize the equivalent&n;&t;&t;&t; * PMD. Clearing is done in reset_pmu() so there is no possible&n;&t;&t;&t; * leak here.&n;&t;&t;&t; */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
suffix:semicolon
)brace
id|abort_mission
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINVAL
)paren
id|reg_retval
op_assign
id|PFM_REG_RETFL_EINVAL
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|reg_retval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update register return value, abort all if problem during copy.&n;&t;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if there was something wrong on this register, don&squot;t touch&n;&t;&t; * the hardware at all and abort write request for others.&n;&t;&t; *&n;&t;&t; * On error, the user mut sequentially scan the table and the first&n;&t;&t; * entry which has a return flag set is the one that caused the error.&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx error %d&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|cnum
comma
id|tmp.reg_value
comma
id|reg_retval
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * We can proceed with this register!&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * keep copy the pmc, used for register reload&n;&t;&t; */
id|th-&gt;pmc
(braket
id|cnum
)braket
op_assign
id|tmp.reg_value
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|cnum
comma
id|tmp.reg_value
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx flags=0x%x save_pmcs=0%lx reload_pmcs=0x%lx&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|cnum
comma
id|tmp.reg_value
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|flags
comma
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
id|pfm_write_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|reg_retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|ta
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* XXX: ctx locking may be required here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cnum
op_assign
id|tmp.reg_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/* update virtualized (64bits) counter */
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|cnum
)paren
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|ival
op_assign
id|tmp.reg_value
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|val
op_assign
id|tmp.reg_value
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|long_reset
op_assign
id|tmp.reg_long_reset
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|short_reset
op_assign
id|tmp.reg_short_reset
suffix:semicolon
)brace
id|abort_mission
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINVAL
)paren
id|reg_retval
op_assign
id|PFM_REG_RETFL_EINVAL
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|reg_retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if there was something wrong on this register, don&squot;t touch&n;&t;&t; * the hardware at all and abort write request for others.&n;&t;&t; *&n;&t;&t; * On error, the user mut sequentially scan the table and the first&n;&t;&t; * entry which has a return flag set is the one that caused the error.&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmc[%u]=0x%lx error %d&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|cnum
comma
id|tmp.reg_value
comma
id|reg_retval
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* keep track of what we use */
id|CTX_USED_PMD
c_func
(paren
id|ctx
comma
id|cnum
)paren
suffix:semicolon
multiline_comment|/* writes to unimplemented part is ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|tmp.reg_value
)paren
suffix:semicolon
multiline_comment|/* to go away */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%u]: soft_pmd=0x%lx  short_reset=0x%lx &quot;
l_string|&quot;long_reset=0x%lx hw_pmd=%lx notify=%c used_pmds=0x%lx reset_pmds=0x%lx&bslash;n&quot;
comma
id|ta-&gt;pid
comma
id|cnum
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|val
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|short_reset
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|long_reset
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
comma
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|cnum
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|cnum
)braket
dot
id|reset_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
id|pfm_read_pmds
c_func
(paren
r_struct
id|task_struct
op_star
id|ta
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
id|pfarg_reg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_reg_t
op_star
)paren
id|arg
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: MUST MAKE SURE WE DON&quot;T HAVE ANY PENDING OVERFLOW BEFORE READING&n;&t; * This is required when the monitoring has been stoppped by user or kernel.&n;&t; * If it is still going on, then that&squot;s fine because we a re not guaranteed&n;&t; * to return an accurate value in this case.&n;&t; */
multiline_comment|/* XXX: ctx locking may be required here */
id|DBprintk
c_func
(paren
(paren
l_string|&quot;ctx_last_cpu=%d for [%d]&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
r_int
id|reg_val
op_assign
op_complement
l_int|0UL
comma
id|ctx_val
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|tmp.reg_num
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the task is not the current one, then we check if the&n;&t;&t; * PMU state is still in the local live register due to lazy ctxsw.&n;&t;&t; * If true, then we read directly from the registers.&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|reg_val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.reg_num
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reading pmd[%u]=0x%lx from hw&bslash;n&quot;
comma
id|tmp.reg_num
comma
id|val
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SMP
r_int
id|cpu
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * for SMP system, the context may still be live on another&n;&t;&t;&t; * CPU so we need to fetch it before proceeding with the read&n;&t;&t;&t; * This call we only be made once for the whole loop because&n;&t;&t;&t; * of ctx_last_cpu becoming == -1.&n;&t;&t;&t; *&n;&t;&t;&t; * We cannot reuse ctx_last_cpu as it may change before we get to the&n;&t;&t;&t; * actual IPI call. In this case, we will do the call for nothing but&n;&t;&t;&t; * there is no way around it. The receiving side will simply do nothing.&n;&t;&t;&t; */
id|cpu
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ne
op_minus
l_int|1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;must fetch on CPU%d for [%d]&bslash;n&quot;
comma
id|cpu
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
id|pfm_fetch_regs
c_func
(paren
id|cpu
comma
id|ta
comma
id|ctx
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* context has been saved */
id|val
op_assign
id|reg_val
op_assign
id|th-&gt;pmd
(braket
id|tmp.reg_num
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|tmp.reg_num
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX: need to check for overflow&n;&t;&t;&t; */
id|val
op_and_assign
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|val
op_add_assign
id|ctx_val
op_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|tmp.reg_num
)braket
dot
id|val
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|reg_val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.reg_num
)paren
suffix:semicolon
)brace
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
l_int|0
)paren
suffix:semicolon
id|tmp.reg_value
op_assign
id|val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;read pmd[%u] soft_pmd=0x%lx reg=0x%lx pmc=0x%lx&bslash;n&quot;
comma
id|tmp.reg_num
comma
id|ctx_val
comma
id|reg_val
comma
id|ia64_get_pmc
c_func
(paren
id|tmp.reg_num
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.reg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * XXX: if this fails, we stick we the original failure, flag not updated!&n;&t; */
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef PFM_PMU_USES_DBR
multiline_comment|/*&n; * Only call this function when a process it trying to&n; * write the debug registers (reading is always allowed)&n; */
r_int
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do it only once&n;&t; */
r_if
c_cond
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Even on SMP, we do not need to use an atomic here because&n;&t; * the only way in is via ptrace() and this is possible only when the&n;&t; * process is stopped. Even in the case where the ctxsw out is not totally&n;&t; * completed by the time we come here, there is no way the &squot;stopped&squot; process&n;&t; * could be in the middle of fiddling with the pfm_write_ibr_dbr() routine.&n;&t; * So this is always safe.&n;&t; */
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: not pretty&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only allow the use of debug registers when there is no system&n;&t; * wide monitoring &n;&t; * XXX: we could relax this by &n;&t; */
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
OG
l_int|0
)paren
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|pfm_sessions.pfs_ptrace_use_dbregs
op_increment
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;ptrace_use_dbregs=%lu  sys_use_dbregs=%lu by [%d] ret = %d&bslash;n&quot;
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|task-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for every task that exits with the&n; * IA64_THREAD_DBG_VALID set. This indicates a task which was&n; * able to use the debug registers for debugging purposes via&n; * ptrace(). Therefore we know it was not using them for&n; * perfmormance monitoring, so we only decrement the number&n; * of &quot;ptraced&quot; debug register users to keep the count up to date&n; */
r_int
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|ret
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: invalid release for [%d] ptrace_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_ptrace_use_dbregs
op_decrement
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* PFM_PMU_USES_DBR is true */
multiline_comment|/*&n; * in case, the PMU does not use the debug registers, these two functions are nops.&n; * The first function is called from arch/ia64/kernel/ptrace.c.&n; * The second function is called from arch/ia64/kernel/process.c.&n; */
r_int
id|pfm_use_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
id|pfm_release_debug_registers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* PFM_PMU_USES_DBR */
r_static
r_int
id|pfm_restart
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
op_star
id|sem
op_assign
op_amp
id|ctx-&gt;ctx_restart_sem
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task %d without pmu_frozen set&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;restarting self %d frozen=%d &bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_frozen
)paren
)paren
suffix:semicolon
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|PFM_RELOAD_LONG_RESET
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We ignore block/don&squot;t block because we never block&n;&t;&t; * for a self-monitoring process.&n;&t;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* restart on another task */
multiline_comment|/*&n;&t; * if blocking, then post the semaphore.&n;&t; * if non-blocking, then we ensure that the task will go into&n;&t; * pfm_overflow_must_block() before returning to user mode. &n;&t; * We cannot explicitely reset another task, it MUST always&n;&t; * be done by the task itself. This works for system wide because&n;&t; * the tool that is controlling the session is doing &quot;self-monitoring&quot;.&n;&t; *&n;&t; * XXX: what if the task never goes back to user?&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;unblocking %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|1
suffix:semicolon
id|set_tsk_thread_flag
c_func
(paren
id|current
comma
id|TIF_NOTIFY_RESUME
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * in case of non blocking mode, then it&squot;s just a matter of&n;&t; * of reseting the sampling buffer (if any) index. The PMU&n;&t; * is already active.&n;&t; */
multiline_comment|/*&n;&t; * must reset the header count first&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;resetting sampling indexes for %d &bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_destroy_context
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|task-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* freeze PMU */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* restore security level */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * remove sampling buffer mapping, if any&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_vaddr
)paren
id|pfm_remove_smpl_mapping
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* now free context and related state */
id|pfm_context_exit
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * does nothing at the moment&n; */
r_static
r_int
id|pfm_unprotect_context
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_protect_context
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context from [%d] is protected&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * from now on, only the creator of the context has access to it&n;&t; */
id|ctx-&gt;ctx_fl_protected
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * reinforce secure monitoring: cannot toggle psr.up&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_debug
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mode
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|arg
suffix:semicolon
id|pfm_debug_mode
op_assign
id|mode
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon debugging %s&bslash;n&quot;
comma
id|pfm_debug_mode
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef PFM_PMU_USES_DBR
r_typedef
r_struct
(brace
r_int
r_int
id|ibr_mask
suffix:colon
l_int|56
suffix:semicolon
r_int
r_int
id|ibr_plm
suffix:colon
l_int|4
suffix:semicolon
r_int
r_int
id|ibr_ig
suffix:colon
l_int|3
suffix:semicolon
r_int
r_int
id|ibr_x
suffix:colon
l_int|1
suffix:semicolon
)brace
id|ibr_mask_reg_t
suffix:semicolon
r_typedef
r_struct
(brace
r_int
r_int
id|dbr_mask
suffix:colon
l_int|56
suffix:semicolon
r_int
r_int
id|dbr_plm
suffix:colon
l_int|4
suffix:semicolon
r_int
r_int
id|dbr_ig
suffix:colon
l_int|2
suffix:semicolon
r_int
r_int
id|dbr_w
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|dbr_r
suffix:colon
l_int|1
suffix:semicolon
)brace
id|dbr_mask_reg_t
suffix:semicolon
r_typedef
r_union
(brace
r_int
r_int
id|val
suffix:semicolon
id|ibr_mask_reg_t
id|ibr
suffix:semicolon
id|dbr_mask_reg_t
id|dbr
suffix:semicolon
)brace
id|dbreg_t
suffix:semicolon
r_static
r_int
id|pfm_write_ibr_dbr
c_func
(paren
r_int
id|mode
comma
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
id|pfarg_dbreg_t
id|tmp
comma
op_star
id|req
op_assign
(paren
id|pfarg_dbreg_t
op_star
)paren
id|arg
suffix:semicolon
id|dbreg_t
id|dbreg
suffix:semicolon
r_int
r_int
id|rnum
suffix:semicolon
r_int
id|first_time
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * for range restriction: psr.db must be cleared or the&n;&t; * the PMU will ignore the debug registers.&n;&t; *&n;&t; * XXX: may need more in system wide mode,&n;&t; * no task can have this bit set?&n;&t; */
r_if
c_cond
(paren
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|db
op_eq
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|first_time
op_assign
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * check for debug registers in system wide mode&n;&t; *&n;&t; */
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_logical_and
id|first_time
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|pfm_sessions.pfs_sys_use_dbregs
op_increment
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* we mark ourselves as owner  of the debug registers */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|thread-&gt;flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;debug registers already in use for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/* we mark ourselves as owner  of the debug registers */
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Given debug registers cannot be used for both debugging &n;&t;&t;&t; * and performance monitoring at the same time, we reuse&n;&t;&t;&t; * the storage area to save and restore the registers on ctxsw.&n;&t;&t;&t; */
id|memset
c_func
(paren
id|task-&gt;thread.dbr
comma
l_int|0
comma
r_sizeof
(paren
id|task-&gt;thread.dbr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|task-&gt;thread.ibr
comma
l_int|0
comma
r_sizeof
(paren
id|task-&gt;thread.ibr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * clear hardware registers to make sure we don&squot;t leak&n;&t;&t;&t; * information and pick up stale state&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_ibrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_ibr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmu_conf.num_dbrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_dbr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
)brace
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Now install the values into the registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
id|rnum
op_assign
id|tmp.dbreg_num
suffix:semicolon
id|dbreg.val
op_assign
id|tmp.dbreg_value
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_eq
l_int|0
op_logical_and
op_logical_neg
id|IBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
op_logical_or
(paren
(paren
id|mode
op_eq
l_int|1
)paren
op_logical_and
op_logical_neg
id|DBR_IS_IMPL
c_func
(paren
id|rnum
)paren
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid register %u val=0x%lx mode=%d i=%d count=%d&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|mode
comma
id|i
comma
id|count
)paren
)paren
suffix:semicolon
r_goto
id|abort_mission
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * make sure we do not install enabled breakpoint&n;&t;&t; */
r_if
c_cond
(paren
id|rnum
op_amp
l_int|0x1
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
id|dbreg.ibr.ibr_x
op_assign
l_int|0
suffix:semicolon
r_else
id|dbreg.dbr.dbr_r
op_assign
id|dbreg.dbr.dbr_w
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * clear return flags and copy back to user&n;&t;&t; *&n;&t;&t; * XXX: fix once EAGAIN is implemented&n;&t;&t; */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.dbreg_flags
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|abort_mission
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Debug registers, just like PMC, can only be modified&n;&t;&t; * by a kernel call. Moreover, perfmon() access to those&n;&t;&t; * registers are centralized in this routine. The hardware&n;&t;&t; * does not modify the value of these registers, therefore,&n;&t;&t; * if we save them as they are written, we can avoid having&n;&t;&t; * to save them on context switch out. This is made possible&n;&t;&t; * by the fact that when perfmon uses debug registers, ptrace()&n;&t;&t; * won&squot;t be able to modify them concurrently.&n;&t;&t; */
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
(brace
id|CTX_USED_IBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
id|ia64_set_ibr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|thread-&gt;ibr
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;write ibr%u=0x%lx used_ibrs=0x%lx&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CTX_USED_DBR
c_func
(paren
id|ctx
comma
id|rnum
)paren
suffix:semicolon
id|ia64_set_dbr
c_func
(paren
id|rnum
comma
id|dbreg.val
)paren
suffix:semicolon
id|thread-&gt;dbr
(braket
id|rnum
)braket
op_assign
id|dbreg.val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;write dbr%u=0x%lx used_dbrs=0x%lx&bslash;n&quot;
comma
id|rnum
comma
id|dbreg.val
comma
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|abort_mission
suffix:colon
multiline_comment|/*&n;&t; * in case it was our first attempt, we undo the global modifications&n;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_fl_using_dbreg
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * install error return flag&n;&t; */
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EFAULT
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX: for now we can only come here on EINVAL&n;&t;&t; */
id|PFM_REG_RETFLAG_SET
c_func
(paren
id|tmp.dbreg_flags
comma
id|PFM_REG_RETFL_EINVAL
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
id|pfm_write_ibrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|pfm_write_ibr_dbr
c_func
(paren
l_int|0
comma
id|task
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
r_static
r_int
id|pfm_write_dbrs
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|pfm_write_ibr_dbr
c_func
(paren
l_int|1
comma
id|task
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
)brace
macro_line|#endif /* PFM_PMU_USES_DBR */
r_static
r_int
id|pfm_get_features
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfarg_features_t
id|tmp
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.ft_version
op_assign
id|PFM_VERSION
suffix:semicolon
id|tmp.ft_smpl_version
op_assign
id|PFM_SMPL_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_start
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] fl_system=%d owner=%p current=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_system
comma
id|PMU_OWNER
c_func
(paren
)paren
comma
id|current
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|task
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pfm_start task [%d] not pmu owner&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* enable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_or
id|IA64_DCR_PP
)paren
suffix:semicolon
id|local_cpu_data-&gt;pfm_dcr_pp
op_assign
l_int|1
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;ssm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pfm_start task flag not set for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;sum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_enable
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_logical_and
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|current
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* reset all registers to stable quiet state */
id|ia64_reset_pmu
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* make sure nothing starts */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to make sure! */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|local_cpu_data-&gt;pfm_syst_wide
op_assign
l_int|1
suffix:semicolon
id|local_cpu_data-&gt;pfm_dcr_pp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * needed in case the task was a passive task during&n;&t;&t; * a system wide session and now wants to have its own&n;&t;&t; * session&n;&t;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to make sure! */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * allow user control (user monitors only)&n;&t;&t;if (task  == ctx-&gt;ctx_owner) {&n;&t;&t; */
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;clearing psr.sp for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|0
suffix:semicolon
)brace
id|task-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
id|SET_PMU_OWNER
c_func
(paren
id|task
)paren
suffix:semicolon
id|ctx-&gt;ctx_flags.state
op_assign
id|PFM_CTX_ENABLED
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_disable
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring, freeze PMU, and save state in context&n;&t; */
id|pfm_flush_regs
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * just to make sure nothing starts again when back in user mode.&n;&t; * pfm_flush_regs() freezes the PMU anyway.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * goes back to default behavior &n;&t; * no need to change live psr.sp because useless at the kernel level&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;enabling psr.sp for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|ctx-&gt;ctx_flags.state
op_assign
id|PFM_CTX_DISABLED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pfm_stop
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; * Cannot do anything before PMU is enabled &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CTX_IS_ENABLED
c_func
(paren
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] fl_system=%d owner=%p current=%p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ctx-&gt;ctx_fl_system
comma
id|PMU_OWNER
c_func
(paren
)paren
comma
id|current
)paren
)paren
suffix:semicolon
multiline_comment|/* simply stop monitoring but not the PMU */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* disable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|local_cpu_data-&gt;pfm_dcr_pp
op_assign
l_int|0
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * functions MUST be listed in the increasing order of their index (see permfon.h)&n; */
r_static
id|pfm_cmd_desc_t
id|pfm_cmd_tab
(braket
)braket
op_assign
initialization_block
suffix:semicolon
mdefine_line|#define PFM_CMD_COUNT&t;(sizeof(pfm_cmd_tab)/sizeof(pfm_cmd_desc_t))
r_static
r_int
id|check_task_state
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* We must wait until the state has been completely&n;&t; * saved. There can be situations where the reader arrives before&n;&t; * after the task is marked as STOPPED but before pfm_save_regs()&n;&t; * is completed.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|task_lock
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
multiline_comment|/*XXX !task_has_cpu(task)*/
)paren
r_break
suffix:semicolon
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
multiline_comment|/*task_has_cpu(task)*/
)paren
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|task-&gt;state
op_ne
id|TASK_ZOMBIE
op_logical_and
id|task-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;warning [%d] not in stable state %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|task-&gt;state
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
id|asmlinkage
r_int
id|sys_perfmonctl
(paren
id|pid_t
id|pid
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
op_assign
id|current
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ESRCH
comma
id|narg
suffix:semicolon
multiline_comment|/* &n;&t; * reject any call if perfmon was disabled at initialization time&n;&t; */
r_if
c_cond
(paren
id|PFM_IS_DISABLED
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cmd=%d idx=%d valid=%d narg=0x%x&bslash;n&quot;
comma
id|cmd
comma
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
comma
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_IS_VALID
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* ingore arguments when command has none */
id|narg
op_assign
id|PFM_CMD_NARG
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|narg
op_eq
id|PFM_CMD_ARG_MANY
op_logical_and
id|count
op_eq
l_int|0
)paren
op_logical_or
(paren
id|narg
OG
l_int|0
op_logical_and
id|narg
op_ne
id|count
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sz
op_assign
id|PFM_CMD_ARG_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_READ_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
id|sz
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_WRITE_ARG
c_func
(paren
id|cmd
)paren
op_logical_and
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
id|sz
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_USE_PID
c_func
(paren
id|cmd
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * XXX: may need to fine tune this one&n;&t;&t; */
r_if
c_cond
(paren
id|pid
OL
l_int|2
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|task
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|abort_call
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pfm_bad_permissions
c_func
(paren
id|task
)paren
)paren
r_goto
id|abort_call
suffix:semicolon
r_if
c_cond
(paren
id|PFM_CMD_CHK
c_func
(paren
id|cmd
)paren
)paren
(brace
id|ret
op_assign
id|check_task_state
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|abort_call
suffix:semicolon
)brace
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|PFM_CMD_USE_CTX
c_func
(paren
id|cmd
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;no context for task %d&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_call
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t;&t;* we only grant access to the context if:&n;&t;&t;* &t;- the caller is the creator of the context (ctx_owner)&n;&t;&t;*  OR   - the context is attached to the caller AND The context IS NOT &n;&t;&t;*  &t;  in protected mode&n;&t;&t;*/
r_if
c_cond
(paren
id|ctx-&gt;ctx_owner
op_ne
id|current
op_logical_and
(paren
id|ctx-&gt;ctx_fl_protected
op_logical_or
id|task
op_ne
id|current
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;context protected, no access for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
r_goto
id|abort_call
suffix:semicolon
)brace
)brace
id|ret
op_assign
(paren
op_star
id|pfm_cmd_tab
(braket
id|PFM_CMD_IDX
c_func
(paren
id|cmd
)paren
)braket
dot
id|cmd_func
)paren
(paren
id|task
comma
id|ctx
comma
id|arg
comma
id|count
comma
id|regs
)paren
suffix:semicolon
id|abort_call
suffix:colon
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
id|pfm_ovfl_block_reset
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * clear the flag, to make sure we won&squot;t get here&n;&t; * again&n;&t; */
id|th-&gt;pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * do some sanity checks first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: [%d] has no PFM context&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
)paren
r_goto
id|non_blocking
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] before sleeping&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * may go through without blocking on SMP systems&n;&t; * if restart has been received already by the time we call down()&n;&t; */
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ctx-&gt;ctx_restart_sem
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] after sleeping ret=%d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in case of interruption of down() we don&squot;t restart anything&n;&t; */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|non_blocking
suffix:colon
multiline_comment|/* we reactivate on context switch */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the ovfl_sem is cleared by the restart task and this is safe because we always&n;&t;&t; * use the local reference&n;&t;&t; */
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
id|ctx-&gt;ctx_ovfl_regs
comma
id|PFM_RELOAD_LONG_RESET
)paren
suffix:semicolon
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Unlock sampling buffer and reset index atomically&n;&t;&t; * XXX: not really needed when blocking&n;&t;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0
suffix:semicolon
)brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* state restored, can go back to work (user mode) */
)brace
)brace
multiline_comment|/*&n; * This function will record an entry in the sampling if it is not full already.&n; * Return:&n; * &t;0 : buffer is not full (did not BECOME full: still space or was already full)&n; * &t;1 : buffer is full (recorded the last entry)&n; */
r_static
r_int
id|pfm_record_sample
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
comma
r_int
r_int
id|ovfl_mask
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
r_int
r_int
op_star
id|e
comma
id|m
comma
id|idx
suffix:semicolon
id|perfmon_smpl_entry_t
op_star
id|h
suffix:semicolon
r_int
id|j
suffix:semicolon
id|pfm_recorded_samples_count
op_increment
suffix:semicolon
id|idx
op_assign
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_index
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;recording index=%ld entries=%ld&bslash;n&quot;
comma
id|idx
op_minus
l_int|1
comma
id|psb-&gt;psb_entries
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* XXX: there is a small chance that we could run out on index before resetting&n;&t;* but index is unsigned long, so it will take some time.....&n;&t;* We use &gt; instead of == because fetch_and_add() is off by one (see below)&n;&t;*&n;&t;* This case can happen in non-blocking mode or with multiple processes.&n;&t;* For non-blocking, we need to reload and continue.&n;&t; */
r_if
c_cond
(paren
id|idx
OG
id|psb-&gt;psb_entries
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* first entry is really entry 0, not 1 caused by fetch_and_add */
id|idx
op_decrement
suffix:semicolon
id|h
op_assign
(paren
id|perfmon_smpl_entry_t
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|psb-&gt;psb_addr
)paren
op_plus
id|idx
op_star
(paren
id|psb-&gt;psb_entry_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize entry header&n;&t; */
id|h-&gt;pid
op_assign
id|task-&gt;pid
suffix:semicolon
id|h-&gt;cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|h-&gt;rate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX: add the sampling rate used here */
id|h-&gt;ip
op_assign
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0x0
suffix:semicolon
multiline_comment|/* where did the fault happened */
id|h-&gt;regs
op_assign
id|ovfl_mask
suffix:semicolon
multiline_comment|/* which registers overflowed */
multiline_comment|/* guaranteed to monotonically increase on each cpu */
id|h-&gt;stamp
op_assign
id|pfm_get_stamp
c_func
(paren
)paren
suffix:semicolon
id|h-&gt;period
op_assign
l_int|0UL
suffix:semicolon
multiline_comment|/* not yet used */
multiline_comment|/* position for first pmd */
id|e
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * selectively store PMDs in increasing index number&n;&t; */
id|m
op_assign
id|ctx-&gt;ctx_smpl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|j
)paren
)paren
(brace
op_star
id|e
op_assign
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|j
)paren
suffix:semicolon
multiline_comment|/* check if this pmd overflowed as well */
op_star
id|e
op_add_assign
id|ovfl_mask
op_amp
(paren
l_int|1UL
op_lshift
id|j
)paren
ques
c_cond
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|e
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
multiline_comment|/* slow */
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;e=%p pmd%d =0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|e
comma
id|j
comma
op_star
id|e
)paren
)paren
suffix:semicolon
id|e
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make the new entry visible to user, needs to be atomic&n;&t; */
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;index=%ld entries=%ld hdr_count=%ld&bslash;n&quot;
comma
id|idx
comma
id|psb-&gt;psb_entries
comma
id|psb-&gt;psb_hdr-&gt;hdr_count
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * sampling buffer full ? &n;&t; */
r_if
c_cond
(paren
id|idx
op_eq
(paren
id|psb-&gt;psb_entries
op_minus
l_int|1
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling buffer full&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX: must reset buffer in blocking mode and lost notified&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * main overflow processing routine.&n; * it can be called from the interrupt path or explicitely during the context switch code&n; * Return:&n; *&t;new value of pmc[0]. if 0x0 then unfreeze, else keep frozen&n; */
r_static
r_int
r_int
id|pfm_overflow_handler
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
id|u64
id|pmc0
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|old_val
suffix:semicolon
r_int
r_int
id|ovfl_notify
op_assign
l_int|0UL
comma
id|ovfl_pmds
op_assign
l_int|0UL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|my_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * It is never safe to access the task for which the overflow interrupt is destinated&n;&t; * using the current variable as the interrupt may occur in the middle of a context switch&n;&t; * where current does not hold the task that is running yet.&n;&t; *&n;&t; * For monitoring, however, we do need to get access to the task which caused the overflow&n;&t; * to account for overflow on the counters.&n;&t; *&n;&t; * We accomplish this by maintaining a current owner of the PMU per CPU. During context&n;&t; * switch the ownership is changed in a way such that the reflected owner is always the&n;&t; * valid one, i.e. the one that caused the interrupt.&n;&t; */
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;owners[%d]=NULL&bslash;n&quot;
comma
id|my_cpu
)paren
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d has no PFM context&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX: debug test&n;&t; * Don&squot;t think this could happen given upfront tests&n;&t; */
r_if
c_cond
(paren
(paren
id|t-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
op_logical_and
id|ctx-&gt;ctx_fl_system
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: Spurious overflow interrupt: process %d not using perfmon&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
l_int|0x1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sanity test. Should never happen&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: pid %d pmc0=0x%lx assumption error for freeze bit&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|pmc0
)paren
suffix:semicolon
r_return
l_int|0x0
suffix:semicolon
)brace
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;pmc0=0x%lx pid=%d iip=0x%lx, %s&quot;
l_string|&quot; mode used_pmds=0x%lx save_pmcs=0x%lx reload_pmcs=0x%lx&bslash;n&quot;
comma
id|pmc0
comma
id|task-&gt;pid
comma
(paren
id|regs
ques
c_cond
id|regs-&gt;cr_iip
suffix:colon
l_int|0
)paren
comma
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
ques
c_cond
l_string|&quot;nonblocking&quot;
suffix:colon
l_string|&quot;blocking&quot;
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First we update the virtual counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip pmd which did not overflow */
r_if
c_cond
(paren
(paren
id|mask
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;PMD[%d] overflowed hw_pmd=0x%lx soft_pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Because we sometimes (EARS/BTB) reset to a specific value, we cannot simply use&n;&t;&t; * val to count the number of times we overflowed. Otherwise we would loose the &n;&t;&t; * current value in the PMD (which can be &gt;0). So to make sure we don&squot;t loose&n;&t;&t; * the residual counts we set val to contain full 64bits value of the counter.&n;&t;&t; */
id|old_val
op_assign
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
op_plus
id|pfm_read_soft_counter
c_func
(paren
id|ctx
comma
id|i
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;soft_pmd[%d].val=0x%lx old_val=0x%lx pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
comma
id|old_val
comma
id|ia64_get_pmd
c_func
(paren
id|i
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now that we have extracted the hardware counter, we can clear it to ensure&n;&t;&t; * that a subsequent PFM_READ_PMDS will not include it again.&n;&t;&t; */
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for overflow condition&n;&t;&t; */
r_if
c_cond
(paren
id|old_val
OG
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
(brace
id|ovfl_pmds
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;soft_pmd[%d] overflowed flags=0x%x, ovfl=0x%lx&bslash;n&quot;
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|flags
comma
id|ovfl_pmds
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMC_OVFL_NOTIFY
c_func
(paren
id|ctx
comma
id|i
)paren
)paren
(brace
id|ovfl_notify
op_or_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * check for sampling buffer&n;&t; *&n;&t; * if present, record sample. We propagate notification ONLY when buffer&n;&t; * becomes full.&n;&t; */
r_if
c_cond
(paren
id|CTX_HAS_SMPL
c_func
(paren
id|ctx
)paren
)paren
(brace
id|ret
op_assign
id|pfm_record_sample
c_func
(paren
id|task
comma
id|ctx
comma
id|ovfl_pmds
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Sampling buffer became full&n;&t;&t;&t; * If no notication was requested, then we reset buffer index&n;&t;&t;&t; * and reset registers (done below) and resume.&n;&t;&t;&t; * If notification requested, then defer reset until pfm_restart()&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ovfl_notify
op_eq
l_int|0UL
)paren
(brace
id|ctx-&gt;ctx_psb-&gt;psb_hdr-&gt;hdr_count
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_psb-&gt;psb_index
op_assign
l_int|0UL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * sample recorded in buffer, no need to notify user&n;&t;&t;&t; */
id|ovfl_notify
op_assign
l_int|0UL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * No overflow requiring a user level notification&n;&t; */
r_if
c_cond
(paren
id|ovfl_notify
op_eq
l_int|0UL
)paren
(brace
id|pfm_reset_regs
c_func
(paren
id|ctx
comma
op_amp
id|ovfl_pmds
comma
id|PFM_RELOAD_SHORT_RESET
)paren
suffix:semicolon
r_return
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * keep track of what to reset when unblocking &n;&t; */
id|ctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
id|ovfl_pmds
suffix:semicolon
multiline_comment|/*&n;&t; * we have come to this point because there was an overflow and that notification&n;&t; * was requested. The notify_task may have disappeared, in which case notify_task&n;&t; * is NULL.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
)paren
(brace
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
l_int|NULL
suffix:semicolon
id|si.si_pid
op_assign
id|task-&gt;pid
suffix:semicolon
multiline_comment|/* who is sending */
id|si.si_signo
op_assign
id|SIGPROF
suffix:semicolon
id|si.si_code
op_assign
id|PROF_OVFL
suffix:semicolon
multiline_comment|/* indicates a perfmon SIGPROF signal */
multiline_comment|/*&n;&t;&t; * Shift the bitvector such that the user sees bit 4 for PMD4 and so on.&n;&t;&t; * We only use smpl_ovfl[0] for now. It should be fine for quite a while&n;&t;&t; * until we have more than 61 PMD available.&n;&t;&t; */
id|si.si_pfm_ovfl
(braket
l_int|0
)braket
op_assign
id|ovfl_notify
suffix:semicolon
multiline_comment|/*&n;&t;&t; * when the target of the signal is not ourself, we have to be more&n;&t;&t; * careful. The notify_task may being cleared by the target task itself&n;&t;&t; * in release_thread(). We must ensure mutual exclusion here such that&n;&t;&t; * the signal is delivered (even to a dying task) safely.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * grab the notification lock for this task&n;&t;&t;&t; * This guarantees that the sequence: test + send_signal&n;&t;&t;&t; * is atomic with regards to the ctx_notify_task field.&n;&t;&t;&t; *&n;&t;&t;&t; * We need a spinlock and not just an atomic variable for this.&n;&t;&t;&t; *&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now notify_task cannot be modified until we&squot;re done&n;&t;&t;&t; * if NULL, they it got modified while we were in the handler&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If we&squot;ve lost the notified task, then we will run&n;&t;&t;&t;&t; * to completion wbut keep the PMU frozen. Results&n;&t;&t;&t;&t; * will be incorrect anyway. We do not kill task&n;&t;&t;&t;&t; * to leave it possible to attach perfmon context&n;&t;&t;&t;&t; * to already running task.&n;&t;&t;&t;&t; */
r_goto
id|lost_notify
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * required by send_sig_info() to make sure the target&n;&t;&t;&t; * task does not disappear on us.&n;&t;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; &t; * in this case, we don&squot;t stop the task, we let it go on. It will&n;&t; &t; * necessarily go to the signal handler (if any) when it goes back to&n;&t; &t; * user mode.&n;&t; &t; */
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] sending notification to [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * this call is safe in an interrupt handler, so does read_lock() on tasklist_lock&n;&t;&t; */
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|SIGPROF
comma
op_amp
id|si
comma
id|ctx-&gt;ctx_notify_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;send_sig_info(process %d, SIGPROF)=%d&bslash;n&quot;
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now undo the protections in order&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
id|current
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if we block set the pfm_must_block bit&n;&t;&t; * when in block mode, we can effectively block only when the notified&n;&t;&t; * task is not self, otherwise we would deadlock. &n;&t;&t; * in this configuration, the notification is sent, the task will not &n;&t;&t; * block on the way back to user mode, but the PMU will be kept frozen&n;&t;&t; * until PFM_RESTART.&n;&t;&t; * Note that here there is still a race condition with notify_task&n;&t;&t; * possibly being nullified behind our back, but this is fine because&n;&t;&t; * it can only be changed to NULL which by construction, can only be&n;&t;&t; * done when notify_task != current. So if it was already different&n;&t;&t; * before, changing it to NULL will still maintain this invariant.&n;&t;&t; * Of course, when it is equal to current it cannot change at this point.&n;&t;&t; */
id|DBprintk
c_func
(paren
(paren
l_string|&quot;block=%d notify [%d] current [%d]&bslash;n&quot;
comma
id|ctx-&gt;ctx_fl_block
comma
id|ctx-&gt;ctx_notify_task
ques
c_cond
id|ctx-&gt;ctx_notify_task-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CTX_OVFL_NOBLOCK
c_func
(paren
id|ctx
)paren
op_logical_and
id|ctx-&gt;ctx_notify_task
op_ne
id|task
)paren
(brace
id|t-&gt;pfm_ovfl_block_reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* will cause blocking */
)brace
)brace
r_else
(brace
id|lost_notify
suffix:colon
multiline_comment|/* XXX: more to do here, to convert to non-blocking (reset values) */
id|DBprintk
c_func
(paren
(paren
l_string|&quot;notification task has disappeared !&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * for a non-blocking context, we make sure we do not fall into the &n;&t;&t; * pfm_overflow_notify() trap. Also in the case of a blocking context with lost &n;&t;&t; * notify process, then we do not want to block either (even though it is &n;&t;&t; * interruptible). In this case, the PMU will be kept frozen and the process will &n;&t;&t; * run to completion without monitoring enabled.&n;&t;&t; *&n;&t;&t; * Of course, we cannot loose notify process when self-monitoring.&n;&t;&t; */
id|t-&gt;pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If notification was successful, then we rely on the pfm_restart()&n;&t; * call to unfreeze and reset (in both blocking or non-blocking mode).&n;&t; *&n;&t; * If notification failed, then we will keep the PMU frozen and run&n;&t; * the task to completion&n;&t; */
id|ctx-&gt;ctx_fl_frozen
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;reload pmc0=0x%x must_block=%ld&bslash;n&quot;
comma
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
comma
id|t-&gt;pfm_ovfl_block_reset
)paren
)paren
suffix:semicolon
r_return
id|ctx-&gt;ctx_fl_frozen
ques
c_cond
l_int|0x1
suffix:colon
l_int|0x0
suffix:semicolon
)brace
r_static
r_void
id|perfmon_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|pmc0
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|pfm_ovfl_intr_count
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * srlz.d done before arriving here&n;&t; *&n;&t; * This is slow&n;&t; */
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we have some pending bits set&n;&t; * assumes : if any PM[0].bit[63-1] is set, then PMC[0].fr = 1&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
op_complement
l_int|0x1UL
)paren
op_ne
l_int|0UL
op_logical_and
(paren
id|task
op_assign
id|PMU_OWNER
c_func
(paren
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* &n;&t;&t; * assumes, PMC[0].fr = 1 at this point &n;&t;&t; *&n;&t;&t; * XXX: change protype to pass &amp;pmc0&n;&t;&t; */
id|pmc0
op_assign
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|pmc0
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* we never explicitely freeze PMU here */
r_if
c_cond
(paren
id|pmc0
op_eq
l_int|0
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|pfm_spurious_ovfl_intr_count
op_increment
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;perfmon: Spurious PMU overflow interrupt on CPU%d: pmc0=0x%lx owner=%p&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|pmc0
comma
(paren
r_void
op_star
)paren
id|PMU_OWNER
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for debug only */
r_static
r_int
id|perfmon_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
macro_line|#ifdef CONFIG_SMP
mdefine_line|#define cpu_is_online(i) (cpu_online_map &amp; (1UL &lt;&lt; i))
macro_line|#else
mdefine_line|#define cpu_is_online(i)        1
macro_line|#endif
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;perfmon enabled: %s&bslash;n&quot;
comma
id|pmu_conf.pfm_is_disabled
ques
c_cond
l_string|&quot;No&quot;
suffix:colon
l_string|&quot;Yes&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;monitors_pmcs0]=0x%lx&bslash;n&quot;
comma
id|pmu_conf.monitor_pmcs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;counter_pmcds[0]=0x%lx&bslash;n&quot;
comma
id|pmu_conf.counter_pmds
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;overflow interrupts=%lu&bslash;n&quot;
comma
id|pfm_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;spurious overflow interrupts=%lu&bslash;n&quot;
comma
id|pfm_spurious_ovfl_intr_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;recorded samples=%lu&bslash;n&quot;
comma
id|pfm_recorded_samples_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.pmc[0]=%lx&bslash;nPerfmon debug: %s&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|pmc0
comma
id|pfm_debug
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d cpu_data.pfm_syst_wide=%d cpu_data.dcr_pp=%d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|local_cpu_data-&gt;pfm_syst_wide
comma
id|local_cpu_data-&gt;pfm_dcr_pp
)paren
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;proc_sessions=%lu&bslash;nsys_sessions=%lu&bslash;nsys_use_dbregs=%lu&bslash;nptrace_use_dbregs=%lu&bslash;n&quot;
comma
id|pfm_sessions.pfs_task_sessions
comma
id|pfm_sessions.pfs_sys_sessions
comma
id|pfm_sessions.pfs_sys_use_dbregs
comma
id|pfm_sessions.pfs_ptrace_use_dbregs
)paren
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_online
c_func
(paren
id|i
)paren
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.pmu_owner: %-6d&bslash;n&quot;
comma
id|i
comma
id|pmu_owners
(braket
id|i
)braket
dot
id|owner
ques
c_cond
id|pmu_owners
(braket
id|i
)braket
dot
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/* /proc interface, for debug only */
r_static
r_int
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|perfmon_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_void
id|pfm_syst_wide_update_task
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|mode
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|task
op_plus
id|IA64_STK_OFFSET
)paren
suffix:semicolon
id|regs
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * propagate the value of the dcr_pp bit to the psr&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|pp
op_assign
id|mode
ques
c_cond
id|local_cpu_data-&gt;pfm_dcr_pp
suffix:colon
l_int|0
suffix:semicolon
)brace
r_void
id|pfm_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|psr
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the last instruction which can generate an overflow&n;&t; *&n;&t; * We do not need to set psr.sp because, it is irrelevant in kernel.&n;&t; * It will be restored from ipsr when going back to user level&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|ctx-&gt;ctx_saved_psr
op_assign
id|psr
suffix:semicolon
singleline_comment|//ctx-&gt;ctx_last_cpu  = smp_processor_id();
)brace
r_static
r_void
id|pfm_lazy_save_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;on [%d] by [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* &n;&t; * announce we are saving this PMU state&n;&t; * This will cause other CPU, to wait until we&squot;re done&n;&t; * before using the context.h&n;&t; *&n;&t; * must be an atomic operation&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  * if owner is NULL, it means that the other CPU won the race&n;&t;  * and the IPI has caused the context to be saved in pfm_handle_fectch_regs()&n;&t;  * instead of here. We have nothing to do&n;&t;  *&n;&t;  * note that this is safe, because the other CPU NEVER modifies saving_in_progress.&n;&t;  */
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|do_nothing
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * do not own the PMU&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX: simplify to pmc0 only&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* not owned by this CPU */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|do_nothing
suffix:colon
multiline_comment|/*&n;&t; * declare we are done saving this context&n;&t; *&n;&t; * must be an atomic operation&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * Handles request coming from other CPUs&n; */
r_static
r_void
id|pfm_handle_fetch_regs
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|pfm_smp_ipi_arg_t
op_star
id|arg
op_assign
id|info
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ctx
op_assign
id|arg-&gt;task-&gt;thread.pfm_context
suffix:semicolon
id|t
op_assign
op_amp
id|arg-&gt;task-&gt;thread
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;task=%d owner=%d saving=%d&bslash;n&quot;
comma
id|arg-&gt;task-&gt;pid
comma
id|PMU_OWNER
c_func
(paren
)paren
ques
c_cond
id|PMU_OWNER
c_func
(paren
)paren
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* must wait if saving was interrupted */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
)paren
)paren
(brace
id|arg-&gt;retval
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* can proceed, done with context */
r_if
c_cond
(paren
id|PMU_OWNER
c_func
(paren
)paren
op_ne
id|arg-&gt;task
)paren
(brace
id|arg-&gt;retval
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;saving state for [%d] save_pmcs=0x%lx all_pmcs=0x%lx used_pmds=0x%lx&bslash;n&quot;
comma
id|arg-&gt;task-&gt;pid
comma
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
comma
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: will be replaced with pure assembly call&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX needs further optimization.&n;&t; * Also must take holes into account&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|mask
op_assign
id|ctx-&gt;ctx_saved_pmcs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* not owned by this CPU */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* can proceed */
id|arg-&gt;retval
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function call to fetch PMU state from another CPU identified by &squot;cpu&squot;.&n; * If the context is being saved on the remote CPU, then we busy wait until&n; * the saving is done and then we return. In this case, non IPI is sent.&n; * Otherwise, we send an IPI to the remote CPU, potentially interrupting &n; * pfm_lazy_save_regs() over there.&n; *&n; * If the retval==1, then it means that we interrupted remote save and that we must&n; * wait until the saving is over before proceeding.&n; * Otherwise, we did the saving on the remote CPU, and it was done by the time we got there.&n; * in either case, we can proceed.&n; */
r_static
r_void
id|pfm_fetch_regs
c_func
(paren
r_int
id|cpu
comma
r_struct
id|task_struct
op_star
id|task
comma
id|pfm_context_t
op_star
id|ctx
)paren
(brace
id|pfm_smp_ipi_arg_t
id|arg
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|arg.task
op_assign
id|task
suffix:semicolon
id|arg.retval
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;no IPI, must wait for [%d] to be saved on [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cpu
)paren
)paren
suffix:semicolon
multiline_comment|/* busy wait */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;calling CPU %d from CPU %d&bslash;n&quot;
comma
id|cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;refusing to use -1 for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* will send IPI to other CPU and wait for completion of remote call */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|smp_call_function_single
c_func
(paren
id|cpu
comma
id|pfm_handle_fetch_regs
comma
op_amp
id|arg
comma
l_int|0
comma
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: remote CPU call from %d to %d error %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu
comma
id|ret
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we must wait until saving is over on the other CPU&n;&t; * This is the case, where we interrupted the saving which started just at the time we sent the&n;&t; * IPI.&n;&t; */
r_if
c_cond
(paren
id|arg.retval
op_eq
l_int|1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;must wait for [%d] to be saved on [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cpu
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_saving_in_progress
)paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;done saving for [%d] on [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|cpu
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
r_void
id|pfm_load_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
r_struct
id|task_struct
op_star
id|owner
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|u64
id|psr
suffix:semicolon
r_int
id|i
comma
id|cpu
suffix:semicolon
id|owner
op_assign
id|PMU_OWNER
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * if we were the last user, then nothing to do except restore psr&n;&t; */
r_if
c_cond
(paren
id|owner
op_eq
id|task
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|DBprintk
c_func
(paren
(paren
l_string|&quot;invalid last_cpu=%d for [%d]&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;load_regs: must reload for [%d] owner=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|owner
ques
c_cond
id|owner-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * someone else is still using the PMU, first push it out and&n;&t; * then we&squot;ll be able to install our stuff !&n;&t; */
r_if
c_cond
(paren
id|owner
)paren
id|pfm_lazy_save_regs
c_func
(paren
id|owner
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* &n;&t; * check if context on another CPU (-1 means saved)&n;&t; * We MUST use the variable, as last_cpu may change behind our &n;&t; * back. If it changes to -1 (not on a CPU anymore), then in cpu&n;&t; * we have the last CPU the context was on. We may be sending the &n;&t; * IPI for nothing, but we have no way of verifying this. &n;&t; */
id|cpu
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ne
op_minus
l_int|1
)paren
(brace
id|pfm_fetch_regs
c_func
(paren
id|cpu
comma
id|task
comma
id|ctx
)paren
suffix:semicolon
)brace
macro_line|#endif
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: will be replaced by assembly routine&n;&t; * We clear all unused PMDs to avoid leaking information&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmd
c_func
(paren
id|i
comma
id|t-&gt;pmd
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX: will need to clear all unused pmd, for security */
multiline_comment|/* &n;&t; * skip pmc[0] to avoid side-effects, &n;&t; * all PMCs are systematically reloaded, unsued get default value&n;&t; * to avoid picking up stale configuration&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_pmc
c_func
(paren
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restore debug registers when used for range restrictions.&n;&t; * We must restore the unused registers to avoid picking up&n;&t; * stale information.&n;&t; */
id|mask
op_assign
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_ibr
c_func
(paren
id|i
comma
id|t-&gt;ibr
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|ia64_set_ibr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
id|mask
op_assign
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|ia64_set_dbr
c_func
(paren
id|i
comma
id|t-&gt;dbr
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|ia64_set_dbr
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;pmc
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x1
)paren
(brace
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pfm_overflow_handler
c_func
(paren
id|task
comma
id|t-&gt;pmc
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fl_frozen==1 when we are in blocking mode waiting for restart&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_frozen
op_eq
l_int|0
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|SET_PMU_OWNER
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restore the psr we changed in pfm_save_regs()&n;&t; */
id|psr
op_assign
id|ctx-&gt;ctx_saved_psr
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;; srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
id|pfm_model_specific_reset_pmu
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_ITANIUM
multiline_comment|/* opcode matcher set to all 1s */
id|ia64_set_pmc
c_func
(paren
l_int|8
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|9
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* I-EAR config cleared, plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|10
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* D-EAR config cleared, PMC[11].pt must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|11
comma
l_int|1UL
op_lshift
l_int|28
)paren
suffix:semicolon
multiline_comment|/* BTB config. plm=0 */
id|ia64_set_pmc
c_func
(paren
l_int|12
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* Instruction address range, PMC[13].ta must be 1 */
id|ia64_set_pmc
c_func
(paren
l_int|13
comma
l_int|1UL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Clear all PMDs &n;&t; *&n;&t; * XXX: may be good enough to rely on the impl_regs to generalize&n;&t; * this. &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|18
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|i
comma
l_int|0UL
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * XXX: this routine is not very portable for PMCs&n; * XXX: make this routine able to work with non current context&n; */
r_static
r_void
id|ia64_reset_pmu
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: invalid task in ia64_reset_pmu()&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* PMU is frozen, no pending overflow bits */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s first do the architected initializations&n;&t; */
multiline_comment|/* clear counters */
id|ia64_set_pmd
c_func
(paren
l_int|4
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|5
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|6
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
l_int|7
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* clear overflow status bits */
id|ia64_set_pmc
c_func
(paren
l_int|1
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|2
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|3
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* clear counting monitor configuration */
id|ia64_set_pmc
c_func
(paren
l_int|4
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|5
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|6
comma
l_int|0UL
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|7
comma
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now let&squot;s do the CPU model specific initializations&n;&t; */
id|pfm_model_specific_reset_pmu
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * On context switched restore, we must restore ALL pmc even&n;&t; * when they are not actively used by the task. In UP, the incoming process &n;&t; * may otherwise pick up left over PMC state from the previous process.&n;&t; * As opposed to PMD, stale PMC can cause harm to the incoming&n;&t; * process because they may change what is being measured. &n;&t; * Therefore, we must systematically reinstall the entire&n;&t; * PMC state. In SMP, the same thing is possible on the &n;&t; * same CPU but also on between 2 CPUs.&n;&t; *&n;&t; * There is unfortunately no easy way to avoid this problem&n;&t; * on either UP or SMP. This definitively slows down the &n;&t; * pfm_load_regs(). &n;&t; */
multiline_comment|/*&n;&t;  * We must include all the PMC in this mask to make sure we don&squot;t&n;&t;  * see any side effect of the stale state, such as opcode matching&n;&t;  * or range restrictions, for instance.&n;&t;  */
id|ctx-&gt;ctx_reload_pmcs
(braket
l_int|0
)braket
op_assign
id|pmu_conf.impl_regs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * make sure we pick up whatever values were installed&n;&t; * for the CPU model specific reset. We also include&n;&t; * the architected PMC (pmc4-pmc7)&n;&t; *&n;&t; * This step is required in order to restore the correct values in PMC when&n;&t; * the task is switched out and back in just after the PFM_ENABLE.&n;&t; */
id|mask
op_assign
id|pmu_conf.impl_regs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * useful in case of re-enable after disable&n;&t; */
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_used_ibrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ctx-&gt;ctx_used_dbrs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when a thread exits (from exit_thread()).&n; * This is a simplified pfm_save_regs() that simply flushes the current&n; * register state into the save area taking into account any pending&n; * overflow. This time no notification is sent because the task is dying&n; * anyway. The inline processing of overflows avoids loosing some counts.&n; * The PMU is frozen on exit from this call and is to never be reenabled&n; * again for this task.&n; *&n; */
r_void
id|pfm_flush_regs
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|u64
id|pmc0
suffix:semicolon
r_int
r_int
id|mask
comma
id|mask2
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; * that&squot;s it if context already disabled&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_flags.state
op_eq
id|PFM_CTX_DISABLED
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in-flight.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
multiline_comment|/* disable dcr pp */
id|ia64_set_dcr
c_func
(paren
id|ia64_get_dcr
c_func
(paren
)paren
op_amp
op_complement
id|IA64_DCR_PP
)paren
suffix:semicolon
id|local_cpu_data-&gt;pfm_syst_wide
op_assign
l_int|0
suffix:semicolon
id|local_cpu_data-&gt;pfm_dcr_pp
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.pp;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;rum psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* no more save/restore on ctxsw */
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Mark the PMU as not owned&n;&t; * This will cause the interrupt handler to do nothing in case an overflow&n;&t; * interrupt was in-flight&n;&t; * This also guarantees that pmc0 will contain the final state&n;&t; * It virtually gives us full control on overflow processing from that point&n;&t; * on.&n;&t; * It must be an atomic operation.&n;&t; */
id|SET_PMU_OWNER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * we are guaranteed to read the final stable state&n;&t; */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* slow */
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t need to restore psr, because we are on our way out anyway&n;&t; */
multiline_comment|/*&n;&t; * This loop flushes the PMD into the PFM context.&n;&t; * It also processes overflow inline.&n;&t; *&n;&t; * IMPORTANT: No notification is sent at this point as the process is dying.&n;&t; * The implicit notification will come from a SIGCHILD or a return from a&n;&t; * waitpid().&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;perfmon: [%d] last_cpu=%d&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
)paren
)paren
suffix:semicolon
id|mask
op_assign
id|pmc0
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask2
op_assign
id|ctx-&gt;ctx_used_pmds
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|mask2
suffix:semicolon
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
comma
id|mask2
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* skip non used pmds */
r_if
c_cond
(paren
(paren
id|mask2
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTING
c_func
(paren
id|i
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] soft_pmd=0x%lx hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
comma
id|val
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
multiline_comment|/* collect latest results */
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
id|val
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * now everything is in ctx_soft_pmds[] and we need&n;&t;&t;&t; * to clear the saved context from save_regs() such that&n;&t;&t;&t; * pfm_read_pmds() gets the correct value&n;&t;&t;&t; */
id|task-&gt;thread.pmd
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* take care of overflow inline */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] overflowed soft_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|ctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] pmd[%d] hw_pmd=0x%lx&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|i
comma
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/* not a counter, just save value as is */
id|task-&gt;thread.pmd
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * indicates that context has been saved&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * task is the newly created task, pt_regs for new child&n; */
r_int
id|pfm_inherit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|current-&gt;thread.pfm_context
suffix:semicolon
id|pfm_context_t
op_star
id|nctx
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
op_assign
op_amp
id|task-&gt;thread
suffix:semicolon
r_int
r_int
id|m
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * make sure child cannot mess up the monitoring session&n;&t; */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|sp
op_assign
l_int|1
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;enabling psr.sp for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  * remove any sampling buffer mapping from child user &n;&t;  * address space. Must be done for all cases of inheritance.&n;&t;  */
r_if
c_cond
(paren
id|ctx-&gt;ctx_smpl_vaddr
)paren
id|pfm_remove_smpl_mapping
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * takes care of easiest case first&n;&t; */
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_NONE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;removing PFM context for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy_thread() clears IA64_THREAD_PM_VALID */
r_return
l_int|0
suffix:semicolon
)brace
id|nctx
op_assign
id|pfm_context_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* copy content */
op_star
id|nctx
op_assign
op_star
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|CTX_INHERIT_MODE
c_func
(paren
id|ctx
)paren
op_eq
id|PFM_FL_INHERIT_ONCE
)paren
(brace
id|nctx-&gt;ctx_fl_inherit
op_assign
id|PFM_FL_INHERIT_NONE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|nctx-&gt;ctx_last_cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * task is not yet visible in the tasklist, so we do &n;&t;&t; * not need to lock the newly created context.&n;&t;&t; * However, we must grab the tasklist_lock to ensure&n;&t;&t; * that the ctx_owner or ctx_notify_task do not disappear&n;&t;&t; * while we increment their check counters.&n;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx-&gt;ctx_notify_task
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nctx-&gt;ctx_owner
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;downgrading to INHERIT_NONE for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|pfm_sessions.pfs_task_sessions
op_increment
suffix:semicolon
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize counters in new context */
id|m
op_assign
id|pmu_conf.counter_pmds
(braket
l_int|0
)braket
op_rshift
id|PMU_FIRST_COUNTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|m
op_amp
l_int|0x1
)paren
(brace
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|val
op_assign
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|th-&gt;pmd
(braket
id|i
)braket
op_assign
id|nctx-&gt;ctx_soft_pmds
(braket
id|i
)braket
dot
id|ival
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
)brace
)brace
multiline_comment|/* clear BTB index register */
id|th-&gt;pmd
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if sampling then increment number of users of buffer */
r_if
c_cond
(paren
id|nctx-&gt;ctx_psb
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX: nopt very pretty!&n;&t;&t; */
id|LOCK_PSB
c_func
(paren
id|nctx-&gt;ctx_psb
)paren
suffix:semicolon
id|nctx-&gt;ctx_psb-&gt;psb_refcnt
op_increment
suffix:semicolon
id|UNLOCK_PSB
c_func
(paren
id|nctx-&gt;ctx_psb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * remove any pointer to sampling buffer mapping&n;&t; &t; */
id|nctx-&gt;ctx_smpl_vaddr
op_assign
l_int|0
suffix:semicolon
)brace
id|nctx-&gt;ctx_fl_frozen
op_assign
l_int|0
suffix:semicolon
id|nctx-&gt;ctx_ovfl_regs
(braket
l_int|0
)braket
op_assign
l_int|0UL
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|nctx-&gt;ctx_restart_sem
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset this semaphore to locked */
multiline_comment|/* clear pending notification */
id|th-&gt;pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* link with new task */
id|th-&gt;pfm_context
op_assign
id|nctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;nctx=%p for process [%d]&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|nctx
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the copy_thread routine automatically clears&n;&t; * IA64_THREAD_PM_VALID, so we need to reenable it, if it was used by the caller&n;&t; */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;setting PM_VALID for [%d]&bslash;n&quot;
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|th-&gt;flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&n; * We cannot touch any of the PMU registers at this point as we may&n; * not be running on the same CPU the task was last run on.  Therefore&n; * it is assumed that the PMU has been stopped appropriately in&n; * pfm_flush_regs() called from exit_thread(). &n; *&n; * The function is called in the context of the parent via a release_thread()&n; * and wait4(). The task is not in the tasklist anymore.&n; */
r_void
id|pfm_context_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_context_t
op_star
id|ctx
op_assign
id|task-&gt;thread.pfm_context
suffix:semicolon
multiline_comment|/*&n;&t; * check sampling buffer&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;ctx_psb
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|psb
op_assign
id|ctx-&gt;ctx_psb
suffix:semicolon
id|LOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;sampling buffer from [%d] @%p size %ld vma_flag=0x%x&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
comma
id|psb-&gt;psb_flags
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in the case where we are the last user, we may be able to free&n;&t;&t; * the buffer&n;&t;&t; */
id|psb-&gt;psb_refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;psb_refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The flag is cleared in pfm_vm_close(). which gets &n;&t;&t;&t; * called from do_exit() via exit_mm(). &n;&t;&t;&t; * By the time we come here, the task has no more mm context.&n;&t;&t;&t; *&n;&t;&t;&t; * We can only free the psb and buffer here after the vm area&n;&t;&t;&t; * describing the buffer has been removed. This normally happens &n;&t;&t;&t; * as part of do_exit() but the entire mm context is ONLY removed&n;&t;&t;&t; * once its reference counts goes to zero. This is typically&n;&t;&t;&t; * the case except for multi-threaded (several tasks) processes.&n;&t;&t;&t; *&n;&t;&t;&t; * See pfm_vm_close() and pfm_cleanup_smpl_buf() for more details.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|psb-&gt;psb_flags
op_amp
id|PFM_PSB_VMA
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cleaning sampling buffer from [%d] @%p size %ld&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * free the buffer and psb &n;&t;&t;&t;&t; */
id|pfm_rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|psb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* psb may have been deleted */
r_if
c_cond
(paren
id|psb
)paren
id|UNLOCK_PSB
c_func
(paren
id|psb
)paren
suffix:semicolon
)brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;cleaning [%d] pfm_context @%p notify_task=%p check=%d mm=%p&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|ctx
comma
id|ctx-&gt;ctx_notify_task
comma
id|atomic_read
c_func
(paren
op_amp
id|task-&gt;thread.pfm_notifiers_check
)paren
comma
id|task-&gt;mm
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To avoid getting the notified task or owner task scan the entire process &n;&t; * list when they exit, we decrement notifiers_check and owners_check respectively.&n;&t; *&n;&t; * Of course, there is race condition between decreasing the value and the &n;&t; * task exiting. The danger comes from the fact that, in both cases, we have a &n;&t; * direct pointer to a task structure thereby bypassing the tasklist. &n;&t; * We must make sure that, if we have task!= NULL, the target task is still &n;&t; * present and is identical to the initial task specified &n;&t; * during pfm_create_context(). It may already be detached from the tasklist but &n;&t; * that&squot;s okay. Note that it is okay if we miss the deadline and the task scans &n;&t; * the list for nothing, it will affect performance but not correctness. &n;&t; * The correctness is ensured by using the ctx_lock which prevents the &n;&t; * notify_task from changing the fields in our context.&n;&t; * Once holdhing this lock, if we see task!= NULL, then it will stay like&n;&t; * that until we release the lock. If it is NULL already then we came too late.&n;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_notify_task
op_ne
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d], [%d] atomic_sub on [%d] notifiers=%u&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_notify_task-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ctx-&gt;ctx_notify_task-&gt;thread.pfm_notifiers_check
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;ctx_owner
op_ne
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d], [%d] atomic_sub on [%d] owners=%u&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
comma
id|ctx-&gt;ctx_owner-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ctx-&gt;ctx_owner-&gt;thread.pfm_owners_check
)paren
suffix:semicolon
)brace
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|LOCK_PFS
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_system
)paren
(brace
id|pfm_sessions.pfs_sys_session
(braket
id|ctx-&gt;ctx_cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
id|pfm_sessions.pfs_sys_sessions
op_decrement
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;freeing syswide session on CPU%ld&bslash;n&quot;
comma
id|ctx-&gt;ctx_cpu
)paren
)paren
suffix:semicolon
multiline_comment|/* update perfmon debug register counter */
r_if
c_cond
(paren
id|ctx-&gt;ctx_fl_using_dbreg
)paren
(brace
r_if
c_cond
(paren
id|pfm_sessions.pfs_sys_use_dbregs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: invalid release for [%d] sys_use_dbregs=0&bslash;n&quot;
comma
id|task-&gt;pid
)paren
suffix:semicolon
)brace
r_else
id|pfm_sessions.pfs_sys_use_dbregs
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; &t; * remove any CPU pinning&n;&t; &t; */
id|set_cpus_allowed
c_func
(paren
id|task
comma
id|ctx-&gt;ctx_saved_cpus_allowed
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfm_sessions.pfs_task_sessions
op_decrement
suffix:semicolon
)brace
id|UNLOCK_PFS
c_func
(paren
)paren
suffix:semicolon
id|pfm_context_free
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  clean pfm state in thread structure,&n;&t; */
id|task-&gt;thread.pfm_context
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;thread.pfm_ovfl_block_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pfm_notifiers is cleaned in pfm_cleanup_notifiers() */
)brace
multiline_comment|/*&n; * function invoked from release_thread when pfm_smpl_buf_list is not NULL&n; */
r_int
id|pfm_cleanup_smpl_buf
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
id|pfm_smpl_buffer_desc_t
op_star
id|tmp
comma
op_star
id|psb
op_assign
id|task-&gt;thread.pfm_smpl_buf_list
suffix:semicolon
r_if
c_cond
(paren
id|psb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: psb is null in [%d]&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Walk through the list and free the sampling buffer and psb&n;&t; */
r_while
c_loop
(paren
id|psb
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;[%d] freeing smpl @%p size %ld&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
)paren
suffix:semicolon
id|pfm_rvfree
c_func
(paren
id|psb-&gt;psb_hdr
comma
id|psb-&gt;psb_size
)paren
suffix:semicolon
id|tmp
op_assign
id|psb-&gt;psb_next
suffix:semicolon
id|kfree
c_func
(paren
id|psb
)paren
suffix:semicolon
id|psb
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* just in case */
id|task-&gt;thread.pfm_smpl_buf_list
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * function invoked from release_thread to make sure that the ctx_owner field does not&n; * point to an unexisting task.&n; */
r_void
id|pfm_cleanup_owners
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called by [%d] for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to do the 2-step test here, because thread.ctx&n;&t;&t; * is cleaned up only in release_thread() and at that point&n;&t;&t; * the task has been detached from the tasklist which is an&n;&t;&t; * operation which uses the write_lock() on the tasklist_lock&n;&t;&t; * so it cannot run concurrently to this loop. So we have the&n;&t;&t; * guarantee that if we find p and it has a perfmon ctx then&n;&t;&t; * it is going to stay like this for the entire execution of this&n;&t;&t; * loop.&n;&t;&t; */
id|ctx
op_assign
id|p-&gt;thread.pfm_context
suffix:semicolon
singleline_comment|//DBprintk((&quot;[%d] scanning task [%d] ctx=%p&bslash;n&quot;, task-&gt;pid, p-&gt;pid, ctx));
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_owner
op_eq
id|task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;trying for owner [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the spinlock is required to take care of a race condition&n;&t;&t;&t; * with the send_sig_info() call. We must make sure that &n;&t;&t;&t; * either the send_sig_info() completes using a valid task,&n;&t;&t;&t; * or the notify_task is cleared before the send_sig_info()&n;&t;&t;&t; * can pick up a stale value. Note that by the time this&n;&t;&t;&t; * function is executed the &squot;task&squot; is already detached from the&n;&t;&t;&t; * tasklist. The problem is that the notifiers have a direct&n;&t;&t;&t; * pointer to it. It is okay to send a signal to a task in this&n;&t;&t;&t; * stage, it simply will have no effect. But it is better than sending&n;&t;&t;&t; * to a completely destroyed task or worse to a new task using the same&n;&t;&t;&t; * task_struct address.&n;&t;&t;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_owner
op_assign
l_int|NULL
suffix:semicolon
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;done for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function called from release_thread to make sure that the ctx_notify_task is not pointing&n; * to an unexisting task&n; */
r_void
id|pfm_cleanup_notifiers
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|pfm_context_t
op_star
id|ctx
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;called by [%d] for [%d]&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|task-&gt;pid
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to do the 2-step test here, because thread.ctx&n;&t;&t; * is cleaned up only in release_thread() and at that point&n;&t;&t; * the task has been detached from the tasklist which is an&n;&t;&t; * operation which uses the write_lock() on the tasklist_lock&n;&t;&t; * so it cannot run concurrently to this loop. So we have the&n;&t;&t; * guarantee that if we find p and it has a perfmon ctx then&n;&t;&t; * it is going to stay like this for the entire execution of this&n;&t;&t; * loop.&n;&t;&t; */
id|ctx
op_assign
id|p-&gt;thread.pfm_context
suffix:semicolon
singleline_comment|//DBprintk((&quot;[%d] scanning task [%d] ctx=%p&bslash;n&quot;, task-&gt;pid, p-&gt;pid, ctx));
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;ctx_notify_task
op_eq
id|task
)paren
(brace
id|DBprintk
c_func
(paren
(paren
l_string|&quot;trying for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the spinlock is required to take care of a race condition&n;&t;&t;&t; * with the send_sig_info() call. We must make sure that &n;&t;&t;&t; * either the send_sig_info() completes using a valid task,&n;&t;&t;&t; * or the notify_task is cleared before the send_sig_info()&n;&t;&t;&t; * can pick up a stale value. Note that by the time this&n;&t;&t;&t; * function is executed the &squot;task&squot; is already detached from the&n;&t;&t;&t; * tasklist. The problem is that the notifiers have a direct&n;&t;&t;&t; * pointer to it. It is okay to send a signal to a task in this&n;&t;&t;&t; * stage, it simply will have no effect. But it is better than sending&n;&t;&t;&t; * to a completely destroyed task or worse to a new task using the same&n;&t;&t;&t; * task_struct address.&n;&t;&t;&t; */
id|LOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;ctx_notify_task
op_assign
l_int|NULL
suffix:semicolon
id|UNLOCK_CTX
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
l_string|&quot;done for notifier [%d] in [%d]&bslash;n&quot;
comma
id|task-&gt;pid
comma
id|p-&gt;pid
)paren
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
id|handler
suffix:colon
id|perfmon_interrupt
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * perfmon initialization routine, called from the initcall() table&n; */
r_int
id|__init
id|perfmon_init
(paren
r_void
)paren
(brace
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|register_percpu_irq
c_func
(paren
id|IA64_PERFMON_VECTOR
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|pmu_conf.pfm_is_disabled
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: version %u.%u (sampling format v%u.%u) IRQ %u&bslash;n&quot;
comma
id|PFM_VERSION_MAJ
comma
id|PFM_VERSION_MIN
comma
id|PFM_SMPL_VERSION_MAJ
comma
id|PFM_SMPL_VERSION_MIN
comma
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_perf_mon_info
c_func
(paren
id|pmu_conf.impl_regs
comma
op_amp
id|pm_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;perfmon: PAL call failed (%ld), perfmon disabled&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pmu_conf.perf_ovfl_val
op_assign
(paren
l_int|1UL
op_lshift
id|pm_info.pal_perf_mon_info_s.width
)paren
op_minus
l_int|1
suffix:semicolon
id|pmu_conf.max_counters
op_assign
id|pm_info.pal_perf_mon_info_s.generic
suffix:semicolon
id|pmu_conf.num_pmcs
op_assign
id|find_num_pm_regs
c_func
(paren
id|pmu_conf.impl_regs
)paren
suffix:semicolon
id|pmu_conf.num_pmds
op_assign
id|find_num_pm_regs
c_func
(paren
op_amp
id|pmu_conf.impl_regs
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %u bits counters (max value 0x%016lx)&bslash;n&quot;
comma
id|pm_info.pal_perf_mon_info_s.width
comma
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: %lu PMC/PMD pairs, %lu PMCs, %lu PMDs&bslash;n&quot;
comma
id|pmu_conf.max_counters
comma
id|pmu_conf.num_pmcs
comma
id|pmu_conf.num_pmds
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pmu_conf.num_pmds
op_ge
id|IA64_NUM_PMD_REGS
op_logical_or
id|pmu_conf.num_pmcs
op_ge
id|IA64_NUM_PMC_REGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;perfmon: not enough pmc/pmd, perfmon is DISABLED&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no need to continue anyway */
)brace
r_if
c_cond
(paren
id|ia64_pal_debug_info
c_func
(paren
op_amp
id|pmu_conf.num_ibrs
comma
op_amp
id|pmu_conf.num_dbrs
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;perfmon: unable to get number of debug registers&bslash;n&quot;
)paren
suffix:semicolon
id|pmu_conf.num_ibrs
op_assign
id|pmu_conf.num_dbrs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* PAL reports the number of pairs */
id|pmu_conf.num_ibrs
op_lshift_assign
l_int|1
suffix:semicolon
id|pmu_conf.num_dbrs
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t; * list the pmc registers used to control monitors &n;&t; * XXX: unfortunately this information is not provided by PAL&n;&t; *&n;&t; * We start with the architected minimum and then refine for each CPU model&n;&t; */
id|pmu_conf.monitor_pmcs
(braket
l_int|0
)braket
op_assign
id|PMM
c_func
(paren
l_int|4
)paren
op_or
id|PMM
c_func
(paren
l_int|5
)paren
op_or
id|PMM
c_func
(paren
l_int|6
)paren
op_or
id|PMM
c_func
(paren
l_int|7
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * architected counters&n;&t; */
id|pmu_conf.counter_pmds
(braket
l_int|0
)braket
op_or_assign
id|PMM
c_func
(paren
l_int|4
)paren
op_or
id|PMM
c_func
(paren
l_int|5
)paren
op_or
id|PMM
c_func
(paren
l_int|6
)paren
op_or
id|PMM
c_func
(paren
l_int|7
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ITANIUM
id|pmu_conf.monitor_pmcs
(braket
l_int|0
)braket
op_or_assign
id|PMM
c_func
(paren
l_int|10
)paren
op_or
id|PMM
c_func
(paren
l_int|11
)paren
op_or
id|PMM
c_func
(paren
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Itanium does not add more counters */
macro_line|#endif
multiline_comment|/* we are all set */
id|pmu_conf.pfm_is_disabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pfm_sessions.pfs_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__initcall
c_func
(paren
id|perfmon_init
)paren
suffix:semicolon
r_void
id|perfmon_init_percpu
(paren
r_void
)paren
(brace
id|ia64_set_pmv
c_func
(paren
id|IA64_PERFMON_VECTOR
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_void
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
