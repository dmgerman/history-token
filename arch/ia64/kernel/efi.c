multiline_comment|/*&n; * Extensible Firmware Interface&n; *&n; * Based on Extensible Firmware Interface Specification version 0.9 April 30, 1999&n; *&n; * Copyright (C) 1999 VA Linux Systems&n; * Copyright (C) 1999 Walt Drummond &lt;drummond@valinux.com&gt;&n; * Copyright (C) 1999-2003 Hewlett-Packard Co.&n; *&t;David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&t;Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *&n; * All EFI Runtime Services are not implemented yet as EFI only&n; * supports physical mode addressing on SoftSDV. This is to be fixed&n; * in a future version.  --drummond 1999-07-20&n; *&n; * Implemented EFI runtime services and virtual mode calls.  --davidm&n; *&n; * Goutham Rao: &lt;goutham.rao@intel.com&gt;&n; *&t;Skip non-WB memory and ignore empty memory ranges.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/kregs.h&gt;
macro_line|#include &lt;asm/meminit.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/mca.h&gt;
DECL|macro|EFI_DEBUG
mdefine_line|#define EFI_DEBUG&t;0
r_extern
id|efi_status_t
id|efi_call_phys
(paren
r_void
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
DECL|variable|efi
r_struct
id|efi
id|efi
suffix:semicolon
DECL|variable|efi
id|EXPORT_SYMBOL
c_func
(paren
id|efi
)paren
suffix:semicolon
DECL|variable|runtime
r_static
id|efi_runtime_services_t
op_star
id|runtime
suffix:semicolon
DECL|variable|mem_limit
DECL|variable|max_addr
r_static
r_int
r_int
id|mem_limit
op_assign
op_complement
l_int|0UL
comma
id|max_addr
op_assign
op_complement
l_int|0UL
suffix:semicolon
DECL|macro|efi_call_virt
mdefine_line|#define efi_call_virt(f, args...)&t;(*(f))(args)
DECL|macro|STUB_GET_TIME
mdefine_line|#define STUB_GET_TIME(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;prefix##_get_time (efi_time_t *tm, efi_time_cap_t *tc)&t;&t;&t;&t;&t;&t;  &bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;efi_time_cap_t *atc = NULL;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;if (tc)&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;&t;atc = adjust_arg(tc);&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ret = efi_call_##prefix((efi_get_time_t *) __va(runtime-&gt;get_time), adjust_arg(tm), atc); &bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;}
DECL|macro|STUB_SET_TIME
mdefine_line|#define STUB_SET_TIME(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_set_time (efi_time_t *tm)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_set_time_t *) __va(runtime-&gt;set_time), adjust_arg(tm));&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_GET_WAKEUP_TIME
mdefine_line|#define STUB_GET_WAKEUP_TIME(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_get_wakeup_time (efi_bool_t *enabled, efi_bool_t *pending, efi_time_t *tm)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_get_wakeup_time_t *) __va(runtime-&gt;get_wakeup_time),&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(enabled), adjust_arg(pending), adjust_arg(tm));&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_SET_WAKEUP_TIME
mdefine_line|#define STUB_SET_WAKEUP_TIME(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_set_wakeup_time (efi_bool_t enabled, efi_time_t *tm)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_time_t *atm = NULL;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (tm)&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;atm = adjust_arg(tm);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_set_wakeup_time_t *) __va(runtime-&gt;set_wakeup_time),&t;&bslash;&n;&t;&t;&t;&t;enabled, atm);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_GET_VARIABLE
mdefine_line|#define STUB_GET_VARIABLE(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_get_variable (efi_char16_t *name, efi_guid_t *vendor, u32 *attr,&t;&t;&bslash;&n;&t;&t;       unsigned long *data_size, void *data)&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;u32 *aattr = NULL;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (attr)&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;aattr = adjust_arg(attr);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_get_variable_t *) __va(runtime-&gt;get_variable),&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(name), adjust_arg(vendor), aattr,&t;&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(data_size), adjust_arg(data));&t;&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_GET_NEXT_VARIABLE
mdefine_line|#define STUB_GET_NEXT_VARIABLE(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_get_next_variable (unsigned long *name_size, efi_char16_t *name, efi_guid_t *vendor)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_get_next_variable_t *) __va(runtime-&gt;get_next_variable),&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(name_size), adjust_arg(name), adjust_arg(vendor));&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_SET_VARIABLE
mdefine_line|#define STUB_SET_VARIABLE(prefix, adjust_arg)&t;&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_set_variable (efi_char16_t *name, efi_guid_t *vendor, unsigned long attr,&t;&bslash;&n;&t;&t;       unsigned long data_size, void *data)&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_set_variable_t *) __va(runtime-&gt;set_variable),&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(name), adjust_arg(vendor), attr, data_size,&t;&bslash;&n;&t;&t;&t;&t;adjust_arg(data));&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_GET_NEXT_HIGH_MONO_COUNT
mdefine_line|#define STUB_GET_NEXT_HIGH_MONO_COUNT(prefix, adjust_arg)&t;&t;&t;&t;&t;&bslash;&n;static efi_status_t&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_get_next_high_mono_count (u32 *count)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_status_t ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = efi_call_##prefix((efi_get_next_high_mono_count_t *)&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;__va(runtime-&gt;get_next_high_mono_count), adjust_arg(count));&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|STUB_RESET_SYSTEM
mdefine_line|#define STUB_RESET_SYSTEM(prefix, adjust_arg)&t;&t;&t;&t;&t;&bslash;&n;static void&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;prefix##_reset_system (int reset_type, efi_status_t status,&t;&t;&t;&bslash;&n;&t;&t;       unsigned long data_size, efi_char16_t *data)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ia64_fpreg fr[6];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_char16_t *adata = NULL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (data)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;adata = adjust_arg(data);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ia64_save_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;efi_call_##prefix((efi_reset_system_t *) __va(runtime-&gt;reset_system),&t;&bslash;&n;&t;&t;&t;  reset_type, status, data_size, adata);&t;&t;&bslash;&n;&t;/* should not return, but just in case... */&t;&t;&t;&t;&bslash;&n;&t;ia64_load_scratch_fpregs(fr);&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|phys_ptr
mdefine_line|#define phys_ptr(arg)&t;((__typeof__(arg)) ia64_tpa(arg))
DECL|function|STUB_GET_TIME
id|STUB_GET_TIME
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_SET_TIME
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_GET_WAKEUP_TIME
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_SET_WAKEUP_TIME
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_GET_VARIABLE
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_GET_NEXT_VARIABLE
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_SET_VARIABLE
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_GET_NEXT_HIGH_MONO_COUNT
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
id|STUB_RESET_SYSTEM
c_func
(paren
id|phys
comma
id|phys_ptr
)paren
DECL|macro|id
mdefine_line|#define id(arg)&t;arg
id|STUB_GET_TIME
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_SET_TIME
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_GET_WAKEUP_TIME
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_SET_WAKEUP_TIME
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_GET_VARIABLE
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_GET_NEXT_VARIABLE
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_SET_VARIABLE
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_GET_NEXT_HIGH_MONO_COUNT
c_func
(paren
id|virt
comma
id|id
)paren
id|STUB_RESET_SYSTEM
c_func
(paren
id|virt
comma
id|id
)paren
r_void
id|efi_gettimeofday
(paren
r_struct
id|timespec
op_star
id|ts
)paren
(brace
id|efi_time_t
id|tm
suffix:semicolon
id|memset
c_func
(paren
id|ts
comma
l_int|0
comma
r_sizeof
(paren
id|ts
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|efi.get_time
)paren
(paren
op_amp
id|tm
comma
l_int|NULL
)paren
op_ne
id|EFI_SUCCESS
)paren
r_return
suffix:semicolon
id|ts-&gt;tv_sec
op_assign
id|mktime
c_func
(paren
id|tm.year
comma
id|tm.month
comma
id|tm.day
comma
id|tm.hour
comma
id|tm.minute
comma
id|tm.second
)paren
suffix:semicolon
id|ts-&gt;tv_nsec
op_assign
id|tm.nanosecond
suffix:semicolon
)brace
r_static
r_int
DECL|function|is_available_memory
id|is_available_memory
(paren
id|efi_memory_desc_t
op_star
id|md
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|md-&gt;type
)paren
(brace
r_case
id|EFI_LOADER_CODE
suffix:colon
r_case
id|EFI_LOADER_DATA
suffix:colon
r_case
id|EFI_BOOT_SERVICES_CODE
suffix:colon
r_case
id|EFI_BOOT_SERVICES_DATA
suffix:colon
r_case
id|EFI_CONVENTIONAL_MEMORY
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Trim descriptor MD so its starts at address START_ADDR.  If the descriptor covers&n; * memory that is normally available to the kernel, issue a warning that some memory&n; * is being ignored.&n; */
r_static
r_void
DECL|function|trim_bottom
id|trim_bottom
(paren
id|efi_memory_desc_t
op_star
id|md
comma
id|u64
id|start_addr
)paren
(brace
id|u64
id|num_skipped_pages
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;phys_addr
op_ge
id|start_addr
op_logical_or
op_logical_neg
id|md-&gt;num_pages
)paren
r_return
suffix:semicolon
id|num_skipped_pages
op_assign
(paren
id|start_addr
op_minus
id|md-&gt;phys_addr
)paren
op_rshift
id|EFI_PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|num_skipped_pages
OG
id|md-&gt;num_pages
)paren
id|num_skipped_pages
op_assign
id|md-&gt;num_pages
suffix:semicolon
r_if
c_cond
(paren
id|is_available_memory
c_func
(paren
id|md
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;efi.%s: ignoring %luKB of memory at 0x%lx due to granule hole &quot;
l_string|&quot;at 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
id|num_skipped_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_rshift
l_int|10
comma
id|md-&gt;phys_addr
comma
id|start_addr
op_minus
id|IA64_GRANULE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: Don&squot;t set md-&gt;phys_addr to START_ADDR because that could cause the memory&n;&t; * descriptor list to become unsorted.  In such a case, md-&gt;num_pages will be&n;&t; * zero, so the Right Thing will happen.&n;&t; */
id|md-&gt;phys_addr
op_add_assign
id|num_skipped_pages
op_lshift
id|EFI_PAGE_SHIFT
suffix:semicolon
id|md-&gt;num_pages
op_sub_assign
id|num_skipped_pages
suffix:semicolon
)brace
r_static
r_void
DECL|function|trim_top
id|trim_top
(paren
id|efi_memory_desc_t
op_star
id|md
comma
id|u64
id|end_addr
)paren
(brace
id|u64
id|num_dropped_pages
comma
id|md_end_addr
suffix:semicolon
id|md_end_addr
op_assign
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_end_addr
op_le
id|end_addr
op_logical_or
op_logical_neg
id|md-&gt;num_pages
)paren
r_return
suffix:semicolon
id|num_dropped_pages
op_assign
(paren
id|md_end_addr
op_minus
id|end_addr
)paren
op_rshift
id|EFI_PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|num_dropped_pages
OG
id|md-&gt;num_pages
)paren
id|num_dropped_pages
op_assign
id|md-&gt;num_pages
suffix:semicolon
r_if
c_cond
(paren
id|is_available_memory
c_func
(paren
id|md
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;efi.%s: ignoring %luKB of memory at 0x%lx due to granule hole &quot;
l_string|&quot;at 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
id|num_dropped_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_rshift
l_int|10
comma
id|md-&gt;phys_addr
comma
id|end_addr
)paren
suffix:semicolon
id|md-&gt;num_pages
op_sub_assign
id|num_dropped_pages
suffix:semicolon
)brace
multiline_comment|/*&n; * Walks the EFI memory map and calls CALLBACK once for each EFI memory descriptor that&n; * has memory that is available for OS use.&n; */
r_void
DECL|function|efi_memmap_walk
id|efi_memmap_walk
(paren
id|efi_freemem_callback_t
id|callback
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|prev_valid
op_assign
l_int|0
suffix:semicolon
r_struct
id|range
(brace
id|u64
id|start
suffix:semicolon
id|u64
id|end
suffix:semicolon
)brace
id|prev
comma
id|curr
suffix:semicolon
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
comma
op_star
id|check_md
suffix:semicolon
id|u64
id|efi_desc_size
comma
id|start
comma
id|end
comma
id|granule_addr
comma
id|last_granule_addr
comma
id|first_non_wb_addr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_mem
op_assign
l_int|0
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
multiline_comment|/* skip over non-WB memory descriptors; that&squot;s all we&squot;re interested in... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * granule_addr is the base of md&squot;s first granule.&n;&t;&t; * [granule_addr - first_non_wb_addr) is guaranteed to&n;&t;&t; * be contiguous WB memory.&n;&t;&t; */
id|granule_addr
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
id|md-&gt;phys_addr
)paren
suffix:semicolon
id|first_non_wb_addr
op_assign
id|max
c_func
(paren
id|first_non_wb_addr
comma
id|granule_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_non_wb_addr
OL
id|md-&gt;phys_addr
)paren
(brace
id|trim_bottom
c_func
(paren
id|md
comma
id|granule_addr
op_plus
id|IA64_GRANULE_SIZE
)paren
suffix:semicolon
id|granule_addr
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
id|md-&gt;phys_addr
)paren
suffix:semicolon
id|first_non_wb_addr
op_assign
id|max
c_func
(paren
id|first_non_wb_addr
comma
id|granule_addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
id|q
OL
id|efi_map_end
suffix:semicolon
id|q
op_add_assign
id|efi_desc_size
)paren
(brace
id|check_md
op_assign
id|q
suffix:semicolon
r_if
c_cond
(paren
(paren
id|check_md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
op_logical_and
(paren
id|check_md-&gt;phys_addr
op_eq
id|first_non_wb_addr
)paren
)paren
id|first_non_wb_addr
op_add_assign
id|check_md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
suffix:semicolon
r_else
r_break
suffix:semicolon
multiline_comment|/* non-WB or hole */
)brace
id|last_granule_addr
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
id|first_non_wb_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_granule_addr
OL
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
id|trim_top
c_func
(paren
id|md
comma
id|last_granule_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_available_memory
c_func
(paren
id|md
)paren
)paren
(brace
r_if
c_cond
(paren
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_ge
id|max_addr
)paren
(brace
r_if
c_cond
(paren
id|md-&gt;phys_addr
op_ge
id|max_addr
)paren
r_continue
suffix:semicolon
id|md-&gt;num_pages
op_assign
(paren
id|max_addr
op_minus
id|md-&gt;phys_addr
)paren
op_rshift
id|EFI_PAGE_SHIFT
suffix:semicolon
id|first_non_wb_addr
op_assign
id|max_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|total_mem
op_ge
id|mem_limit
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|total_mem
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
OG
id|mem_limit
)paren
(brace
r_int
r_int
id|limit_addr
op_assign
id|md-&gt;phys_addr
suffix:semicolon
id|limit_addr
op_add_assign
id|mem_limit
op_minus
id|total_mem
suffix:semicolon
id|limit_addr
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
id|limit_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;phys_addr
OG
id|limit_addr
)paren
r_continue
suffix:semicolon
id|md-&gt;num_pages
op_assign
(paren
id|limit_addr
op_minus
id|md-&gt;phys_addr
)paren
op_rshift
id|EFI_PAGE_SHIFT
suffix:semicolon
id|first_non_wb_addr
op_assign
id|max_addr
op_assign
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
)brace
id|total_mem
op_add_assign
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;num_pages
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|curr.start
op_assign
id|PAGE_OFFSET
op_plus
id|md-&gt;phys_addr
suffix:semicolon
id|curr.end
op_assign
id|curr.start
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev_valid
)paren
(brace
id|prev
op_assign
id|curr
suffix:semicolon
id|prev_valid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|curr.start
OL
id|prev.start
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Oops: EFI memory table not ordered!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev.end
op_eq
id|curr.start
)paren
(brace
multiline_comment|/* merge two consecutive memory ranges */
id|prev.end
op_assign
id|curr.end
suffix:semicolon
)brace
r_else
(brace
id|start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|prev.start
)paren
suffix:semicolon
id|end
op_assign
id|prev.end
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|end
OG
id|start
)paren
op_logical_and
(paren
op_star
id|callback
)paren
(paren
id|start
comma
id|end
comma
id|arg
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|prev
op_assign
id|curr
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|prev_valid
)paren
(brace
id|start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|prev.start
)paren
suffix:semicolon
id|end
op_assign
id|prev.end
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|start
)paren
(paren
op_star
id|callback
)paren
(paren
id|start
comma
id|end
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Look for the PAL_CODE region reported by EFI and maps it using an&n; * ITR to enable safe PAL calls in virtual mode.  See IA-64 Processor&n; * Abstraction Layer chapter 11 in ADAG&n; */
r_void
DECL|function|efi_map_pal_code
id|efi_map_pal_code
(paren
r_void
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
r_int
id|pal_code_count
op_assign
l_int|0
suffix:semicolon
id|u64
id|mask
comma
id|psr
suffix:semicolon
id|u64
id|vaddr
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;type
op_ne
id|EFI_PAL_CODE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|pal_code_count
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Too many EFI Pal Code memory ranges, dropped @ %lx&bslash;n&quot;
comma
id|md-&gt;phys_addr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The only ITLB entry in region 7 that is used is the one installed by&n;&t;&t; * __start().  That entry covers a 64MB range.&n;&t;&t; */
id|mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|KERNEL_TR_PAGE_SHIFT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|vaddr
op_assign
id|PAGE_OFFSET
op_plus
id|md-&gt;phys_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must check that the PAL mapping won&squot;t overlap with the kernel&n;&t;&t; * mapping.&n;&t;&t; *&n;&t;&t; * PAL code is guaranteed to be aligned on a power of 2 between 4k and&n;&t;&t; * 256KB and that only one ITR is needed to map it. This implies that the&n;&t;&t; * PAL code is always aligned on its size, i.e., the closest matching page&n;&t;&t; * size supported by the TLB. Therefore PAL code is guaranteed never to&n;&t;&t; * cross a 64MB unless it is bigger than 64MB (very unlikely!).  So for&n;&t;&t; * now the following test is enough to determine whether or not we need a&n;&t;&t; * dedicated ITR for the PAL code.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|vaddr
op_amp
id|mask
)paren
op_eq
(paren
id|KERNEL_START
op_amp
id|mask
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no need to install ITR for PAL code&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
OG
id|IA64_GRANULE_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;Woah!  PAL code size bigger than a granule!&quot;
)paren
suffix:semicolon
id|mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|IA64_GRANULE_SHIFT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if EFI_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CPU %d: mapping PAL code [0x%lx-0x%lx) into [0x%lx-0x%lx)&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|md-&gt;phys_addr
comma
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
comma
id|vaddr
op_amp
id|mask
comma
(paren
id|vaddr
op_amp
id|mask
)paren
op_plus
id|IA64_GRANULE_SIZE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Cannot write to CRx with PSR.ic=1&n;&t;&t; */
id|psr
op_assign
id|ia64_clear_ic
c_func
(paren
)paren
suffix:semicolon
id|ia64_itr
c_func
(paren
l_int|0x1
comma
id|IA64_TR_PALCODE
comma
id|vaddr
op_amp
id|mask
comma
id|pte_val
c_func
(paren
id|pfn_pte
c_func
(paren
id|md-&gt;phys_addr
op_rshift
id|PAGE_SHIFT
comma
id|PAGE_KERNEL
)paren
)paren
comma
id|IA64_GRANULE_SHIFT
)paren
suffix:semicolon
id|ia64_set_psr
c_func
(paren
id|psr
)paren
suffix:semicolon
multiline_comment|/* restore psr */
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Put pal_base and pal_paddr in the cpuinfo structure.&n; */
r_void
DECL|function|efi_get_pal_addr
id|efi_get_pal_addr
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
r_int
id|pal_code_count
op_assign
l_int|0
suffix:semicolon
id|u64
id|mask
suffix:semicolon
id|u64
id|vaddr
suffix:semicolon
r_struct
id|cpuinfo_ia64
op_star
id|cpuinfo
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;type
op_ne
id|EFI_PAL_CODE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|pal_code_count
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Too many EFI Pal Code memory ranges, dropped @ %lx&bslash;n&quot;
comma
id|md-&gt;phys_addr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The only ITLB entry in region 7 that is used is the one installed by&n;&t;&t; * __start().  That entry covers a 64MB range.&n;&t;&t; */
id|mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|KERNEL_TR_PAGE_SHIFT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|vaddr
op_assign
id|PAGE_OFFSET
op_plus
id|md-&gt;phys_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must check that the PAL mapping won&squot;t overlap with the kernel&n;&t;&t; * mapping.&n;&t;&t; *&n;&t;&t; * PAL code is guaranteed to be aligned on a power of 2 between 4k and&n;&t;&t; * 256KB and that only one ITR is needed to map it. This implies that the&n;&t;&t; * PAL code is always aligned on its size, i.e., the closest matching page&n;&t;&t; * size supported by the TLB. Therefore PAL code is guaranteed never to&n;&t;&t; * cross a 64MB unless it is bigger than 64MB (very unlikely!).  So for&n;&t;&t; * now the following test is enough to determine whether or not we need a&n;&t;&t; * dedicated ITR for the PAL code.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|vaddr
op_amp
id|mask
)paren
op_eq
(paren
id|KERNEL_START
op_amp
id|mask
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no need to install ITR for PAL code&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
OG
id|IA64_GRANULE_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;Woah!  PAL code size bigger than a granule!&quot;
)paren
suffix:semicolon
id|mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|IA64_GRANULE_SHIFT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* insert this TR into our list for MCA recovery purposes */
id|cpuinfo
op_assign
(paren
r_struct
id|cpuinfo_ia64
op_star
)paren
id|__va
c_func
(paren
id|ia64_get_kr
c_func
(paren
id|IA64_KR_PA_CPU_INFO
)paren
)paren
suffix:semicolon
id|cpuinfo-&gt;pal_base
op_assign
id|vaddr
op_amp
id|mask
suffix:semicolon
id|cpuinfo-&gt;pal_paddr
op_assign
id|pte_val
c_func
(paren
id|mk_pte_phys
c_func
(paren
id|md-&gt;phys_addr
comma
id|PAGE_KERNEL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CPU %d: late efi pal_base 0x%lx pal_paddr 0x%lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpuinfo-&gt;pal_base
comma
id|cpuinfo-&gt;pal_paddr
)paren
suffix:semicolon
)brace
)brace
r_void
id|__init
DECL|function|efi_init
id|efi_init
(paren
r_void
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
suffix:semicolon
id|efi_config_table_t
op_star
id|config_tables
suffix:semicolon
id|efi_char16_t
op_star
id|c16
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|end
comma
id|vendor
(braket
l_int|100
)braket
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_extern
r_char
id|saved_command_line
(braket
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* it&squot;s too early to be able to use the standard kernel command line support... */
r_for
c_loop
(paren
id|cp
op_assign
id|saved_command_line
suffix:semicolon
op_star
id|cp
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|cp
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|cp
op_add_assign
l_int|4
suffix:semicolon
id|mem_limit
op_assign
id|memparse
c_func
(paren
id|cp
comma
op_amp
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
id|cp
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|end
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|cp
comma
l_string|&quot;max_addr=&quot;
comma
l_int|9
)paren
op_eq
l_int|0
)paren
(brace
id|cp
op_add_assign
l_int|9
suffix:semicolon
id|max_addr
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
id|memparse
c_func
(paren
id|cp
comma
op_amp
id|end
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
id|cp
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_star
id|cp
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|cp
)paren
op_increment
id|cp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|cp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|max_addr
op_ne
op_complement
l_int|0UL
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Ignoring memory above %luMB&bslash;n&quot;
comma
id|max_addr
op_rshift
l_int|20
)paren
suffix:semicolon
id|efi.systab
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_systab
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the EFI Table&n;&t; */
r_if
c_cond
(paren
id|efi.systab
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;Woah! Can&squot;t find EFI system table.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.systab-&gt;hdr.signature
op_ne
id|EFI_SYSTEM_TABLE_SIGNATURE
)paren
id|panic
c_func
(paren
l_string|&quot;Woah! EFI system table signature incorrect&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|efi.systab-&gt;hdr.revision
op_xor
id|EFI_SYSTEM_TABLE_REVISION
)paren
op_rshift
l_int|16
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: EFI system table major version mismatch: &quot;
l_string|&quot;got %d.%02d, expected %d.%02d&bslash;n&quot;
comma
id|efi.systab-&gt;hdr.revision
op_rshift
l_int|16
comma
id|efi.systab-&gt;hdr.revision
op_amp
l_int|0xffff
comma
id|EFI_SYSTEM_TABLE_REVISION
op_rshift
l_int|16
comma
id|EFI_SYSTEM_TABLE_REVISION
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|config_tables
op_assign
id|__va
c_func
(paren
id|efi.systab-&gt;tables
)paren
suffix:semicolon
multiline_comment|/* Show what we know for posterity */
id|c16
op_assign
id|__va
c_func
(paren
id|efi.systab-&gt;fw_vendor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c16
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
r_sizeof
(paren
id|vendor
)paren
op_logical_and
op_star
id|c16
suffix:semicolon
op_increment
id|i
)paren
id|vendor
(braket
id|i
)braket
op_assign
op_star
id|c16
op_increment
suffix:semicolon
id|vendor
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EFI v%u.%.02u by %s:&quot;
comma
id|efi.systab-&gt;hdr.revision
op_rshift
l_int|16
comma
id|efi.systab-&gt;hdr.revision
op_amp
l_int|0xffff
comma
id|vendor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|efi.systab-&gt;nr_tables
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|MPS_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.mps
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; MPS=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|ACPI_20_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.acpi20
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ACPI 2.0=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|ACPI_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.acpi
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ACPI=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|SMBIOS_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.smbios
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; SMBIOS=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|SAL_SYSTEM_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.sal_systab
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; SALsystab=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|HCDP_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.hcdp
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; HCDP=0x%lx&quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|runtime
op_assign
id|__va
c_func
(paren
id|efi.systab-&gt;runtime
)paren
suffix:semicolon
id|efi.get_time
op_assign
id|phys_get_time
suffix:semicolon
id|efi.set_time
op_assign
id|phys_set_time
suffix:semicolon
id|efi.get_wakeup_time
op_assign
id|phys_get_wakeup_time
suffix:semicolon
id|efi.set_wakeup_time
op_assign
id|phys_set_wakeup_time
suffix:semicolon
id|efi.get_variable
op_assign
id|phys_get_variable
suffix:semicolon
id|efi.get_next_variable
op_assign
id|phys_get_next_variable
suffix:semicolon
id|efi.set_variable
op_assign
id|phys_set_variable
suffix:semicolon
id|efi.get_next_high_mono_count
op_assign
id|phys_get_next_high_mono_count
suffix:semicolon
id|efi.reset_system
op_assign
id|phys_reset_system
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
macro_line|#if EFI_DEBUG
multiline_comment|/* print EFI memory map: */
(brace
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
op_increment
id|i
comma
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mem%02u: type=%u, attr=0x%lx, range=[0x%016lx-0x%016lx) (%luMB)&bslash;n&quot;
comma
id|i
comma
id|md-&gt;type
comma
id|md-&gt;attribute
comma
id|md-&gt;phys_addr
comma
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
comma
id|md-&gt;num_pages
op_rshift
(paren
l_int|20
op_minus
id|EFI_PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|efi_map_pal_code
c_func
(paren
)paren
suffix:semicolon
id|efi_enter_virtual_mode
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|efi_enter_virtual_mode
id|efi_enter_virtual_mode
(paren
r_void
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|efi_status_t
id|status
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_RUNTIME
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Some descriptors have multiple bits set, so the order of&n;&t;&t;&t; * the tests is relevant.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
(brace
id|md-&gt;virt_addr
op_assign
(paren
id|u64
)paren
id|__va
c_func
(paren
id|md-&gt;phys_addr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_UC
)paren
(brace
id|md-&gt;virt_addr
op_assign
(paren
id|u64
)paren
id|ioremap
c_func
(paren
id|md-&gt;phys_addr
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WC
)paren
(brace
macro_line|#if 0
id|md-&gt;virt_addr
op_assign
id|ia64_remap
c_func
(paren
id|md-&gt;phys_addr
comma
(paren
id|_PAGE_A
op_or
id|_PAGE_P
op_or
id|_PAGE_D
op_or
id|_PAGE_MA_WC
op_or
id|_PAGE_PL_0
op_or
id|_PAGE_AR_RW
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EFI_MEMORY_WC mapping&bslash;n&quot;
)paren
suffix:semicolon
id|md-&gt;virt_addr
op_assign
(paren
id|u64
)paren
id|ioremap
c_func
(paren
id|md-&gt;phys_addr
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WT
)paren
(brace
macro_line|#if 0
id|md-&gt;virt_addr
op_assign
id|ia64_remap
c_func
(paren
id|md-&gt;phys_addr
comma
(paren
id|_PAGE_A
op_or
id|_PAGE_P
op_or
id|_PAGE_D
op_or
id|_PAGE_MA_WT
op_or
id|_PAGE_PL_0
op_or
id|_PAGE_AR_RW
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EFI_MEMORY_WT mapping&bslash;n&quot;
)paren
suffix:semicolon
id|md-&gt;virt_addr
op_assign
(paren
id|u64
)paren
id|ioremap
c_func
(paren
id|md-&gt;phys_addr
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
id|status
op_assign
id|efi_call_phys
c_func
(paren
id|__va
c_func
(paren
id|runtime-&gt;set_virtual_address_map
)paren
comma
id|ia64_boot_param-&gt;efi_memmap_size
comma
id|efi_desc_size
comma
id|ia64_boot_param-&gt;efi_memdesc_version
comma
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;warning: unable to switch EFI into virtual mode &quot;
l_string|&quot;(status=%lu)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now that EFI is in virtual mode, we call the EFI functions more efficiently:&n;&t; */
id|efi.get_time
op_assign
id|virt_get_time
suffix:semicolon
id|efi.set_time
op_assign
id|virt_set_time
suffix:semicolon
id|efi.get_wakeup_time
op_assign
id|virt_get_wakeup_time
suffix:semicolon
id|efi.set_wakeup_time
op_assign
id|virt_set_wakeup_time
suffix:semicolon
id|efi.get_variable
op_assign
id|virt_get_variable
suffix:semicolon
id|efi.get_next_variable
op_assign
id|virt_get_next_variable
suffix:semicolon
id|efi.set_variable
op_assign
id|virt_set_variable
suffix:semicolon
id|efi.get_next_high_mono_count
op_assign
id|virt_get_next_high_mono_count
suffix:semicolon
id|efi.reset_system
op_assign
id|virt_reset_system
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk the EFI memory map looking for the I/O port range.  There can only be one entry of&n; * this type, other I/O port ranges should be described via ACPI.&n; */
id|u64
DECL|function|efi_get_iobase
id|efi_get_iobase
(paren
r_void
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;type
op_eq
id|EFI_MEMORY_MAPPED_IO_PORT_SPACE
)paren
(brace
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_UC
)paren
r_return
id|md-&gt;phys_addr
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|u32
DECL|function|efi_mem_type
id|efi_mem_type
(paren
r_int
r_int
id|phys_addr
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|phys_addr
op_minus
id|md-&gt;phys_addr
OL
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
r_return
id|md-&gt;type
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|u64
DECL|function|efi_mem_attributes
id|efi_mem_attributes
(paren
r_int
r_int
id|phys_addr
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|phys_addr
op_minus
id|md-&gt;phys_addr
OL
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
r_return
id|md-&gt;attribute
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|valid_phys_addr_range
id|valid_phys_addr_range
(paren
r_int
r_int
id|phys_addr
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_void
op_star
id|efi_map_start
comma
op_star
id|efi_map_end
comma
op_star
id|p
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|u64
id|efi_desc_size
suffix:semicolon
id|efi_map_start
op_assign
id|__va
c_func
(paren
id|ia64_boot_param-&gt;efi_memmap
)paren
suffix:semicolon
id|efi_map_end
op_assign
id|efi_map_start
op_plus
id|ia64_boot_param-&gt;efi_memmap_size
suffix:semicolon
id|efi_desc_size
op_assign
id|ia64_boot_param-&gt;efi_memdesc_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|efi_map_start
suffix:semicolon
id|p
OL
id|efi_map_end
suffix:semicolon
id|p
op_add_assign
id|efi_desc_size
)paren
(brace
id|md
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|phys_addr
op_minus
id|md-&gt;phys_addr
OL
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|size
OG
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_minus
id|phys_addr
)paren
op_star
id|size
op_assign
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_minus
id|phys_addr
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
id|__init
DECL|function|efi_uart_console_only
id|efi_uart_console_only
c_func
(paren
r_void
)paren
(brace
id|efi_status_t
id|status
suffix:semicolon
r_char
op_star
id|s
comma
id|name
(braket
)braket
op_assign
l_string|&quot;ConOut&quot;
suffix:semicolon
id|efi_guid_t
id|guid
op_assign
id|EFI_GLOBAL_VARIABLE_GUID
suffix:semicolon
id|efi_char16_t
op_star
id|utf16
comma
id|name_utf16
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|1024
)braket
suffix:semicolon
r_int
r_int
id|size
op_assign
r_sizeof
(paren
id|data
)paren
suffix:semicolon
r_struct
id|efi_generic_dev_path
op_star
id|hdr
comma
op_star
id|end_addr
suffix:semicolon
r_int
id|uart
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Convert to UTF-16 */
id|utf16
op_assign
id|name_utf16
suffix:semicolon
id|s
op_assign
id|name
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
)paren
op_star
id|utf16
op_increment
op_assign
op_star
id|s
op_increment
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|utf16
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|efi
dot
id|get_variable
c_func
(paren
id|name_utf16
comma
op_amp
id|guid
comma
l_int|NULL
comma
op_amp
id|size
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No EFI %s variable?&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hdr
op_assign
(paren
r_struct
id|efi_generic_dev_path
op_star
)paren
id|data
suffix:semicolon
id|end_addr
op_assign
(paren
r_struct
id|efi_generic_dev_path
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|data
op_plus
id|size
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hdr
OL
id|end_addr
)paren
(brace
r_if
c_cond
(paren
id|hdr-&gt;type
op_eq
id|EFI_DEV_MSG
op_logical_and
id|hdr-&gt;sub_type
op_eq
id|EFI_DEV_MSG_UART
)paren
id|uart
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hdr-&gt;type
op_eq
id|EFI_DEV_END_PATH
op_logical_or
id|hdr-&gt;type
op_eq
id|EFI_DEV_END_PATH2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|uart
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;sub_type
op_eq
id|EFI_DEV_END_ENTIRE
)paren
r_return
l_int|1
suffix:semicolon
id|uart
op_assign
l_int|0
suffix:semicolon
)brace
id|hdr
op_assign
(paren
r_struct
id|efi_generic_dev_path
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|hdr
op_plus
id|hdr-&gt;length
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Malformed %s value&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
