multiline_comment|/*&n; * File:&t;mca.c&n; * Purpose:&t;Generic MCA handling layer&n; *&n; * Updated for latest kernel&n; * Copyright (C) 2003 Hewlett-Packard Co&n; *&t;David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * Copyright (C) 2002 Dell Inc.&n; * Copyright (C) Matt Domsch (Matt_Domsch@dell.com)&n; *&n; * Copyright (C) 2002 Intel&n; * Copyright (C) Jenna Hall (jenna.s.hall@intel.com)&n; *&n; * Copyright (C) 2001 Intel&n; * Copyright (C) Fred Lewis (frederick.v.lewis@intel.com)&n; *&n; * Copyright (C) 2000 Intel&n; * Copyright (C) Chuck Fleckenstein (cfleck@co.intel.com)&n; *&n; * Copyright (C) 1999, 2004 Silicon Graphics, Inc.&n; * Copyright (C) Vijay Chander(vijay@engr.sgi.com)&n; *&n; * 03/04/15 D. Mosberger Added INIT backtrace support.&n; * 02/03/25 M. Domsch&t;GUID cleanups&n; *&n; * 02/01/04 J. Hall&t;Aligned MCA stack to 16 bytes, added platform vs. CPU&n; *&t;&t;&t;error flag, set SAL default return values, changed&n; *&t;&t;&t;error record structure to linked list, added init call&n; *&t;&t;&t;to sal_get_state_info_size().&n; *&n; * 01/01/03 F. Lewis    Added setup of CMCI and CPEI IRQs, logging of corrected&n; *                      platform errors, completed code for logging of&n; *                      corrected &amp; uncorrected machine check errors, and&n; *                      updated for conformance with Nov. 2000 revision of the&n; *                      SAL 3.0 spec.&n; * 00/03/29 C. Fleckenstein  Fixed PAL/SAL update issues, began MCA bug fixes, logging issues,&n; *                           added min save state dump, added INIT handler.&n; *&n; * 2003-12-08 Keith Owens &lt;kaos@sgi.com&gt;&n; *            smp_call_function() must not be called from interrupt context (can&n; *            deadlock on tasklist_lock).  Use keventd to call smp_call_function().&n; *&n; * 2004-02-01 Keith Owens &lt;kaos@sgi.com&gt;&n; *            Avoid deadlock when using printk() for MCA and INIT records.&n; *            Delete all record printing code, moved to salinfo_decode in user space.&n; *            Mark variables and functions static where possible.&n; *            Delete dead variables and functions.&n; *            Reorder to remove the need for forward declarations and to consolidate&n; *            related code.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/meminit.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/mca.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#if defined(IA64_MCA_DEBUG_INFO)
DECL|macro|IA64_MCA_DEBUG
macro_line|# define IA64_MCA_DEBUG(fmt...)&t;printk(fmt)
macro_line|#else
DECL|macro|IA64_MCA_DEBUG
macro_line|# define IA64_MCA_DEBUG(fmt...)
macro_line|#endif
multiline_comment|/* Used by mca_asm.S */
DECL|variable|ia64_sal_to_os_handoff_state
id|ia64_mca_sal_to_os_state_t
id|ia64_sal_to_os_handoff_state
suffix:semicolon
DECL|variable|ia64_os_to_sal_handoff_state
id|ia64_mca_os_to_sal_state_t
id|ia64_os_to_sal_handoff_state
suffix:semicolon
DECL|variable|ia64_mca_serialize
id|u64
id|ia64_mca_serialize
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
id|u64
comma
id|ia64_mca_data
)paren
suffix:semicolon
multiline_comment|/* == __per_cpu_mca[smp_processor_id()] */
id|DEFINE_PER_CPU
c_func
(paren
id|u64
comma
id|ia64_mca_per_cpu_pte
)paren
suffix:semicolon
multiline_comment|/* PTE to map per-CPU area */
id|DEFINE_PER_CPU
c_func
(paren
id|u64
comma
id|ia64_mca_pal_pte
)paren
suffix:semicolon
multiline_comment|/* PTE to map PAL code */
id|DEFINE_PER_CPU
c_func
(paren
id|u64
comma
id|ia64_mca_pal_base
)paren
suffix:semicolon
multiline_comment|/* vaddr PAL code granule */
DECL|variable|__per_cpu_mca
r_int
r_int
id|__per_cpu_mca
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* In mca_asm.S */
r_extern
r_void
id|ia64_monarch_init_handler
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ia64_slave_init_handler
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ia64_mc_info
r_static
id|ia64_mc_info_t
id|ia64_mc_info
suffix:semicolon
DECL|macro|MAX_CPE_POLL_INTERVAL
mdefine_line|#define MAX_CPE_POLL_INTERVAL (15*60*HZ) /* 15 minutes */
DECL|macro|MIN_CPE_POLL_INTERVAL
mdefine_line|#define MIN_CPE_POLL_INTERVAL (2*60*HZ)  /* 2 minutes */
DECL|macro|CMC_POLL_INTERVAL
mdefine_line|#define CMC_POLL_INTERVAL     (1*60*HZ)  /* 1 minute */
DECL|macro|CPE_HISTORY_LENGTH
mdefine_line|#define CPE_HISTORY_LENGTH    5
DECL|macro|CMC_HISTORY_LENGTH
mdefine_line|#define CMC_HISTORY_LENGTH    5
DECL|variable|cpe_poll_timer
r_static
r_struct
id|timer_list
id|cpe_poll_timer
suffix:semicolon
DECL|variable|cmc_poll_timer
r_static
r_struct
id|timer_list
id|cmc_poll_timer
suffix:semicolon
multiline_comment|/*&n; * This variable tells whether we are currently in polling mode.&n; * Start with this in the wrong state so we won&squot;t play w/ timers&n; * before the system is ready.&n; */
DECL|variable|cmc_polling_enabled
r_static
r_int
id|cmc_polling_enabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Clearing this variable prevents CPE polling from getting activated&n; * in mca_late_init.  Use it if your system doesn&squot;t provide a CPEI,&n; * but encounters problems retrieving CPE logs.  This should only be&n; * necessary for debugging.&n; */
DECL|variable|cpe_poll_enabled
r_static
r_int
id|cpe_poll_enabled
op_assign
l_int|1
suffix:semicolon
r_extern
r_void
id|salinfo_log_wakeup
c_func
(paren
r_int
id|type
comma
id|u8
op_star
id|buffer
comma
id|u64
id|size
comma
r_int
id|irqsafe
)paren
suffix:semicolon
DECL|variable|mca_init
r_static
r_int
id|mca_init
suffix:semicolon
multiline_comment|/*&n; * IA64_MCA log support&n; */
DECL|macro|IA64_MAX_LOGS
mdefine_line|#define IA64_MAX_LOGS&t;&t;2&t;/* Double-buffering for nested MCAs */
DECL|macro|IA64_MAX_LOG_TYPES
mdefine_line|#define IA64_MAX_LOG_TYPES      4   /* MCA, INIT, CMC, CPE */
DECL|struct|ia64_state_log_s
r_typedef
r_struct
id|ia64_state_log_s
(brace
DECL|member|isl_lock
id|spinlock_t
id|isl_lock
suffix:semicolon
DECL|member|isl_index
r_int
id|isl_index
suffix:semicolon
DECL|member|isl_count
r_int
r_int
id|isl_count
suffix:semicolon
DECL|member|isl_log
id|ia64_err_rec_t
op_star
id|isl_log
(braket
id|IA64_MAX_LOGS
)braket
suffix:semicolon
multiline_comment|/* need space to store header + error log */
DECL|typedef|ia64_state_log_t
)brace
id|ia64_state_log_t
suffix:semicolon
DECL|variable|ia64_state_log
r_static
id|ia64_state_log_t
id|ia64_state_log
(braket
id|IA64_MAX_LOG_TYPES
)braket
suffix:semicolon
DECL|macro|IA64_LOG_ALLOCATE
mdefine_line|#define IA64_LOG_ALLOCATE(it, size) &bslash;&n;&t;{ia64_state_log[it].isl_log[IA64_LOG_CURR_INDEX(it)] = &bslash;&n;&t;&t;(ia64_err_rec_t *)alloc_bootmem(size); &bslash;&n;&t;ia64_state_log[it].isl_log[IA64_LOG_NEXT_INDEX(it)] = &bslash;&n;&t;&t;(ia64_err_rec_t *)alloc_bootmem(size);}
DECL|macro|IA64_LOG_LOCK_INIT
mdefine_line|#define IA64_LOG_LOCK_INIT(it) spin_lock_init(&amp;ia64_state_log[it].isl_lock)
DECL|macro|IA64_LOG_LOCK
mdefine_line|#define IA64_LOG_LOCK(it)      spin_lock_irqsave(&amp;ia64_state_log[it].isl_lock, s)
DECL|macro|IA64_LOG_UNLOCK
mdefine_line|#define IA64_LOG_UNLOCK(it)    spin_unlock_irqrestore(&amp;ia64_state_log[it].isl_lock,s)
DECL|macro|IA64_LOG_NEXT_INDEX
mdefine_line|#define IA64_LOG_NEXT_INDEX(it)    ia64_state_log[it].isl_index
DECL|macro|IA64_LOG_CURR_INDEX
mdefine_line|#define IA64_LOG_CURR_INDEX(it)    1 - ia64_state_log[it].isl_index
DECL|macro|IA64_LOG_INDEX_INC
mdefine_line|#define IA64_LOG_INDEX_INC(it) &bslash;&n;    {ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index; &bslash;&n;    ia64_state_log[it].isl_count++;}
DECL|macro|IA64_LOG_INDEX_DEC
mdefine_line|#define IA64_LOG_INDEX_DEC(it) &bslash;&n;    ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index
DECL|macro|IA64_LOG_NEXT_BUFFER
mdefine_line|#define IA64_LOG_NEXT_BUFFER(it)   (void *)((ia64_state_log[it].isl_log[IA64_LOG_NEXT_INDEX(it)]))
DECL|macro|IA64_LOG_CURR_BUFFER
mdefine_line|#define IA64_LOG_CURR_BUFFER(it)   (void *)((ia64_state_log[it].isl_log[IA64_LOG_CURR_INDEX(it)]))
DECL|macro|IA64_LOG_COUNT
mdefine_line|#define IA64_LOG_COUNT(it)         ia64_state_log[it].isl_count
multiline_comment|/*&n; * ia64_log_init&n; *&t;Reset the OS ia64 log buffer&n; * Inputs   :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})&n; * Outputs&t;:&t;None&n; */
r_static
r_void
DECL|function|ia64_log_init
id|ia64_log_init
c_func
(paren
r_int
id|sal_info_type
)paren
(brace
id|u64
id|max_size
op_assign
l_int|0
suffix:semicolon
id|IA64_LOG_NEXT_INDEX
c_func
(paren
id|sal_info_type
)paren
op_assign
l_int|0
suffix:semicolon
id|IA64_LOG_LOCK_INIT
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
singleline_comment|// SAL will tell us the maximum size of any error record of this type
id|max_size
op_assign
id|ia64_sal_get_state_info_size
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_size
)paren
multiline_comment|/* alloc_bootmem() doesn&squot;t like zero-sized allocations! */
r_return
suffix:semicolon
singleline_comment|// set up OS data structures to hold error info
id|IA64_LOG_ALLOCATE
c_func
(paren
id|sal_info_type
comma
id|max_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|IA64_LOG_CURR_BUFFER
c_func
(paren
id|sal_info_type
)paren
comma
l_int|0
comma
id|max_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|IA64_LOG_NEXT_BUFFER
c_func
(paren
id|sal_info_type
)paren
comma
l_int|0
comma
id|max_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_log_get&n; *&n; *&t;Get the current MCA log from SAL and copy it into the OS log buffer.&n; *&n; *  Inputs  :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})&n; *              irq_safe    whether you can use printk at this point&n; *  Outputs :   size        (total record length)&n; *              *buffer     (ptr to error record)&n; *&n; */
r_static
id|u64
DECL|function|ia64_log_get
id|ia64_log_get
c_func
(paren
r_int
id|sal_info_type
comma
id|u8
op_star
op_star
id|buffer
comma
r_int
id|irq_safe
)paren
(brace
id|sal_log_record_header_t
op_star
id|log_buffer
suffix:semicolon
id|u64
id|total_len
op_assign
l_int|0
suffix:semicolon
r_int
id|s
suffix:semicolon
id|IA64_LOG_LOCK
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
multiline_comment|/* Get the process state information */
id|log_buffer
op_assign
id|IA64_LOG_NEXT_BUFFER
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
id|total_len
op_assign
id|ia64_sal_get_state_info
c_func
(paren
id|sal_info_type
comma
(paren
id|u64
op_star
)paren
id|log_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_len
)paren
(brace
id|IA64_LOG_INDEX_INC
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
id|IA64_LOG_UNLOCK
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_safe
)paren
(brace
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: SAL error record type %d retrieved. &quot;
l_string|&quot;Record length = %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sal_info_type
comma
id|total_len
)paren
suffix:semicolon
)brace
op_star
id|buffer
op_assign
(paren
id|u8
op_star
)paren
id|log_buffer
suffix:semicolon
r_return
id|total_len
suffix:semicolon
)brace
r_else
(brace
id|IA64_LOG_UNLOCK
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  ia64_mca_log_sal_error_record&n; *&n; *  This function retrieves a specified error record type from SAL&n; *  and wakes up any processes waiting for error records.&n; *&n; *  Inputs  :   sal_info_type   (Type of error record MCA/CMC/CPE/INIT)&n; */
r_static
r_void
DECL|function|ia64_mca_log_sal_error_record
id|ia64_mca_log_sal_error_record
c_func
(paren
r_int
id|sal_info_type
)paren
(brace
id|u8
op_star
id|buffer
suffix:semicolon
id|sal_log_record_header_t
op_star
id|rh
suffix:semicolon
id|u64
id|size
suffix:semicolon
r_int
id|irq_safe
op_assign
id|sal_info_type
op_ne
id|SAL_INFO_TYPE_MCA
op_logical_and
id|sal_info_type
op_ne
id|SAL_INFO_TYPE_INIT
suffix:semicolon
macro_line|#ifdef IA64_MCA_DEBUG_INFO
r_static
r_const
r_char
op_star
r_const
id|rec_name
(braket
)braket
op_assign
(brace
l_string|&quot;MCA&quot;
comma
l_string|&quot;INIT&quot;
comma
l_string|&quot;CMC&quot;
comma
l_string|&quot;CPE&quot;
)brace
suffix:semicolon
macro_line|#endif
id|size
op_assign
id|ia64_log_get
c_func
(paren
id|sal_info_type
comma
op_amp
id|buffer
comma
id|irq_safe
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
suffix:semicolon
id|salinfo_log_wakeup
c_func
(paren
id|sal_info_type
comma
id|buffer
comma
id|size
comma
id|irq_safe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_safe
)paren
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;CPU %d: SAL log contains %s error record&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|sal_info_type
OL
id|ARRAY_SIZE
c_func
(paren
id|rec_name
)paren
ques
c_cond
id|rec_name
(braket
id|sal_info_type
)braket
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear logs from corrected errors in case there&squot;s no user-level logger */
id|rh
op_assign
(paren
id|sal_log_record_header_t
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|rh-&gt;severity
op_eq
id|sal_log_severity_corrected
)paren
id|ia64_sal_clear_state_info
c_func
(paren
id|sal_info_type
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * platform dependent error handling&n; */
macro_line|#ifndef PLATFORM_MCA_HANDLERS
macro_line|#ifdef CONFIG_ACPI
DECL|variable|cpe_vector
r_static
r_int
id|cpe_vector
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|irqreturn_t
DECL|function|ia64_mca_cpe_int_handler
id|ia64_mca_cpe_int_handler
(paren
r_int
id|cpe_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_static
r_int
r_int
id|cpe_history
(braket
id|CPE_HISTORY_LENGTH
)braket
suffix:semicolon
r_static
r_int
id|index
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|cpe_history_lock
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: received interrupt vector = %#x on CPU %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cpe_irq
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* SAL spec states this should run w/ interrupts enabled */
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the CPE error record and log it */
id|ia64_mca_log_sal_error_record
c_func
(paren
id|SAL_INFO_TYPE_CPE
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cpe_history_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpe_poll_enabled
op_logical_and
id|cpe_vector
op_ge
l_int|0
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we know 1 happened now */
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPE_HISTORY_LENGTH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|now
op_minus
id|cpe_history
(braket
id|i
)braket
op_le
id|HZ
)paren
id|count
op_increment
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
id|KERN_INFO
l_string|&quot;CPE threshold %d/%d&bslash;n&quot;
comma
id|count
comma
id|CPE_HISTORY_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|CPE_HISTORY_LENGTH
)paren
(brace
id|cpe_poll_enabled
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cpe_history_lock
)paren
suffix:semicolon
id|disable_irq_nosync
c_func
(paren
id|local_vector_to_irq
c_func
(paren
id|IA64_CPE_VECTOR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Corrected errors will still be corrected, but&n;&t;&t;&t; * make sure there&squot;s a log somewhere that indicates&n;&t;&t;&t; * something is generating more than we can handle.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: Switching to polling CPE handler; error records may be lost&bslash;n&quot;
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|cpe_poll_timer
comma
id|jiffies
op_plus
id|MIN_CPE_POLL_INTERVAL
)paren
suffix:semicolon
multiline_comment|/* lock already released, get out now */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_else
(brace
id|cpe_history
(braket
id|index
op_increment
)braket
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|CPE_HISTORY_LENGTH
)paren
id|index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cpe_history_lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ACPI */
r_static
r_void
DECL|function|show_min_state
id|show_min_state
(paren
id|pal_min_state_area_t
op_star
id|minstate
)paren
(brace
id|u64
id|iip
op_assign
id|minstate-&gt;pmsa_iip
op_plus
(paren
(paren
r_struct
id|ia64_psr
op_star
)paren
(paren
op_amp
id|minstate-&gt;pmsa_ipsr
)paren
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
id|u64
id|xip
op_assign
id|minstate-&gt;pmsa_xip
op_plus
(paren
(paren
r_struct
id|ia64_psr
op_star
)paren
(paren
op_amp
id|minstate-&gt;pmsa_xpsr
)paren
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NaT bits&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_nat_bits
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pr&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_pr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;b0&bslash;t&bslash;t%016lx &quot;
comma
id|minstate-&gt;pmsa_br0
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|minstate-&gt;pmsa_br0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ar.rsc&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_rsc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cr.iip&bslash;t&bslash;t%016lx &quot;
comma
id|iip
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|iip
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cr.ipsr&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_ipsr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cr.ifs&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_ifs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xip&bslash;t&bslash;t%016lx &quot;
comma
id|xip
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|xip
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xpsr&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_xpsr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xfs&bslash;t&bslash;t%016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_xfs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;b1&bslash;t&bslash;t%016lx &quot;
comma
id|minstate-&gt;pmsa_br1
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|minstate-&gt;pmsa_br1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nstatic registers r0-r15:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r0- 3 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
l_int|0UL
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|0
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|1
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r4- 7 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|3
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|4
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|5
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r8-11 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|7
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|8
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|9
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|10
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12-15 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|11
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|12
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|13
)braket
comma
id|minstate-&gt;pmsa_gr
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nbank 0:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16-19 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|0
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|1
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|2
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r20-23 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|4
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|5
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|6
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r24-27 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|8
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|9
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|10
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r28-31 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|12
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|13
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|14
)braket
comma
id|minstate-&gt;pmsa_bank0_gr
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nbank 1:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16-19 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|0
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|1
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|2
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r20-23 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|4
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|5
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|6
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r24-27 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|8
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|9
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|10
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r28-31 %016lx %016lx %016lx %016lx&bslash;n&quot;
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|12
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|13
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|14
)braket
comma
id|minstate-&gt;pmsa_bank1_gr
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|fetch_min_state
id|fetch_min_state
(paren
id|pal_min_state_area_t
op_star
id|ms
comma
r_struct
id|pt_regs
op_star
id|pt
comma
r_struct
id|switch_stack
op_star
id|sw
)paren
(brace
id|u64
op_star
id|dst_banked
comma
op_star
id|src_banked
comma
id|bit
comma
id|shift
comma
id|nat_bits
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * First, update the pt-regs and switch-stack structures with the contents stored&n;&t; * in the min-state area:&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ia64_psr
op_star
)paren
op_amp
id|ms-&gt;pmsa_ipsr
)paren
op_member_access_from_pointer
id|ic
op_eq
l_int|0
)paren
(brace
id|pt-&gt;cr_ipsr
op_assign
id|ms-&gt;pmsa_xpsr
suffix:semicolon
id|pt-&gt;cr_iip
op_assign
id|ms-&gt;pmsa_xip
suffix:semicolon
id|pt-&gt;cr_ifs
op_assign
id|ms-&gt;pmsa_xfs
suffix:semicolon
)brace
r_else
(brace
id|pt-&gt;cr_ipsr
op_assign
id|ms-&gt;pmsa_ipsr
suffix:semicolon
id|pt-&gt;cr_iip
op_assign
id|ms-&gt;pmsa_iip
suffix:semicolon
id|pt-&gt;cr_ifs
op_assign
id|ms-&gt;pmsa_ifs
suffix:semicolon
)brace
id|pt-&gt;ar_rsc
op_assign
id|ms-&gt;pmsa_rsc
suffix:semicolon
id|pt-&gt;pr
op_assign
id|ms-&gt;pmsa_pr
suffix:semicolon
id|pt-&gt;r1
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|0
)braket
suffix:semicolon
id|pt-&gt;r2
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|1
)braket
suffix:semicolon
id|pt-&gt;r3
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|2
)braket
suffix:semicolon
id|sw-&gt;r4
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|3
)braket
suffix:semicolon
id|sw-&gt;r5
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|4
)braket
suffix:semicolon
id|sw-&gt;r6
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|5
)braket
suffix:semicolon
id|sw-&gt;r7
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|6
)braket
suffix:semicolon
id|pt-&gt;r8
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|7
)braket
suffix:semicolon
id|pt-&gt;r9
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|8
)braket
suffix:semicolon
id|pt-&gt;r10
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|9
)braket
suffix:semicolon
id|pt-&gt;r11
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|10
)braket
suffix:semicolon
id|pt-&gt;r12
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|11
)braket
suffix:semicolon
id|pt-&gt;r13
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|12
)braket
suffix:semicolon
id|pt-&gt;r14
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|13
)braket
suffix:semicolon
id|pt-&gt;r15
op_assign
id|ms-&gt;pmsa_gr
(braket
l_int|14
)braket
suffix:semicolon
id|dst_banked
op_assign
op_amp
id|pt-&gt;r16
suffix:semicolon
multiline_comment|/* r16-r31 are contiguous in struct pt_regs */
id|src_banked
op_assign
id|ms-&gt;pmsa_bank1_gr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|dst_banked
(braket
id|i
)braket
op_assign
id|src_banked
(braket
id|i
)braket
suffix:semicolon
id|pt-&gt;b0
op_assign
id|ms-&gt;pmsa_br0
suffix:semicolon
id|sw-&gt;b1
op_assign
id|ms-&gt;pmsa_br1
suffix:semicolon
multiline_comment|/* construct the NaT bits for the pt-regs structure: */
DECL|macro|PUT_NAT_BIT
macro_line|#&t;define PUT_NAT_BIT(dst, addr)&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;bit = nat_bits &amp; 1; nat_bits &gt;&gt;= 1;&t;&t;&t;&bslash;&n;&t;&t;shift = ((unsigned long) addr &gt;&gt; 3) &amp; 0x3f;&t;&t;&bslash;&n;&t;&t;dst = ((dst) &amp; ~(1UL &lt;&lt; shift)) | (bit &lt;&lt; shift);&t;&bslash;&n;&t;} while (0)
multiline_comment|/* Rotate the saved NaT bits such that bit 0 corresponds to pmsa_gr[0]: */
id|shift
op_assign
(paren
(paren
r_int
r_int
)paren
op_amp
id|ms-&gt;pmsa_gr
(braket
l_int|0
)braket
op_rshift
l_int|3
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|nat_bits
op_assign
(paren
id|ms-&gt;pmsa_nat_bits
op_rshift
id|shift
)paren
op_or
(paren
id|ms-&gt;pmsa_nat_bits
op_lshift
(paren
l_int|64
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r1
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r2
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r3
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;ar_unat
comma
op_amp
id|sw-&gt;r4
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;ar_unat
comma
op_amp
id|sw-&gt;r5
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;ar_unat
comma
op_amp
id|sw-&gt;r6
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;ar_unat
comma
op_amp
id|sw-&gt;r7
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r8
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r9
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r10
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r11
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r12
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r13
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r14
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r15
)paren
suffix:semicolon
id|nat_bits
op_rshift_assign
l_int|16
suffix:semicolon
multiline_comment|/* skip over bank0 NaT bits */
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r16
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r17
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r18
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r19
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r20
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r21
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r22
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r23
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r24
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r25
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r26
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r27
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r28
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r29
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r30
)paren
suffix:semicolon
id|PUT_NAT_BIT
c_func
(paren
id|sw-&gt;caller_unat
comma
op_amp
id|pt-&gt;r31
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_handler_platform
id|init_handler_platform
(paren
id|pal_min_state_area_t
op_star
id|ms
comma
r_struct
id|pt_regs
op_star
id|pt
comma
r_struct
id|switch_stack
op_star
id|sw
)paren
(brace
r_struct
id|unw_frame_info
id|info
suffix:semicolon
multiline_comment|/* if a kernel debugger is available call it here else just dump the registers */
multiline_comment|/*&n;&t; * Wait for a bit.  On some machines (e.g., HP&squot;s zx2000 and zx6000, INIT can be&n;&t; * generated via the BMC&squot;s command-line interface, but since the console is on the&n;&t; * same serial line, the user will need some time to switch out of the BMC before&n;&t; * the dump begins.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Delaying for 5 seconds...&bslash;n&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
op_star
l_int|1000000
)paren
suffix:semicolon
id|show_min_state
c_func
(paren
id|ms
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Backtrace of current task (pid %d, %s)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|fetch_min_state
c_func
(paren
id|ms
comma
id|pt
comma
id|sw
)paren
suffix:semicolon
id|unw_init_from_interruption
c_func
(paren
op_amp
id|info
comma
id|current
comma
id|pt
comma
id|sw
)paren
suffix:semicolon
id|ia64_do_show_stack
c_func
(paren
op_amp
id|info
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* read_trylock() would be handy... */
r_if
c_cond
(paren
op_logical_neg
id|tasklist_lock.write_lock
)paren
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
macro_line|#endif
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|t
suffix:semicolon
id|do_each_thread
(paren
id|g
comma
id|t
)paren
(brace
r_if
c_cond
(paren
id|t
op_eq
id|current
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nBacktrace of pid %d (%s)&bslash;n&quot;
comma
id|t-&gt;pid
comma
id|t-&gt;comm
)paren
suffix:semicolon
id|show_stack
c_func
(paren
id|t
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|while_each_thread
(paren
id|g
comma
id|t
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
op_logical_neg
id|tasklist_lock.write_lock
)paren
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;nINIT dump complete.  Please reboot now.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hang city if no debugger */
)brace
macro_line|#ifdef CONFIG_ACPI
multiline_comment|/*&n; * ia64_mca_register_cpev&n; *&n; *  Register the corrected platform error vector with SAL.&n; *&n; *  Inputs&n; *      cpev        Corrected Platform Error Vector number&n; *&n; *  Outputs&n; *      None&n; */
r_static
r_void
DECL|function|ia64_mca_register_cpev
id|ia64_mca_register_cpev
(paren
r_int
id|cpev
)paren
(brace
multiline_comment|/* Register the CPE interrupt vector with SAL */
r_struct
id|ia64_sal_retval
id|isrv
suffix:semicolon
id|isrv
op_assign
id|ia64_sal_mc_set_params
c_func
(paren
id|SAL_MC_PARAM_CPE_INT
comma
id|SAL_MC_PARAM_MECHANISM_INT
comma
id|cpev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isrv.status
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to register Corrected Platform &quot;
l_string|&quot;Error interrupt vector with SAL (status %ld)&bslash;n&quot;
comma
id|isrv.status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: corrected platform error &quot;
l_string|&quot;vector %#x registered&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cpev
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ACPI */
macro_line|#endif /* PLATFORM_MCA_HANDLERS */
multiline_comment|/*&n; * ia64_mca_cmc_vector_setup&n; *&n; *  Setup the corrected machine check vector register in the processor.&n; *  (The interrupt is masked on boot. ia64_mca_late_init unmask this.)&n; *  This function is invoked on a per-processor basis.&n; *&n; * Inputs&n; *      None&n; *&n; * Outputs&n; *&t;None&n; */
r_void
DECL|function|ia64_mca_cmc_vector_setup
id|ia64_mca_cmc_vector_setup
(paren
r_void
)paren
(brace
id|cmcv_reg_t
id|cmcv
suffix:semicolon
id|cmcv.cmcv_regval
op_assign
l_int|0
suffix:semicolon
id|cmcv.cmcv_mask
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Mask/disable interrupt at first */
id|cmcv.cmcv_vector
op_assign
id|IA64_CMC_VECTOR
suffix:semicolon
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_CMCV
comma
id|cmcv.cmcv_regval
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPU %d corrected &quot;
l_string|&quot;machine check vector %#x registered.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|IA64_CMC_VECTOR
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPU %d CMCV = %#016lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_CMCV
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_cmc_vector_disable&n; *&n; *  Mask the corrected machine check vector register in the processor.&n; *  This function is invoked on a per-processor basis.&n; *&n; * Inputs&n; *      dummy(unused)&n; *&n; * Outputs&n; *&t;None&n; */
r_static
r_void
DECL|function|ia64_mca_cmc_vector_disable
id|ia64_mca_cmc_vector_disable
(paren
r_void
op_star
id|dummy
)paren
(brace
id|cmcv_reg_t
id|cmcv
suffix:semicolon
id|cmcv.cmcv_regval
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_CMCV
)paren
suffix:semicolon
id|cmcv.cmcv_mask
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Mask/disable interrupt */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_CMCV
comma
id|cmcv.cmcv_regval
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPU %d corrected &quot;
l_string|&quot;machine check vector %#x disabled.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cmcv.cmcv_vector
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_cmc_vector_enable&n; *&n; *  Unmask the corrected machine check vector register in the processor.&n; *  This function is invoked on a per-processor basis.&n; *&n; * Inputs&n; *      dummy(unused)&n; *&n; * Outputs&n; *&t;None&n; */
r_static
r_void
DECL|function|ia64_mca_cmc_vector_enable
id|ia64_mca_cmc_vector_enable
(paren
r_void
op_star
id|dummy
)paren
(brace
id|cmcv_reg_t
id|cmcv
suffix:semicolon
id|cmcv.cmcv_regval
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_CMCV
)paren
suffix:semicolon
id|cmcv.cmcv_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unmask/enable interrupt */
id|ia64_setreg
c_func
(paren
id|_IA64_REG_CR_CMCV
comma
id|cmcv.cmcv_regval
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPU %d corrected &quot;
l_string|&quot;machine check vector %#x enabled.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cmcv.cmcv_vector
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_cmc_vector_disable_keventd&n; *&n; * Called via keventd (smp_call_function() is not safe in interrupt context) to&n; * disable the cmc interrupt vector.&n; */
r_static
r_void
DECL|function|ia64_mca_cmc_vector_disable_keventd
id|ia64_mca_cmc_vector_disable_keventd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|on_each_cpu
c_func
(paren
id|ia64_mca_cmc_vector_disable
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_cmc_vector_enable_keventd&n; *&n; * Called via keventd (smp_call_function() is not safe in interrupt context) to&n; * enable the cmc interrupt vector.&n; */
r_static
r_void
DECL|function|ia64_mca_cmc_vector_enable_keventd
id|ia64_mca_cmc_vector_enable_keventd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|on_each_cpu
c_func
(paren
id|ia64_mca_cmc_vector_enable
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_wakeup_ipi_wait&n; *&n; *&t;Wait for the inter-cpu interrupt to be sent by the&n; *&t;monarch processor once it is done with handling the&n; *&t;MCA.&n; *&n; *  Inputs  :   None&n; *  Outputs :   None&n; */
r_static
r_void
DECL|function|ia64_mca_wakeup_ipi_wait
id|ia64_mca_wakeup_ipi_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|irr_num
op_assign
(paren
id|IA64_MCA_WAKEUP_VECTOR
op_rshift
l_int|6
)paren
suffix:semicolon
r_int
id|irr_bit
op_assign
(paren
id|IA64_MCA_WAKEUP_VECTOR
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|u64
id|irr
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_switch
c_cond
(paren
id|irr_num
)paren
(brace
r_case
l_int|0
suffix:colon
id|irr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_IRR0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|irr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_IRR1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|irr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_IRR2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|irr
op_assign
id|ia64_getreg
c_func
(paren
id|_IA64_REG_CR_IRR3
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|irr
op_amp
(paren
l_int|1UL
op_lshift
id|irr_bit
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_wakeup&n; *&n; *&t;Send an inter-cpu interrupt to wake-up a particular cpu&n; *&t;and mark that cpu to be out of rendez.&n; *&n; *  Inputs  :   cpuid&n; *  Outputs :   None&n; */
r_static
r_void
DECL|function|ia64_mca_wakeup
id|ia64_mca_wakeup
c_func
(paren
r_int
id|cpu
)paren
(brace
id|platform_send_ipi
c_func
(paren
id|cpu
comma
id|IA64_MCA_WAKEUP_VECTOR
comma
id|IA64_IPI_DM_INT
comma
l_int|0
)paren
suffix:semicolon
id|ia64_mc_info.imi_rendez_checkin
(braket
id|cpu
)braket
op_assign
id|IA64_MCA_RENDEZ_CHECKIN_NOTDONE
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_wakeup_all&n; *&n; *&t;Wakeup all the cpus which have rendez&squot;ed previously.&n; *&n; *  Inputs  :   None&n; *  Outputs :   None&n; */
r_static
r_void
DECL|function|ia64_mca_wakeup_all
id|ia64_mca_wakeup_all
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
suffix:semicolon
multiline_comment|/* Clear the Rendez checkin flag for all cpus */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ia64_mc_info.imi_rendez_checkin
(braket
id|cpu
)braket
op_eq
id|IA64_MCA_RENDEZ_CHECKIN_DONE
)paren
id|ia64_mca_wakeup
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ia64_mca_rendez_interrupt_handler&n; *&n; *&t;This is handler used to put slave processors into spinloop&n; *&t;while the monarch processor does the mca handling and later&n; *&t;wake each slave up once the monarch is done.&n; *&n; *  Inputs  :   None&n; *  Outputs :   None&n; */
r_static
id|irqreturn_t
DECL|function|ia64_mca_rendez_int_handler
id|ia64_mca_rendez_int_handler
c_func
(paren
r_int
id|rendez_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Mask all interrupts */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ia64_mc_info.imi_rendez_checkin
(braket
id|cpu
)braket
op_assign
id|IA64_MCA_RENDEZ_CHECKIN_DONE
suffix:semicolon
multiline_comment|/* Register with the SAL monarch that the slave has&n;&t; * reached SAL&n;&t; */
id|ia64_sal_mc_rendez
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the wakeup IPI from the monarch&n;&t; * This waiting is done by polling on the wakeup-interrupt&n;&t; * vector bit in the processor&squot;s IRRs&n;&t; */
id|ia64_mca_wakeup_ipi_wait
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Enable all interrupts */
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_wakeup_int_handler&n; *&n; *&t;The interrupt handler for processing the inter-cpu interrupt to the&n; *&t;slave cpu which was spinning in the rendez loop.&n; *&t;Since this spinning is done by turning off the interrupts and&n; *&t;polling on the wakeup-interrupt bit in the IRR, there is&n; *&t;nothing useful to be done in the handler.&n; *&n; *  Inputs  :   wakeup_irq  (Wakeup-interrupt bit)&n; *&t;arg&t;&t;(Interrupt handler specific argument)&n; *&t;ptregs&t;&t;(Exception frame at the time of the interrupt)&n; *  Outputs :   None&n; *&n; */
r_static
id|irqreturn_t
DECL|function|ia64_mca_wakeup_int_handler
id|ia64_mca_wakeup_int_handler
c_func
(paren
r_int
id|wakeup_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_return_to_sal_check&n; *&n; *&t;This is function called before going back from the OS_MCA handler&n; *&t;to the OS_MCA dispatch code which finally takes the control back&n; *&t;to the SAL.&n; *&t;The main purpose of this routine is to setup the OS_MCA to SAL&n; *&t;return state which can be used by the OS_MCA dispatch code&n; *&t;just before going back to SAL.&n; *&n; *  Inputs  :   None&n; *  Outputs :   None&n; */
r_static
r_void
DECL|function|ia64_return_to_sal_check
id|ia64_return_to_sal_check
c_func
(paren
r_int
id|recover
)paren
(brace
multiline_comment|/* Copy over some relevant stuff from the sal_to_os_mca_handoff&n;&t; * so that it can be used at the time of os_mca_to_sal_handoff&n;&t; */
id|ia64_os_to_sal_handoff_state.imots_sal_gp
op_assign
id|ia64_sal_to_os_handoff_state.imsto_sal_gp
suffix:semicolon
id|ia64_os_to_sal_handoff_state.imots_sal_check_ra
op_assign
id|ia64_sal_to_os_handoff_state.imsto_sal_check_ra
suffix:semicolon
r_if
c_cond
(paren
id|recover
)paren
id|ia64_os_to_sal_handoff_state.imots_os_status
op_assign
id|IA64_MCA_CORRECTED
suffix:semicolon
r_else
id|ia64_os_to_sal_handoff_state.imots_os_status
op_assign
id|IA64_MCA_COLD_BOOT
suffix:semicolon
multiline_comment|/* Default = tell SAL to return to same context */
id|ia64_os_to_sal_handoff_state.imots_context
op_assign
id|IA64_MCA_SAME_CONTEXT
suffix:semicolon
id|ia64_os_to_sal_handoff_state.imots_new_min_state
op_assign
(paren
id|u64
op_star
)paren
id|ia64_sal_to_os_handoff_state.pal_min_state
suffix:semicolon
)brace
multiline_comment|/* Function pointer for extra MCA recovery */
DECL|variable|ia64_mca_ucmc_extension
r_int
(paren
op_star
id|ia64_mca_ucmc_extension
)paren
(paren
r_void
op_star
comma
id|ia64_mca_sal_to_os_state_t
op_star
comma
id|ia64_mca_os_to_sal_state_t
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
r_int
DECL|function|ia64_reg_MCA_extension
id|ia64_reg_MCA_extension
c_func
(paren
r_void
op_star
id|fn
)paren
(brace
r_if
c_cond
(paren
id|ia64_mca_ucmc_extension
)paren
r_return
l_int|1
suffix:semicolon
id|ia64_mca_ucmc_extension
op_assign
id|fn
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ia64_unreg_MCA_extension
id|ia64_unreg_MCA_extension
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ia64_mca_ucmc_extension
)paren
id|ia64_mca_ucmc_extension
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|ia64_reg_MCA_extension
id|EXPORT_SYMBOL
c_func
(paren
id|ia64_reg_MCA_extension
)paren
suffix:semicolon
DECL|variable|ia64_unreg_MCA_extension
id|EXPORT_SYMBOL
c_func
(paren
id|ia64_unreg_MCA_extension
)paren
suffix:semicolon
multiline_comment|/*&n; * ia64_mca_ucmc_handler&n; *&n; *&t;This is uncorrectable machine check handler called from OS_MCA&n; *&t;dispatch code which is in turn called from SAL_CHECK().&n; *&t;This is the place where the core of OS MCA handling is done.&n; *&t;Right now the logs are extracted and displayed in a well-defined&n; *&t;format. This handler code is supposed to be run only on the&n; *&t;monarch processor. Once the monarch is done with MCA handling&n; *&t;further MCA logging is enabled by clearing logs.&n; *&t;Monarch also has the duty of sending wakeup-IPIs to pull the&n; *&t;slave processors out of rendezvous spinloop.&n; *&n; *  Inputs  :   None&n; *  Outputs :   None&n; */
r_void
DECL|function|ia64_mca_ucmc_handler
id|ia64_mca_ucmc_handler
c_func
(paren
r_void
)paren
(brace
id|pal_processor_state_info_t
op_star
id|psp
op_assign
(paren
id|pal_processor_state_info_t
op_star
)paren
op_amp
id|ia64_sal_to_os_handoff_state.proc_state_param
suffix:semicolon
r_int
id|recover
suffix:semicolon
multiline_comment|/* Get the MCA error record and log it */
id|ia64_mca_log_sal_error_record
c_func
(paren
id|SAL_INFO_TYPE_MCA
)paren
suffix:semicolon
multiline_comment|/* TLB error is only exist in this SAL error record */
id|recover
op_assign
(paren
id|psp-&gt;tc
op_logical_and
op_logical_neg
(paren
id|psp-&gt;cc
op_logical_or
id|psp-&gt;bc
op_logical_or
id|psp-&gt;rc
op_logical_or
id|psp-&gt;uc
)paren
)paren
multiline_comment|/* other error recovery */
op_logical_or
(paren
id|ia64_mca_ucmc_extension
op_logical_and
id|ia64_mca_ucmc_extension
c_func
(paren
id|IA64_LOG_CURR_BUFFER
c_func
(paren
id|SAL_INFO_TYPE_MCA
)paren
comma
op_amp
id|ia64_sal_to_os_handoff_state
comma
op_amp
id|ia64_os_to_sal_handoff_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recover
)paren
(brace
id|sal_log_record_header_t
op_star
id|rh
op_assign
id|IA64_LOG_CURR_BUFFER
c_func
(paren
id|SAL_INFO_TYPE_MCA
)paren
suffix:semicolon
id|rh-&gt;severity
op_assign
id|sal_log_severity_corrected
suffix:semicolon
id|ia64_sal_clear_state_info
c_func
(paren
id|SAL_INFO_TYPE_MCA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Wakeup all the processors which are spinning in the rendezvous&n;&t; *  loop.&n;&t; */
id|ia64_mca_wakeup_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Return to SAL */
id|ia64_return_to_sal_check
c_func
(paren
id|recover
)paren
suffix:semicolon
)brace
r_static
id|DECLARE_WORK
c_func
(paren
id|cmc_disable_work
comma
id|ia64_mca_cmc_vector_disable_keventd
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|cmc_enable_work
comma
id|ia64_mca_cmc_vector_enable_keventd
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; * ia64_mca_cmc_int_handler&n; *&n; *  This is corrected machine check interrupt handler.&n; *&t;Right now the logs are extracted and displayed in a well-defined&n; *&t;format.&n; *&n; * Inputs&n; *      interrupt number&n; *      client data arg ptr&n; *      saved registers ptr&n; *&n; * Outputs&n; *&t;None&n; */
r_static
id|irqreturn_t
DECL|function|ia64_mca_cmc_int_handler
id|ia64_mca_cmc_int_handler
c_func
(paren
r_int
id|cmc_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_static
r_int
r_int
id|cmc_history
(braket
id|CMC_HISTORY_LENGTH
)braket
suffix:semicolon
r_static
r_int
id|index
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|cmc_history_lock
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: received interrupt vector = %#x on CPU %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cmc_irq
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* SAL spec states this should run w/ interrupts enabled */
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the CMC error record and log it */
id|ia64_mca_log_sal_error_record
c_func
(paren
id|SAL_INFO_TYPE_CMC
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cmc_history_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmc_polling_enabled
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we know 1 happened now */
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CMC_HISTORY_LENGTH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|now
op_minus
id|cmc_history
(braket
id|i
)braket
op_le
id|HZ
)paren
id|count
op_increment
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
id|KERN_INFO
l_string|&quot;CMC threshold %d/%d&bslash;n&quot;
comma
id|count
comma
id|CMC_HISTORY_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|CMC_HISTORY_LENGTH
)paren
(brace
id|cmc_polling_enabled
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cmc_history_lock
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|cmc_disable_work
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Corrected errors will still be corrected, but&n;&t;&t;&t; * make sure there&squot;s a log somewhere that indicates&n;&t;&t;&t; * something is generating more than we can handle.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: Switching to polling CMC handler; error records may be lost&bslash;n&quot;
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|cmc_poll_timer
comma
id|jiffies
op_plus
id|CMC_POLL_INTERVAL
)paren
suffix:semicolon
multiline_comment|/* lock already released, get out now */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_else
(brace
id|cmc_history
(braket
id|index
op_increment
)braket
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|CMC_HISTORY_LENGTH
)paren
id|index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cmc_history_lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; *  ia64_mca_cmc_int_caller&n; *&n; * &t;Triggered by sw interrupt from CMC polling routine.  Calls&n; * &t;real interrupt handler and either triggers a sw interrupt&n; * &t;on the next cpu or does cleanup at the end.&n; *&n; * Inputs&n; *&t;interrupt number&n; *&t;client data arg ptr&n; *&t;saved registers ptr&n; * Outputs&n; * &t;handled&n; */
r_static
id|irqreturn_t
DECL|function|ia64_mca_cmc_int_caller
id|ia64_mca_cmc_int_caller
c_func
(paren
r_int
id|cmc_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_static
r_int
id|start_count
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|cpuid
suffix:semicolon
id|cpuid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If first cpu, update count */
r_if
c_cond
(paren
id|start_count
op_eq
op_minus
l_int|1
)paren
id|start_count
op_assign
id|IA64_LOG_COUNT
c_func
(paren
id|SAL_INFO_TYPE_CMC
)paren
suffix:semicolon
id|ia64_mca_cmc_int_handler
c_func
(paren
id|cmc_irq
comma
id|arg
comma
id|ptregs
)paren
suffix:semicolon
r_for
c_loop
(paren
op_increment
id|cpuid
suffix:semicolon
id|cpuid
OL
id|NR_CPUS
op_logical_and
op_logical_neg
id|cpu_online
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|cpuid
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
OL
id|NR_CPUS
)paren
(brace
id|platform_send_ipi
c_func
(paren
id|cpuid
comma
id|IA64_CMCP_VECTOR
comma
id|IA64_IPI_DM_INT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If no log record, switch out of polling mode */
r_if
c_cond
(paren
id|start_count
op_eq
id|IA64_LOG_COUNT
c_func
(paren
id|SAL_INFO_TYPE_CMC
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Returning to interrupt driven CMC handler&bslash;n&quot;
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|cmc_enable_work
)paren
suffix:semicolon
id|cmc_polling_enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|mod_timer
c_func
(paren
op_amp
id|cmc_poll_timer
comma
id|jiffies
op_plus
id|CMC_POLL_INTERVAL
)paren
suffix:semicolon
)brace
id|start_count
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; *  ia64_mca_cmc_poll&n; *&n; *&t;Poll for Corrected Machine Checks (CMCs)&n; *&n; * Inputs   :   dummy(unused)&n; * Outputs  :   None&n; *&n; */
r_static
r_void
DECL|function|ia64_mca_cmc_poll
id|ia64_mca_cmc_poll
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* Trigger a CMC interrupt cascade  */
id|platform_send_ipi
c_func
(paren
id|first_cpu
c_func
(paren
id|cpu_online_map
)paren
comma
id|IA64_CMCP_VECTOR
comma
id|IA64_IPI_DM_INT
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  ia64_mca_cpe_int_caller&n; *&n; * &t;Triggered by sw interrupt from CPE polling routine.  Calls&n; * &t;real interrupt handler and either triggers a sw interrupt&n; * &t;on the next cpu or does cleanup at the end.&n; *&n; * Inputs&n; *&t;interrupt number&n; *&t;client data arg ptr&n; *&t;saved registers ptr&n; * Outputs&n; * &t;handled&n; */
macro_line|#ifdef CONFIG_ACPI
r_static
id|irqreturn_t
DECL|function|ia64_mca_cpe_int_caller
id|ia64_mca_cpe_int_caller
c_func
(paren
r_int
id|cpe_irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_static
r_int
id|start_count
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_int
id|poll_time
op_assign
id|MIN_CPE_POLL_INTERVAL
suffix:semicolon
r_int
r_int
id|cpuid
suffix:semicolon
id|cpuid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If first cpu, update count */
r_if
c_cond
(paren
id|start_count
op_eq
op_minus
l_int|1
)paren
id|start_count
op_assign
id|IA64_LOG_COUNT
c_func
(paren
id|SAL_INFO_TYPE_CPE
)paren
suffix:semicolon
id|ia64_mca_cpe_int_handler
c_func
(paren
id|cpe_irq
comma
id|arg
comma
id|ptregs
)paren
suffix:semicolon
r_for
c_loop
(paren
op_increment
id|cpuid
suffix:semicolon
id|cpuid
OL
id|NR_CPUS
op_logical_and
op_logical_neg
id|cpu_online
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|cpuid
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
OL
id|NR_CPUS
)paren
(brace
id|platform_send_ipi
c_func
(paren
id|cpuid
comma
id|IA64_CPEP_VECTOR
comma
id|IA64_IPI_DM_INT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If a log was recorded, increase our polling frequency,&n;&t;&t; * otherwise, backoff or return to interrupt mode.&n;&t;&t; */
r_if
c_cond
(paren
id|start_count
op_ne
id|IA64_LOG_COUNT
c_func
(paren
id|SAL_INFO_TYPE_CPE
)paren
)paren
(brace
id|poll_time
op_assign
id|max
c_func
(paren
id|MIN_CPE_POLL_INTERVAL
comma
id|poll_time
op_div
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpe_vector
OL
l_int|0
)paren
(brace
id|poll_time
op_assign
id|min
c_func
(paren
id|MAX_CPE_POLL_INTERVAL
comma
id|poll_time
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|poll_time
op_assign
id|MIN_CPE_POLL_INTERVAL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Returning to interrupt driven CPE handler&bslash;n&quot;
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|local_vector_to_irq
c_func
(paren
id|IA64_CPE_VECTOR
)paren
)paren
suffix:semicolon
id|cpe_poll_enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpe_poll_enabled
)paren
id|mod_timer
c_func
(paren
op_amp
id|cpe_poll_timer
comma
id|jiffies
op_plus
id|poll_time
)paren
suffix:semicolon
id|start_count
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ACPI */
multiline_comment|/*&n; *  ia64_mca_cpe_poll&n; *&n; *&t;Poll for Corrected Platform Errors (CPEs), trigger interrupt&n; *&t;on first cpu, from there it will trickle through all the cpus.&n; *&n; * Inputs   :   dummy(unused)&n; * Outputs  :   None&n; *&n; */
r_static
r_void
DECL|function|ia64_mca_cpe_poll
id|ia64_mca_cpe_poll
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* Trigger a CPE interrupt cascade  */
id|platform_send_ipi
c_func
(paren
id|first_cpu
c_func
(paren
id|cpu_online_map
)paren
comma
id|IA64_CPEP_VECTOR
comma
id|IA64_IPI_DM_INT
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * C portion of the OS INIT handler&n; *&n; * Called from ia64_monarch_init_handler&n; *&n; * Inputs: pointer to pt_regs where processor info was saved.&n; *&n; * Returns:&n; *   0 if SAL must warm boot the System&n; *   1 if SAL must return to interrupted context using PAL_MC_RESUME&n; *&n; */
r_void
DECL|function|ia64_init_handler
id|ia64_init_handler
(paren
r_struct
id|pt_regs
op_star
id|pt
comma
r_struct
id|switch_stack
op_star
id|sw
)paren
(brace
id|pal_min_state_area_t
op_star
id|ms
suffix:semicolon
id|oops_in_progress
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* avoid deadlock in printk, but it makes recovery dodgy */
id|console_loglevel
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* make sure printks make it to console */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Entered OS INIT handler. PSP=%lx&bslash;n&quot;
comma
id|ia64_sal_to_os_handoff_state.proc_state_param
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Address of minstate area provided by PAL is physical,&n;&t; * uncacheable (bit 63 set). Convert to Linux virtual&n;&t; * address in region 6.&n;&t; */
id|ms
op_assign
(paren
id|pal_min_state_area_t
op_star
)paren
(paren
id|ia64_sal_to_os_handoff_state.pal_min_state
op_or
(paren
l_int|6ul
op_lshift
l_int|61
)paren
)paren
suffix:semicolon
id|init_handler_platform
c_func
(paren
id|ms
comma
id|pt
comma
id|sw
)paren
suffix:semicolon
multiline_comment|/* call platform specific routines */
)brace
r_static
r_int
id|__init
DECL|function|ia64_mca_disable_cpe_polling
id|ia64_mca_disable_cpe_polling
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|cpe_poll_enabled
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;disable_cpe_poll&quot;
comma
id|ia64_mca_disable_cpe_polling
)paren
suffix:semicolon
DECL|variable|cmci_irqaction
r_static
r_struct
id|irqaction
id|cmci_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_cmc_int_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;cmc_hndlr&quot;
)brace
suffix:semicolon
DECL|variable|cmcp_irqaction
r_static
r_struct
id|irqaction
id|cmcp_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_cmc_int_caller
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;cmc_poll&quot;
)brace
suffix:semicolon
DECL|variable|mca_rdzv_irqaction
r_static
r_struct
id|irqaction
id|mca_rdzv_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_rendez_int_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;mca_rdzv&quot;
)brace
suffix:semicolon
DECL|variable|mca_wkup_irqaction
r_static
r_struct
id|irqaction
id|mca_wkup_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_wakeup_int_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;mca_wkup&quot;
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI
DECL|variable|mca_cpe_irqaction
r_static
r_struct
id|irqaction
id|mca_cpe_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_cpe_int_handler
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;cpe_hndlr&quot;
)brace
suffix:semicolon
DECL|variable|mca_cpep_irqaction
r_static
r_struct
id|irqaction
id|mca_cpep_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|ia64_mca_cpe_int_caller
comma
dot
id|flags
op_assign
id|SA_INTERRUPT
comma
dot
id|name
op_assign
l_string|&quot;cpe_poll&quot;
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_ACPI */
multiline_comment|/* Do per-CPU MCA-related initialization.  */
r_void
id|__devinit
DECL|function|ia64_mca_cpu_init
id|ia64_mca_cpu_init
c_func
(paren
r_void
op_star
id|cpu_data
)paren
(brace
r_void
op_star
id|pal_vaddr
suffix:semicolon
multiline_comment|/*&n;         * The MCA info structure was allocated earlier and its&n;         * physical address saved in __per_cpu_mca[cpu].  Copy that&n;         * address * to ia64_mca_data so we can access it as a per-CPU&n;         * variable.&n;         */
id|__get_cpu_var
c_func
(paren
id|ia64_mca_data
)paren
op_assign
id|__per_cpu_mca
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Stash away a copy of the PTE needed to map the per-CPU page.&n;&t; * We may need it during MCA recovery.&n;&t; */
id|__get_cpu_var
c_func
(paren
id|ia64_mca_per_cpu_pte
)paren
op_assign
id|pte_val
c_func
(paren
id|mk_pte_phys
c_func
(paren
id|__pa
c_func
(paren
id|cpu_data
)paren
comma
id|PAGE_KERNEL
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Also, stash away a copy of the PAL address and the PTE&n;         * needed to map it.&n;         */
id|pal_vaddr
op_assign
id|efi_get_pal_addr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pal_vaddr
)paren
r_return
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|ia64_mca_pal_base
)paren
op_assign
id|GRANULEROUNDDOWN
c_func
(paren
(paren
r_int
r_int
)paren
id|pal_vaddr
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|ia64_mca_pal_pte
)paren
op_assign
id|pte_val
c_func
(paren
id|mk_pte_phys
c_func
(paren
id|__pa
c_func
(paren
id|pal_vaddr
)paren
comma
id|PAGE_KERNEL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_init&n; *&n; *  Do all the system level mca specific initialization.&n; *&n; *&t;1. Register spinloop and wakeup request interrupt vectors&n; *&n; *&t;2. Register OS_MCA handler entry point&n; *&n; *&t;3. Register OS_INIT handler entry point&n; *&n; *  4. Initialize MCA/CMC/INIT related log buffers maintained by the OS.&n; *&n; *  Note that this initialization is done very early before some kernel&n; *  services are available.&n; *&n; *  Inputs  :   None&n; *&n; *  Outputs :   None&n; */
r_void
id|__init
DECL|function|ia64_mca_init
id|ia64_mca_init
c_func
(paren
r_void
)paren
(brace
id|ia64_fptr_t
op_star
id|mon_init_ptr
op_assign
(paren
id|ia64_fptr_t
op_star
)paren
id|ia64_monarch_init_handler
suffix:semicolon
id|ia64_fptr_t
op_star
id|slave_init_ptr
op_assign
(paren
id|ia64_fptr_t
op_star
)paren
id|ia64_slave_init_handler
suffix:semicolon
id|ia64_fptr_t
op_star
id|mca_hldlr_ptr
op_assign
(paren
id|ia64_fptr_t
op_star
)paren
id|ia64_os_mca_dispatch
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s64
id|rc
suffix:semicolon
r_struct
id|ia64_sal_retval
id|isrv
suffix:semicolon
id|u64
id|timeout
op_assign
id|IA64_MCA_RENDEZ_TIMEOUT
suffix:semicolon
multiline_comment|/* platform specific */
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: begin&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Clear the Rendez checkin flag for all cpus */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_mc_info.imi_rendez_checkin
(braket
id|i
)braket
op_assign
id|IA64_MCA_RENDEZ_CHECKIN_NOTDONE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the rendezvous spinloop and wakeup mechanism with SAL&n;&t; */
multiline_comment|/* Register the rendezvous interrupt vector with SAL */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|isrv
op_assign
id|ia64_sal_mc_set_params
c_func
(paren
id|SAL_MC_PARAM_RENDEZ_INT
comma
id|SAL_MC_PARAM_MECHANISM_INT
comma
id|IA64_MCA_RENDEZ_VECTOR
comma
id|timeout
comma
id|SAL_MC_PARAM_RZ_ALWAYS
)paren
suffix:semicolon
id|rc
op_assign
id|isrv.status
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Increasing MCA rendezvous timeout from &quot;
l_string|&quot;%ld to %ld milliseconds&bslash;n&quot;
comma
id|timeout
comma
id|isrv.v0
)paren
suffix:semicolon
id|timeout
op_assign
id|isrv.v0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to register rendezvous interrupt &quot;
l_string|&quot;with SAL (status %ld)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Register the wakeup interrupt vector with SAL */
id|isrv
op_assign
id|ia64_sal_mc_set_params
c_func
(paren
id|SAL_MC_PARAM_RENDEZ_WAKEUP
comma
id|SAL_MC_PARAM_MECHANISM_INT
comma
id|IA64_MCA_WAKEUP_VECTOR
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|rc
op_assign
id|isrv.status
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to register wakeup interrupt with SAL &quot;
l_string|&quot;(status %ld)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: registered MCA rendezvous spinloop and wakeup mech.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ia64_mc_info.imi_mca_handler
op_assign
id|ia64_tpa
c_func
(paren
id|mca_hldlr_ptr-&gt;fp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX - disable SAL checksum by setting size to 0; should be&n;&t; *&t;ia64_tpa(ia64_os_mca_dispatch_end) - ia64_tpa(ia64_os_mca_dispatch);&n;&t; */
id|ia64_mc_info.imi_mca_handler_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Register the os mca handler with SAL */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ia64_sal_set_vectors
c_func
(paren
id|SAL_VECTOR_OS_MCA
comma
id|ia64_mc_info.imi_mca_handler
comma
id|ia64_tpa
c_func
(paren
id|mca_hldlr_ptr-&gt;gp
)paren
comma
id|ia64_mc_info.imi_mca_handler_size
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to register OS MCA handler with SAL &quot;
l_string|&quot;(status %ld)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: registered OS MCA handler with SAL at 0x%lx, gp = 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ia64_mc_info.imi_mca_handler
comma
id|ia64_tpa
c_func
(paren
id|mca_hldlr_ptr-&gt;gp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX - disable SAL checksum by setting size to 0, should be&n;&t; * size of the actual init handler in mca_asm.S.&n;&t; */
id|ia64_mc_info.imi_monarch_init_handler
op_assign
id|ia64_tpa
c_func
(paren
id|mon_init_ptr-&gt;fp
)paren
suffix:semicolon
id|ia64_mc_info.imi_monarch_init_handler_size
op_assign
l_int|0
suffix:semicolon
id|ia64_mc_info.imi_slave_init_handler
op_assign
id|ia64_tpa
c_func
(paren
id|slave_init_ptr-&gt;fp
)paren
suffix:semicolon
id|ia64_mc_info.imi_slave_init_handler_size
op_assign
l_int|0
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: OS INIT handler at %lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ia64_mc_info.imi_monarch_init_handler
)paren
suffix:semicolon
multiline_comment|/* Register the os init handler with SAL */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ia64_sal_set_vectors
c_func
(paren
id|SAL_VECTOR_OS_INIT
comma
id|ia64_mc_info.imi_monarch_init_handler
comma
id|ia64_tpa
c_func
(paren
id|ia64_getreg
c_func
(paren
id|_IA64_REG_GP
)paren
)paren
comma
id|ia64_mc_info.imi_monarch_init_handler_size
comma
id|ia64_mc_info.imi_slave_init_handler
comma
id|ia64_tpa
c_func
(paren
id|ia64_getreg
c_func
(paren
id|_IA64_REG_GP
)paren
)paren
comma
id|ia64_mc_info.imi_slave_init_handler_size
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to register m/s INIT handlers with SAL &quot;
l_string|&quot;(status %ld)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: registered OS INIT handler with SAL&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Configure the CMCI/P vector and handler. Interrupts for CMC are&n;&t; *  per-processor, so AP CMC interrupts are setup in smp_callin() (smpboot.c).&n;&t; */
id|register_percpu_irq
c_func
(paren
id|IA64_CMC_VECTOR
comma
op_amp
id|cmci_irqaction
)paren
suffix:semicolon
id|register_percpu_irq
c_func
(paren
id|IA64_CMCP_VECTOR
comma
op_amp
id|cmcp_irqaction
)paren
suffix:semicolon
id|ia64_mca_cmc_vector_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Setup vector on BSP */
multiline_comment|/* Setup the MCA rendezvous interrupt vector */
id|register_percpu_irq
c_func
(paren
id|IA64_MCA_RENDEZ_VECTOR
comma
op_amp
id|mca_rdzv_irqaction
)paren
suffix:semicolon
multiline_comment|/* Setup the MCA wakeup interrupt vector */
id|register_percpu_irq
c_func
(paren
id|IA64_MCA_WAKEUP_VECTOR
comma
op_amp
id|mca_wkup_irqaction
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI
multiline_comment|/* Setup the CPEI/P vector and handler */
id|cpe_vector
op_assign
id|acpi_request_vector
c_func
(paren
id|ACPI_INTERRUPT_CPEI
)paren
suffix:semicolon
id|register_percpu_irq
c_func
(paren
id|IA64_CPEP_VECTOR
comma
op_amp
id|mca_cpep_irqaction
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the areas set aside by the OS to buffer the&n;&t; * platform/processor error states for MCA/INIT/CMC&n;&t; * handling.&n;&t; */
id|ia64_log_init
c_func
(paren
id|SAL_INFO_TYPE_MCA
)paren
suffix:semicolon
id|ia64_log_init
c_func
(paren
id|SAL_INFO_TYPE_INIT
)paren
suffix:semicolon
id|ia64_log_init
c_func
(paren
id|SAL_INFO_TYPE_CMC
)paren
suffix:semicolon
id|ia64_log_init
c_func
(paren
id|SAL_INFO_TYPE_CPE
)paren
suffix:semicolon
id|mca_init
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MCA related initialization done&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ia64_mca_late_init&n; *&n; *&t;Opportunity to setup things that require initialization later&n; *&t;than ia64_mca_init.  Setup a timer to poll for CPEs if the&n; *&t;platform doesn&squot;t support an interrupt driven mechanism.&n; *&n; *  Inputs  :   None&n; *  Outputs :   Status&n; */
r_static
r_int
id|__init
DECL|function|ia64_mca_late_init
id|ia64_mca_late_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mca_init
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Setup the CMCI/P vector and handler */
id|init_timer
c_func
(paren
op_amp
id|cmc_poll_timer
)paren
suffix:semicolon
id|cmc_poll_timer.function
op_assign
id|ia64_mca_cmc_poll
suffix:semicolon
multiline_comment|/* Unmask/enable the vector */
id|cmc_polling_enabled
op_assign
l_int|0
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|cmc_enable_work
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CMCI/P setup and enabled.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI
multiline_comment|/* Setup the CPEI/P vector and handler */
id|init_timer
c_func
(paren
op_amp
id|cpe_poll_timer
)paren
suffix:semicolon
id|cpe_poll_timer.function
op_assign
id|ia64_mca_cpe_poll
suffix:semicolon
(brace
id|irq_desc_t
op_star
id|desc
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|cpe_vector
op_ge
l_int|0
)paren
(brace
multiline_comment|/* If platform supports CPEI, enable the irq. */
id|cpe_poll_enabled
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NR_IRQS
suffix:semicolon
op_increment
id|irq
)paren
r_if
c_cond
(paren
id|irq_to_vector
c_func
(paren
id|irq
)paren
op_eq
id|cpe_vector
)paren
(brace
id|desc
op_assign
id|irq_descp
c_func
(paren
id|irq
)paren
suffix:semicolon
id|desc-&gt;status
op_or_assign
id|IRQ_PER_CPU
suffix:semicolon
id|setup_irq
c_func
(paren
id|irq
comma
op_amp
id|mca_cpe_irqaction
)paren
suffix:semicolon
)brace
id|ia64_mca_register_cpev
c_func
(paren
id|cpe_vector
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPEI/P setup and enabled.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If platform doesn&squot;t support CPEI, get the timer going. */
r_if
c_cond
(paren
id|cpe_poll_enabled
)paren
(brace
id|ia64_mca_cpe_poll
c_func
(paren
l_int|0UL
)paren
suffix:semicolon
id|IA64_MCA_DEBUG
c_func
(paren
l_string|&quot;%s: CPEP setup and enabled.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ia64_mca_late_init
id|device_initcall
c_func
(paren
id|ia64_mca_late_init
)paren
suffix:semicolon
eof
