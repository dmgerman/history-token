multiline_comment|/*&n; * I/O SAPIC support.&n; *&n; * Copyright (C) 1999 Intel Corp.&n; * Copyright (C) 1999 Asit Mallick &lt;asit.k.mallick@intel.com&gt;&n; * Copyright (C) 1999-2000 Hewlett-Packard Co.&n; * Copyright (C) 1999-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; * Copyright (C) 1999 VA Linux Systems&n; * Copyright (C) 1999,2000 Walt Drummond &lt;drummond@valinux.com&gt;&n; *&n; * 00/04/19&t;D. Mosberger&t;Rewritten to mirror more closely the x86 I/O APIC code.&n; *&t;&t;&t;&t;In particular, we now have separate handlers for edge&n; *&t;&t;&t;&t;and level triggered interrupts.&n; * 00/10/27&t;Asit Mallick, Goutham Rao &lt;goutham.rao@intel.com&gt; IRQ vector allocation&n; *&t;&t;&t;&t;PCI to vector mapping, shared PCI interrupts.&n; * 00/10/27&t;D. Mosberger&t;Document things a bit more to make them more understandable.&n; *&t;&t;&t;&t;Clean up much of the old IOSAPIC cruft.&n; */
multiline_comment|/*&n; * Here is what the interrupt logic between a PCI device and the CPU looks like:&n; *&n; * (1) A PCI device raises one of the four interrupt pins (INTA, INTB, INTC, INTD).  The&n; *     device is uniquely identified by its bus--, and slot-number (the function&n; *     number does not matter here because all functions share the same interrupt&n; *     lines).&n; *&n; * (2) The motherboard routes the interrupt line to a pin on a IOSAPIC controller.&n; *     Multiple interrupt lines may have to share the same IOSAPIC pin (if they&squot;re level&n; *     triggered and use the same polarity).  Each interrupt line has a unique IOSAPIC&n; *     irq number which can be calculated as the sum of the controller&squot;s base irq number&n; *     and the IOSAPIC pin number to which the line connects.&n; *&n; * (3) The IOSAPIC uses an internal table to map the IOSAPIC pin into the IA-64 interrupt&n; *     vector.  This interrupt vector is then sent to the CPU.&n; *&n; * In other words, there are two levels of indirections involved:&n; *&n; *&t;pci pin -&gt; iosapic irq -&gt; IA-64 vector&n; *&n; * Note: outside this module, IA-64 vectors are called &quot;irqs&quot;.  This is because that&squot;s&n; * the traditional name Linux uses for interrupt vectors.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/acpi-ext.h&gt;
macro_line|#include &lt;asm/acpikcfg.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/iosapic.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|macro|DEBUG_IRQ_ROUTING
macro_line|#undef DEBUG_IRQ_ROUTING
DECL|variable|iosapic_lock
r_static
id|spinlock_t
id|iosapic_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* PCI pin to IOSAPIC irq routing information.  This info typically comes from ACPI. */
r_static
r_struct
(brace
DECL|member|num_routes
r_int
id|num_routes
suffix:semicolon
DECL|member|route
r_struct
id|pci_vector_struct
op_star
id|route
suffix:semicolon
DECL|variable|pci_irq
)brace
id|pci_irq
suffix:semicolon
multiline_comment|/* This tables maps IA-64 vectors to the IOSAPIC pin that generates this vector. */
DECL|struct|iosapic_irq
r_static
r_struct
id|iosapic_irq
(brace
DECL|member|addr
r_char
op_star
id|addr
suffix:semicolon
multiline_comment|/* base address of IOSAPIC */
DECL|member|base_irq
r_int
r_char
id|base_irq
suffix:semicolon
multiline_comment|/* first irq assigned to this IOSAPIC */
DECL|member|pin
r_char
id|pin
suffix:semicolon
multiline_comment|/* IOSAPIC pin (-1 =&gt; not an IOSAPIC irq) */
DECL|member|dmode
r_int
r_char
id|dmode
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* delivery mode (see iosapic.h) */
DECL|member|polarity
r_int
r_char
id|polarity
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* interrupt polarity (see iosapic.h) */
DECL|member|trigger
r_int
r_char
id|trigger
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* trigger mode (see iosapic.h) */
DECL|variable|iosapic_irq
)brace
id|iosapic_irq
(braket
id|IA64_NUM_VECTORS
)braket
suffix:semicolon
multiline_comment|/*&n; * Translate IOSAPIC irq number to the corresponding IA-64 interrupt vector.  If no&n; * entry exists, return -1.&n; */
r_static
r_int
DECL|function|iosapic_irq_to_vector
id|iosapic_irq_to_vector
(paren
r_int
id|irq
)paren
(brace
r_int
id|vector
suffix:semicolon
r_for
c_loop
(paren
id|vector
op_assign
l_int|0
suffix:semicolon
id|vector
OL
id|IA64_NUM_VECTORS
suffix:semicolon
op_increment
id|vector
)paren
r_if
c_cond
(paren
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_plus
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_eq
id|irq
)paren
r_return
id|vector
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Map PCI pin to the corresponding IA-64 interrupt vector.  If no such mapping exists,&n; * return -1.&n; */
r_static
r_int
DECL|function|pci_pin_to_vector
id|pci_pin_to_vector
(paren
r_int
id|bus
comma
r_int
id|slot
comma
r_int
id|pci_pin
)paren
(brace
r_struct
id|pci_vector_struct
op_star
id|r
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|pci_irq.route
suffix:semicolon
id|r
OL
id|pci_irq.route
op_plus
id|pci_irq.num_routes
suffix:semicolon
op_increment
id|r
)paren
r_if
c_cond
(paren
id|r-&gt;bus
op_eq
id|bus
op_logical_and
(paren
id|r-&gt;pci_id
op_rshift
l_int|16
)paren
op_eq
id|slot
op_logical_and
id|r-&gt;pin
op_eq
id|pci_pin
)paren
r_return
id|iosapic_irq_to_vector
c_func
(paren
id|r-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|set_rte
id|set_rte
(paren
r_int
r_int
id|vector
comma
r_int
r_int
id|dest
)paren
(brace
r_int
r_int
id|pol
comma
id|trigger
comma
id|dmode
suffix:semicolon
id|u32
id|low32
comma
id|high32
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
r_int
id|pin
suffix:semicolon
id|pin
op_assign
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
suffix:semicolon
r_if
c_cond
(paren
id|pin
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* not an IOSAPIC interrupt */
id|addr
op_assign
id|iosapic_irq
(braket
id|vector
)braket
dot
id|addr
suffix:semicolon
id|pol
op_assign
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
suffix:semicolon
id|trigger
op_assign
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
suffix:semicolon
id|dmode
op_assign
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
suffix:semicolon
id|low32
op_assign
(paren
(paren
id|pol
op_lshift
id|IOSAPIC_POLARITY_SHIFT
)paren
op_or
(paren
id|trigger
op_lshift
id|IOSAPIC_TRIGGER_SHIFT
)paren
op_or
(paren
id|dmode
op_lshift
id|IOSAPIC_DELIVERY_SHIFT
)paren
op_or
id|vector
)paren
suffix:semicolon
multiline_comment|/* dest contains both id and eid */
id|high32
op_assign
(paren
id|dest
op_lshift
id|IOSAPIC_DEST_SHIFT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|IOSAPIC_RTE_HIGH
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|high32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
id|writel
c_func
(paren
id|IOSAPIC_RTE_LOW
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|low32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|nop
id|nop
(paren
r_int
r_int
id|vector
)paren
(brace
multiline_comment|/* do nothing... */
)brace
r_static
r_void
DECL|function|mask_irq
id|mask_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|u32
id|low32
suffix:semicolon
r_int
id|pin
suffix:semicolon
id|ia64_vector
id|vec
op_assign
id|irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|addr
op_assign
id|iosapic_irq
(braket
id|vec
)braket
dot
id|addr
suffix:semicolon
id|pin
op_assign
id|iosapic_irq
(braket
id|vec
)braket
dot
id|pin
suffix:semicolon
r_if
c_cond
(paren
id|pin
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* not an IOSAPIC interrupt! */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|writel
c_func
(paren
id|IOSAPIC_RTE_LOW
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|low32
op_assign
id|readl
c_func
(paren
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
id|low32
op_or_assign
(paren
l_int|1
op_lshift
id|IOSAPIC_MASK_SHIFT
)paren
suffix:semicolon
multiline_comment|/* set only the mask bit */
id|writel
c_func
(paren
id|low32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|unmask_irq
id|unmask_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|u32
id|low32
suffix:semicolon
r_int
id|pin
suffix:semicolon
id|ia64_vector
id|vec
op_assign
id|irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|addr
op_assign
id|iosapic_irq
(braket
id|vec
)braket
dot
id|addr
suffix:semicolon
id|pin
op_assign
id|iosapic_irq
(braket
id|vec
)braket
dot
id|pin
suffix:semicolon
r_if
c_cond
(paren
id|pin
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* not an IOSAPIC interrupt! */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|writel
c_func
(paren
id|IOSAPIC_RTE_LOW
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|low32
op_assign
id|readl
c_func
(paren
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
id|low32
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|IOSAPIC_MASK_SHIFT
)paren
suffix:semicolon
multiline_comment|/* clear only the mask bit */
id|writel
c_func
(paren
id|low32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_set_affinity
id|iosapic_set_affinity
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|mask
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|high32
comma
id|low32
suffix:semicolon
r_int
id|dest
comma
id|pin
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|mask
op_and_assign
(paren
l_int|1UL
op_lshift
id|smp_num_cpus
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
op_logical_or
id|irq
op_ge
id|IA64_NUM_VECTORS
)paren
r_return
suffix:semicolon
id|dest
op_assign
id|cpu_physical_id
c_func
(paren
id|ffz
c_func
(paren
op_complement
id|mask
)paren
)paren
suffix:semicolon
id|pin
op_assign
id|iosapic_irq
(braket
id|irq
)braket
dot
id|pin
suffix:semicolon
id|addr
op_assign
id|iosapic_irq
(braket
id|irq
)braket
dot
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|pin
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* not an IOSAPIC interrupt */
multiline_comment|/* dest contains both id and eid */
id|high32
op_assign
id|dest
op_lshift
id|IOSAPIC_DEST_SHIFT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
(brace
multiline_comment|/* get current delivery mode by reading the low32 */
id|writel
c_func
(paren
id|IOSAPIC_RTE_LOW
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|low32
op_assign
id|readl
c_func
(paren
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
multiline_comment|/* change delivery mode to fixed */
id|low32
op_and_assign
op_complement
(paren
l_int|7
op_lshift
id|IOSAPIC_DELIVERY_SHIFT
)paren
suffix:semicolon
id|low32
op_or_assign
(paren
id|IOSAPIC_FIXED
op_lshift
id|IOSAPIC_DELIVERY_SHIFT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|IOSAPIC_RTE_HIGH
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|high32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
id|writel
c_func
(paren
id|IOSAPIC_RTE_LOW
c_func
(paren
id|pin
)paren
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|low32
comma
id|addr
op_plus
id|IOSAPIC_WINDOW
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Handlers for level-triggered interrupts.&n; */
r_static
r_int
r_int
DECL|function|iosapic_startup_level_irq
id|iosapic_startup_level_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|unmask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_end_level_irq
id|iosapic_end_level_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|ia64_vector
id|vec
op_assign
id|irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|writel
c_func
(paren
id|vec
comma
id|iosapic_irq
(braket
id|vec
)braket
dot
id|addr
op_plus
id|IOSAPIC_EOI
)paren
suffix:semicolon
)brace
DECL|macro|iosapic_shutdown_level_irq
mdefine_line|#define iosapic_shutdown_level_irq&t;mask_irq
DECL|macro|iosapic_enable_level_irq
mdefine_line|#define iosapic_enable_level_irq&t;unmask_irq
DECL|macro|iosapic_disable_level_irq
mdefine_line|#define iosapic_disable_level_irq&t;mask_irq
DECL|macro|iosapic_ack_level_irq
mdefine_line|#define iosapic_ack_level_irq&t;&t;nop
DECL|variable|irq_type_iosapic_level
r_struct
id|hw_interrupt_type
id|irq_type_iosapic_level
op_assign
(brace
r_typename
suffix:colon
l_string|&quot;IO-SAPIC-level&quot;
comma
id|startup
suffix:colon
id|iosapic_startup_level_irq
comma
id|shutdown
suffix:colon
id|iosapic_shutdown_level_irq
comma
id|enable
suffix:colon
id|iosapic_enable_level_irq
comma
id|disable
suffix:colon
id|iosapic_disable_level_irq
comma
id|ack
suffix:colon
id|iosapic_ack_level_irq
comma
id|end
suffix:colon
id|iosapic_end_level_irq
comma
id|set_affinity
suffix:colon
id|iosapic_set_affinity
)brace
suffix:semicolon
multiline_comment|/*&n; * Handlers for edge-triggered interrupts.&n; */
r_static
r_int
r_int
DECL|function|iosapic_startup_edge_irq
id|iosapic_startup_edge_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|unmask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * IOSAPIC simply drops interrupts pended while the&n;&t; * corresponding pin was masked, so we can&squot;t know if an&n;&t; * interrupt is pending already.  Let&squot;s hope not...&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_ack_edge_irq
id|iosapic_ack_edge_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|irq_desc_t
op_star
id|idesc
op_assign
id|irq_desc
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Once we have recorded IRQ_PENDING already, we can mask the&n;&t; * interrupt for real. This prevents IRQ storms from unhandled&n;&t; * devices.&n;&t; */
r_if
c_cond
(paren
(paren
id|idesc-&gt;status
op_amp
(paren
id|IRQ_PENDING
op_or
id|IRQ_DISABLED
)paren
)paren
op_eq
(paren
id|IRQ_PENDING
op_or
id|IRQ_DISABLED
)paren
)paren
id|mask_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|macro|iosapic_enable_edge_irq
mdefine_line|#define iosapic_enable_edge_irq&t;&t;unmask_irq
DECL|macro|iosapic_disable_edge_irq
mdefine_line|#define iosapic_disable_edge_irq&t;nop
DECL|macro|iosapic_end_edge_irq
mdefine_line|#define iosapic_end_edge_irq&t;&t;nop
DECL|variable|irq_type_iosapic_edge
r_struct
id|hw_interrupt_type
id|irq_type_iosapic_edge
op_assign
(brace
r_typename
suffix:colon
l_string|&quot;IO-SAPIC-edge&quot;
comma
id|startup
suffix:colon
id|iosapic_startup_edge_irq
comma
id|shutdown
suffix:colon
id|iosapic_disable_edge_irq
comma
id|enable
suffix:colon
id|iosapic_enable_edge_irq
comma
id|disable
suffix:colon
id|iosapic_disable_edge_irq
comma
id|ack
suffix:colon
id|iosapic_ack_edge_irq
comma
id|end
suffix:colon
id|iosapic_end_edge_irq
comma
id|set_affinity
suffix:colon
id|iosapic_set_affinity
)brace
suffix:semicolon
r_int
r_int
DECL|function|iosapic_version
id|iosapic_version
(paren
r_char
op_star
id|addr
)paren
(brace
multiline_comment|/*&n;&t; * IOSAPIC Version Register return 32 bit structure like:&n;&t; * {&n;&t; *&t;unsigned int version   : 8;&n;&t; *&t;unsigned int reserved1 : 8;&n;&t; *&t;unsigned int pins      : 8;&n;&t; *&t;unsigned int reserved2 : 8;&n;&t; * }&n;&t; */
id|writel
c_func
(paren
id|IOSAPIC_VERSION
comma
id|addr
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
r_return
id|readl
c_func
(paren
id|IOSAPIC_WINDOW
op_plus
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ACPI can describe IOSAPIC interrupts via static tables and namespace&n; * methods.  This provides an interface to register those interrupts and&n; * program the IOSAPIC RTE.&n; */
r_int
DECL|function|iosapic_register_irq
id|iosapic_register_irq
(paren
id|u32
id|global_vector
comma
r_int
r_int
id|polarity
comma
r_int
r_int
id|edge_triggered
comma
id|u32
id|base_irq
comma
r_char
op_star
id|iosapic_address
)paren
(brace
id|irq_desc_t
op_star
id|idesc
suffix:semicolon
r_struct
id|hw_interrupt_type
op_star
id|irq_type
suffix:semicolon
r_int
id|vector
suffix:semicolon
id|vector
op_assign
id|iosapic_irq_to_vector
c_func
(paren
id|global_vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
OL
l_int|0
)paren
id|vector
op_assign
id|ia64_alloc_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* fill in information from this vector&squot;s IOSAPIC */
id|iosapic_irq
(braket
id|vector
)braket
dot
id|addr
op_assign
id|iosapic_address
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_assign
id|base_irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
id|global_vector
op_minus
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
op_assign
id|polarity
ques
c_cond
id|IOSAPIC_POL_HIGH
suffix:colon
id|IOSAPIC_POL_LOW
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_LOWEST_PRIORITY
suffix:semicolon
r_if
c_cond
(paren
id|edge_triggered
)paren
(brace
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_EDGE
suffix:semicolon
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_edge
suffix:semicolon
)brace
r_else
(brace
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_LEVEL
suffix:semicolon
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_level
suffix:semicolon
)brace
id|idesc
op_assign
id|irq_desc
c_func
(paren
id|vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
id|irq_type
)paren
(brace
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
op_amp
id|no_irq_type
)paren
id|printk
c_func
(paren
l_string|&quot;iosapic_register_irq(): changing vector 0x%02x from&quot;
l_string|&quot;%s to %s&bslash;n&quot;
comma
id|vector
comma
id|idesc-&gt;handler
op_member_access_from_pointer
r_typename
comma
id|irq_type
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|idesc-&gt;handler
op_assign
id|irq_type
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;IOSAPIC %x(%s,%s) -&gt; Vector %x&bslash;n&quot;
comma
id|global_vector
comma
(paren
id|polarity
ques
c_cond
l_string|&quot;high&quot;
suffix:colon
l_string|&quot;low&quot;
)paren
comma
(paren
id|edge_triggered
ques
c_cond
l_string|&quot;edge&quot;
suffix:colon
l_string|&quot;level&quot;
)paren
comma
id|vector
)paren
suffix:semicolon
multiline_comment|/* program the IOSAPIC routing table */
id|set_rte
c_func
(paren
id|vector
comma
(paren
id|ia64_get_lid
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_return
id|vector
suffix:semicolon
)brace
multiline_comment|/*&n; * ACPI calls this when it finds an entry for a platform interrupt.&n; * Note that the irq_base and IOSAPIC address must be set in iosapic_init().&n; */
r_int
DECL|function|iosapic_register_platform_irq
id|iosapic_register_platform_irq
(paren
id|u32
id|int_type
comma
id|u32
id|global_vector
comma
id|u32
id|iosapic_vector
comma
id|u16
id|eid
comma
id|u16
id|id
comma
r_int
r_int
id|polarity
comma
r_int
r_int
id|edge_triggered
comma
id|u32
id|base_irq
comma
r_char
op_star
id|iosapic_address
)paren
(brace
r_struct
id|hw_interrupt_type
op_star
id|irq_type
suffix:semicolon
id|irq_desc_t
op_star
id|idesc
suffix:semicolon
r_int
id|vector
suffix:semicolon
r_switch
c_cond
(paren
id|int_type
)paren
(brace
r_case
id|ACPI20_ENTRY_PIS_CPEI
suffix:colon
id|vector
op_assign
id|IA64_PCE_VECTOR
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_LOWEST_PRIORITY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI20_ENTRY_PIS_INIT
suffix:colon
id|vector
op_assign
id|ia64_alloc_irq
c_func
(paren
)paren
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_INIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;iosapic_register_platform_irq(): invalid int type&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* fill in information from this vector&squot;s IOSAPIC */
id|iosapic_irq
(braket
id|vector
)braket
dot
id|addr
op_assign
id|iosapic_address
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_assign
id|base_irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
id|global_vector
op_minus
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
op_assign
id|polarity
ques
c_cond
id|IOSAPIC_POL_HIGH
suffix:colon
id|IOSAPIC_POL_LOW
suffix:semicolon
r_if
c_cond
(paren
id|edge_triggered
)paren
(brace
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_EDGE
suffix:semicolon
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_edge
suffix:semicolon
)brace
r_else
(brace
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_LEVEL
suffix:semicolon
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_level
suffix:semicolon
)brace
id|idesc
op_assign
id|irq_desc
c_func
(paren
id|vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
id|irq_type
)paren
(brace
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
op_amp
id|no_irq_type
)paren
id|printk
c_func
(paren
l_string|&quot;iosapic_register_platform_irq(): changing vector 0x%02x from&quot;
l_string|&quot;%s to %s&bslash;n&quot;
comma
id|vector
comma
id|idesc-&gt;handler
op_member_access_from_pointer
r_typename
comma
id|irq_type
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|idesc-&gt;handler
op_assign
id|irq_type
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PLATFORM int %x: IOSAPIC %x(%s,%s) -&gt; Vector %x CPU %.02u:%.02u&bslash;n&quot;
comma
id|int_type
comma
id|global_vector
comma
(paren
id|polarity
ques
c_cond
l_string|&quot;high&quot;
suffix:colon
l_string|&quot;low&quot;
)paren
comma
(paren
id|edge_triggered
ques
c_cond
l_string|&quot;edge&quot;
suffix:colon
l_string|&quot;level&quot;
)paren
comma
id|vector
comma
id|eid
comma
id|id
)paren
suffix:semicolon
multiline_comment|/* program the IOSAPIC routing table */
id|set_rte
c_func
(paren
id|vector
comma
(paren
(paren
id|id
op_lshift
l_int|8
)paren
op_or
id|eid
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_return
id|vector
suffix:semicolon
)brace
multiline_comment|/*&n; * ACPI calls this when it finds an entry for a legacy ISA interrupt.  Note that the&n; * irq_base and IOSAPIC address must be set in iosapic_init().&n; */
r_void
DECL|function|iosapic_register_legacy_irq
id|iosapic_register_legacy_irq
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|pin
comma
r_int
r_int
id|polarity
comma
r_int
r_int
id|edge_triggered
)paren
(brace
r_int
r_int
id|vector
op_assign
id|isa_irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ_ROUTING
id|printk
c_func
(paren
l_string|&quot;ISA: IRQ %u -&gt; IOSAPIC irq 0x%02x (%s, %s) -&gt; vector %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|irq
comma
(paren
r_int
)paren
id|pin
comma
id|polarity
ques
c_cond
l_string|&quot;high&quot;
suffix:colon
l_string|&quot;low&quot;
comma
id|edge_triggered
ques
c_cond
l_string|&quot;edge&quot;
suffix:colon
l_string|&quot;level&quot;
comma
id|vector
)paren
suffix:semicolon
macro_line|#endif
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
id|pin
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_LOWEST_PRIORITY
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
op_assign
id|polarity
ques
c_cond
id|IOSAPIC_POL_HIGH
suffix:colon
id|IOSAPIC_POL_LOW
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|edge_triggered
ques
c_cond
id|IOSAPIC_EDGE
suffix:colon
id|IOSAPIC_LEVEL
suffix:semicolon
)brace
r_void
id|__init
DECL|function|iosapic_init
id|iosapic_init
(paren
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|base_irq
comma
r_int
id|pcat_compat
)paren
(brace
r_struct
id|hw_interrupt_type
op_star
id|irq_type
suffix:semicolon
r_int
id|i
comma
id|irq
comma
id|max_pin
comma
id|vector
suffix:semicolon
id|irq_desc_t
op_star
id|idesc
suffix:semicolon
r_int
r_int
id|ver
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|first_time
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vector
op_assign
l_int|0
suffix:semicolon
id|vector
OL
id|IA64_NUM_VECTORS
suffix:semicolon
op_increment
id|vector
)paren
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* mark as unused */
multiline_comment|/*&n;&t;&t; * Fetch the PCI interrupt routing table:&n;&t;&t; */
id|acpi_cf_get_pci_vectors
c_func
(paren
op_amp
id|pci_irq.route
comma
op_amp
id|pci_irq.num_routes
)paren
suffix:semicolon
)brace
id|addr
op_assign
id|ioremap
c_func
(paren
id|phys_addr
comma
l_int|0
)paren
suffix:semicolon
id|ver
op_assign
id|iosapic_version
c_func
(paren
id|addr
)paren
suffix:semicolon
id|max_pin
op_assign
(paren
id|ver
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IOSAPIC: version %x.%x, address 0x%lx, IRQs 0x%02x-0x%02x&bslash;n&quot;
comma
(paren
id|ver
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
comma
(paren
id|ver
op_amp
l_int|0x0f
)paren
comma
id|phys_addr
comma
id|base_irq
comma
id|base_irq
op_plus
id|max_pin
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base_irq
op_eq
l_int|0
)paren
op_logical_and
id|pcat_compat
)paren
multiline_comment|/*&n;&t;&t; * Map the legacy ISA devices into the IOSAPIC data.  Some of these may&n;&t;&t; * get reprogrammed later on with data from the ACPI Interrupt Source&n;&t;&t; * Override table.&n;&t;&t; */
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
l_int|16
suffix:semicolon
op_increment
id|irq
)paren
(brace
id|vector
op_assign
id|isa_irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_eq
op_minus
l_int|1
)paren
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
id|irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_LOWEST_PRIORITY
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_EDGE
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
op_assign
id|IOSAPIC_POL_HIGH
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ_ROUTING
id|printk
c_func
(paren
l_string|&quot;ISA: IRQ %u -&gt; IOSAPIC irq 0x%02x (high, edge) -&gt; vector 0x%02x&bslash;n&quot;
comma
id|irq
comma
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_plus
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
comma
id|vector
)paren
suffix:semicolon
macro_line|#endif
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_edge
suffix:semicolon
id|idesc
op_assign
id|irq_desc
c_func
(paren
id|vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
id|irq_type
)paren
(brace
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
op_amp
id|no_irq_type
)paren
id|printk
c_func
(paren
l_string|&quot;iosapic_init: changing vector 0x%02x from %s to &quot;
l_string|&quot;%s&bslash;n&quot;
comma
id|irq
comma
id|idesc-&gt;handler
op_member_access_from_pointer
r_typename
comma
id|irq_type
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|idesc-&gt;handler
op_assign
id|irq_type
suffix:semicolon
)brace
multiline_comment|/* program the IOSAPIC routing table: */
id|set_rte
c_func
(paren
id|vector
comma
(paren
id|ia64_get_lid
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pci_irq.num_routes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq
op_assign
id|pci_irq.route
(braket
id|i
)braket
dot
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|irq
op_minus
id|base_irq
)paren
OG
id|max_pin
)paren
multiline_comment|/* the interrupt route is for another controller... */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pcat_compat
op_logical_and
(paren
id|irq
OL
l_int|16
)paren
)paren
id|vector
op_assign
id|isa_irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
r_else
(brace
id|vector
op_assign
id|iosapic_irq_to_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
OL
l_int|0
)paren
multiline_comment|/* new iosapic irq: allocate a vector for it */
id|vector
op_assign
id|ia64_alloc_irq
c_func
(paren
)paren
suffix:semicolon
)brace
id|iosapic_irq
(braket
id|vector
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_assign
id|base_irq
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
op_assign
(paren
id|irq
op_minus
id|base_irq
)paren
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|dmode
op_assign
id|IOSAPIC_LOWEST_PRIORITY
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|trigger
op_assign
id|IOSAPIC_LEVEL
suffix:semicolon
id|iosapic_irq
(braket
id|vector
)braket
dot
id|polarity
op_assign
id|IOSAPIC_POL_LOW
suffix:semicolon
macro_line|# ifdef DEBUG_IRQ_ROUTING
id|printk
c_func
(paren
l_string|&quot;PCI: (B%d,I%d,P%d) -&gt; IOSAPIC irq 0x%02x -&gt; vector 0x%02x&bslash;n&quot;
comma
id|pci_irq.route
(braket
id|i
)braket
dot
id|bus
comma
id|pci_irq.route
(braket
id|i
)braket
dot
id|pci_id
op_rshift
l_int|16
comma
id|pci_irq.route
(braket
id|i
)braket
dot
id|pin
comma
id|iosapic_irq
(braket
id|vector
)braket
dot
id|base_irq
op_plus
id|iosapic_irq
(braket
id|vector
)braket
dot
id|pin
comma
id|vector
)paren
suffix:semicolon
macro_line|# endif
id|irq_type
op_assign
op_amp
id|irq_type_iosapic_level
suffix:semicolon
id|idesc
op_assign
id|irq_desc
c_func
(paren
id|vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
id|irq_type
)paren
(brace
r_if
c_cond
(paren
id|idesc-&gt;handler
op_ne
op_amp
id|no_irq_type
)paren
id|printk
c_func
(paren
l_string|&quot;iosapic_init: changing vector 0x%02x from %s to %s&bslash;n&quot;
comma
id|vector
comma
id|idesc-&gt;handler
op_member_access_from_pointer
r_typename
comma
id|irq_type
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|idesc-&gt;handler
op_assign
id|irq_type
suffix:semicolon
)brace
multiline_comment|/* program the IOSAPIC routing table: */
id|set_rte
c_func
(paren
id|vector
comma
(paren
id|ia64_get_lid
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|iosapic_pci_fixup
id|iosapic_pci_fixup
(paren
r_int
id|phase
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
r_char
id|pin
suffix:semicolon
r_int
id|vector
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
l_int|1
)paren
r_return
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pin
)paren
(brace
id|pin
op_decrement
suffix:semicolon
multiline_comment|/* interrupt pins are numbered starting from 1 */
id|vector
op_assign
id|pci_pin_to_vector
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|pin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
OL
l_int|0
op_logical_and
id|dev-&gt;bus-&gt;parent
)paren
(brace
multiline_comment|/* go back to the bridge */
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|dev-&gt;bus-&gt;self
suffix:semicolon
r_if
c_cond
(paren
id|bridge
)paren
(brace
multiline_comment|/* allow for multiple bridges on an adapter */
r_do
(brace
multiline_comment|/* do the bridge swizzle... */
id|pin
op_assign
(paren
id|pin
op_plus
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
op_mod
l_int|4
suffix:semicolon
id|vector
op_assign
id|pci_pin_to_vector
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|bridge-&gt;devfn
)paren
comma
id|pin
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|vector
OL
l_int|0
op_logical_and
(paren
id|bridge
op_assign
id|bridge-&gt;bus-&gt;self
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vector
op_ge
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: using PPB(B%d,I%d,P%d) to get vector %02x&bslash;n&quot;
comma
id|bridge-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|bridge-&gt;devfn
)paren
comma
id|pin
comma
id|vector
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: Couldn&squot;t map irq for (B%d,I%d,P%d)o&bslash;n&quot;
comma
id|bridge-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|bridge-&gt;devfn
)paren
comma
id|pin
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vector
op_ge
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI-&gt;APIC IRQ transform: (B%d,I%d,P%d) -&gt; 0x%02x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|pin
comma
id|vector
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|vector
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t;&t;&t; * For platforms that do not support interrupt redirect&n;&t;&t;&t;&t; * via the XTP interface, we can round-robin the PCI&n;&t;&t;&t;&t; * device interrupts to the processors&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|smp_int_redirect
op_amp
id|SMP_IRQ_REDIRECTION
)paren
)paren
(brace
r_static
r_int
id|cpu_index
op_assign
l_int|0
suffix:semicolon
id|set_rte
c_func
(paren
id|vector
comma
id|cpu_physical_id
c_func
(paren
id|cpu_index
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|cpu_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpu_index
op_ge
id|smp_num_cpus
)paren
id|cpu_index
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;&t;&t; * Nothing to fixup&n;&t;&t; * Fix out-of-range IRQ numbers&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;irq
op_ge
id|IA64_NUM_VECTORS
)paren
id|dev-&gt;irq
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* Spurious interrupts */
)brace
)brace
eof
