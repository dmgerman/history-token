multiline_comment|/*&n; * IA-64-specific support for kernel module loader.&n; *&n; * Copyright (C) 2003 Hewlett-Packard Co&n; *&t;David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * Loosely based on patch by Rusty Russell.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/moduleloader.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#ifdef CONFIG_ITANIUM
DECL|macro|USE_BRL
macro_line|# define USE_BRL&t;0
macro_line|#else
DECL|macro|USE_BRL
macro_line|# define USE_BRL&t;1
macro_line|#endif
DECL|macro|ARCH_MODULE_DEBUG
mdefine_line|#define ARCH_MODULE_DEBUG&t;0
macro_line|#if ARCH_MODULE_DEBUG
DECL|macro|DEBUGP
macro_line|# define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
macro_line|# define DEBUGP(fmt , a...)
macro_line|#endif
DECL|struct|got_entry
r_struct
id|got_entry
(brace
DECL|member|val
r_uint64
id|val
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fdesc
r_struct
id|fdesc
(brace
DECL|member|ip
r_uint64
id|ip
suffix:semicolon
DECL|member|gp
r_uint64
id|gp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Opaque struct for insns, to protect against derefs. */
r_struct
id|insn
suffix:semicolon
r_static
r_inline
r_void
op_star
DECL|function|bundle
id|bundle
(paren
r_const
r_struct
id|insn
op_star
id|insn
)paren
(brace
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_uint64
)paren
id|insn
op_amp
op_complement
l_int|0xfUL
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|slot
id|slot
(paren
r_const
r_struct
id|insn
op_star
id|insn
)paren
(brace
r_return
(paren
r_uint64
)paren
id|insn
op_amp
l_int|0x3
suffix:semicolon
)brace
multiline_comment|/* Patch instruction with &quot;val&quot; where &quot;mask&quot; has 1 bits. */
r_static
r_void
DECL|function|apply
id|apply
(paren
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|mask
comma
r_uint64
id|val
)paren
(brace
r_uint64
id|m0
comma
id|m1
comma
id|v0
comma
id|v1
comma
id|b0
comma
id|b1
comma
op_star
id|b
op_assign
id|bundle
c_func
(paren
id|insn
)paren
suffix:semicolon
DECL|macro|insn_mask
macro_line|#&t;define insn_mask ((1UL &lt;&lt; 41) - 1)
r_int
r_int
id|shift
suffix:semicolon
id|b0
op_assign
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|b1
op_assign
id|b
(braket
l_int|1
)braket
suffix:semicolon
id|shift
op_assign
l_int|5
op_plus
l_int|41
op_star
id|slot
c_func
(paren
id|insn
)paren
suffix:semicolon
multiline_comment|/* 5 bits of template, then 3 x 41-bit instructions */
r_if
c_cond
(paren
id|shift
op_ge
l_int|64
)paren
(brace
id|m1
op_assign
id|mask
op_lshift
(paren
id|shift
op_minus
l_int|64
)paren
suffix:semicolon
id|v1
op_assign
id|val
op_lshift
(paren
id|shift
op_minus
l_int|64
)paren
suffix:semicolon
)brace
r_else
(brace
id|m0
op_assign
id|mask
op_lshift
id|shift
suffix:semicolon
id|m1
op_assign
id|mask
op_rshift
(paren
l_int|64
op_minus
id|shift
)paren
suffix:semicolon
id|v0
op_assign
id|val
op_lshift
id|shift
suffix:semicolon
id|v1
op_assign
id|val
op_rshift
(paren
l_int|64
op_minus
id|shift
)paren
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
(paren
id|b0
op_amp
op_complement
id|m0
)paren
op_or
(paren
id|v0
op_amp
id|m0
)paren
suffix:semicolon
)brace
id|b
(braket
l_int|1
)braket
op_assign
(paren
id|b1
op_amp
op_complement
id|m1
)paren
op_or
(paren
id|v1
op_amp
id|m1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|apply_imm64
id|apply_imm64
(paren
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|val
)paren
(brace
id|BUG_ON
c_func
(paren
id|slot
c_func
(paren
id|insn
)paren
op_ne
l_int|2
)paren
suffix:semicolon
id|apply
c_func
(paren
id|insn
comma
l_int|0x01fffefe000
comma
(paren
(paren
(paren
id|val
op_amp
l_int|0x8000000000000000
)paren
op_rshift
l_int|27
)paren
multiline_comment|/* bit 63 -&gt; 36 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x0000000000200000
)paren
op_lshift
l_int|0
)paren
multiline_comment|/* bit 21 -&gt; 21 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x00000000001f0000
)paren
op_lshift
l_int|6
)paren
multiline_comment|/* bit 16 -&gt; 22 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x000000000000ff80
)paren
op_lshift
l_int|20
)paren
multiline_comment|/* bit  7 -&gt; 27 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x000000000000007f
)paren
op_lshift
l_int|13
)paren
multiline_comment|/* bit  0 -&gt; 13 */
)paren
)paren
suffix:semicolon
id|apply
c_func
(paren
(paren
r_void
op_star
)paren
id|insn
op_minus
l_int|1
comma
l_int|0x1ffffffffff
comma
id|val
op_rshift
l_int|22
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|apply_imm60
id|apply_imm60
(paren
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|val
)paren
(brace
id|BUG_ON
c_func
(paren
id|slot
c_func
(paren
id|insn
)paren
op_ne
l_int|2
)paren
suffix:semicolon
id|apply
c_func
(paren
id|insn
comma
l_int|0x011ffffe000
comma
(paren
(paren
(paren
id|val
op_amp
l_int|0x1000000000000000
)paren
op_rshift
l_int|24
)paren
multiline_comment|/* bit 60 -&gt; 36 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x00000000000fffff
)paren
op_lshift
l_int|13
)paren
multiline_comment|/* bit  0 -&gt; 13 */
)paren
)paren
suffix:semicolon
id|apply
c_func
(paren
(paren
r_void
op_star
)paren
id|insn
op_minus
l_int|1
comma
l_int|0x1fffffffffc
comma
id|val
op_rshift
l_int|18
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|apply_imm22
id|apply_imm22
(paren
r_struct
id|module
op_star
id|mod
comma
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|val
)paren
(brace
r_if
c_cond
(paren
id|val
op_plus
(paren
l_int|1
op_lshift
l_int|21
)paren
op_ge
(paren
l_int|1
op_lshift
l_int|22
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: value %li out of range&bslash;n&quot;
comma
id|mod-&gt;name
comma
(paren
r_int64
)paren
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|apply
c_func
(paren
id|insn
comma
l_int|0x01fffcfe000
comma
(paren
(paren
(paren
id|val
op_amp
l_int|0x200000
)paren
op_lshift
l_int|15
)paren
multiline_comment|/* bit 21 -&gt; 36 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x1f0000
)paren
op_lshift
l_int|6
)paren
multiline_comment|/* bit 16 -&gt; 22 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x00ff80
)paren
op_lshift
l_int|20
)paren
multiline_comment|/* bit  7 -&gt; 27 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x00007f
)paren
op_lshift
l_int|13
)paren
multiline_comment|/* bit  0 -&gt; 13 */
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|apply_imm21b
id|apply_imm21b
(paren
r_struct
id|module
op_star
id|mod
comma
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|val
)paren
(brace
r_if
c_cond
(paren
id|val
op_plus
(paren
l_int|1
op_lshift
l_int|20
)paren
op_ge
(paren
l_int|1
op_lshift
l_int|21
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: value %li out of range&bslash;n&quot;
comma
id|mod-&gt;name
comma
(paren
r_int64
)paren
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|apply
c_func
(paren
id|insn
comma
l_int|0x11ffffe000
comma
(paren
(paren
(paren
id|val
op_amp
l_int|0x100000
)paren
op_lshift
l_int|16
)paren
multiline_comment|/* bit 20 -&gt; 36 */
op_or
(paren
(paren
id|val
op_amp
l_int|0x0fffff
)paren
op_lshift
l_int|13
)paren
multiline_comment|/* bit  0 -&gt; 13 */
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if USE_BRL
DECL|struct|plt_entry
r_struct
id|plt_entry
(brace
multiline_comment|/* Three instruction bundles in PLT. */
DECL|member|bundle
r_int
r_char
id|bundle
(braket
l_int|2
)braket
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ia64_plt_template
r_static
r_const
r_struct
id|plt_entry
id|ia64_plt_template
op_assign
(brace
(brace
(brace
l_int|0x04
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
multiline_comment|/* [MLX] nop.m 0 */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x20
comma
multiline_comment|/*&t;     movl gp=TARGET_GP */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x60
)brace
comma
(brace
l_int|0x05
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
multiline_comment|/* [MLX] nop.m 0 */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*&t;     brl.many gp=TARGET_GP */
l_int|0x08
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xc0
)brace
)brace
)brace
suffix:semicolon
r_static
r_void
DECL|function|patch_plt
id|patch_plt
(paren
r_struct
id|plt_entry
op_star
id|plt
comma
r_int
id|target_ip
comma
r_int
r_int
id|target_gp
)paren
(brace
id|apply_imm64
c_func
(paren
(paren
r_struct
id|insn
op_star
)paren
(paren
id|plt-&gt;bundle
(braket
l_int|0
)braket
op_plus
l_int|2
)paren
comma
id|target_gp
)paren
suffix:semicolon
id|apply_imm60
c_func
(paren
(paren
r_struct
id|insn
op_star
)paren
(paren
id|plt-&gt;bundle
(braket
l_int|1
)braket
op_plus
l_int|2
)paren
comma
(paren
id|target_ip
op_minus
(paren
r_int
)paren
id|plt-&gt;bundle
(braket
l_int|1
)braket
)paren
op_div
l_int|16
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|plt_target
id|plt_target
(paren
r_struct
id|plt_entry
op_star
id|plt
)paren
(brace
r_uint64
id|b0
comma
id|b1
comma
op_star
id|b
op_assign
(paren
r_uint64
op_star
)paren
id|plt-&gt;bundle
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|off
suffix:semicolon
id|b0
op_assign
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|b1
op_assign
id|b
(braket
l_int|1
)braket
suffix:semicolon
id|off
op_assign
(paren
(paren
(paren
id|b1
op_amp
l_int|0x00fffff000000000
)paren
op_rshift
l_int|36
)paren
multiline_comment|/* imm20b -&gt; bit 0 */
op_or
(paren
(paren
id|b0
op_rshift
l_int|48
)paren
op_lshift
l_int|20
)paren
op_or
(paren
(paren
id|b1
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|36
)paren
multiline_comment|/* imm39 -&gt; bit 20 */
op_or
(paren
(paren
id|b1
op_amp
l_int|0x0800000000000000
)paren
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* i -&gt; bit 60 */
r_return
(paren
r_int
)paren
id|plt-&gt;bundle
(braket
l_int|1
)braket
op_plus
l_int|16
op_star
id|off
suffix:semicolon
)brace
macro_line|#else /* !USE_BRL */
DECL|struct|plt_entry
r_struct
id|plt_entry
(brace
multiline_comment|/* Three instruction bundles in PLT. */
DECL|member|bundle
r_int
r_char
id|bundle
(braket
l_int|3
)braket
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ia64_plt_template
r_static
r_const
r_struct
id|plt_entry
id|ia64_plt_template
op_assign
(brace
(brace
(brace
l_int|0x05
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
multiline_comment|/* [MLX] nop.m 0 */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*&t;     movl r16=TARGET_IP */
l_int|0x02
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x60
)brace
comma
(brace
l_int|0x04
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
multiline_comment|/* [MLX] nop.m 0 */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x20
comma
multiline_comment|/*&t;     movl gp=TARGET_GP */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x60
)brace
comma
(brace
l_int|0x11
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
multiline_comment|/* [MIB] nop.m 0 */
l_int|0x60
comma
l_int|0x80
comma
l_int|0x04
comma
l_int|0x80
comma
l_int|0x03
comma
l_int|0x00
comma
multiline_comment|/*&t;     mov b6=r16 */
l_int|0x60
comma
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
multiline_comment|/*&t;     br.few b6 */
)brace
)brace
)brace
suffix:semicolon
r_static
r_void
DECL|function|patch_plt
id|patch_plt
(paren
r_struct
id|plt_entry
op_star
id|plt
comma
r_int
r_int
id|target_ip
comma
r_int
r_int
id|target_gp
)paren
(brace
id|apply_imm64
c_func
(paren
(paren
r_struct
id|insn
op_star
)paren
(paren
id|plt-&gt;bundle
(braket
l_int|0
)braket
op_plus
l_int|2
)paren
comma
id|target_ip
)paren
suffix:semicolon
id|apply_imm64
c_func
(paren
(paren
r_struct
id|insn
op_star
)paren
(paren
id|plt-&gt;bundle
(braket
l_int|1
)braket
op_plus
l_int|2
)paren
comma
id|target_gp
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|plt_target
id|plt_target
(paren
r_struct
id|plt_entry
op_star
id|plt
)paren
(brace
r_uint64
id|b0
comma
id|b1
comma
op_star
id|b
op_assign
(paren
r_uint64
op_star
)paren
id|plt-&gt;bundle
(braket
l_int|0
)braket
suffix:semicolon
id|b0
op_assign
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|b1
op_assign
id|b
(braket
l_int|1
)braket
suffix:semicolon
r_return
(paren
(paren
(paren
id|b1
op_amp
l_int|0x000007f000000000
)paren
op_rshift
l_int|36
)paren
multiline_comment|/* imm7b -&gt; bit 0 */
op_or
(paren
(paren
id|b1
op_amp
l_int|0x07fc000000000000
)paren
op_rshift
l_int|43
)paren
multiline_comment|/* imm9d -&gt; bit 7 */
op_or
(paren
(paren
id|b1
op_amp
l_int|0x0003e00000000000
)paren
op_rshift
l_int|29
)paren
multiline_comment|/* imm5c -&gt; bit 16 */
op_or
(paren
(paren
id|b1
op_amp
l_int|0x0000100000000000
)paren
op_rshift
l_int|23
)paren
multiline_comment|/* ic -&gt; bit 21 */
op_or
(paren
(paren
id|b0
op_rshift
l_int|46
)paren
op_lshift
l_int|22
)paren
op_or
(paren
(paren
id|b1
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|40
)paren
multiline_comment|/* imm41 -&gt; bit 22 */
op_or
(paren
(paren
id|b1
op_amp
l_int|0x0800000000000000
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* i -&gt; bit 63 */
)brace
macro_line|#endif /* !USE_BRL */
r_void
op_star
DECL|function|module_alloc
id|module_alloc
(paren
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_void
DECL|function|module_free
id|module_free
(paren
r_struct
id|module
op_star
id|mod
comma
r_void
op_star
id|module_region
)paren
(brace
id|vfree
c_func
(paren
id|module_region
)paren
suffix:semicolon
)brace
multiline_comment|/* Have we already seen one of these relocations? */
multiline_comment|/* FIXME: we could look in other sections, too --RR */
r_static
r_int
DECL|function|duplicate_reloc
id|duplicate_reloc
(paren
r_const
id|Elf64_Rela
op_star
id|rela
comma
r_int
r_int
id|num
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
op_eq
id|rela
(braket
id|num
)braket
dot
id|r_info
op_logical_and
id|rela
(braket
id|i
)braket
dot
id|r_addend
op_eq
id|rela
(braket
id|num
)braket
dot
id|r_addend
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Count how many GOT entries we may need */
r_static
r_int
r_int
DECL|function|count_gots
id|count_gots
(paren
r_const
id|Elf64_Rela
op_star
id|rela
comma
r_int
r_int
id|num
)paren
(brace
r_int
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sure, this is order(n^2), but it&squot;s usually short, and not&n;           time critical */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ELF64_R_TYPE
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
)paren
(brace
r_case
id|R_IA64_LTOFF22
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|duplicate_reloc
c_func
(paren
id|rela
comma
id|i
)paren
)paren
id|ret
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Count how many PLT entries we may need */
r_static
r_int
r_int
DECL|function|count_plts
id|count_plts
(paren
r_const
id|Elf64_Rela
op_star
id|rela
comma
r_int
r_int
id|num
)paren
(brace
r_int
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sure, this is order(n^2), but it&squot;s usually short, and not&n;           time critical */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ELF64_R_TYPE
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
)paren
(brace
r_case
id|R_IA64_PCREL21B
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|duplicate_reloc
c_func
(paren
id|rela
comma
id|i
)paren
)paren
id|ret
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* We need to create an function-descriptors for any internal function&n;   which is referenced. */
r_static
r_int
r_int
DECL|function|count_fdescs
id|count_fdescs
(paren
r_const
id|Elf64_Rela
op_star
id|rela
comma
r_int
r_int
id|num
)paren
(brace
r_int
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sure, this is order(n^2), but it&squot;s usually short, and not time critical.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ELF64_R_TYPE
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
)paren
(brace
r_case
id|R_IA64_FPTR64LSB
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Jumps to static functions sometimes go straight to their&n;&t;&t;&t; * offset.  Of course, that may not be possible if the jump is&n;&t;&t;&t; * from init -&gt; core or vice. versa, so we need to generate an&n;&t;&t;&t; * FDESC (and PLT etc) for that.&n;&t;&t;&t; */
r_case
id|R_IA64_PCREL21B
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|duplicate_reloc
c_func
(paren
id|rela
comma
id|i
)paren
)paren
id|ret
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|module_frob_arch_sections
id|module_frob_arch_sections
(paren
id|Elf_Ehdr
op_star
id|ehdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_char
op_star
id|secstrings
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|core_plts
op_assign
l_int|0
comma
id|init_plts
op_assign
l_int|0
comma
id|gots
op_assign
l_int|0
comma
id|fdescs
op_assign
l_int|0
suffix:semicolon
id|Elf64_Shdr
op_star
id|s
comma
op_star
id|sechdrs_end
op_assign
id|sechdrs
op_plus
id|ehdr-&gt;e_shnum
suffix:semicolon
id|Elf64_Shdr
op_star
id|core_text
op_assign
l_int|NULL
comma
op_star
id|init_text
op_assign
l_int|NULL
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * To store the PLTs and function-descriptors, we expand the .text section for&n;&t; * core module-code and the .init.text section for initialization code.&n;&t; */
r_for
c_loop
(paren
id|s
op_assign
id|sechdrs
suffix:semicolon
id|s
OL
id|sechdrs_end
suffix:semicolon
op_increment
id|s
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;.text&quot;
comma
id|secstrings
op_plus
id|s-&gt;sh_name
)paren
op_eq
l_int|0
)paren
id|core_text
op_assign
id|mod-&gt;arch.core_text_sec
op_assign
id|s
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;.init.text&quot;
comma
id|secstrings
op_plus
id|s-&gt;sh_name
)paren
op_eq
l_int|0
)paren
id|init_text
op_assign
id|mod-&gt;arch.init_text_sec
op_assign
id|s
suffix:semicolon
multiline_comment|/* GOT and PLTs can occur in any relocated section... */
r_for
c_loop
(paren
id|s
op_assign
id|sechdrs
op_plus
l_int|1
suffix:semicolon
id|s
OL
id|sechdrs_end
suffix:semicolon
op_increment
id|s
)paren
(brace
r_const
id|Elf64_Rela
op_star
id|rels
op_assign
(paren
r_void
op_star
)paren
id|ehdr
op_plus
id|s-&gt;sh_offset
suffix:semicolon
r_int
r_int
id|numrels
op_assign
id|s-&gt;sh_size
op_div
r_sizeof
(paren
id|Elf64_Rela
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;sh_type
op_ne
id|SHT_RELA
)paren
r_continue
suffix:semicolon
id|gots
op_add_assign
id|count_gots
c_func
(paren
id|rels
comma
id|numrels
)paren
suffix:semicolon
id|fdescs
op_add_assign
id|count_fdescs
c_func
(paren
id|rels
comma
id|numrels
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|secstrings
op_plus
id|s-&gt;sh_name
comma
l_string|&quot;.init&quot;
)paren
)paren
id|init_plts
op_add_assign
id|count_plts
c_func
(paren
id|rels
comma
id|numrels
)paren
suffix:semicolon
r_else
id|core_plts
op_add_assign
id|count_plts
c_func
(paren
id|rels
comma
id|numrels
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|core_plts
op_or
id|fdescs
op_or
id|gots
)paren
OG
l_int|0
op_logical_and
op_logical_neg
id|core_text
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;module %s: no .text section&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_plts
OG
l_int|0
op_logical_and
op_logical_neg
id|init_text
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;module %s: no .init.text section&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: text sections must be at leasts 16-byte aligned, so we should be fine&n;&t; * here without any extra work.&n;&t; */
id|size
op_assign
id|core_text-&gt;sh_size
suffix:semicolon
id|mod-&gt;arch.core_plt_offset
op_assign
id|size
suffix:semicolon
id|size
op_add_assign
id|core_plts
op_star
r_sizeof
(paren
r_struct
id|plt_entry
)paren
suffix:semicolon
id|mod-&gt;arch.fdesc_offset
op_assign
id|size
suffix:semicolon
id|size
op_add_assign
id|fdescs
op_star
r_sizeof
(paren
r_struct
id|fdesc
)paren
suffix:semicolon
id|mod-&gt;arch.got_offset
op_assign
id|size
suffix:semicolon
id|size
op_add_assign
id|gots
op_star
r_sizeof
(paren
r_struct
id|got_entry
)paren
suffix:semicolon
id|core_text-&gt;sh_size
op_assign
id|size
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;%s: core: sz=%lu, plt=+%lx, fdesc=+%lx, got=+%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|mod-&gt;arch.core_plt_offset
comma
id|mod-&gt;arch.fdesc_offset
comma
id|mod-&gt;arch.got_offset
)paren
suffix:semicolon
id|size
op_assign
id|init_text-&gt;sh_size
suffix:semicolon
id|mod-&gt;arch.init_plt_offset
op_assign
id|size
suffix:semicolon
id|size
op_add_assign
id|init_plts
op_star
r_sizeof
(paren
r_struct
id|plt_entry
)paren
suffix:semicolon
id|init_text-&gt;sh_size
op_assign
id|size
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;%s: init: sz=%lu, plt=+%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|mod-&gt;arch.init_plt_offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|in_init
id|in_init
(paren
r_const
r_struct
id|module
op_star
id|mod
comma
r_void
op_star
id|addr
)paren
(brace
r_return
(paren
r_uint64
)paren
(paren
id|addr
op_minus
id|mod-&gt;module_init
)paren
OL
id|mod-&gt;init_size
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|in_core
id|in_core
(paren
r_const
r_struct
id|module
op_star
id|mod
comma
r_void
op_star
id|addr
)paren
(brace
r_return
(paren
r_uint64
)paren
(paren
id|addr
op_minus
id|mod-&gt;module_core
)paren
OL
id|mod-&gt;core_size
suffix:semicolon
)brace
multiline_comment|/*&n; * Get gp-relative GOT entry for this value (gp points to start of GOT).  Returns -1 on&n; * failure.&n; */
r_static
r_uint64
DECL|function|get_got
id|get_got
(paren
r_struct
id|module
op_star
id|mod
comma
r_uint64
id|value
)paren
(brace
r_struct
id|got_entry
op_star
id|got
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: zero value in GOT&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_return
(paren
r_uint64
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|got
op_assign
(paren
r_void
op_star
)paren
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.got_offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|got
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|got
(braket
id|i
)braket
dot
id|val
op_eq
id|value
)paren
r_return
id|i
op_star
r_sizeof
(paren
r_struct
id|got_entry
)paren
suffix:semicolon
multiline_comment|/* Not enough GOT entries? */
r_if
c_cond
(paren
id|got
op_plus
id|i
op_ge
(paren
r_struct
id|got_entry
op_star
)paren
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.core_text_sec-&gt;sh_size
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|got
(braket
id|i
)braket
dot
id|val
op_assign
id|value
suffix:semicolon
r_return
id|i
op_star
r_sizeof
(paren
r_struct
id|got_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* Get PC-relative PLT entry for this value.  Returns 0 on failure. */
r_static
r_uint64
DECL|function|get_plt
id|get_plt
(paren
r_struct
id|module
op_star
id|mod
comma
r_const
r_struct
id|insn
op_star
id|insn
comma
r_uint64
id|value
)paren
(brace
r_struct
id|plt_entry
op_star
id|plt
comma
op_star
id|plt_end
suffix:semicolon
r_uint64
id|target_ip
comma
id|target_gp
suffix:semicolon
r_if
c_cond
(paren
id|in_init
c_func
(paren
id|mod
comma
(paren
r_void
op_star
)paren
id|insn
)paren
)paren
(brace
id|plt
op_assign
(paren
r_void
op_star
)paren
(paren
id|mod-&gt;arch.init_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.init_plt_offset
)paren
suffix:semicolon
id|plt_end
op_assign
(paren
r_void
op_star
)paren
id|plt
op_plus
id|mod-&gt;arch.init_text_sec-&gt;sh_size
suffix:semicolon
)brace
r_else
(brace
id|plt
op_assign
(paren
r_void
op_star
)paren
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.core_plt_offset
)paren
suffix:semicolon
id|plt_end
op_assign
(paren
r_void
op_star
)paren
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.fdesc_offset
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;value&quot; is a pointer to a function-descriptor; fetch the target ip/gp from it: */
id|target_ip
op_assign
(paren
(paren
r_uint64
op_star
)paren
id|value
)paren
(braket
l_int|0
)braket
suffix:semicolon
id|target_gp
op_assign
(paren
(paren
r_uint64
op_star
)paren
id|value
)paren
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Look for existing PLT entry. */
r_while
c_loop
(paren
id|plt-&gt;bundle
(braket
l_int|0
)braket
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|plt_target
c_func
(paren
id|plt
)paren
op_eq
id|target_ip
)paren
r_goto
id|found
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|plt
op_ge
id|plt_end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|plt
op_assign
id|ia64_plt_template
suffix:semicolon
id|patch_plt
c_func
(paren
id|plt
comma
id|target_ip
comma
id|target_gp
)paren
suffix:semicolon
macro_line|#if ARCH_MODULE_DEBUG
r_if
c_cond
(paren
id|plt_target
c_func
(paren
id|plt
)paren
op_ne
id|target_ip
)paren
id|printk
c_func
(paren
l_string|&quot;%s: mistargeted PLT: wanted %lx, got %lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|target_ip
comma
id|plt_target
c_func
(paren
id|plt
)paren
)paren
suffix:semicolon
macro_line|#endif
id|found
suffix:colon
r_return
(paren
r_uint64
)paren
id|plt
suffix:semicolon
)brace
multiline_comment|/* Get function descriptor for this function.  Returns 0 on failure. */
r_static
r_uint64
DECL|function|get_fdesc
id|get_fdesc
(paren
r_struct
id|module
op_star
id|mod
comma
r_uint64
id|value
)paren
(brace
r_struct
id|fdesc
op_star
id|fdesc
op_assign
(paren
r_void
op_star
)paren
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.fdesc_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: fdesc for zero requested!&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look for existing function descriptor. */
r_while
c_loop
(paren
id|fdesc-&gt;ip
)paren
(brace
r_if
c_cond
(paren
id|fdesc-&gt;ip
op_eq
id|value
)paren
r_return
(paren
r_uint64
)paren
id|fdesc
suffix:semicolon
r_if
c_cond
(paren
(paren
r_uint64
)paren
op_increment
id|fdesc
op_ge
(paren
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.core_text_sec-&gt;sh_size
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Create new one */
id|fdesc-&gt;ip
op_assign
id|value
suffix:semicolon
id|fdesc-&gt;gp
op_assign
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.got_offset
suffix:semicolon
r_return
(paren
r_uint64
)paren
id|fdesc
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_internal
id|is_internal
(paren
r_const
r_struct
id|module
op_star
id|mod
comma
r_uint64
id|value
)paren
(brace
r_return
id|in_init
c_func
(paren
id|mod
comma
(paren
r_void
op_star
)paren
id|value
)paren
op_logical_or
id|in_core
c_func
(paren
id|mod
comma
(paren
r_void
op_star
)paren
id|value
)paren
suffix:semicolon
)brace
r_int
DECL|function|apply_relocate_add
id|apply_relocate_add
(paren
id|Elf64_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|strtab
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|relsec
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
comma
id|n
op_assign
id|sechdrs
(braket
id|relsec
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf64_Rela
)paren
suffix:semicolon
id|Elf64_Rela
op_star
id|rela
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|relsec
)braket
dot
id|sh_addr
suffix:semicolon
id|Elf64_Sym
op_star
id|symtab
comma
op_star
id|sym
suffix:semicolon
id|Elf64_Shdr
op_star
id|target_sec
suffix:semicolon
r_void
op_star
id|base
comma
op_star
id|location
suffix:semicolon
r_uint64
id|value
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;apply_relocate_add: applying section %u (%u relocs) to %u&bslash;n&quot;
comma
id|relsec
comma
id|n
comma
id|sechdrs
(braket
id|relsec
)braket
dot
id|sh_info
)paren
suffix:semicolon
id|target_sec
op_assign
id|sechdrs
op_plus
id|sechdrs
(braket
id|relsec
)braket
dot
id|sh_info
suffix:semicolon
r_if
c_cond
(paren
id|target_sec-&gt;sh_entsize
op_eq
op_complement
l_int|0UL
)paren
multiline_comment|/*&n;&t;&t; * If target section wasn&squot;t allocated, we don&squot;t need to relocate it.&n;&t;&t; * Happens, e.g., for debug sections.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
id|base
op_assign
(paren
r_void
op_star
)paren
id|target_sec-&gt;sh_addr
suffix:semicolon
id|symtab
op_assign
(paren
id|Elf64_Sym
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;base=%p, symtab=%p&bslash;n&quot;
comma
id|base
comma
id|symtab
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* This is where to make the change */
id|location
op_assign
id|base
op_plus
id|rela
(braket
id|i
)braket
dot
id|r_offset
suffix:semicolon
multiline_comment|/* This is the symbol it is referring to */
id|sym
op_assign
id|symtab
op_plus
id|ELF64_R_SYM
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym-&gt;st_value
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* `Everything is relative&squot;. */
id|value
op_assign
id|sym-&gt;st_value
op_plus
id|rela
(braket
id|i
)braket
dot
id|r_addend
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;loc=%p, val=0x%lx, sym=%p: &quot;
comma
id|location
comma
id|value
comma
id|sym
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ELF64_R_TYPE
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
)paren
(brace
r_case
id|R_IA64_LTOFF22
suffix:colon
id|value
op_assign
id|get_got
c_func
(paren
id|mod
comma
id|value
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;LTOFF22 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
(paren
r_uint64
)paren
op_minus
l_int|1
op_logical_or
op_logical_neg
id|apply_imm22
c_func
(paren
id|mod
comma
id|location
comma
id|value
)paren
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_PCREL21B
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|is_internal
c_func
(paren
id|mod
comma
id|value
)paren
)paren
id|value
op_assign
id|get_plt
c_func
(paren
id|mod
comma
id|location
comma
id|value
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;PCREL21B 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|value
op_sub_assign
(paren
r_uint64
)paren
id|bundle
c_func
(paren
id|location
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apply_imm21b
c_func
(paren
id|mod
comma
id|location
comma
(paren
r_int
)paren
id|value
op_div
l_int|16
)paren
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_DIR32LSB
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;DIR32LSB 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
op_star
(paren
(paren
r_uint32
op_star
)paren
id|location
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_SEGREL64LSB
suffix:colon
multiline_comment|/* My definition of &quot;segment&quot; is a little fuzzy here, but quoth&n;&t;&t;&t;   David Mosberger-Tang:&n;&n;&t;&t;&t;   As long as it&squot;s used consistently, it doesn&squot;t matter much.  All&n;&t;&t;&t;   unwind offsets are 64-bit offsets anyhow, so you could just use&n;&t;&t;&t;   a segment base of zero (the reason SEGREL relocs are used is to&n;&t;&t;&t;   make it possible to have the unwind tables be read-only in&n;&t;&t;&t;   shared libraries, but since you need to do relocation anyhow,&n;&t;&t;&t;   that&squot;s a moot issue). */
multiline_comment|/* Fall thru */
r_case
id|R_IA64_DIR64LSB
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;DIR64LSB 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
op_star
(paren
(paren
r_uint64
op_star
)paren
id|location
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_FPTR64LSB
suffix:colon
multiline_comment|/* Create a function descriptor for internal functions only. */
r_if
c_cond
(paren
id|is_internal
c_func
(paren
id|mod
comma
id|value
)paren
)paren
id|value
op_assign
id|get_fdesc
c_func
(paren
id|mod
comma
id|value
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;FPTR64LSB 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
op_star
(paren
(paren
r_uint64
op_star
)paren
id|location
)paren
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_GPREL22
suffix:colon
id|value
op_sub_assign
id|mod-&gt;arch.core_text_sec-&gt;sh_addr
op_plus
id|mod-&gt;arch.got_offset
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;GPREL22 0x%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apply_imm22
c_func
(paren
id|mod
comma
id|location
comma
id|value
)paren
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_LTOFF_FPTR22
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;LTOFF_FPTR22: orig=%lx, &quot;
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_internal
c_func
(paren
id|mod
comma
id|value
)paren
)paren
id|value
op_assign
id|get_fdesc
c_func
(paren
id|mod
comma
id|value
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;fdesc=%lx, &quot;
comma
id|value
)paren
suffix:semicolon
id|value
op_assign
id|get_got
c_func
(paren
id|mod
comma
id|value
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;got=%lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
(paren
r_uint64
)paren
op_minus
l_int|1
op_logical_or
op_logical_neg
id|apply_imm22
c_func
(paren
id|mod
comma
id|location
comma
id|value
)paren
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R_IA64_SECREL32LSB
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;SECREL32LSB: orig=0x%lx, val=0x%lx&bslash;n&quot;
comma
id|value
comma
id|value
op_minus
(paren
r_uint64
)paren
id|base
)paren
suffix:semicolon
op_star
(paren
r_uint32
op_star
)paren
id|location
op_assign
id|value
op_minus
(paren
r_uint64
)paren
id|base
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unknown RELA relocation: %lu&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|ELF64_R_TYPE
c_func
(paren
id|rela
(braket
id|i
)braket
dot
id|r_info
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|apply_relocate
id|apply_relocate
(paren
id|Elf64_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|strtab
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|relsec
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;module %s: REL relocs unsupported&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_int
DECL|function|module_finalize
id|module_finalize
(paren
r_const
id|Elf_Ehdr
op_star
id|hdr
comma
r_const
id|Elf_Shdr
op_star
id|sechdrs
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s: init: entry=%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|mod-&gt;init
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
