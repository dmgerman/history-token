multiline_comment|/*&n; * Copyright (C) 2003 Jerome Marchand, Bull S.A.&n; *&t;Cleaned up by David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * This file is released under the GPLv2, or at your option any later version.&n; *&n; * ia64 version of &quot;atomic_dec_and_lock()&quot; using the atomic &quot;cmpxchg&quot; instruction.  This&n; * code is an adaptation of the x86 version of &quot;atomic_dec_and_lock()&quot;.&n; */
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * Decrement REFCOUNT and if the count reaches zero, acquire the spinlock.  Both of these&n; * operations have to be done atomically, so that the count doesn&squot;t drop to zero without&n; * acquiring the spinlock first.&n; */
r_int
DECL|function|_atomic_dec_and_lock
id|_atomic_dec_and_lock
(paren
id|atomic_t
op_star
id|refcount
comma
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
id|old
comma
r_new
suffix:semicolon
r_do
(brace
id|old
op_assign
id|atomic_read
c_func
(paren
id|refcount
)paren
suffix:semicolon
r_new
op_assign
id|old
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|old
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* oops, we may be decrementing to zero, do it the slow way... */
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
id|refcount
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|cmpxchg
c_func
(paren
op_amp
id|refcount-&gt;counter
comma
id|old
comma
r_new
)paren
op_ne
id|old
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|_atomic_dec_and_lock
id|EXPORT_SYMBOL
c_func
(paren
id|_atomic_dec_and_lock
)paren
suffix:semicolon
eof
