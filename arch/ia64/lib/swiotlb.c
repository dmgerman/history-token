multiline_comment|/*&n; * Dynamic DMA mapping support.&n; *&n; * This implementation is for IA-64 platforms that do not support&n; * I/O TLBs (aka DMA address translation hardware).&n; * Copyright (C) 2000 Asit Mallick &lt;Asit.K.Mallick@intel.com&gt;&n; * Copyright (C) 2000 Goutham Rao &lt;goutham.rao@intel.com&gt;&n; * Copyright (C) 2000, 2003 Hewlett-Packard Co&n; *&t;David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * 03/05/07 davidm&t;Switch from PCI-DMA to generic device DMA API.&n; * 00/12/13 davidm&t;Rename to swiotlb.c and add mark_clean() to avoid&n; *&t;&t;&t;unnecessary i-cache flushing.&n; * 04/07/.. ak          Better overflow handling. Assorted fixes.&n; */
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
DECL|macro|OFFSET
mdefine_line|#define OFFSET(val,align) ((unsigned long)&t;&bslash;&n;&t;                   ( (val) &amp; ( (align) - 1)))
DECL|macro|SG_ENT_VIRT_ADDRESS
mdefine_line|#define SG_ENT_VIRT_ADDRESS(sg)&t;(page_address((sg)-&gt;page) + (sg)-&gt;offset)
DECL|macro|SG_ENT_PHYS_ADDRESS
mdefine_line|#define SG_ENT_PHYS_ADDRESS(SG)&t;virt_to_phys(SG_ENT_VIRT_ADDRESS(SG))
multiline_comment|/*&n; * Maximum allowable number of contiguous slabs to map,&n; * must be a power of 2.  What is the appropriate value ?&n; * The complexity of {map,unmap}_single is linearly dependent on this value.&n; */
DECL|macro|IO_TLB_SEGSIZE
mdefine_line|#define IO_TLB_SEGSIZE&t;128
multiline_comment|/*&n; * log of the size of each IO TLB slab.  The number of slabs is command line&n; * controllable.&n; */
DECL|macro|IO_TLB_SHIFT
mdefine_line|#define IO_TLB_SHIFT 11
DECL|variable|swiotlb_force
r_int
id|swiotlb_force
suffix:semicolon
multiline_comment|/*&n; * Used to do a quick range check in swiotlb_unmap_single and&n; * swiotlb_sync_single_*, to see if the memory was in fact allocated by this&n; * API.&n; */
DECL|variable|io_tlb_start
DECL|variable|io_tlb_end
r_static
r_char
op_star
id|io_tlb_start
comma
op_star
id|io_tlb_end
suffix:semicolon
multiline_comment|/*&n; * The number of IO TLB blocks (in groups of 64) betweeen io_tlb_start and&n; * io_tlb_end.  This is command line adjustable via setup_io_tlb_npages.&n; */
DECL|variable|io_tlb_nslabs
r_static
r_int
r_int
id|io_tlb_nslabs
suffix:semicolon
multiline_comment|/*&n; * When the IOMMU overflows we return a fallback buffer. This sets the size.&n; */
DECL|variable|io_tlb_overflow
r_static
r_int
r_int
id|io_tlb_overflow
op_assign
l_int|32
op_star
l_int|1024
suffix:semicolon
DECL|variable|io_tlb_overflow_buffer
r_void
op_star
id|io_tlb_overflow_buffer
suffix:semicolon
multiline_comment|/*&n; * This is a free list describing the number of free entries available from&n; * each index&n; */
DECL|variable|io_tlb_list
r_static
r_int
r_int
op_star
id|io_tlb_list
suffix:semicolon
DECL|variable|io_tlb_index
r_static
r_int
r_int
id|io_tlb_index
suffix:semicolon
multiline_comment|/*&n; * We need to save away the original address corresponding to a mapped entry&n; * for the sync operations.&n; */
DECL|variable|io_tlb_orig_addr
r_static
r_int
r_char
op_star
op_star
id|io_tlb_orig_addr
suffix:semicolon
multiline_comment|/*&n; * Protect the above data structures in the map and unmap calls&n; */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|io_tlb_lock
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|setup_io_tlb_npages
id|setup_io_tlb_npages
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|str
)paren
)paren
(brace
id|io_tlb_nslabs
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
op_amp
id|str
comma
l_int|0
)paren
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|IO_TLB_SHIFT
)paren
suffix:semicolon
multiline_comment|/* avoid tail segment of size &lt; IO_TLB_SEGSIZE */
id|io_tlb_nslabs
op_assign
id|ALIGN
c_func
(paren
id|io_tlb_nslabs
comma
id|IO_TLB_SEGSIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;,&squot;
)paren
op_increment
id|str
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;force&quot;
)paren
)paren
id|swiotlb_force
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;swiotlb=&quot;
comma
id|setup_io_tlb_npages
)paren
suffix:semicolon
multiline_comment|/* make io_tlb_overflow tunable too? */
multiline_comment|/*&n; * Statically reserve bounce buffer space and initialize bounce buffer data&n; * structures for the software IO TLB used to implement the PCI DMA API.&n; */
r_void
DECL|function|swiotlb_init_with_default_size
id|swiotlb_init_with_default_size
(paren
r_int
id|default_size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_tlb_nslabs
)paren
(brace
id|io_tlb_nslabs
op_assign
(paren
id|default_size
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|io_tlb_nslabs
op_assign
id|ALIGN
c_func
(paren
id|io_tlb_nslabs
comma
id|IO_TLB_SEGSIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get IO TLB memory from the low pages&n;&t; */
id|io_tlb_start
op_assign
id|alloc_bootmem_low_pages
c_func
(paren
id|io_tlb_nslabs
op_star
(paren
l_int|1
op_lshift
id|IO_TLB_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_tlb_start
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot allocate SWIOTLB buffer&quot;
)paren
suffix:semicolon
id|io_tlb_end
op_assign
id|io_tlb_start
op_plus
id|io_tlb_nslabs
op_star
(paren
l_int|1
op_lshift
id|IO_TLB_SHIFT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the free list array.  This array is used&n;&t; * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE&n;&t; * between io_tlb_start and io_tlb_end.&n;&t; */
id|io_tlb_list
op_assign
id|alloc_bootmem
c_func
(paren
id|io_tlb_nslabs
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|io_tlb_nslabs
suffix:semicolon
id|i
op_increment
)paren
id|io_tlb_list
(braket
id|i
)braket
op_assign
id|IO_TLB_SEGSIZE
op_minus
id|OFFSET
c_func
(paren
id|i
comma
id|IO_TLB_SEGSIZE
)paren
suffix:semicolon
id|io_tlb_index
op_assign
l_int|0
suffix:semicolon
id|io_tlb_orig_addr
op_assign
id|alloc_bootmem
c_func
(paren
id|io_tlb_nslabs
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the overflow emergency buffer&n;&t; */
id|io_tlb_overflow_buffer
op_assign
id|alloc_bootmem_low
c_func
(paren
id|io_tlb_overflow
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Placing software IO TLB between 0x%lx - 0x%lx&bslash;n&quot;
comma
id|virt_to_phys
c_func
(paren
id|io_tlb_start
)paren
comma
id|virt_to_phys
c_func
(paren
id|io_tlb_end
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|swiotlb_init
id|swiotlb_init
(paren
r_void
)paren
(brace
id|swiotlb_init_with_default_size
c_func
(paren
l_int|64
op_star
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
suffix:semicolon
multiline_comment|/* default to 64MB */
)brace
r_static
r_inline
r_int
DECL|function|address_needs_mapping
id|address_needs_mapping
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
id|dma_addr_t
id|addr
)paren
(brace
id|dma_addr_t
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* If the device has a mask, use it, otherwise default to 32 bits */
r_if
c_cond
(paren
id|hwdev
op_logical_and
id|hwdev-&gt;dma_mask
)paren
id|mask
op_assign
op_star
id|hwdev-&gt;dma_mask
suffix:semicolon
r_return
(paren
id|addr
op_amp
op_complement
id|mask
)paren
op_ne
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates bounce buffer and returns its kernel virtual address.&n; */
r_static
r_void
op_star
DECL|function|map_single
id|map_single
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|dma_addr
suffix:semicolon
r_int
r_int
id|nslots
comma
id|stride
comma
id|index
comma
id|wrap
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For mappings greater than a page, we limit the stride (and&n;&t; * hence alignment) to a page size.&n;&t; */
id|nslots
op_assign
id|ALIGN
c_func
(paren
id|size
comma
l_int|1
op_lshift
id|IO_TLB_SHIFT
)paren
op_rshift
id|IO_TLB_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|stride
op_assign
(paren
l_int|1
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|IO_TLB_SHIFT
)paren
)paren
suffix:semicolon
r_else
id|stride
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nslots
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find suitable number of IO TLB entries size that will fit this&n;&t; * request and allocate a buffer from that IO TLB pool.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_tlb_lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|wrap
op_assign
id|index
op_assign
id|ALIGN
c_func
(paren
id|io_tlb_index
comma
id|stride
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|io_tlb_nslabs
)paren
id|wrap
op_assign
id|index
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t;&t; * If we find a slot that indicates we have &squot;nslots&squot;&n;&t;&t;&t; * number of contiguous buffers, we allocate the&n;&t;&t;&t; * buffers from that slot and mark the entries as &squot;0&squot;&n;&t;&t;&t; * indicating unavailable.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|io_tlb_list
(braket
id|index
)braket
op_ge
id|nslots
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|index
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|index
op_plus
id|nslots
)paren
suffix:semicolon
id|i
op_increment
)paren
id|io_tlb_list
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
(paren
id|OFFSET
c_func
(paren
id|i
comma
id|IO_TLB_SEGSIZE
)paren
op_ne
id|IO_TLB_SEGSIZE
op_minus
l_int|1
)paren
op_logical_and
id|io_tlb_list
(braket
id|i
)braket
suffix:semicolon
id|i
op_decrement
)paren
id|io_tlb_list
(braket
id|i
)braket
op_assign
op_increment
id|count
suffix:semicolon
id|dma_addr
op_assign
id|io_tlb_start
op_plus
(paren
id|index
op_lshift
id|IO_TLB_SHIFT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Update the indices to avoid searching in&n;&t;&t;&t;&t; * the next round.&n;&t;&t;&t;&t; */
id|io_tlb_index
op_assign
(paren
(paren
id|index
op_plus
id|nslots
)paren
OL
id|io_tlb_nslabs
ques
c_cond
(paren
id|index
op_plus
id|nslots
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
id|index
op_add_assign
id|stride
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|io_tlb_nslabs
)paren
id|index
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|index
op_ne
id|wrap
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_tlb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|found
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_tlb_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save away the mapping from the original address to the DMA address.&n;&t; * This is needed when we sync the memory.  Then we sync the buffer if&n;&t; * needed.&n;&t; */
id|io_tlb_orig_addr
(braket
id|index
)braket
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_TO_DEVICE
op_logical_or
id|dir
op_eq
id|DMA_BIDIRECTIONAL
)paren
id|memcpy
c_func
(paren
id|dma_addr
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_return
id|dma_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * dma_addr is the kernel virtual address of the bounce buffer to unmap.&n; */
r_static
r_void
DECL|function|unmap_single
id|unmap_single
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_char
op_star
id|dma_addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|count
comma
id|nslots
op_assign
id|ALIGN
c_func
(paren
id|size
comma
l_int|1
op_lshift
id|IO_TLB_SHIFT
)paren
op_rshift
id|IO_TLB_SHIFT
suffix:semicolon
r_int
id|index
op_assign
(paren
id|dma_addr
op_minus
id|io_tlb_start
)paren
op_rshift
id|IO_TLB_SHIFT
suffix:semicolon
r_char
op_star
id|buffer
op_assign
id|io_tlb_orig_addr
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * First, sync the memory before unmapping the entry&n;&t; */
r_if
c_cond
(paren
id|buffer
op_logical_and
(paren
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
op_logical_or
(paren
id|dir
op_eq
id|DMA_BIDIRECTIONAL
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t; * bounce... copy the data back into the original buffer * and&n;&t;&t; * delete the bounce buffer.&n;&t;&t; */
id|memcpy
c_func
(paren
id|buffer
comma
id|dma_addr
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return the buffer to the free list by setting the corresponding&n;&t; * entries to indicate the number of contigous entries available.&n;&t; * While returning the entries to the free list, we merge the entries&n;&t; * with slots below and above the pool being returned.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_tlb_lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|count
op_assign
(paren
(paren
id|index
op_plus
id|nslots
)paren
OL
id|ALIGN
c_func
(paren
id|index
op_plus
l_int|1
comma
id|IO_TLB_SEGSIZE
)paren
ques
c_cond
id|io_tlb_list
(braket
id|index
op_plus
id|nslots
)braket
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step 1: return the slots to the free list, merging the&n;&t;&t; * slots with superceeding slots&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|index
op_plus
id|nslots
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
id|index
suffix:semicolon
id|i
op_decrement
)paren
id|io_tlb_list
(braket
id|i
)braket
op_assign
op_increment
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step 2: merge the returned slots with the preceding slots,&n;&t;&t; * if available (non zero)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
(paren
id|OFFSET
c_func
(paren
id|i
comma
id|IO_TLB_SEGSIZE
)paren
op_ne
id|IO_TLB_SEGSIZE
op_minus
l_int|1
)paren
op_logical_and
id|io_tlb_list
(braket
id|i
)braket
suffix:semicolon
id|i
op_decrement
)paren
id|io_tlb_list
(braket
id|i
)braket
op_assign
op_increment
id|count
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_tlb_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sync_single
id|sync_single
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_char
op_star
id|dma_addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_int
id|index
op_assign
(paren
id|dma_addr
op_minus
id|io_tlb_start
)paren
op_rshift
id|IO_TLB_SHIFT
suffix:semicolon
r_char
op_star
id|buffer
op_assign
id|io_tlb_orig_addr
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * bounce... copy the data back into/from the original buffer&n;&t; * XXX How do you handle DMA_BIDIRECTIONAL here ?&n;&t; */
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
id|memcpy
c_func
(paren
id|buffer
comma
id|dma_addr
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_TO_DEVICE
)paren
id|memcpy
c_func
(paren
id|dma_addr
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|swiotlb_alloc_coherent
id|swiotlb_alloc_coherent
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|dev_addr
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
r_int
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX fix me: the DMA API should pass us an explicit DMA mask&n;&t; * instead, or use ZONE_DMA32 (ia64 overloads ZONE_DMA to be a ~32&n;&t; * bit range instead of a 16MB one).&n;&t; */
id|flags
op_or_assign
id|GFP_DMA
suffix:semicolon
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|address_needs_mapping
c_func
(paren
id|hwdev
comma
id|virt_to_phys
c_func
(paren
id|ret
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The allocated memory isn&squot;t reachable by the device.&n;&t;&t; * Fall back on swiotlb_map_single().&n;&t;&t; */
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ret
comma
id|order
)paren
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are either out of memory or the device can&squot;t DMA&n;&t;&t; * to GFP_DMA memory; fall back on&n;&t;&t; * swiotlb_map_single(), which will grab memory from&n;&t;&t; * the lowest available address range.&n;&t;&t; */
id|dma_addr_t
id|handle
suffix:semicolon
id|handle
op_assign
id|swiotlb_map_single
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|size
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_mapping_error
c_func
(paren
id|handle
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|phys_to_virt
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|dev_addr
op_assign
id|virt_to_phys
c_func
(paren
id|ret
)paren
suffix:semicolon
multiline_comment|/* Confirm address can be DMA&squot;d by device */
r_if
c_cond
(paren
id|address_needs_mapping
c_func
(paren
id|hwdev
comma
id|dev_addr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hwdev DMA mask = 0x%016Lx, dev_addr = 0x%016lx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
op_star
id|hwdev-&gt;dma_mask
comma
id|dev_addr
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;swiotlb_alloc_coherent: allocated memory is out of &quot;
l_string|&quot;range for device&quot;
)paren
suffix:semicolon
)brace
op_star
id|dma_handle
op_assign
id|dev_addr
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|swiotlb_free_coherent
id|swiotlb_free_coherent
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vaddr
op_ge
(paren
r_void
op_star
)paren
id|io_tlb_start
op_logical_and
id|vaddr
OL
(paren
r_void
op_star
)paren
id|io_tlb_end
)paren
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_else
multiline_comment|/* DMA_TO_DEVICE to avoid memcpy in unmap_single */
id|swiotlb_unmap_single
(paren
id|hwdev
comma
id|dma_handle
comma
id|size
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|swiotlb_full
id|swiotlb_full
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_int
id|dir
comma
r_int
id|do_panic
)paren
(brace
multiline_comment|/*&n;&t; * Ran out of IOMMU space for this operation. This is very bad.&n;&t; * Unfortunately the drivers cannot handle this operation properly.&n;&t; * unless they check for pci_dma_mapping_error (most don&squot;t)&n;&t; * When the mapping is small enough return a static buffer to limit&n;&t; * the damage, or panic when the transfer is too big.&n;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI-DMA: Out of SW-IOMMU space for %lu bytes at &quot;
l_string|&quot;device %s&bslash;n&quot;
comma
id|size
comma
id|dev
ques
c_cond
id|dev-&gt;bus_id
suffix:colon
l_string|&quot;?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|io_tlb_overflow
op_logical_and
id|do_panic
)paren
(brace
r_if
c_cond
(paren
id|dir
op_eq
id|PCI_DMA_FROMDEVICE
op_logical_or
id|dir
op_eq
id|PCI_DMA_BIDIRECTIONAL
)paren
id|panic
c_func
(paren
l_string|&quot;PCI-DMA: Memory would be corrupted&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|PCI_DMA_TODEVICE
op_logical_or
id|dir
op_eq
id|PCI_DMA_BIDIRECTIONAL
)paren
id|panic
c_func
(paren
l_string|&quot;PCI-DMA: Random memory would be DMAed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Map a single buffer of the indicated size for DMA in streaming mode.  The&n; * PCI address to use is returned.&n; *&n; * Once the device is given the dma address, the device owns this memory until&n; * either swiotlb_unmap_single or swiotlb_dma_sync_single is performed.&n; */
id|dma_addr_t
DECL|function|swiotlb_map_single
id|swiotlb_map_single
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_int
r_int
id|dev_addr
op_assign
id|virt_to_phys
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_void
op_star
id|map
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the pointer passed in happens to be in the device&squot;s DMA window,&n;&t; * we can safely return the device addr and not worry about bounce&n;&t; * buffering it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|address_needs_mapping
c_func
(paren
id|hwdev
comma
id|dev_addr
)paren
op_logical_and
op_logical_neg
id|swiotlb_force
)paren
r_return
id|dev_addr
suffix:semicolon
multiline_comment|/*&n;&t; * Oh well, have to allocate and map a bounce buffer.&n;&t; */
id|map
op_assign
id|map_single
c_func
(paren
id|hwdev
comma
id|ptr
comma
id|size
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|swiotlb_full
c_func
(paren
id|hwdev
comma
id|size
comma
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|map
op_assign
id|io_tlb_overflow_buffer
suffix:semicolon
)brace
id|dev_addr
op_assign
id|virt_to_phys
c_func
(paren
id|map
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the address returned is DMA&squot;ble&n;&t; */
r_if
c_cond
(paren
id|address_needs_mapping
c_func
(paren
id|hwdev
comma
id|dev_addr
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;map_single: bounce buffer is not DMA&squot;ble&quot;
)paren
suffix:semicolon
r_return
id|dev_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Since DMA is i-cache coherent, any (complete) pages that were written via&n; * DMA can be marked as &quot;clean&quot; so that update_mmu_cache() doesn&squot;t have to&n; * flush them when they get mapped into an executable vm-area.&n; */
r_static
r_void
DECL|function|mark_clean
id|mark_clean
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|pg_addr
comma
id|end
suffix:semicolon
id|pg_addr
op_assign
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
id|end
op_assign
(paren
r_int
r_int
)paren
id|addr
op_plus
id|size
suffix:semicolon
r_while
c_loop
(paren
id|pg_addr
op_plus
id|PAGE_SIZE
op_le
id|end
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|virt_to_page
c_func
(paren
id|pg_addr
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_arch_1
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|pg_addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Unmap a single streaming mode DMA translation.  The dma_addr and size must&n; * match what was provided for in a previous swiotlb_map_single call.  All&n; * other usages are undefined.&n; *&n; * After this call, reads by the cpu to the buffer are guaranteed to see&n; * whatever the device wrote there.&n; */
r_void
DECL|function|swiotlb_unmap_single
id|swiotlb_unmap_single
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
id|dma_addr_t
id|dev_addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_char
op_star
id|dma_addr
op_assign
id|phys_to_virt
c_func
(paren
id|dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
op_ge
id|io_tlb_start
op_logical_and
id|dma_addr
OL
id|io_tlb_end
)paren
id|unmap_single
c_func
(paren
id|hwdev
comma
id|dma_addr
comma
id|size
comma
id|dir
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
id|mark_clean
c_func
(paren
id|dma_addr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make physical memory consistent for a single streaming mode DMA translation&n; * after a transfer.&n; *&n; * If you perform a swiotlb_map_single() but wish to interrogate the buffer&n; * using the cpu, yet do not wish to teardown the PCI dma mapping, you must&n; * call this function before doing so.  At the next point you give the PCI dma&n; * address back to the card, you must first perform a&n; * swiotlb_dma_sync_for_device, and then the device again owns the buffer&n; */
r_void
DECL|function|swiotlb_sync_single_for_cpu
id|swiotlb_sync_single_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
id|dma_addr_t
id|dev_addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_char
op_star
id|dma_addr
op_assign
id|phys_to_virt
c_func
(paren
id|dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
op_ge
id|io_tlb_start
op_logical_and
id|dma_addr
OL
id|io_tlb_end
)paren
id|sync_single
c_func
(paren
id|hwdev
comma
id|dma_addr
comma
id|size
comma
id|dir
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
id|mark_clean
c_func
(paren
id|dma_addr
comma
id|size
)paren
suffix:semicolon
)brace
r_void
DECL|function|swiotlb_sync_single_for_device
id|swiotlb_sync_single_for_device
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
id|dma_addr_t
id|dev_addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_char
op_star
id|dma_addr
op_assign
id|phys_to_virt
c_func
(paren
id|dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
op_ge
id|io_tlb_start
op_logical_and
id|dma_addr
OL
id|io_tlb_end
)paren
id|sync_single
c_func
(paren
id|hwdev
comma
id|dma_addr
comma
id|size
comma
id|dir
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
id|mark_clean
c_func
(paren
id|dma_addr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map a set of buffers described by scatterlist in streaming mode for DMA.&n; * This is the scatter-gather version of the above swiotlb_map_single&n; * interface.  Here the scatter gather list elements are each tagged with the&n; * appropriate dma address and length.  They are obtained via&n; * sg_dma_{address,length}(SG).&n; *&n; * NOTE: An implementation may be able to use a smaller number of&n; *       DMA address/length pairs than there are SG table elements.&n; *       (for example via virtual mapping capabilities)&n; *       The routine returns the number of addr/length pairs actually&n; *       used, at most nents.&n; *&n; * Device ownership issues as mentioned above for swiotlb_map_single are the&n; * same here.&n; */
r_int
DECL|function|swiotlb_map_sg
id|swiotlb_map_sg
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|dir
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
r_int
r_int
id|dev_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
id|addr
op_assign
id|SG_ENT_VIRT_ADDRESS
c_func
(paren
id|sg
)paren
suffix:semicolon
id|dev_addr
op_assign
id|virt_to_phys
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swiotlb_force
op_logical_or
id|address_needs_mapping
c_func
(paren
id|hwdev
comma
id|dev_addr
)paren
)paren
(brace
id|sg-&gt;dma_address
op_assign
(paren
id|dma_addr_t
)paren
id|virt_to_phys
c_func
(paren
id|map_single
c_func
(paren
id|hwdev
comma
id|addr
comma
id|sg-&gt;length
comma
id|dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg-&gt;dma_address
)paren
(brace
multiline_comment|/* Don&squot;t panic here, we expect map_sg users&n;&t;&t;&t;&t;   to do proper error handling. */
id|swiotlb_full
c_func
(paren
id|hwdev
comma
id|sg-&gt;length
comma
id|dir
comma
l_int|0
)paren
suffix:semicolon
id|swiotlb_unmap_sg
c_func
(paren
id|hwdev
comma
id|sg
op_minus
id|i
comma
id|i
comma
id|dir
)paren
suffix:semicolon
id|sg
(braket
l_int|0
)braket
dot
id|dma_length
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|sg-&gt;dma_address
op_assign
id|dev_addr
suffix:semicolon
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
)brace
r_return
id|nelems
suffix:semicolon
)brace
multiline_comment|/*&n; * Unmap a set of streaming mode DMA translations.  Again, cpu read rules&n; * concerning calls here are the same as for swiotlb_unmap_single() above.&n; */
r_void
DECL|function|swiotlb_unmap_sg
id|swiotlb_unmap_sg
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
r_if
c_cond
(paren
id|sg-&gt;dma_address
op_ne
id|SG_ENT_PHYS_ADDRESS
c_func
(paren
id|sg
)paren
)paren
id|unmap_single
c_func
(paren
id|hwdev
comma
(paren
r_void
op_star
)paren
id|phys_to_virt
c_func
(paren
id|sg-&gt;dma_address
)paren
comma
id|sg-&gt;dma_length
comma
id|dir
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
id|mark_clean
c_func
(paren
id|SG_ENT_VIRT_ADDRESS
c_func
(paren
id|sg
)paren
comma
id|sg-&gt;dma_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make physical memory consistent for a set of streaming mode DMA translations&n; * after a transfer.&n; *&n; * The same as swiotlb_sync_single_* but for a scatter-gather list, same rules&n; * and usage.&n; */
r_void
DECL|function|swiotlb_sync_sg_for_cpu
id|swiotlb_sync_sg_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
r_if
c_cond
(paren
id|sg-&gt;dma_address
op_ne
id|SG_ENT_PHYS_ADDRESS
c_func
(paren
id|sg
)paren
)paren
id|sync_single
c_func
(paren
id|hwdev
comma
(paren
r_void
op_star
)paren
id|sg-&gt;dma_address
comma
id|sg-&gt;dma_length
comma
id|dir
)paren
suffix:semicolon
)brace
r_void
DECL|function|swiotlb_sync_sg_for_device
id|swiotlb_sync_sg_for_device
c_func
(paren
r_struct
id|device
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelems
comma
r_int
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
r_if
c_cond
(paren
id|sg-&gt;dma_address
op_ne
id|SG_ENT_PHYS_ADDRESS
c_func
(paren
id|sg
)paren
)paren
id|sync_single
c_func
(paren
id|hwdev
comma
(paren
r_void
op_star
)paren
id|sg-&gt;dma_address
comma
id|sg-&gt;dma_length
comma
id|dir
)paren
suffix:semicolon
)brace
r_int
DECL|function|swiotlb_dma_mapping_error
id|swiotlb_dma_mapping_error
c_func
(paren
id|dma_addr_t
id|dma_addr
)paren
(brace
r_return
(paren
id|dma_addr
op_eq
id|virt_to_phys
c_func
(paren
id|io_tlb_overflow_buffer
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return whether the given PCI device DMA address mask can be supported&n; * properly.  For example, if your device can only drive the low 24-bits&n; * during PCI bus mastering, then you would pass 0x00ffffff as the mask to&n; * this function.&n; */
r_int
DECL|function|swiotlb_dma_supported
id|swiotlb_dma_supported
(paren
r_struct
id|device
op_star
id|hwdev
comma
id|u64
id|mask
)paren
(brace
r_return
(paren
id|virt_to_phys
(paren
id|io_tlb_end
)paren
op_minus
l_int|1
)paren
op_le
id|mask
suffix:semicolon
)brace
DECL|variable|swiotlb_init
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_init
)paren
suffix:semicolon
DECL|variable|swiotlb_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_map_single
)paren
suffix:semicolon
DECL|variable|swiotlb_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_unmap_single
)paren
suffix:semicolon
DECL|variable|swiotlb_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_map_sg
)paren
suffix:semicolon
DECL|variable|swiotlb_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_unmap_sg
)paren
suffix:semicolon
DECL|variable|swiotlb_sync_single_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_sync_single_for_cpu
)paren
suffix:semicolon
DECL|variable|swiotlb_sync_single_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_sync_single_for_device
)paren
suffix:semicolon
DECL|variable|swiotlb_sync_sg_for_cpu
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_sync_sg_for_cpu
)paren
suffix:semicolon
DECL|variable|swiotlb_sync_sg_for_device
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_sync_sg_for_device
)paren
suffix:semicolon
DECL|variable|swiotlb_dma_mapping_error
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_dma_mapping_error
)paren
suffix:semicolon
DECL|variable|swiotlb_alloc_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_alloc_coherent
)paren
suffix:semicolon
DECL|variable|swiotlb_free_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_free_coherent
)paren
suffix:semicolon
DECL|variable|swiotlb_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|swiotlb_dma_supported
)paren
suffix:semicolon
eof
