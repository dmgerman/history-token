multiline_comment|/*&n;**  IA64 System Bus Adapter (SBA) I/O MMU manager&n;**&n;**&t;(c) Copyright 2002-2004 Alex Williamson&n;**&t;(c) Copyright 2002-2003 Grant Grundler&n;**&t;(c) Copyright 2002-2004 Hewlett-Packard Company&n;**&n;**&t;Portions (c) 2000 Grant Grundler (from parisc I/O MMU code)&n;**&t;Portions (c) 1999 Dave S. Miller (from sparc64 I/O MMU code)&n;**&n;**&t;This program is free software; you can redistribute it and/or modify&n;**&t;it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;**&n;** This module initializes the IOC (I/O Controller) found on HP&n;** McKinley machines and their successors.&n;**&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &lt;linux/nodemask.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;         /* hweight64() */
macro_line|#include &lt;asm/delay.h&gt;&t;&t;/* ia64_get_itc() */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/page.h&gt;&t;&t;/* PAGE_OFFSET */
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;&t;&t;/* wmb() */
macro_line|#include &lt;asm/acpi-ext.h&gt;
DECL|macro|PFX
mdefine_line|#define PFX &quot;IOC: &quot;
multiline_comment|/*&n;** Enabling timing search of the pdir resource map.  Output in /proc.&n;** Disabled by default to optimize performance.&n;*/
DECL|macro|PDIR_SEARCH_TIMING
macro_line|#undef PDIR_SEARCH_TIMING
multiline_comment|/*&n;** This option allows cards capable of 64bit DMA to bypass the IOMMU.  If&n;** not defined, all DMA will be 32bit and go through the TLB.&n;** There&squot;s potentially a conflict in the bio merge code with us&n;** advertising an iommu, but then bypassing it.  Since I/O MMU bypassing&n;** appears to give more performance than bio-level virtual merging, we&squot;ll&n;** do the former for now.  NOTE: BYPASS_SG also needs to be undef&squot;d to&n;** completely restrict DMA to the IOMMU.&n;*/
DECL|macro|ALLOW_IOV_BYPASS
mdefine_line|#define ALLOW_IOV_BYPASS
multiline_comment|/*&n;** This option specifically allows/disallows bypassing scatterlists with&n;** multiple entries.  Coalescing these entries can allow better DMA streaming&n;** and in some cases shows better performance than entirely bypassing the&n;** IOMMU.  Performance increase on the order of 1-2% sequential output/input&n;** using bonnie++ on a RAID0 MD device (sym2 &amp; mpt).&n;*/
DECL|macro|ALLOW_IOV_BYPASS_SG
macro_line|#undef ALLOW_IOV_BYPASS_SG
multiline_comment|/*&n;** If a device prefetches beyond the end of a valid pdir entry, it will cause&n;** a hard failure, ie. MCA.  Version 3.0 and later of the zx1 LBA should&n;** disconnect on 4k boundaries and prevent such issues.  If the device is&n;** particularly agressive, this option will keep the entire pdir valid such&n;** that prefetching will hit a valid address.  This could severely impact&n;** error containment, and is therefore off by default.  The page that is&n;** used for spill-over is poisoned, so that should help debugging somewhat.&n;*/
DECL|macro|FULL_VALID_PDIR
macro_line|#undef FULL_VALID_PDIR
DECL|macro|ENABLE_MARK_CLEAN
mdefine_line|#define ENABLE_MARK_CLEAN
multiline_comment|/*&n;** The number of debug flags is a clue - this code is fragile.  NOTE: since&n;** tightening the use of res_lock the resource bitmap and actual pdir are no&n;** longer guaranteed to stay in sync.  The sanity checking code isn&squot;t going to&n;** like that.&n;*/
DECL|macro|DEBUG_SBA_INIT
macro_line|#undef DEBUG_SBA_INIT
DECL|macro|DEBUG_SBA_RUN
macro_line|#undef DEBUG_SBA_RUN
DECL|macro|DEBUG_SBA_RUN_SG
macro_line|#undef DEBUG_SBA_RUN_SG
DECL|macro|DEBUG_SBA_RESOURCE
macro_line|#undef DEBUG_SBA_RESOURCE
DECL|macro|ASSERT_PDIR_SANITY
macro_line|#undef ASSERT_PDIR_SANITY
DECL|macro|DEBUG_LARGE_SG_ENTRIES
macro_line|#undef DEBUG_LARGE_SG_ENTRIES
DECL|macro|DEBUG_BYPASS
macro_line|#undef DEBUG_BYPASS
macro_line|#if defined(FULL_VALID_PDIR) &amp;&amp; defined(ASSERT_PDIR_SANITY)
macro_line|#error FULL_VALID_PDIR and ASSERT_PDIR_SANITY are mutually exclusive
macro_line|#endif
DECL|macro|SBA_INLINE
mdefine_line|#define SBA_INLINE&t;__inline__
multiline_comment|/* #define SBA_INLINE */
macro_line|#ifdef DEBUG_SBA_INIT
DECL|macro|DBG_INIT
mdefine_line|#define DBG_INIT(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_INIT
mdefine_line|#define DBG_INIT(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_SBA_RUN
DECL|macro|DBG_RUN
mdefine_line|#define DBG_RUN(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_RUN
mdefine_line|#define DBG_RUN(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_SBA_RUN_SG
DECL|macro|DBG_RUN_SG
mdefine_line|#define DBG_RUN_SG(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_RUN_SG
mdefine_line|#define DBG_RUN_SG(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_SBA_RESOURCE
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_BYPASS
DECL|macro|DBG_BYPASS
mdefine_line|#define DBG_BYPASS(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_BYPASS
mdefine_line|#define DBG_BYPASS(x...)
macro_line|#endif
macro_line|#ifdef ASSERT_PDIR_SANITY
DECL|macro|ASSERT
mdefine_line|#define ASSERT(expr) &bslash;&n;        if(!(expr)) { &bslash;&n;                printk( &quot;&bslash;n&quot; __FILE__ &quot;:%d: Assertion &quot; #expr &quot; failed!&bslash;n&quot;,__LINE__); &bslash;&n;                panic(#expr); &bslash;&n;        }
macro_line|#else
DECL|macro|ASSERT
mdefine_line|#define ASSERT(expr)
macro_line|#endif
multiline_comment|/*&n;** The number of pdir entries to &quot;free&quot; before issuing&n;** a read to PCOM register to flush out PCOM writes.&n;** Interacts with allocation granularity (ie 4 or 8 entries&n;** allocated and free&squot;d/purged at a time might make this&n;** less interesting).&n;*/
DECL|macro|DELAYED_RESOURCE_CNT
mdefine_line|#define DELAYED_RESOURCE_CNT&t;64
DECL|macro|ZX1_IOC_ID
mdefine_line|#define ZX1_IOC_ID&t;((PCI_DEVICE_ID_HP_ZX1_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)
DECL|macro|REO_IOC_ID
mdefine_line|#define REO_IOC_ID&t;((PCI_DEVICE_ID_HP_REO_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)
DECL|macro|SX1000_IOC_ID
mdefine_line|#define SX1000_IOC_ID&t;((PCI_DEVICE_ID_HP_SX1000_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)
DECL|macro|ZX1_IOC_OFFSET
mdefine_line|#define ZX1_IOC_OFFSET&t;0x1000&t;/* ACPI reports SBA, we want IOC */
DECL|macro|IOC_FUNC_ID
mdefine_line|#define IOC_FUNC_ID&t;0x000
DECL|macro|IOC_FCLASS
mdefine_line|#define IOC_FCLASS&t;0x008&t;/* function class, bist, header, rev... */
DECL|macro|IOC_IBASE
mdefine_line|#define IOC_IBASE&t;0x300&t;/* IO TLB */
DECL|macro|IOC_IMASK
mdefine_line|#define IOC_IMASK&t;0x308
DECL|macro|IOC_PCOM
mdefine_line|#define IOC_PCOM&t;0x310
DECL|macro|IOC_TCNFG
mdefine_line|#define IOC_TCNFG&t;0x318
DECL|macro|IOC_PDIR_BASE
mdefine_line|#define IOC_PDIR_BASE&t;0x320
DECL|macro|IOC_ROPE0_CFG
mdefine_line|#define IOC_ROPE0_CFG&t;0x500
DECL|macro|IOC_ROPE_AO
mdefine_line|#define   IOC_ROPE_AO&t;  0x10&t;/* Allow &quot;Relaxed Ordering&quot; */
multiline_comment|/* AGP GART driver looks for this */
DECL|macro|ZX1_SBA_IOMMU_COOKIE
mdefine_line|#define ZX1_SBA_IOMMU_COOKIE&t;0x0000badbadc0ffeeUL
multiline_comment|/*&n;** The zx1 IOC supports 4/8/16/64KB page sizes (see TCNFG register)&n;**&n;** Some IOCs (sx1000) can run at the above pages sizes, but are&n;** really only supported using the IOC at a 4k page size.&n;**&n;** iovp_size could only be greater than PAGE_SIZE if we are&n;** confident the drivers really only touch the next physical&n;** page iff that driver instance owns it.&n;*/
DECL|variable|iovp_size
r_static
r_int
r_int
id|iovp_size
suffix:semicolon
DECL|variable|iovp_shift
r_static
r_int
r_int
id|iovp_shift
suffix:semicolon
DECL|variable|iovp_mask
r_static
r_int
r_int
id|iovp_mask
suffix:semicolon
DECL|struct|ioc
r_struct
id|ioc
(brace
DECL|member|ioc_hpa
r_void
id|__iomem
op_star
id|ioc_hpa
suffix:semicolon
multiline_comment|/* I/O MMU base address */
DECL|member|res_map
r_char
op_star
id|res_map
suffix:semicolon
multiline_comment|/* resource map, bit == pdir entry */
DECL|member|pdir_base
id|u64
op_star
id|pdir_base
suffix:semicolon
multiline_comment|/* physical base address */
DECL|member|ibase
r_int
r_int
id|ibase
suffix:semicolon
multiline_comment|/* pdir IOV Space base */
DECL|member|imask
r_int
r_int
id|imask
suffix:semicolon
multiline_comment|/* pdir IOV Space mask */
DECL|member|res_hint
r_int
r_int
op_star
id|res_hint
suffix:semicolon
multiline_comment|/* next avail IOVP - circular search */
DECL|member|dma_mask
r_int
r_int
id|dma_mask
suffix:semicolon
DECL|member|res_lock
id|spinlock_t
id|res_lock
suffix:semicolon
multiline_comment|/* protects the resource bitmap, but must be held when */
multiline_comment|/* clearing pdir to prevent races with allocations. */
DECL|member|res_bitshift
r_int
r_int
id|res_bitshift
suffix:semicolon
multiline_comment|/* from the RIGHT! */
DECL|member|res_size
r_int
r_int
id|res_size
suffix:semicolon
multiline_comment|/* size of resource map in bytes */
macro_line|#ifdef CONFIG_NUMA
DECL|member|node
r_int
r_int
id|node
suffix:semicolon
multiline_comment|/* node where this IOC lives */
macro_line|#endif
macro_line|#if DELAYED_RESOURCE_CNT &gt; 0
DECL|member|saved_lock
id|spinlock_t
id|saved_lock
suffix:semicolon
multiline_comment|/* may want to try to get this on a separate cacheline */
multiline_comment|/* than res_lock for bigger systems. */
DECL|member|saved_cnt
r_int
id|saved_cnt
suffix:semicolon
DECL|struct|sba_dma_pair
r_struct
id|sba_dma_pair
(brace
DECL|member|iova
id|dma_addr_t
id|iova
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|saved
)brace
id|saved
(braket
id|DELAYED_RESOURCE_CNT
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PDIR_SEARCH_TIMING
DECL|macro|SBA_SEARCH_SAMPLE
mdefine_line|#define SBA_SEARCH_SAMPLE&t;0x100
DECL|member|avg_search
r_int
r_int
id|avg_search
(braket
id|SBA_SEARCH_SAMPLE
)braket
suffix:semicolon
DECL|member|avg_idx
r_int
r_int
id|avg_idx
suffix:semicolon
multiline_comment|/* current index into avg_search */
macro_line|#endif
multiline_comment|/* Stuff we don&squot;t need in performance path */
DECL|member|next
r_struct
id|ioc
op_star
id|next
suffix:semicolon
multiline_comment|/* list of IOC&squot;s in system */
DECL|member|handle
id|acpi_handle
id|handle
suffix:semicolon
multiline_comment|/* for multiple IOC&squot;s */
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|func_id
r_int
r_int
id|func_id
suffix:semicolon
DECL|member|rev
r_int
r_int
id|rev
suffix:semicolon
multiline_comment|/* HW revision of chip */
DECL|member|iov_size
id|u32
id|iov_size
suffix:semicolon
DECL|member|pdir_size
r_int
r_int
id|pdir_size
suffix:semicolon
multiline_comment|/* in bytes, determined by IOV Space size */
DECL|member|sac_only_dev
r_struct
id|pci_dev
op_star
id|sac_only_dev
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ioc_list
r_static
r_struct
id|ioc
op_star
id|ioc_list
suffix:semicolon
DECL|variable|reserve_sba_gart
r_static
r_int
id|reserve_sba_gart
op_assign
l_int|1
suffix:semicolon
r_static
id|SBA_INLINE
r_void
id|sba_mark_invalid
c_func
(paren
r_struct
id|ioc
op_star
comma
id|dma_addr_t
comma
r_int
)paren
suffix:semicolon
r_static
id|SBA_INLINE
r_void
id|sba_free_range
c_func
(paren
r_struct
id|ioc
op_star
comma
id|dma_addr_t
comma
r_int
)paren
suffix:semicolon
DECL|macro|sba_sg_address
mdefine_line|#define sba_sg_address(sg)&t;(page_address((sg)-&gt;page) + (sg)-&gt;offset)
macro_line|#ifdef FULL_VALID_PDIR
DECL|variable|prefetch_spill_page
r_static
id|u64
id|prefetch_spill_page
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PCI
DECL|macro|GET_IOC
macro_line|# define GET_IOC(dev)&t;(((dev)-&gt;bus == &amp;pci_bus_type)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t; ? ((struct ioc *) PCI_CONTROLLER(to_pci_dev(dev))-&gt;iommu) : NULL)
macro_line|#else
DECL|macro|GET_IOC
macro_line|# define GET_IOC(dev)&t;NULL
macro_line|#endif
multiline_comment|/*&n;** DMA_CHUNK_SIZE is used by the SCSI mid-layer to break up&n;** (or rather not merge) DMA&squot;s into managable chunks.&n;** On parisc, this is more of the software/tuning constraint&n;** rather than the HW. I/O MMU allocation alogorithms can be&n;** faster with smaller size is (to some degree).&n;*/
DECL|macro|DMA_CHUNK_SIZE
mdefine_line|#define DMA_CHUNK_SIZE  (BITS_PER_LONG*iovp_size)
DECL|macro|ROUNDUP
mdefine_line|#define ROUNDUP(x,y) ((x + ((y)-1)) &amp; ~((y)-1))
multiline_comment|/************************************&n;** SBA register read and write support&n;**&n;** BE WARNED: register writes are posted.&n;**  (ie follow writes which must reach HW with a read)&n;**&n;*/
DECL|macro|READ_REG
mdefine_line|#define READ_REG(addr)       __raw_readq(addr)
DECL|macro|WRITE_REG
mdefine_line|#define WRITE_REG(val, addr) __raw_writeq(val, addr)
macro_line|#ifdef DEBUG_SBA_INIT
multiline_comment|/**&n; * sba_dump_tlb - debugging only - print IOMMU operating parameters&n; * @hpa: base address of the IOMMU&n; *&n; * Print the size/location of the IO MMU PDIR.&n; */
r_static
r_void
DECL|function|sba_dump_tlb
id|sba_dump_tlb
c_func
(paren
r_char
op_star
id|hpa
)paren
(brace
id|DBG_INIT
c_func
(paren
l_string|&quot;IO TLB at 0x%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|hpa
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;IOC_IBASE    : %016lx&bslash;n&quot;
comma
id|READ_REG
c_func
(paren
id|hpa
op_plus
id|IOC_IBASE
)paren
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;IOC_IMASK    : %016lx&bslash;n&quot;
comma
id|READ_REG
c_func
(paren
id|hpa
op_plus
id|IOC_IMASK
)paren
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;IOC_TCNFG    : %016lx&bslash;n&quot;
comma
id|READ_REG
c_func
(paren
id|hpa
op_plus
id|IOC_TCNFG
)paren
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;IOC_PDIR_BASE: %016lx&bslash;n&quot;
comma
id|READ_REG
c_func
(paren
id|hpa
op_plus
id|IOC_PDIR_BASE
)paren
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ASSERT_PDIR_SANITY
multiline_comment|/**&n; * sba_dump_pdir_entry - debugging only - print one IOMMU PDIR entry&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @msg: text to print ont the output line.&n; * @pide: pdir index.&n; *&n; * Print one entry of the IO MMU PDIR in human readable form.&n; */
r_static
r_void
DECL|function|sba_dump_pdir_entry
id|sba_dump_pdir_entry
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_char
op_star
id|msg
comma
id|uint
id|pide
)paren
(brace
multiline_comment|/* start printing from lowest pde in rval */
id|u64
op_star
id|ptr
op_assign
op_amp
id|ioc-&gt;pdir_base
(braket
id|pide
op_amp
op_complement
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_int
r_int
op_star
id|rptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|ioc-&gt;res_map
(braket
(paren
id|pide
op_rshift
l_int|3
)paren
op_amp
op_minus
r_sizeof
(paren
r_int
r_int
)paren
)braket
suffix:semicolon
id|uint
id|rcnt
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SBA: %s rp %p bit %d rval 0x%lx&bslash;n&quot;
comma
id|msg
comma
id|rptr
comma
id|pide
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
comma
op_star
id|rptr
)paren
suffix:semicolon
id|rcnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|rcnt
OL
id|BITS_PER_LONG
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s %2d %p %016Lx&bslash;n&quot;
comma
(paren
id|rcnt
op_eq
(paren
id|pide
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
)paren
)paren
ques
c_cond
l_string|&quot;    --&gt;&quot;
suffix:colon
l_string|&quot;       &quot;
comma
id|rcnt
comma
id|ptr
comma
(paren
r_int
r_int
r_int
)paren
op_star
id|ptr
)paren
suffix:semicolon
id|rcnt
op_increment
suffix:semicolon
id|ptr
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_check_pdir - debugging only - consistency checker&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @msg: text to print ont the output line.&n; *&n; * Verify the resource map and pdir state is consistent&n; */
r_static
r_int
DECL|function|sba_check_pdir
id|sba_check_pdir
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_char
op_star
id|msg
)paren
(brace
id|u64
op_star
id|rptr_end
op_assign
(paren
id|u64
op_star
)paren
op_amp
(paren
id|ioc-&gt;res_map
(braket
id|ioc-&gt;res_size
)braket
)paren
suffix:semicolon
id|u64
op_star
id|rptr
op_assign
(paren
id|u64
op_star
)paren
id|ioc-&gt;res_map
suffix:semicolon
multiline_comment|/* resource map ptr */
id|u64
op_star
id|pptr
op_assign
id|ioc-&gt;pdir_base
suffix:semicolon
multiline_comment|/* pdir ptr */
id|uint
id|pide
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|rptr
OL
id|rptr_end
)paren
(brace
id|u64
id|rval
suffix:semicolon
r_int
id|rcnt
suffix:semicolon
multiline_comment|/* number of bits we might check */
id|rval
op_assign
op_star
id|rptr
suffix:semicolon
id|rcnt
op_assign
l_int|64
suffix:semicolon
r_while
c_loop
(paren
id|rcnt
)paren
(brace
multiline_comment|/* Get last byte and highest bit from that */
id|u32
id|pde
op_assign
(paren
(paren
id|u32
)paren
(paren
(paren
op_star
id|pptr
op_rshift
(paren
l_int|63
)paren
)paren
op_amp
l_int|0x1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_amp
l_int|0x1
)paren
op_xor
id|pde
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** BUMMER!  -- res_map != pdir --&n;&t;&t;&t;&t;** Dump rval and matching pdir entries&n;&t;&t;&t;&t;*/
id|sba_dump_pdir_entry
c_func
(paren
id|ioc
comma
id|msg
comma
id|pide
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rcnt
op_decrement
suffix:semicolon
id|rval
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* try the next bit */
id|pptr
op_increment
suffix:semicolon
id|pide
op_increment
suffix:semicolon
)brace
id|rptr
op_increment
suffix:semicolon
multiline_comment|/* look at next word of res_map */
)brace
multiline_comment|/* It&squot;d be nice if we always got here :^) */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_dump_sg - debugging only - print Scatter-Gather list&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @startsg: head of the SG list&n; * @nents: number of entries in SG list&n; *&n; * print the SG list so we can verify it&squot;s correct by hand.&n; */
r_static
r_void
DECL|function|sba_dump_sg
id|sba_dump_sg
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
)paren
(brace
r_while
c_loop
(paren
id|nents
op_decrement
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; %d : DMA %08lx/%05x CPU %p&bslash;n&quot;
comma
id|nents
comma
id|startsg-&gt;dma_address
comma
id|startsg-&gt;dma_length
comma
id|sba_sg_address
c_func
(paren
id|startsg
)paren
)paren
suffix:semicolon
id|startsg
op_increment
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|sba_check_sg
id|sba_check_sg
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
)paren
(brace
r_struct
id|scatterlist
op_star
id|the_sg
op_assign
id|startsg
suffix:semicolon
r_int
id|the_nents
op_assign
id|nents
suffix:semicolon
r_while
c_loop
(paren
id|the_nents
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sba_sg_address
c_func
(paren
id|the_sg
)paren
op_eq
l_int|0x0UL
)paren
id|sba_dump_sg
c_func
(paren
l_int|NULL
comma
id|startsg
comma
id|nents
)paren
suffix:semicolon
id|the_sg
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif /* ASSERT_PDIR_SANITY */
multiline_comment|/**************************************************************&n;*&n;*   I/O Pdir Resource Management&n;*&n;*   Bits set in the resource map are in use.&n;*   Each bit can represent a number of pages.&n;*   LSbs represent lower addresses (IOVA&squot;s).&n;*&n;***************************************************************/
DECL|macro|PAGES_PER_RANGE
mdefine_line|#define PAGES_PER_RANGE 1&t;/* could increase this to 4 or 8 if needed */
multiline_comment|/* Convert from IOVP to IOVA and vice versa. */
DECL|macro|SBA_IOVA
mdefine_line|#define SBA_IOVA(ioc,iovp,offset) ((ioc-&gt;ibase) | (iovp) | (offset))
DECL|macro|SBA_IOVP
mdefine_line|#define SBA_IOVP(ioc,iova) ((iova) &amp; ~(ioc-&gt;ibase))
DECL|macro|PDIR_ENTRY_SIZE
mdefine_line|#define PDIR_ENTRY_SIZE&t;sizeof(u64)
DECL|macro|PDIR_INDEX
mdefine_line|#define PDIR_INDEX(iovp)   ((iovp)&gt;&gt;iovp_shift)
DECL|macro|RESMAP_MASK
mdefine_line|#define RESMAP_MASK(n)    ~(~0UL &lt;&lt; (n))
DECL|macro|RESMAP_IDX_MASK
mdefine_line|#define RESMAP_IDX_MASK   (sizeof(unsigned long) - 1)
multiline_comment|/**&n; * For most cases the normal get_order is sufficient, however it limits us&n; * to PAGE_SIZE being the minimum mapping alignment and TC flush granularity.&n; * It only incurs about 1 clock cycle to use this one with the static variable&n; * and makes the code more intuitive.&n; */
r_static
id|SBA_INLINE
r_int
DECL|function|get_iovp_order
id|get_iovp_order
(paren
r_int
r_int
id|size
)paren
(brace
r_int
r_float
id|d
op_assign
id|size
op_minus
l_int|1
suffix:semicolon
r_int
id|order
suffix:semicolon
id|order
op_assign
id|ia64_getf_exp
c_func
(paren
id|d
)paren
suffix:semicolon
id|order
op_assign
id|order
op_minus
id|iovp_shift
op_minus
l_int|0xffff
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
l_int|0
)paren
id|order
op_assign
l_int|0
suffix:semicolon
r_return
id|order
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_search_bitmap - find free space in IO PDIR resource bitmap&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @bits_wanted: number of entries we need.&n; *&n; * Find consecutive free bits in resource bitmap.&n; * Each bit represents one entry in the IO Pdir.&n; * Cool perf optimization: search for log2(size) bits at a time.&n; */
r_static
id|SBA_INLINE
r_int
r_int
DECL|function|sba_search_bitmap
id|sba_search_bitmap
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_int
r_int
id|bits_wanted
)paren
(brace
r_int
r_int
op_star
id|res_ptr
op_assign
id|ioc-&gt;res_hint
suffix:semicolon
r_int
r_int
op_star
id|res_end
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|ioc-&gt;res_map
(braket
id|ioc-&gt;res_size
)braket
)paren
suffix:semicolon
r_int
r_int
id|pide
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|ioc-&gt;res_hint
op_amp
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_minus
l_int|1UL
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|res_ptr
OL
id|res_end
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * N.B.  REO/Grande defect AR2305 can cause TLB fetch timeouts&n;&t; * if a TLB entry is purged while in use.  sba_mark_invalid()&n;&t; * purges IOTLB entries in power-of-two sizes, so we also&n;&t; * allocate IOVA space in power-of-two sizes.&n;&t; */
id|bits_wanted
op_assign
l_int|1UL
op_lshift
id|get_iovp_order
c_func
(paren
id|bits_wanted
op_lshift
id|iovp_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bits_wanted
op_eq
l_int|1
)paren
)paren
(brace
r_int
r_int
id|bitshiftcnt
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|res_ptr
OL
id|res_end
suffix:semicolon
id|res_ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_star
id|res_ptr
op_ne
op_complement
l_int|0UL
)paren
)paren
(brace
id|bitshiftcnt
op_assign
id|ffz
c_func
(paren
op_star
id|res_ptr
)paren
suffix:semicolon
op_star
id|res_ptr
op_or_assign
(paren
l_int|1UL
op_lshift
id|bitshiftcnt
)paren
suffix:semicolon
id|pide
op_assign
(paren
(paren
r_int
r_int
)paren
id|res_ptr
op_minus
(paren
r_int
r_int
)paren
id|ioc-&gt;res_map
)paren
suffix:semicolon
id|pide
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* convert to bit address */
id|pide
op_add_assign
id|bitshiftcnt
suffix:semicolon
id|ioc-&gt;res_bitshift
op_assign
id|bitshiftcnt
op_plus
id|bits_wanted
suffix:semicolon
r_goto
id|found_it
suffix:semicolon
)brace
)brace
r_goto
id|not_found
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bits_wanted
op_le
id|BITS_PER_LONG
op_div
l_int|2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;** Search the resource bit map on well-aligned values.&n;&t;&t;** &quot;o&quot; is the alignment.&n;&t;&t;** We need the alignment to invalidate I/O TLB using&n;&t;&t;** SBA HW features in the unmap path.&n;&t;&t;*/
r_int
r_int
id|o
op_assign
l_int|1
op_lshift
id|get_iovp_order
c_func
(paren
id|bits_wanted
op_lshift
id|iovp_shift
)paren
suffix:semicolon
id|uint
id|bitshiftcnt
op_assign
id|ROUNDUP
c_func
(paren
id|ioc-&gt;res_bitshift
comma
id|o
)paren
suffix:semicolon
r_int
r_int
id|mask
comma
id|base_mask
suffix:semicolon
id|base_mask
op_assign
id|RESMAP_MASK
c_func
(paren
id|bits_wanted
)paren
suffix:semicolon
id|mask
op_assign
id|base_mask
op_lshift
id|bitshiftcnt
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;%s() o %ld %p&quot;
comma
id|__FUNCTION__
comma
id|o
comma
id|res_ptr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|res_ptr
OL
id|res_end
suffix:semicolon
id|res_ptr
op_increment
)paren
(brace
id|DBG_RES
c_func
(paren
l_string|&quot;    %p %lx %lx&bslash;n&quot;
comma
id|res_ptr
comma
id|mask
comma
op_star
id|res_ptr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
op_ne
id|mask
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|mask
suffix:semicolon
id|mask
op_lshift_assign
id|o
comma
id|bitshiftcnt
op_add_assign
id|o
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
(paren
(paren
op_star
id|res_ptr
)paren
op_amp
id|mask
)paren
)paren
(brace
op_star
id|res_ptr
op_or_assign
id|mask
suffix:semicolon
multiline_comment|/* mark resources busy! */
id|pide
op_assign
(paren
(paren
r_int
r_int
)paren
id|res_ptr
op_minus
(paren
r_int
r_int
)paren
id|ioc-&gt;res_map
)paren
suffix:semicolon
id|pide
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* convert to bit address */
id|pide
op_add_assign
id|bitshiftcnt
suffix:semicolon
id|ioc-&gt;res_bitshift
op_assign
id|bitshiftcnt
op_plus
id|bits_wanted
suffix:semicolon
r_goto
id|found_it
suffix:semicolon
)brace
)brace
id|bitshiftcnt
op_assign
l_int|0
suffix:semicolon
id|mask
op_assign
id|base_mask
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|qwords
comma
id|bits
comma
id|i
suffix:semicolon
r_int
r_int
op_star
id|end
suffix:semicolon
id|qwords
op_assign
id|bits_wanted
op_rshift
l_int|6
suffix:semicolon
multiline_comment|/* /64 */
id|bits
op_assign
id|bits_wanted
op_minus
(paren
id|qwords
op_star
id|BITS_PER_LONG
)paren
suffix:semicolon
id|end
op_assign
id|res_end
op_minus
id|qwords
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|res_ptr
OL
id|end
suffix:semicolon
id|res_ptr
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qwords
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|res_ptr
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_goto
id|next_ptr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_logical_and
id|res_ptr
(braket
id|i
)braket
op_logical_and
(paren
id|__ffs
c_func
(paren
id|res_ptr
(braket
id|i
)braket
)paren
OL
id|bits
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Found it, mark it */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qwords
suffix:semicolon
id|i
op_increment
)paren
id|res_ptr
(braket
id|i
)braket
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|res_ptr
(braket
id|i
)braket
op_or_assign
id|RESMAP_MASK
c_func
(paren
id|bits
)paren
suffix:semicolon
id|pide
op_assign
(paren
(paren
r_int
r_int
)paren
id|res_ptr
op_minus
(paren
r_int
r_int
)paren
id|ioc-&gt;res_map
)paren
suffix:semicolon
id|pide
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* convert to bit address */
id|res_ptr
op_add_assign
id|qwords
suffix:semicolon
id|ioc-&gt;res_bitshift
op_assign
id|bits
suffix:semicolon
r_goto
id|found_it
suffix:semicolon
id|next_ptr
suffix:colon
suffix:semicolon
)brace
)brace
id|not_found
suffix:colon
id|prefetch
c_func
(paren
id|ioc-&gt;res_map
)paren
suffix:semicolon
id|ioc-&gt;res_hint
op_assign
(paren
r_int
r_int
op_star
)paren
id|ioc-&gt;res_map
suffix:semicolon
id|ioc-&gt;res_bitshift
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|pide
)paren
suffix:semicolon
id|found_it
suffix:colon
id|ioc-&gt;res_hint
op_assign
id|res_ptr
suffix:semicolon
r_return
(paren
id|pide
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_alloc_range - find free bits and mark them in IO PDIR resource bitmap&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @size: number of bytes to create a mapping for&n; *&n; * Given a size, find consecutive unmarked and then mark those bits in the&n; * resource bit map.&n; */
r_static
r_int
DECL|function|sba_alloc_range
id|sba_alloc_range
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|pages_needed
op_assign
id|size
op_rshift
id|iovp_shift
suffix:semicolon
macro_line|#ifdef PDIR_SEARCH_TIMING
r_int
r_int
id|itc_start
suffix:semicolon
macro_line|#endif
r_int
r_int
id|pide
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|pages_needed
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
op_eq
(paren
id|size
op_amp
op_complement
id|iovp_mask
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef PDIR_SEARCH_TIMING
id|itc_start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** &quot;seek and ye shall find&quot;...praying never hurts either...&n;&t;*/
id|pide
op_assign
id|sba_search_bitmap
c_func
(paren
id|ioc
comma
id|pages_needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pide
op_ge
(paren
id|ioc-&gt;res_size
op_lshift
l_int|3
)paren
)paren
)paren
(brace
id|pide
op_assign
id|sba_search_bitmap
c_func
(paren
id|ioc
comma
id|pages_needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pide
op_ge
(paren
id|ioc-&gt;res_size
op_lshift
l_int|3
)paren
)paren
)paren
(brace
macro_line|#if DELAYED_RESOURCE_CNT &gt; 0
multiline_comment|/*&n;&t;&t;&t;** With delayed resource freeing, we can give this one more shot.  We&squot;re&n;&t;&t;&t;** getting close to being in trouble here, so do what we can to make this&n;&t;&t;&t;** one count.&n;&t;&t;&t;*/
id|spin_lock
c_func
(paren
op_amp
id|ioc-&gt;saved_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;saved_cnt
OG
l_int|0
)paren
(brace
r_struct
id|sba_dma_pair
op_star
id|d
suffix:semicolon
r_int
id|cnt
op_assign
id|ioc-&gt;saved_cnt
suffix:semicolon
id|d
op_assign
op_amp
(paren
id|ioc-&gt;saved
(braket
id|ioc-&gt;saved_cnt
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
(brace
id|sba_mark_invalid
c_func
(paren
id|ioc
comma
id|d-&gt;iova
comma
id|d-&gt;size
)paren
suffix:semicolon
id|sba_free_range
c_func
(paren
id|ioc
comma
id|d-&gt;iova
comma
id|d-&gt;size
)paren
suffix:semicolon
id|d
op_decrement
suffix:semicolon
)brace
id|ioc-&gt;saved_cnt
op_assign
l_int|0
suffix:semicolon
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
multiline_comment|/* flush purges */
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ioc-&gt;saved_lock
)paren
suffix:semicolon
id|pide
op_assign
id|sba_search_bitmap
c_func
(paren
id|ioc
comma
id|pages_needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pide
op_ge
(paren
id|ioc-&gt;res_size
op_lshift
l_int|3
)paren
)paren
)paren
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;: I/O MMU @ %p is out of mapping resources&bslash;n&quot;
comma
id|ioc-&gt;ioc_hpa
)paren
suffix:semicolon
macro_line|#else
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;: I/O MMU @ %p is out of mapping resources&bslash;n&quot;
comma
id|ioc-&gt;ioc_hpa
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef PDIR_SEARCH_TIMING
id|ioc-&gt;avg_search
(braket
id|ioc-&gt;avg_idx
op_increment
)braket
op_assign
(paren
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|itc_start
)paren
op_div
id|pages_needed
suffix:semicolon
id|ioc-&gt;avg_idx
op_and_assign
id|SBA_SEARCH_SAMPLE
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|prefetchw
c_func
(paren
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|pide
)braket
)paren
)paren
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
multiline_comment|/* verify the first enable bit is clear */
r_if
c_cond
(paren
l_int|0x00
op_ne
(paren
(paren
id|u8
op_star
)paren
id|ioc-&gt;pdir_base
)paren
(braket
id|pide
op_star
id|PDIR_ENTRY_SIZE
op_plus
l_int|7
)braket
)paren
(brace
id|sba_dump_pdir_entry
c_func
(paren
id|ioc
comma
l_string|&quot;sba_search_bitmap() botched it?&quot;
comma
id|pide
)paren
suffix:semicolon
)brace
macro_line|#endif
id|DBG_RES
c_func
(paren
l_string|&quot;%s(%x) %d -&gt; %lx hint %x/%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|pages_needed
comma
id|pide
comma
(paren
id|uint
)paren
(paren
(paren
r_int
r_int
)paren
id|ioc-&gt;res_hint
op_minus
(paren
r_int
r_int
)paren
id|ioc-&gt;res_map
)paren
comma
id|ioc-&gt;res_bitshift
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|pide
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_free_range - unmark bits in IO PDIR resource bitmap&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @iova: IO virtual address which was previously allocated.&n; * @size: number of bytes to create a mapping for&n; *&n; * clear bits in the ioc&squot;s resource map&n; */
r_static
id|SBA_INLINE
r_void
DECL|function|sba_free_range
id|sba_free_range
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|dma_addr_t
id|iova
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|iovp
op_assign
id|SBA_IOVP
c_func
(paren
id|ioc
comma
id|iova
)paren
suffix:semicolon
r_int
r_int
id|pide
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
suffix:semicolon
r_int
r_int
id|ridx
op_assign
id|pide
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* convert bit to byte address */
r_int
r_int
op_star
id|res_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
(paren
id|ioc
)paren
op_member_access_from_pointer
id|res_map
(braket
id|ridx
op_amp
op_complement
id|RESMAP_IDX_MASK
)braket
)paren
suffix:semicolon
r_int
id|bits_not_wanted
op_assign
id|size
op_rshift
id|iovp_shift
suffix:semicolon
r_int
r_int
id|m
suffix:semicolon
multiline_comment|/* Round up to power-of-two size: see AR2305 note above */
id|bits_not_wanted
op_assign
l_int|1UL
op_lshift
id|get_iovp_order
c_func
(paren
id|bits_not_wanted
op_lshift
id|iovp_shift
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|bits_not_wanted
OG
l_int|0
suffix:semicolon
id|res_ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bits_not_wanted
OG
id|BITS_PER_LONG
)paren
)paren
(brace
multiline_comment|/* these mappings start 64bit aligned */
op_star
id|res_ptr
op_assign
l_int|0UL
suffix:semicolon
id|bits_not_wanted
op_sub_assign
id|BITS_PER_LONG
suffix:semicolon
id|pide
op_add_assign
id|BITS_PER_LONG
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 3-bits &quot;bit&quot; address plus 2 (or 3) bits for &quot;byte&quot; == bit in word */
id|m
op_assign
id|RESMAP_MASK
c_func
(paren
id|bits_not_wanted
)paren
op_lshift
(paren
id|pide
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|bits_not_wanted
op_assign
l_int|0
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;%s( ,%x,%x) %x/%lx %x %p %lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
id|uint
)paren
id|iova
comma
id|size
comma
id|bits_not_wanted
comma
id|m
comma
id|pide
comma
id|res_ptr
comma
op_star
id|res_ptr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|m
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bits_not_wanted
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
op_star
id|res_ptr
op_amp
id|m
)paren
op_eq
id|m
)paren
suffix:semicolon
multiline_comment|/* verify same bits are set */
op_star
id|res_ptr
op_and_assign
op_complement
id|m
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**************************************************************&n;*&n;*   &quot;Dynamic DMA Mapping&quot; support (aka &quot;Coherent I/O&quot;)&n;*&n;***************************************************************/
multiline_comment|/**&n; * sba_io_pdir_entry - fill in one IO PDIR entry&n; * @pdir_ptr:  pointer to IO PDIR entry&n; * @vba: Virtual CPU address of buffer to map&n; *&n; * SBA Mapping Routine&n; *&n; * Given a virtual address (vba, arg1) sba_io_pdir_entry()&n; * loads the I/O PDIR entry pointed to by pdir_ptr (arg0).&n; * Each IO Pdir entry consists of 8 bytes as shown below&n; * (LSB == bit 0):&n; *&n; *  63                    40                                 11    7        0&n; * +-+---------------------+----------------------------------+----+--------+&n; * |V|        U            |            PPN[39:12]            | U  |   FF   |&n; * +-+---------------------+----------------------------------+----+--------+&n; *&n; *  V  == Valid Bit&n; *  U  == Unused&n; * PPN == Physical Page Number&n; *&n; * The physical address fields are filled with the results of virt_to_phys()&n; * on the vba.&n; */
macro_line|#if 1
DECL|macro|sba_io_pdir_entry
mdefine_line|#define sba_io_pdir_entry(pdir_ptr, vba) *pdir_ptr = ((vba &amp; ~0xE000000000000FFFULL)&t;&bslash;&n;&t;&t;&t;&t;&t;&t;      | 0x8000000000000000ULL)
macro_line|#else
r_void
id|SBA_INLINE
DECL|function|sba_io_pdir_entry
id|sba_io_pdir_entry
c_func
(paren
id|u64
op_star
id|pdir_ptr
comma
r_int
r_int
id|vba
)paren
(brace
op_star
id|pdir_ptr
op_assign
(paren
(paren
id|vba
op_amp
op_complement
l_int|0xE000000000000FFFULL
)paren
op_or
l_int|0x80000000000000FFULL
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ENABLE_MARK_CLEAN
multiline_comment|/**&n; * Since DMA is i-cache coherent, any (complete) pages that were written via&n; * DMA can be marked as &quot;clean&quot; so that update_mmu_cache() doesn&squot;t have to&n; * flush them when they get mapped into an executable vm-area.&n; */
r_static
r_void
DECL|function|mark_clean
id|mark_clean
(paren
r_void
op_star
id|addr
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|pg_addr
comma
id|end
suffix:semicolon
id|pg_addr
op_assign
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
id|end
op_assign
(paren
r_int
r_int
)paren
id|addr
op_plus
id|size
suffix:semicolon
r_while
c_loop
(paren
id|pg_addr
op_plus
id|PAGE_SIZE
op_le
id|end
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|pg_addr
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_arch_1
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|pg_addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/**&n; * sba_mark_invalid - invalidate one or more IO PDIR entries&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @iova:  IO Virtual Address mapped earlier&n; * @byte_cnt:  number of bytes this mapping covers.&n; *&n; * Marking the IO PDIR entry(ies) as Invalid and invalidate&n; * corresponding IO TLB entry. The PCOM (Purge Command Register)&n; * is to purge stale entries in the IO TLB when unmapping entries.&n; *&n; * The PCOM register supports purging of multiple pages, with a minium&n; * of 1 page and a maximum of 2GB. Hardware requires the address be&n; * aligned to the size of the range being purged. The size of the range&n; * must be a power of 2. The &quot;Cool perf optimization&quot; in the&n; * allocation routine helps keep that true.&n; */
r_static
id|SBA_INLINE
r_void
DECL|function|sba_mark_invalid
id|sba_mark_invalid
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|dma_addr_t
id|iova
comma
r_int
id|byte_cnt
)paren
(brace
id|u32
id|iovp
op_assign
(paren
id|u32
)paren
id|SBA_IOVP
c_func
(paren
id|ioc
comma
id|iova
)paren
suffix:semicolon
r_int
id|off
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
suffix:semicolon
multiline_comment|/* Must be non-zero and rounded up */
id|ASSERT
c_func
(paren
id|byte_cnt
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
op_eq
(paren
id|byte_cnt
op_amp
op_complement
id|iovp_mask
)paren
)paren
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
multiline_comment|/* Assert first pdir entry is set */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_rshift
l_int|60
)paren
)paren
(brace
id|sba_dump_pdir_entry
c_func
(paren
id|ioc
comma
l_string|&quot;sba_mark_invalid()&quot;
comma
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|byte_cnt
op_le
id|iovp_size
)paren
(brace
id|ASSERT
c_func
(paren
id|off
OL
id|ioc-&gt;pdir_size
)paren
suffix:semicolon
id|iovp
op_or_assign
id|iovp_shift
suffix:semicolon
multiline_comment|/* set &quot;size&quot; field for PCOM */
macro_line|#ifndef FULL_VALID_PDIR
multiline_comment|/*&n;&t;&t;** clear I/O PDIR entry &quot;valid&quot; bit&n;&t;&t;** Do NOT clear the rest - save it for debugging.&n;&t;&t;** We should only clear bits that have previously&n;&t;&t;** been enabled.&n;&t;&t;*/
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_and_assign
op_complement
(paren
l_int|0x80000000000000FFULL
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;  &t;&t;** If we want to maintain the PDIR as valid, put in&n;&t;&t;** the spill page so devices prefetching won&squot;t&n;&t;&t;** cause a hard fail.&n;&t;&t;*/
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_assign
(paren
l_int|0x80000000000000FFULL
op_or
id|prefetch_spill_page
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|u32
id|t
op_assign
id|get_iovp_order
c_func
(paren
id|byte_cnt
)paren
op_plus
id|iovp_shift
suffix:semicolon
id|iovp
op_or_assign
id|t
suffix:semicolon
id|ASSERT
c_func
(paren
id|t
op_le
l_int|31
)paren
suffix:semicolon
multiline_comment|/* 2GB! Max value of &quot;size&quot; field */
r_do
(brace
multiline_comment|/* verify this pdir entry is enabled */
id|ASSERT
c_func
(paren
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_rshift
l_int|63
)paren
suffix:semicolon
macro_line|#ifndef FULL_VALID_PDIR
multiline_comment|/* clear I/O Pdir entry &quot;valid&quot; bit first */
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_and_assign
op_complement
(paren
l_int|0x80000000000000FFULL
)paren
suffix:semicolon
macro_line|#else
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_assign
(paren
l_int|0x80000000000000FFULL
op_or
id|prefetch_spill_page
)paren
suffix:semicolon
macro_line|#endif
id|off
op_increment
suffix:semicolon
id|byte_cnt
op_sub_assign
id|iovp_size
suffix:semicolon
)brace
r_while
c_loop
(paren
id|byte_cnt
OG
l_int|0
)paren
suffix:semicolon
)brace
id|WRITE_REG
c_func
(paren
id|iovp
op_or
id|ioc-&gt;ibase
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_map_single - map one buffer and return IOVA for DMA&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @addr:  driver buffer to map.&n; * @size:  number of bytes to map in driver buffer.&n; * @dir:  R/W or both.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
id|dma_addr_t
DECL|function|sba_map_single
id|sba_map_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
id|dma_addr_t
id|iovp
suffix:semicolon
id|dma_addr_t
id|offset
suffix:semicolon
id|u64
op_star
id|pdir_start
suffix:semicolon
r_int
id|pide
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ALLOW_IOV_BYPASS
r_int
r_int
id|pci_addr
op_assign
id|virt_to_phys
c_func
(paren
id|addr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ALLOW_IOV_BYPASS
id|ASSERT
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dma_mask
)paren
suffix:semicolon
multiline_comment|/*&n; &t;** Check if the PCI device can DMA to ptr... if so, just return ptr&n; &t;*/
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|pci_addr
op_amp
op_complement
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dma_mask
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n; &t;&t;** Device is bit capable of DMA&squot;ing to the buffer...&n;&t;&t;** just return the PCI address of ptr&n; &t;&t;*/
id|DBG_BYPASS
c_func
(paren
l_string|&quot;sba_map_single() bypass mask/addr: 0x%lx/0x%lx&bslash;n&quot;
comma
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dma_mask
comma
id|pci_addr
)paren
suffix:semicolon
r_return
id|pci_addr
suffix:semicolon
)brace
macro_line|#endif
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|prefetch
c_func
(paren
id|ioc-&gt;res_hint
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|size
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|size
op_le
id|DMA_CHUNK_SIZE
)paren
suffix:semicolon
multiline_comment|/* save offset bits */
id|offset
op_assign
(paren
(paren
id|dma_addr_t
)paren
(paren
r_int
)paren
id|addr
)paren
op_amp
op_complement
id|iovp_mask
suffix:semicolon
multiline_comment|/* round up to nearest iovp_size */
id|size
op_assign
(paren
id|size
op_plus
id|offset
op_plus
op_complement
id|iovp_mask
)paren
op_amp
id|iovp_mask
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check before sba_map_single()&quot;
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Sanity check failed&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|pide
op_assign
id|sba_alloc_range
c_func
(paren
id|ioc
comma
id|size
)paren
suffix:semicolon
id|iovp
op_assign
(paren
id|dma_addr_t
)paren
id|pide
op_lshift
id|iovp_shift
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot;%s() 0x%p -&gt; 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|addr
comma
(paren
r_int
)paren
id|iovp
op_or
id|offset
)paren
suffix:semicolon
id|pdir_start
op_assign
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|pide
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
(paren
(paren
id|u8
op_star
)paren
id|pdir_start
)paren
(braket
l_int|7
)braket
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* verify availability */
id|sba_io_pdir_entry
c_func
(paren
id|pdir_start
comma
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot;     pdir 0x%p %lx&bslash;n&quot;
comma
id|pdir_start
comma
op_star
id|pdir_start
)paren
suffix:semicolon
id|addr
op_add_assign
id|iovp_size
suffix:semicolon
id|size
op_sub_assign
id|iovp_size
suffix:semicolon
id|pdir_start
op_increment
suffix:semicolon
)brace
multiline_comment|/* force pdir update */
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* form complete address */
macro_line|#ifdef ASSERT_PDIR_SANITY
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check after sba_map_single()&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SBA_IOVA
c_func
(paren
id|ioc
comma
id|iovp
comma
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_unmap_single - unmap one IOVA and free resources&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @iova:  IOVA of driver buffer previously mapped.&n; * @size:  number of bytes mapped in driver buffer.&n; * @dir:  R/W or both.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
DECL|function|sba_unmap_single
r_void
id|sba_unmap_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|iova
comma
r_int
id|size
comma
r_int
id|dir
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
macro_line|#if DELAYED_RESOURCE_CNT &gt; 0
r_struct
id|sba_dma_pair
op_star
id|d
suffix:semicolon
macro_line|#endif
r_int
r_int
id|flags
suffix:semicolon
id|dma_addr_t
id|offset
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc
)paren
suffix:semicolon
macro_line|#ifdef ALLOW_IOV_BYPASS
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|iova
op_amp
id|ioc-&gt;imask
)paren
op_ne
id|ioc-&gt;ibase
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;** Address does not fall w/in IOVA, must be bypassing&n;&t;&t;*/
id|DBG_BYPASS
c_func
(paren
l_string|&quot;sba_unmap_single() bypass addr: 0x%lx&bslash;n&quot;
comma
id|iova
)paren
suffix:semicolon
macro_line|#ifdef ENABLE_MARK_CLEAN
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
(brace
id|mark_clean
c_func
(paren
id|phys_to_virt
c_func
(paren
id|iova
)paren
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
macro_line|#endif
id|offset
op_assign
id|iova
op_amp
op_complement
id|iovp_mask
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot;%s() iovp 0x%lx/%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_int
)paren
id|iova
comma
id|size
)paren
suffix:semicolon
id|iova
op_xor_assign
id|offset
suffix:semicolon
multiline_comment|/* clear offset bits */
id|size
op_add_assign
id|offset
suffix:semicolon
id|size
op_assign
id|ROUNDUP
c_func
(paren
id|size
comma
id|iovp_size
)paren
suffix:semicolon
macro_line|#if DELAYED_RESOURCE_CNT &gt; 0
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;saved_lock
comma
id|flags
)paren
suffix:semicolon
id|d
op_assign
op_amp
(paren
id|ioc-&gt;saved
(braket
id|ioc-&gt;saved_cnt
)braket
)paren
suffix:semicolon
id|d-&gt;iova
op_assign
id|iova
suffix:semicolon
id|d-&gt;size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_increment
(paren
id|ioc-&gt;saved_cnt
)paren
op_ge
id|DELAYED_RESOURCE_CNT
)paren
)paren
(brace
r_int
id|cnt
op_assign
id|ioc-&gt;saved_cnt
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ioc-&gt;res_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
(brace
id|sba_mark_invalid
c_func
(paren
id|ioc
comma
id|d-&gt;iova
comma
id|d-&gt;size
)paren
suffix:semicolon
id|sba_free_range
c_func
(paren
id|ioc
comma
id|d-&gt;iova
comma
id|d-&gt;size
)paren
suffix:semicolon
id|d
op_decrement
suffix:semicolon
)brace
id|ioc-&gt;saved_cnt
op_assign
l_int|0
suffix:semicolon
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
multiline_comment|/* flush purges */
id|spin_unlock
c_func
(paren
op_amp
id|ioc-&gt;res_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;saved_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#else /* DELAYED_RESOURCE_CNT == 0 */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
id|sba_mark_invalid
c_func
(paren
id|ioc
comma
id|iova
comma
id|size
)paren
suffix:semicolon
id|sba_free_range
c_func
(paren
id|ioc
comma
id|iova
comma
id|size
)paren
suffix:semicolon
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
multiline_comment|/* flush purges */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif /* DELAYED_RESOURCE_CNT == 0 */
macro_line|#ifdef ENABLE_MARK_CLEAN
r_if
c_cond
(paren
id|dir
op_eq
id|DMA_FROM_DEVICE
)paren
(brace
id|u32
id|iovp
op_assign
(paren
id|u32
)paren
id|SBA_IOVP
c_func
(paren
id|ioc
comma
id|iova
)paren
suffix:semicolon
r_int
id|off
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
id|iovp_size
)paren
(brace
id|addr
op_assign
id|phys_to_virt
c_func
(paren
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_amp
op_complement
l_int|0xE000000000000FFFULL
)paren
suffix:semicolon
id|mark_clean
c_func
(paren
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|byte_cnt
op_assign
id|size
suffix:semicolon
r_do
(brace
id|addr
op_assign
id|phys_to_virt
c_func
(paren
id|ioc-&gt;pdir_base
(braket
id|off
)braket
op_amp
op_complement
l_int|0xE000000000000FFFULL
)paren
suffix:semicolon
id|mark_clean
c_func
(paren
id|addr
comma
id|min
c_func
(paren
id|byte_cnt
comma
id|iovp_size
)paren
)paren
suffix:semicolon
id|off
op_increment
suffix:semicolon
id|byte_cnt
op_sub_assign
id|iovp_size
suffix:semicolon
)brace
r_while
c_loop
(paren
id|byte_cnt
OG
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/**&n; * sba_alloc_coherent - allocate/map shared mem for DMA&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @size:  number of bytes mapped in driver buffer.&n; * @dma_handle:  IOVA of new buffer.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
r_void
op_star
DECL|function|sba_alloc_coherent
id|sba_alloc_coherent
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
comma
r_int
id|flags
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|alloc_pages_node
c_func
(paren
id|ioc-&gt;node
op_eq
id|MAX_NUMNODES
ques
c_cond
id|numa_node_id
c_func
(paren
)paren
suffix:colon
id|ioc-&gt;node
comma
id|flags
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|addr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
macro_line|#else
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|addr
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
op_star
id|dma_handle
op_assign
id|virt_to_phys
c_func
(paren
id|addr
)paren
suffix:semicolon
macro_line|#ifdef ALLOW_IOV_BYPASS
id|ASSERT
c_func
(paren
id|dev-&gt;coherent_dma_mask
)paren
suffix:semicolon
multiline_comment|/*&n; &t;** Check if the PCI device can DMA to ptr... if so, just return ptr&n; &t;*/
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
op_star
id|dma_handle
op_amp
op_complement
id|dev-&gt;coherent_dma_mask
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|DBG_BYPASS
c_func
(paren
l_string|&quot;sba_alloc_coherent() bypass mask/addr: 0x%lx/0x%lx&bslash;n&quot;
comma
id|dev-&gt;coherent_dma_mask
comma
op_star
id|dma_handle
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If device can&squot;t bypass or bypass is disabled, pass the 32bit fake&n;&t; * device to map single to get an iova mapping.&n;&t; */
op_star
id|dma_handle
op_assign
id|sba_map_single
c_func
(paren
op_amp
id|ioc-&gt;sac_only_dev-&gt;dev
comma
id|addr
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_free_coherent - free/unmap shared mem for DMA&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @size:  number of bytes mapped in driver buffer.&n; * @vaddr:  virtual address IOVA of &quot;consistent&quot; buffer.&n; * @dma_handler:  IO virtual address of &quot;consistent&quot; buffer.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
DECL|function|sba_free_coherent
r_void
id|sba_free_coherent
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
id|sba_unmap_single
c_func
(paren
id|dev
comma
id|dma_handle
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Since 0 is a valid pdir_base index value, can&squot;t use that&n;** to determine if a value is valid or not. Use a flag to indicate&n;** the SG list entry contains a valid pdir index.&n;*/
DECL|macro|PIDE_FLAG
mdefine_line|#define PIDE_FLAG 0x1UL
macro_line|#ifdef DEBUG_LARGE_SG_ENTRIES
DECL|variable|dump_run_sg
r_int
id|dump_run_sg
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * sba_fill_pdir - write allocated SG entries into IO PDIR&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @startsg:  list of IOVA/size pairs&n; * @nents: number of entries in startsg list&n; *&n; * Take preprocessed SG list and write corresponding entries&n; * in the IO PDIR.&n; */
r_static
id|SBA_INLINE
r_int
DECL|function|sba_fill_pdir
id|sba_fill_pdir
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
op_assign
id|startsg
suffix:semicolon
multiline_comment|/* pointer to current DMA */
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
id|u64
op_star
id|pdirp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|dma_offset
op_assign
l_int|0
suffix:semicolon
id|dma_sg
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|nents
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|cnt
op_assign
id|startsg-&gt;dma_length
suffix:semicolon
id|startsg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_LARGE_SG_ENTRIES
r_if
c_cond
(paren
id|dump_run_sg
)paren
id|printk
c_func
(paren
l_string|&quot; %2d : %08lx/%05x %p&bslash;n&quot;
comma
id|nents
comma
id|startsg-&gt;dma_address
comma
id|cnt
comma
id|sba_sg_address
c_func
(paren
id|startsg
)paren
)paren
suffix:semicolon
macro_line|#else
id|DBG_RUN_SG
c_func
(paren
l_string|&quot; %d : %08lx/%05x %p&bslash;n&quot;
comma
id|nents
comma
id|startsg-&gt;dma_address
comma
id|cnt
comma
id|sba_sg_address
c_func
(paren
id|startsg
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;** Look for the start of a new DMA stream&n;&t;&t;*/
r_if
c_cond
(paren
id|startsg-&gt;dma_address
op_amp
id|PIDE_FLAG
)paren
(brace
id|u32
id|pide
op_assign
id|startsg-&gt;dma_address
op_amp
op_complement
id|PIDE_FLAG
suffix:semicolon
id|dma_offset
op_assign
(paren
r_int
r_int
)paren
id|pide
op_amp
op_complement
id|iovp_mask
suffix:semicolon
id|startsg-&gt;dma_address
op_assign
l_int|0
suffix:semicolon
id|dma_sg
op_increment
suffix:semicolon
id|dma_sg-&gt;dma_address
op_assign
id|pide
op_or
id|ioc-&gt;ibase
suffix:semicolon
id|pdirp
op_assign
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|pide
op_rshift
id|iovp_shift
)braket
)paren
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Look for a VCONTIG chunk&n;&t;&t;*/
r_if
c_cond
(paren
id|cnt
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|sba_sg_address
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pdirp
)paren
suffix:semicolon
multiline_comment|/* Since multiple Vcontig blocks could make up&n;&t;&t;&t;** one DMA stream, *add* cnt to dma_len.&n;&t;&t;&t;*/
id|dma_sg-&gt;dma_length
op_add_assign
id|cnt
suffix:semicolon
id|cnt
op_add_assign
id|dma_offset
suffix:semicolon
id|dma_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only want offset on first chunk */
id|cnt
op_assign
id|ROUNDUP
c_func
(paren
id|cnt
comma
id|iovp_size
)paren
suffix:semicolon
r_do
(brace
id|sba_io_pdir_entry
c_func
(paren
id|pdirp
comma
id|vaddr
)paren
suffix:semicolon
id|vaddr
op_add_assign
id|iovp_size
suffix:semicolon
id|cnt
op_sub_assign
id|iovp_size
suffix:semicolon
id|pdirp
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cnt
OG
l_int|0
)paren
suffix:semicolon
)brace
id|startsg
op_increment
suffix:semicolon
)brace
multiline_comment|/* force pdir update */
id|wmb
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_LARGE_SG_ENTRIES
id|dump_run_sg
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
id|n_mappings
suffix:semicolon
)brace
multiline_comment|/*&n;** Two address ranges are DMA contiguous *iff* &quot;end of prev&quot; and&n;** &quot;start of next&quot; are both on an IOV page boundary.&n;**&n;** (shift left is a quick trick to mask off upper bits)&n;*/
DECL|macro|DMA_CONTIG
mdefine_line|#define DMA_CONTIG(__X, __Y) &bslash;&n;&t;(((((unsigned long) __X) | ((unsigned long) __Y)) &lt;&lt; (BITS_PER_LONG - iovp_shift)) == 0UL)
multiline_comment|/**&n; * sba_coalesce_chunks - preprocess the SG list&n; * @ioc: IO MMU structure which owns the pdir we are interested in.&n; * @startsg:  list of IOVA/size pairs&n; * @nents: number of entries in startsg list&n; *&n; * First pass is to walk the SG list and determine where the breaks are&n; * in the DMA stream. Allocates PDIR entries but does not fill them.&n; * Returns the number of DMA chunks.&n; *&n; * Doing the fill separate from the coalescing/allocation keeps the&n; * code simpler. Future enhancement could make one pass through&n; * the sglist do both.&n; */
r_static
id|SBA_INLINE
r_int
DECL|function|sba_coalesce_chunks
id|sba_coalesce_chunks
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
)paren
(brace
r_struct
id|scatterlist
op_star
id|vcontig_sg
suffix:semicolon
multiline_comment|/* VCONTIG chunk head */
r_int
r_int
id|vcontig_len
suffix:semicolon
multiline_comment|/* len of VCONTIG chunk */
r_int
r_int
id|vcontig_end
suffix:semicolon
r_struct
id|scatterlist
op_star
id|dma_sg
suffix:semicolon
multiline_comment|/* next DMA stream head */
r_int
r_int
id|dma_offset
comma
id|dma_len
suffix:semicolon
multiline_comment|/* start/len of DMA stream */
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nents
OG
l_int|0
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|sba_sg_address
c_func
(paren
id|startsg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Prepare for first/next DMA stream&n;&t;&t;*/
id|dma_sg
op_assign
id|vcontig_sg
op_assign
id|startsg
suffix:semicolon
id|dma_len
op_assign
id|vcontig_len
op_assign
id|vcontig_end
op_assign
id|startsg-&gt;length
suffix:semicolon
id|vcontig_end
op_add_assign
id|vaddr
suffix:semicolon
id|dma_offset
op_assign
id|vaddr
op_amp
op_complement
id|iovp_mask
suffix:semicolon
multiline_comment|/* PARANOID: clear entries */
id|startsg-&gt;dma_address
op_assign
id|startsg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;** This loop terminates one iteration &quot;early&quot; since&n;&t;&t;** it&squot;s always looking one &quot;ahead&quot;.&n;&t;&t;*/
r_while
c_loop
(paren
op_decrement
id|nents
OG
l_int|0
)paren
(brace
r_int
r_int
id|vaddr
suffix:semicolon
multiline_comment|/* tmp */
id|startsg
op_increment
suffix:semicolon
multiline_comment|/* PARANOID */
id|startsg-&gt;dma_address
op_assign
id|startsg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* catch brokenness in SCSI layer */
id|ASSERT
c_func
(paren
id|startsg-&gt;length
op_le
id|DMA_CHUNK_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** First make sure current dma stream won&squot;t&n;&t;&t;&t;** exceed DMA_CHUNK_SIZE if we coalesce the&n;&t;&t;&t;** next entry.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
(paren
id|dma_len
op_plus
id|dma_offset
op_plus
id|startsg-&gt;length
op_plus
op_complement
id|iovp_mask
)paren
op_amp
id|iovp_mask
)paren
OG
id|DMA_CHUNK_SIZE
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Then look for virtually contiguous blocks.&n;&t;&t;&t;**&n;&t;&t;&t;** append the next transaction?&n;&t;&t;&t;*/
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|sba_sg_address
c_func
(paren
id|startsg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcontig_end
op_eq
id|vaddr
)paren
(brace
id|vcontig_len
op_add_assign
id|startsg-&gt;length
suffix:semicolon
id|vcontig_end
op_add_assign
id|startsg-&gt;length
suffix:semicolon
id|dma_len
op_add_assign
id|startsg-&gt;length
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_LARGE_SG_ENTRIES
id|dump_run_sg
op_assign
(paren
id|vcontig_len
OG
id|iovp_size
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;** Not virtually contigous.&n;&t;&t;&t;** Terminate prev chunk.&n;&t;&t;&t;** Start a new chunk.&n;&t;&t;&t;**&n;&t;&t;&t;** Once we start a new VCONTIG chunk, dma_offset&n;&t;&t;&t;** can&squot;t change. And we need the offset from the first&n;&t;&t;&t;** chunk - not the last one. Ergo Successive chunks&n;&t;&t;&t;** must start on page boundaries and dove tail&n;&t;&t;&t;** with it&squot;s predecessor.&n;&t;&t;&t;*/
id|vcontig_sg-&gt;dma_length
op_assign
id|vcontig_len
suffix:semicolon
id|vcontig_sg
op_assign
id|startsg
suffix:semicolon
id|vcontig_len
op_assign
id|startsg-&gt;length
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** 3) do the entries end/start on page boundaries?&n;&t;&t;&t;**    Don&squot;t update vcontig_end until we&squot;ve checked.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|DMA_CONTIG
c_func
(paren
id|vcontig_end
comma
id|vaddr
)paren
)paren
(brace
id|vcontig_end
op_assign
id|vcontig_len
op_plus
id|vaddr
suffix:semicolon
id|dma_len
op_add_assign
id|vcontig_len
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;** End of DMA Stream&n;&t;&t;** Terminate last VCONTIG block.&n;&t;&t;** Allocate space for DMA stream.&n;&t;&t;*/
id|vcontig_sg-&gt;dma_length
op_assign
id|vcontig_len
suffix:semicolon
id|dma_len
op_assign
(paren
id|dma_len
op_plus
id|dma_offset
op_plus
op_complement
id|iovp_mask
)paren
op_amp
id|iovp_mask
suffix:semicolon
id|ASSERT
c_func
(paren
id|dma_len
op_le
id|DMA_CHUNK_SIZE
)paren
suffix:semicolon
id|dma_sg-&gt;dma_address
op_assign
(paren
id|dma_addr_t
)paren
(paren
id|PIDE_FLAG
op_or
(paren
id|sba_alloc_range
c_func
(paren
id|ioc
comma
id|dma_len
)paren
op_lshift
id|iovp_shift
)paren
op_or
id|dma_offset
)paren
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
)brace
r_return
id|n_mappings
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_map_sg - map Scatter/Gather list&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @sglist:  array of buffer/length pairs&n; * @nents:  number of entries in list&n; * @dir:  R/W or both.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
DECL|function|sba_map_sg
r_int
id|sba_map_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_int
id|dir
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_int
id|coalesced
comma
id|filled
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ALLOW_IOV_BYPASS_SG
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
macro_line|#endif
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() START %d entries&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
)paren
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc
)paren
suffix:semicolon
macro_line|#ifdef ALLOW_IOV_BYPASS_SG
id|ASSERT
c_func
(paren
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dma_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|ioc-&gt;dma_mask
op_amp
op_complement
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dma_mask
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|sg
op_assign
id|sglist
suffix:semicolon
id|filled
OL
id|nents
suffix:semicolon
id|filled
op_increment
comma
id|sg
op_increment
)paren
(brace
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
id|sg-&gt;dma_address
op_assign
id|virt_to_phys
c_func
(paren
id|sba_sg_address
c_func
(paren
id|sg
)paren
)paren
suffix:semicolon
)brace
r_return
id|filled
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Fast path single entry scatterlists. */
r_if
c_cond
(paren
id|nents
op_eq
l_int|1
)paren
(brace
id|sglist-&gt;dma_length
op_assign
id|sglist-&gt;length
suffix:semicolon
id|sglist-&gt;dma_address
op_assign
id|sba_map_single
c_func
(paren
id|dev
comma
id|sba_sg_address
c_func
(paren
id|sglist
)paren
comma
id|sglist-&gt;length
comma
id|dir
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef ASSERT_PDIR_SANITY
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check before sba_map_sg()&quot;
)paren
)paren
(brace
id|sba_dump_sg
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Check before sba_map_sg()&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|prefetch
c_func
(paren
id|ioc-&gt;res_hint
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** First coalesce the chunks and allocate I/O pdir space&n;&t;**&n;&t;** If this is one DMA stream, we can properly map using the&n;&t;** correct virtual address associated with each DMA page.&n;&t;** w/o this association, we wouldn&squot;t have coherent DMA!&n;&t;** Access to the virtual address is what forces a two pass algorithm.&n;&t;*/
id|coalesced
op_assign
id|sba_coalesce_chunks
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Program the I/O Pdir&n;&t;**&n;&t;** map the virtual addresses to the I/O Pdir&n;&t;** o dma_address will contain the pdir index&n;&t;** o dma_len will contain the number of bytes to map&n;&t;** o address contains the virtual address.&n;&t;*/
id|filled
op_assign
id|sba_fill_pdir
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
)paren
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check after sba_map_sg()&quot;
)paren
)paren
(brace
id|sba_dump_sg
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Check after sba_map_sg()&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|coalesced
op_eq
id|filled
)paren
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() DONE %d mappings&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|filled
)paren
suffix:semicolon
r_return
id|filled
suffix:semicolon
)brace
multiline_comment|/**&n; * sba_unmap_sg - unmap Scatter/Gather list&n; * @dev: instance of PCI owned by the driver that&squot;s asking.&n; * @sglist:  array of buffer/length pairs&n; * @nents:  number of entries in list&n; * @dir:  R/W or both.&n; *&n; * See Documentation/DMA-mapping.txt&n; */
DECL|function|sba_unmap_sg
r_void
id|sba_unmap_sg
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_int
id|dir
)paren
(brace
macro_line|#ifdef ASSERT_PDIR_SANITY
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() START %d entries,  %p,%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
comma
id|sba_sg_address
c_func
(paren
id|sglist
)paren
comma
id|sglist-&gt;length
)paren
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check before sba_unmap_sg()&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|nents
op_logical_and
id|sglist-&gt;dma_length
)paren
(brace
id|sba_unmap_single
c_func
(paren
id|dev
comma
id|sglist-&gt;dma_address
comma
id|sglist-&gt;dma_length
comma
id|dir
)paren
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
id|nents
op_decrement
suffix:semicolon
)brace
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() DONE (nents %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
)paren
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
id|sba_check_pdir
c_func
(paren
id|ioc
comma
l_string|&quot;Check after sba_unmap_sg()&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**************************************************************&n;*&n;*   Initialization and claim&n;*&n;***************************************************************/
r_static
r_void
id|__init
DECL|function|ioc_iova_init
id|ioc_iova_init
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
r_int
id|tcnfg
suffix:semicolon
r_int
id|agp_found
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef FULL_VALID_PDIR
r_int
r_int
id|index
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** Firmware programs the base and size of a &quot;safe IOVA space&quot;&n;&t;** (one that doesn&squot;t overlap memory or LMMIO space) in the&n;&t;** IBASE and IMASK registers.&n;&t;*/
id|ioc-&gt;ibase
op_assign
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_IBASE
)paren
op_amp
op_complement
l_int|0x1UL
suffix:semicolon
id|ioc-&gt;imask
op_assign
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_IMASK
)paren
op_or
l_int|0xFFFFFFFF00000000UL
suffix:semicolon
id|ioc-&gt;iov_size
op_assign
op_complement
id|ioc-&gt;imask
op_plus
l_int|1
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() hpa %p IOV base 0x%lx mask 0x%lx (%dMB)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ioc-&gt;ioc_hpa
comma
id|ioc-&gt;ibase
comma
id|ioc-&gt;imask
comma
id|ioc-&gt;iov_size
op_rshift
l_int|20
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|iovp_size
)paren
(brace
r_case
l_int|4
op_star
l_int|1024
suffix:colon
id|tcnfg
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
op_star
l_int|1024
suffix:colon
id|tcnfg
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
op_star
l_int|1024
suffix:colon
id|tcnfg
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
op_star
l_int|1024
suffix:colon
id|tcnfg
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
id|PFX
l_string|&quot;Unsupported IOTLB page size %ldK&quot;
comma
id|iovp_size
op_rshift
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|WRITE_REG
c_func
(paren
id|tcnfg
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_TCNFG
)paren
suffix:semicolon
id|ioc-&gt;pdir_size
op_assign
(paren
id|ioc-&gt;iov_size
op_div
id|iovp_size
)paren
op_star
id|PDIR_ENTRY_SIZE
suffix:semicolon
id|ioc-&gt;pdir_base
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|ioc-&gt;pdir_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc-&gt;pdir_base
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;Couldn&squot;t allocate I/O Page Table&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ioc-&gt;pdir_base
comma
l_int|0
comma
id|ioc-&gt;pdir_size
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() IOV page size %ldK pdir %p size %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|iovp_size
op_rshift
l_int|10
comma
id|ioc-&gt;pdir_base
comma
id|ioc-&gt;pdir_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|ioc-&gt;pdir_base
comma
l_int|4
op_star
l_int|1024
)paren
op_eq
(paren
r_int
r_int
)paren
id|ioc-&gt;pdir_base
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|virt_to_phys
c_func
(paren
id|ioc-&gt;pdir_base
)paren
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PDIR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** If an AGP device is present, only use half of the IOV space&n;&t;** for PCI DMA.  Unfortunately we can&squot;t know ahead of time&n;&t;** whether GART support will actually be used, for now we&n;&t;** can just key on an AGP device found in the system.&n;&t;** We program the next pdir index after we stop w/ a key for&n;&t;** the GART code to handshake on.&n;&t;*/
r_while
c_loop
(paren
(paren
id|device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|device
)paren
)paren
op_ne
l_int|NULL
)paren
id|agp_found
op_or_assign
id|pci_find_capability
c_func
(paren
id|device
comma
id|PCI_CAP_ID_AGP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agp_found
op_logical_and
id|reserve_sba_gart
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;reserving %dMb of IOVA space at 0x%lx for agpgart&bslash;n&quot;
comma
id|ioc-&gt;iov_size
op_div
l_int|2
op_rshift
l_int|20
comma
id|ioc-&gt;ibase
op_plus
id|ioc-&gt;iov_size
op_div
l_int|2
)paren
suffix:semicolon
id|ioc-&gt;pdir_size
op_div_assign
l_int|2
suffix:semicolon
(paren
(paren
id|u64
op_star
)paren
id|ioc-&gt;pdir_base
)paren
(braket
id|PDIR_INDEX
c_func
(paren
id|ioc-&gt;iov_size
op_div
l_int|2
)paren
)braket
op_assign
id|ZX1_SBA_IOMMU_COOKIE
suffix:semicolon
)brace
macro_line|#ifdef FULL_VALID_PDIR
multiline_comment|/*&n;  &t;** Check to see if the spill page has been allocated, we don&squot;t need more than&n;&t;** one across multiple SBAs.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|prefetch_spill_page
)paren
(brace
r_char
op_star
id|spill_poison
op_assign
l_string|&quot;SBAIOMMU POISON&quot;
suffix:semicolon
r_int
id|poison_size
op_assign
l_int|16
suffix:semicolon
r_void
op_star
id|poison_addr
comma
op_star
id|addr
suffix:semicolon
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|iovp_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;Couldn&squot;t allocate PDIR spill page&bslash;n&quot;
)paren
suffix:semicolon
id|poison_addr
op_assign
id|addr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|u64
)paren
id|poison_addr
OL
id|addr
op_plus
id|iovp_size
suffix:semicolon
id|poison_addr
op_add_assign
id|poison_size
)paren
id|memcpy
c_func
(paren
id|poison_addr
comma
id|spill_poison
comma
id|poison_size
)paren
suffix:semicolon
id|prefetch_spill_page
op_assign
id|virt_to_phys
c_func
(paren
id|addr
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() prefetch spill addr: 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|prefetch_spill_page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  &t;** Set all the PDIR entries valid w/ the spill page as the target&n;&t;*/
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
(paren
id|ioc-&gt;pdir_size
op_div
id|PDIR_ENTRY_SIZE
)paren
suffix:semicolon
id|index
op_increment
)paren
(paren
(paren
id|u64
op_star
)paren
id|ioc-&gt;pdir_base
)paren
(braket
id|index
)braket
op_assign
(paren
l_int|0x80000000000000FF
op_or
id|prefetch_spill_page
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Clear I/O TLB of any possible entries */
id|WRITE_REG
c_func
(paren
id|ioc-&gt;ibase
op_or
(paren
id|get_iovp_order
c_func
(paren
id|ioc-&gt;iov_size
)paren
op_plus
id|iovp_shift
)paren
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_PCOM
)paren
suffix:semicolon
multiline_comment|/* Enable IOVA translation */
id|WRITE_REG
c_func
(paren
id|ioc-&gt;ibase
op_or
l_int|1
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_IBASE
)paren
suffix:semicolon
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_IBASE
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|ioc_resource_init
id|ioc_resource_init
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|ioc-&gt;res_lock
)paren
suffix:semicolon
macro_line|#if DELAYED_RESOURCE_CNT &gt; 0
id|spin_lock_init
c_func
(paren
op_amp
id|ioc-&gt;saved_lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* resource map size dictated by pdir_size */
id|ioc-&gt;res_size
op_assign
id|ioc-&gt;pdir_size
op_div
id|PDIR_ENTRY_SIZE
suffix:semicolon
multiline_comment|/* entries */
id|ioc-&gt;res_size
op_rshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* convert bit count to byte count */
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() res_size 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ioc-&gt;res_size
)paren
suffix:semicolon
id|ioc-&gt;res_map
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|ioc-&gt;res_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc-&gt;res_map
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;Couldn&squot;t allocate resource map&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ioc-&gt;res_map
comma
l_int|0
comma
id|ioc-&gt;res_size
)paren
suffix:semicolon
multiline_comment|/* next available IOVP - circular search */
id|ioc-&gt;res_hint
op_assign
(paren
r_int
r_int
op_star
)paren
id|ioc-&gt;res_map
suffix:semicolon
macro_line|#ifdef ASSERT_PDIR_SANITY
multiline_comment|/* Mark first bit busy - ie no IOVA 0 */
id|ioc-&gt;res_map
(braket
l_int|0
)braket
op_assign
l_int|0x1
suffix:semicolon
id|ioc-&gt;pdir_base
(braket
l_int|0
)braket
op_assign
l_int|0x8000000000000000ULL
op_or
id|ZX1_SBA_IOMMU_COOKIE
suffix:semicolon
macro_line|#endif
macro_line|#ifdef FULL_VALID_PDIR
multiline_comment|/* Mark the last resource used so we don&squot;t prefetch beyond IOVA space */
id|ioc-&gt;res_map
(braket
id|ioc-&gt;res_size
op_minus
l_int|1
)braket
op_or_assign
l_int|0x80UL
suffix:semicolon
multiline_comment|/* res_map is chars */
id|ioc-&gt;pdir_base
(braket
(paren
id|ioc-&gt;pdir_size
op_div
id|PDIR_ENTRY_SIZE
)paren
op_minus
l_int|1
)braket
op_assign
(paren
l_int|0x80000000000000FF
op_or
id|prefetch_spill_page
)paren
suffix:semicolon
macro_line|#endif
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() res_map %x %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ioc-&gt;res_size
comma
(paren
r_void
op_star
)paren
id|ioc-&gt;res_map
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|ioc_sac_init
id|ioc_sac_init
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
r_struct
id|pci_dev
op_star
id|sac
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_controller
op_star
id|controller
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * pci_alloc_coherent() must return a DMA address which is&n;&t; * SAC (single address cycle) addressable, so allocate a&n;&t; * pseudo-device to enforce that.&n;&t; */
id|sac
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sac
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sac
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;Couldn&squot;t allocate struct pci_dev&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sac
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sac
)paren
)paren
suffix:semicolon
id|controller
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|controller
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|controller
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;Couldn&squot;t allocate struct pci_controller&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|controller
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|controller
)paren
)paren
suffix:semicolon
id|controller-&gt;iommu
op_assign
id|ioc
suffix:semicolon
id|sac-&gt;sysdata
op_assign
id|controller
suffix:semicolon
id|sac-&gt;dma_mask
op_assign
l_int|0xFFFFFFFFUL
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|sac-&gt;dev.bus
op_assign
op_amp
id|pci_bus_type
suffix:semicolon
macro_line|#endif
id|ioc-&gt;sac_only_dev
op_assign
id|sac
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|ioc_zx1_init
id|ioc_zx1_init
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
r_int
r_int
id|rope_config
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;rev
OL
l_int|0x20
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;IOC 2.0 or later required for IOMMU support&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* 38 bit memory controller + extra bit for range displaced by MMIO */
id|ioc-&gt;dma_mask
op_assign
(paren
l_int|0x1UL
op_lshift
l_int|39
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;** Clear ROPE(N)_CONFIG AO bit.&n;&t;** Disables &quot;NT Ordering&quot; (~= !&quot;Relaxed Ordering&quot;)&n;&t;** Overrides bit 1 in DMA Hint Sets.&n;&t;** Improves netperf UDP_STREAM by ~10% for tg3 on bcm5701.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|8
op_star
l_int|8
)paren
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|rope_config
op_assign
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_ROPE0_CFG
op_plus
id|i
)paren
suffix:semicolon
id|rope_config
op_and_assign
op_complement
id|IOC_ROPE_AO
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|rope_config
comma
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_ROPE0_CFG
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|typedef|initfunc
r_typedef
r_void
(paren
id|initfunc
)paren
(paren
r_struct
id|ioc
op_star
)paren
suffix:semicolon
DECL|struct|ioc_iommu
r_struct
id|ioc_iommu
(brace
DECL|member|func_id
id|u32
id|func_id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|init
id|initfunc
op_star
id|init
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|ioc_iommu
id|ioc_iommu_info
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|ZX1_IOC_ID
comma
l_string|&quot;zx1&quot;
comma
id|ioc_zx1_init
)brace
comma
(brace
id|SX1000_IOC_ID
comma
l_string|&quot;sx1000&quot;
comma
l_int|NULL
)brace
comma
)brace
suffix:semicolon
r_static
r_struct
id|ioc
op_star
id|__init
DECL|function|ioc_init
id|ioc_init
c_func
(paren
id|u64
id|hpa
comma
r_void
op_star
id|handle
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_struct
id|ioc_iommu
op_star
id|info
suffix:semicolon
id|ioc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ioc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ioc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ioc
)paren
)paren
suffix:semicolon
id|ioc-&gt;next
op_assign
id|ioc_list
suffix:semicolon
id|ioc_list
op_assign
id|ioc
suffix:semicolon
id|ioc-&gt;handle
op_assign
id|handle
suffix:semicolon
id|ioc-&gt;ioc_hpa
op_assign
id|ioremap
c_func
(paren
id|hpa
comma
l_int|0x1000
)paren
suffix:semicolon
id|ioc-&gt;func_id
op_assign
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_FUNC_ID
)paren
suffix:semicolon
id|ioc-&gt;rev
op_assign
id|READ_REG
c_func
(paren
id|ioc-&gt;ioc_hpa
op_plus
id|IOC_FCLASS
)paren
op_amp
l_int|0xFFUL
suffix:semicolon
id|ioc-&gt;dma_mask
op_assign
l_int|0xFFFFFFFFFFFFFFFFUL
suffix:semicolon
multiline_comment|/* conservative */
r_for
c_loop
(paren
id|info
op_assign
id|ioc_iommu_info
suffix:semicolon
id|info
OL
id|ioc_iommu_info
op_plus
id|ARRAY_SIZE
c_func
(paren
id|ioc_iommu_info
)paren
suffix:semicolon
id|info
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioc-&gt;func_id
op_eq
id|info-&gt;func_id
)paren
(brace
id|ioc-&gt;name
op_assign
id|info-&gt;name
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;init
)paren
(paren
id|info-&gt;init
)paren
(paren
id|ioc
)paren
suffix:semicolon
)brace
)brace
id|iovp_size
op_assign
(paren
l_int|1
op_lshift
id|iovp_shift
)paren
suffix:semicolon
id|iovp_mask
op_assign
op_complement
(paren
id|iovp_size
op_minus
l_int|1
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s: PAGE_SIZE %ldK, iovp_size %ldK&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|PAGE_SIZE
op_rshift
l_int|10
comma
id|iovp_size
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc-&gt;name
)paren
(brace
id|ioc-&gt;name
op_assign
id|kmalloc
c_func
(paren
l_int|24
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;name
)paren
id|sprintf
c_func
(paren
(paren
r_char
op_star
)paren
id|ioc-&gt;name
comma
l_string|&quot;Unknown (%04x:%04x)&quot;
comma
id|ioc-&gt;func_id
op_amp
l_int|0xFFFF
comma
(paren
id|ioc-&gt;func_id
op_rshift
l_int|16
)paren
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_else
id|ioc-&gt;name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
id|ioc_iova_init
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|ioc_resource_init
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|ioc_sac_init
c_func
(paren
id|ioc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
op_complement
id|iovp_mask
OG
(paren
r_int
)paren
id|ia64_max_iommu_merge_mask
)paren
id|ia64_max_iommu_merge_mask
op_assign
op_complement
id|iovp_mask
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;%s %d.%d HPA 0x%lx IOVA space %dMb at 0x%lx&bslash;n&quot;
comma
id|ioc-&gt;name
comma
(paren
id|ioc-&gt;rev
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
comma
id|ioc-&gt;rev
op_amp
l_int|0xF
comma
id|hpa
comma
id|ioc-&gt;iov_size
op_rshift
l_int|20
comma
id|ioc-&gt;ibase
)paren
suffix:semicolon
r_return
id|ioc
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n;**&n;**   SBA initialization code (HW and SW)&n;**&n;**   o identify SBA chip itself&n;**   o FIXME: initialize DMA hints for reasonable defaults&n;**&n;**************************************************************************/
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_void
op_star
DECL|function|ioc_start
id|ioc_start
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
id|loff_t
id|n
op_assign
op_star
id|pos
suffix:semicolon
r_for
c_loop
(paren
id|ioc
op_assign
id|ioc_list
suffix:semicolon
id|ioc
suffix:semicolon
id|ioc
op_assign
id|ioc-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|n
op_decrement
)paren
r_return
id|ioc
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|ioc_next
id|ioc_next
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
op_assign
id|v
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|ioc-&gt;next
suffix:semicolon
)brace
r_static
r_void
DECL|function|ioc_stop
id|ioc_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
)paren
(brace
)brace
r_static
r_int
DECL|function|ioc_show
id|ioc_show
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
op_assign
id|v
suffix:semicolon
r_int
r_int
op_star
id|res_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|ioc-&gt;res_map
suffix:semicolon
r_int
id|i
comma
id|used
op_assign
l_int|0
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;Hewlett Packard %s IOC rev %d.%d&bslash;n&quot;
comma
id|ioc-&gt;name
comma
(paren
(paren
id|ioc-&gt;rev
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)paren
comma
(paren
id|ioc-&gt;rev
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
r_if
c_cond
(paren
id|ioc-&gt;node
op_ne
id|MAX_NUMNODES
)paren
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;NUMA node       : %d&bslash;n&quot;
comma
id|ioc-&gt;node
)paren
suffix:semicolon
macro_line|#endif
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;IOVA size       : %ld MB&bslash;n&quot;
comma
(paren
(paren
id|ioc-&gt;pdir_size
op_rshift
l_int|3
)paren
op_star
id|iovp_size
)paren
op_div
(paren
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;IOVA page size  : %ld kb&bslash;n&quot;
comma
id|iovp_size
op_div
l_int|1024
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|ioc-&gt;res_size
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
op_increment
id|i
comma
op_increment
id|res_ptr
)paren
id|used
op_add_assign
id|hweight64
c_func
(paren
op_star
id|res_ptr
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;PDIR size       : %d entries&bslash;n&quot;
comma
id|ioc-&gt;pdir_size
op_rshift
l_int|3
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;PDIR used       : %d entries&bslash;n&quot;
comma
id|used
)paren
suffix:semicolon
macro_line|#ifdef PDIR_SEARCH_TIMING
(brace
r_int
r_int
id|i
op_assign
l_int|0
comma
id|avg
op_assign
l_int|0
comma
id|min
comma
id|max
suffix:semicolon
id|min
op_assign
id|max
op_assign
id|ioc-&gt;avg_search
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBA_SEARCH_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|avg
op_add_assign
id|ioc-&gt;avg_search
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;avg_search
(braket
id|i
)braket
OG
id|max
)paren
id|max
op_assign
id|ioc-&gt;avg_search
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;avg_search
(braket
id|i
)braket
OL
id|min
)paren
id|min
op_assign
id|ioc-&gt;avg_search
(braket
id|i
)braket
suffix:semicolon
)brace
id|avg
op_div_assign
id|SBA_SEARCH_SAMPLE
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;Bitmap search   : %ld/%ld/%ld (min/avg/max CPU Cycles/IOVA page)&bslash;n&quot;
comma
id|min
comma
id|avg
comma
id|max
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef ALLOW_IOV_BYPASS
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;IOVA bypass disabled&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ioc_seq_ops
r_static
r_struct
id|seq_operations
id|ioc_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|ioc_start
comma
dot
id|next
op_assign
id|ioc_next
comma
dot
id|stop
op_assign
id|ioc_stop
comma
dot
id|show
op_assign
id|ioc_show
)brace
suffix:semicolon
r_static
r_int
DECL|function|ioc_open
id|ioc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|ioc_seq_ops
)paren
suffix:semicolon
)brace
DECL|variable|ioc_fops
r_static
r_struct
id|file_operations
id|ioc_fops
op_assign
(brace
dot
id|open
op_assign
id|ioc_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
)brace
suffix:semicolon
r_static
r_void
id|__init
DECL|function|ioc_proc_init
id|ioc_proc_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|dir
comma
op_star
id|entry
suffix:semicolon
id|dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;bus/mckinley&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
suffix:semicolon
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ioc_list-&gt;name
comma
l_int|0
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;proc_fops
op_assign
op_amp
id|ioc_fops
suffix:semicolon
)brace
macro_line|#endif
r_static
r_void
DECL|function|sba_connect_bus
id|sba_connect_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
id|acpi_handle
id|handle
comma
id|parent
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCI_CONTROLLER
c_func
(paren
id|bus
)paren
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;no sysdata on bus %d!&bslash;n&quot;
comma
id|bus-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_CONTROLLER
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|iommu
)paren
r_return
suffix:semicolon
id|handle
op_assign
id|PCI_CONTROLLER
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|acpi_handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * The IOC scope encloses PCI root bridges in the ACPI&n;&t; * namespace, so work our way out until we find an IOC we&n;&t; * claimed previously.&n;&t; */
r_do
(brace
r_for
c_loop
(paren
id|ioc
op_assign
id|ioc_list
suffix:semicolon
id|ioc
suffix:semicolon
id|ioc
op_assign
id|ioc-&gt;next
)paren
r_if
c_cond
(paren
id|ioc-&gt;handle
op_eq
id|handle
)paren
(brace
id|PCI_CONTROLLER
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|iommu
op_assign
id|ioc
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status
op_assign
id|acpi_get_parent
c_func
(paren
id|handle
comma
op_amp
id|parent
)paren
suffix:semicolon
id|handle
op_assign
id|parent
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No IOC for PCI Bus %04x:%02x in ACPI&bslash;n&quot;
comma
id|pci_domain_nr
c_func
(paren
id|bus
)paren
comma
id|bus-&gt;number
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
r_static
r_void
id|__init
DECL|function|sba_map_ioc_to_node
id|sba_map_ioc_to_node
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|acpi_handle
id|handle
)paren
(brace
r_struct
id|acpi_buffer
id|buffer
op_assign
(brace
id|ACPI_ALLOCATE_BUFFER
comma
l_int|NULL
)brace
suffix:semicolon
r_union
id|acpi_object
op_star
id|obj
suffix:semicolon
id|acpi_handle
id|phandle
suffix:semicolon
r_int
r_int
id|node
suffix:semicolon
id|ioc-&gt;node
op_assign
id|MAX_NUMNODES
suffix:semicolon
multiline_comment|/*&n;&t; * Check for a _PXM on this node first.  We don&squot;t typically see&n;&t; * one here, so we&squot;ll end up getting it from the parent.&n;&t; */
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|acpi_evaluate_object
c_func
(paren
id|handle
comma
l_string|&quot;_PXM&quot;
comma
l_int|NULL
comma
op_amp
id|buffer
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|acpi_get_parent
c_func
(paren
id|handle
comma
op_amp
id|phandle
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Reset the acpi buffer */
id|buffer.length
op_assign
id|ACPI_ALLOCATE_BUFFER
suffix:semicolon
id|buffer.pointer
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|acpi_evaluate_object
c_func
(paren
id|phandle
comma
l_string|&quot;_PXM&quot;
comma
l_int|NULL
comma
op_amp
id|buffer
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer.length
op_logical_or
op_logical_neg
id|buffer.pointer
)paren
r_return
suffix:semicolon
id|obj
op_assign
id|buffer.pointer
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|ACPI_TYPE_INTEGER
op_logical_or
id|obj-&gt;integer.value
op_ge
id|MAX_PXM_DOMAINS
)paren
(brace
id|acpi_os_free
c_func
(paren
id|buffer.pointer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|node
op_assign
id|pxm_to_nid_map
(braket
id|obj-&gt;integer.value
)braket
suffix:semicolon
id|acpi_os_free
c_func
(paren
id|buffer.pointer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_ge
id|MAX_NUMNODES
op_logical_or
op_logical_neg
id|node_online
c_func
(paren
id|node
)paren
)paren
r_return
suffix:semicolon
id|ioc-&gt;node
op_assign
id|node
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#else
DECL|macro|sba_map_ioc_to_node
mdefine_line|#define sba_map_ioc_to_node(ioc, handle)
macro_line|#endif
r_static
r_int
id|__init
DECL|function|acpi_sba_ioc_add
id|acpi_sba_ioc_add
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
id|u64
id|hpa
comma
id|length
suffix:semicolon
r_struct
id|acpi_buffer
id|buffer
suffix:semicolon
r_struct
id|acpi_device_info
op_star
id|dev_info
suffix:semicolon
id|status
op_assign
id|hp_acpi_csr_space
c_func
(paren
id|device-&gt;handle
comma
op_amp
id|hpa
comma
op_amp
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|buffer.length
op_assign
id|ACPI_ALLOCATE_LOCAL_BUFFER
suffix:semicolon
id|status
op_assign
id|acpi_get_object_info
c_func
(paren
id|device-&gt;handle
comma
op_amp
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dev_info
op_assign
id|buffer.pointer
suffix:semicolon
multiline_comment|/*&n;&t; * For HWP0001, only SBA appears in ACPI namespace.  It encloses the PCI&n;&t; * root bridges, and its CSR space includes the IOC function.&n;&t; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;HWP0001&quot;
comma
id|dev_info-&gt;hardware_id.value
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|hpa
op_add_assign
id|ZX1_IOC_OFFSET
suffix:semicolon
multiline_comment|/* zx1 based systems default to kernel page size iommu pages */
r_if
c_cond
(paren
op_logical_neg
id|iovp_shift
)paren
id|iovp_shift
op_assign
id|min
c_func
(paren
id|PAGE_SHIFT
comma
l_int|16
)paren
suffix:semicolon
)brace
id|ACPI_MEM_FREE
c_func
(paren
id|dev_info
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * default anything not caught above or specified on cmdline to 4k&n;&t; * iommu page size&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|iovp_shift
)paren
id|iovp_shift
op_assign
l_int|12
suffix:semicolon
id|ioc
op_assign
id|ioc_init
c_func
(paren
id|hpa
comma
id|device-&gt;handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* setup NUMA node association */
id|sba_map_ioc_to_node
c_func
(paren
id|ioc
comma
id|device-&gt;handle
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|acpi_sba_ioc_driver
r_static
r_struct
id|acpi_driver
id|acpi_sba_ioc_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;IOC IOMMU Driver&quot;
comma
dot
id|ids
op_assign
l_string|&quot;HWP0001,HWP0004&quot;
comma
dot
id|ops
op_assign
(brace
dot
id|add
op_assign
id|acpi_sba_ioc_add
comma
)brace
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|sba_init
id|sba_init
c_func
(paren
r_void
)paren
(brace
id|acpi_bus_register_driver
c_func
(paren
op_amp
id|acpi_sba_ioc_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc_list
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
(brace
r_struct
id|pci_bus
op_star
id|b
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|b
op_assign
id|pci_find_next_bus
c_func
(paren
id|b
)paren
)paren
op_ne
l_int|NULL
)paren
id|sba_connect_bus
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|ioc_proc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sba_init
id|subsys_initcall
c_func
(paren
id|sba_init
)paren
suffix:semicolon
multiline_comment|/* must be initialized after ACPI etc., but before any drivers... */
r_extern
r_void
id|dig_setup
c_func
(paren
r_char
op_star
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * MAX_DMA_ADDRESS needs to be setup prior to paging_init to do any good,&n; * so we use the platform_setup hook to fix it up.&n; */
r_void
id|__init
DECL|function|sba_setup
id|sba_setup
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
id|MAX_DMA_ADDRESS
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|dig_setup
c_func
(paren
id|cmdline_p
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|nosbagart
id|nosbagart
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|reserve_sba_gart
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|sba_dma_supported
id|sba_dma_supported
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|mask
)paren
(brace
multiline_comment|/* make sure it&squot;s at least 32bit capable */
r_return
(paren
(paren
id|mask
op_amp
l_int|0xFFFFFFFFUL
)paren
op_eq
l_int|0xFFFFFFFFUL
)paren
suffix:semicolon
)brace
r_int
DECL|function|sba_dma_mapping_error
id|sba_dma_mapping_error
(paren
id|dma_addr_t
id|dma_addr
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nosbagart&quot;
comma
id|nosbagart
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|sba_page_override
id|sba_page_override
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|page_size
suffix:semicolon
id|page_size
op_assign
id|memparse
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|page_size
)paren
(brace
r_case
l_int|4096
suffix:colon
r_case
l_int|8192
suffix:colon
r_case
l_int|16384
suffix:colon
r_case
l_int|65536
suffix:colon
id|iovp_shift
op_assign
id|ffs
c_func
(paren
id|page_size
)paren
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unknown/unsupported iommu page size %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|page_size
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;sbapagesize=&quot;
comma
id|sba_page_override
)paren
suffix:semicolon
DECL|variable|sba_dma_mapping_error
id|EXPORT_SYMBOL
c_func
(paren
id|sba_dma_mapping_error
)paren
suffix:semicolon
DECL|variable|sba_map_single
id|EXPORT_SYMBOL
c_func
(paren
id|sba_map_single
)paren
suffix:semicolon
DECL|variable|sba_unmap_single
id|EXPORT_SYMBOL
c_func
(paren
id|sba_unmap_single
)paren
suffix:semicolon
DECL|variable|sba_map_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sba_map_sg
)paren
suffix:semicolon
DECL|variable|sba_unmap_sg
id|EXPORT_SYMBOL
c_func
(paren
id|sba_unmap_sg
)paren
suffix:semicolon
DECL|variable|sba_dma_supported
id|EXPORT_SYMBOL
c_func
(paren
id|sba_dma_supported
)paren
suffix:semicolon
DECL|variable|sba_alloc_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sba_alloc_coherent
)paren
suffix:semicolon
DECL|variable|sba_free_coherent
id|EXPORT_SYMBOL
c_func
(paren
id|sba_free_coherent
)paren
suffix:semicolon
eof
