multiline_comment|/* &n; * &n; * Glue Code for optimized 586 assembler version of AES&n; *&n; * Copyright (c) 2002, Dr Brian Gladman &lt;&gt;, Worcester, UK.&n; * All rights reserved.&n; *&n; * LICENSE TERMS&n; *&n; * The free distribution and use of this software in both source and binary&n; * form is allowed (with or without changes) provided that:&n; *&n; *   1. distributions of this source code include the above copyright&n; *      notice, this list of conditions and the following disclaimer;&n; *&n; *   2. distributions in binary form include the above copyright&n; *      notice, this list of conditions and the following disclaimer&n; *      in the documentation and/or other associated materials;&n; *&n; *   3. the copyright holder&squot;s name is not used to endorse products&n; *      built using this software without specific written permission.&n; *&n; * ALTERNATIVELY, provided that this notice is retained in full, this product&n; * may be distributed under the terms of the GNU General Public License (GPL),&n; * in which case the provisions of the GPL apply INSTEAD OF those given above.&n; *&n; * DISCLAIMER&n; *&n; * This software is provided &squot;as is&squot; with no explicit or implied warranties&n; * in respect of its properties, including, but not limited to, correctness&n; * and/or fitness for purpose.&n; *&n; * Copyright (c) 2003, Adam J. Richter &lt;adam@yggdrasil.com&gt; (conversion to&n; * 2.5 API).&n; * Copyright (c) 2003, 2004 Fruhwirth Clemens &lt;clemens@endorphin.org&gt;&n; * Copyright (c) 2004 Red Hat, Inc., James Morris &lt;jmorris@redhat.com&gt;&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/crypto.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
id|asmlinkage
r_void
id|aes_enc_blk
c_func
(paren
r_const
id|u8
op_star
id|src
comma
id|u8
op_star
id|dst
comma
r_void
op_star
id|ctx
)paren
suffix:semicolon
id|asmlinkage
r_void
id|aes_dec_blk
c_func
(paren
r_const
id|u8
op_star
id|src
comma
id|u8
op_star
id|dst
comma
r_void
op_star
id|ctx
)paren
suffix:semicolon
DECL|macro|AES_MIN_KEY_SIZE
mdefine_line|#define AES_MIN_KEY_SIZE&t;16
DECL|macro|AES_MAX_KEY_SIZE
mdefine_line|#define AES_MAX_KEY_SIZE&t;32
DECL|macro|AES_BLOCK_SIZE
mdefine_line|#define AES_BLOCK_SIZE&t;&t;16
DECL|macro|AES_KS_LENGTH
mdefine_line|#define AES_KS_LENGTH&t;&t;4 * AES_BLOCK_SIZE
DECL|macro|RC_LENGTH
mdefine_line|#define RC_LENGTH&t;&t;29
DECL|struct|aes_ctx
r_struct
id|aes_ctx
(brace
DECL|member|ekey
id|u32
id|ekey
(braket
id|AES_KS_LENGTH
)braket
suffix:semicolon
DECL|member|rounds
id|u32
id|rounds
suffix:semicolon
DECL|member|dkey
id|u32
id|dkey
(braket
id|AES_KS_LENGTH
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|WPOLY
mdefine_line|#define WPOLY 0x011b
DECL|macro|u32_in
mdefine_line|#define u32_in(x) le32_to_cpu(*(const u32 *)(x))
DECL|macro|bytes2word
mdefine_line|#define bytes2word(b0, b1, b2, b3)  &bslash;&n;&t;(((u32)(b3) &lt;&lt; 24) | ((u32)(b2) &lt;&lt; 16) | ((u32)(b1) &lt;&lt; 8) | (b0))
multiline_comment|/* define the finite field multiplies required for Rijndael */
DECL|macro|f2
mdefine_line|#define f2(x) ((x) ? pow[log[x] + 0x19] : 0)
DECL|macro|f3
mdefine_line|#define f3(x) ((x) ? pow[log[x] + 0x01] : 0)
DECL|macro|f9
mdefine_line|#define f9(x) ((x) ? pow[log[x] + 0xc7] : 0)
DECL|macro|fb
mdefine_line|#define fb(x) ((x) ? pow[log[x] + 0x68] : 0)
DECL|macro|fd
mdefine_line|#define fd(x) ((x) ? pow[log[x] + 0xee] : 0)
DECL|macro|fe
mdefine_line|#define fe(x) ((x) ? pow[log[x] + 0xdf] : 0)
DECL|macro|fi
mdefine_line|#define fi(x) ((x) ?   pow[255 - log[x]]: 0)
DECL|function|upr
r_static
r_inline
id|u32
id|upr
c_func
(paren
id|u32
id|x
comma
r_int
id|n
)paren
(brace
r_return
(paren
id|x
op_lshift
l_int|8
op_star
id|n
)paren
op_or
(paren
id|x
op_rshift
(paren
l_int|32
op_minus
l_int|8
op_star
id|n
)paren
)paren
suffix:semicolon
)brace
DECL|function|bval
r_static
r_inline
id|u8
id|bval
c_func
(paren
id|u32
id|x
comma
r_int
id|n
)paren
(brace
r_return
id|x
op_rshift
l_int|8
op_star
id|n
suffix:semicolon
)brace
multiline_comment|/* The forward and inverse affine transformations used in the S-box */
DECL|macro|fwd_affine
mdefine_line|#define fwd_affine(x) &bslash;&n;&t;(w = (u32)x, w ^= (w&lt;&lt;1)^(w&lt;&lt;2)^(w&lt;&lt;3)^(w&lt;&lt;4), 0x63^(u8)(w^(w&gt;&gt;8)))
DECL|macro|inv_affine
mdefine_line|#define inv_affine(x) &bslash;&n;&t;(w = (u32)x, w = (w&lt;&lt;1)^(w&lt;&lt;3)^(w&lt;&lt;6), 0x05^(u8)(w^(w&gt;&gt;8)))
DECL|variable|rcon_tab
r_static
id|u32
id|rcon_tab
(braket
id|RC_LENGTH
)braket
suffix:semicolon
DECL|variable|ft_tab
id|u32
id|ft_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|fl_tab
id|u32
id|fl_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|ls_tab
r_static
id|u32
id|ls_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|im_tab
r_static
id|u32
id|im_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|il_tab
id|u32
id|il_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|it_tab
id|u32
id|it_tab
(braket
l_int|4
)braket
(braket
l_int|256
)braket
suffix:semicolon
DECL|function|gen_tabs
r_static
r_void
id|gen_tabs
c_func
(paren
r_void
)paren
(brace
id|u32
id|i
comma
id|w
suffix:semicolon
id|u8
id|pow
(braket
l_int|512
)braket
comma
id|log
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * log and power tables for GF(2^8) finite field with&n;&t; * WPOLY as modular polynomial - the simplest primitive&n;&t; * root is 0x03, used here to generate the tables.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|w
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|pow
(braket
id|i
)braket
op_assign
(paren
id|u8
)paren
id|w
suffix:semicolon
id|pow
(braket
id|i
op_plus
l_int|255
)braket
op_assign
(paren
id|u8
)paren
id|w
suffix:semicolon
id|log
(braket
id|w
)braket
op_assign
(paren
id|u8
)paren
id|i
op_increment
suffix:semicolon
id|w
op_xor_assign
(paren
id|w
op_lshift
l_int|1
)paren
op_xor
(paren
id|w
op_amp
l_int|0x80
ques
c_cond
id|WPOLY
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|w
op_ne
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|RC_LENGTH
suffix:semicolon
op_increment
id|i
)paren
(brace
id|rcon_tab
(braket
id|i
)braket
op_assign
id|bytes2word
c_func
(paren
id|w
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|w
op_assign
id|f2
c_func
(paren
id|w
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
op_increment
id|i
)paren
(brace
id|u8
id|b
suffix:semicolon
id|b
op_assign
id|fwd_affine
c_func
(paren
id|fi
c_func
(paren
(paren
id|u8
)paren
id|i
)paren
)paren
suffix:semicolon
id|w
op_assign
id|bytes2word
c_func
(paren
id|f2
c_func
(paren
id|b
)paren
comma
id|b
comma
id|b
comma
id|f3
c_func
(paren
id|b
)paren
)paren
suffix:semicolon
multiline_comment|/* tables for a normal encryption round */
id|ft_tab
(braket
l_int|0
)braket
(braket
id|i
)braket
op_assign
id|w
suffix:semicolon
id|ft_tab
(braket
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|ft_tab
(braket
l_int|2
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|ft_tab
(braket
l_int|3
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
id|w
op_assign
id|bytes2word
c_func
(paren
id|b
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * tables for last encryption round&n;&t;&t; * (may also be used in the key schedule)&n;&t;&t; */
id|fl_tab
(braket
l_int|0
)braket
(braket
id|i
)braket
op_assign
id|w
suffix:semicolon
id|fl_tab
(braket
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|fl_tab
(braket
l_int|2
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|fl_tab
(braket
l_int|3
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * table for key schedule if fl_tab above is&n;&t;&t; * not of the required form&n;&t;&t; */
id|ls_tab
(braket
l_int|0
)braket
(braket
id|i
)braket
op_assign
id|w
suffix:semicolon
id|ls_tab
(braket
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|ls_tab
(braket
l_int|2
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|ls_tab
(braket
l_int|3
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
id|b
op_assign
id|fi
c_func
(paren
id|inv_affine
c_func
(paren
(paren
id|u8
)paren
id|i
)paren
)paren
suffix:semicolon
id|w
op_assign
id|bytes2word
c_func
(paren
id|fe
c_func
(paren
id|b
)paren
comma
id|f9
c_func
(paren
id|b
)paren
comma
id|fd
c_func
(paren
id|b
)paren
comma
id|fb
c_func
(paren
id|b
)paren
)paren
suffix:semicolon
multiline_comment|/* tables for the inverse mix column operation  */
id|im_tab
(braket
l_int|0
)braket
(braket
id|b
)braket
op_assign
id|w
suffix:semicolon
id|im_tab
(braket
l_int|1
)braket
(braket
id|b
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|im_tab
(braket
l_int|2
)braket
(braket
id|b
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|im_tab
(braket
l_int|3
)braket
(braket
id|b
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* tables for a normal decryption round */
id|it_tab
(braket
l_int|0
)braket
(braket
id|i
)braket
op_assign
id|w
suffix:semicolon
id|it_tab
(braket
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|it_tab
(braket
l_int|2
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|it_tab
(braket
l_int|3
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
id|w
op_assign
id|bytes2word
c_func
(paren
id|b
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* tables for last decryption round */
id|il_tab
(braket
l_int|0
)braket
(braket
id|i
)braket
op_assign
id|w
suffix:semicolon
id|il_tab
(braket
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|1
)paren
suffix:semicolon
id|il_tab
(braket
l_int|2
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|2
)paren
suffix:semicolon
id|il_tab
(braket
l_int|3
)braket
(braket
id|i
)braket
op_assign
id|upr
c_func
(paren
id|w
comma
l_int|3
)paren
suffix:semicolon
)brace
)brace
DECL|macro|four_tables
mdefine_line|#define four_tables(x,tab,vf,rf,c)&t;&t;&bslash;&n;(&t;tab[0][bval(vf(x,0,c),rf(0,c))]&t;^&t;&bslash;&n;&t;tab[1][bval(vf(x,1,c),rf(1,c))] ^&t;&bslash;&n;&t;tab[2][bval(vf(x,2,c),rf(2,c))] ^&t;&bslash;&n;&t;tab[3][bval(vf(x,3,c),rf(3,c))]&t;&t;&bslash;&n;)
DECL|macro|vf1
mdefine_line|#define vf1(x,r,c)  (x)
DECL|macro|rf1
mdefine_line|#define rf1(r,c)    (r)
DECL|macro|rf2
mdefine_line|#define rf2(r,c)    ((r-c)&amp;3)
DECL|macro|inv_mcol
mdefine_line|#define inv_mcol(x) four_tables(x,im_tab,vf1,rf1,0)
DECL|macro|ls_box
mdefine_line|#define ls_box(x,c) four_tables(x,fl_tab,vf1,rf2,c)
DECL|macro|ff
mdefine_line|#define ff(x) inv_mcol(x)
DECL|macro|ke4
mdefine_line|#define ke4(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+4] = ss[0] ^= ls_box(ss[3],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[4*(i)+5] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+6] = ss[2] ^= ss[1];&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+7] = ss[3] ^= ss[2];&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kel4
mdefine_line|#define kel4(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+4] = ss[0] ^= ls_box(ss[3],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[4*(i)+5] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+6] = ss[2] ^= ss[1]; k[4*(i)+7] = ss[3] ^= ss[2];&t;&bslash;&n;}
DECL|macro|ke6
mdefine_line|#define ke6(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 6] = ss[0] ^= ls_box(ss[5],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[6*(i)+ 7] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 8] = ss[2] ^= ss[1];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 9] = ss[3] ^= ss[2];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+10] = ss[4] ^= ss[3];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+11] = ss[5] ^= ss[4];&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kel6
mdefine_line|#define kel6(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 6] = ss[0] ^= ls_box(ss[5],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[6*(i)+ 7] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 8] = ss[2] ^= ss[1];&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 9] = ss[3] ^= ss[2];&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|ke8
mdefine_line|#define ke8(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 8] = ss[0] ^= ls_box(ss[7],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[8*(i)+ 9] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+10] = ss[2] ^= ss[1];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+11] = ss[3] ^= ss[2];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+12] = ss[4] ^= ls_box(ss[3],0);&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+13] = ss[5] ^= ss[4];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+14] = ss[6] ^= ss[5];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+15] = ss[7] ^= ss[6];&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kel8
mdefine_line|#define kel8(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 8] = ss[0] ^= ls_box(ss[7],3) ^ rcon_tab[i];&t;&t;&bslash;&n;&t;k[8*(i)+ 9] = ss[1] ^= ss[0];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+10] = ss[2] ^= ss[1];&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+11] = ss[3] ^= ss[2];&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdf4
mdefine_line|#define kdf4(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[0] = ss[0] ^ ss[2] ^ ss[1] ^ ss[3];&t;&t;&t;&t;&bslash;&n;&t;ss[1] = ss[1] ^ ss[3];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[2] = ss[2] ^ ss[3];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[3] = ss[3];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] = ls_box(ss[(i+3) % 4], 3) ^ rcon_tab[i];&t;&t;&t;&bslash;&n;&t;ss[i % 4] ^= ss[4];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= k[4*(i)];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+4] = ff(ss[4]);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= k[4*(i)+1];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+5] = ff(ss[4]);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= k[4*(i)+2];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+6] = ff(ss[4]);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= k[4*(i)+3];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+7] = ff(ss[4]);&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kd4
mdefine_line|#define kd4(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] = ls_box(ss[(i+3) % 4], 3) ^ rcon_tab[i];&t;&t;&t;&bslash;&n;&t;ss[i % 4] ^= ss[4];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] = ff(ss[4]);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+4] = ss[4] ^= k[4*(i)];&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+5] = ss[4] ^= k[4*(i)+1];&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+6] = ss[4] ^= k[4*(i)+2];&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+7] = ss[4] ^= k[4*(i)+3];&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdl4
mdefine_line|#define kdl4(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] = ls_box(ss[(i+3) % 4], 3) ^ rcon_tab[i];&t;&t;&t;&bslash;&n;&t;ss[i % 4] ^= ss[4];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+4] = (ss[0] ^= ss[1]) ^ ss[2] ^ ss[3];&t;&t;&t;&bslash;&n;&t;k[4*(i)+5] = ss[1] ^ ss[3];&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+6] = ss[0];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[4*(i)+7] = ss[1];&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdf6
mdefine_line|#define kdf6(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[0] ^= ls_box(ss[5],3) ^ rcon_tab[i];&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 6] = ff(ss[0]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 7] = ff(ss[1]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 8] = ff(ss[2]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 9] = ff(ss[3]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= ss[3];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+10] = ff(ss[4]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[5] ^= ss[4];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+11] = ff(ss[5]);&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kd6
mdefine_line|#define kd6(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[6] = ls_box(ss[5],3) ^ rcon_tab[i];&t;&t;&t;&t;&bslash;&n;&t;ss[0] ^= ss[6]; ss[6] = ff(ss[6]);&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 6] = ss[6] ^= k[6*(i)];&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 7] = ss[6] ^= k[6*(i)+ 1];&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 8] = ss[6] ^= k[6*(i)+ 2];&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 9] = ss[6] ^= k[6*(i)+ 3];&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= ss[3];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+10] = ss[6] ^= k[6*(i)+ 4];&t;&t;&t;&t;&bslash;&n;&t;ss[5] ^= ss[4];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+11] = ss[6] ^= k[6*(i)+ 5];&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdl6
mdefine_line|#define kdl6(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[0] ^= ls_box(ss[5],3) ^ rcon_tab[i];&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 6] = ss[0];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 7] = ss[1];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 8] = ss[2];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[6*(i)+ 9] = ss[3];&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdf8
mdefine_line|#define kdf8(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[0] ^= ls_box(ss[7],3) ^ rcon_tab[i];&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 8] = ff(ss[0]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 9] = ff(ss[1]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+10] = ff(ss[2]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+11] = ff(ss[3]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= ls_box(ss[3],0);&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+12] = ff(ss[4]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[5] ^= ss[4];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+13] = ff(ss[5]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[6] ^= ss[5];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+14] = ff(ss[6]);&t;&t;&t;&t;&t;&bslash;&n;&t;ss[7] ^= ss[6];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+15] = ff(ss[7]);&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kd8
mdefine_line|#define kd8(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;u32 __g = ls_box(ss[7],3) ^ rcon_tab[i];&t;&t;&t;&bslash;&n;&t;ss[0] ^= __g;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__g = ff(__g);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 8] = __g ^= k[8*(i)];&t;&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 9] = __g ^= k[8*(i)+ 1];&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+10] = __g ^= k[8*(i)+ 2];&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+11] = __g ^= k[8*(i)+ 3];&t;&t;&t;&t;&bslash;&n;&t;__g = ls_box(ss[3],0);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[4] ^= __g;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__g = ff(__g);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+12] = __g ^= k[8*(i)+ 4];&t;&t;&t;&t;&bslash;&n;&t;ss[5] ^= ss[4];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+13] = __g ^= k[8*(i)+ 5];&t;&t;&t;&t;&bslash;&n;&t;ss[6] ^= ss[5];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+14] = __g ^= k[8*(i)+ 6];&t;&t;&t;&t;&bslash;&n;&t;ss[7] ^= ss[6];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+15] = __g ^= k[8*(i)+ 7];&t;&t;&t;&t;&bslash;&n;}
DECL|macro|kdl8
mdefine_line|#define kdl8(k,i)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[0] ^= ls_box(ss[7],3) ^ rcon_tab[i];&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 8] = ss[0];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[1] ^= ss[0];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+ 9] = ss[1];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[2] ^= ss[1];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+10] = ss[2];&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ss[3] ^= ss[2];&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;k[8*(i)+11] = ss[3];&t;&t;&t;&t;&t;&t;&bslash;&n;}
r_static
r_int
DECL|function|aes_set_key
id|aes_set_key
c_func
(paren
r_void
op_star
id|ctx_arg
comma
r_const
id|u8
op_star
id|in_key
comma
r_int
r_int
id|key_len
comma
id|u32
op_star
id|flags
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|ss
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|aes_ctx
op_star
id|ctx
op_assign
id|ctx_arg
suffix:semicolon
multiline_comment|/* encryption schedule */
id|ctx-&gt;ekey
(braket
l_int|0
)braket
op_assign
id|ss
(braket
l_int|0
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|1
)braket
op_assign
id|ss
(braket
l_int|1
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|4
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|2
)braket
op_assign
id|ss
(braket
l_int|2
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|8
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|3
)braket
op_assign
id|ss
(braket
l_int|3
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|12
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|key_len
)paren
(brace
r_case
l_int|16
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
id|ke4
c_func
(paren
id|ctx-&gt;ekey
comma
id|i
)paren
suffix:semicolon
id|kel4
c_func
(paren
id|ctx-&gt;ekey
comma
l_int|9
)paren
suffix:semicolon
id|ctx-&gt;rounds
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|ctx-&gt;ekey
(braket
l_int|4
)braket
op_assign
id|ss
(braket
l_int|4
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|16
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|5
)braket
op_assign
id|ss
(braket
l_int|5
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|20
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|ke6
c_func
(paren
id|ctx-&gt;ekey
comma
id|i
)paren
suffix:semicolon
id|kel6
c_func
(paren
id|ctx-&gt;ekey
comma
l_int|7
)paren
suffix:semicolon
id|ctx-&gt;rounds
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|ctx-&gt;ekey
(braket
l_int|4
)braket
op_assign
id|ss
(braket
l_int|4
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|16
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|5
)braket
op_assign
id|ss
(braket
l_int|5
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|20
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|6
)braket
op_assign
id|ss
(braket
l_int|6
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|24
)paren
suffix:semicolon
id|ctx-&gt;ekey
(braket
l_int|7
)braket
op_assign
id|ss
(braket
l_int|7
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|28
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|ke8
c_func
(paren
id|ctx-&gt;ekey
comma
id|i
)paren
suffix:semicolon
id|kel8
c_func
(paren
id|ctx-&gt;ekey
comma
l_int|6
)paren
suffix:semicolon
id|ctx-&gt;rounds
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|flags
op_or_assign
id|CRYPTO_TFM_RES_BAD_KEY_LEN
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* decryption schedule */
id|ctx-&gt;dkey
(braket
l_int|0
)braket
op_assign
id|ss
(braket
l_int|0
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|1
)braket
op_assign
id|ss
(braket
l_int|1
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|4
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|2
)braket
op_assign
id|ss
(braket
l_int|2
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|8
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|3
)braket
op_assign
id|ss
(braket
l_int|3
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|12
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|key_len
)paren
(brace
r_case
l_int|16
suffix:colon
id|kdf4
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
id|kd4
c_func
(paren
id|ctx-&gt;dkey
comma
id|i
)paren
suffix:semicolon
id|kdl4
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|9
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|ctx-&gt;dkey
(braket
l_int|4
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|4
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|16
)paren
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|5
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|5
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|20
)paren
)paren
suffix:semicolon
id|kdf6
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|kd6
c_func
(paren
id|ctx-&gt;dkey
comma
id|i
)paren
suffix:semicolon
id|kdl6
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|7
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|ctx-&gt;dkey
(braket
l_int|4
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|4
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|16
)paren
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|5
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|5
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|20
)paren
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|6
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|6
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|24
)paren
)paren
suffix:semicolon
id|ctx-&gt;dkey
(braket
l_int|7
)braket
op_assign
id|ff
c_func
(paren
id|ss
(braket
l_int|7
)braket
op_assign
id|u32_in
c_func
(paren
id|in_key
op_plus
l_int|28
)paren
)paren
suffix:semicolon
id|kdf8
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|kd8
c_func
(paren
id|ctx-&gt;dkey
comma
id|i
)paren
suffix:semicolon
id|kdl8
c_func
(paren
id|ctx-&gt;dkey
comma
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|aes_encrypt
r_static
r_inline
r_void
id|aes_encrypt
c_func
(paren
r_void
op_star
id|ctx
comma
id|u8
op_star
id|dst
comma
r_const
id|u8
op_star
id|src
)paren
(brace
id|aes_enc_blk
c_func
(paren
id|src
comma
id|dst
comma
id|ctx
)paren
suffix:semicolon
)brace
DECL|function|aes_decrypt
r_static
r_inline
r_void
id|aes_decrypt
c_func
(paren
r_void
op_star
id|ctx
comma
id|u8
op_star
id|dst
comma
r_const
id|u8
op_star
id|src
)paren
(brace
id|aes_dec_blk
c_func
(paren
id|src
comma
id|dst
comma
id|ctx
)paren
suffix:semicolon
)brace
DECL|variable|aes_alg
r_static
r_struct
id|crypto_alg
id|aes_alg
op_assign
(brace
dot
id|cra_name
op_assign
l_string|&quot;aes&quot;
comma
dot
id|cra_flags
op_assign
id|CRYPTO_ALG_TYPE_CIPHER
comma
dot
id|cra_blocksize
op_assign
id|AES_BLOCK_SIZE
comma
dot
id|cra_ctxsize
op_assign
r_sizeof
(paren
r_struct
id|aes_ctx
)paren
comma
dot
id|cra_module
op_assign
id|THIS_MODULE
comma
dot
id|cra_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|aes_alg.cra_list
)paren
comma
dot
id|cra_u
op_assign
(brace
dot
id|cipher
op_assign
(brace
dot
id|cia_min_keysize
op_assign
id|AES_MIN_KEY_SIZE
comma
dot
id|cia_max_keysize
op_assign
id|AES_MAX_KEY_SIZE
comma
dot
id|cia_setkey
op_assign
id|aes_set_key
comma
dot
id|cia_encrypt
op_assign
id|aes_encrypt
comma
dot
id|cia_decrypt
op_assign
id|aes_decrypt
)brace
)brace
)brace
suffix:semicolon
DECL|function|aes_init
r_static
r_int
id|__init
id|aes_init
c_func
(paren
r_void
)paren
(brace
id|gen_tabs
c_func
(paren
)paren
suffix:semicolon
r_return
id|crypto_register_alg
c_func
(paren
op_amp
id|aes_alg
)paren
suffix:semicolon
)brace
DECL|function|aes_fini
r_static
r_void
id|__exit
id|aes_fini
c_func
(paren
r_void
)paren
(brace
id|crypto_unregister_alg
c_func
(paren
op_amp
id|aes_alg
)paren
suffix:semicolon
)brace
DECL|variable|aes_init
id|module_init
c_func
(paren
id|aes_init
)paren
suffix:semicolon
DECL|variable|aes_fini
id|module_exit
c_func
(paren
id|aes_fini
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Rijndael (AES) Cipher Algorithm, i586 asm optimized&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Fruhwirth Clemens, James Morris, Brian Gladman, Adam Richter&quot;
)paren
suffix:semicolon
id|MODULE_ALIAS
c_func
(paren
l_string|&quot;aes&quot;
)paren
suffix:semicolon
eof
