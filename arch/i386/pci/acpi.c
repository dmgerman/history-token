macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &quot;pci.h&quot;
DECL|function|pci_acpi_scan_root
r_struct
id|pci_bus
op_star
id|__devinit
id|pci_acpi_scan_root
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
comma
r_int
id|domain
comma
r_int
id|busnum
)paren
(brace
r_if
c_cond
(paren
id|domain
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: Multiple domains not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|pcibios_scan_root
c_func
(paren
id|busnum
)paren
suffix:semicolon
)brace
r_extern
r_int
id|pci_routeirq
suffix:semicolon
DECL|function|pci_acpi_init
r_static
r_int
id|__init
id|pci_acpi_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_scanned
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|acpi_noirq
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PCI: Using ACPI for IRQ routing&bslash;n&quot;
)paren
suffix:semicolon
id|acpi_irq_penalty_init
c_func
(paren
)paren
suffix:semicolon
id|pcibios_scanned
op_increment
suffix:semicolon
id|pcibios_enable_irq
op_assign
id|acpi_pci_irq_enable
suffix:semicolon
r_if
c_cond
(paren
id|pci_routeirq
)paren
(brace
multiline_comment|/*&n;&t;&t; * PCI IRQ routing is set up by pci_enable_device(), but we&n;&t;&t; * also do it here in case there are still broken drivers that&n;&t;&t; * don&squot;t use pci_enable_device().&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** Routing PCI interrupts for all devices because &bslash;&quot;pci=routeirq&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** was specified.  If this was required to make a driver work,&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** please email the output of &bslash;&quot;lspci&bslash;&quot; to bjorn.helgaas@hp.com&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** so I can fix the driver.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
id|acpi_pci_irq_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** PCI interrupts are no longer routed automatically.  If this&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** causes a device to stop working, it is probably because the&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** driver failed to call pci_enable_device().  As a temporary&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** workaround, the &bslash;&quot;pci=routeirq&bslash;&quot; argument restores the old&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** behavior.  If this argument makes the device work again,&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** please email the output of &bslash;&quot;lspci&bslash;&quot; to bjorn.helgaas@hp.com&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;** so I can fix the driver.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_X86_IO_APIC
r_if
c_cond
(paren
id|acpi_ioapic
)paren
id|print_IO_APIC
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pci_acpi_init
id|subsys_initcall
c_func
(paren
id|pci_acpi_init
)paren
suffix:semicolon
eof
