multiline_comment|/*&n; * arch/i386/mm/boot_ioremap.c&n; * &n; * Re-map functions for early boot-time before paging_init() when the &n; * boot-time pagetables are still in use&n; *&n; * Written by Dave Hansen &lt;haveblue@us.ibm.com&gt;&n; */
multiline_comment|/*&n; * We need to use the 2-level pagetable functions, but CONFIG_X86_PAE&n; * keeps that from happenning.  If anyone has a better way, I&squot;m listening.&n; *&n; * boot_pte_t is defined only if this all works correctly&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|CONFIG_X86_PAE
macro_line|#undef CONFIG_X86_PAE
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
multiline_comment|/* &n; * I&squot;m cheating here.  It is known that the two boot PTE pages are &n; * allocated next to each other.  I&squot;m pretending that they&squot;re just&n; * one big array. &n; */
DECL|macro|BOOT_PTE_PTRS
mdefine_line|#define BOOT_PTE_PTRS (PTRS_PER_PTE*2)
DECL|macro|boot_pte_index
mdefine_line|#define boot_pte_index(address) &bslash;&n;&t;     (((address) &gt;&gt; PAGE_SHIFT) &amp; (BOOT_PTE_PTRS - 1))
DECL|function|boot_vaddr_to_pte
r_static
r_inline
id|boot_pte_t
op_star
id|boot_vaddr_to_pte
c_func
(paren
r_void
op_star
id|address
)paren
(brace
id|boot_pte_t
op_star
id|boot_pg
op_assign
(paren
id|boot_pte_t
op_star
)paren
id|pg0
suffix:semicolon
r_return
op_amp
id|boot_pg
(braket
id|boot_pte_index
c_func
(paren
(paren
r_int
r_int
)paren
id|address
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * This is only for a caller who is clever enough to page-align&n; * phys_addr and virtual_source, and who also has a preference&n; * about which virtual address from which to steal ptes&n; */
DECL|function|__boot_ioremap
r_static
r_void
id|__boot_ioremap
c_func
(paren
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|nrpages
comma
r_void
op_star
id|virtual_source
)paren
(brace
id|boot_pte_t
op_star
id|pte
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|vaddr
op_assign
id|virtual_source
suffix:semicolon
id|pte
op_assign
id|boot_vaddr_to_pte
c_func
(paren
id|virtual_source
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nrpages
suffix:semicolon
id|i
op_increment
comma
id|phys_addr
op_add_assign
id|PAGE_SIZE
comma
id|pte
op_increment
)paren
(brace
id|set_pte
c_func
(paren
id|pte
comma
id|pfn_pte
c_func
(paren
id|phys_addr
op_rshift
id|PAGE_SHIFT
comma
id|PAGE_KERNEL
)paren
)paren
suffix:semicolon
id|__flush_tlb_one
c_func
(paren
op_amp
id|vaddr
(braket
id|i
op_star
id|PAGE_SIZE
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* the virtual space we&squot;re going to remap comes from this array */
DECL|macro|BOOT_IOREMAP_PAGES
mdefine_line|#define BOOT_IOREMAP_PAGES 4
DECL|macro|BOOT_IOREMAP_SIZE
mdefine_line|#define BOOT_IOREMAP_SIZE (BOOT_IOREMAP_PAGES*PAGE_SIZE)
DECL|variable|boot_ioremap_space
id|__initdata
r_char
id|boot_ioremap_space
(braket
id|BOOT_IOREMAP_SIZE
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * This only applies to things which need to ioremap before paging_init()&n; * bt_ioremap() and plain ioremap() are both useless at this point.&n; * &n; * When used, we&squot;re still using the boot-time pagetables, which only&n; * have 2 PTE pages mapping the first 8MB&n; *&n; * There is no unmap.  The boot-time PTE pages aren&squot;t used after boot.&n; * If you really want the space back, just remap it yourself.&n; * boot_ioremap(&amp;ioremap_space-PAGE_OFFSET, BOOT_IOREMAP_SIZE)&n; */
DECL|function|boot_ioremap
id|__init
r_void
op_star
id|boot_ioremap
c_func
(paren
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|last_addr
comma
id|offset
suffix:semicolon
r_int
r_int
id|nrpages
suffix:semicolon
id|last_addr
op_assign
id|phys_addr
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* page align the requested address */
id|offset
op_assign
id|phys_addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|phys_addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|last_addr
)paren
op_minus
id|phys_addr
suffix:semicolon
id|nrpages
op_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|nrpages
OG
id|BOOT_IOREMAP_PAGES
)paren
r_return
l_int|NULL
suffix:semicolon
id|__boot_ioremap
c_func
(paren
id|phys_addr
comma
id|nrpages
comma
id|boot_ioremap_space
)paren
suffix:semicolon
r_return
op_amp
id|boot_ioremap_space
(braket
id|offset
)braket
suffix:semicolon
)brace
eof
