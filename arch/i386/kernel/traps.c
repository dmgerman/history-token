multiline_comment|/*&n; *  linux/arch/i386/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  Pentium III FXSR, SSE support&n; *&t;Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;asm.s&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kprobes.h&gt;
macro_line|#ifdef CONFIG_EISA
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/eisa.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_MCA
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/debugreg.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/i387.h&gt;
macro_line|#include &lt;asm/nmi.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/arch_hooks.h&gt;
macro_line|#include &lt;asm/kdebug.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;mach_traps.h&quot;
id|asmlinkage
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|lcall7
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|lcall27
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|default_ldt
r_struct
id|desc_struct
id|default_ldt
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Do we ignore FPU interrupts ? */
DECL|variable|ignore_fpu_irq
r_char
id|ignore_fpu_irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The IDT has to be page-aligned to simplify the Pentium&n; * F0 0F bug workaround.. We have a special link segment&n; * for this.&n; */
DECL|variable|idt_table
r_struct
id|desc_struct
id|idt_table
(braket
l_int|256
)braket
id|__attribute__
c_func
(paren
(paren
id|__section__
c_func
(paren
l_string|&quot;.data.idt&quot;
)paren
)paren
)paren
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
id|asmlinkage
r_void
id|divide_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|debug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|nmi
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|int3
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|overflow
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|bounds
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_op
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|device_not_available
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_segment_overrun
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_TSS
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|segment_not_present
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|stack_segment
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|general_protection
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|page_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|simd_coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|alignment_check
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|spurious_interrupt_bug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|machine_check
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|kstack_depth_to_print
r_static
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|variable|i386die_chain
r_struct
id|notifier_block
op_star
id|i386die_chain
suffix:semicolon
DECL|variable|die_notifier_lock
r_static
id|spinlock_t
id|die_notifier_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|register_die_notifier
r_int
id|register_die_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|die_notifier_lock
comma
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|notifier_chain_register
c_func
(paren
op_amp
id|i386die_chain
comma
id|nb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|die_notifier_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|valid_stack_ptr
r_static
r_int
id|valid_stack_ptr
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_void
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p
op_le
(paren
r_void
op_star
)paren
id|task-&gt;thread_info
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|kstack_end
c_func
(paren
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_FRAME_POINTER
DECL|function|print_context_stack
r_static
r_void
id|print_context_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|stack
comma
r_int
r_int
id|ebp
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_while
c_loop
(paren
id|valid_stack_ptr
c_func
(paren
id|task
comma
(paren
r_void
op_star
)paren
id|ebp
)paren
)paren
(brace
id|addr
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|ebp
op_plus
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&quot;
comma
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ebp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|ebp
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|print_context_stack
r_static
r_void
id|print_context_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|stack
comma
r_int
r_int
id|ebp
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|kstack_end
c_func
(paren
id|stack
)paren
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|__kernel_text_address
c_func
(paren
id|addr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; [&lt;%08lx&gt;]&quot;
comma
id|addr
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot; %s&quot;
comma
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|stack
)paren
(brace
r_int
r_int
id|ebp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
id|task
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_stack_ptr
c_func
(paren
id|task
comma
id|stack
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Stack pointer is garbage, not printing trace&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
multiline_comment|/* Grab ebp right from our regs */
id|asm
(paren
l_string|&quot;movl %%ebp, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ebp
)paren
suffix:colon
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ebp is the last reg pushed by switch_to */
id|ebp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|task-&gt;thread.esp
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|thread_info
op_star
id|context
suffix:semicolon
id|context
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|stack
op_amp
(paren
op_complement
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|print_context_stack
c_func
(paren
id|task
comma
id|stack
comma
id|ebp
)paren
suffix:semicolon
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
id|context-&gt;previous_esp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stack
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; =======================&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|esp
)paren
(brace
r_int
r_int
op_star
id|stack
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|esp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|task
)paren
id|esp
op_assign
(paren
r_int
r_int
op_star
)paren
id|task-&gt;thread.esp
suffix:semicolon
r_else
id|esp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|esp
suffix:semicolon
)brace
id|stack
op_assign
id|esp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kstack_end
c_func
(paren
id|stack
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace:&bslash;n&quot;
)paren
suffix:semicolon
id|show_trace
c_func
(paren
id|task
comma
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The architecture-independent dump_stack generator&n; */
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|stack
suffix:semicolon
id|show_trace
c_func
(paren
id|current
comma
op_amp
id|stack
)paren
suffix:semicolon
)brace
DECL|variable|dump_stack
id|EXPORT_SYMBOL
c_func
(paren
id|dump_stack
)paren
suffix:semicolon
DECL|function|show_registers
r_void
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|in_kernel
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|esp
suffix:semicolon
r_int
r_int
id|ss
suffix:semicolon
id|esp
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|regs-&gt;esp
)paren
suffix:semicolon
id|ss
op_assign
id|__KERNEL_DS
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
(brace
id|in_kernel
op_assign
l_int|0
suffix:semicolon
id|esp
op_assign
id|regs-&gt;esp
suffix:semicolon
id|ss
op_assign
id|regs-&gt;xss
op_amp
l_int|0xffff
suffix:semicolon
)brace
id|print_modules
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU:    %d&bslash;nEIP:    %04x:[&lt;%08lx&gt;]    %s VLI&bslash;nEFLAGS: %08lx&quot;
l_string|&quot;   (%s) &bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
l_int|0xffff
op_amp
id|regs-&gt;xcs
comma
id|regs-&gt;eip
comma
id|print_tainted
c_func
(paren
)paren
comma
id|regs-&gt;eflags
comma
id|UTS_RELEASE
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;EIP is at %s&bslash;n&quot;
comma
id|regs-&gt;eip
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx&bslash;n&quot;
comma
id|regs-&gt;eax
comma
id|regs-&gt;ebx
comma
id|regs-&gt;ecx
comma
id|regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx&bslash;n&quot;
comma
id|regs-&gt;esi
comma
id|regs-&gt;edi
comma
id|regs-&gt;ebp
comma
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ds: %04x   es: %04x   ss: %04x&bslash;n&quot;
comma
id|regs-&gt;xds
op_amp
l_int|0xffff
comma
id|regs-&gt;xes
op_amp
l_int|0xffff
comma
id|ss
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, threadinfo=%p task=%p)&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|current_thread_info
c_func
(paren
)paren
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When in-kernel, we also print out the stack and code at the&n;&t; * time of the fault..&n;&t; */
r_if
c_cond
(paren
id|in_kernel
)paren
(brace
id|u8
op_star
id|eip
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack: &quot;
)paren
suffix:semicolon
id|show_stack
c_func
(paren
l_int|NULL
comma
(paren
r_int
r_int
op_star
)paren
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code: &quot;
)paren
suffix:semicolon
id|eip
op_assign
(paren
id|u8
op_star
)paren
id|regs-&gt;eip
op_minus
l_int|43
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
comma
id|eip
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
(paren
id|u8
op_star
)paren
id|PAGE_OFFSET
op_logical_or
id|__get_user
c_func
(paren
id|c
comma
id|eip
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Bad EIP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eip
op_eq
(paren
id|u8
op_star
)paren
id|regs-&gt;eip
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;%02x&gt; &quot;
comma
id|c
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|handle_BUG
r_static
r_void
id|handle_BUG
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|ud2
suffix:semicolon
r_int
r_int
id|line
suffix:semicolon
r_char
op_star
id|file
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
r_int
id|eip
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
r_goto
id|no_bug
suffix:semicolon
multiline_comment|/* Not in kernel */
id|eip
op_assign
id|regs-&gt;eip
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|PAGE_OFFSET
)paren
r_goto
id|no_bug
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|ud2
comma
(paren
r_int
r_int
op_star
)paren
id|eip
)paren
)paren
r_goto
id|no_bug
suffix:semicolon
r_if
c_cond
(paren
id|ud2
op_ne
l_int|0x0b0f
)paren
r_goto
id|no_bug
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|line
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|eip
op_plus
l_int|2
)paren
)paren
)paren
r_goto
id|bug
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|file
comma
(paren
r_char
op_star
op_star
)paren
(paren
id|eip
op_plus
l_int|4
)paren
)paren
op_logical_or
(paren
r_int
r_int
)paren
id|file
OL
id|PAGE_OFFSET
op_logical_or
id|__get_user
c_func
(paren
id|c
comma
id|file
)paren
)paren
id|file
op_assign
l_string|&quot;&lt;bad filename&gt;&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;------------[ cut here ]------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;kernel BUG at %s:%d!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|no_bug
suffix:colon
r_return
suffix:semicolon
multiline_comment|/* Here we know it was a BUG but file-n-line is unavailable */
id|bug
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Kernel BUG&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_static
r_struct
(brace
id|spinlock_t
id|lock
suffix:semicolon
id|u32
id|lock_owner
suffix:semicolon
r_int
id|lock_owner_depth
suffix:semicolon
)brace
id|die
op_assign
(brace
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|lock_owner
op_assign
op_minus
l_int|1
comma
dot
id|lock_owner_depth
op_assign
l_int|0
)brace
suffix:semicolon
r_static
r_int
id|die_counter
suffix:semicolon
r_if
c_cond
(paren
id|die.lock_owner
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die.lock
)paren
suffix:semicolon
id|die.lock_owner
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|die.lock_owner_depth
op_assign
l_int|0
suffix:semicolon
id|bust_spinlocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|die.lock_owner_depth
OL
l_int|3
)paren
(brace
r_int
id|nl
op_assign
l_int|0
suffix:semicolon
id|handle_BUG
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s: %04lx [#%d]&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
comma
op_increment
id|die_counter
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PREEMPT
id|printk
c_func
(paren
l_string|&quot;PREEMPT &quot;
)paren
suffix:semicolon
id|nl
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot;SMP &quot;
)paren
suffix:semicolon
id|nl
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DEBUG_PAGEALLOC
id|printk
c_func
(paren
l_string|&quot;DEBUG_PAGEALLOC&quot;
)paren
suffix:semicolon
id|nl
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nl
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|notify_die
c_func
(paren
id|DIE_OOPS
comma
(paren
r_char
op_star
)paren
id|str
comma
id|regs
comma
id|err
comma
l_int|255
comma
id|SIGSEGV
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Recursive die() failure, output suppressed&bslash;n&quot;
)paren
suffix:semicolon
id|bust_spinlocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|die.lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Fatal exception in interrupt&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|panic_on_oops
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Fatal exception: panic in 5 seconds&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Fatal exception&quot;
)paren
suffix:semicolon
)brace
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
op_logical_and
op_logical_neg
(paren
l_int|3
op_amp
id|regs-&gt;xcs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|get_cr2
r_static
r_inline
r_int
r_int
id|get_cr2
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* get the address */
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
r_return
id|address
suffix:semicolon
)brace
DECL|function|do_trap
r_static
r_inline
r_void
id|do_trap
c_func
(paren
r_int
id|trapnr
comma
r_int
id|signr
comma
r_char
op_star
id|str
comma
r_int
id|vm86
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
comma
id|siginfo_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
(brace
r_if
c_cond
(paren
id|vm86
)paren
r_goto
id|vm86_trap
suffix:semicolon
r_goto
id|trap_signal
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
)paren
r_goto
id|kernel_trap
suffix:semicolon
id|trap_signal
suffix:colon
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
id|trapnr
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
id|force_sig_info
c_func
(paren
id|signr
comma
id|info
comma
id|tsk
)paren
suffix:semicolon
r_else
id|force_sig
c_func
(paren
id|signr
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kernel_trap
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|fixup_exception
c_func
(paren
id|regs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|vm86_trap
suffix:colon
(brace
r_int
id|ret
op_assign
id|handle_vm86_trap
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
comma
id|trapnr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|trap_signal
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) &bslash;&n;&t;&t;&t;&t;&t;&t;== NOTIFY_STOP) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, 0, regs, error_code, NULL); &bslash;&n;}
DECL|macro|DO_ERROR_INFO
mdefine_line|#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;siginfo_t info; &bslash;&n;&t;info.si_signo = signr; &bslash;&n;&t;info.si_errno = 0; &bslash;&n;&t;info.si_code = sicode; &bslash;&n;&t;info.si_addr = (void __user *)siaddr; &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) &bslash;&n;&t;&t;&t;&t;&t;&t;== NOTIFY_STOP) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, 0, regs, error_code, &amp;info); &bslash;&n;}
DECL|macro|DO_VM86_ERROR
mdefine_line|#define DO_VM86_ERROR(trapnr, signr, str, name) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) &bslash;&n;&t;&t;&t;&t;&t;&t;== NOTIFY_STOP) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, 1, regs, error_code, NULL); &bslash;&n;}
DECL|macro|DO_VM86_ERROR_INFO
mdefine_line|#define DO_VM86_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;siginfo_t info; &bslash;&n;&t;info.si_signo = signr; &bslash;&n;&t;info.si_errno = 0; &bslash;&n;&t;info.si_code = sicode; &bslash;&n;&t;info.si_addr = (void __user *)siaddr; &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) &bslash;&n;&t;&t;&t;&t;&t;&t;== NOTIFY_STOP) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, 1, regs, error_code, &amp;info); &bslash;&n;}
id|DO_VM86_ERROR_INFO
c_func
(paren
l_int|0
comma
id|SIGFPE
comma
l_string|&quot;divide error&quot;
comma
id|divide_error
comma
id|FPE_INTDIV
comma
id|regs-&gt;eip
)paren
macro_line|#ifndef CONFIG_KPROBES
id|DO_VM86_ERROR
c_func
(paren
l_int|3
comma
id|SIGTRAP
comma
l_string|&quot;int3&quot;
comma
id|int3
)paren
macro_line|#endif
id|DO_VM86_ERROR
c_func
(paren
l_int|4
comma
id|SIGSEGV
comma
l_string|&quot;overflow&quot;
comma
id|overflow
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|5
comma
id|SIGSEGV
comma
l_string|&quot;bounds&quot;
comma
id|bounds
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|6
comma
id|SIGILL
comma
l_string|&quot;invalid operand&quot;
comma
id|invalid_op
comma
id|ILL_ILLOPN
comma
id|regs-&gt;eip
)paren
id|DO_ERROR
c_func
(paren
l_int|9
comma
id|SIGFPE
comma
l_string|&quot;coprocessor segment overrun&quot;
comma
id|coprocessor_segment_overrun
)paren
id|DO_ERROR
c_func
(paren
l_int|10
comma
id|SIGSEGV
comma
l_string|&quot;invalid TSS&quot;
comma
id|invalid_TSS
)paren
id|DO_ERROR
c_func
(paren
l_int|11
comma
id|SIGBUS
comma
l_string|&quot;segment not present&quot;
comma
id|segment_not_present
)paren
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGBUS
comma
l_string|&quot;stack segment&quot;
comma
id|stack_segment
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|17
comma
id|SIGBUS
comma
l_string|&quot;alignment check&quot;
comma
id|alignment_check
comma
id|BUS_ADRALN
comma
l_int|0
)paren
DECL|function|do_general_protection
id|asmlinkage
r_void
id|do_general_protection
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_struct
id|tss_struct
op_star
id|tss
op_assign
op_amp
id|per_cpu
c_func
(paren
id|init_tss
comma
id|cpu
)paren
suffix:semicolon
r_struct
id|thread_struct
op_star
id|thread
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
multiline_comment|/*&n;&t; * Perform the lazy TSS&squot;s I/O bitmap copy. If the TSS has an&n;&t; * invalid offset set (the LAZY one) and the faulting thread has&n;&t; * a valid I/O bitmap pointer, we copy the I/O bitmap in the TSS&n;&t; * and we set the offset field correctly. Then we let the CPU to&n;&t; * restart the faulting instruction.&n;&t; */
r_if
c_cond
(paren
id|tss-&gt;io_bitmap_base
op_eq
id|INVALID_IO_BITMAP_OFFSET_LAZY
op_logical_and
id|thread-&gt;io_bitmap_ptr
)paren
(brace
id|memcpy
c_func
(paren
id|tss-&gt;io_bitmap
comma
id|thread-&gt;io_bitmap_ptr
comma
id|thread-&gt;io_bitmap_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the previously set map was extending to higher ports&n;&t;&t; * than the current one, pad extra space with 0xff (no access).&n;&t;&t; */
r_if
c_cond
(paren
id|thread-&gt;io_bitmap_max
OL
id|tss-&gt;io_bitmap_max
)paren
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|tss-&gt;io_bitmap
op_plus
id|thread-&gt;io_bitmap_max
comma
l_int|0xff
comma
id|tss-&gt;io_bitmap_max
op_minus
id|thread-&gt;io_bitmap_max
)paren
suffix:semicolon
id|tss-&gt;io_bitmap_max
op_assign
id|thread-&gt;io_bitmap_max
suffix:semicolon
id|tss-&gt;io_bitmap_base
op_assign
id|IO_BITMAP_OFFSET
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|gp_in_vm86
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
)paren
r_goto
id|gp_in_kernel
suffix:semicolon
id|current-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
l_int|13
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_vm86
suffix:colon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_kernel
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|fixup_exception
c_func
(paren
id|regs
)paren
)paren
(brace
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_GPF
comma
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
comma
l_int|13
comma
id|SIGSEGV
)paren
op_eq
id|NOTIFY_STOP
)paren
suffix:semicolon
r_return
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_parity_error
r_static
r_void
id|mem_parity_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received. Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;You probably have a hardware problem with your RAM chips&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear and disable the memory parity error line. */
id|clear_mem_error
c_func
(paren
id|reason
)paren
suffix:semicolon
)brace
DECL|function|io_check_error
r_static
r_void
id|io_check_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI: IOCK error (debug interrupt?)&bslash;n&quot;
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Re-enable the IOCK line, wait for a few seconds */
id|reason
op_assign
(paren
id|reason
op_amp
l_int|0xf
)paren
op_or
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
id|i
op_assign
l_int|2000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|reason
op_and_assign
op_complement
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|unknown_nmi_error
r_static
r_void
id|unknown_nmi_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_MCA
multiline_comment|/* Might actually be able to figure out what the guilty party&n;&t;* is. */
r_if
c_cond
(paren
id|MCA_bus
)paren
(brace
id|mca_handle_nmi
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received for unknown reason %02x on CPU %d.&bslash;n&quot;
comma
id|reason
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Do you have a strange power saving mode enabled?&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|nmi_print_lock
r_static
id|spinlock_t
id|nmi_print_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|die_nmi
r_void
id|die_nmi
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|nmi_print_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* We are in trouble anyway, lets at least try&n;&t;* to get a message out.&n;&t;*/
id|bust_spinlocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; on CPU%d, eip %08lx, registers:&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|regs-&gt;eip
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;console shuts up ...&bslash;n&quot;
)paren
suffix:semicolon
id|console_silent
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nmi_print_lock
)paren
suffix:semicolon
id|bust_spinlocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|default_do_nmi
r_static
r_void
id|default_do_nmi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|reason
op_assign
id|get_nmi_reason
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reason
op_amp
l_int|0xc0
)paren
)paren
(brace
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_NMI_IPI
comma
l_string|&quot;nmi_ipi&quot;
comma
id|regs
comma
id|reason
comma
l_int|0
comma
id|SIGINT
)paren
op_eq
id|NOTIFY_STOP
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
multiline_comment|/*&n;&t;&t; * Ok, so this is none of the documented NMI sources,&n;&t;&t; * so it must be the NMI watchdog.&n;&t;&t; */
r_if
c_cond
(paren
id|nmi_watchdog
)paren
(brace
id|nmi_watchdog_tick
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|unknown_nmi_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_NMI
comma
l_string|&quot;nmi&quot;
comma
id|regs
comma
id|reason
comma
l_int|0
comma
id|SIGINT
)paren
op_eq
id|NOTIFY_STOP
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x80
)paren
id|mem_parity_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x40
)paren
id|io_check_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reassert NMI in case it became active meanwhile&n;&t; * as it&squot;s edge-triggered.&n;&t; */
id|reassert_nmi
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dummy_nmi_callback
r_static
r_int
id|dummy_nmi_callback
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|cpu
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nmi_callback
r_static
id|nmi_callback_t
id|nmi_callback
op_assign
id|dummy_nmi_callback
suffix:semicolon
DECL|function|do_nmi
id|asmlinkage
r_void
id|do_nmi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|nmi_enter
c_func
(paren
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
op_increment
id|nmi_count
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nmi_callback
c_func
(paren
id|regs
comma
id|cpu
)paren
)paren
id|default_do_nmi
c_func
(paren
id|regs
)paren
suffix:semicolon
id|nmi_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|set_nmi_callback
r_void
id|set_nmi_callback
c_func
(paren
id|nmi_callback_t
id|callback
)paren
(brace
id|nmi_callback
op_assign
id|callback
suffix:semicolon
)brace
DECL|function|unset_nmi_callback
r_void
id|unset_nmi_callback
c_func
(paren
r_void
)paren
(brace
id|nmi_callback
op_assign
id|dummy_nmi_callback
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KPROBES
DECL|function|do_int3
id|asmlinkage
r_int
id|do_int3
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_INT3
comma
l_string|&quot;int3&quot;
comma
id|regs
comma
id|error_code
comma
l_int|3
comma
id|SIGTRAP
)paren
op_eq
id|NOTIFY_STOP
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This is an interrupt gate, because kprobes wants interrupts&n;&t;disabled.  Normal trap handlers don&squot;t. */
id|restore_interrupts
c_func
(paren
id|regs
)paren
suffix:semicolon
id|do_trap
c_func
(paren
l_int|3
comma
id|SIGTRAP
comma
l_string|&quot;int3&quot;
comma
l_int|1
comma
id|regs
comma
id|error_code
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Our handling of the processor debug registers is non-trivial.&n; * We do not clear them on entry and exit from the kernel. Therefore&n; * it is possible to get a watchpoint trap here from inside the kernel.&n; * However, the code in ./ptrace.c has ensured that the user can&n; * only set watchpoints on userspace addresses. Therefore the in-kernel&n; * watchpoint trap can only occur in code which is reading/writing&n; * from user space. Such code must not hold kernel locks (since it&n; * can equally take a page fault), therefore it is safe to call&n; * force_sig_info even though that claims and releases locks.&n; * &n; * Code in ./signal.c ensures that the debug control register&n; * is restored before we deliver any signal, and therefore that&n; * user code runs with the correct debug control register even though&n; * we clear it here.&n; *&n; * Being careful here means that we don&squot;t have to be as careful in a&n; * lot of more complicated places (task switching can be a bit lazy&n; * about restoring all the debug state, and ptrace doesn&squot;t have to&n; * find every occurrence of the TF bit that could be saved away even&n; * by user code)&n; */
DECL|function|do_debug
id|asmlinkage
r_void
id|do_debug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_int
id|condition
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%db6,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|condition
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_DEBUG
comma
l_string|&quot;debug&quot;
comma
id|regs
comma
id|condition
comma
id|error_code
comma
id|SIGTRAP
)paren
op_eq
id|NOTIFY_STOP
)paren
r_return
suffix:semicolon
multiline_comment|/* It&squot;s safe to allow irq&squot;s after DR6 has been saved */
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|X86_EFLAGS_IF
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Mask out spurious debug traps due to lazy DR7 setting */
r_if
c_cond
(paren
id|condition
op_amp
(paren
id|DR_TRAP0
op_or
id|DR_TRAP1
op_or
id|DR_TRAP2
op_or
id|DR_TRAP3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;thread.debugreg
(braket
l_int|7
)braket
)paren
r_goto
id|clear_dr7
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|debug_vm86
suffix:semicolon
multiline_comment|/* Save debug status register where ptrace can see it */
id|tsk-&gt;thread.debugreg
(braket
l_int|6
)braket
op_assign
id|condition
suffix:semicolon
multiline_comment|/* Mask out spurious TF errors due to lazy TF clearing */
r_if
c_cond
(paren
id|condition
op_amp
id|DR_STEP
)paren
(brace
multiline_comment|/*&n;&t;&t; * The TF error should be masked out only if the current&n;&t;&t; * process is not traced and if the TRAP flag has been set&n;&t;&t; * previously by a tracing process (condition detected by&n;&t;&t; * the PT_DTRACE flag); remember that the i386 TRAP flag&n;&t;&t; * can be modified by the process itself in user mode,&n;&t;&t; * allowing programs to debug themselves without the ptrace()&n;&t;&t; * interface.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
r_goto
id|clear_TF_reenable
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tsk-&gt;ptrace
op_amp
(paren
id|PT_DTRACE
op_or
id|PT_PTRACED
)paren
)paren
op_eq
id|PT_DTRACE
)paren
r_goto
id|clear_TF
suffix:semicolon
)brace
multiline_comment|/* Ok, finally something we can handle */
id|tsk-&gt;thread.trap_no
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|info.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
multiline_comment|/* If this is a kernel mode trap, save the user PC on entry to &n;&t; * the kernel, that&squot;s what the debugger can make sense of.&n;&t; */
id|info.si_addr
op_assign
(paren
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
ques
c_cond
(paren
r_void
id|__user
op_star
)paren
id|tsk-&gt;thread.eip
suffix:colon
(paren
r_void
id|__user
op_star
)paren
id|regs-&gt;eip
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|info
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* Disable additional traps. They&squot;ll be re-enabled when&n;&t; * the signal is delivered.&n;&t; */
id|clear_dr7
suffix:colon
id|__asm__
c_func
(paren
l_string|&quot;movl %0,%%db7&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|debug_vm86
suffix:colon
id|handle_vm86_trap
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
id|clear_TF_reenable
suffix:colon
id|set_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_SINGLESTEP
)paren
suffix:semicolon
id|clear_TF
suffix:colon
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we play around with the &squot;TS&squot; bit in an attempt to get&n; * the correct behaviour even in the presence of the asynchronous&n; * IRQ13 behaviour&n; */
DECL|function|math_error
r_void
id|math_error
c_func
(paren
r_void
id|__user
op_star
id|eip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|cwd
comma
id|swd
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|16
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|eip
suffix:semicolon
multiline_comment|/*&n;&t; * (~cwd &amp; swd) will mask out exceptions that are not set to unmasked&n;&t; * status.  0x3f is the exception bits in these regs, 0x200 is the&n;&t; * C1 reg you need in case of a stack fault, 0x040 is the stack&n;&t; * fault bit.  We should only be taking one exception at a time,&n;&t; * so if this combination doesn&squot;t produce any single exception,&n;&t; * then we have a bad program that isn&squot;t syncronizing its FPU usage&n;&t; * and it will suffer the consequences since we won&squot;t be able to&n;&t; * fully reproduce the context of the exception&n;&t; */
id|cwd
op_assign
id|get_fpu_cwd
c_func
(paren
id|task
)paren
suffix:semicolon
id|swd
op_assign
id|get_fpu_swd
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
op_complement
id|cwd
)paren
op_amp
id|swd
op_amp
l_int|0x3f
)paren
op_or
(paren
id|swd
op_amp
l_int|0x240
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
r_case
l_int|0x041
suffix:colon
multiline_comment|/* Stack Fault */
r_case
l_int|0x241
suffix:colon
multiline_comment|/* Stack Fault | Direction */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
multiline_comment|/* Should we clear the SF or let user space do it ???? */
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_coprocessor_error
id|asmlinkage
r_void
id|do_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|ignore_fpu_irq
op_assign
l_int|1
suffix:semicolon
id|math_error
c_func
(paren
(paren
r_void
id|__user
op_star
)paren
id|regs-&gt;eip
)paren
suffix:semicolon
)brace
DECL|function|simd_math_error
r_void
id|simd_math_error
c_func
(paren
r_void
id|__user
op_star
id|eip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|mxcsr
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|19
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|eip
suffix:semicolon
multiline_comment|/*&n;&t; * The SIMD FPU exceptions are handled a little differently, as there&n;&t; * is only a single status/control register.  Thus, to determine which&n;&t; * unmasked exception was caught we must mask the exception mask bits&n;&t; * at 0x1f80, and then use these to mask the exception bits at 0x3f.&n;&t; */
id|mxcsr
op_assign
id|get_fpu_mxcsr
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_complement
(paren
(paren
id|mxcsr
op_amp
l_int|0x1f80
)paren
op_rshift
l_int|7
)paren
op_amp
(paren
id|mxcsr
op_amp
l_int|0x3f
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_simd_coprocessor_error
id|asmlinkage
r_void
id|do_simd_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_xmm
)paren
(brace
multiline_comment|/* Handle SIMD FPU exceptions on PIII+ processors. */
id|ignore_fpu_irq
op_assign
l_int|1
suffix:semicolon
id|simd_math_error
c_func
(paren
(paren
r_void
id|__user
op_star
)paren
id|regs-&gt;eip
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Handle strange cache flush from user space exception&n;&t;&t; * in all other cases.  This is undocumented behaviour.&n;&t;&t; */
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
(brace
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;cache flush denied&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
l_int|19
suffix:semicolon
id|current-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_spurious_interrupt_bug
id|asmlinkage
r_void
id|do_spurious_interrupt_bug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
macro_line|#if 0
multiline_comment|/* No need to warn about this any longer. */
id|printk
c_func
(paren
l_string|&quot;Ignoring P6 Local APIC Spurious Interrupt Bug...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; *&n; * Must be called with kernel preemption disabled (in this case,&n; * local interrupts are disabled at the call-site in entry.S).&n; */
DECL|function|math_state_restore
id|asmlinkage
r_void
id|math_state_restore
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_struct
id|thread_info
op_star
id|thread
op_assign
id|current_thread_info
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|thread-&gt;task
suffix:semicolon
id|clts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allow maths ops (or we recurse) */
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;used_math
)paren
id|init_fpu
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|restore_fpu
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|thread-&gt;status
op_or_assign
id|TS_USEDFPU
suffix:semicolon
multiline_comment|/* So we fnsave on switch_to() */
)brace
macro_line|#ifndef CONFIG_MATH_EMULATION
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_int
id|arg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;math-emulation not enabled and no coprocessor found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;killing %s.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MATH_EMULATION */
macro_line|#ifdef CONFIG_X86_F00F_BUG
DECL|function|trap_init_f00f_bug
r_void
id|__init
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
(brace
id|__set_fixmap
c_func
(paren
id|FIX_F00F_IDT
comma
id|__pa
c_func
(paren
op_amp
id|idt_table
)paren
comma
id|PAGE_KERNEL_RO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the IDT descriptor and reload the IDT so that&n;&t; * it uses the read-only mapped virtual address.&n;&t; */
id|idt_descr.address
op_assign
id|fix_to_virt
c_func
(paren
id|FIX_F00F_IDT
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|idt_descr
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|_set_gate
mdefine_line|#define _set_gate(gate_addr,type,dpl,addr,seg) &bslash;&n;do { &bslash;&n;  int __d0, __d1; &bslash;&n;  __asm__ __volatile__ (&quot;movw %%dx,%%ax&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movw %4,%%dx&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%eax,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%edx,%1&quot; &bslash;&n;&t;:&quot;=m&quot; (*((long *) (gate_addr))), &bslash;&n;&t; &quot;=m&quot; (*(1+(long *) (gate_addr))), &quot;=&amp;a&quot; (__d0), &quot;=&amp;d&quot; (__d1) &bslash;&n;&t;:&quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), &bslash;&n;&t; &quot;3&quot; ((char *) (addr)),&quot;2&quot; ((seg) &lt;&lt; 16)); &bslash;&n;} while (0)
multiline_comment|/*&n; * This needs to use &squot;idt_table&squot; rather than &squot;idt&squot;, and&n; * thus use the _nonmapped_ version of the IDT, as the&n; * Pentium F0 0F bugfix can have resulted in the mapped&n; * IDT being write-protected.&n; */
DECL|function|set_intr_gate
r_void
id|set_intr_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|14
comma
l_int|0
comma
id|addr
comma
id|__KERNEL_CS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine sets up an interrupt gate at directory privilege level 3.&n; */
DECL|function|set_system_intr_gate
r_static
r_inline
r_void
id|set_system_intr_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|14
comma
l_int|3
comma
id|addr
comma
id|__KERNEL_CS
)paren
suffix:semicolon
)brace
DECL|function|set_trap_gate
r_static
r_void
id|__init
id|set_trap_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|0
comma
id|addr
comma
id|__KERNEL_CS
)paren
suffix:semicolon
)brace
DECL|function|set_system_gate
r_static
r_void
id|__init
id|set_system_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|3
comma
id|addr
comma
id|__KERNEL_CS
)paren
suffix:semicolon
)brace
DECL|function|set_call_gate
r_static
r_void
id|__init
id|set_call_gate
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|a
comma
l_int|12
comma
l_int|3
comma
id|addr
comma
id|__KERNEL_CS
)paren
suffix:semicolon
)brace
DECL|function|set_task_gate
r_static
r_void
id|__init
id|set_task_gate
c_func
(paren
r_int
r_int
id|n
comma
r_int
r_int
id|gdt_entry
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|5
comma
l_int|0
comma
l_int|0
comma
(paren
id|gdt_entry
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_EISA
r_if
c_cond
(paren
id|isa_readl
c_func
(paren
l_int|0x0FFFD9
)paren
op_eq
l_char|&squot;E&squot;
op_plus
(paren
l_char|&squot;I&squot;
op_lshift
l_int|8
)paren
op_plus
(paren
l_char|&squot;S&squot;
op_lshift
l_int|16
)paren
op_plus
(paren
l_char|&squot;A&squot;
op_lshift
l_int|24
)paren
)paren
(brace
id|EISA_bus
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
id|init_apic_mappings
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|set_trap_gate
c_func
(paren
l_int|0
comma
op_amp
id|divide_error
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|1
comma
op_amp
id|debug
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|2
comma
op_amp
id|nmi
)paren
suffix:semicolon
id|set_system_intr_gate
c_func
(paren
l_int|3
comma
op_amp
id|int3
)paren
suffix:semicolon
multiline_comment|/* int3-5 can be called from all */
id|set_system_gate
c_func
(paren
l_int|4
comma
op_amp
id|overflow
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|5
comma
op_amp
id|bounds
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|6
comma
op_amp
id|invalid_op
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|7
comma
op_amp
id|device_not_available
)paren
suffix:semicolon
id|set_task_gate
c_func
(paren
l_int|8
comma
id|GDT_ENTRY_DOUBLEFAULT_TSS
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|9
comma
op_amp
id|coprocessor_segment_overrun
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|10
comma
op_amp
id|invalid_TSS
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|11
comma
op_amp
id|segment_not_present
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|12
comma
op_amp
id|stack_segment
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|13
comma
op_amp
id|general_protection
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|14
comma
op_amp
id|page_fault
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|15
comma
op_amp
id|spurious_interrupt_bug
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|16
comma
op_amp
id|coprocessor_error
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|17
comma
op_amp
id|alignment_check
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_MCE
id|set_trap_gate
c_func
(paren
l_int|18
comma
op_amp
id|machine_check
)paren
suffix:semicolon
macro_line|#endif
id|set_trap_gate
c_func
(paren
l_int|19
comma
op_amp
id|simd_coprocessor_error
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
id|SYSCALL_VECTOR
comma
op_amp
id|system_call
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * default LDT is a single-entry callgate to lcall7 for iBCS&n;&t; * and a callgate to lcall27 for Solaris/x86 binaries&n;&t; */
id|set_call_gate
c_func
(paren
op_amp
id|default_ldt
(braket
l_int|0
)braket
comma
id|lcall7
)paren
suffix:semicolon
id|set_call_gate
c_func
(paren
op_amp
id|default_ldt
(braket
l_int|4
)braket
comma
id|lcall27
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Should be a barrier for any external CPU state.&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
id|trap_init_hook
c_func
(paren
)paren
suffix:semicolon
)brace
eof
