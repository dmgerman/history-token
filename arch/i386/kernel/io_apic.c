multiline_comment|/*&n; *&t;Intel IO-APIC support for multi-Pentium hosts.&n; *&n; *&t;Copyright (C) 1997, 1998, 1999, 2000 Ingo Molnar, Hajnalka Szabo&n; *&n; *&t;Many thanks to Stig Venaas for trying out countless experimental&n; *&t;patches and reporting/debugging problems patiently!&n; *&n; *&t;(c) 1999, Multiple IO-APIC support, developed by&n; *&t;Ken-ichi Yaku &lt;yaku@css1.kbnes.nec.co.jp&gt; and&n; *      Hidemi Kishimoto &lt;kisimoto@css1.kbnes.nec.co.jp&gt;,&n; *&t;further tested and cleaned up by Zach Brown &lt;zab@redhat.com&gt;&n; *&t;and Ingo Molnar &lt;mingo@redhat.com&gt;&n; *&n; *&t;Fixes&n; *&t;Maciej W. Rozycki&t;:&t;Bits for genuine 82489DX APICs;&n; *&t;&t;&t;&t;&t;thanks to Eric Gilmore&n; *&t;&t;&t;&t;&t;and Rolf G. Tews&n; *&t;&t;&t;&t;&t;for testing these extensively&n; *&t;Paul Diefenbaugh&t;:&t;Added full ACPI support&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;mach_apic.h&gt;
macro_line|#include &quot;io_ports.h&quot;
DECL|variable|ioapic_lock
r_static
id|spinlock_t
id|ioapic_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *&t;Is the SiS APIC rmw bug present ?&n; *&t;-1 = don&squot;t know, 0 = no, 1 = yes&n; */
DECL|variable|sis_apic_bug
r_int
id|sis_apic_bug
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * # of IRQ routing registers&n; */
DECL|variable|nr_ioapic_registers
r_int
id|nr_ioapic_registers
(braket
id|MAX_IO_APICS
)braket
suffix:semicolon
multiline_comment|/*&n; * Rough estimation of how many shared IRQs there are, can&n; * be changed anytime.&n; */
DECL|macro|MAX_PLUS_SHARED_IRQS
mdefine_line|#define MAX_PLUS_SHARED_IRQS NR_IRQS
DECL|macro|PIN_MAP_SIZE
mdefine_line|#define PIN_MAP_SIZE (MAX_PLUS_SHARED_IRQS + NR_IRQS)
multiline_comment|/*&n; * This is performance-critical, we want to do it O(1)&n; *&n; * the indexing order of this array favors 1:1 mappings&n; * between pins and IRQs.&n; */
DECL|struct|irq_pin_list
r_static
r_struct
id|irq_pin_list
(brace
DECL|member|apic
DECL|member|pin
DECL|member|next
r_int
id|apic
comma
id|pin
comma
id|next
suffix:semicolon
DECL|variable|irq_2_pin
)brace
id|irq_2_pin
(braket
id|PIN_MAP_SIZE
)braket
suffix:semicolon
DECL|variable|vector_irq
r_int
id|vector_irq
(braket
id|NR_VECTORS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_VECTORS
op_minus
l_int|1
)braket
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PCI_USE_VECTOR
DECL|macro|vector_to_irq
mdefine_line|#define vector_to_irq(vector) &t;&bslash;&n;&t;(platform_legacy_irq(vector) ? vector : vector_irq[vector])
macro_line|#else
DECL|macro|vector_to_irq
mdefine_line|#define vector_to_irq(vector)&t;(vector)
macro_line|#endif
multiline_comment|/*&n; * The common case is 1:1 IRQ&lt;-&gt;pin mappings. Sometimes there are&n; * shared ISA-space IRQs, so we have to support them. We are super&n; * fast in the common case, and fast for shared ISA-space IRQs.&n; */
DECL|function|add_pin_to_irq
r_static
r_void
id|__init
id|add_pin_to_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|apic
comma
r_int
id|pin
)paren
(brace
r_static
r_int
id|first_free_entry
op_assign
id|NR_IRQS
suffix:semicolon
r_struct
id|irq_pin_list
op_star
id|entry
op_assign
id|irq_2_pin
op_plus
id|irq
suffix:semicolon
r_while
c_loop
(paren
id|entry-&gt;next
)paren
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;pin
op_ne
op_minus
l_int|1
)paren
(brace
id|entry-&gt;next
op_assign
id|first_free_entry
suffix:semicolon
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|first_free_entry
op_ge
id|PIN_MAP_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;io_apic.c: whoops&quot;
)paren
suffix:semicolon
)brace
id|entry-&gt;apic
op_assign
id|apic
suffix:semicolon
id|entry-&gt;pin
op_assign
id|pin
suffix:semicolon
)brace
multiline_comment|/*&n; * Reroute an IRQ to a different pin.&n; */
DECL|function|replace_pin_at_irq
r_static
r_void
id|__init
id|replace_pin_at_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|oldapic
comma
r_int
id|oldpin
comma
r_int
id|newapic
comma
r_int
id|newpin
)paren
(brace
r_struct
id|irq_pin_list
op_star
id|entry
op_assign
id|irq_2_pin
op_plus
id|irq
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;apic
op_eq
id|oldapic
op_logical_and
id|entry-&gt;pin
op_eq
id|oldpin
)paren
(brace
id|entry-&gt;apic
op_assign
id|newapic
suffix:semicolon
id|entry-&gt;pin
op_assign
id|newpin
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;next
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|__modify_IO_APIC_irq
r_static
r_void
id|__modify_IO_APIC_irq
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|enable
comma
r_int
r_int
id|disable
)paren
(brace
r_struct
id|irq_pin_list
op_star
id|entry
op_assign
id|irq_2_pin
op_plus
id|irq
suffix:semicolon
r_int
r_int
id|pin
comma
id|reg
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pin
op_assign
id|entry-&gt;pin
suffix:semicolon
r_if
c_cond
(paren
id|pin
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
id|reg
op_assign
id|io_apic_read
c_func
(paren
id|entry-&gt;apic
comma
l_int|0x10
op_plus
id|pin
op_star
l_int|2
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
id|disable
suffix:semicolon
id|reg
op_or_assign
id|enable
suffix:semicolon
id|io_apic_modify
c_func
(paren
id|entry-&gt;apic
comma
l_int|0x10
op_plus
id|pin
op_star
l_int|2
comma
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;next
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* mask = 1 */
DECL|function|__mask_IO_APIC_irq
r_static
r_void
id|__mask_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|__modify_IO_APIC_irq
c_func
(paren
id|irq
comma
l_int|0x00010000
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* mask = 0 */
DECL|function|__unmask_IO_APIC_irq
r_static
r_void
id|__unmask_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|__modify_IO_APIC_irq
c_func
(paren
id|irq
comma
l_int|0
comma
l_int|0x00010000
)paren
suffix:semicolon
)brace
multiline_comment|/* mask = 1, trigger = 0 */
DECL|function|__mask_and_edge_IO_APIC_irq
r_static
r_void
id|__mask_and_edge_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|__modify_IO_APIC_irq
c_func
(paren
id|irq
comma
l_int|0x00010000
comma
l_int|0x00008000
)paren
suffix:semicolon
)brace
multiline_comment|/* mask = 0, trigger = 1 */
DECL|function|__unmask_and_level_IO_APIC_irq
r_static
r_void
id|__unmask_and_level_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|__modify_IO_APIC_irq
c_func
(paren
id|irq
comma
l_int|0x00008000
comma
l_int|0x00010000
)paren
suffix:semicolon
)brace
DECL|function|mask_IO_APIC_irq
r_static
r_void
id|mask_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|__mask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|unmask_IO_APIC_irq
r_static
r_void
id|unmask_IO_APIC_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|__unmask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|clear_IO_APIC_pin
r_void
id|clear_IO_APIC_pin
c_func
(paren
r_int
r_int
id|apic
comma
r_int
r_int
id|pin
)paren
(brace
r_struct
id|IO_APIC_route_entry
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Check delivery_mode to be sure we&squot;re not clearing an SMI pin */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.delivery_mode
op_eq
id|dest_SMI
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Disable it in the IO-APIC irq-routing table:&n;&t; */
id|memset
c_func
(paren
op_amp
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
id|entry.mask
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|apic
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|apic
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|clear_IO_APIC
r_static
r_void
id|clear_IO_APIC
(paren
r_void
)paren
(brace
r_int
id|apic
comma
id|pin
suffix:semicolon
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
r_for
c_loop
(paren
id|pin
op_assign
l_int|0
suffix:semicolon
id|pin
OL
id|nr_ioapic_registers
(braket
id|apic
)braket
suffix:semicolon
id|pin
op_increment
)paren
id|clear_IO_APIC_pin
c_func
(paren
id|apic
comma
id|pin
)paren
suffix:semicolon
)brace
DECL|function|set_ioapic_affinity_irq
r_static
r_void
id|set_ioapic_affinity_irq
c_func
(paren
r_int
r_int
id|irq
comma
id|cpumask_t
id|cpumask
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pin
suffix:semicolon
r_struct
id|irq_pin_list
op_star
id|entry
op_assign
id|irq_2_pin
op_plus
id|irq
suffix:semicolon
r_int
r_int
id|apicid_value
suffix:semicolon
id|apicid_value
op_assign
id|cpu_mask_to_apicid
c_func
(paren
id|mk_cpumask_const
c_func
(paren
id|cpumask
)paren
)paren
suffix:semicolon
multiline_comment|/* Prepare to do the io_apic_write */
id|apicid_value
op_assign
id|apicid_value
op_lshift
l_int|24
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pin
op_assign
id|entry-&gt;pin
suffix:semicolon
r_if
c_cond
(paren
id|pin
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
id|io_apic_write
c_func
(paren
id|entry-&gt;apic
comma
l_int|0x10
op_plus
l_int|1
op_plus
id|pin
op_star
l_int|2
comma
id|apicid_value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;next
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_IRQBALANCE)
macro_line|# include &lt;asm/processor.h&gt;&t;/* kernel_thread() */
macro_line|# include &lt;linux/kernel_stat.h&gt;&t;/* kstat */
macro_line|# include &lt;linux/slab.h&gt;&t;&t;/* kmalloc() */
macro_line|# include &lt;linux/timer.h&gt;&t;/* time_after() */
macro_line|# ifdef CONFIG_BALANCED_IRQ_DEBUG
DECL|macro|TDprintk
macro_line|#  define TDprintk(x...) do { printk(&quot;&lt;%ld:%s:%d&gt;: &quot;, jiffies, __FILE__, __LINE__); printk(x); } while (0)
DECL|macro|Dprintk
macro_line|#  define Dprintk(x...) do { TDprintk(x); } while (0)
macro_line|# else
DECL|macro|TDprintk
macro_line|#  define TDprintk(x...) 
DECL|macro|Dprintk
macro_line|#  define Dprintk(x...) 
macro_line|# endif
r_extern
id|cpumask_t
id|irq_affinity
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|variable|pending_irq_balance_cpumask
id|cpumask_t
id|__cacheline_aligned
id|pending_irq_balance_cpumask
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|macro|IRQBALANCE_CHECK_ARCH
mdefine_line|#define IRQBALANCE_CHECK_ARCH -999
DECL|variable|irqbalance_disabled
r_static
r_int
id|irqbalance_disabled
op_assign
id|IRQBALANCE_CHECK_ARCH
suffix:semicolon
DECL|variable|physical_balance
r_static
r_int
id|physical_balance
op_assign
l_int|0
suffix:semicolon
DECL|struct|irq_cpu_info
r_struct
id|irq_cpu_info
(brace
DECL|member|last_irq
r_int
r_int
op_star
id|last_irq
suffix:semicolon
DECL|member|irq_delta
r_int
r_int
op_star
id|irq_delta
suffix:semicolon
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
DECL|variable|irq_cpu_data
)brace
id|irq_cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|CPU_IRQ
mdefine_line|#define CPU_IRQ(cpu)&t;&t;(irq_cpu_data[cpu].irq)
DECL|macro|LAST_CPU_IRQ
mdefine_line|#define LAST_CPU_IRQ(cpu,irq)   (irq_cpu_data[cpu].last_irq[irq])
DECL|macro|IRQ_DELTA
mdefine_line|#define IRQ_DELTA(cpu,irq) &t;(irq_cpu_data[cpu].irq_delta[irq])
DECL|macro|IDLE_ENOUGH
mdefine_line|#define IDLE_ENOUGH(cpu,now) &bslash;&n;&t;&t;(idle_cpu(cpu) &amp;&amp; ((now) - irq_stat[(cpu)].idle_timestamp &gt; 1))
DECL|macro|IRQ_ALLOWED
mdefine_line|#define IRQ_ALLOWED(cpu, allowed_mask)&t;cpu_isset(cpu, allowed_mask)
DECL|macro|CPU_TO_PACKAGEINDEX
mdefine_line|#define CPU_TO_PACKAGEINDEX(i) (first_cpu(cpu_sibling_map[i]))
DECL|macro|MAX_BALANCED_IRQ_INTERVAL
mdefine_line|#define MAX_BALANCED_IRQ_INTERVAL&t;(5*HZ)
DECL|macro|MIN_BALANCED_IRQ_INTERVAL
mdefine_line|#define MIN_BALANCED_IRQ_INTERVAL&t;(HZ/2)
DECL|macro|BALANCED_IRQ_MORE_DELTA
mdefine_line|#define BALANCED_IRQ_MORE_DELTA&t;&t;(HZ/10)
DECL|macro|BALANCED_IRQ_LESS_DELTA
mdefine_line|#define BALANCED_IRQ_LESS_DELTA&t;&t;(HZ)
DECL|variable|balanced_irq_interval
r_int
id|balanced_irq_interval
op_assign
id|MAX_BALANCED_IRQ_INTERVAL
suffix:semicolon
DECL|function|move
r_static
r_int
r_int
id|move
c_func
(paren
r_int
id|curr_cpu
comma
id|cpumask_t
id|allowed_mask
comma
r_int
r_int
id|now
comma
r_int
id|direction
)paren
(brace
r_int
id|search_idle
op_assign
l_int|1
suffix:semicolon
r_int
id|cpu
op_assign
id|curr_cpu
suffix:semicolon
r_goto
id|inside
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cpu
op_eq
id|curr_cpu
)paren
)paren
id|search_idle
op_assign
l_int|0
suffix:semicolon
id|inside
suffix:colon
r_if
c_cond
(paren
id|direction
op_eq
l_int|1
)paren
(brace
id|cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ge
id|NR_CPUS
)paren
id|cpu
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cpu
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
op_minus
l_int|1
)paren
id|cpu
op_assign
id|NR_CPUS
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
op_logical_or
op_logical_neg
id|IRQ_ALLOWED
c_func
(paren
id|cpu
comma
id|allowed_mask
)paren
op_logical_or
(paren
id|search_idle
op_logical_and
op_logical_neg
id|IDLE_ENOUGH
c_func
(paren
id|cpu
comma
id|now
)paren
)paren
)paren
suffix:semicolon
r_return
id|cpu
suffix:semicolon
)brace
DECL|function|balance_irq
r_static
r_inline
r_void
id|balance_irq
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|cpumask_t
id|allowed_mask
suffix:semicolon
r_int
r_int
id|new_cpu
suffix:semicolon
r_if
c_cond
(paren
id|irqbalance_disabled
)paren
r_return
suffix:semicolon
id|cpus_and
c_func
(paren
id|allowed_mask
comma
id|cpu_online_map
comma
id|irq_affinity
(braket
id|irq
)braket
)paren
suffix:semicolon
id|new_cpu
op_assign
id|move
c_func
(paren
id|cpu
comma
id|allowed_mask
comma
id|now
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ne
id|new_cpu
)paren
(brace
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_desc
op_plus
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pending_irq_balance_cpumask
(braket
id|irq
)braket
op_assign
id|cpumask_of_cpu
c_func
(paren
id|new_cpu
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|rotate_irqs_among_cpus
r_static
r_inline
r_void
id|rotate_irqs_among_cpus
c_func
(paren
r_int
r_int
id|useful_load_threshold
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Rotating IRQs among CPUs.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|cpu_online
c_func
(paren
id|i
)paren
op_logical_and
(paren
id|j
OL
id|NR_IRQS
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_desc
(braket
id|j
)braket
dot
id|action
)paren
r_continue
suffix:semicolon
multiline_comment|/* Is it a significant load ?  */
r_if
c_cond
(paren
id|IRQ_DELTA
c_func
(paren
id|CPU_TO_PACKAGEINDEX
c_func
(paren
id|i
)paren
comma
id|j
)paren
OL
id|useful_load_threshold
)paren
r_continue
suffix:semicolon
id|balance_irq
c_func
(paren
id|i
comma
id|j
)paren
suffix:semicolon
)brace
)brace
id|balanced_irq_interval
op_assign
id|max
c_func
(paren
(paren
r_int
)paren
id|MIN_BALANCED_IRQ_INTERVAL
comma
id|balanced_irq_interval
op_minus
id|BALANCED_IRQ_LESS_DELTA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|do_irq_balance
r_static
r_void
id|do_irq_balance
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|max_cpu_irq
op_assign
l_int|0
comma
id|min_cpu_irq
op_assign
(paren
op_complement
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|move_this_load
op_assign
l_int|0
suffix:semicolon
r_int
id|max_loaded
op_assign
l_int|0
comma
id|min_loaded
op_assign
l_int|0
suffix:semicolon
r_int
id|load
suffix:semicolon
r_int
r_int
id|useful_load_threshold
op_assign
id|balanced_irq_interval
op_plus
l_int|10
suffix:semicolon
r_int
id|selected_irq
suffix:semicolon
r_int
id|tmp_loaded
comma
id|first_attempt
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|tmp_cpu_irq
suffix:semicolon
r_int
r_int
id|imbalance
op_assign
l_int|0
suffix:semicolon
id|cpumask_t
id|allowed_mask
comma
id|target_cpu_mask
comma
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|package_index
suffix:semicolon
id|CPU_IRQ
c_func
(paren
id|i
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|package_index
op_assign
id|CPU_TO_PACKAGEINDEX
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_IRQS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
r_int
id|value_now
comma
id|delta
suffix:semicolon
multiline_comment|/* Is this an active IRQ? */
r_if
c_cond
(paren
op_logical_neg
id|irq_desc
(braket
id|j
)braket
dot
id|action
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|package_index
op_eq
id|i
)paren
id|IRQ_DELTA
c_func
(paren
id|package_index
comma
id|j
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Determine the total count per processor per IRQ */
id|value_now
op_assign
(paren
r_int
r_int
)paren
id|kstat_cpu
c_func
(paren
id|i
)paren
dot
id|irqs
(braket
id|j
)braket
suffix:semicolon
multiline_comment|/* Determine the activity per processor per IRQ */
id|delta
op_assign
id|value_now
op_minus
id|LAST_CPU_IRQ
c_func
(paren
id|i
comma
id|j
)paren
suffix:semicolon
multiline_comment|/* Update last_cpu_irq[][] for the next time */
id|LAST_CPU_IRQ
c_func
(paren
id|i
comma
id|j
)paren
op_assign
id|value_now
suffix:semicolon
multiline_comment|/* Ignore IRQs whose rate is less than the clock */
r_if
c_cond
(paren
id|delta
OL
id|useful_load_threshold
)paren
r_continue
suffix:semicolon
multiline_comment|/* update the load for the processor or package total */
id|IRQ_DELTA
c_func
(paren
id|package_index
comma
id|j
)paren
op_add_assign
id|delta
suffix:semicolon
multiline_comment|/* Keep track of the higher numbered sibling as well */
r_if
c_cond
(paren
id|i
op_ne
id|package_index
)paren
id|CPU_IRQ
c_func
(paren
id|i
)paren
op_add_assign
id|delta
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We have sibling A and sibling B in the package&n;&t;&t;&t; *&n;&t;&t;&t; * cpu_irq[A] = load for cpu A + load for cpu B&n;&t;&t;&t; * cpu_irq[B] = load for cpu B&n;&t;&t;&t; */
id|CPU_IRQ
c_func
(paren
id|package_index
)paren
op_add_assign
id|delta
suffix:semicolon
)brace
)brace
multiline_comment|/* Find the least loaded processor package */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CPU_TO_PACKAGEINDEX
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|min_cpu_irq
OG
id|CPU_IRQ
c_func
(paren
id|i
)paren
)paren
(brace
id|min_cpu_irq
op_assign
id|CPU_IRQ
c_func
(paren
id|i
)paren
suffix:semicolon
id|min_loaded
op_assign
id|i
suffix:semicolon
)brace
)brace
id|max_cpu_irq
op_assign
id|ULONG_MAX
suffix:semicolon
id|tryanothercpu
suffix:colon
multiline_comment|/* Look for heaviest loaded processor.&n;&t; * We may come back to get the next heaviest loaded processor.&n;&t; * Skip processors with trivial loads.&n;&t; */
id|tmp_cpu_irq
op_assign
l_int|0
suffix:semicolon
id|tmp_loaded
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CPU_TO_PACKAGEINDEX
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|max_cpu_irq
op_le
id|CPU_IRQ
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tmp_cpu_irq
OL
id|CPU_IRQ
c_func
(paren
id|i
)paren
)paren
(brace
id|tmp_cpu_irq
op_assign
id|CPU_IRQ
c_func
(paren
id|i
)paren
suffix:semicolon
id|tmp_loaded
op_assign
id|i
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tmp_loaded
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* In the case of small number of heavy interrupt sources, &n;&t;  * loading some of the cpus too much. We use Ingo&squot;s original &n;&t;  * approach to rotate them around.&n;&t;  */
r_if
c_cond
(paren
op_logical_neg
id|first_attempt
op_logical_and
id|imbalance
op_ge
id|useful_load_threshold
)paren
(brace
id|rotate_irqs_among_cpus
c_func
(paren
id|useful_load_threshold
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_goto
id|not_worth_the_effort
suffix:semicolon
)brace
id|first_attempt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* heaviest search */
id|max_cpu_irq
op_assign
id|tmp_cpu_irq
suffix:semicolon
multiline_comment|/* load */
id|max_loaded
op_assign
id|tmp_loaded
suffix:semicolon
multiline_comment|/* processor */
id|imbalance
op_assign
(paren
id|max_cpu_irq
op_minus
id|min_cpu_irq
)paren
op_div
l_int|2
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;max_loaded cpu = %d&bslash;n&quot;
comma
id|max_loaded
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;min_loaded cpu = %d&bslash;n&quot;
comma
id|min_loaded
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;max_cpu_irq load = %ld&bslash;n&quot;
comma
id|max_cpu_irq
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;min_cpu_irq load = %ld&bslash;n&quot;
comma
id|min_cpu_irq
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;load imbalance = %lu&bslash;n&quot;
comma
id|imbalance
)paren
suffix:semicolon
multiline_comment|/* if imbalance is less than approx 10% of max load, then&n;&t; * observe diminishing returns action. - quit&n;&t; */
r_if
c_cond
(paren
id|imbalance
OL
(paren
id|max_cpu_irq
op_rshift
l_int|3
)paren
)paren
(brace
id|Dprintk
c_func
(paren
l_string|&quot;Imbalance too trivial&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|not_worth_the_effort
suffix:semicolon
)brace
id|tryanotherirq
suffix:colon
multiline_comment|/* if we select an IRQ to move that can&squot;t go where we want, then&n;&t; * see if there is another one to try.&n;&t; */
id|move_this_load
op_assign
l_int|0
suffix:semicolon
id|selected_irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_IRQS
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* Is this an active IRQ? */
r_if
c_cond
(paren
op_logical_neg
id|irq_desc
(braket
id|j
)braket
dot
id|action
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|imbalance
op_le
id|IRQ_DELTA
c_func
(paren
id|max_loaded
comma
id|j
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Try to find the IRQ that is closest to the imbalance&n;&t;&t; * without going over.&n;&t;&t; */
r_if
c_cond
(paren
id|move_this_load
OL
id|IRQ_DELTA
c_func
(paren
id|max_loaded
comma
id|j
)paren
)paren
(brace
id|move_this_load
op_assign
id|IRQ_DELTA
c_func
(paren
id|max_loaded
comma
id|j
)paren
suffix:semicolon
id|selected_irq
op_assign
id|j
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|selected_irq
op_eq
op_minus
l_int|1
)paren
(brace
r_goto
id|tryanothercpu
suffix:semicolon
)brace
id|imbalance
op_assign
id|move_this_load
suffix:semicolon
multiline_comment|/* For physical_balance case, we accumlated both load&n;&t; * values in the one of the siblings cpu_irq[],&n;&t; * to use the same code for physical and logical processors&n;&t; * as much as possible. &n;&t; *&n;&t; * NOTE: the cpu_irq[] array holds the sum of the load for&n;&t; * sibling A and sibling B in the slot for the lowest numbered&n;&t; * sibling (A), _AND_ the load for sibling B in the slot for&n;&t; * the higher numbered sibling.&n;&t; *&n;&t; * We seek the least loaded sibling by making the comparison&n;&t; * (A+B)/2 vs B&n;&t; */
id|load
op_assign
id|CPU_IRQ
c_func
(paren
id|min_loaded
)paren
op_rshift
l_int|1
suffix:semicolon
id|for_each_cpu_mask
c_func
(paren
id|j
comma
id|cpu_sibling_map
(braket
id|min_loaded
)braket
)paren
(brace
r_if
c_cond
(paren
id|load
OG
id|CPU_IRQ
c_func
(paren
id|j
)paren
)paren
(brace
multiline_comment|/* This won&squot;t change cpu_sibling_map[min_loaded] */
id|load
op_assign
id|CPU_IRQ
c_func
(paren
id|j
)paren
suffix:semicolon
id|min_loaded
op_assign
id|j
suffix:semicolon
)brace
)brace
id|cpus_and
c_func
(paren
id|allowed_mask
comma
id|cpu_online_map
comma
id|irq_affinity
(braket
id|selected_irq
)braket
)paren
suffix:semicolon
id|target_cpu_mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|min_loaded
)paren
suffix:semicolon
id|cpus_and
c_func
(paren
id|tmp
comma
id|target_cpu_mask
comma
id|allowed_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|tmp
)paren
)paren
(brace
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_desc
op_plus
id|selected_irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;irq = %d moved to cpu = %d&bslash;n&quot;
comma
id|selected_irq
comma
id|min_loaded
)paren
suffix:semicolon
multiline_comment|/* mark for change destination */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pending_irq_balance_cpumask
(braket
id|selected_irq
)braket
op_assign
id|cpumask_of_cpu
c_func
(paren
id|min_loaded
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|desc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Since we made a change, come back sooner to &n;&t;&t; * check for more variation.&n;&t;&t; */
id|balanced_irq_interval
op_assign
id|max
c_func
(paren
(paren
r_int
)paren
id|MIN_BALANCED_IRQ_INTERVAL
comma
id|balanced_irq_interval
op_minus
id|BALANCED_IRQ_LESS_DELTA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_goto
id|tryanotherirq
suffix:semicolon
id|not_worth_the_effort
suffix:colon
multiline_comment|/*&n;&t; * if we did not find an IRQ to move, then adjust the time interval&n;&t; * upward&n;&t; */
id|balanced_irq_interval
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
id|MAX_BALANCED_IRQ_INTERVAL
comma
id|balanced_irq_interval
op_plus
id|BALANCED_IRQ_MORE_DELTA
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;IRQ worth rotating not found&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|balanced_irq
r_int
id|balanced_irq
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|prev_balance_time
op_assign
id|jiffies
suffix:semicolon
r_int
id|time_remaining
op_assign
id|balanced_irq_interval
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;kirqd&quot;
)paren
suffix:semicolon
multiline_comment|/* push everything to CPU 0 to give us a starting point.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pending_irq_balance_cpumask
(braket
id|i
)braket
op_assign
id|cpumask_of_cpu
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|time_remaining
op_assign
id|schedule_timeout
c_func
(paren
id|time_remaining
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|prev_balance_time
op_plus
id|balanced_irq_interval
)paren
)paren
(brace
id|Dprintk
c_func
(paren
l_string|&quot;balanced_irq: calling do_irq_balance() %lu&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|do_irq_balance
c_func
(paren
)paren
suffix:semicolon
id|prev_balance_time
op_assign
id|jiffies
suffix:semicolon
id|time_remaining
op_assign
id|balanced_irq_interval
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|balanced_irq_init
r_static
r_int
id|__init
id|balanced_irq_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|cpuinfo_x86
op_star
id|c
suffix:semicolon
id|cpumask_t
id|tmp
suffix:semicolon
id|cpus_shift_right
c_func
(paren
id|tmp
comma
id|cpu_online_map
comma
l_int|2
)paren
suffix:semicolon
id|c
op_assign
op_amp
id|boot_cpu_data
suffix:semicolon
multiline_comment|/* When not overwritten by the command line ask subarchitecture. */
r_if
c_cond
(paren
id|irqbalance_disabled
op_eq
id|IRQBALANCE_CHECK_ARCH
)paren
id|irqbalance_disabled
op_assign
id|NO_BALANCE_IRQ
suffix:semicolon
r_if
c_cond
(paren
id|irqbalance_disabled
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* disable irqbalance completely if there is only one processor online */
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OL
l_int|2
)paren
(brace
id|irqbalance_disabled
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable physical balance only if more than 1 physical processor&n;&t; * is present&n;&t; */
r_if
c_cond
(paren
id|smp_num_siblings
OG
l_int|1
op_logical_and
op_logical_neg
id|cpus_empty
c_func
(paren
id|tmp
)paren
)paren
id|physical_balance
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|irq_cpu_data
(braket
id|i
)braket
dot
id|irq_delta
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
id|NR_IRQS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|irq_cpu_data
(braket
id|i
)braket
dot
id|last_irq
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
id|NR_IRQS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|irq_delta
op_eq
l_int|NULL
op_logical_or
id|irq_cpu_data
(braket
id|i
)braket
dot
id|last_irq
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;balanced_irq_init: out of memory&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|memset
c_func
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|irq_delta
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
id|NR_IRQS
)paren
suffix:semicolon
id|memset
c_func
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|last_irq
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
id|NR_IRQS
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Starting balanced_irq&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_thread
c_func
(paren
id|balanced_irq
comma
l_int|NULL
comma
id|CLONE_KERNEL
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;balanced_irq_init: failed to spawn balanced_irq&quot;
)paren
suffix:semicolon
id|failed
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|irq_delta
)paren
(brace
id|kfree
c_func
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|irq_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|last_irq
)paren
(brace
id|kfree
c_func
(paren
id|irq_cpu_data
(braket
id|i
)braket
dot
id|last_irq
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irqbalance_disable
r_static
r_int
id|__init
id|irqbalance_disable
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|irqbalance_disabled
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noirqbalance&quot;
comma
id|irqbalance_disable
)paren
suffix:semicolon
DECL|function|move_irq
r_static
r_inline
r_void
id|move_irq
c_func
(paren
r_int
id|irq
)paren
(brace
multiline_comment|/* note - we hold the desc-&gt;lock */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|pending_irq_balance_cpumask
(braket
id|irq
)braket
)paren
)paren
)paren
(brace
id|set_ioapic_affinity_irq
c_func
(paren
id|irq
comma
id|pending_irq_balance_cpumask
(braket
id|irq
)braket
)paren
suffix:semicolon
id|cpus_clear
c_func
(paren
id|pending_irq_balance_cpumask
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|balanced_irq_init
id|__initcall
c_func
(paren
id|balanced_irq_init
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_IRQBALANCE */
DECL|function|move_irq
r_static
r_inline
r_void
id|move_irq
c_func
(paren
r_int
id|irq
)paren
(brace
)brace
macro_line|#endif /* CONFIG_IRQBALANCE */
macro_line|#ifndef CONFIG_SMP
DECL|function|send_IPI_self
r_void
id|fastcall
id|send_IPI_self
c_func
(paren
r_int
id|vector
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for idle.&n;&t; */
id|apic_wait_icr_idle
c_func
(paren
)paren
suffix:semicolon
id|cfg
op_assign
id|APIC_DM_FIXED
op_or
id|APIC_DEST_SELF
op_or
id|vector
op_or
id|APIC_DEST_LOGICAL
suffix:semicolon
multiline_comment|/*&n;&t; * Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_SMP */
multiline_comment|/*&n; * support for broken MP BIOSs, enables hand-redirection of PIRQ0-7 to&n; * specific CPU-side IRQs.&n; */
DECL|macro|MAX_PIRQS
mdefine_line|#define MAX_PIRQS 8
DECL|variable|pirq_entries
r_int
id|pirq_entries
(braket
id|MAX_PIRQS
)braket
suffix:semicolon
DECL|variable|pirqs_enabled
r_int
id|pirqs_enabled
suffix:semicolon
DECL|variable|skip_ioapic_setup
r_int
id|skip_ioapic_setup
suffix:semicolon
DECL|function|ioapic_setup
r_static
r_int
id|__init
id|ioapic_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|skip_ioapic_setup
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noapic&quot;
comma
id|ioapic_setup
)paren
suffix:semicolon
DECL|function|ioapic_pirq_setup
r_static
r_int
id|__init
id|ioapic_pirq_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
r_int
id|ints
(braket
id|MAX_PIRQS
op_plus
l_int|1
)braket
suffix:semicolon
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PIRQS
suffix:semicolon
id|i
op_increment
)paren
id|pirq_entries
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|pirqs_enabled
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PIRQ redirection, working around broken MP-BIOS.&bslash;n&quot;
)paren
suffix:semicolon
id|max
op_assign
id|MAX_PIRQS
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
id|MAX_PIRQS
)paren
id|max
op_assign
id|ints
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... PIRQ%d -&gt; IRQ %d&bslash;n&quot;
comma
id|i
comma
id|ints
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * PIRQs are mapped upside down, usually.&n;&t;&t; */
id|pirq_entries
(braket
id|MAX_PIRQS
op_minus
id|i
op_minus
l_int|1
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;pirq=&quot;
comma
id|ioapic_pirq_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * Find the IRQ entry number of a certain pin.&n; */
DECL|function|find_irq_entry
r_static
r_int
id|__init
id|find_irq_entry
c_func
(paren
r_int
id|apic
comma
r_int
id|pin
comma
r_int
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp_irq_entries
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_irqtype
op_eq
id|type
op_logical_and
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_eq
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
op_logical_or
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_eq
id|MP_APIC_ALL
)paren
op_logical_and
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstirq
op_eq
id|pin
)paren
r_return
id|i
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the pin to which IRQ[irq] (ISA) is connected&n; */
DECL|function|find_isa_irq_pin
r_static
r_int
id|__init
id|find_isa_irq_pin
c_func
(paren
r_int
id|irq
comma
r_int
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp_irq_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|lbus
op_assign
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_srcbus
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp_bus_id_to_type
(braket
id|lbus
)braket
op_eq
id|MP_BUS_ISA
op_logical_or
id|mp_bus_id_to_type
(braket
id|lbus
)braket
op_eq
id|MP_BUS_EISA
op_logical_or
id|mp_bus_id_to_type
(braket
id|lbus
)braket
op_eq
id|MP_BUS_MCA
op_logical_or
id|mp_bus_id_to_type
(braket
id|lbus
)braket
op_eq
id|MP_BUS_NEC98
)paren
op_logical_and
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_irqtype
op_eq
id|type
)paren
op_logical_and
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_srcbusirq
op_eq
id|irq
)paren
)paren
r_return
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstirq
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a specific PCI IRQ entry.&n; * Not an __init, possibly needed by modules&n; */
r_static
r_int
id|pin_2_irq
c_func
(paren
r_int
id|idx
comma
r_int
id|apic
comma
r_int
id|pin
)paren
suffix:semicolon
DECL|function|IO_APIC_get_PCI_irq_vector
r_int
id|IO_APIC_get_PCI_irq_vector
c_func
(paren
r_int
id|bus
comma
r_int
id|slot
comma
r_int
id|pin
)paren
(brace
r_int
id|apic
comma
id|i
comma
id|best_guess
op_assign
op_minus
l_int|1
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;querying PCI -&gt; IRQ mapping bus:%d, slot:%d, pin:%d.&bslash;n&quot;
comma
id|bus
comma
id|slot
comma
id|pin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp_bus_id_to_pci_bus
(braket
id|bus
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI BIOS passed nonexistent PCI bus %d!&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp_irq_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|lbus
op_assign
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_srcbus
suffix:semicolon
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
r_if
c_cond
(paren
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
op_eq
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_logical_or
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_eq
id|MP_APIC_ALL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp_bus_id_to_type
(braket
id|lbus
)braket
op_eq
id|MP_BUS_PCI
)paren
op_logical_and
op_logical_neg
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_irqtype
op_logical_and
(paren
id|bus
op_eq
id|lbus
)paren
op_logical_and
(paren
id|slot
op_eq
(paren
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_srcbusirq
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
)paren
)paren
(brace
r_int
id|irq
op_assign
id|pin_2_irq
c_func
(paren
id|i
comma
id|apic
comma
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstirq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|apic
op_logical_or
id|IO_APIC_IRQ
c_func
(paren
id|irq
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pin
op_eq
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_srcbusirq
op_amp
l_int|3
)paren
)paren
r_return
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Use the first all-but-pin matching entry as a&n;&t;&t;&t; * best-guess fuzzy result for broken mptables.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|best_guess
OL
l_int|0
)paren
id|best_guess
op_assign
id|irq
suffix:semicolon
)brace
)brace
r_return
id|best_guess
suffix:semicolon
)brace
multiline_comment|/*&n; * This function currently is only a helper for the i386 smp boot process where &n; * we need to reprogram the ioredtbls to cater for the cpus which have come online&n; * so mask in all cases should simply be TARGET_CPUS&n; */
DECL|function|setup_ioapic_dest
r_void
id|__init
id|setup_ioapic_dest
c_func
(paren
r_void
)paren
(brace
r_int
id|pin
comma
id|ioapic
comma
id|irq
comma
id|irq_entry
suffix:semicolon
r_if
c_cond
(paren
id|skip_ioapic_setup
op_eq
l_int|1
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|ioapic
op_assign
l_int|0
suffix:semicolon
id|ioapic
OL
id|nr_ioapics
suffix:semicolon
id|ioapic
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pin
op_assign
l_int|0
suffix:semicolon
id|pin
OL
id|nr_ioapic_registers
(braket
id|ioapic
)braket
suffix:semicolon
id|pin
op_increment
)paren
(brace
id|irq_entry
op_assign
id|find_irq_entry
c_func
(paren
id|ioapic
comma
id|pin
comma
id|mp_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_entry
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|irq
op_assign
id|pin_2_irq
c_func
(paren
id|irq_entry
comma
id|ioapic
comma
id|pin
)paren
suffix:semicolon
id|set_ioapic_affinity_irq
c_func
(paren
id|irq
comma
id|TARGET_CPUS
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * EISA Edge/Level control register, ELCR&n; */
DECL|function|EISA_ELCR
r_static
r_int
id|__init
id|EISA_ELCR
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
(brace
r_int
r_int
id|port
op_assign
l_int|0x4d0
op_plus
(paren
id|irq
op_rshift
l_int|3
)paren
suffix:semicolon
r_return
(paren
id|inb
c_func
(paren
id|port
)paren
op_rshift
(paren
id|irq
op_amp
l_int|7
)paren
)paren
op_amp
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Broken MPtable reports ISA irq %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* EISA interrupts are always polarity zero and can be edge or level&n; * trigger depending on the ELCR value.  If an interrupt is listed as&n; * EISA conforming in the MP table, that means its trigger type must&n; * be read in from the ELCR */
DECL|macro|default_EISA_trigger
mdefine_line|#define default_EISA_trigger(idx)&t;(EISA_ELCR(mp_irqs[idx].mpc_srcbusirq))
DECL|macro|default_EISA_polarity
mdefine_line|#define default_EISA_polarity(idx)&t;(0)
multiline_comment|/* ISA interrupts are always polarity zero edge triggered,&n; * when listed as conforming in the MP table. */
DECL|macro|default_ISA_trigger
mdefine_line|#define default_ISA_trigger(idx)&t;(0)
DECL|macro|default_ISA_polarity
mdefine_line|#define default_ISA_polarity(idx)&t;(0)
multiline_comment|/* PCI interrupts are always polarity one level triggered,&n; * when listed as conforming in the MP table. */
DECL|macro|default_PCI_trigger
mdefine_line|#define default_PCI_trigger(idx)&t;(1)
DECL|macro|default_PCI_polarity
mdefine_line|#define default_PCI_polarity(idx)&t;(1)
multiline_comment|/* MCA interrupts are always polarity zero level triggered,&n; * when listed as conforming in the MP table. */
DECL|macro|default_MCA_trigger
mdefine_line|#define default_MCA_trigger(idx)&t;(1)
DECL|macro|default_MCA_polarity
mdefine_line|#define default_MCA_polarity(idx)&t;(0)
multiline_comment|/* NEC98 interrupts are always polarity zero edge triggered,&n; * when listed as conforming in the MP table. */
DECL|macro|default_NEC98_trigger
mdefine_line|#define default_NEC98_trigger(idx)     (0)
DECL|macro|default_NEC98_polarity
mdefine_line|#define default_NEC98_polarity(idx)    (0)
DECL|function|MPBIOS_polarity
r_static
r_int
id|__init
id|MPBIOS_polarity
c_func
(paren
r_int
id|idx
)paren
(brace
r_int
id|bus
op_assign
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_srcbus
suffix:semicolon
r_int
id|polarity
suffix:semicolon
multiline_comment|/*&n;&t; * Determine IRQ line polarity (high active or low active):&n;&t; */
r_switch
c_cond
(paren
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_irqflag
op_amp
l_int|3
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* conforms, ie. bus-type dependent polarity */
(brace
r_switch
c_cond
(paren
id|mp_bus_id_to_type
(braket
id|bus
)braket
)paren
(brace
r_case
id|MP_BUS_ISA
suffix:colon
multiline_comment|/* ISA pin */
(brace
id|polarity
op_assign
id|default_ISA_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_EISA
suffix:colon
multiline_comment|/* EISA pin */
(brace
id|polarity
op_assign
id|default_EISA_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_PCI
suffix:colon
multiline_comment|/* PCI pin */
(brace
id|polarity
op_assign
id|default_PCI_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_MCA
suffix:colon
multiline_comment|/* MCA pin */
(brace
id|polarity
op_assign
id|default_MCA_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_NEC98
suffix:colon
multiline_comment|/* NEC 98 pin */
(brace
id|polarity
op_assign
id|default_NEC98_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|polarity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
multiline_comment|/* high active */
(brace
id|polarity
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
multiline_comment|/* reserved */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|polarity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
multiline_comment|/* low active */
(brace
id|polarity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/* invalid */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|polarity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|polarity
suffix:semicolon
)brace
DECL|function|MPBIOS_trigger
r_static
r_int
id|__init
id|MPBIOS_trigger
c_func
(paren
r_int
id|idx
)paren
(brace
r_int
id|bus
op_assign
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_srcbus
suffix:semicolon
r_int
id|trigger
suffix:semicolon
multiline_comment|/*&n;&t; * Determine IRQ trigger mode (edge or level sensitive):&n;&t; */
r_switch
c_cond
(paren
(paren
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_irqflag
op_rshift
l_int|2
)paren
op_amp
l_int|3
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* conforms, ie. bus-type dependent */
(brace
r_switch
c_cond
(paren
id|mp_bus_id_to_type
(braket
id|bus
)braket
)paren
(brace
r_case
id|MP_BUS_ISA
suffix:colon
multiline_comment|/* ISA pin */
(brace
id|trigger
op_assign
id|default_ISA_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_EISA
suffix:colon
multiline_comment|/* EISA pin */
(brace
id|trigger
op_assign
id|default_EISA_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_PCI
suffix:colon
multiline_comment|/* PCI pin */
(brace
id|trigger
op_assign
id|default_PCI_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_MCA
suffix:colon
multiline_comment|/* MCA pin */
(brace
id|trigger
op_assign
id|default_MCA_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_NEC98
suffix:colon
multiline_comment|/* NEC 98 pin */
(brace
id|trigger
op_assign
id|default_NEC98_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|trigger
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
multiline_comment|/* edge */
(brace
id|trigger
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
multiline_comment|/* reserved */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|trigger
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
multiline_comment|/* level */
(brace
id|trigger
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/* invalid */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;broken BIOS!!&bslash;n&quot;
)paren
suffix:semicolon
id|trigger
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|trigger
suffix:semicolon
)brace
DECL|function|irq_polarity
r_static
r_inline
r_int
id|irq_polarity
c_func
(paren
r_int
id|idx
)paren
(brace
r_return
id|MPBIOS_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
DECL|function|irq_trigger
r_static
r_inline
r_int
id|irq_trigger
c_func
(paren
r_int
id|idx
)paren
(brace
r_return
id|MPBIOS_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
DECL|function|pin_2_irq
r_static
r_int
id|pin_2_irq
c_func
(paren
r_int
id|idx
comma
r_int
id|apic
comma
r_int
id|pin
)paren
(brace
r_int
id|irq
comma
id|i
suffix:semicolon
r_int
id|bus
op_assign
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_srcbus
suffix:semicolon
multiline_comment|/*&n;&t; * Debugging check, we are in big trouble if this message pops up!&n;&t; */
r_if
c_cond
(paren
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_dstirq
op_ne
id|pin
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;broken BIOS or MPTABLE parser, ayiee!!&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mp_bus_id_to_type
(braket
id|bus
)braket
)paren
(brace
r_case
id|MP_BUS_ISA
suffix:colon
multiline_comment|/* ISA pin */
r_case
id|MP_BUS_EISA
suffix:colon
r_case
id|MP_BUS_MCA
suffix:colon
r_case
id|MP_BUS_NEC98
suffix:colon
(brace
id|irq
op_assign
id|mp_irqs
(braket
id|idx
)braket
dot
id|mpc_srcbusirq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS_PCI
suffix:colon
multiline_comment|/* PCI pin */
(brace
multiline_comment|/*&n;&t;&t;&t; * PCI IRQs are mapped in order&n;&t;&t;&t; */
id|i
op_assign
id|irq
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|apic
)paren
id|irq
op_add_assign
id|nr_ioapic_registers
(braket
id|i
op_increment
)braket
suffix:semicolon
id|irq
op_add_assign
id|pin
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|apic
)paren
op_logical_and
(paren
id|irq
OL
l_int|16
)paren
)paren
id|irq
op_add_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unknown bus type %d.&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
id|irq
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * PCI IRQ command line redirection. Yes, limits are hardcoded.&n;&t; */
r_if
c_cond
(paren
(paren
id|pin
op_ge
l_int|16
)paren
op_logical_and
(paren
id|pin
op_le
l_int|23
)paren
)paren
(brace
r_if
c_cond
(paren
id|pirq_entries
(braket
id|pin
op_minus
l_int|16
)braket
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pirq_entries
(braket
id|pin
op_minus
l_int|16
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;disabling PIRQ%d&bslash;n&quot;
comma
id|pin
op_minus
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|irq
op_assign
id|pirq_entries
(braket
id|pin
op_minus
l_int|16
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;using PIRQ%d -&gt; IRQ %d&bslash;n&quot;
comma
id|pin
op_minus
l_int|16
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|irq
suffix:semicolon
)brace
DECL|function|IO_APIC_irq_trigger
r_static
r_inline
r_int
id|IO_APIC_irq_trigger
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|apic
comma
id|idx
comma
id|pin
suffix:semicolon
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pin
op_assign
l_int|0
suffix:semicolon
id|pin
OL
id|nr_ioapic_registers
(braket
id|apic
)braket
suffix:semicolon
id|pin
op_increment
)paren
(brace
id|idx
op_assign
id|find_irq_entry
c_func
(paren
id|apic
comma
id|pin
comma
id|mp_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|irq
op_eq
id|pin_2_irq
c_func
(paren
id|idx
comma
id|apic
comma
id|pin
)paren
)paren
)paren
r_return
id|irq_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * nonexistent IRQs are edge default&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* irq_vectors is indexed by the sum of all RTEs in all I/O APICs. */
DECL|variable|irq_vector
id|u8
id|irq_vector
(braket
id|NR_IRQ_VECTORS
)braket
op_assign
(brace
id|FIRST_DEVICE_VECTOR
comma
l_int|0
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PCI_USE_VECTOR
DECL|function|assign_irq_vector
r_int
id|assign_irq_vector
c_func
(paren
r_int
id|irq
)paren
macro_line|#else
r_int
id|__init
id|assign_irq_vector
c_func
(paren
r_int
id|irq
)paren
macro_line|#endif
(brace
r_static
r_int
id|current_vector
op_assign
id|FIRST_DEVICE_VECTOR
comma
id|offset
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|irq
op_ge
id|NR_IRQ_VECTORS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|AUTO_ASSIGN
op_logical_and
id|IO_APIC_VECTOR
c_func
(paren
id|irq
)paren
OG
l_int|0
)paren
r_return
id|IO_APIC_VECTOR
c_func
(paren
id|irq
)paren
suffix:semicolon
id|next
suffix:colon
id|current_vector
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|current_vector
op_eq
id|SYSCALL_VECTOR
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|current_vector
op_ge
id|FIRST_SYSTEM_VECTOR
)paren
(brace
id|offset
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|offset
op_mod
l_int|8
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|current_vector
op_assign
id|FIRST_DEVICE_VECTOR
op_plus
id|offset
suffix:semicolon
)brace
id|vector_irq
(braket
id|current_vector
)braket
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|AUTO_ASSIGN
)paren
id|IO_APIC_VECTOR
c_func
(paren
id|irq
)paren
op_assign
id|current_vector
suffix:semicolon
r_return
id|current_vector
suffix:semicolon
)brace
DECL|variable|ioapic_level_type
r_static
r_struct
id|hw_interrupt_type
id|ioapic_level_type
suffix:semicolon
DECL|variable|ioapic_edge_type
r_static
r_struct
id|hw_interrupt_type
id|ioapic_edge_type
suffix:semicolon
DECL|macro|IOAPIC_AUTO
mdefine_line|#define IOAPIC_AUTO&t;-1
DECL|macro|IOAPIC_EDGE
mdefine_line|#define IOAPIC_EDGE&t;0
DECL|macro|IOAPIC_LEVEL
mdefine_line|#define IOAPIC_LEVEL&t;1
DECL|function|ioapic_register_intr
r_static
r_inline
r_void
id|ioapic_register_intr
c_func
(paren
r_int
id|irq
comma
r_int
id|vector
comma
r_int
r_int
id|trigger
)paren
(brace
r_if
c_cond
(paren
id|use_pci_vector
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|platform_legacy_irq
c_func
(paren
id|irq
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|trigger
op_eq
id|IOAPIC_AUTO
op_logical_and
id|IO_APIC_irq_trigger
c_func
(paren
id|irq
)paren
)paren
op_logical_or
id|trigger
op_eq
id|IOAPIC_LEVEL
)paren
id|irq_desc
(braket
id|vector
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_level_type
suffix:semicolon
r_else
id|irq_desc
(braket
id|vector
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_edge_type
suffix:semicolon
id|set_intr_gate
c_func
(paren
id|vector
comma
id|interrupt
(braket
id|vector
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|trigger
op_eq
id|IOAPIC_AUTO
op_logical_and
id|IO_APIC_irq_trigger
c_func
(paren
id|irq
)paren
)paren
op_logical_or
id|trigger
op_eq
id|IOAPIC_LEVEL
)paren
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_level_type
suffix:semicolon
r_else
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_edge_type
suffix:semicolon
id|set_intr_gate
c_func
(paren
id|vector
comma
id|interrupt
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|setup_IO_APIC_irqs
r_void
id|__init
id|setup_IO_APIC_irqs
c_func
(paren
r_void
)paren
(brace
r_struct
id|IO_APIC_route_entry
id|entry
suffix:semicolon
r_int
id|apic
comma
id|pin
comma
id|idx
comma
id|irq
comma
id|first_notcon
op_assign
l_int|1
comma
id|vector
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;init IO_APIC IRQs&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pin
op_assign
l_int|0
suffix:semicolon
id|pin
OL
id|nr_ioapic_registers
(braket
id|apic
)braket
suffix:semicolon
id|pin
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * add it to the IO-APIC irq-routing table:&n;&t;&t; */
id|memset
c_func
(paren
op_amp
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
id|entry.delivery_mode
op_assign
id|INT_DELIVERY_MODE
suffix:semicolon
id|entry.dest_mode
op_assign
id|INT_DEST_MODE
suffix:semicolon
id|entry.mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* enable IRQ */
id|entry.dest.logical.logical_dest
op_assign
id|cpu_mask_to_apicid
c_func
(paren
id|TARGET_CPUS
)paren
suffix:semicolon
id|idx
op_assign
id|find_irq_entry
c_func
(paren
id|apic
comma
id|pin
comma
id|mp_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|first_notcon
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; IO-APIC (apicid-pin) %d-%d&quot;
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
comma
id|pin
)paren
suffix:semicolon
id|first_notcon
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %d-%d&quot;
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
comma
id|pin
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|entry.trigger
op_assign
id|irq_trigger
c_func
(paren
id|idx
)paren
suffix:semicolon
id|entry.polarity
op_assign
id|irq_polarity
c_func
(paren
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_trigger
c_func
(paren
id|idx
)paren
)paren
(brace
id|entry.trigger
op_assign
l_int|1
suffix:semicolon
id|entry.mask
op_assign
l_int|1
suffix:semicolon
)brace
id|irq
op_assign
id|pin_2_irq
c_func
(paren
id|idx
comma
id|apic
comma
id|pin
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * skip adding the timer int on secondary nodes, which causes&n;&t;&t; * a small but painful rift in the time-space continuum&n;&t;&t; */
r_if
c_cond
(paren
id|multi_timer_check
c_func
(paren
id|apic
comma
id|irq
)paren
)paren
r_continue
suffix:semicolon
r_else
id|add_pin_to_irq
c_func
(paren
id|irq
comma
id|apic
comma
id|pin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apic
op_logical_and
op_logical_neg
id|IO_APIC_IRQ
c_func
(paren
id|irq
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|IO_APIC_IRQ
c_func
(paren
id|irq
)paren
)paren
(brace
id|vector
op_assign
id|assign_irq_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|entry.vector
op_assign
id|vector
suffix:semicolon
id|ioapic_register_intr
c_func
(paren
id|irq
comma
id|vector
comma
id|IOAPIC_AUTO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apic
op_logical_and
(paren
id|irq
OL
l_int|16
)paren
)paren
id|disable_8259A_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|apic
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|apic
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|first_notcon
)paren
id|printk
c_func
(paren
l_string|&quot; not connected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the 8259A-master output pin:&n; */
DECL|function|setup_ExtINT_IRQ0_pin
r_void
id|__init
id|setup_ExtINT_IRQ0_pin
c_func
(paren
r_int
r_int
id|pin
comma
r_int
id|vector
)paren
(brace
r_struct
id|IO_APIC_route_entry
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
id|disable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask LVT0 */
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|APIC_LVT_MASKED
op_or
id|APIC_DM_EXTINT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We use logical delivery to get the timer IRQ&n;&t; * to the first CPU.&n;&t; */
id|entry.dest_mode
op_assign
id|INT_DEST_MODE
suffix:semicolon
id|entry.mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unmask IRQ now */
id|entry.dest.logical.logical_dest
op_assign
id|cpu_mask_to_apicid
c_func
(paren
id|TARGET_CPUS
)paren
suffix:semicolon
id|entry.delivery_mode
op_assign
id|INT_DELIVERY_MODE
suffix:semicolon
id|entry.polarity
op_assign
l_int|0
suffix:semicolon
id|entry.trigger
op_assign
l_int|0
suffix:semicolon
id|entry.vector
op_assign
id|vector
suffix:semicolon
multiline_comment|/*&n;&t; * The timer IRQ doesn&squot;t have to know that behind the&n;&t; * scene we have a 8259A-master in AEOI mode ...&n;&t; */
id|irq_desc
(braket
l_int|0
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_edge_type
suffix:semicolon
multiline_comment|/*&n;&t; * Add it to the IO-APIC irq-routing table:&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|enable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|UNEXPECTED_IO_APIC
r_static
r_inline
r_void
id|UNEXPECTED_IO_APIC
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|print_IO_APIC
r_void
id|__init
id|print_IO_APIC
c_func
(paren
r_void
)paren
(brace
r_int
id|apic
comma
id|i
suffix:semicolon
r_union
id|IO_APIC_reg_00
id|reg_00
suffix:semicolon
r_union
id|IO_APIC_reg_01
id|reg_01
suffix:semicolon
r_union
id|IO_APIC_reg_02
id|reg_02
suffix:semicolon
r_union
id|IO_APIC_reg_03
id|reg_03
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;number of MP IRQ sources: %d.&bslash;n&quot;
comma
id|mp_irq_entries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ioapics
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;number of IO-APIC #%d registers: %d.&bslash;n&quot;
comma
id|mp_ioapics
(braket
id|i
)braket
dot
id|mpc_apicid
comma
id|nr_ioapic_registers
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are a bit conservative about what we expect.  We have to&n;&t; * know about every hardware change ASAP.&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;testing the IO APIC.......................&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_00.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0
)paren
suffix:semicolon
id|reg_01.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_01.bits.version
op_ge
l_int|0x10
)paren
id|reg_02.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_01.bits.version
op_ge
l_int|0x20
)paren
id|reg_03.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|3
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;IO APIC #%d......&bslash;n&quot;
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.... register #00: %08X&bslash;n&quot;
comma
id|reg_00.raw
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......    : physical APIC id: %02X&bslash;n&quot;
comma
id|reg_00.bits.ID
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......    : Delivery Type: %X&bslash;n&quot;
comma
id|reg_00.bits.delivery_type
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......    : LTS          : %X&bslash;n&quot;
comma
id|reg_00.bits.LTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_00.bits.ID
op_ge
id|get_physical_broadcast
c_func
(paren
)paren
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_00.bits.__reserved_1
op_logical_or
id|reg_00.bits.__reserved_2
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.... register #01: %08X&bslash;n&quot;
comma
id|reg_01.raw
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......     : max redirection entries: %04X&bslash;n&quot;
comma
id|reg_01.bits.entries
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg_01.bits.entries
op_ne
l_int|0x0f
)paren
op_logical_and
multiline_comment|/* older (Neptune) boards */
(paren
id|reg_01.bits.entries
op_ne
l_int|0x17
)paren
op_logical_and
multiline_comment|/* typical ISA+PCI boards */
(paren
id|reg_01.bits.entries
op_ne
l_int|0x1b
)paren
op_logical_and
multiline_comment|/* Compaq Proliant boards */
(paren
id|reg_01.bits.entries
op_ne
l_int|0x1f
)paren
op_logical_and
multiline_comment|/* dual Xeon boards */
(paren
id|reg_01.bits.entries
op_ne
l_int|0x22
)paren
op_logical_and
multiline_comment|/* bigger Xeon boards */
(paren
id|reg_01.bits.entries
op_ne
l_int|0x2E
)paren
op_logical_and
(paren
id|reg_01.bits.entries
op_ne
l_int|0x3F
)paren
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......     : PRQ implemented: %X&bslash;n&quot;
comma
id|reg_01.bits.PRQ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......     : IO APIC version: %04X&bslash;n&quot;
comma
id|reg_01.bits.version
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg_01.bits.version
op_ne
l_int|0x01
)paren
op_logical_and
multiline_comment|/* 82489DX IO-APICs */
(paren
id|reg_01.bits.version
op_ne
l_int|0x10
)paren
op_logical_and
multiline_comment|/* oldest IO-APICs */
(paren
id|reg_01.bits.version
op_ne
l_int|0x11
)paren
op_logical_and
multiline_comment|/* Pentium/Pro IO-APICs */
(paren
id|reg_01.bits.version
op_ne
l_int|0x13
)paren
op_logical_and
multiline_comment|/* Xeon IO-APICs */
(paren
id|reg_01.bits.version
op_ne
l_int|0x20
)paren
multiline_comment|/* Intel P64H (82806 AA) */
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_01.bits.__reserved_1
op_logical_or
id|reg_01.bits.__reserved_2
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some Intel chipsets with IO APIC VERSION of 0x1? don&squot;t have reg_02,&n;&t; * but the value of reg_02 is read as the previous read register&n;&t; * value, so ignore it if reg_02 == reg_01.&n;&t; */
r_if
c_cond
(paren
id|reg_01.bits.version
op_ge
l_int|0x10
op_logical_and
id|reg_02.raw
op_ne
id|reg_01.raw
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.... register #02: %08X&bslash;n&quot;
comma
id|reg_02.raw
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......     : arbitration: %02X&bslash;n&quot;
comma
id|reg_02.bits.arbitration
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_02.bits.__reserved_1
op_logical_or
id|reg_02.bits.__reserved_2
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some Intel chipsets with IO APIC VERSION of 0x2? don&squot;t have reg_02&n;&t; * or reg_03, but the value of reg_0[23] is read as the previous read&n;&t; * register value, so ignore it if reg_03 == reg_0[12].&n;&t; */
r_if
c_cond
(paren
id|reg_01.bits.version
op_ge
l_int|0x20
op_logical_and
id|reg_03.raw
op_ne
id|reg_02.raw
op_logical_and
id|reg_03.raw
op_ne
id|reg_01.raw
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.... register #03: %08X&bslash;n&quot;
comma
id|reg_03.raw
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.......     : Boot DT    : %X&bslash;n&quot;
comma
id|reg_03.bits.boot_DT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_03.bits.__reserved_1
)paren
id|UNEXPECTED_IO_APIC
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.... IRQ redirection table:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; NR Log Phy Mask Trig IRR Pol&quot;
l_string|&quot; Stat Dest Deli Vect:   &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|reg_01.bits.entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|IO_APIC_route_entry
id|entry
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0x10
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0x11
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; %02x %03X %02X  &quot;
comma
id|i
comma
id|entry.dest.logical.logical_dest
comma
id|entry.dest.physical.physical_dest
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X&bslash;n&quot;
comma
id|entry.mask
comma
id|entry.trigger
comma
id|entry.irr
comma
id|entry.polarity
comma
id|entry.delivery_status
comma
id|entry.dest_mode
comma
id|entry.delivery_mode
comma
id|entry.vector
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;IRQ to pin mappings:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|irq_pin_list
op_star
id|entry
op_assign
id|irq_2_pin
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;pin
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;IRQ%d &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-&gt; %d:%d&quot;
comma
id|entry-&gt;apic
comma
id|entry-&gt;pin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;next
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|irq_2_pin
op_plus
id|entry-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;.................................... done.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|print_APIC_bitfield
r_static
r_void
id|print_APIC_bitfield
(paren
r_int
id|base
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;0123456789abcdef0123456789abcdef&bslash;n&quot;
id|KERN_DEBUG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|v
op_assign
id|apic_read
c_func
(paren
id|base
op_plus
id|i
op_star
l_int|0x10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|v
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|print_local_APIC
r_void
multiline_comment|/*__init*/
id|print_local_APIC
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
r_int
r_int
id|v
comma
id|ver
comma
id|maxlvt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_DEBUG
l_string|&quot;printing local APIC contents on CPU#%d/%d:&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_ID
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;... APIC ID:      %08x (%01x)&bslash;n&quot;
comma
id|v
comma
id|GET_APIC_ID
c_func
(paren
id|v
)paren
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;... APIC VERSION: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|ver
op_assign
id|GET_APIC_VERSION
c_func
(paren
id|v
)paren
suffix:semicolon
id|maxlvt
op_assign
id|get_maxlvt
c_func
(paren
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_TASKPRI
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC TASKPRI: %08x (%02x)&bslash;n&quot;
comma
id|v
comma
id|v
op_amp
id|APIC_TPRI_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|ver
)paren
)paren
(brace
multiline_comment|/* !82489DX */
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_ARBPRI
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC ARBPRI: %08x (%02x)&bslash;n&quot;
comma
id|v
comma
id|v
op_amp
id|APIC_ARBPRI_MASK
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_PROCPRI
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC PROCPRI: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_EOI
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC EOI: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_RRR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC RRR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LDR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LDR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_DFR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC DFR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC SPIV: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC ISR field:&bslash;n&quot;
)paren
suffix:semicolon
id|print_APIC_bitfield
c_func
(paren
id|APIC_ISR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC TMR field:&bslash;n&quot;
)paren
suffix:semicolon
id|print_APIC_bitfield
c_func
(paren
id|APIC_TMR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC IRR field:&bslash;n&quot;
)paren
suffix:semicolon
id|print_APIC_bitfield
c_func
(paren
id|APIC_IRR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|ver
)paren
)paren
(brace
multiline_comment|/* !82489DX */
r_if
c_cond
(paren
id|maxlvt
OG
l_int|3
)paren
multiline_comment|/* Due to the Pentium erratum 3AP. */
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC ESR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC ICR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC ICR2: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVTT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LVTT: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxlvt
OG
l_int|3
)paren
(brace
multiline_comment|/* PC is LVT#4. */
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVTPC
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LVTPC: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LVT0: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LVT1: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxlvt
OG
l_int|2
)paren
(brace
multiline_comment|/* ERR is LVT#3. */
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVTERR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC LVTERR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_TMICT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC TMICT: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_TMCCT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC TMCCT: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_TDCR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... APIC TDCR: %08x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|print_all_local_APICs
r_void
id|print_all_local_APICs
(paren
r_void
)paren
(brace
id|on_each_cpu
c_func
(paren
id|print_local_APIC
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|print_PIC
r_void
multiline_comment|/*__init*/
id|print_PIC
c_func
(paren
r_void
)paren
(brace
r_extern
id|spinlock_t
id|i8259A_lock
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;nprinting PIC contents&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8259A_lock
comma
id|flags
)paren
suffix:semicolon
id|v
op_assign
id|inb
c_func
(paren
l_int|0xa1
)paren
op_lshift
l_int|8
op_or
id|inb
c_func
(paren
l_int|0x21
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... PIC  IMR: %04x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
op_or
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... PIC  IRR: %04x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0xa0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x20
)paren
suffix:semicolon
id|v
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
op_or
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0xa0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0x20
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8259A_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... PIC  ISR: %04x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
id|v
op_assign
id|inb
c_func
(paren
l_int|0x4d1
)paren
op_lshift
l_int|8
op_or
id|inb
c_func
(paren
l_int|0x4d0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;... PIC ELCR: %04x&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
DECL|function|enable_IO_APIC
r_static
r_void
id|__init
id|enable_IO_APIC
c_func
(paren
r_void
)paren
(brace
r_union
id|IO_APIC_reg_01
id|reg_01
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIN_MAP_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_2_pin
(braket
id|i
)braket
dot
id|pin
op_assign
op_minus
l_int|1
suffix:semicolon
id|irq_2_pin
(braket
id|i
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pirqs_enabled
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PIRQS
suffix:semicolon
id|i
op_increment
)paren
id|pirq_entries
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * The number of IO-APIC IRQ registers (== #pins):&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ioapics
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_01.raw
op_assign
id|io_apic_read
c_func
(paren
id|i
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|nr_ioapic_registers
(braket
id|i
)braket
op_assign
id|reg_01.bits.entries
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do not trust the IO-APIC being empty at bootup&n;&t; */
id|clear_IO_APIC
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Not an __init, needed by the reboot code&n; */
DECL|function|disable_IO_APIC
r_void
id|disable_IO_APIC
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Clear the IO-APIC before rebooting:&n;&t; */
id|clear_IO_APIC
c_func
(paren
)paren
suffix:semicolon
id|disconnect_bsp_APIC
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function to set the IO-APIC physical IDs based on the&n; * values stored in the MPC table.&n; *&n; * by Matt Domsch &lt;Matt_Domsch@dell.com&gt;  Tue Dec 21 12:25:05 CST 1999&n; */
macro_line|#ifndef CONFIG_X86_NUMAQ
DECL|function|setup_ioapic_ids_from_mpc
r_static
r_void
id|__init
id|setup_ioapic_ids_from_mpc
c_func
(paren
r_void
)paren
(brace
r_union
id|IO_APIC_reg_00
id|reg_00
suffix:semicolon
id|physid_mask_t
id|phys_id_present_map
suffix:semicolon
r_int
id|apic
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|old_id
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * This is broken; anything with a real cpu count has to&n;&t; * circumvent this idiocy regardless.&n;&t; */
id|phys_id_present_map
op_assign
id|ioapic_phys_id_map
c_func
(paren
id|phys_cpu_present_map
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the IOAPIC ID to the value stored in the MPC table.&n;&t; */
r_for
c_loop
(paren
id|apic
op_assign
l_int|0
suffix:semicolon
id|apic
OL
id|nr_ioapics
suffix:semicolon
id|apic
op_increment
)paren
(brace
multiline_comment|/* Read the register 0 value */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_00.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|old_id
op_assign
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
suffix:semicolon
r_if
c_cond
(paren
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
op_ge
id|get_physical_broadcast
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...&bslash;n&quot;
comma
id|apic
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;... fixing up to %d. (tell your hw vendor)&bslash;n&quot;
comma
id|reg_00.bits.ID
)paren
suffix:semicolon
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
op_assign
id|reg_00.bits.ID
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t check I/O APIC IDs for some xAPIC systems.  They have&n;&t;&t; * no meaning without the serial APIC bus. */
r_if
c_cond
(paren
id|NO_IOAPIC_CHECK
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Sanity check, is the ID really free? Every APIC in a&n;&t;&t; * system must have a unique ID or we get lots of nice&n;&t;&t; * &squot;stuck on smp_invalidate_needed IPI wait&squot; messages.&n;&t;&t; */
r_if
c_cond
(paren
id|check_apicid_used
c_func
(paren
id|phys_id_present_map
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BIOS bug, IO-APIC#%d ID %d is already used!...&bslash;n&quot;
comma
id|apic
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_physical_broadcast
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|physid_isset
c_func
(paren
id|i
comma
id|phys_id_present_map
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|get_physical_broadcast
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Max APIC ID exceeded!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;... fixing up to %d. (tell your hw vendor)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|physid_set
c_func
(paren
id|i
comma
id|phys_id_present_map
)paren
suffix:semicolon
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
id|physid_mask_t
id|tmp
suffix:semicolon
id|tmp
op_assign
id|apicid_to_cpu_present
c_func
(paren
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Setting %d in the phys_id_present_map&bslash;n&quot;
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
id|physids_or
c_func
(paren
id|phys_id_present_map
comma
id|phys_id_present_map
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We need to adjust the IRQ routing table&n;&t;&t; * if the ID changed.&n;&t;&t; */
r_if
c_cond
(paren
id|old_id
op_ne
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp_irq_entries
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_eq
id|old_id
)paren
id|mp_irqs
(braket
id|i
)braket
dot
id|mpc_dstapic
op_assign
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the right value from the MPC table and&n;&t;&t; * write it into the ID register.&n;&t; &t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;...changing IO-APIC physical APIC ID to %d ...&quot;
comma
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
suffix:semicolon
id|reg_00.bits.ID
op_assign
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|apic
comma
l_int|0
comma
id|reg_00.raw
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Sanity check&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_00.raw
op_assign
id|io_apic_read
c_func
(paren
id|apic
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_00.bits.ID
op_ne
id|mp_ioapics
(braket
id|apic
)braket
dot
id|mpc_apicid
)paren
id|panic
c_func
(paren
l_string|&quot;could not set ID!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; ok.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|setup_ioapic_ids_from_mpc
r_static
r_void
id|__init
id|setup_ioapic_ids_from_mpc
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
multiline_comment|/*&n; * There is a nasty bug in some older SMP boards, their mptable lies&n; * about the timer IRQ. We do the following to work around the situation:&n; *&n; *&t;- timer IRQ defaults to IO-APIC IRQ&n; *&t;- if this function detects that timer IRQs are defunct, then we fall&n; *&t;  back to ISA timer IRQs&n; */
DECL|function|timer_irq_works
r_static
r_int
id|__init
id|timer_irq_works
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|t1
op_assign
id|jiffies
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Let ten ticks pass... */
id|mdelay
c_func
(paren
(paren
l_int|10
op_star
l_int|1000
)paren
op_div
id|HZ
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Expect a few ticks at least, to be sure some possible&n;&t; * glue logic does not lock up after one or two first&n;&t; * ticks in a non-ExtINT mode.  Also the local APIC&n;&t; * might have cached one ExtINT interrupt.  Finally, at&n;&t; * least one tick may be lost due to delays.&n;&t; */
r_if
c_cond
(paren
id|jiffies
op_minus
id|t1
OG
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * In the SMP+IOAPIC case it might happen that there are an unspecified&n; * number of pending IRQ events unhandled. These cases are very rare,&n; * so we &squot;resend&squot; these IRQs via IPIs, to the same CPU. It&squot;s much&n; * better to do it this way as thus we do not have to be aware of&n; * &squot;pending&squot; interrupts in the IRQ path, except at this point.&n; */
multiline_comment|/*&n; * Edge triggered needs to resend any interrupt&n; * that was delayed but this is now handled in the device&n; * independent code.&n; */
multiline_comment|/*&n; * Starting up a edge-triggered IO-APIC interrupt is&n; * nasty - we need to make sure that we get the edge.&n; * If it is already asserted for some reason, we need&n; * return 1 to indicate that is was pending.&n; *&n; * This is not complete - we should be able to fake&n; * an edge even if it isn&squot;t on the 8259A...&n; */
DECL|function|startup_edge_ioapic_irq
r_static
r_int
r_int
id|startup_edge_ioapic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|was_pending
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
(brace
id|disable_8259A_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8259A_irq_pending
c_func
(paren
id|irq
)paren
)paren
id|was_pending
op_assign
l_int|1
suffix:semicolon
)brace
id|__unmask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|was_pending
suffix:semicolon
)brace
multiline_comment|/*&n; * Once we have recorded IRQ_PENDING already, we can mask the&n; * interrupt for real. This prevents IRQ storms from unhandled&n; * devices.&n; */
DECL|function|ack_edge_ioapic_irq
r_static
r_void
id|ack_edge_ioapic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|move_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_PENDING
op_or
id|IRQ_DISABLED
)paren
)paren
op_eq
(paren
id|IRQ_PENDING
op_or
id|IRQ_DISABLED
)paren
)paren
id|mask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Level triggered interrupts can just be masked,&n; * and shutting down and starting up the interrupt&n; * is the same as enabling and disabling them -- except&n; * with a startup need to return a &quot;was pending&quot; value.&n; *&n; * Level triggered interrupts are special because we&n; * do not touch any IO-APIC register while handling&n; * them. We ack the APIC in the end-IRQ handler, not&n; * in the start-IRQ-handler. Protection against reentrance&n; * from the same interrupt is still provided, both by the&n; * generic IRQ layer and by the fact that an unacked local&n; * APIC does not accept IRQs.&n; */
DECL|function|startup_level_ioapic_irq
r_static
r_int
r_int
id|startup_level_ioapic_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|unmask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t check for pending */
)brace
DECL|function|end_level_ioapic_irq
r_static
r_void
id|end_level_ioapic_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_int
id|i
suffix:semicolon
id|move_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n; * It appears there is an erratum which affects at least version 0x11&n; * of I/O APIC (that&squot;s the 82093AA and cores integrated into various&n; * chipsets).  Under certain conditions a level-triggered interrupt is&n; * erroneously delivered as edge-triggered one but the respective IRR&n; * bit gets set nevertheless.  As a result the I/O unit expects an EOI&n; * message but it will never arrive and further interrupts are blocked&n; * from the source.  The exact reason is so far unknown, but the&n; * phenomenon was observed when two consecutive interrupt requests&n; * from a given source get delivered to the same CPU and the source is&n; * temporarily disabled in between.&n; *&n; * A workaround is to simulate an EOI message manually.  We achieve it&n; * by setting the trigger mode to edge and then to level when the edge&n; * trigger mode gets detected in the TMR of a local APIC for a&n; * level-triggered interrupt.  We mask the source for the time of the&n; * operation to prevent an edge-triggered interrupt escaping meanwhile.&n; * The idea is from Manfred Spraul.  --macro&n; */
id|i
op_assign
id|IO_APIC_VECTOR
c_func
(paren
id|irq
)paren
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_TMR
op_plus
(paren
(paren
id|i
op_amp
op_complement
l_int|0x1f
)paren
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|v
op_amp
(paren
l_int|1
op_lshift
(paren
id|i
op_amp
l_int|0x1f
)paren
)paren
)paren
)paren
(brace
macro_line|#ifdef APIC_MISMATCH_DEBUG
id|atomic_inc
c_func
(paren
op_amp
id|irq_mis_count
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|ioapic_lock
)paren
suffix:semicolon
id|__mask_and_edge_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|__unmask_and_level_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ioapic_lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PCI_USE_VECTOR
DECL|function|startup_edge_ioapic_vector
r_static
r_int
r_int
id|startup_edge_ioapic_vector
c_func
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
r_return
id|startup_edge_ioapic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|ack_edge_ioapic_vector
r_static
r_void
id|ack_edge_ioapic_vector
c_func
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
id|ack_edge_ioapic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|startup_level_ioapic_vector
r_static
r_int
r_int
id|startup_level_ioapic_vector
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
r_return
id|startup_level_ioapic_irq
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|end_level_ioapic_vector
r_static
r_void
id|end_level_ioapic_vector
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
id|end_level_ioapic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|mask_IO_APIC_vector
r_static
r_void
id|mask_IO_APIC_vector
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
id|mask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|unmask_IO_APIC_vector
r_static
r_void
id|unmask_IO_APIC_vector
(paren
r_int
r_int
id|vector
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
id|unmask_IO_APIC_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|set_ioapic_affinity_vector
r_static
r_void
id|set_ioapic_affinity_vector
(paren
r_int
r_int
id|vector
comma
id|cpumask_t
id|cpu_mask
)paren
(brace
r_int
id|irq
op_assign
id|vector_to_irq
c_func
(paren
id|vector
)paren
suffix:semicolon
id|set_ioapic_affinity_irq
c_func
(paren
id|irq
comma
id|cpu_mask
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Level and edge triggered IO-APIC interrupts need different handling,&n; * so we use two separate IRQ descriptors. Edge triggered IRQs can be&n; * handled with the level-triggered descriptor, but that one has slightly&n; * more overhead. Level-triggered interrupts cannot be handled with the&n; * edge-triggered handler, without risking IRQ storms and other ugly&n; * races.&n; */
DECL|variable|ioapic_edge_type
r_static
r_struct
id|hw_interrupt_type
id|ioapic_edge_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;IO-APIC-edge&quot;
comma
dot
id|startup
op_assign
id|startup_edge_ioapic
comma
dot
id|shutdown
op_assign
id|shutdown_edge_ioapic
comma
dot
id|enable
op_assign
id|enable_edge_ioapic
comma
dot
id|disable
op_assign
id|disable_edge_ioapic
comma
dot
id|ack
op_assign
id|ack_edge_ioapic
comma
dot
id|end
op_assign
id|end_edge_ioapic
comma
dot
id|set_affinity
op_assign
id|set_ioapic_affinity
comma
)brace
suffix:semicolon
DECL|variable|ioapic_level_type
r_static
r_struct
id|hw_interrupt_type
id|ioapic_level_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;IO-APIC-level&quot;
comma
dot
id|startup
op_assign
id|startup_level_ioapic
comma
dot
id|shutdown
op_assign
id|shutdown_level_ioapic
comma
dot
id|enable
op_assign
id|enable_level_ioapic
comma
dot
id|disable
op_assign
id|disable_level_ioapic
comma
dot
id|ack
op_assign
id|mask_and_ack_level_ioapic
comma
dot
id|end
op_assign
id|end_level_ioapic
comma
dot
id|set_affinity
op_assign
id|set_ioapic_affinity
comma
)brace
suffix:semicolon
DECL|function|init_IO_APIC_traps
r_static
r_inline
r_void
id|init_IO_APIC_traps
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE! The local APIC isn&squot;t very good at handling&n;&t; * multiple interrupts at the same interrupt level.&n;&t; * As the interrupt level is determined by taking the&n;&t; * vector number and shifting that right by 4, we&n;&t; * want to spread these out a bit so that they don&squot;t&n;&t; * all fall in the same interrupt level.&n;&t; *&n;&t; * Also, we&squot;ve got to be careful not to trash gate&n;&t; * 0x80, because int 0x80 is hm, kind of importantish. ;)&n;&t; */
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NR_IRQS
suffix:semicolon
id|irq
op_increment
)paren
(brace
r_int
id|tmp
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|use_pci_vector
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|platform_legacy_irq
c_func
(paren
id|tmp
)paren
)paren
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|vector_to_irq
c_func
(paren
id|tmp
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IO_APIC_IRQ
c_func
(paren
id|tmp
)paren
op_logical_and
op_logical_neg
id|IO_APIC_VECTOR
c_func
(paren
id|tmp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Hmm.. We don&squot;t have an entry for this,&n;&t;&t;&t; * so default to an old-fashioned 8259&n;&t;&t;&t; * interrupt if we can..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
id|make_8259A_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_else
multiline_comment|/* Strange. Oh, well.. */
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|no_irq_type
suffix:semicolon
)brace
)brace
)brace
DECL|function|enable_lapic_irq
r_static
r_void
id|enable_lapic_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|v
op_amp
op_complement
id|APIC_LVT_MASKED
)paren
suffix:semicolon
)brace
DECL|function|disable_lapic_irq
r_static
r_void
id|disable_lapic_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|v
op_or
id|APIC_LVT_MASKED
)paren
suffix:semicolon
)brace
DECL|function|ack_lapic_irq
r_static
r_void
id|ack_lapic_irq
(paren
r_int
r_int
id|irq
)paren
(brace
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|end_lapic_irq
r_static
r_void
id|end_lapic_irq
(paren
r_int
r_int
id|i
)paren
(brace
multiline_comment|/* nothing */
)brace
DECL|variable|lapic_irq_type
r_static
r_struct
id|hw_interrupt_type
id|lapic_irq_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;local-APIC-edge&quot;
comma
dot
id|startup
op_assign
l_int|NULL
comma
multiline_comment|/* startup_irq() not used for IRQ0 */
dot
id|shutdown
op_assign
l_int|NULL
comma
multiline_comment|/* shutdown_irq() not used for IRQ0 */
dot
id|enable
op_assign
id|enable_lapic_irq
comma
dot
id|disable
op_assign
id|disable_lapic_irq
comma
dot
id|ack
op_assign
id|ack_lapic_irq
comma
dot
id|end
op_assign
id|end_lapic_irq
)brace
suffix:semicolon
DECL|function|setup_nmi
r_static
r_void
id|setup_nmi
(paren
r_void
)paren
(brace
multiline_comment|/*&n; &t; * Dirty trick to enable the NMI watchdog ...&n;&t; * We put the 8259A master into AEOI mode and&n;&t; * unmask on all local APICs LVT0 as NMI.&n;&t; *&n;&t; * The idea to use the 8259A in AEOI mode (&squot;8259A Virtual Wire&squot;)&n;&t; * is from Maciej W. Rozycki - so we do not have to EOI from&n;&t; * the NMI handler or the timer interrupt.&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;activating NMI Watchdog ...&quot;
)paren
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|enable_NMI_through_LVT0
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This looks a bit hackish but it&squot;s about the only one way of sending&n; * a few INTA cycles to 8259As and any associated glue logic.  ICR does&n; * not support the ExtINT mode, unfortunately.  We need to send these&n; * cycles as some i82489DX-based boards have glue logic that keeps the&n; * 8259A interrupt line asserted until INTA.  --macro&n; */
DECL|function|unlock_ExtINT_logic
r_static
r_inline
r_void
id|unlock_ExtINT_logic
c_func
(paren
r_void
)paren
(brace
r_int
id|pin
comma
id|i
suffix:semicolon
r_struct
id|IO_APIC_route_entry
id|entry0
comma
id|entry1
suffix:semicolon
r_int
r_char
id|save_control
comma
id|save_freq_select
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pin
op_assign
id|find_isa_irq_pin
c_func
(paren
l_int|8
comma
id|mp_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pin
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry0
)paren
op_plus
l_int|1
)paren
op_assign
id|io_apic_read
c_func
(paren
l_int|0
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry0
)paren
op_plus
l_int|0
)paren
op_assign
id|io_apic_read
c_func
(paren
l_int|0
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_IO_APIC_pin
c_func
(paren
l_int|0
comma
id|pin
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|entry1
comma
l_int|0
comma
r_sizeof
(paren
id|entry1
)paren
)paren
suffix:semicolon
id|entry1.dest_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* physical delivery */
id|entry1.mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unmask IRQ now */
id|entry1.dest.physical.physical_dest
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|entry1.delivery_mode
op_assign
id|dest_ExtINT
suffix:semicolon
id|entry1.polarity
op_assign
id|entry0.polarity
suffix:semicolon
id|entry1.trigger
op_assign
l_int|0
suffix:semicolon
id|entry1.vector
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry1
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry1
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|save_control
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|save_freq_select
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
(paren
id|save_freq_select
op_amp
op_complement
id|RTC_RATE_SELECT
)paren
op_or
l_int|0x6
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_control
op_or
id|RTC_PIE
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|i
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
op_amp
id|RTC_PF
)paren
op_eq
id|RTC_PF
)paren
id|i
op_sub_assign
l_int|10
suffix:semicolon
)brace
id|CMOS_WRITE
c_func
(paren
id|save_control
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_freq_select
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|clear_IO_APIC_pin
c_func
(paren
l_int|0
comma
id|pin
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry0
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
l_int|0
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry0
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This code may look a bit paranoid, but it&squot;s supposed to cooperate with&n; * a wide range of boards and BIOS bugs.  Fortunately only the timer IRQ&n; * is so screwy.  Thanks to Brian Perkins for testing/hacking this beast&n; * fanatically on his truly buggy board.&n; */
DECL|function|check_timer
r_static
r_inline
r_void
id|check_timer
c_func
(paren
r_void
)paren
(brace
r_int
id|pin1
comma
id|pin2
suffix:semicolon
r_int
id|vector
suffix:semicolon
multiline_comment|/*&n;&t; * get/set the timer IRQ vector:&n;&t; */
id|disable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|vector
op_assign
id|assign_irq_vector
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
id|vector
comma
id|interrupt
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Subtle, code in do_timer_interrupt() expects an AEOI&n;&t; * mode for the 8259A whenever interrupts are routed&n;&t; * through I/O APICs.  Also IRQ0 has to be enabled in&n;&t; * the 8259A which implies the virtual wire has to be&n;&t; * disabled in the local APIC.&n;&t; */
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|APIC_LVT_MASKED
op_or
id|APIC_DM_EXTINT
)paren
suffix:semicolon
id|init_8259A
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|timer_ack
op_assign
l_int|1
suffix:semicolon
id|enable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pin1
op_assign
id|find_isa_irq_pin
c_func
(paren
l_int|0
comma
id|mp_INT
)paren
suffix:semicolon
id|pin2
op_assign
id|find_isa_irq_pin
c_func
(paren
l_int|0
comma
id|mp_ExtINT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;..TIMER: vector=0x%02X pin1=%d pin2=%d&bslash;n&quot;
comma
id|vector
comma
id|pin1
comma
id|pin2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pin1
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, does IRQ0 through the IOAPIC work?&n;&t;&t; */
id|unmask_IO_APIC_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_irq_works
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|nmi_watchdog
op_eq
id|NMI_IO_APIC
)paren
(brace
id|disable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|setup_nmi
c_func
(paren
)paren
suffix:semicolon
id|enable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|check_nmi_watchdog
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|clear_IO_APIC_pin
c_func
(paren
l_int|0
comma
id|pin1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;..MP-BIOS bug: 8254 timer not connected to IO-APIC&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;...trying to set up timer (IRQ0) through the 8259A ... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pin2
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n..... (found pin %d) ...&quot;
comma
id|pin2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * legacy devices should be connected to IO APIC #0&n;&t;&t; */
id|setup_ExtINT_IRQ0_pin
c_func
(paren
id|pin2
comma
id|vector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_irq_works
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;works.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pin1
op_ne
op_minus
l_int|1
)paren
id|replace_pin_at_irq
c_func
(paren
l_int|0
comma
l_int|0
comma
id|pin1
comma
l_int|0
comma
id|pin2
)paren
suffix:semicolon
r_else
id|add_pin_to_irq
c_func
(paren
l_int|0
comma
l_int|0
comma
id|pin2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmi_watchdog
op_eq
id|NMI_IO_APIC
)paren
(brace
id|setup_nmi
c_func
(paren
)paren
suffix:semicolon
id|check_nmi_watchdog
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Cleanup, just in case ...&n;&t;&t; */
id|clear_IO_APIC_pin
c_func
(paren
l_int|0
comma
id|pin2
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmi_watchdog
op_eq
id|NMI_IO_APIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;timer doesn&squot;t work through the IO-APIC - disabling NMI Watchdog!&bslash;n&quot;
)paren
suffix:semicolon
id|nmi_watchdog
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;...trying to set up timer as Virtual Wire IRQ...&quot;
)paren
suffix:semicolon
id|disable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|irq_desc
(braket
l_int|0
)braket
dot
id|handler
op_assign
op_amp
id|lapic_irq_type
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|APIC_DM_FIXED
op_or
id|vector
)paren
suffix:semicolon
multiline_comment|/* Fixed mode */
id|enable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_irq_works
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; works.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|APIC_LVT_MASKED
op_or
id|APIC_DM_FIXED
op_or
id|vector
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;...trying to set up timer as ExtINT IRQ...&quot;
)paren
suffix:semicolon
id|timer_ack
op_assign
l_int|0
suffix:semicolon
id|init_8259A
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|make_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|APIC_DM_EXTINT
)paren
suffix:semicolon
id|unlock_ExtINT_logic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_irq_works
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; works.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; failed :(.&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;IO-APIC + timer doesn&squot;t work! pester mingo@redhat.com&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * IRQ&squot;s that are handled by the PIC in the MPS IOAPIC case.&n; * - IRQ2 is the cascade IRQ, and cannot be a io-apic IRQ.&n; *   Linux doesn&squot;t really care, as it&squot;s not actually used&n; *   for any interrupt handling anyway.&n; */
DECL|macro|PIC_IRQS
mdefine_line|#define PIC_IRQS&t;(1 &lt;&lt; PIC_CASCADE_IR)
DECL|function|setup_IO_APIC
r_void
id|__init
id|setup_IO_APIC
c_func
(paren
r_void
)paren
(brace
id|enable_IO_APIC
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_ioapic
)paren
id|io_apic_irqs
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* all IRQs go through IOAPIC */
r_else
id|io_apic_irqs
op_assign
op_complement
id|PIC_IRQS
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ENABLING IO-APIC IRQs&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up IO-APIC IRQ routing.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ioapic
)paren
id|setup_ioapic_ids_from_mpc
c_func
(paren
)paren
suffix:semicolon
id|sync_Arb_IDs
c_func
(paren
)paren
suffix:semicolon
id|setup_IO_APIC_irqs
c_func
(paren
)paren
suffix:semicolon
id|init_IO_APIC_traps
c_func
(paren
)paren
suffix:semicolon
id|check_timer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_ioapic
)paren
id|print_IO_APIC
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called after all the initialization is done. If we didnt find any&n; *&t;APIC bugs then we can allow the modify fast path&n; */
DECL|function|io_apic_bug_finalize
r_static
r_int
id|__init
id|io_apic_bug_finalize
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|sis_apic_bug
op_eq
op_minus
l_int|1
)paren
(brace
id|sis_apic_bug
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|io_apic_bug_finalize
id|late_initcall
c_func
(paren
id|io_apic_bug_finalize
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------------&n;                          ACPI-based IOAPIC Configuration&n;   -------------------------------------------------------------------------- */
macro_line|#ifdef CONFIG_ACPI_BOOT
DECL|function|io_apic_get_unique_id
r_int
id|__init
id|io_apic_get_unique_id
(paren
r_int
id|ioapic
comma
r_int
id|apic_id
)paren
(brace
r_union
id|IO_APIC_reg_00
id|reg_00
suffix:semicolon
r_static
id|physid_mask_t
id|apic_id_map
op_assign
id|PHYSID_MASK_NONE
suffix:semicolon
id|physid_mask_t
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The P4 platform supports up to 256 APIC IDs on two separate APIC &n;&t; * buses (one for LAPICs, one for IOAPICs), where predecessors only &n;&t; * supports up to 16 on one shared APIC bus.&n;&t; * &n;&t; * TBD: Expand LAPIC/IOAPIC support on P4-class systems to take full&n;&t; *      advantage of new APIC bus architecture.&n;&t; */
r_if
c_cond
(paren
id|physids_empty
c_func
(paren
id|apic_id_map
)paren
)paren
id|apic_id_map
op_assign
id|ioapic_phys_id_map
c_func
(paren
id|phys_cpu_present_map
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_00.raw
op_assign
id|io_apic_read
c_func
(paren
id|ioapic
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apic_id
op_ge
id|get_physical_broadcast
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOAPIC[%d]: Invalid apic_id %d, trying &quot;
l_string|&quot;%d&bslash;n&quot;
comma
id|ioapic
comma
id|apic_id
comma
id|reg_00.bits.ID
)paren
suffix:semicolon
id|apic_id
op_assign
id|reg_00.bits.ID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Every APIC in a system must have a unique ID or we get lots of nice &n;&t; * &squot;stuck on smp_invalidate_needed IPI wait&squot; messages.&n;&t; */
r_if
c_cond
(paren
id|check_apicid_used
c_func
(paren
id|apic_id_map
comma
id|apic_id
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_physical_broadcast
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_apicid_used
c_func
(paren
id|apic_id_map
comma
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|get_physical_broadcast
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Max apic_id exceeded!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOAPIC[%d]: apic_id %d already used, &quot;
l_string|&quot;trying %d&bslash;n&quot;
comma
id|ioapic
comma
id|apic_id
comma
id|i
)paren
suffix:semicolon
id|apic_id
op_assign
id|i
suffix:semicolon
)brace
id|tmp
op_assign
id|apicid_to_cpu_present
c_func
(paren
id|apic_id
)paren
suffix:semicolon
id|physids_or
c_func
(paren
id|apic_id_map
comma
id|apic_id_map
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_00.bits.ID
op_ne
id|apic_id
)paren
(brace
id|reg_00.bits.ID
op_assign
id|apic_id
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|ioapic
comma
l_int|0
comma
id|reg_00.raw
)paren
suffix:semicolon
id|reg_00.raw
op_assign
id|io_apic_read
c_func
(paren
id|ioapic
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|reg_00.bits.ID
op_ne
id|apic_id
)paren
id|panic
c_func
(paren
l_string|&quot;IOAPIC[%d]: Unable change apic_id!&bslash;n&quot;
comma
id|ioapic
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IOAPIC[%d]: Assigned apic_id %d&bslash;n&quot;
comma
id|ioapic
comma
id|apic_id
)paren
suffix:semicolon
r_return
id|apic_id
suffix:semicolon
)brace
DECL|function|io_apic_get_version
r_int
id|__init
id|io_apic_get_version
(paren
r_int
id|ioapic
)paren
(brace
r_union
id|IO_APIC_reg_01
id|reg_01
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_01.raw
op_assign
id|io_apic_read
c_func
(paren
id|ioapic
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|reg_01.bits.version
suffix:semicolon
)brace
DECL|function|io_apic_get_redir_entries
r_int
id|__init
id|io_apic_get_redir_entries
(paren
r_int
id|ioapic
)paren
(brace
r_union
id|IO_APIC_reg_01
id|reg_01
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|reg_01.raw
op_assign
id|io_apic_read
c_func
(paren
id|ioapic
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|reg_01.bits.entries
suffix:semicolon
)brace
DECL|function|io_apic_set_pci_routing
r_int
id|io_apic_set_pci_routing
(paren
r_int
id|ioapic
comma
r_int
id|pin
comma
r_int
id|irq
comma
r_int
id|edge_level
comma
r_int
id|active_high_low
)paren
(brace
r_struct
id|IO_APIC_route_entry
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IO_APIC_IRQ
c_func
(paren
id|irq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IOAPIC[%d]: Invalid reference to IRQ 0&bslash;n&quot;
comma
id|ioapic
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Generate a PCI IRQ routing entry and program the IOAPIC accordingly.&n;&t; * Note that we mask (disable) IRQs now -- these get enabled when the&n;&t; * corresponding device driver registers for this IRQ.&n;&t; */
id|memset
c_func
(paren
op_amp
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
id|entry.delivery_mode
op_assign
id|INT_DELIVERY_MODE
suffix:semicolon
id|entry.dest_mode
op_assign
id|INT_DEST_MODE
suffix:semicolon
id|entry.dest.logical.logical_dest
op_assign
id|cpu_mask_to_apicid
c_func
(paren
id|TARGET_CPUS
)paren
suffix:semicolon
id|entry.trigger
op_assign
id|edge_level
suffix:semicolon
id|entry.polarity
op_assign
id|active_high_low
suffix:semicolon
id|entry.mask
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * IRQs &lt; 16 are already in the irq_2_pin[] map&n;&t; */
r_if
c_cond
(paren
id|irq
op_ge
l_int|16
)paren
id|add_pin_to_irq
c_func
(paren
id|irq
comma
id|ioapic
comma
id|pin
)paren
suffix:semicolon
id|entry.vector
op_assign
id|assign_irq_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;IOAPIC[%d]: Set PCI routing entry (%d-%d -&gt; 0x%x -&gt; &quot;
l_string|&quot;IRQ %d Mode:%i Active:%i)&bslash;n&quot;
comma
id|ioapic
comma
id|mp_ioapics
(braket
id|ioapic
)braket
dot
id|mpc_apicid
comma
id|pin
comma
id|entry.vector
comma
id|irq
comma
id|edge_level
comma
id|active_high_low
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_pci_vector
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|platform_legacy_irq
c_func
(paren
id|irq
)paren
)paren
id|irq
op_assign
id|IO_APIC_VECTOR
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|edge_level
)paren
(brace
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_level_type
suffix:semicolon
)brace
r_else
(brace
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|ioapic_edge_type
suffix:semicolon
)brace
id|set_intr_gate
c_func
(paren
id|entry.vector
comma
id|interrupt
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioapic
op_logical_and
(paren
id|irq
OL
l_int|16
)paren
)paren
id|disable_8259A_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|ioapic
comma
l_int|0x11
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|io_apic_write
c_func
(paren
id|ioapic
comma
l_int|0x10
op_plus
l_int|2
op_star
id|pin
comma
op_star
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|entry
)paren
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioapic_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /*CONFIG_ACPI_BOOT*/
eof
