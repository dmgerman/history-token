multiline_comment|/*&n; *&t;linux/arch/i386/kernel/irq.c&n; *&n; *&t;Copyright (C) 1992, 1998 Linus Torvalds, Ingo Molnar&n; *&n; * This file contains the lowest level x86-specific interrupt&n; * entry, irq-stacks and irq statistics code. All the remaining&n; * irq logic is done by the generic kernel/irq/ code and&n; * by the x86-specific irq controller code. (e.g. i8259.c and&n; * io_apic.c.)&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#ifndef CONFIG_X86_LOCAL_APIC
multiline_comment|/*&n; * &squot;what should we do if we get a hw irq event on an illegal vector&squot;.&n; * each architecture has to answer this themselves.&n; */
DECL|function|ack_bad_irq
r_void
id|ack_bad_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unexpected IRQ trap at vector %02x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_4KSTACKS
multiline_comment|/*&n; * per-CPU IRQ handling contexts (thread information and stack)&n; */
DECL|union|irq_ctx
r_union
id|irq_ctx
(brace
DECL|member|tinfo
r_struct
id|thread_info
id|tinfo
suffix:semicolon
DECL|member|stack
id|u32
id|stack
(braket
id|THREAD_SIZE
op_div
r_sizeof
(paren
id|u32
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|hardirq_ctx
r_static
r_union
id|irq_ctx
op_star
id|hardirq_ctx
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|softirq_ctx
r_static
r_union
id|irq_ctx
op_star
id|softirq_ctx
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * do_IRQ handles all normal device IRQ&squot;s (the special&n; * SMP cross-CPU interrupts have their own specific&n; * handlers).&n; */
DECL|function|do_IRQ
id|asmlinkage
r_int
r_int
id|do_IRQ
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
multiline_comment|/* high bits used in ret_from_ code */
r_int
id|irq
op_assign
id|regs.orig_eax
op_amp
l_int|0xff
suffix:semicolon
macro_line|#ifdef CONFIG_4KSTACKS
r_union
id|irq_ctx
op_star
id|curctx
comma
op_star
id|irqctx
suffix:semicolon
id|u32
op_star
id|isp
suffix:semicolon
macro_line|#endif
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_STACKOVERFLOW
multiline_comment|/* Debugging check for stack overflow: is there less than 1KB free? */
(brace
r_int
id|esp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;andl %%esp,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|esp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|esp
OL
(paren
r_sizeof
(paren
r_struct
id|thread_info
)paren
op_plus
id|STACK_WARN
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;do_IRQ: stack overflow: %ld&bslash;n&quot;
comma
id|esp
op_minus
r_sizeof
(paren
r_struct
id|thread_info
)paren
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_4KSTACKS
id|curctx
op_assign
(paren
r_union
id|irq_ctx
op_star
)paren
id|current_thread_info
c_func
(paren
)paren
suffix:semicolon
id|irqctx
op_assign
id|hardirq_ctx
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * this is where we switch to the IRQ stack. However, if we are&n;&t; * already using the IRQ stack (because we interrupted a hardirq&n;&t; * handler) we can&squot;t do that and just have to keep using the&n;&t; * current stack (which is the irq stack already after all)&n;&t; */
r_if
c_cond
(paren
id|curctx
op_ne
id|irqctx
)paren
(brace
multiline_comment|/* build the stack frame on the IRQ stack */
id|isp
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|irqctx
op_plus
r_sizeof
(paren
op_star
id|irqctx
)paren
)paren
suffix:semicolon
id|irqctx-&gt;tinfo.task
op_assign
id|curctx-&gt;tinfo.task
suffix:semicolon
id|irqctx-&gt;tinfo.previous_esp
op_assign
id|current_stack_pointer
c_func
(paren
)paren
suffix:semicolon
op_star
op_decrement
id|isp
op_assign
(paren
id|u32
)paren
op_amp
id|regs
suffix:semicolon
op_star
op_decrement
id|isp
op_assign
(paren
id|u32
)paren
id|irq
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;       xchgl   %%ebx,%%esp      &bslash;n&quot;
l_string|&quot;       call    __do_IRQ         &bslash;n&quot;
l_string|&quot;       xchgl   %%ebx,%%esp      &bslash;n&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
id|isp
)paren
suffix:colon
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
comma
l_string|&quot;eax&quot;
comma
l_string|&quot;edx&quot;
comma
l_string|&quot;ecx&quot;
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|__do_IRQ
c_func
(paren
id|irq
comma
op_amp
id|regs
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_4KSTACKS
multiline_comment|/*&n; * These should really be __section__(&quot;.bss.page_aligned&quot;) as well, but&n; * gcc&squot;s 3.0 and earlier don&squot;t handle that correctly.&n; */
DECL|variable|softirq_stack
r_static
r_char
id|softirq_stack
(braket
id|NR_CPUS
op_star
id|THREAD_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|THREAD_SIZE
)paren
)paren
)paren
suffix:semicolon
DECL|variable|hardirq_stack
r_static
r_char
id|hardirq_stack
(braket
id|NR_CPUS
op_star
id|THREAD_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|THREAD_SIZE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * allocate per-cpu stacks for hardirq and for softirq processing&n; */
DECL|function|irq_ctx_init
r_void
id|irq_ctx_init
c_func
(paren
r_int
id|cpu
)paren
(brace
r_union
id|irq_ctx
op_star
id|irqctx
suffix:semicolon
r_if
c_cond
(paren
id|hardirq_ctx
(braket
id|cpu
)braket
)paren
r_return
suffix:semicolon
id|irqctx
op_assign
(paren
r_union
id|irq_ctx
op_star
)paren
op_amp
id|hardirq_stack
(braket
id|cpu
op_star
id|THREAD_SIZE
)braket
suffix:semicolon
id|irqctx-&gt;tinfo.task
op_assign
l_int|NULL
suffix:semicolon
id|irqctx-&gt;tinfo.exec_domain
op_assign
l_int|NULL
suffix:semicolon
id|irqctx-&gt;tinfo.cpu
op_assign
id|cpu
suffix:semicolon
id|irqctx-&gt;tinfo.preempt_count
op_assign
id|HARDIRQ_OFFSET
suffix:semicolon
id|irqctx-&gt;tinfo.addr_limit
op_assign
id|MAKE_MM_SEG
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|hardirq_ctx
(braket
id|cpu
)braket
op_assign
id|irqctx
suffix:semicolon
id|irqctx
op_assign
(paren
r_union
id|irq_ctx
op_star
)paren
op_amp
id|softirq_stack
(braket
id|cpu
op_star
id|THREAD_SIZE
)braket
suffix:semicolon
id|irqctx-&gt;tinfo.task
op_assign
l_int|NULL
suffix:semicolon
id|irqctx-&gt;tinfo.exec_domain
op_assign
l_int|NULL
suffix:semicolon
id|irqctx-&gt;tinfo.cpu
op_assign
id|cpu
suffix:semicolon
id|irqctx-&gt;tinfo.preempt_count
op_assign
id|SOFTIRQ_OFFSET
suffix:semicolon
id|irqctx-&gt;tinfo.addr_limit
op_assign
id|MAKE_MM_SEG
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|softirq_ctx
(braket
id|cpu
)braket
op_assign
id|irqctx
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU %u irqstacks, hard=%p soft=%p&bslash;n&quot;
comma
id|cpu
comma
id|hardirq_ctx
(braket
id|cpu
)braket
comma
id|softirq_ctx
(braket
id|cpu
)braket
)paren
suffix:semicolon
)brace
r_extern
id|asmlinkage
r_void
id|__do_softirq
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|do_softirq
id|asmlinkage
r_void
id|do_softirq
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|thread_info
op_star
id|curctx
suffix:semicolon
r_union
id|irq_ctx
op_star
id|irqctx
suffix:semicolon
id|u32
op_star
id|isp
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_softirq_pending
c_func
(paren
)paren
)paren
(brace
id|curctx
op_assign
id|current_thread_info
c_func
(paren
)paren
suffix:semicolon
id|irqctx
op_assign
id|softirq_ctx
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
id|irqctx-&gt;tinfo.task
op_assign
id|curctx-&gt;task
suffix:semicolon
id|irqctx-&gt;tinfo.previous_esp
op_assign
id|current_stack_pointer
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* build the stack frame on the softirq stack */
id|isp
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|irqctx
op_plus
r_sizeof
(paren
op_star
id|irqctx
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;       xchgl   %%ebx,%%esp     &bslash;n&quot;
l_string|&quot;       call    __do_softirq    &bslash;n&quot;
l_string|&quot;       movl    %%ebx,%%esp     &bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|isp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|isp
)paren
suffix:colon
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
comma
l_string|&quot;edx&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;eax&quot;
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|do_softirq
id|EXPORT_SYMBOL
c_func
(paren
id|do_softirq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Interrupt statistics:&n; */
DECL|variable|irq_err_count
id|atomic_t
id|irq_err_count
suffix:semicolon
multiline_comment|/*&n; * /proc/interrupts printing:&n; */
DECL|function|show_interrupts
r_int
id|show_interrupts
c_func
(paren
r_struct
id|seq_file
op_star
id|p
comma
r_void
op_star
id|v
)paren
(brace
r_int
id|i
op_assign
op_star
(paren
id|loff_t
op_star
)paren
id|v
comma
id|j
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;           &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d       &quot;
comma
id|j
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|NR_IRQS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_desc
(braket
id|i
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
id|action
op_assign
id|irq_desc
(braket
id|i
)braket
dot
id|action
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_goto
id|skip
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_cpu
c_func
(paren
id|j
)paren
dot
id|irqs
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot; %14s&quot;
comma
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_member_access_from_pointer
r_typename
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;  %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;, %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|skip
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_desc
(braket
id|i
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_eq
id|NR_IRQS
)paren
(brace
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;NMI: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|nmi_count
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;LOC: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|j
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|irq_stat
(braket
id|j
)braket
dot
id|apic_timer_irqs
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;ERR: %10u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|irq_err_count
)paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_X86_IO_APIC)
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;MIS: %10u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|irq_mis_count
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
