multiline_comment|/*&n; * This code largely moved from arch/i386/kernel/time.c.&n; * See comments there for proper credits.&n; */
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &quot;io_ports.h&quot;
macro_line|#include &quot;mach_timer.h&quot;
macro_line|#include &lt;asm/hpet.h&gt;
DECL|variable|hpet_usec_quotient
r_static
r_int
r_int
id|hpet_usec_quotient
suffix:semicolon
multiline_comment|/* convert hpet clks to usec */
DECL|variable|tsc_hpet_quotient
r_static
r_int
r_int
id|tsc_hpet_quotient
suffix:semicolon
multiline_comment|/* convert tsc to hpet clks */
DECL|variable|hpet_last
r_static
r_int
r_int
id|hpet_last
suffix:semicolon
multiline_comment|/* hpet counter value at last tick*/
DECL|variable|last_tsc_low
r_static
r_int
r_int
id|last_tsc_low
suffix:semicolon
multiline_comment|/* lsb 32 bits of Time Stamp Counter */
DECL|variable|last_tsc_high
r_static
r_int
r_int
id|last_tsc_high
suffix:semicolon
multiline_comment|/* msb 32 bits of Time Stamp Counter */
DECL|variable|monotonic_base
r_static
r_int
r_int
r_int
id|monotonic_base
suffix:semicolon
DECL|variable|monotonic_lock
r_static
id|seqlock_t
id|monotonic_lock
op_assign
id|SEQLOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* convert from cycles(64bits) =&gt; nanoseconds (64bits)&n; *  basic equation:&n; *&t;&t;ns = cycles / (freq / ns_per_sec)&n; *&t;&t;ns = cycles * (ns_per_sec / freq)&n; *&t;&t;ns = cycles * (10^9 / (cpu_mhz * 10^6))&n; *&t;&t;ns = cycles * (10^3 / cpu_mhz)&n; *&n; *&t;Then we use scaling math (suggested by george@mvista.com) to get:&n; *&t;&t;ns = cycles * (10^3 * SC / cpu_mhz) / SC&n; *&t;&t;ns = cycles * cyc2ns_scale / SC&n; *&n; *&t;And since SC is a constant power of two, we can convert the div&n; *  into a shift.&n; *&t;&t;&t;-johnstul@us.ibm.com &quot;math is hard, lets go shopping!&quot;&n; */
DECL|variable|cyc2ns_scale
r_static
r_int
r_int
id|cyc2ns_scale
suffix:semicolon
DECL|macro|CYC2NS_SCALE_FACTOR
mdefine_line|#define CYC2NS_SCALE_FACTOR 10 /* 2^10, carefully chosen */
DECL|function|set_cyc2ns_scale
r_static
r_inline
r_void
id|set_cyc2ns_scale
c_func
(paren
r_int
r_int
id|cpu_mhz
)paren
(brace
id|cyc2ns_scale
op_assign
(paren
l_int|1000
op_lshift
id|CYC2NS_SCALE_FACTOR
)paren
op_div
id|cpu_mhz
suffix:semicolon
)brace
DECL|function|cycles_2_ns
r_static
r_inline
r_int
r_int
r_int
id|cycles_2_ns
c_func
(paren
r_int
r_int
r_int
id|cyc
)paren
(brace
r_return
(paren
id|cyc
op_star
id|cyc2ns_scale
)paren
op_rshift
id|CYC2NS_SCALE_FACTOR
suffix:semicolon
)brace
DECL|function|monotonic_clock_hpet
r_static
r_int
r_int
r_int
id|monotonic_clock_hpet
c_func
(paren
r_void
)paren
(brace
r_int
r_int
r_int
id|last_offset
comma
id|this_offset
comma
id|base
suffix:semicolon
r_int
id|seq
suffix:semicolon
multiline_comment|/* atomically read monotonic base &amp; last_offset */
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
id|last_offset
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|last_tsc_high
op_lshift
l_int|32
)paren
op_or
id|last_tsc_low
suffix:semicolon
id|base
op_assign
id|monotonic_base
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|monotonic_lock
comma
id|seq
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the Time Stamp Counter */
id|rdtscll
c_func
(paren
id|this_offset
)paren
suffix:semicolon
multiline_comment|/* return the value in ns */
r_return
id|base
op_plus
id|cycles_2_ns
c_func
(paren
id|this_offset
op_minus
id|last_offset
)paren
suffix:semicolon
)brace
DECL|function|get_offset_hpet
r_static
r_int
r_int
id|get_offset_hpet
c_func
(paren
r_void
)paren
(brace
r_register
r_int
r_int
id|eax
comma
id|edx
suffix:semicolon
id|eax
op_assign
id|hpet_readl
c_func
(paren
id|HPET_COUNTER
)paren
suffix:semicolon
id|eax
op_sub_assign
id|hpet_last
suffix:semicolon
multiline_comment|/* hpet delta */
multiline_comment|/*&n;         * Time offset = (hpet delta) * ( usecs per HPET clock )&n;&t; *             = (hpet delta) * ( usecs per tick / HPET clocks per tick)&n;&t; *             = (hpet delta) * ( hpet_usec_quotient ) / (2^32)&n;&t; *&n;&t; * Where,&n;&t; * hpet_usec_quotient = (2^32 * usecs per tick)/HPET clocks per tick&n;&t; *&n;&t; * Using a mull instead of a divl saves some cycles in critical path.&n;         */
id|ASM_MUL64_REG
c_func
(paren
id|eax
comma
id|edx
comma
id|hpet_usec_quotient
comma
id|eax
)paren
suffix:semicolon
multiline_comment|/* our adjusted time offset in microseconds */
r_return
id|edx
suffix:semicolon
)brace
DECL|function|mark_offset_hpet
r_static
r_void
id|mark_offset_hpet
c_func
(paren
r_void
)paren
(brace
r_int
r_int
r_int
id|this_offset
comma
id|last_offset
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|write_seqlock
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
id|last_offset
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|last_tsc_high
op_lshift
l_int|32
)paren
op_or
id|last_tsc_low
suffix:semicolon
id|rdtsc
c_func
(paren
id|last_tsc_low
comma
id|last_tsc_high
)paren
suffix:semicolon
id|offset
op_assign
id|hpet_readl
c_func
(paren
id|HPET_T0_CMP
)paren
op_minus
id|hpet_tick
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
id|offset
op_minus
id|hpet_last
)paren
OG
id|hpet_tick
)paren
op_logical_and
(paren
id|hpet_last
op_ne
l_int|0
)paren
)paren
)paren
(brace
r_int
id|lost_ticks
op_assign
(paren
id|offset
op_minus
id|hpet_last
)paren
op_div
id|hpet_tick
suffix:semicolon
id|jiffies
op_add_assign
id|lost_ticks
suffix:semicolon
)brace
id|hpet_last
op_assign
id|offset
suffix:semicolon
multiline_comment|/* update the monotonic base value */
id|this_offset
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|last_tsc_high
op_lshift
l_int|32
)paren
op_or
id|last_tsc_low
suffix:semicolon
id|monotonic_base
op_add_assign
id|cycles_2_ns
c_func
(paren
id|this_offset
op_minus
id|last_offset
)paren
suffix:semicolon
id|write_sequnlock
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
)brace
DECL|function|delay_hpet
r_void
id|delay_hpet
c_func
(paren
r_int
r_int
id|loops
)paren
(brace
r_int
r_int
id|hpet_start
comma
id|hpet_end
suffix:semicolon
r_int
r_int
id|eax
suffix:semicolon
multiline_comment|/* loops is the number of cpu cycles. Convert it to hpet clocks */
id|ASM_MUL64_REG
c_func
(paren
id|eax
comma
id|loops
comma
id|tsc_hpet_quotient
comma
id|loops
)paren
suffix:semicolon
id|hpet_start
op_assign
id|hpet_readl
c_func
(paren
id|HPET_COUNTER
)paren
suffix:semicolon
r_do
(brace
id|rep_nop
c_func
(paren
)paren
suffix:semicolon
id|hpet_end
op_assign
id|hpet_readl
c_func
(paren
id|HPET_COUNTER
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hpet_end
op_minus
id|hpet_start
)paren
OL
(paren
id|loops
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_hpet
r_static
r_int
id|__init
id|init_hpet
c_func
(paren
r_char
op_star
id|override
)paren
(brace
r_int
r_int
id|result
comma
id|remain
suffix:semicolon
multiline_comment|/* check clock override */
r_if
c_cond
(paren
id|override
(braket
l_int|0
)braket
op_logical_and
id|strncmp
c_func
(paren
id|override
comma
l_string|&quot;hpet&quot;
comma
l_int|4
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_hpet_enabled
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using HPET for gettimeofday&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_tsc
)paren
(brace
r_int
r_int
id|tsc_quotient
op_assign
id|calibrate_tsc_hpet
c_func
(paren
op_amp
id|tsc_hpet_quotient
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsc_quotient
)paren
(brace
multiline_comment|/* report CPU clock rate in Hz.&n;&t;&t;&t; * The formula is (10^6 * 2^32) / (2^32 * 1 / (clocks/us)) =&n;&t;&t;&t; * clock/second. Our precision is about 100 ppm.&n;&t;&t;&t; */
(brace
r_int
r_int
id|eax
op_assign
l_int|0
comma
id|edx
op_assign
l_int|1000
suffix:semicolon
id|ASM_DIV64_REG
c_func
(paren
id|cpu_khz
comma
id|edx
comma
id|tsc_quotient
comma
id|eax
comma
id|edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Detected %lu.%03lu MHz processor.&bslash;n&quot;
comma
id|cpu_khz
op_div
l_int|1000
comma
id|cpu_khz
op_mod
l_int|1000
)paren
suffix:semicolon
)brace
id|set_cyc2ns_scale
c_func
(paren
id|cpu_khz
op_div
l_int|1000
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Math to calculate hpet to usec multiplier&n;&t; * Look for the comments at get_offset_hpet()&n;&t; */
id|ASM_DIV64_REG
c_func
(paren
id|result
comma
id|remain
comma
id|hpet_tick
comma
l_int|0
comma
id|KERNEL_TICK_USEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remain
OG
(paren
id|hpet_tick
op_rshift
l_int|1
)paren
)paren
id|result
op_increment
suffix:semicolon
multiline_comment|/* rounding the result */
id|hpet_usec_quotient
op_assign
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/************************************************************/
multiline_comment|/* tsc timer_opts struct */
DECL|variable|timer_hpet
r_struct
id|timer_opts
id|timer_hpet
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;hpet&quot;
comma
dot
id|init
op_assign
id|init_hpet
comma
dot
id|mark_offset
op_assign
id|mark_offset_hpet
comma
dot
id|get_offset
op_assign
id|get_offset_hpet
comma
dot
id|monotonic_clock
op_assign
id|monotonic_clock_hpet
comma
dot
id|delay
op_assign
id|delay_hpet
comma
)brace
suffix:semicolon
eof
