multiline_comment|/*&n; *&t;Common functions used across the timers go here&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/hpet.h&gt;
macro_line|#include &quot;mach_timer.h&quot;
multiline_comment|/* ------ Calibrate the TSC -------&n; * Return 2^32 * (1 / (TSC clocks per usec)) for do_fast_gettimeoffset().&n; * Too much 64-bit arithmetic here to do this cleanly in C, and for&n; * accuracy&squot;s sake we want to keep the overhead on the CTC speaker (channel 2)&n; * output busy loop as low as possible. We avoid reading the CTC registers&n; * directly because of the awkward 8-bit access mechanism of the 82C54&n; * device.&n; */
DECL|macro|CALIBRATE_TIME
mdefine_line|#define CALIBRATE_TIME&t;(5 * 1000020/HZ)
DECL|function|calibrate_tsc
r_int
r_int
id|__init
id|calibrate_tsc
c_func
(paren
r_void
)paren
(brace
id|mach_prepare_counter
c_func
(paren
)paren
suffix:semicolon
(brace
r_int
r_int
id|startlow
comma
id|starthigh
suffix:semicolon
r_int
r_int
id|endlow
comma
id|endhigh
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
id|rdtsc
c_func
(paren
id|startlow
comma
id|starthigh
)paren
suffix:semicolon
id|mach_countup
c_func
(paren
op_amp
id|count
)paren
suffix:semicolon
id|rdtsc
c_func
(paren
id|endlow
comma
id|endhigh
)paren
suffix:semicolon
multiline_comment|/* Error: ECTCNEVERSET */
r_if
c_cond
(paren
id|count
op_le
l_int|1
)paren
r_goto
id|bad_ctc
suffix:semicolon
multiline_comment|/* 64-bit subtract - gcc just messes up with long longs */
id|__asm__
c_func
(paren
l_string|&quot;subl %2,%0&bslash;n&bslash;t&quot;
l_string|&quot;sbbl %3,%1&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|endlow
)paren
comma
l_string|&quot;=d&quot;
(paren
id|endhigh
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|startlow
)paren
comma
l_string|&quot;g&quot;
(paren
id|starthigh
)paren
comma
l_string|&quot;0&quot;
(paren
id|endlow
)paren
comma
l_string|&quot;1&quot;
(paren
id|endhigh
)paren
)paren
suffix:semicolon
multiline_comment|/* Error: ECPUTOOFAST */
r_if
c_cond
(paren
id|endhigh
)paren
r_goto
id|bad_ctc
suffix:semicolon
multiline_comment|/* Error: ECPUTOOSLOW */
r_if
c_cond
(paren
id|endlow
op_le
id|CALIBRATE_TIME
)paren
r_goto
id|bad_ctc
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;divl %2&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|endlow
)paren
comma
l_string|&quot;=d&quot;
(paren
id|endhigh
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|endlow
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;1&quot;
(paren
id|CALIBRATE_TIME
)paren
)paren
suffix:semicolon
r_return
id|endlow
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The CTC wasn&squot;t reliable: we got a hit on the very first read,&n;&t; * or the CPU was so fast/slow that the quotient wouldn&squot;t fit in&n;&t; * 32 bits..&n;&t; */
id|bad_ctc
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HPET_TIMER
multiline_comment|/* ------ Calibrate the TSC using HPET -------&n; * Return 2^32 * (1 / (TSC clocks per usec)) for getting the CPU freq.&n; * Second output is parameter 1 (when non NULL)&n; * Set 2^32 * (1 / (tsc per HPET clk)) for delay_hpet().&n; * calibrate_tsc() calibrates the processor TSC by comparing&n; * it to the HPET timer of known frequency.&n; * Too much 64-bit arithmetic here to do this cleanly in C&n; */
DECL|macro|CALIBRATE_CNT_HPET
mdefine_line|#define CALIBRATE_CNT_HPET &t;(5 * hpet_tick)
DECL|macro|CALIBRATE_TIME_HPET
mdefine_line|#define CALIBRATE_TIME_HPET &t;(5 * KERNEL_TICK_USEC)
DECL|function|calibrate_tsc_hpet
r_int
r_int
id|__init
id|calibrate_tsc_hpet
c_func
(paren
r_int
r_int
op_star
id|tsc_hpet_quotient_ptr
)paren
(brace
r_int
r_int
id|tsc_startlow
comma
id|tsc_starthigh
suffix:semicolon
r_int
r_int
id|tsc_endlow
comma
id|tsc_endhigh
suffix:semicolon
r_int
r_int
id|hpet_start
comma
id|hpet_end
suffix:semicolon
r_int
r_int
id|result
comma
id|remain
suffix:semicolon
id|hpet_start
op_assign
id|hpet_readl
c_func
(paren
id|HPET_COUNTER
)paren
suffix:semicolon
id|rdtsc
c_func
(paren
id|tsc_startlow
comma
id|tsc_starthigh
)paren
suffix:semicolon
r_do
(brace
id|hpet_end
op_assign
id|hpet_readl
c_func
(paren
id|HPET_COUNTER
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hpet_end
op_minus
id|hpet_start
)paren
OL
id|CALIBRATE_CNT_HPET
)paren
suffix:semicolon
id|rdtsc
c_func
(paren
id|tsc_endlow
comma
id|tsc_endhigh
)paren
suffix:semicolon
multiline_comment|/* 64-bit subtract - gcc just messes up with long longs */
id|__asm__
c_func
(paren
l_string|&quot;subl %2,%0&bslash;n&bslash;t&quot;
l_string|&quot;sbbl %3,%1&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|tsc_endlow
)paren
comma
l_string|&quot;=d&quot;
(paren
id|tsc_endhigh
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|tsc_startlow
)paren
comma
l_string|&quot;g&quot;
(paren
id|tsc_starthigh
)paren
comma
l_string|&quot;0&quot;
(paren
id|tsc_endlow
)paren
comma
l_string|&quot;1&quot;
(paren
id|tsc_endhigh
)paren
)paren
suffix:semicolon
multiline_comment|/* Error: ECPUTOOFAST */
r_if
c_cond
(paren
id|tsc_endhigh
)paren
r_goto
id|bad_calibration
suffix:semicolon
multiline_comment|/* Error: ECPUTOOSLOW */
r_if
c_cond
(paren
id|tsc_endlow
op_le
id|CALIBRATE_TIME_HPET
)paren
r_goto
id|bad_calibration
suffix:semicolon
id|ASM_DIV64_REG
c_func
(paren
id|result
comma
id|remain
comma
id|tsc_endlow
comma
l_int|0
comma
id|CALIBRATE_TIME_HPET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remain
OG
(paren
id|tsc_endlow
op_rshift
l_int|1
)paren
)paren
id|result
op_increment
suffix:semicolon
multiline_comment|/* rounding the result */
r_if
c_cond
(paren
id|tsc_hpet_quotient_ptr
)paren
(brace
r_int
r_int
id|tsc_hpet_quotient
suffix:semicolon
id|ASM_DIV64_REG
c_func
(paren
id|tsc_hpet_quotient
comma
id|remain
comma
id|tsc_endlow
comma
l_int|0
comma
id|CALIBRATE_CNT_HPET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remain
OG
(paren
id|tsc_endlow
op_rshift
l_int|1
)paren
)paren
id|tsc_hpet_quotient
op_increment
suffix:semicolon
multiline_comment|/* rounding the result */
op_star
id|tsc_hpet_quotient_ptr
op_assign
id|tsc_hpet_quotient
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
id|bad_calibration
suffix:colon
multiline_comment|/*&n;&t; * the CPU was so fast/slow that the quotient wouldn&squot;t fit in&n;&t; * 32 bits..&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* calculate cpu_khz */
DECL|function|init_cpu_khz
r_void
id|__init
id|init_cpu_khz
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_tsc
)paren
(brace
r_int
r_int
id|tsc_quotient
op_assign
id|calibrate_tsc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsc_quotient
)paren
(brace
multiline_comment|/* report CPU clock rate in Hz.&n;&t;&t;&t; * The formula is (10^6 * 2^32) / (2^32 * 1 / (clocks/us)) =&n;&t;&t;&t; * clock/second. Our precision is about 100 ppm.&n;&t;&t;&t; */
(brace
r_int
r_int
id|eax
op_assign
l_int|0
comma
id|edx
op_assign
l_int|1000
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;divl %2&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|cpu_khz
)paren
comma
l_string|&quot;=d&quot;
(paren
id|edx
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tsc_quotient
)paren
comma
l_string|&quot;0&quot;
(paren
id|eax
)paren
comma
l_string|&quot;1&quot;
(paren
id|edx
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Detected %lu.%03lu MHz processor.&bslash;n&quot;
comma
id|cpu_khz
op_div
l_int|1000
comma
id|cpu_khz
op_mod
l_int|1000
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
eof
