multiline_comment|/*&n; * (C) Dominik Brodowski &lt;linux@brodo.de&gt; 2003&n; *&n; * Driver to use the Power Management Timer (PMTMR) available in some&n; * southbridges as primary timing source for the Linux kernel.&n; *&n; * Based on parts of linux/drivers/acpi/hardware/hwtimer.c, timer_pit.c,&n; * timer_hpet.c, and on Arjan van de Ven&squot;s implementation for 2.4.&n; *&n; * This file is licensed under the GPL v2.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/arch_hooks.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &quot;mach_timer.h&quot;
multiline_comment|/* Number of PMTMR ticks expected during calibration run */
DECL|macro|PMTMR_TICKS_PER_SEC
mdefine_line|#define PMTMR_TICKS_PER_SEC 3579545
DECL|macro|PMTMR_EXPECTED_RATE
mdefine_line|#define PMTMR_EXPECTED_RATE &bslash;&n;  ((CALIBRATE_LATCH * (PMTMR_TICKS_PER_SEC &gt;&gt; 10)) / (CLOCK_TICK_RATE&gt;&gt;10))
multiline_comment|/* The I/O port the PMTMR resides at.&n; * The location is detected during setup_arch(),&n; * in arch/i386/acpi/boot.c */
DECL|variable|pmtmr_ioport
id|u32
id|pmtmr_ioport
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* value of the Power timer at last timer interrupt */
DECL|variable|offset_tick
r_static
id|u32
id|offset_tick
suffix:semicolon
DECL|variable|offset_delay
r_static
id|u32
id|offset_delay
suffix:semicolon
DECL|variable|monotonic_base
r_static
r_int
r_int
r_int
id|monotonic_base
suffix:semicolon
DECL|variable|monotonic_lock
r_static
id|seqlock_t
id|monotonic_lock
op_assign
id|SEQLOCK_UNLOCKED
suffix:semicolon
DECL|macro|ACPI_PM_MASK
mdefine_line|#define ACPI_PM_MASK 0xFFFFFF /* limit it to 24 bits */
multiline_comment|/*helper function to safely read acpi pm timesource*/
DECL|function|read_pmtmr
r_static
r_inline
id|u32
id|read_pmtmr
c_func
(paren
r_void
)paren
(brace
id|u32
id|v1
op_assign
l_int|0
comma
id|v2
op_assign
l_int|0
comma
id|v3
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* It has been reported that because of various broken&n;&t; * chipsets (ICH4, PIIX4 and PIIX4E) where the ACPI PM time&n;&t; * source is not latched, so you must read it multiple&n;&t; * times to insure a safe value is read.&n;&t; */
r_do
(brace
id|v1
op_assign
id|inl
c_func
(paren
id|pmtmr_ioport
)paren
suffix:semicolon
id|v2
op_assign
id|inl
c_func
(paren
id|pmtmr_ioport
)paren
suffix:semicolon
id|v3
op_assign
id|inl
c_func
(paren
id|pmtmr_ioport
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|v1
OG
id|v2
op_logical_and
id|v1
OL
id|v3
)paren
op_logical_or
(paren
id|v2
OG
id|v3
op_logical_and
id|v2
OL
id|v1
)paren
op_logical_or
(paren
id|v3
OG
id|v1
op_logical_and
id|v3
OL
id|v2
)paren
)paren
suffix:semicolon
multiline_comment|/* mask the output to 24 bits */
r_return
id|v2
op_amp
id|ACPI_PM_MASK
suffix:semicolon
)brace
multiline_comment|/*&n; * Some boards have the PMTMR running way too fast. We check&n; * the PMTMR rate against PIT channel 2 to catch these cases.&n; */
DECL|function|verify_pmtmr_rate
r_static
r_int
id|verify_pmtmr_rate
c_func
(paren
r_void
)paren
(brace
id|u32
id|value1
comma
id|value2
suffix:semicolon
r_int
r_int
id|count
comma
id|delta
suffix:semicolon
id|mach_prepare_counter
c_func
(paren
)paren
suffix:semicolon
id|value1
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
id|mach_countup
c_func
(paren
op_amp
id|count
)paren
suffix:semicolon
id|value2
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
id|delta
op_assign
(paren
id|value2
op_minus
id|value1
)paren
op_amp
id|ACPI_PM_MASK
suffix:semicolon
multiline_comment|/* Check that the PMTMR delta is within 5% of what we expect */
r_if
c_cond
(paren
id|delta
template_param
(paren
id|PMTMR_EXPECTED_RATE
op_star
l_int|21
)paren
op_div
l_int|20
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PM-Timer running at invalid rate: %lu%% of normal - aborting.&bslash;n&quot;
comma
l_int|100UL
op_star
id|delta
op_div
id|PMTMR_EXPECTED_RATE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_pmtmr
r_static
r_int
id|init_pmtmr
c_func
(paren
r_char
op_star
id|override
)paren
(brace
id|u32
id|value1
comma
id|value2
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|override
(braket
l_int|0
)braket
op_logical_and
id|strncmp
c_func
(paren
id|override
comma
l_string|&quot;pmtmr&quot;
comma
l_int|5
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmtmr_ioport
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* we use the TSC for delay_pmtmr, so make sure it exists */
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_tsc
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* &quot;verify&quot; this timing source */
id|value1
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|value2
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value2
op_eq
id|value1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|value2
OG
id|value1
)paren
r_goto
id|pm_good
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value2
OL
id|value1
)paren
op_logical_and
(paren
(paren
id|value2
)paren
OL
l_int|0xFFF
)paren
)paren
r_goto
id|pm_good
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PM-Timer had inconsistent results: 0x%#x, 0x%#x - aborting.&bslash;n&quot;
comma
id|value1
comma
id|value2
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PM-Timer had no reasonable result: 0x%#x - aborting.&bslash;n&quot;
comma
id|value1
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
id|pm_good
suffix:colon
r_if
c_cond
(paren
id|verify_pmtmr_rate
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|init_cpu_khz
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cyc2us
r_static
r_inline
id|u32
id|cyc2us
c_func
(paren
id|u32
id|cycles
)paren
(brace
multiline_comment|/* The Power Management Timer ticks at 3.579545 ticks per microsecond.&n;&t; * 1 / PM_TIMER_FREQUENCY == 0.27936511 =~ 286/1024 [error: 0.024%]&n;&t; *&n;&t; * Even with HZ = 100, delta is at maximum 35796 ticks, so it can&n;&t; * easily be multiplied with 286 (=0x11E) without having to fear&n;&t; * u32 overflows.&n;&t; */
id|cycles
op_mul_assign
l_int|286
suffix:semicolon
r_return
(paren
id|cycles
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this gets called during each timer interrupt&n; *   - Called while holding the writer xtime_lock&n; */
DECL|function|mark_offset_pmtmr
r_static
r_void
id|mark_offset_pmtmr
c_func
(paren
r_void
)paren
(brace
id|u32
id|lost
comma
id|delta
comma
id|last_offset
suffix:semicolon
r_static
r_int
id|first_run
op_assign
l_int|1
suffix:semicolon
id|last_offset
op_assign
id|offset_tick
suffix:semicolon
id|write_seqlock
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
id|offset_tick
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* calculate tick interval */
id|delta
op_assign
(paren
id|offset_tick
op_minus
id|last_offset
)paren
op_amp
id|ACPI_PM_MASK
suffix:semicolon
multiline_comment|/* convert to usecs */
id|delta
op_assign
id|cyc2us
c_func
(paren
id|delta
)paren
suffix:semicolon
multiline_comment|/* update the monotonic base value */
id|monotonic_base
op_add_assign
id|delta
op_star
id|NSEC_PER_USEC
suffix:semicolon
id|write_sequnlock
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
multiline_comment|/* convert to ticks */
id|delta
op_add_assign
id|offset_delay
suffix:semicolon
id|lost
op_assign
id|delta
op_div
(paren
id|USEC_PER_SEC
op_div
id|HZ
)paren
suffix:semicolon
id|offset_delay
op_assign
id|delta
op_mod
(paren
id|USEC_PER_SEC
op_div
id|HZ
)paren
suffix:semicolon
multiline_comment|/* compensate for lost ticks */
r_if
c_cond
(paren
id|lost
op_ge
l_int|2
)paren
id|jiffies_64
op_add_assign
id|lost
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t calculate delay for first run,&n;&t;   or if we&squot;ve got less then a tick */
r_if
c_cond
(paren
id|first_run
op_logical_or
(paren
id|lost
OL
l_int|1
)paren
)paren
(brace
id|first_run
op_assign
l_int|0
suffix:semicolon
id|offset_delay
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|monotonic_clock_pmtmr
r_static
r_int
r_int
r_int
id|monotonic_clock_pmtmr
c_func
(paren
r_void
)paren
(brace
id|u32
id|last_offset
comma
id|this_offset
suffix:semicolon
r_int
r_int
r_int
id|base
comma
id|ret
suffix:semicolon
r_int
id|seq
suffix:semicolon
multiline_comment|/* atomically read monotonic base &amp; last_offset */
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|monotonic_lock
)paren
suffix:semicolon
id|last_offset
op_assign
id|offset_tick
suffix:semicolon
id|base
op_assign
id|monotonic_base
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|monotonic_lock
comma
id|seq
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the pmtmr */
id|this_offset
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* convert to nanoseconds */
id|ret
op_assign
(paren
id|this_offset
op_minus
id|last_offset
)paren
op_amp
id|ACPI_PM_MASK
suffix:semicolon
id|ret
op_assign
id|base
op_plus
(paren
id|cyc2us
c_func
(paren
id|ret
)paren
op_star
id|NSEC_PER_USEC
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|delay_pmtmr
r_static
r_void
id|delay_pmtmr
c_func
(paren
r_int
r_int
id|loops
)paren
(brace
r_int
r_int
id|bclock
comma
id|now
suffix:semicolon
id|rdtscl
c_func
(paren
id|bclock
)paren
suffix:semicolon
r_do
(brace
id|rep_nop
c_func
(paren
)paren
suffix:semicolon
id|rdtscl
c_func
(paren
id|now
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|now
op_minus
id|bclock
)paren
OL
id|loops
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * get the offset (in microseconds) from the last call to mark_offset()&n; *&t;- Called holding a reader xtime_lock&n; */
DECL|function|get_offset_pmtmr
r_static
r_int
r_int
id|get_offset_pmtmr
c_func
(paren
r_void
)paren
(brace
id|u32
id|now
comma
id|offset
comma
id|delta
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|offset_tick
suffix:semicolon
id|now
op_assign
id|read_pmtmr
c_func
(paren
)paren
suffix:semicolon
id|delta
op_assign
(paren
id|now
op_minus
id|offset
)paren
op_amp
id|ACPI_PM_MASK
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|offset_delay
op_plus
id|cyc2us
c_func
(paren
id|delta
)paren
suffix:semicolon
)brace
multiline_comment|/* acpi timer_opts struct */
DECL|variable|timer_pmtmr
r_static
r_struct
id|timer_opts
id|timer_pmtmr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;pmtmr&quot;
comma
dot
id|mark_offset
op_assign
id|mark_offset_pmtmr
comma
dot
id|get_offset
op_assign
id|get_offset_pmtmr
comma
dot
id|monotonic_clock
op_assign
id|monotonic_clock_pmtmr
comma
dot
id|delay
op_assign
id|delay_pmtmr
comma
)brace
suffix:semicolon
DECL|variable|timer_pmtmr_init
r_struct
id|init_timer_opts
id|__initdata
id|timer_pmtmr_init
op_assign
(brace
dot
id|init
op_assign
id|init_pmtmr
comma
dot
id|opts
op_assign
op_amp
id|timer_pmtmr
comma
)brace
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dominik Brodowski &lt;linux@brodo.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Power Management Timer (PMTMR) as primary timing source for x86&quot;
)paren
suffix:semicolon
eof
