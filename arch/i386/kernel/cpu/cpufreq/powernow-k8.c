multiline_comment|/*&n; *   (c) 2003 Advanced Micro Devices, Inc.&n; *  Your use of this code is subject to the terms and conditions of the&n; *  GNU general public license version 2. See &quot;../../../COPYING&quot; or&n; *  http://www.gnu.org/licenses/gpl.html&n; *&n; *  Support : paul.devriendt@amd.com&n; *&n; *  Based on the powernow-k7.c module written by Dave Jones.&n; *  (C) 2003 Dave Jones &lt;davej@codemonkey.ork.uk&gt; on behalf of SuSE Labs&n; *  Licensed under the terms of the GNU GPL License version 2.&n; *  Based upon datasheets &amp; sample CPUs kindly provided by AMD.&n; *&n; *  Processor information obtained from Chapter 9 (Power and Thermal Management)&n; *  of the &quot;BIOS and Kernel Developer&squot;s Guide for the AMD Athlon 64 and AMD&n; *  Opteron Processors&quot;, revision 3.03, available for download from www.amd.com&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/cpufreq.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
DECL|macro|PFX
mdefine_line|#define PFX &quot;powernow-k8: &quot;
DECL|macro|BFX
mdefine_line|#define BFX PFX &quot;BIOS error: &quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;version 1.00.08 - September 26, 2003&quot;
macro_line|#include &quot;powernow-k8.h&quot;
macro_line|#ifdef CONFIG_PREEMPT
macro_line|#warning this driver has not been tested on a preempt system
macro_line|#endif
DECL|variable|vstable
r_static
id|u32
id|vstable
suffix:semicolon
multiline_comment|/* voltage stabalization time, from PSB, units 20 us */
DECL|variable|plllock
r_static
id|u32
id|plllock
suffix:semicolon
multiline_comment|/* pll lock time, from PSB, units 1 us */
DECL|variable|numps
r_static
id|u32
id|numps
suffix:semicolon
multiline_comment|/* number of p-states, from PSB */
DECL|variable|rvo
r_static
id|u32
id|rvo
suffix:semicolon
multiline_comment|/* ramp voltage offset, from PSB */
DECL|variable|irt
r_static
id|u32
id|irt
suffix:semicolon
multiline_comment|/* isochronous relief time, from PSB */
DECL|variable|vidmvs
r_static
id|u32
id|vidmvs
suffix:semicolon
multiline_comment|/* usable value calculated from mvs, from PSB */
DECL|variable|ppst
r_struct
id|pst_s
op_star
id|ppst
suffix:semicolon
multiline_comment|/* array of p states, valid for this part */
DECL|variable|currvid
r_static
id|u32
id|currvid
suffix:semicolon
multiline_comment|/* keep track of the current fid / vid */
DECL|variable|currfid
r_static
id|u32
id|currfid
suffix:semicolon
multiline_comment|/*&n;The PSB table supplied by BIOS allows for the definition of the number of&n;p-states that can be used when running on a/c, and the number of p-states&n;that can be used when running on battery. This allows laptop manufacturers&n;to force the system to save power when running from battery. The relationship &n;is :&n;   1 &lt;= number_of_battery_p_states &lt;= maximum_number_of_p_states&n;&n;This driver does NOT have the support in it to detect transitions from&n;a/c power to battery power, and thus trigger the transition to a lower&n;p-state if required. This is because I need ACPI and the 2.6 kernel to do &n;this, and this is a 2.4 kernel driver. Check back for a new improved driver&n;for the 2.6 kernel soon.&n;&n;This code therefore assumes it is on battery at all times, and thus&n;restricts performance to number_of_battery_p_states. For desktops, &n;  number_of_battery_p_states == maximum_number_of_pstates, &n;so this is not actually a restriction.&n;*/
DECL|variable|batps
r_static
id|u32
id|batps
suffix:semicolon
multiline_comment|/* limit on the number of p states when on battery */
multiline_comment|/* - set by BIOS in the PSB/PST                    */
DECL|variable|cpufreq_amd64_driver
r_static
r_struct
id|cpufreq_driver
id|cpufreq_amd64_driver
op_assign
(brace
dot
id|verify
op_assign
id|drv_verify
comma
dot
id|target
op_assign
id|drv_target
comma
dot
id|init
op_assign
id|drv_cpu_init
comma
dot
id|name
op_assign
l_string|&quot;cpufreq-amd64&quot;
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|macro|SEARCH_UP
mdefine_line|#define SEARCH_UP     1
DECL|macro|SEARCH_DOWN
mdefine_line|#define SEARCH_DOWN   0
multiline_comment|/* Return a frequency in MHz, given an input fid */
id|u32
DECL|function|find_freq_from_fid
id|find_freq_from_fid
c_func
(paren
id|u32
id|fid
)paren
(brace
r_return
l_int|800
op_plus
(paren
id|fid
op_star
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* Return a fid matching an input frequency in MHz */
id|u32
DECL|function|find_fid_from_freq
id|find_fid_from_freq
c_func
(paren
id|u32
id|freq
)paren
(brace
r_return
(paren
id|freq
op_minus
l_int|800
)paren
op_div
l_int|100
suffix:semicolon
)brace
multiline_comment|/* Return the vco fid for an input fid */
r_static
id|u32
DECL|function|convert_fid_to_vco_fid
id|convert_fid_to_vco_fid
c_func
(paren
id|u32
id|fid
)paren
(brace
r_if
c_cond
(paren
id|fid
OL
id|HI_FID_TABLE_BOTTOM
)paren
(brace
r_return
l_int|8
op_plus
(paren
l_int|2
op_star
id|fid
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|fid
suffix:semicolon
)brace
)brace
multiline_comment|/* Sort the fid/vid frequency table into ascending order by fid. The spec */
multiline_comment|/* implies that it will be sorted by BIOS, but, it only implies it, and I */
multiline_comment|/* prefer not to trust when I can check.                                  */
multiline_comment|/* Yes, it is a simple bubble sort, but the PST is really small, so the   */
multiline_comment|/* choice of algorithm is pretty irrelevant.                              */
r_static
r_inline
r_void
DECL|function|sort_pst
id|sort_pst
c_func
(paren
r_struct
id|pst_s
op_star
id|ppst
comma
id|u32
id|numpstates
)paren
(brace
id|u32
id|i
suffix:semicolon
id|u8
id|tempfid
suffix:semicolon
id|u8
id|tempvid
suffix:semicolon
r_int
id|swaps
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|swaps
)paren
(brace
id|swaps
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|numpstates
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ppst
(braket
id|i
)braket
dot
id|fid
OG
id|ppst
(braket
id|i
op_plus
l_int|1
)braket
dot
id|fid
)paren
(brace
id|swaps
op_assign
l_int|1
suffix:semicolon
id|tempfid
op_assign
id|ppst
(braket
id|i
)braket
dot
id|fid
suffix:semicolon
id|tempvid
op_assign
id|ppst
(braket
id|i
)braket
dot
id|vid
suffix:semicolon
id|ppst
(braket
id|i
)braket
dot
id|fid
op_assign
id|ppst
(braket
id|i
op_plus
l_int|1
)braket
dot
id|fid
suffix:semicolon
id|ppst
(braket
id|i
)braket
dot
id|vid
op_assign
id|ppst
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vid
suffix:semicolon
id|ppst
(braket
id|i
op_plus
l_int|1
)braket
dot
id|fid
op_assign
id|tempfid
suffix:semicolon
id|ppst
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vid
op_assign
id|tempvid
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Return 1 if the pending bit is set. Unless we are actually just told the */
multiline_comment|/* processor to transition a state, seeing this bit set is really bad news. */
r_static
r_inline
r_int
DECL|function|pending_bit_stuck
id|pending_bit_stuck
c_func
(paren
r_void
)paren
(brace
id|u32
id|lo
suffix:semicolon
id|u32
id|hi
suffix:semicolon
id|rdmsr
c_func
(paren
id|MSR_FIDVID_STATUS
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_return
id|lo
op_amp
id|MSR_S_LO_CHANGE_PENDING
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Update the global current fid / vid values from the status msr. Returns 1 */
multiline_comment|/* on error.                                                                 */
r_static
r_int
DECL|function|query_current_values_with_pending_wait
id|query_current_values_with_pending_wait
c_func
(paren
r_void
)paren
(brace
id|u32
id|lo
suffix:semicolon
id|u32
id|hi
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|lo
op_assign
id|MSR_S_LO_CHANGE_PENDING
suffix:semicolon
r_while
c_loop
(paren
id|lo
op_amp
id|MSR_S_LO_CHANGE_PENDING
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|0x1000000
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;detected change pending stuck&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MSR_FIDVID_STATUS
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
)brace
id|currvid
op_assign
id|hi
op_amp
id|MSR_S_HI_CURRENT_VID
suffix:semicolon
id|currfid
op_assign
id|lo
op_amp
id|MSR_S_LO_CURRENT_FID
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the isochronous relief time */
r_static
r_inline
r_void
DECL|function|count_off_irt
id|count_off_irt
c_func
(paren
r_void
)paren
(brace
id|udelay
c_func
(paren
(paren
l_int|1
op_lshift
id|irt
)paren
op_star
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* the voltage stabalization time */
r_static
r_inline
r_void
DECL|function|count_off_vst
id|count_off_vst
c_func
(paren
r_void
)paren
(brace
id|udelay
c_func
(paren
id|vstable
op_star
id|VST_UNITS_20US
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* write the new fid value along with the other control fields to the msr */
r_static
r_int
DECL|function|write_new_fid
id|write_new_fid
c_func
(paren
id|u32
id|fid
)paren
(brace
id|u32
id|lo
suffix:semicolon
id|u32
id|savevid
op_assign
id|currvid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fid
op_amp
id|INVALID_FID_MASK
)paren
op_logical_or
(paren
id|currvid
op_amp
id|INVALID_VID_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;internal error - overflow on fid write&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lo
op_assign
id|fid
op_or
(paren
id|currvid
op_lshift
id|MSR_C_LO_VID_SHIFT
)paren
op_or
id|MSR_C_LO_INIT_FID_VID
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;writing fid %x, lo %x, hi %x&bslash;n&quot;
comma
id|fid
comma
id|lo
comma
id|plllock
op_star
id|PLL_LOCK_CONVERSION
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MSR_FIDVID_CTL
comma
id|lo
comma
id|plllock
op_star
id|PLL_LOCK_CONVERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|count_off_irt
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|savevid
op_ne
id|currvid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;vid changed on fid transition, save %x, currvid %x&bslash;n&quot;
comma
id|savevid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fid
op_ne
id|currfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;fid transition failed, fid %x, currfid %x&bslash;n&quot;
comma
id|fid
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write a new vid to the hardware */
r_static
r_int
DECL|function|write_new_vid
id|write_new_vid
c_func
(paren
id|u32
id|vid
)paren
(brace
id|u32
id|lo
suffix:semicolon
id|u32
id|savefid
op_assign
id|currfid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|currfid
op_amp
id|INVALID_FID_MASK
)paren
op_logical_or
(paren
id|vid
op_amp
id|INVALID_VID_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;internal error - overflow on vid write&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lo
op_assign
id|currfid
op_or
(paren
id|vid
op_lshift
id|MSR_C_LO_VID_SHIFT
)paren
op_or
id|MSR_C_LO_INIT_FID_VID
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;writing vid %x, lo %x, hi %x&bslash;n&quot;
comma
id|vid
comma
id|lo
comma
id|STOP_GRANT_5NS
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MSR_FIDVID_CTL
comma
id|lo
comma
id|STOP_GRANT_5NS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|savefid
op_ne
id|currfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;fid changed on vid transition, save %x currfid %x&bslash;n&quot;
comma
id|savefid
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vid
op_ne
id|currvid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;vid transition failed, vid %x, currvid %x&bslash;n&quot;
comma
id|vid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reduce the vid by the max of step or reqvid.                   */
multiline_comment|/* Decreasing vid codes represent increasing voltages :           */
multiline_comment|/* vid of 0 is 1.550V, vid of 0x1e is 0.800V, vid of 0x1f is off. */
r_static
r_int
DECL|function|decrease_vid_code_by_step
id|decrease_vid_code_by_step
c_func
(paren
id|u32
id|reqvid
comma
id|u32
id|step
)paren
(brace
r_if
c_cond
(paren
(paren
id|currvid
op_minus
id|reqvid
)paren
OG
id|step
)paren
id|reqvid
op_assign
id|currvid
op_minus
id|step
suffix:semicolon
r_if
c_cond
(paren
id|write_new_vid
c_func
(paren
id|reqvid
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|count_off_vst
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Change the fid and vid, by the 3 phases. */
r_static
r_inline
r_int
DECL|function|transition_fid_vid
id|transition_fid_vid
c_func
(paren
id|u32
id|reqfid
comma
id|u32
id|reqvid
)paren
(brace
r_if
c_cond
(paren
id|core_voltage_pre_transition
c_func
(paren
id|reqvid
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|core_frequency_transition
c_func
(paren
id|reqfid
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|core_voltage_post_transition
c_func
(paren
id|reqvid
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reqfid
op_ne
id|currfid
)paren
op_logical_or
(paren
id|reqvid
op_ne
id|currvid
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;failed: req 0x%x 0x%x, curr 0x%x 0x%x&bslash;n&quot;
comma
id|reqfid
comma
id|reqvid
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;transitioned: new fid 0x%x, vid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Phase 1 - core voltage transition ... setup appropriate voltage for the */
multiline_comment|/* fid transition.                                                         */
r_static
r_inline
r_int
DECL|function|core_voltage_pre_transition
id|core_voltage_pre_transition
c_func
(paren
id|u32
id|reqvid
)paren
(brace
id|u32
id|rvosteps
op_assign
id|rvo
suffix:semicolon
id|u32
id|savefid
op_assign
id|currfid
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph1: start, currfid 0x%x, currvid 0x%x, reqvid 0x%x, rvo %x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
comma
id|reqvid
comma
id|rvo
)paren
suffix:semicolon
r_while
c_loop
(paren
id|currvid
OG
id|reqvid
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph1: curr 0x%x, requesting vid 0x%x&bslash;n&quot;
comma
id|currvid
comma
id|reqvid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decrease_vid_code_by_step
c_func
(paren
id|reqvid
comma
id|vidmvs
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rvosteps
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|currvid
op_eq
l_int|0
)paren
(brace
id|rvosteps
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph1: changing vid for rvo, requesting 0x%x&bslash;n&quot;
comma
id|currvid
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decrease_vid_code_by_step
c_func
(paren
id|currvid
op_minus
l_int|1
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|rvosteps
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|savefid
op_ne
id|currfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph1 err, currfid changed 0x%x&bslash;n&quot;
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph1 complete, currfid 0x%x, currvid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Phase 2 - core frequency transition */
r_static
r_inline
r_int
DECL|function|core_frequency_transition
id|core_frequency_transition
c_func
(paren
id|u32
id|reqfid
)paren
(brace
id|u32
id|vcoreqfid
suffix:semicolon
id|u32
id|vcocurrfid
suffix:semicolon
id|u32
id|vcofiddiff
suffix:semicolon
id|u32
id|savevid
op_assign
id|currvid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reqfid
OL
id|HI_FID_TABLE_BOTTOM
)paren
op_logical_and
(paren
id|currfid
OL
id|HI_FID_TABLE_BOTTOM
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph2 illegal lo-lo transition 0x%x 0x%x&bslash;n&quot;
comma
id|reqfid
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|currfid
op_eq
id|reqfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph2 null fid transition 0x%x&bslash;n&quot;
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph2 starting, currfid 0x%x, currvid 0x%x, reqfid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
comma
id|reqfid
)paren
suffix:semicolon
id|vcoreqfid
op_assign
id|convert_fid_to_vco_fid
c_func
(paren
id|reqfid
)paren
suffix:semicolon
id|vcocurrfid
op_assign
id|convert_fid_to_vco_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
id|vcofiddiff
op_assign
id|vcocurrfid
OG
id|vcoreqfid
ques
c_cond
id|vcocurrfid
op_minus
id|vcoreqfid
suffix:colon
id|vcoreqfid
op_minus
id|vcocurrfid
suffix:semicolon
r_while
c_loop
(paren
id|vcofiddiff
OG
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|reqfid
OG
id|currfid
)paren
(brace
r_if
c_cond
(paren
id|currfid
OG
id|LO_FID_TABLE_TOP
)paren
(brace
r_if
c_cond
(paren
id|write_new_fid
c_func
(paren
id|currfid
op_plus
l_int|2
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|write_new_fid
(paren
l_int|2
op_plus
id|convert_fid_to_vco_fid
c_func
(paren
id|currfid
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|write_new_fid
c_func
(paren
id|currfid
op_minus
l_int|2
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|vcocurrfid
op_assign
id|convert_fid_to_vco_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
id|vcofiddiff
op_assign
id|vcocurrfid
OG
id|vcoreqfid
ques
c_cond
id|vcocurrfid
op_minus
id|vcoreqfid
suffix:colon
id|vcoreqfid
op_minus
id|vcocurrfid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_new_fid
c_func
(paren
id|reqfid
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currfid
op_ne
id|reqfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph2 mismatch, failed fid transition, curr %x, req %x&bslash;n&quot;
comma
id|currfid
comma
id|reqfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|savevid
op_ne
id|currvid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph2 vid changed, save %x, curr %x&bslash;n&quot;
comma
id|savevid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph2 complete, currfid 0x%x, currvid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Phase 3 - core voltage transition flow ... jump to the final vid. */
r_static
r_inline
r_int
DECL|function|core_voltage_post_transition
id|core_voltage_post_transition
c_func
(paren
id|u32
id|reqvid
)paren
(brace
id|u32
id|savefid
op_assign
id|currfid
suffix:semicolon
id|u32
id|savereqvid
op_assign
id|reqvid
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph3 starting, currfid 0x%x, currvid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqvid
op_ne
id|currvid
)paren
(brace
r_if
c_cond
(paren
id|write_new_vid
c_func
(paren
id|reqvid
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|savefid
op_ne
id|currfid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph3: bad fid change, save %x, curr %x&bslash;n&quot;
comma
id|savefid
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|currvid
op_ne
id|reqvid
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph3: failed vid transition&bslash;n, req %x, curr %x&quot;
comma
id|reqvid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|savereqvid
op_ne
id|currvid
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph3 failed, currvid 0x%x&bslash;n&quot;
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|savefid
op_ne
id|currfid
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ph3 failed, currfid changed 0x%x&bslash;n&quot;
comma
id|currfid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ph3 complete, currfid 0x%x, currvid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|check_supported_cpu
id|check_supported_cpu
c_func
(paren
r_void
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
id|cpu_data
suffix:semicolon
id|u32
id|eax
comma
id|ebx
comma
id|ecx
comma
id|edx
suffix:semicolon
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;multiprocessor systems not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_ne
id|X86_VENDOR_AMD
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Not an AMD processor&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|eax
op_assign
id|cpuid_eax
c_func
(paren
id|CPUID_PROCESSOR_SIGNATURE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eax
op_amp
id|CPUID_XFAM_MOD
)paren
op_eq
id|ATHLON64_XFAM_MOD
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;AMD Althon 64 Processor found&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eax
op_amp
id|CPUID_F1_STEP
)paren
OL
id|ATHLON64_REV_C0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Revision C0 or better &quot;
l_string|&quot;AMD Athlon 64 processor required&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|eax
op_amp
id|CPUID_XFAM_MOD
)paren
op_eq
id|OPTERON_XFAM_MOD
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;AMD Opteron Processor found&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;AMD Athlon 64 or AMD Opteron processor required&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|eax
op_assign
id|cpuid_eax
c_func
(paren
id|CPUID_GET_MAX_CAPABILITIES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eax
OL
id|CPUID_FREQ_VOLT_CAPABILITIES
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;No frequency change capabilities detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cpuid
c_func
(paren
id|CPUID_FREQ_VOLT_CAPABILITIES
comma
op_amp
id|eax
comma
op_amp
id|ebx
comma
op_amp
id|ecx
comma
op_amp
id|edx
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|edx
op_amp
id|P_STATE_TRANSITION_CAPABLE
)paren
op_ne
id|P_STATE_TRANSITION_CAPABLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Power state transitions not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Found AMD Athlon 64 / Opteron processor &quot;
l_string|&quot;supporting p-state transitions&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Find and validate the PSB/PST table in BIOS. */
r_static
r_inline
r_int
DECL|function|find_psb_table
id|find_psb_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|psb_s
op_star
id|psb
suffix:semicolon
r_struct
id|pst_s
op_star
id|pst
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|lastfid
suffix:semicolon
id|u32
id|mvs
suffix:semicolon
id|u8
id|maxvid
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0xc0000
suffix:semicolon
id|i
OL
l_int|0xffff0
suffix:semicolon
id|i
op_add_assign
l_int|0x10
)paren
(brace
multiline_comment|/* Scan BIOS looking for the signature. */
multiline_comment|/* It can not be at ffff0 - it is too big. */
id|psb
op_assign
id|phys_to_virt
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|psb
comma
id|PSB_ID_STRING
comma
id|PSB_ID_STRING_LEN
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;found PSB header at 0x%p&bslash;n&quot;
comma
id|psb
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;table vers: 0x%x&bslash;n&quot;
comma
id|psb-&gt;tableversion
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;tableversion
op_ne
id|PSB_VERSION_1_4
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|BFX
l_string|&quot;PSB table is not v1.4&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;flags: 0x%x&bslash;n&quot;
comma
id|psb-&gt;flags1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;flags1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;unknown flags&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|vstable
op_assign
id|psb-&gt;voltagestabilizationtime
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;voltage stable time: %d (units 20us)&bslash;n&quot;
comma
id|vstable
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;flags2: 0x%x&bslash;n&quot;
comma
id|psb-&gt;flags2
)paren
suffix:semicolon
id|rvo
op_assign
id|psb-&gt;flags2
op_amp
l_int|3
suffix:semicolon
id|irt
op_assign
(paren
(paren
id|psb-&gt;flags2
)paren
op_rshift
l_int|2
)paren
op_amp
l_int|3
suffix:semicolon
id|mvs
op_assign
(paren
(paren
id|psb-&gt;flags2
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|3
suffix:semicolon
id|vidmvs
op_assign
l_int|1
op_lshift
id|mvs
suffix:semicolon
id|batps
op_assign
(paren
(paren
id|psb-&gt;flags2
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|3
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;p states on battery: %d &quot;
comma
id|batps
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|batps
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;- all available&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;- only the minimum&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;- only the 2 lowest&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;- only the 3 lowest&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;ramp voltage offset: %d&bslash;n&quot;
comma
id|rvo
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;isochronous relief time: %d&bslash;n&quot;
comma
id|irt
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;maximum voltage step: %d&bslash;n&quot;
comma
id|mvs
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;numpst: 0x%x&bslash;n&quot;
comma
id|psb-&gt;numpst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psb-&gt;numpst
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;numpst must be 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;cpuid: 0x%x&bslash;n&quot;
comma
id|psb-&gt;cpuid
)paren
suffix:semicolon
id|plllock
op_assign
id|psb-&gt;plllocktime
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;pll lock time: 0x%x&bslash;n&quot;
comma
id|plllock
)paren
suffix:semicolon
id|maxvid
op_assign
id|psb-&gt;maxvid
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;maxfid: 0x%x&bslash;n&quot;
comma
id|psb-&gt;maxfid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;maxvid: 0x%x&bslash;n&quot;
comma
id|maxvid
)paren
suffix:semicolon
id|numps
op_assign
id|psb-&gt;numpstates
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;numpstates: 0x%x&bslash;n&quot;
comma
id|numps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numps
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;no p states to transition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|batps
op_eq
l_int|0
)paren
(brace
id|batps
op_assign
id|numps
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|batps
OG
id|numps
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;batterypstates &gt; numpstates&bslash;n&quot;
)paren
suffix:semicolon
id|batps
op_assign
id|numps
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Restricting operation to %d p-states&bslash;n&quot;
comma
id|batps
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Check for an updated driver to access all &quot;
l_string|&quot;%d p-states&bslash;n&quot;
comma
id|numps
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|numps
op_le
l_int|1
)paren
op_logical_or
(paren
id|batps
op_le
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;only 1 p-state to transition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|ppst
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pst_s
)paren
op_star
id|numps
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppst
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ppst memory alloc failure&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|pst
op_assign
(paren
r_struct
id|pst_s
op_star
)paren
(paren
id|psb
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|numps
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ppst
(braket
id|j
)braket
dot
id|fid
op_assign
id|pst
(braket
id|j
)braket
dot
id|fid
suffix:semicolon
id|ppst
(braket
id|j
)braket
dot
id|vid
op_assign
id|pst
(braket
id|j
)braket
dot
id|vid
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;   %d : fid 0x%x, vid 0x%x&bslash;n&quot;
comma
id|j
comma
id|ppst
(braket
id|j
)braket
dot
id|fid
comma
id|ppst
(braket
id|j
)braket
dot
id|vid
)paren
suffix:semicolon
)brace
id|sort_pst
c_func
(paren
id|ppst
comma
id|numps
)paren
suffix:semicolon
id|lastfid
op_assign
id|ppst
(braket
l_int|0
)braket
dot
id|fid
suffix:semicolon
r_if
c_cond
(paren
id|lastfid
OG
id|LO_FID_TABLE_TOP
)paren
id|printk
c_func
(paren
id|KERN_INFO
id|BFX
l_string|&quot;first fid not in lo freq tbl&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lastfid
OG
id|MAX_FID
)paren
op_logical_or
(paren
id|lastfid
op_amp
l_int|1
)paren
op_logical_or
(paren
id|ppst
(braket
l_int|0
)braket
dot
id|vid
OG
id|LEAST_VID
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;first fid/vid bad (0x%x - 0x%x)&bslash;n&quot;
comma
id|lastfid
comma
id|ppst
(braket
l_int|0
)braket
dot
id|vid
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppst
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|numps
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lastfid
op_ge
id|ppst
(braket
id|j
)braket
dot
id|fid
)paren
op_logical_or
(paren
id|ppst
(braket
id|j
)braket
dot
id|fid
op_amp
l_int|1
)paren
op_logical_or
(paren
id|ppst
(braket
id|j
)braket
dot
id|fid
OL
id|HI_FID_TABLE_BOTTOM
)paren
op_logical_or
(paren
id|ppst
(braket
id|j
)braket
dot
id|fid
OG
id|MAX_FID
)paren
op_logical_or
(paren
id|ppst
(braket
id|j
)braket
dot
id|vid
OG
id|LEAST_VID
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;invalid fid/vid in pst(%x %x)&bslash;n&quot;
comma
id|ppst
(braket
id|j
)braket
dot
id|fid
comma
id|ppst
(braket
id|j
)braket
dot
id|vid
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppst
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|lastfid
op_assign
id|ppst
(braket
id|j
)braket
dot
id|fid
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|numps
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ppst
(braket
id|j
)braket
dot
id|vid
OL
id|rvo
)paren
(brace
multiline_comment|/* vid+rvo &gt;= 0 */
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;0 vid exceeded with pstate %d&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppst
(braket
id|j
)braket
dot
id|vid
OL
id|maxvid
op_plus
id|rvo
)paren
(brace
multiline_comment|/* vid+rvo &gt;= maxvid */
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;maxvid exceeded with pstate %d&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|ppst
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;currfid 0x%x, currvid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|numps
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
(paren
id|ppst
(braket
id|j
)braket
dot
id|fid
op_eq
id|currfid
)paren
op_logical_and
(paren
id|ppst
(braket
id|j
)braket
dot
id|vid
op_eq
id|currvid
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;currfid/vid do not match PST, ignoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
id|BFX
l_string|&quot;no PSB&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Converts a frequency (that might not necessarily be a multiple of 200) */
multiline_comment|/* to a fid.                                                              */
id|u32
DECL|function|find_closest_fid
id|find_closest_fid
c_func
(paren
id|u32
id|freq
comma
r_int
id|searchup
)paren
(brace
r_if
c_cond
(paren
id|searchup
op_eq
id|SEARCH_UP
)paren
id|freq
op_add_assign
id|MIN_FREQ_RESOLUTION
op_minus
l_int|1
suffix:semicolon
id|freq
op_assign
(paren
id|freq
op_div
id|MIN_FREQ_RESOLUTION
)paren
op_star
id|MIN_FREQ_RESOLUTION
suffix:semicolon
r_if
c_cond
(paren
id|freq
OL
id|MIN_FREQ
)paren
id|freq
op_assign
id|MIN_FREQ
suffix:semicolon
r_else
r_if
c_cond
(paren
id|freq
OG
id|MAX_FREQ
)paren
id|freq
op_assign
id|MAX_FREQ
suffix:semicolon
r_return
id|find_fid_from_freq
c_func
(paren
id|freq
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|find_match
id|find_match
c_func
(paren
id|u32
op_star
id|ptargfreq
comma
id|u32
op_star
id|pmin
comma
id|u32
op_star
id|pmax
comma
r_int
id|searchup
comma
id|u32
op_star
id|pfid
comma
id|u32
op_star
id|pvid
)paren
(brace
id|u32
id|availpstates
op_assign
id|batps
suffix:semicolon
id|u32
id|targfid
op_assign
id|find_closest_fid
c_func
(paren
op_star
id|ptargfreq
comma
id|searchup
)paren
suffix:semicolon
id|u32
id|minfid
op_assign
id|find_closest_fid
c_func
(paren
op_star
id|pmin
comma
id|SEARCH_DOWN
)paren
suffix:semicolon
id|u32
id|maxfid
op_assign
id|find_closest_fid
c_func
(paren
op_star
id|pmax
comma
id|SEARCH_UP
)paren
suffix:semicolon
id|u32
id|minidx
op_assign
l_int|0
suffix:semicolon
id|u32
id|maxidx
op_assign
id|availpstates
op_minus
l_int|1
suffix:semicolon
id|u32
id|targidx
op_assign
l_int|0xffffffff
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;find match: freq %d MHz, min %d, max %d&bslash;n&quot;
comma
op_star
id|ptargfreq
comma
op_star
id|pmin
comma
op_star
id|pmax
)paren
suffix:semicolon
multiline_comment|/* Restrict values to the frequency choices in the PST */
r_if
c_cond
(paren
id|minfid
OL
id|ppst
(braket
l_int|0
)braket
dot
id|fid
)paren
id|minfid
op_assign
id|ppst
(braket
l_int|0
)braket
dot
id|fid
suffix:semicolon
r_if
c_cond
(paren
id|maxfid
OG
id|ppst
(braket
id|maxidx
)braket
dot
id|fid
)paren
id|maxfid
op_assign
id|ppst
(braket
id|maxidx
)braket
dot
id|fid
suffix:semicolon
multiline_comment|/* Find appropriate PST index for the minimim fid */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|availpstates
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|minfid
op_ge
id|ppst
(braket
id|i
)braket
dot
id|fid
)paren
id|minidx
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Find appropriate PST index for the maximum fid */
r_for
c_loop
(paren
id|i
op_assign
id|availpstates
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|maxfid
op_le
id|ppst
(braket
id|i
)braket
dot
id|fid
)paren
id|maxidx
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minidx
OG
id|maxidx
)paren
id|maxidx
op_assign
id|minidx
suffix:semicolon
multiline_comment|/* Frequency ids are now constrained by limits matching PST entries */
id|minfid
op_assign
id|ppst
(braket
id|minidx
)braket
dot
id|fid
suffix:semicolon
id|maxfid
op_assign
id|ppst
(braket
id|maxidx
)braket
dot
id|fid
suffix:semicolon
multiline_comment|/* Limit the target frequency to these limits */
r_if
c_cond
(paren
id|targfid
OL
id|minfid
)paren
id|targfid
op_assign
id|minfid
suffix:semicolon
r_else
r_if
c_cond
(paren
id|targfid
OG
id|maxfid
)paren
id|targfid
op_assign
id|maxfid
suffix:semicolon
multiline_comment|/* Find the best target index into the PST, contrained by the range */
r_if
c_cond
(paren
id|searchup
op_eq
id|SEARCH_UP
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|maxidx
suffix:semicolon
id|i
op_ge
(paren
r_int
)paren
id|minidx
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|targfid
op_le
id|ppst
(braket
id|i
)braket
dot
id|fid
)paren
id|targidx
op_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|minidx
suffix:semicolon
id|i
op_le
(paren
r_int
)paren
id|maxidx
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|targfid
op_ge
id|ppst
(braket
id|i
)braket
dot
id|fid
)paren
id|targidx
op_assign
id|i
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|targidx
op_eq
l_int|0xffffffff
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;could not find target&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|pmin
op_assign
id|find_freq_from_fid
c_func
(paren
id|minfid
)paren
suffix:semicolon
op_star
id|pmax
op_assign
id|find_freq_from_fid
c_func
(paren
id|maxfid
)paren
suffix:semicolon
op_star
id|ptargfreq
op_assign
id|find_freq_from_fid
c_func
(paren
id|ppst
(braket
id|targidx
)braket
dot
id|fid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfid
)paren
op_star
id|pfid
op_assign
id|ppst
(braket
id|targidx
)braket
dot
id|fid
suffix:semicolon
r_if
c_cond
(paren
id|pvid
)paren
op_star
id|pvid
op_assign
id|ppst
(braket
id|targidx
)braket
dot
id|vid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Take a frequency, and issue the fid/vid transition command */
r_static
r_inline
r_int
DECL|function|transition_frequency
id|transition_frequency
c_func
(paren
id|u32
op_star
id|preq
comma
id|u32
op_star
id|pmin
comma
id|u32
op_star
id|pmax
comma
id|u32
id|searchup
)paren
(brace
id|u32
id|fid
suffix:semicolon
id|u32
id|vid
suffix:semicolon
r_int
id|res
suffix:semicolon
r_struct
id|cpufreq_freqs
id|freqs
suffix:semicolon
r_if
c_cond
(paren
id|find_match
c_func
(paren
id|preq
comma
id|pmin
comma
id|pmax
comma
id|searchup
comma
op_amp
id|fid
comma
op_amp
id|vid
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;table matched fid 0x%x, giving vid 0x%x&bslash;n&quot;
comma
id|fid
comma
id|vid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|currvid
op_eq
id|vid
)paren
op_logical_and
(paren
id|currfid
op_eq
id|fid
)paren
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;target matches current values (fid 0x%x, vid 0x%x)&bslash;n&quot;
comma
id|fid
comma
id|vid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|fid
OL
id|HI_FID_TABLE_BOTTOM
)paren
op_logical_and
(paren
id|currfid
OL
id|HI_FID_TABLE_BOTTOM
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ignoring illegal change in lo freq table-%x to %x&bslash;n&quot;
comma
id|currfid
comma
id|fid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;changing to fid 0x%x, vid 0x%x&bslash;n&quot;
comma
id|fid
comma
id|vid
)paren
suffix:semicolon
id|freqs.cpu
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only true because SMP not supported */
id|freqs.old
op_assign
id|find_freq_from_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
id|freqs
dot
r_new
op_assign
id|find_freq_from_fid
c_func
(paren
id|fid
)paren
suffix:semicolon
id|cpufreq_notify_transition
c_func
(paren
op_amp
id|freqs
comma
id|CPUFREQ_PRECHANGE
)paren
suffix:semicolon
id|res
op_assign
id|transition_fid_vid
c_func
(paren
id|fid
comma
id|vid
)paren
suffix:semicolon
id|freqs
dot
r_new
op_assign
id|find_freq_from_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
id|cpufreq_notify_transition
c_func
(paren
op_amp
id|freqs
comma
id|CPUFREQ_POSTCHANGE
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Driver entry point to switch to the target frequency */
r_static
r_int
DECL|function|drv_target
id|drv_target
c_func
(paren
r_struct
id|cpufreq_policy
op_star
id|pol
comma
r_int
id|targfreq
comma
r_int
id|relation
)paren
(brace
id|u32
id|checkfid
op_assign
id|currfid
suffix:semicolon
id|u32
id|checkvid
op_assign
id|currvid
suffix:semicolon
id|u32
id|reqfreq
op_assign
id|targfreq
op_div
l_int|1000
suffix:semicolon
id|u32
id|minfreq
op_assign
id|pol-&gt;min
op_div
l_int|1000
suffix:semicolon
id|u32
id|maxfreq
op_assign
id|pol-&gt;max
op_div
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|ppst
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;targ: ppst 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_bit_stuck
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;drv targ fail: change pending bit set&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;targ: %d kHz, min %d, max %d, relation %d&bslash;n&quot;
comma
id|targfreq
comma
id|pol-&gt;min
comma
id|pol-&gt;max
comma
id|relation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;targ: curr fid 0x%x, vid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|checkvid
op_ne
id|currvid
)paren
op_logical_or
(paren
id|checkfid
op_ne
id|currfid
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;error - out of sync, fid 0x%x 0x%x, vid 0x%x 0x%x&bslash;n&quot;
comma
id|checkfid
comma
id|currfid
comma
id|checkvid
comma
id|currvid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transition_frequency
c_func
(paren
op_amp
id|reqfreq
comma
op_amp
id|minfreq
comma
op_amp
id|maxfreq
comma
id|relation
op_eq
id|CPUFREQ_RELATION_H
ques
c_cond
id|SEARCH_UP
suffix:colon
id|SEARCH_DOWN
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;transition frequency failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pol-&gt;cur
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Driver entry point to verify the policy and range of frequencies */
r_static
r_int
DECL|function|drv_verify
id|drv_verify
c_func
(paren
r_struct
id|cpufreq_policy
op_star
id|pol
)paren
(brace
id|u32
id|min
op_assign
id|pol-&gt;min
op_div
l_int|1000
suffix:semicolon
id|u32
id|max
op_assign
id|pol-&gt;max
op_div
l_int|1000
suffix:semicolon
id|u32
id|targ
op_assign
id|min
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|ppst
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;verify - ppst 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_bit_stuck
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;failing verify, change pending bit set&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;ver: cpu%d, min %d, max %d, cur %d, pol %d&bslash;n&quot;
comma
id|pol-&gt;cpu
comma
id|pol-&gt;min
comma
id|pol-&gt;max
comma
id|pol-&gt;cur
comma
id|pol-&gt;policy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pol-&gt;cpu
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;verify - cpu not 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|res
op_assign
id|find_match
c_func
(paren
op_amp
id|targ
comma
op_amp
id|min
comma
op_amp
id|max
comma
id|pol-&gt;policy
op_eq
id|CPUFREQ_POLICY_POWERSAVE
ques
c_cond
id|SEARCH_DOWN
suffix:colon
id|SEARCH_UP
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|pol-&gt;min
op_assign
id|min
op_star
l_int|1000
suffix:semicolon
id|pol-&gt;max
op_assign
id|max
op_star
l_int|1000
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* per CPU init entry point to the driver */
r_static
r_int
id|__init
DECL|function|drv_cpu_init
id|drv_cpu_init
c_func
(paren
r_struct
id|cpufreq_policy
op_star
id|pol
)paren
(brace
r_if
c_cond
(paren
id|pol-&gt;cpu
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;init not cpu 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pol-&gt;policy
op_assign
id|CPUFREQ_POLICY_PERFORMANCE
suffix:semicolon
multiline_comment|/* boot as fast as we can */
multiline_comment|/* Take a crude guess here. */
id|pol-&gt;cpuinfo.transition_latency
op_assign
(paren
(paren
id|rvo
op_plus
l_int|8
)paren
op_star
id|vstable
op_star
id|VST_UNITS_20US
)paren
op_plus
(paren
l_int|3
op_star
(paren
l_int|1
op_lshift
id|irt
)paren
op_star
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|query_current_values_with_pending_wait
c_func
(paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|pol-&gt;cur
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|currfid
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_DEBUG
id|PFX
l_string|&quot;policy current frequency %d kHz&bslash;n&quot;
comma
id|pol-&gt;cur
)paren
suffix:semicolon
multiline_comment|/* min/max the cpu is capable of */
id|pol-&gt;cpuinfo.min_freq
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|ppst
(braket
l_int|0
)braket
dot
id|fid
)paren
suffix:semicolon
id|pol-&gt;cpuinfo.max_freq
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|ppst
(braket
id|numps
op_minus
l_int|1
)braket
dot
id|fid
)paren
suffix:semicolon
id|pol-&gt;min
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|ppst
(braket
l_int|0
)braket
dot
id|fid
)paren
suffix:semicolon
id|pol-&gt;max
op_assign
l_int|1000
op_star
id|find_freq_from_fid
c_func
(paren
id|ppst
(braket
id|batps
op_minus
l_int|1
)braket
dot
id|fid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;cpu_init done, current fid 0x%x, vid 0x%x&bslash;n&quot;
comma
id|currfid
comma
id|currvid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* driver entry point for init */
r_static
r_int
id|__init
DECL|function|drv_init
id|drv_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_supported_cpu
c_func
(paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|rc
op_assign
id|find_psb_table
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|pending_bit_stuck
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;drv_init fail, change pending bit set&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppst
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
id|cpufreq_register_driver
c_func
(paren
op_amp
id|cpufreq_amd64_driver
)paren
suffix:semicolon
)brace
multiline_comment|/* driver entry point for term */
r_static
r_void
id|__exit
DECL|function|drv_exit
id|drv_exit
c_func
(paren
r_void
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;drv_exit&bslash;n&quot;
)paren
suffix:semicolon
id|cpufreq_unregister_driver
c_func
(paren
op_amp
id|cpufreq_amd64_driver
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppst
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Paul Devriendt &lt;paul.devriendt@amd.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;AMD Athlon 64 and Opteron processor frequency driver.&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|drv_init
id|module_init
c_func
(paren
id|drv_init
)paren
suffix:semicolon
DECL|variable|drv_exit
id|module_exit
c_func
(paren
id|drv_exit
)paren
suffix:semicolon
eof
