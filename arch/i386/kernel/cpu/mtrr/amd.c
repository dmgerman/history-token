macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &quot;mtrr.h&quot;
r_static
r_void
DECL|function|amd_get_mtrr
id|amd_get_mtrr
c_func
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|low
comma
id|high
suffix:semicolon
id|rdmsr
c_func
(paren
id|MSR_K6_UWCCR
comma
id|low
comma
id|high
)paren
suffix:semicolon
multiline_comment|/*  Upper dword is region 1, lower is region 0  */
r_if
c_cond
(paren
id|reg
op_eq
l_int|1
)paren
id|low
op_assign
id|high
suffix:semicolon
multiline_comment|/*  The base masks off on the right alignment  */
op_star
id|base
op_assign
(paren
id|low
op_amp
l_int|0xFFFE0000
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|low
op_amp
l_int|1
)paren
op_star
id|type
op_assign
id|MTRR_TYPE_UNCACHABLE
suffix:semicolon
r_if
c_cond
(paren
id|low
op_amp
l_int|2
)paren
op_star
id|type
op_assign
id|MTRR_TYPE_WRCOMB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|low
op_amp
l_int|3
)paren
)paren
(brace
op_star
id|size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  This needs a little explaining. The size is stored as an&n;&t; *  inverted mask of bits of 128K granularity 15 bits long offset&n;&t; *  2 bits&n;&t; *&n;&t; *  So to get a size we do invert the mask and add 1 to the lowest&n;&t; *  mask bit (4 as its 2 bits in). This gives us a size we then shift&n;&t; *  to turn into 128K blocks&n;&t; *&n;&t; *  eg              111 1111 1111 1100      is 512K&n;&t; *&n;&t; *  invert          000 0000 0000 0011&n;&t; *  +1              000 0000 0000 0100&n;&t; *  *128K   ...&n;&t; */
id|low
op_assign
(paren
op_complement
id|low
)paren
op_amp
l_int|0x1FFFC
suffix:semicolon
op_star
id|size
op_assign
(paren
id|low
op_plus
l_int|4
)paren
op_lshift
(paren
l_int|15
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|amd_set_mtrr
r_static
r_void
id|amd_set_mtrr
c_func
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;    [RETURNS] Nothing.&n;*/
(brace
id|u32
id|regs
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Low is MTRR0 , High MTRR 1&n;&t; */
id|rdmsr
c_func
(paren
id|MSR_K6_UWCCR
comma
id|regs
(braket
l_int|0
)braket
comma
id|regs
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Blank to disable&n;&t; */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|regs
(braket
id|reg
)braket
op_assign
l_int|0
suffix:semicolon
r_else
multiline_comment|/* Set the register to the base, the type (off by one) and an&n;&t;&t;   inverted bitmask of the size The size is the only odd&n;&t;&t;   bit. We are fed say 512K We invert this and we get 111 1111&n;&t;&t;   1111 1011 but if you subtract one and invert you get the   &n;&t;&t;   desired 111 1111 1111 1100 mask&n;&n;&t;&t;   But ~(x - 1) == ~x + 1 == -x. Two&squot;s complement rocks!  */
id|regs
(braket
id|reg
)braket
op_assign
(paren
op_minus
id|size
op_rshift
(paren
l_int|15
op_minus
id|PAGE_SHIFT
)paren
op_amp
l_int|0x0001FFFC
)paren
op_or
(paren
id|base
op_lshift
id|PAGE_SHIFT
)paren
op_or
(paren
id|type
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The writeback rule is quite specific. See the manual. Its&n;&t; *  disable local interrupts, write back the cache, set the mtrr&n;&t; */
id|wbinvd
c_func
(paren
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MSR_K6_UWCCR
comma
id|regs
(braket
l_int|0
)braket
comma
id|regs
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
DECL|function|amd_validate_add_page
r_static
r_int
id|amd_validate_add_page
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
)paren
(brace
multiline_comment|/* Apply the K6 block alignment and size rules&n;&t;   In order&n;&t;   o Uncached or gathering only&n;&t;   o 128K or bigger block&n;&t;   o Power of 2 block&n;&t;   o base suitably aligned to the power&n;&t;*/
r_if
c_cond
(paren
id|type
OG
id|MTRR_TYPE_WRCOMB
op_logical_or
id|size
OL
(paren
l_int|1
op_lshift
(paren
l_int|17
op_minus
id|PAGE_SHIFT
)paren
)paren
op_logical_or
(paren
id|size
op_amp
op_complement
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_minus
id|size
op_logical_or
(paren
id|base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|amd_mtrr_ops
r_static
r_struct
id|mtrr_ops
id|amd_mtrr_ops
op_assign
(brace
dot
id|vendor
op_assign
id|X86_VENDOR_AMD
comma
dot
id|set
op_assign
id|amd_set_mtrr
comma
dot
id|get
op_assign
id|amd_get_mtrr
comma
dot
id|get_free_region
op_assign
id|generic_get_free_region
comma
dot
id|validate_add_page
op_assign
id|amd_validate_add_page
comma
dot
id|have_wrcomb
op_assign
id|positive_have_wrcomb
comma
)brace
suffix:semicolon
DECL|function|amd_init_mtrr
r_int
id|__init
id|amd_init_mtrr
c_func
(paren
r_void
)paren
(brace
id|set_mtrr_ops
c_func
(paren
op_amp
id|amd_mtrr_ops
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//arch_initcall(amd_mtrr_init);
eof
