multiline_comment|/* This only handles 32bit MTRR on 32bit hosts. This is strictly wrong&n;   because MTRRs can span upto 40 bits (36bits on most modern x86) */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/cpufeature.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &quot;mtrr.h&quot;
DECL|struct|mtrr_state
r_struct
id|mtrr_state
(brace
DECL|member|var_ranges
r_struct
id|mtrr_var_range
op_star
id|var_ranges
suffix:semicolon
DECL|member|fixed_ranges
id|mtrr_type
id|fixed_ranges
(braket
id|NUM_FIXED_RANGES
)braket
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
DECL|member|def_type
id|mtrr_type
id|def_type
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|smp_changes_mask
r_static
r_int
r_int
id|smp_changes_mask
suffix:semicolon
DECL|variable|mtrr_state
r_struct
id|mtrr_state
id|mtrr_state
op_assign
(brace
)brace
suffix:semicolon
multiline_comment|/*  Get the MSR pair relating to a var range  */
r_static
r_void
id|__init
DECL|function|get_mtrr_var_range
id|get_mtrr_var_range
c_func
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|get_fixed_ranges
id|get_fixed_ranges
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*  Grab all of the MTRR state for this CPU into *state  */
DECL|function|get_mtrr_state
r_void
id|__init
id|get_mtrr_state
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|mtrr_var_range
op_star
id|vrs
suffix:semicolon
r_int
id|lo
comma
id|dummy
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtrr_state.var_ranges
)paren
(brace
id|mtrr_state.var_ranges
op_assign
id|kmalloc
c_func
(paren
id|num_var_ranges
op_star
r_sizeof
(paren
r_struct
id|mtrr_var_range
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtrr_state.var_ranges
)paren
r_return
suffix:semicolon
)brace
id|vrs
op_assign
id|mtrr_state.var_ranges
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_var_ranges
suffix:semicolon
id|i
op_increment
)paren
id|get_mtrr_var_range
c_func
(paren
id|i
comma
op_amp
id|vrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|get_fixed_ranges
c_func
(paren
id|mtrr_state.fixed_ranges
)paren
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|lo
comma
id|dummy
)paren
suffix:semicolon
id|mtrr_state.def_type
op_assign
(paren
id|lo
op_amp
l_int|0xff
)paren
suffix:semicolon
id|mtrr_state.enabled
op_assign
(paren
id|lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
multiline_comment|/*  Free resources associated with a struct mtrr_state  */
DECL|function|finalize_mtrr_state
r_void
id|__init
id|finalize_mtrr_state
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|mtrr_state.var_ranges
)paren
id|kfree
c_func
(paren
id|mtrr_state.var_ranges
)paren
suffix:semicolon
id|mtrr_state.var_ranges
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  Some BIOS&squot;s are fucked and don&squot;t set all MTRRs the same!  */
DECL|function|mtrr_state_warn
r_void
id|__init
id|mtrr_state_warn
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mask
op_assign
id|smp_changes_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_FIXED
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: your CPUs had inconsistent fixed MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_VARIABLE
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: your CPUs had inconsistent variable MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_DEFTYPE
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: your CPUs had inconsistent MTRRdefType settings&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;mtrr: probably your BIOS does not setup all CPUs.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;mtrr: corrected configuration.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|generic_get_free_region
r_int
id|generic_get_free_region
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Get a free MTRR.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    [RETURNS] The index of the region on success, else -1 on error.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
suffix:semicolon
r_int
id|lsize
suffix:semicolon
id|max
op_assign
id|num_var_ranges
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
id|mtrr_if
op_member_access_from_pointer
id|get
c_func
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
DECL|function|generic_get_mtrr
r_void
id|generic_get_mtrr
c_func
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|mask_lo
comma
id|mask_hi
comma
id|base_lo
comma
id|base_hi
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|reg
)paren
comma
id|mask_lo
comma
id|mask_hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask_lo
op_amp
l_int|0x800
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Invalid (i.e. free) range  */
op_star
id|base
op_assign
l_int|0
suffix:semicolon
op_star
id|size
op_assign
l_int|0
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|reg
)paren
comma
id|base_lo
comma
id|base_hi
)paren
suffix:semicolon
multiline_comment|/* Work out the shifted address mask. */
id|mask_lo
op_assign
id|size_or_mask
op_or
id|mask_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|mask_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* This works correctly if size is a power of two, i.e. a&n;&t;   contiguous range. */
op_star
id|size
op_assign
op_minus
id|mask_lo
suffix:semicolon
op_star
id|base
op_assign
id|base_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|base_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
id|base_lo
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|function|set_fixed_ranges
r_static
r_int
id|set_fixed_ranges
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_return
id|changed
suffix:semicolon
)brace
multiline_comment|/*  Set the MSR pair relating to a var range. Returns TRUE if&n;    changes are made  */
DECL|function|set_mtrr_var_ranges
r_static
r_int
id|set_mtrr_var_ranges
c_func
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;base_lo
op_amp
l_int|0xfffff0ffUL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff0ffUL
)paren
op_logical_or
(paren
id|vr-&gt;base_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;mask_lo
op_amp
l_int|0xfffff800UL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff800UL
)paren
op_logical_or
(paren
id|vr-&gt;mask_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|set_mtrr_state
r_static
r_int
r_int
id|set_mtrr_state
c_func
(paren
id|u32
id|deftype_lo
comma
id|u32
id|deftype_hi
)paren
multiline_comment|/*  [SUMMARY] Set the MTRR state for this CPU.&n;    &lt;state&gt; The MTRR state information to read.&n;    &lt;ctxt&gt; Some relevant CPU context.&n;    [NOTE] The CPU must already be in a safe state for MTRR changes.&n;    [RETURNS] 0 if no changes made, else a mask indication what was changed.&n;*/
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|change_mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_var_ranges
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|set_mtrr_var_ranges
c_func
(paren
id|i
comma
op_amp
id|mtrr_state.var_ranges
(braket
id|i
)braket
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_VARIABLE
suffix:semicolon
r_if
c_cond
(paren
id|set_fixed_ranges
c_func
(paren
id|mtrr_state.fixed_ranges
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_FIXED
suffix:semicolon
multiline_comment|/*  Set_mtrr_restore restores the old value of MTRRdefType,&n;&t;   so to set it we fiddle with the saved value  */
r_if
c_cond
(paren
(paren
id|deftype_lo
op_amp
l_int|0xff
)paren
op_ne
id|mtrr_state.def_type
op_logical_or
(paren
(paren
id|deftype_lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
)paren
op_ne
id|mtrr_state.enabled
)paren
(brace
id|deftype_lo
op_or_assign
(paren
id|mtrr_state.def_type
op_or
id|mtrr_state.enabled
op_lshift
l_int|10
)paren
suffix:semicolon
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_DEFTYPE
suffix:semicolon
)brace
r_return
id|change_mask
suffix:semicolon
)brace
DECL|variable|cr4
r_static
r_int
r_int
id|cr4
op_assign
l_int|0
suffix:semicolon
DECL|variable|deftype_lo
DECL|variable|deftype_hi
r_static
id|u32
id|deftype_lo
comma
id|deftype_hi
suffix:semicolon
DECL|variable|set_atomicity_lock
r_static
id|spinlock_t
id|set_atomicity_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Since we are disabling the cache don&squot;t allow any interrupts - they&n; * would run extremely slow and would only increase the pain.  The caller must&n; * ensure that local interrupts are disabled and are reenabled after post_set()&n; * has been called.&n; */
DECL|function|prepare_set
r_static
r_void
id|prepare_set
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cr0
suffix:semicolon
multiline_comment|/*  Note that this is not ideal, since the cache is only flushed/disabled&n;&t;   for this CPU while the MTRRs are changed, but changing this requires&n;&t;   more invasive changes to the way the kernel boots  */
id|spin_lock
c_func
(paren
op_amp
id|set_atomicity_lock
)paren
suffix:semicolon
multiline_comment|/*  Enter the no-fill (CD=1, NW=0) cache mode and flush caches. */
id|cr0
op_assign
id|read_cr0
c_func
(paren
)paren
op_or
l_int|0x40000000
suffix:semicolon
multiline_comment|/* set CD flag */
id|write_cr0
c_func
(paren
id|cr0
)paren
suffix:semicolon
id|wbinvd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Save value of CR4 and clear Page Global Enable (bit 7)  */
r_if
c_cond
(paren
id|cpu_has_pge
)paren
(brace
id|cr4
op_assign
id|read_cr4
c_func
(paren
)paren
suffix:semicolon
id|write_cr4
c_func
(paren
id|cr4
op_amp
(paren
r_int
r_char
)paren
op_complement
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush all TLBs via a mov %cr3, %reg; mov %reg, %cr3 */
id|__flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Save MTRR state */
id|rdmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|deftype_lo
comma
id|deftype_hi
)paren
suffix:semicolon
multiline_comment|/*  Disable MTRRs, and set the default type to uncached  */
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|deftype_lo
op_amp
l_int|0xf300UL
comma
id|deftype_hi
)paren
suffix:semicolon
)brace
DECL|function|post_set
r_static
r_void
id|post_set
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*  Flush TLBs (no need to flush caches - they are disabled)  */
id|__flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Intel (P6) standard MTRRs */
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|deftype_lo
comma
id|deftype_hi
)paren
suffix:semicolon
multiline_comment|/*  Enable caches  */
id|write_cr0
c_func
(paren
id|read_cr0
c_func
(paren
)paren
op_amp
l_int|0xbfffffff
)paren
suffix:semicolon
multiline_comment|/*  Restore value of CR4  */
r_if
c_cond
(paren
id|cpu_has_pge
)paren
id|write_cr4
c_func
(paren
id|cr4
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|set_atomicity_lock
)paren
suffix:semicolon
)brace
DECL|function|generic_set_all
r_static
r_void
id|generic_set_all
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mask
comma
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|prepare_set
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Actually set the state */
id|mask
op_assign
id|set_mtrr_state
c_func
(paren
id|deftype_lo
comma
id|deftype_hi
)paren
suffix:semicolon
id|post_set
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*  Use the atomic bitops to update the global mask  */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
r_sizeof
id|mask
op_star
l_int|8
suffix:semicolon
op_increment
id|count
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x01
)paren
id|set_bit
c_func
(paren
id|count
comma
op_amp
id|smp_changes_mask
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|generic_set_mtrr
r_static
r_void
id|generic_set_mtrr
c_func
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;    [RETURNS] Nothing.&n;*/
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|prepare_set
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The invalid bit is kept in the mask, so we simply clear the&n;&t;&t;   relevant mask register to disable a range. */
id|wrmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|reg
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|wrmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|reg
)paren
comma
id|base
op_lshift
id|PAGE_SHIFT
op_or
id|type
comma
(paren
id|base
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|reg
)paren
comma
op_minus
id|size
op_lshift
id|PAGE_SHIFT
op_or
l_int|0x800
comma
(paren
op_minus
id|size
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
id|post_set
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|generic_validate_add_page
r_int
id|generic_validate_add_page
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
)paren
(brace
r_int
r_int
id|lbase
comma
id|last
suffix:semicolon
multiline_comment|/*  For Intel PPro stepping &lt;= 7, must be 4 MiB aligned &n;&t;    and not touch 0x70000000-&gt;0x7003FFFF */
r_if
c_cond
(paren
id|is_cpu
c_func
(paren
id|INTEL
)paren
op_logical_and
id|boot_cpu_data.x86
op_eq
l_int|6
op_logical_and
id|boot_cpu_data.x86_model
op_eq
l_int|1
op_logical_and
id|boot_cpu_data.x86_mask
op_le
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|base
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
l_int|22
op_minus
id|PAGE_SHIFT
)paren
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: base(0x%lx000) is not 4 MiB aligned&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_plus
id|size
template_param
l_int|0x7003FFFF
)paren
op_logical_and
(paren
id|type
op_eq
id|MTRR_TYPE_WRCOMB
op_logical_or
id|type
op_eq
id|MTRR_TYPE_WRBACK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|base
op_plus
id|size
OL
l_int|0x100
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: cannot set region below 1 MiB (0x%lx000,0x%lx000)&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  Check upper bits of base and last are equal and lower bits are 0&n;&t;    for base and 1 for last  */
id|last
op_assign
id|base
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|lbase
op_assign
id|base
suffix:semicolon
op_logical_neg
(paren
id|lbase
op_amp
l_int|1
)paren
op_logical_and
(paren
id|last
op_amp
l_int|1
)paren
suffix:semicolon
id|lbase
op_assign
id|lbase
op_rshift
l_int|1
comma
id|last
op_assign
id|last
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_ne
id|last
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|generic_have_wrcomb
r_int
id|generic_have_wrcomb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
suffix:semicolon
)brace
DECL|function|positive_have_wrcomb
r_int
id|positive_have_wrcomb
c_func
(paren
r_void
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* generic structure...&n; */
DECL|variable|generic_mtrr_ops
r_struct
id|mtrr_ops
id|generic_mtrr_ops
op_assign
(brace
dot
id|use_intel_if
op_assign
l_int|1
comma
dot
id|set_all
op_assign
id|generic_set_all
comma
dot
id|get
op_assign
id|generic_get_mtrr
comma
dot
id|get_free_region
op_assign
id|generic_get_free_region
comma
dot
id|set
op_assign
id|generic_set_mtrr
comma
dot
id|validate_add_page
op_assign
id|generic_validate_add_page
comma
dot
id|have_wrcomb
op_assign
id|generic_have_wrcomb
comma
)brace
suffix:semicolon
eof
