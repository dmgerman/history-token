multiline_comment|/*&n; *&t;x86 SMP booting functions&n; *&n; *&t;(c) 1995 Alan Cox, Building #3 &lt;alan@redhat.com&gt;&n; *&t;(c) 1998, 1999, 2000 Ingo Molnar &lt;mingo@redhat.com&gt;&n; *&n; *&t;Much of the core SMP work is based on previous work by Thomas Radke, to&n; *&t;whom a great many thanks are extended.&n; *&n; *&t;Thanks to Intel for making available several different Pentium,&n; *&t;Pentium Pro and Pentium-II/Xeon MP machines.&n; *&t;Original development of Linux SMP code supported by Caldera.&n; *&n; *&t;This code is released under the GNU General Public License version 2 or&n; *&t;later.&n; *&n; *&t;Fixes&n; *&t;&t;Felix Koop&t;:&t;NR_CPUS used properly&n; *&t;&t;Jose Renau&t;:&t;Handle single CPU case.&n; *&t;&t;Alan Cox&t;:&t;By repeated request 8) - Total BogoMIP report.&n; *&t;&t;Greg Wright&t;:&t;Fix for kernel stacks panic.&n; *&t;&t;Erich Boleyn&t;:&t;MP v1.4 and additional changes.&n; *&t;Matthias Sattler&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michel Lespinasse&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michael Chastain&t;:&t;Change trampoline.S to gnu as.&n; *&t;&t;Alan Cox&t;:&t;Dumb bug: &squot;B&squot; step PPro&squot;s are fine&n; *&t;&t;Ingo Molnar&t;:&t;Added APIC timers, based on code&n; *&t;&t;&t;&t;&t;from Jose Renau&n; *&t;&t;Ingo Molnar&t;:&t;various cleanups and rewrites&n; *&t;&t;Tigran Aivazian&t;:&t;fixed &quot;0.00 in /proc/uptime on SMP&quot; bug.&n; *&t;Maciej W. Rozycki&t;:&t;Bits for genuine 82489DX APICs&n; *&t;&t;Martin J. Bligh&t;: &t;Added support for multi-quad systems&n; *&t;&t;Dave Jones&t;:&t;Report invalid combinations of Athlon CPUs.&n;*&t;&t;Rusty Russell&t;:&t;Hacked into shape for new &quot;hotplug&quot; boot process. */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/arch_hooks.h&gt;
macro_line|#include &lt;mach_apic.h&gt;
macro_line|#include &lt;mach_wakecpu.h&gt;
macro_line|#include &lt;smpboot_hooks.h&gt;
multiline_comment|/* Set if we find a B stepping CPU */
DECL|variable|smp_b_stepping
r_static
r_int
id|__initdata
id|smp_b_stepping
suffix:semicolon
multiline_comment|/* Number of siblings per CPU package */
DECL|variable|smp_num_siblings
r_int
id|smp_num_siblings
op_assign
l_int|1
suffix:semicolon
DECL|variable|phys_proc_id
r_int
id|phys_proc_id
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Package ID of each logical CPU */
multiline_comment|/* bitmap of online cpus */
DECL|variable|cpu_online_map
id|cpumask_t
id|cpu_online_map
suffix:semicolon
DECL|variable|cpu_callin_map
r_static
id|cpumask_t
id|cpu_callin_map
suffix:semicolon
DECL|variable|cpu_callout_map
id|cpumask_t
id|cpu_callout_map
suffix:semicolon
DECL|variable|smp_commenced_mask
r_static
id|cpumask_t
id|smp_commenced_mask
suffix:semicolon
multiline_comment|/* Per CPU bogomips and other parameters */
DECL|variable|__cacheline_aligned
r_struct
id|cpuinfo_x86
id|cpu_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
multiline_comment|/* Set when the idlers are all forked */
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
suffix:semicolon
multiline_comment|/*&n; * Trampoline 80x86 program as an array.&n; */
r_extern
r_int
r_char
id|trampoline_data
(braket
)braket
suffix:semicolon
r_extern
r_int
r_char
id|trampoline_end
(braket
)braket
suffix:semicolon
DECL|variable|trampoline_base
r_static
r_int
r_char
op_star
id|trampoline_base
suffix:semicolon
multiline_comment|/*&n; * Currently trivial. Write the real-&gt;protected mode&n; * bootstrap into the page concerned. The caller&n; * has made sure it&squot;s suitably aligned.&n; */
DECL|function|setup_trampoline
r_static
r_int
r_int
id|__init
id|setup_trampoline
c_func
(paren
r_void
)paren
(brace
id|memcpy
c_func
(paren
id|trampoline_base
comma
id|trampoline_data
comma
id|trampoline_end
op_minus
id|trampoline_data
)paren
suffix:semicolon
r_return
id|virt_to_phys
c_func
(paren
id|trampoline_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are called very early to get the low memory for the&n; * SMP bootup trampoline page.&n; */
DECL|function|smp_alloc_memory
r_void
id|__init
id|smp_alloc_memory
c_func
(paren
r_void
)paren
(brace
id|trampoline_base
op_assign
(paren
r_void
op_star
)paren
id|alloc_bootmem_low_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Has to be in very low memory so we can execute&n;&t; * real-mode AP code.&n;&t; */
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|trampoline_base
)paren
op_ge
l_int|0x9F000
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The bootstrap kernel entry code has set these up. Save them for&n; * a given CPU&n; */
DECL|function|smp_store_cpu_info
r_static
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
id|cpu_data
op_plus
id|id
suffix:semicolon
op_star
id|c
op_assign
id|boot_cpu_data
suffix:semicolon
r_if
c_cond
(paren
id|id
op_ne
l_int|0
)paren
id|identify_cpu
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mask B, Pentium, but not Pentium MMX&n;&t; */
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|c-&gt;x86
op_eq
l_int|5
op_logical_and
id|c-&gt;x86_mask
op_ge
l_int|1
op_logical_and
id|c-&gt;x86_mask
op_le
l_int|4
op_logical_and
id|c-&gt;x86_model
op_le
l_int|3
)paren
multiline_comment|/*&n;&t;&t; * Remember we have B step Pentia with bugs&n;&t;&t; */
id|smp_b_stepping
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Certain Athlons might work (for various values of &squot;work&squot;) in SMP&n;&t; * but they are not certified as MP capable.&n;&t; */
r_if
c_cond
(paren
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_AMD
)paren
op_logical_and
(paren
id|c-&gt;x86
op_eq
l_int|6
)paren
)paren
(brace
multiline_comment|/* Athlon 660/661 is valid. */
r_if
c_cond
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|6
)paren
op_logical_and
(paren
(paren
id|c-&gt;x86_mask
op_eq
l_int|0
)paren
op_logical_or
(paren
id|c-&gt;x86_mask
op_eq
l_int|1
)paren
)paren
)paren
r_goto
id|valid_k7
suffix:semicolon
multiline_comment|/* Duron 670 is valid */
r_if
c_cond
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|7
)paren
op_logical_and
(paren
id|c-&gt;x86_mask
op_eq
l_int|0
)paren
)paren
r_goto
id|valid_k7
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Athlon 662, Duron 671, and Athlon &gt;model 7 have capability bit.&n;&t;&t; * It&squot;s worth noting that the A5 stepping (662) of some Athlon XP&squot;s&n;&t;&t; * have the MP bit set.&n;&t;&t; * See http://www.heise.de/newsticker/data/jow-18.10.01-000 for more.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|6
)paren
op_logical_and
(paren
id|c-&gt;x86_mask
op_ge
l_int|2
)paren
)paren
op_logical_or
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|7
)paren
op_logical_and
(paren
id|c-&gt;x86_mask
op_ge
l_int|1
)paren
)paren
op_logical_or
(paren
id|c-&gt;x86_model
OG
l_int|7
)paren
)paren
r_if
c_cond
(paren
id|cpu_has_mp
)paren
r_goto
id|valid_k7
suffix:semicolon
multiline_comment|/* If we get here, it&squot;s not a certified SMP capable AMD system. */
id|tainted
op_or_assign
id|TAINT_UNSAFE_SMP
suffix:semicolon
)brace
id|valid_k7
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n; * TSC synchronization.&n; *&n; * We first check whether all CPUs have their TSC&squot;s synchronized,&n; * then we print a warning if not, and always resync.&n; */
DECL|variable|tsc_start_flag
r_static
id|atomic_t
id|tsc_start_flag
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_count_start
r_static
id|atomic_t
id|tsc_count_start
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_count_stop
r_static
id|atomic_t
id|tsc_count_stop
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_values
r_static
r_int
r_int
r_int
id|tsc_values
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|NR_LOOPS
mdefine_line|#define NR_LOOPS 5
multiline_comment|/*&n; * accurate 64-bit/32-bit division, expanded to 32-bit divisions and 64-bit&n; * multiplication. Not terribly optimized but we need it at boot time only&n; * anyway.&n; *&n; * result == a / b&n; *&t;== (a1 + a2*(2^32)) / b&n; *&t;== a1/b + a2*(2^32/b)&n; *&t;== a1/b + a2*((2^32-1)/b) + a2/b + (a2*((2^32-1) % b))/b&n; *&t;&t;    ^---- (this multiplication can overflow)&n; */
DECL|function|div64
r_static
r_int
r_int
r_int
id|__init
id|div64
(paren
r_int
r_int
r_int
id|a
comma
r_int
r_int
id|b0
)paren
(brace
r_int
r_int
id|a1
comma
id|a2
suffix:semicolon
r_int
r_int
r_int
id|res
suffix:semicolon
id|a1
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|a
)paren
(braket
l_int|0
)braket
suffix:semicolon
id|a2
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|a
)paren
(braket
l_int|1
)braket
suffix:semicolon
id|res
op_assign
id|a1
op_div
id|b0
op_plus
(paren
r_int
r_int
r_int
)paren
id|a2
op_star
(paren
r_int
r_int
r_int
)paren
(paren
l_int|0xffffffff
op_div
id|b0
)paren
op_plus
id|a2
op_div
id|b0
op_plus
(paren
id|a2
op_star
(paren
l_int|0xffffffff
op_mod
id|b0
)paren
)paren
op_div
id|b0
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|synchronize_tsc_bp
r_static
r_void
id|__init
id|synchronize_tsc_bp
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
r_int
id|t0
suffix:semicolon
r_int
r_int
r_int
id|sum
comma
id|avg
suffix:semicolon
r_int
r_int
id|delta
suffix:semicolon
r_int
r_int
id|one_usec
suffix:semicolon
r_int
id|buggy
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;checking TSC synchronization across %u CPUs: &quot;
comma
id|num_booting_cpus
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* convert from kcyc/sec to cyc/usec */
id|one_usec
op_assign
id|cpu_khz
op_div
l_int|1000
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_start_flag
comma
l_int|1
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We loop a few times to get a primed instruction cache,&n;&t; * then the last pass is more or less synchronized and&n;&t; * the BP and APs set their cycle counters to zero all at&n;&t; * once. This reduces the chance of having random offsets&n;&t; * between the processors, and guarantees that the maximum&n;&t; * delay between the cycle counters is never bigger than&n;&t; * the latency of information-passing (cachelines) between&n;&t; * two CPUs.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LOOPS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * all APs synchronize but they loop on &squot;== num_cpus&squot;&n;&t;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_start
)paren
op_ne
id|num_booting_cpus
c_func
(paren
)paren
op_minus
l_int|1
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_count_stop
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this lets the APs save their current TSC:&n;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_start
)paren
suffix:semicolon
id|rdtscll
c_func
(paren
id|tsc_values
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We clear the TSC in the last loop:&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|NR_LOOPS
op_minus
l_int|1
)paren
id|write_tsc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for all APs to leave the synchronization point:&n;&t;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_stop
)paren
op_ne
id|num_booting_cpus
c_func
(paren
)paren
op_minus
l_int|1
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_count_start
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_stop
)paren
suffix:semicolon
)brace
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|i
comma
id|cpu_callout_map
)paren
)paren
(brace
id|t0
op_assign
id|tsc_values
(braket
id|i
)braket
suffix:semicolon
id|sum
op_add_assign
id|t0
suffix:semicolon
)brace
)brace
id|avg
op_assign
id|div64
c_func
(paren
id|sum
comma
id|num_booting_cpus
c_func
(paren
)paren
)paren
suffix:semicolon
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|i
comma
id|cpu_callout_map
)paren
)paren
r_continue
suffix:semicolon
id|delta
op_assign
id|tsc_values
(braket
id|i
)braket
op_minus
id|avg
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We report bigger than 2 microseconds clock differences.&n;&t;&t; */
r_if
c_cond
(paren
id|delta
OG
l_int|2
op_star
id|one_usec
)paren
(brace
r_int
id|realdelta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buggy
)paren
(brace
id|buggy
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|realdelta
op_assign
id|div64
c_func
(paren
id|delta
comma
id|one_usec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsc_values
(braket
id|i
)braket
OL
id|avg
)paren
id|realdelta
op_assign
op_minus
id|realdelta
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BIOS BUG: CPU#%d improperly initialized, has %ld usecs TSC skew! FIXED.&bslash;n&quot;
comma
id|i
comma
id|realdelta
)paren
suffix:semicolon
)brace
id|sum
op_add_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buggy
)paren
id|printk
c_func
(paren
l_string|&quot;passed.&bslash;n&quot;
)paren
suffix:semicolon
suffix:semicolon
)brace
DECL|function|synchronize_tsc_ap
r_static
r_void
id|__init
id|synchronize_tsc_ap
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Not every cpu is online at the time&n;&t; * this gets called, so we first wait for the BP to&n;&t; * finish SMP initialization:&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|tsc_start_flag
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LOOPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_start
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_start
)paren
op_ne
id|num_booting_cpus
c_func
(paren
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|rdtscll
c_func
(paren
id|tsc_values
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NR_LOOPS
op_minus
l_int|1
)paren
id|write_tsc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_stop
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_stop
)paren
op_ne
id|num_booting_cpus
c_func
(paren
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|macro|NR_LOOPS
macro_line|#undef NR_LOOPS
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|init_deasserted
r_static
id|atomic_t
id|init_deasserted
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
comma
id|phys_id
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * If waken up by an INIT in an 82489DX configuration&n;&t; * we may get here before an INIT-deassert IPI reaches&n;&t; * our local APIC.  We have to wait for the IPI or we&squot;ll&n;&t; * lock up on an APIC access.&n;&t; */
id|wait_for_init_deassert
c_func
(paren
op_amp
id|init_deasserted
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (This works even if the APIC is not enabled.)&n;&t; */
id|phys_id
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
id|cpuid
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpuid
comma
id|cpu_callin_map
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;huh, phys CPU#%d, CPU#%d already present??&bslash;n&quot;
comma
id|phys_id
comma
id|cpuid
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|Dprintk
c_func
(paren
l_string|&quot;CPU#%d (phys ID: %d) waiting for CALLOUT&bslash;n&quot;
comma
id|cpuid
comma
id|phys_id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * STARTUP IPIs are fragile beasts as they might sometimes&n;&t; * trigger some glue motherboard logic. Complete APIC bus&n;&t; * silence for 1 second, this overestimates the time the&n;&t; * boot CPU is spending to send the up to 2 STARTUP IPIs&n;&t; * by a factor of two. This should be enough.&n;&t; */
multiline_comment|/*&n;&t; * Waiting 2s total for startup (udelay is not yet working)&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Has the boot CPU finished it&squot;s STARTUP sequence?&n;&t;&t; */
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpuid
comma
id|cpu_callout_map
)paren
)paren
r_break
suffix:semicolon
id|rep_nop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BUG: CPU%d started up but did not get a callout!&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the boot CPU has finished the init stage and is spinning&n;&t; * on callin_map until we finish. We are free to set up this&n;&t; * CPU, first the APIC. (this is probably redundant on most&n;&t; * boards)&n;&t; */
id|Dprintk
c_func
(paren
l_string|&quot;CALLIN, before setup_local_APIC().&bslash;n&quot;
)paren
suffix:semicolon
id|smp_callin_clear_local_apic
c_func
(paren
)paren
suffix:semicolon
id|setup_local_APIC
c_func
(paren
)paren
suffix:semicolon
id|map_cpu_to_logical_apicid
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get our bogomips.&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Stack at about %p&bslash;n&quot;
comma
op_amp
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save our processor parameters&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|disable_APIC_timer
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow the master to continue.&n;&t; */
id|cpu_set
c_func
(paren
id|cpuid
comma
id|cpu_callin_map
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Synchronize the TSC with the BP&n;&t; */
r_if
c_cond
(paren
id|cpu_has_tsc
op_logical_and
id|cpu_khz
)paren
id|synchronize_tsc_ap
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|cpucount
r_int
id|cpucount
suffix:semicolon
r_extern
r_int
id|cpu_idle
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Activate a secondary processor.&n; */
DECL|function|start_secondary
r_int
id|__init
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
multiline_comment|/*&n;&t; * Dont put anything before smp_callin(), SMP&n;&t; * booting is too fragile that we want to limit the&n;&t; * things done here to the most necessary things.&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
id|smp_callin
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|smp_commenced_mask
)paren
)paren
id|rep_nop
c_func
(paren
)paren
suffix:semicolon
id|setup_secondary_APIC_clock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmi_watchdog
op_eq
id|NMI_IO_APIC
)paren
(brace
id|disable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|enable_NMI_through_LVT0
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|enable_8259A_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|enable_APIC_timer
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * low-memory mappings have been cleared, flush them from&n;&t; * the local TLBs too.&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_online_map
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_return
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Everything has been set up for the secondary&n; * CPUs - they just need to reload everything&n; * from the task structure&n; * This function must not return.&n; */
DECL|function|initialize_secondary
r_void
id|__init
id|initialize_secondary
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t actually need to load the full TSS,&n;&t; * basically just the stack pointer and the eip.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;movl %0,%%esp&bslash;n&bslash;t&quot;
l_string|&quot;jmp *%1&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|current-&gt;thread.esp
)paren
comma
l_string|&quot;r&quot;
(paren
id|current-&gt;thread.eip
)paren
)paren
suffix:semicolon
)brace
r_extern
r_struct
(brace
DECL|member|esp
r_void
op_star
id|esp
suffix:semicolon
DECL|member|ss
r_int
r_int
id|ss
suffix:semicolon
)brace
id|stack_start
suffix:semicolon
DECL|function|fork_by_hand
r_static
r_struct
id|task_struct
op_star
id|__init
id|fork_by_hand
c_func
(paren
r_void
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t care about the eip and regs settings since&n;&t; * we&squot;ll never reschedule the forked task.&n;&t; */
r_return
id|copy_process
c_func
(paren
id|CLONE_VM
op_or
id|CLONE_IDLETASK
comma
l_int|0
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
multiline_comment|/* which logical CPUs are on which nodes */
DECL|variable|node_2_cpu_mask
id|cpumask_t
id|node_2_cpu_mask
(braket
id|MAX_NUMNODES
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|MAX_NUMNODES
op_minus
l_int|1
)braket
op_assign
id|CPU_MASK_NONE
)brace
suffix:semicolon
multiline_comment|/* which node each logical CPU is on */
DECL|variable|cpu_2_node
r_int
id|cpu_2_node
(braket
id|NR_CPUS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_CPUS
op_minus
l_int|1
)braket
op_assign
l_int|0
)brace
suffix:semicolon
DECL|variable|cpu_2_node
id|EXPORT_SYMBOL
c_func
(paren
id|cpu_2_node
)paren
suffix:semicolon
multiline_comment|/* set up a mapping between cpu and node. */
DECL|function|map_cpu_to_node
r_static
r_inline
r_void
id|map_cpu_to_node
c_func
(paren
r_int
id|cpu
comma
r_int
id|node
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Mapping cpu %d to node %d&bslash;n&quot;
comma
id|cpu
comma
id|node
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|node_2_cpu_mask
(braket
id|node
)braket
)paren
suffix:semicolon
id|cpu_2_node
(braket
id|cpu
)braket
op_assign
id|node
suffix:semicolon
)brace
multiline_comment|/* undo a mapping between cpu and node. */
DECL|function|unmap_cpu_to_node
r_static
r_inline
r_void
id|unmap_cpu_to_node
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|node
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unmapping cpu %d from all nodes&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|MAX_NUMNODES
suffix:semicolon
id|node
op_increment
)paren
id|cpu_clear
c_func
(paren
id|cpu
comma
id|node_2_cpu_mask
(braket
id|node
)braket
)paren
suffix:semicolon
id|cpu_2_node
(braket
id|cpu
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_NUMA */
DECL|macro|map_cpu_to_node
mdefine_line|#define map_cpu_to_node(cpu, node)&t;({})
DECL|macro|unmap_cpu_to_node
mdefine_line|#define unmap_cpu_to_node(cpu)&t;({})
macro_line|#endif /* CONFIG_NUMA */
DECL|variable|cpu_2_logical_apicid
id|u8
id|cpu_2_logical_apicid
(braket
id|NR_CPUS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_CPUS
op_minus
l_int|1
)braket
op_assign
id|BAD_APICID
)brace
suffix:semicolon
DECL|function|map_cpu_to_logical_apicid
r_void
id|map_cpu_to_logical_apicid
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|apicid
op_assign
id|logical_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|cpu_2_logical_apicid
(braket
id|cpu
)braket
op_assign
id|apicid
suffix:semicolon
id|map_cpu_to_node
c_func
(paren
id|cpu
comma
id|apicid_to_node
c_func
(paren
id|apicid
)paren
)paren
suffix:semicolon
)brace
DECL|function|unmap_cpu_to_logical_apicid
r_void
id|unmap_cpu_to_logical_apicid
c_func
(paren
r_int
id|cpu
)paren
(brace
id|cpu_2_logical_apicid
(braket
id|cpu
)braket
op_assign
id|BAD_APICID
suffix:semicolon
id|unmap_cpu_to_node
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
macro_line|#if APIC_DEBUG
DECL|function|__inquire_remote_apic
r_static
r_inline
r_void
id|__inquire_remote_apic
c_func
(paren
r_int
id|apicid
)paren
(brace
r_int
id|i
comma
id|regs
(braket
)braket
op_assign
(brace
id|APIC_ID
op_rshift
l_int|4
comma
id|APIC_LVR
op_rshift
l_int|4
comma
id|APIC_SPIV
op_rshift
l_int|4
)brace
suffix:semicolon
r_char
op_star
id|names
(braket
)braket
op_assign
(brace
l_string|&quot;ID&quot;
comma
l_string|&quot;VERSION&quot;
comma
l_string|&quot;SPIV&quot;
)brace
suffix:semicolon
r_int
id|timeout
comma
id|status
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Inquiring remote APIC #%d...&bslash;n&quot;
comma
id|apicid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
op_star
id|regs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;... APIC #%d %s: &quot;
comma
id|apicid
comma
id|names
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for idle.&n;&t;&t; */
id|apic_wait_icr_idle
c_func
(paren
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|SET_APIC_DEST_FIELD
c_func
(paren
id|apicid
)paren
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|APIC_DM_REMRD
op_or
id|regs
(braket
id|i
)braket
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
id|APIC_ICR_RR_MASK
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_eq
id|APIC_ICR_RR_INPROG
op_logical_and
id|timeout
op_increment
OL
l_int|1000
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|APIC_ICR_RR_VALID
suffix:colon
id|status
op_assign
id|apic_read
c_func
(paren
id|APIC_RRR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
macro_line|#ifdef WAKE_SECONDARY_VIA_NMI
multiline_comment|/* &n; * Poke the other CPU in the eye via NMI to wake it up. Remember that the normal&n; * INIT, INIT, STARTUP sequence will reset the chip hard for us, and this&n; * won&squot;t ... remember to clear down the APIC, etc later.&n; */
r_static
r_int
id|__init
DECL|function|wakeup_secondary_cpu
id|wakeup_secondary_cpu
c_func
(paren
r_int
id|logical_apicid
comma
r_int
r_int
id|start_eip
)paren
(brace
r_int
r_int
id|send_status
op_assign
l_int|0
comma
id|accept_status
op_assign
l_int|0
suffix:semicolon
r_int
id|timeout
comma
id|maxlvt
suffix:semicolon
multiline_comment|/* Target chip */
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|SET_APIC_DEST_FIELD
c_func
(paren
id|logical_apicid
)paren
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack */
multiline_comment|/* Kick the second */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|APIC_DM_NMI
op_or
id|APIC_DEST_LOGICAL
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|Dprintk
c_func
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
id|APIC_ICR_BUSY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Give the other CPU some time to accept the IPI.&n;&t; */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Due to the Pentium erratum 3AP.&n;&t; */
id|maxlvt
op_assign
id|get_maxlvt
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxlvt
OG
l_int|3
)paren
(brace
id|apic_read_around
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;NMI sent.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC never delivered???&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accept_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC delivery error (%lx).&bslash;n&quot;
comma
id|accept_status
)paren
suffix:semicolon
r_return
(paren
id|send_status
op_or
id|accept_status
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAKE_SECONDARY_VIA_NMI */
macro_line|#ifdef WAKE_SECONDARY_VIA_INIT
r_static
r_int
id|__init
DECL|function|wakeup_secondary_cpu
id|wakeup_secondary_cpu
c_func
(paren
r_int
id|phys_apicid
comma
r_int
r_int
id|start_eip
)paren
(brace
r_int
r_int
id|send_status
op_assign
l_int|0
comma
id|accept_status
op_assign
l_int|0
suffix:semicolon
r_int
id|maxlvt
comma
id|timeout
comma
id|num_starts
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * Be paranoid about clearing APIC errors.&n;&t; */
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|apic_version
(braket
id|phys_apicid
)braket
)paren
)paren
(brace
id|apic_read_around
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
)brace
id|Dprintk
c_func
(paren
l_string|&quot;Asserting INIT.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn INIT on target chip&n;&t; */
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|SET_APIC_DEST_FIELD
c_func
(paren
id|phys_apicid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send IPI&n;&t; */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|APIC_INT_LEVELTRIG
op_or
id|APIC_INT_ASSERT
op_or
id|APIC_DM_INIT
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|Dprintk
c_func
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
id|APIC_ICR_BUSY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Deasserting INIT.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Target chip */
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|SET_APIC_DEST_FIELD
c_func
(paren
id|phys_apicid
)paren
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|APIC_INT_LEVELTRIG
op_or
id|APIC_DM_INIT
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|Dprintk
c_func
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
id|APIC_ICR_BUSY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|init_deasserted
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Should we send STARTUP IPIs ?&n;&t; *&n;&t; * Determine this based on the APIC version.&n;&t; * If we don&squot;t have an integrated APIC, don&squot;t send the STARTUP IPIs.&n;&t; */
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|apic_version
(braket
id|phys_apicid
)braket
)paren
)paren
id|num_starts
op_assign
l_int|2
suffix:semicolon
r_else
id|num_starts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Run STARTUP IPI loop.&n;&t; */
id|Dprintk
c_func
(paren
l_string|&quot;#startup loops: %d.&bslash;n&quot;
comma
id|num_starts
)paren
suffix:semicolon
id|maxlvt
op_assign
id|get_maxlvt
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|num_starts
suffix:semicolon
id|j
op_increment
)paren
(brace
id|Dprintk
c_func
(paren
l_string|&quot;Sending STARTUP #%d.&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
id|apic_read_around
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;After apic_write.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * STARTUP IPI&n;&t;&t; */
multiline_comment|/* Target chip */
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|SET_APIC_DEST_FIELD
c_func
(paren
id|phys_apicid
)paren
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack */
multiline_comment|/* Kick the second */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|APIC_DM_STARTUP
op_or
(paren
id|start_eip
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Give the other CPU some time to accept the IPI.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|300
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Startup point 1.&bslash;n&quot;
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|Dprintk
c_func
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
id|APIC_ICR_BUSY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Give the other CPU some time to accept the IPI.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Due to the Pentium erratum 3AP.&n;&t;&t; */
r_if
c_cond
(paren
id|maxlvt
OG
l_int|3
)paren
(brace
id|apic_read_around
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
op_logical_or
id|accept_status
)paren
r_break
suffix:semicolon
)brace
id|Dprintk
c_func
(paren
l_string|&quot;After Startup.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC never delivered???&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accept_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC delivery error (%lx).&bslash;n&quot;
comma
id|accept_status
)paren
suffix:semicolon
r_return
(paren
id|send_status
op_or
id|accept_status
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAKE_SECONDARY_VIA_INIT */
r_extern
id|cpumask_t
id|cpu_initialized
suffix:semicolon
DECL|function|do_boot_cpu
r_static
r_int
id|__init
id|do_boot_cpu
c_func
(paren
r_int
id|apicid
)paren
multiline_comment|/*&n; * NOTE - on most systems this is a PHYSICAL apic ID, but on multiquad&n; * (ie clustered apic addressing mode), this is a LOGICAL apic ID.&n; * Returns zero if CPU booted OK, else error code from wakeup_secondary_cpu.&n; */
(brace
r_struct
id|task_struct
op_star
id|idle
suffix:semicolon
r_int
r_int
id|boot_error
suffix:semicolon
r_int
id|timeout
comma
id|cpu
suffix:semicolon
r_int
r_int
id|start_eip
suffix:semicolon
r_int
r_int
id|nmi_high
op_assign
l_int|0
comma
id|nmi_low
op_assign
l_int|0
suffix:semicolon
id|cpu
op_assign
op_increment
id|cpucount
suffix:semicolon
multiline_comment|/*&n;&t; * We can&squot;t use kernel_thread since we must avoid to&n;&t; * reschedule the child.&n;&t; */
id|idle
op_assign
id|fork_by_hand
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|idle
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;failed fork for CPU %d&quot;
comma
id|cpu
)paren
suffix:semicolon
id|wake_up_forked_process
c_func
(paren
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We remove it from the pidhash and the runqueue&n;&t; * once we got the process:&n;&t; */
id|init_idle
c_func
(paren
id|idle
comma
id|cpu
)paren
suffix:semicolon
id|idle-&gt;thread.eip
op_assign
(paren
r_int
r_int
)paren
id|start_secondary
suffix:semicolon
id|unhash_process
c_func
(paren
id|idle
)paren
suffix:semicolon
multiline_comment|/* start_eip had better be page-aligned! */
id|start_eip
op_assign
id|setup_trampoline
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* So we see what&squot;s up   */
id|printk
c_func
(paren
l_string|&quot;Booting processor %d/%d eip %lx&bslash;n&quot;
comma
id|cpu
comma
id|apicid
comma
id|start_eip
)paren
suffix:semicolon
multiline_comment|/* Stack for startup_32 can be just as for start_secondary onwards */
id|stack_start.esp
op_assign
(paren
r_void
op_star
)paren
id|idle-&gt;thread.esp
suffix:semicolon
id|irq_ctx_init
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This grunge runs the startup process for&n;&t; * the targeted processor.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|init_deasserted
comma
l_int|0
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Setting warm reset code and vector.&bslash;n&quot;
)paren
suffix:semicolon
id|store_NMI_vector
c_func
(paren
op_amp
id|nmi_high
comma
op_amp
id|nmi_low
)paren
suffix:semicolon
id|smpboot_setup_warm_reset_vector
c_func
(paren
id|start_eip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Starting actual IPI sequence...&n;&t; */
id|boot_error
op_assign
id|wakeup_secondary_cpu
c_func
(paren
id|apicid
comma
id|start_eip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_error
)paren
(brace
multiline_comment|/*&n;&t;&t; * allow APs to start initializing.&n;&t;&t; */
id|Dprintk
c_func
(paren
l_string|&quot;Before Callout %d.&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;After Callout %d.&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait 5s total for a response&n;&t;&t; */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|50000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callin_map
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* It has booted */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callin_map
)paren
)paren
(brace
multiline_comment|/* number CPUs logically, starting from 1 (BSP is 0) */
id|Dprintk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
id|cpu
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
id|cpu
)braket
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;CPU has booted.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|boot_error
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|trampoline_base
)paren
op_eq
l_int|0xA5
)paren
multiline_comment|/* trampoline started but...? */
id|printk
c_func
(paren
l_string|&quot;Stuck ??&bslash;n&quot;
)paren
suffix:semicolon
r_else
multiline_comment|/* trampoline code not run */
id|printk
c_func
(paren
l_string|&quot;Not responding.&bslash;n&quot;
)paren
suffix:semicolon
id|inquire_remote_apic
c_func
(paren
id|apicid
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|boot_error
)paren
(brace
multiline_comment|/* Try to put things back the way they were before ... */
id|unmap_cpu_to_logical_apicid
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|cpu_clear
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
suffix:semicolon
multiline_comment|/* was set here (do_boot_cpu()) */
id|cpu_clear
c_func
(paren
id|cpu
comma
id|cpu_initialized
)paren
suffix:semicolon
multiline_comment|/* was set by cpu_init() */
id|cpucount
op_decrement
suffix:semicolon
)brace
multiline_comment|/* mark &quot;stuck&quot; area as not stuck */
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|trampoline_base
)paren
op_assign
l_int|0
suffix:semicolon
r_return
id|boot_error
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|variable|cache_decay_ticks
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_int
r_int
id|cachesize
suffix:semicolon
multiline_comment|/* kB   */
r_int
r_int
id|bandwidth
op_assign
l_int|350
suffix:semicolon
multiline_comment|/* MB/s */
multiline_comment|/*&n;&t; * Rough estimation for SMP scheduling, this is the number of&n;&t; * cycles it takes for a fully memory-limited process to flush&n;&t; * the SMP-local cache.&n;&t; *&n;&t; * (For a P5 this pretty much means we will choose another idle&n;&t; *  CPU almost always at wakeup time (this is due to the small&n;&t; *  L1 cache), on PIIs it&squot;s around 50-100 usecs, depending on&n;&t; *  the cache size)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_khz
)paren
(brace
multiline_comment|/*&n;&t;&t; * this basically disables processor-affinity&n;&t;&t; * scheduling on SMP without a TSC.&n;&t;&t; */
id|cacheflush_time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|cachesize
op_assign
id|boot_cpu_data.x86_cache_size
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
op_eq
op_minus
l_int|1
)paren
(brace
id|cachesize
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Pentiums, 2x8kB cache */
id|bandwidth
op_assign
l_int|100
suffix:semicolon
)brace
id|cacheflush_time
op_assign
(paren
id|cpu_khz
op_rshift
l_int|10
)paren
op_star
(paren
id|cachesize
op_lshift
l_int|10
)paren
op_div
id|bandwidth
suffix:semicolon
)brace
id|cache_decay_ticks
op_assign
(paren
r_int
)paren
id|cacheflush_time
op_div
id|cpu_khz
op_plus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;per-CPU timeslice cutoff: %ld.%02ld usecs.&bslash;n&quot;
comma
(paren
r_int
)paren
id|cacheflush_time
op_div
(paren
id|cpu_khz
op_div
l_int|1000
)paren
comma
(paren
(paren
r_int
)paren
id|cacheflush_time
op_star
l_int|100
op_div
(paren
id|cpu_khz
op_div
l_int|1000
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;task migration cache decay timeout: %ld msecs.&bslash;n&quot;
comma
id|cache_decay_ticks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cycle through the processors sending APIC IPIs to boot each.&n; */
DECL|variable|boot_cpu_logical_apicid
r_static
r_int
id|boot_cpu_logical_apicid
suffix:semicolon
multiline_comment|/* Where the IO area was mapped on multiquad, always 0 otherwise */
DECL|variable|xquad_portio
r_void
op_star
id|xquad_portio
suffix:semicolon
DECL|variable|__cacheline_aligned
id|cpumask_t
id|cpu_sibling_map
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|function|smp_boot_cpus
r_static
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
r_int
id|apicid
comma
id|cpu
comma
id|bit
comma
id|kicked
suffix:semicolon
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Setup boot CPU information&n;&t; */
id|smp_store_cpu_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Final full version of the data */
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
l_int|0
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|boot_cpu_physical_apicid
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
id|boot_cpu_logical_apicid
op_assign
id|logical_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|cpu
op_assign
l_int|0
suffix:semicolon
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|cpus_clear
c_func
(paren
id|cpu_sibling_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
l_int|0
comma
id|cpu_sibling_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we couldn&squot;t find an SMP configuration at boot time,&n;&t; * get out of here now!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_found_config
op_logical_and
op_logical_neg
id|acpi_lapic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SMP motherboard not detected.&bslash;n&quot;
)paren
suffix:semicolon
id|smpboot_clear_io_apic_irqs
c_func
(paren
)paren
suffix:semicolon
id|phys_cpu_present_map
op_assign
id|physid_mask_of_physid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|APIC_init_uniprocessor
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Local APIC not detected.&quot;
l_string|&quot; Using dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
id|map_cpu_to_logical_apicid
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Should not be necessary because the MP table should list the boot&n;&t; * CPU too, but we do it for the sake of robustness anyway.&n;&t; * Makes no sense to do this check in clustered apic mode, so skip it&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_phys_apicid_present
c_func
(paren
id|boot_cpu_physical_apicid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;weird, boot CPU (#%d) not listed by the BIOS.&bslash;n&quot;
comma
id|boot_cpu_physical_apicid
)paren
suffix:semicolon
id|physid_set
c_func
(paren
id|hard_smp_processor_id
c_func
(paren
)paren
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we couldn&squot;t find a local APIC, then get out of here now!&n;&t; */
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|apic_version
(braket
id|boot_cpu_physical_apicid
)braket
)paren
op_logical_and
op_logical_neg
id|cpu_has_apic
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BIOS bug, local APIC #%d not detected!...&bslash;n&quot;
comma
id|boot_cpu_physical_apicid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;... forcing use of dummy APIC emulation. (tell your hw vendor)&bslash;n&quot;
)paren
suffix:semicolon
id|smpboot_clear_io_apic_irqs
c_func
(paren
)paren
suffix:semicolon
id|phys_cpu_present_map
op_assign
id|physid_mask_of_physid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|verify_local_APIC
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If SMP should be disabled, then really disable it!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_cpus
)paren
(brace
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP mode deactivated, forcing use of dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
id|smpboot_clear_io_apic_irqs
c_func
(paren
)paren
suffix:semicolon
id|phys_cpu_present_map
op_assign
id|physid_mask_of_physid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|connect_bsp_APIC
c_func
(paren
)paren
suffix:semicolon
id|setup_local_APIC
c_func
(paren
)paren
suffix:semicolon
id|map_cpu_to_logical_apicid
c_func
(paren
)paren
suffix:semicolon
id|setup_portio_remap
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the CPU present map and fire up the other CPUs via do_boot_cpu&n;&t; *&n;&t; * In clustered apic mode, phys_cpu_present_map is a constructed thus:&n;&t; * bits 0-3 are quad0, 4-7 are quad1, etc. A perverse twist on the &n;&t; * clustered apic ID.&n;&t; */
id|Dprintk
c_func
(paren
l_string|&quot;CPU present map: %lx&bslash;n&quot;
comma
id|physids_coerce
c_func
(paren
id|phys_cpu_present_map
)paren
)paren
suffix:semicolon
id|kicked
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|kicked
OL
id|NR_CPUS
op_logical_and
id|bit
OL
id|MAX_APICS
suffix:semicolon
id|bit
op_increment
)paren
(brace
id|apicid
op_assign
id|cpu_present_to_apicid
c_func
(paren
id|bit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t even attempt to start the boot CPU!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|apicid
op_eq
id|boot_cpu_apicid
)paren
op_logical_or
(paren
id|apicid
op_eq
id|BAD_APICID
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_apicid_present
c_func
(paren
id|bit
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|max_cpus
op_le
id|cpucount
op_plus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|do_boot_cpu
c_func
(paren
id|apicid
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;CPU #%d not responding - cannot use it.&bslash;n&quot;
comma
id|apicid
)paren
suffix:semicolon
r_else
op_increment
id|kicked
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Cleanup possible dangling ends...&n;&t; */
id|smpboot_restore_warm_reset_vector
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow the user to impress friends.&n;&t; */
id|Dprintk
c_func
(paren
l_string|&quot;Before bogomips.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
(braket
id|cpu
)braket
dot
id|loops_per_jiffy
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
id|bogosum
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|bogosum
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|Dprintk
c_func
(paren
l_string|&quot;Before bogocount - setting activated=1.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_b_stepping
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: SMP operation may be unreliable with B stepping processors.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t taint if we are running SMP kernel on a single non-MP&n;&t; * approved Athlon&n;&t; */
r_if
c_cond
(paren
id|tainted
op_amp
id|TAINT_UNSAFE_SMP
)paren
(brace
r_if
c_cond
(paren
id|cpucount
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;WARNING: This combination of AMD processors is not suitable for SMP.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|tainted
op_and_assign
op_complement
id|TAINT_UNSAFE_SMP
suffix:semicolon
)brace
id|Dprintk
c_func
(paren
l_string|&quot;Boot done.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * construct cpu_sibling_map[], so that we can tell sibling CPUs&n;&t; * efficiently.&n;&t; */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
id|cpus_clear
c_func
(paren
id|cpu_sibling_map
(braket
id|cpu
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_int
id|siblings
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|smp_num_siblings
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|i
comma
id|cpu_callout_map
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|phys_proc_id
(braket
id|cpu
)braket
op_eq
id|phys_proc_id
(braket
id|i
)braket
)paren
(brace
id|siblings
op_increment
suffix:semicolon
id|cpu_set
c_func
(paren
id|i
comma
id|cpu_sibling_map
(braket
id|cpu
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|siblings
op_increment
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_sibling_map
(braket
id|cpu
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|siblings
op_ne
id|smp_num_siblings
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: %d siblings found for CPU%d, should be %d&bslash;n&quot;
comma
id|siblings
comma
id|cpu
comma
id|smp_num_siblings
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nmi_watchdog
op_eq
id|NMI_LOCAL_APIC
)paren
id|check_nmi_watchdog
c_func
(paren
)paren
suffix:semicolon
id|smpboot_setup_io_apic
c_func
(paren
)paren
suffix:semicolon
id|setup_boot_APIC_clock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Synchronize the TSC with the AP&n;&t; */
r_if
c_cond
(paren
id|cpu_has_tsc
op_logical_and
id|cpucount
op_logical_and
id|cpu_khz
)paren
id|synchronize_tsc_bp
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCHED_SMT
macro_line|#ifdef CONFIG_NUMA
DECL|variable|sched_group_cpus
r_static
r_struct
id|sched_group
id|sched_group_cpus
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|sched_group_phys
r_static
r_struct
id|sched_group
id|sched_group_phys
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|sched_group_nodes
r_static
r_struct
id|sched_group
id|sched_group_nodes
(braket
id|MAX_NUMNODES
)braket
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|sched_domain
comma
id|cpu_domains
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|sched_domain
comma
id|phys_domains
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|sched_domain
comma
id|node_domains
)paren
suffix:semicolon
DECL|function|arch_init_sched_domains
id|__init
r_void
id|arch_init_sched_domains
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sched_group
op_star
id|first
op_assign
l_int|NULL
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Set up domains */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
r_struct
id|sched_domain
op_star
id|phys_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|phys_domains
comma
id|i
)paren
suffix:semicolon
r_struct
id|sched_domain
op_star
id|node_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|node_domains
comma
id|i
)paren
suffix:semicolon
r_int
id|node
op_assign
id|cpu_to_node
c_func
(paren
id|i
)paren
suffix:semicolon
id|cpumask_t
id|nodemask
op_assign
id|node_to_cpumask
c_func
(paren
id|node
)paren
suffix:semicolon
op_star
id|cpu_domain
op_assign
id|SD_SIBLING_INIT
suffix:semicolon
id|cpu_domain-&gt;span
op_assign
id|cpu_sibling_map
(braket
id|i
)braket
suffix:semicolon
id|cpu_domain-&gt;parent
op_assign
id|phys_domain
suffix:semicolon
id|cpu_domain-&gt;groups
op_assign
op_amp
id|sched_group_cpus
(braket
id|i
)braket
suffix:semicolon
op_star
id|phys_domain
op_assign
id|SD_CPU_INIT
suffix:semicolon
id|phys_domain-&gt;span
op_assign
id|nodemask
suffix:semicolon
id|phys_domain-&gt;parent
op_assign
id|node_domain
suffix:semicolon
id|phys_domain-&gt;groups
op_assign
op_amp
id|sched_group_phys
(braket
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)braket
suffix:semicolon
op_star
id|node_domain
op_assign
id|SD_NODE_INIT
suffix:semicolon
id|node_domain-&gt;span
op_assign
id|cpu_possible_map
suffix:semicolon
id|node_domain-&gt;groups
op_assign
op_amp
id|sched_group_nodes
(braket
id|cpu_to_node
c_func
(paren
id|i
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/* Set up CPU (sibling) groups */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|first
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)paren
r_continue
suffix:semicolon
id|for_each_cpu_mask
c_func
(paren
id|j
comma
id|cpu_domain-&gt;span
)paren
(brace
r_struct
id|sched_group
op_star
id|cpu
op_assign
op_amp
id|sched_group_cpus
(braket
id|j
)braket
suffix:semicolon
id|cpu-&gt;cpumask
op_assign
id|CPU_MASK_NONE
suffix:semicolon
id|cpu_set
c_func
(paren
id|j
comma
id|cpu-&gt;cpumask
)paren
suffix:semicolon
id|cpu-&gt;cpu_power
op_assign
id|SCHED_LOAD_SCALE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|first
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|last-&gt;next
op_assign
id|cpu
suffix:semicolon
id|last
op_assign
id|cpu
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|first
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NUMNODES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
id|cpumask_t
id|nodemask
suffix:semicolon
r_struct
id|sched_group
op_star
id|node
op_assign
op_amp
id|sched_group_nodes
(braket
id|i
)braket
suffix:semicolon
id|cpus_and
c_func
(paren
id|nodemask
comma
id|node_to_cpumask
c_func
(paren
id|i
)paren
comma
id|cpu_possible_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|nodemask
)paren
)paren
r_continue
suffix:semicolon
id|first
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Set up physical groups */
id|for_each_cpu_mask
c_func
(paren
id|j
comma
id|nodemask
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|j
)paren
suffix:semicolon
r_struct
id|sched_group
op_star
id|cpu
op_assign
op_amp
id|sched_group_phys
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ne
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)paren
r_continue
suffix:semicolon
id|cpu-&gt;cpumask
op_assign
id|cpu_domain-&gt;span
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make each extra sibling increase power by 10% of&n;&t;&t;&t; * the basic CPU. This is very arbitrary.&n;&t;&t;&t; */
id|cpu-&gt;cpu_power
op_assign
id|SCHED_LOAD_SCALE
op_plus
id|SCHED_LOAD_SCALE
op_star
(paren
id|cpus_weight
c_func
(paren
id|cpu-&gt;cpumask
)paren
op_minus
l_int|1
)paren
op_div
l_int|10
suffix:semicolon
id|node-&gt;cpu_power
op_add_assign
id|cpu-&gt;cpu_power
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|first
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|last-&gt;next
op_assign
id|cpu
suffix:semicolon
id|last
op_assign
id|cpu
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|first
suffix:semicolon
)brace
multiline_comment|/* Set up nodes */
id|first
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NUMNODES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sched_group
op_star
id|cpu
op_assign
op_amp
id|sched_group_nodes
(braket
id|i
)braket
suffix:semicolon
id|cpumask_t
id|nodemask
suffix:semicolon
id|cpus_and
c_func
(paren
id|nodemask
comma
id|node_to_cpumask
c_func
(paren
id|i
)paren
comma
id|cpu_possible_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|nodemask
)paren
)paren
r_continue
suffix:semicolon
id|cpu-&gt;cpumask
op_assign
id|nodemask
suffix:semicolon
multiline_comment|/* -&gt;cpu_power already setup */
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|first
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|last-&gt;next
op_assign
id|cpu
suffix:semicolon
id|last
op_assign
id|cpu
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|first
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
id|cpu_attach_domain
c_func
(paren
id|cpu_domain
comma
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* !CONFIG_NUMA */
DECL|variable|sched_group_cpus
r_static
r_struct
id|sched_group
id|sched_group_cpus
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|sched_group_phys
r_static
r_struct
id|sched_group
id|sched_group_phys
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|sched_domain
comma
id|cpu_domains
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|sched_domain
comma
id|phys_domains
)paren
suffix:semicolon
DECL|function|arch_init_sched_domains
id|__init
r_void
id|arch_init_sched_domains
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sched_group
op_star
id|first
op_assign
l_int|NULL
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Set up domains */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
r_struct
id|sched_domain
op_star
id|phys_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|phys_domains
comma
id|i
)paren
suffix:semicolon
op_star
id|cpu_domain
op_assign
id|SD_SIBLING_INIT
suffix:semicolon
id|cpu_domain-&gt;span
op_assign
id|cpu_sibling_map
(braket
id|i
)braket
suffix:semicolon
id|cpu_domain-&gt;parent
op_assign
id|phys_domain
suffix:semicolon
id|cpu_domain-&gt;groups
op_assign
op_amp
id|sched_group_cpus
(braket
id|i
)braket
suffix:semicolon
op_star
id|phys_domain
op_assign
id|SD_CPU_INIT
suffix:semicolon
id|phys_domain-&gt;span
op_assign
id|cpu_possible_map
suffix:semicolon
id|phys_domain-&gt;groups
op_assign
op_amp
id|sched_group_phys
(braket
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/* Set up CPU (sibling) groups */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|first
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)paren
r_continue
suffix:semicolon
id|for_each_cpu_mask
c_func
(paren
id|j
comma
id|cpu_domain-&gt;span
)paren
(brace
r_struct
id|sched_group
op_star
id|cpu
op_assign
op_amp
id|sched_group_cpus
(braket
id|j
)braket
suffix:semicolon
id|cpus_clear
c_func
(paren
id|cpu-&gt;cpumask
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|j
comma
id|cpu-&gt;cpumask
)paren
suffix:semicolon
id|cpu-&gt;cpu_power
op_assign
id|SCHED_LOAD_SCALE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|first
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|last-&gt;next
op_assign
id|cpu
suffix:semicolon
id|last
op_assign
id|cpu
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|first
suffix:semicolon
)brace
id|first
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Set up physical groups */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
r_struct
id|sched_group
op_star
id|cpu
op_assign
op_amp
id|sched_group_phys
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|first_cpu
c_func
(paren
id|cpu_domain-&gt;span
)paren
)paren
r_continue
suffix:semicolon
id|cpu-&gt;cpumask
op_assign
id|cpu_domain-&gt;span
suffix:semicolon
multiline_comment|/* See SMT+NUMA setup for comment */
id|cpu-&gt;cpu_power
op_assign
id|SCHED_LOAD_SCALE
op_plus
id|SCHED_LOAD_SCALE
op_star
(paren
id|cpus_weight
c_func
(paren
id|cpu-&gt;cpumask
)paren
op_minus
l_int|1
)paren
op_div
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|first
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|last-&gt;next
op_assign
id|cpu
suffix:semicolon
id|last
op_assign
id|cpu
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|first
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
r_struct
id|sched_domain
op_star
id|cpu_domain
op_assign
op_amp
id|per_cpu
c_func
(paren
id|cpu_domains
comma
id|i
)paren
suffix:semicolon
id|cpu_attach_domain
c_func
(paren
id|cpu_domain
comma
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_NUMA */
macro_line|#endif /* CONFIG_SCHED_SMT */
multiline_comment|/* These are wrappers to interface to the new boot process.  Someone&n;   who understands all this stuff should rewrite it properly. --RR 15/Jul/02 */
DECL|function|smp_prepare_cpus
r_void
id|__init
id|smp_prepare_cpus
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
id|smp_boot_cpus
c_func
(paren
id|max_cpus
)paren
suffix:semicolon
)brace
DECL|function|smp_prepare_boot_cpu
r_void
id|__devinit
id|smp_prepare_boot_cpu
c_func
(paren
r_void
)paren
(brace
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_online_map
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_callout_map
)paren
suffix:semicolon
)brace
DECL|function|__cpu_up
r_int
id|__devinit
id|__cpu_up
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
multiline_comment|/* This only works at boot for x86.  See &quot;rewrite&quot; above. */
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|smp_commenced_mask
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* In case one didn&squot;t come up */
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callin_map
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Unleash the CPU! */
id|cpu_set
c_func
(paren
id|cpu
comma
id|smp_commenced_mask
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_online_map
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_cpus_done
r_void
id|__init
id|smp_cpus_done
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
macro_line|#ifdef CONFIG_X86_IO_APIC
id|setup_ioapic_dest
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|zap_low_mappings
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_intr_init
r_void
id|__init
id|smp_intr_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * IRQ0 must be given a fixed assignment and initialized,&n;&t; * because it&squot;s used before the IO-APIC is set up.&n;&t; */
id|set_intr_gate
c_func
(paren
id|FIRST_DEVICE_VECTOR
comma
id|interrupt
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The reschedule interrupt is a CPU-to-CPU reschedule-helper&n;&t; * IPI, driven by wakeup.&n;&t; */
id|set_intr_gate
c_func
(paren
id|RESCHEDULE_VECTOR
comma
id|reschedule_interrupt
)paren
suffix:semicolon
multiline_comment|/* IPI for invalidation */
id|set_intr_gate
c_func
(paren
id|INVALIDATE_TLB_VECTOR
comma
id|invalidate_interrupt
)paren
suffix:semicolon
multiline_comment|/* IPI for generic function call */
id|set_intr_gate
c_func
(paren
id|CALL_FUNCTION_VECTOR
comma
id|call_function_interrupt
)paren
suffix:semicolon
)brace
eof
