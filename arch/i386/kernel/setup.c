multiline_comment|/*&n; *  linux/arch/i386/kernel/setup.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *&n; *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999&n; *&n; *  Memory region support&n; *&t;David Parsons &lt;orc@pell.chi.il.us&gt;, July-August 1999&n; *&n; *  Added E820 sanitization routine (removes overlapping memory regions);&n; *  Brian Moyle &lt;bmoyle@mvista.com&gt;, February 2001&n; *&n; * Moved CPU detection code to cpu/${cpu}.c&n; *    Patrick Mochel &lt;mochel@osdl.org&gt;, March 2002&n; *&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of initialization&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_RAM
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;asm/e820.h&gt;
macro_line|#include &lt;asm/mpspec.h&gt;
multiline_comment|/*&n; * Machine setup..&n; */
DECL|variable|ignore_irq13
r_char
id|ignore_irq13
suffix:semicolon
multiline_comment|/* set if exception 16 works */
DECL|variable|boot_cpu_data
r_struct
id|cpuinfo_x86
id|boot_cpu_data
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|mmu_cr4_features
r_int
r_int
id|mmu_cr4_features
suffix:semicolon
DECL|variable|MCA_bus
r_int
id|MCA_bus
suffix:semicolon
multiline_comment|/* for MCA, but anyone else can use it if they want */
DECL|variable|machine_id
r_int
r_int
id|machine_id
suffix:semicolon
DECL|variable|machine_submodel_id
r_int
r_int
id|machine_submodel_id
suffix:semicolon
DECL|variable|BIOS_revision
r_int
r_int
id|BIOS_revision
suffix:semicolon
DECL|variable|mca_pentium_flag
r_int
r_int
id|mca_pentium_flag
suffix:semicolon
multiline_comment|/* For PCI or other memory-mapped resources */
DECL|variable|pci_mem_start
r_int
r_int
id|pci_mem_start
op_assign
l_int|0x10000000
suffix:semicolon
multiline_comment|/* user-defined highmem size */
DECL|variable|highmem_pages
r_static
r_int
r_int
id|highmem_pages
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Setup options&n; */
DECL|struct|drive_info_struct
DECL|member|dummy
DECL|variable|drive_info
r_struct
id|drive_info_struct
(brace
r_char
id|dummy
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|drive_info
suffix:semicolon
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
suffix:semicolon
DECL|variable|apm_info
r_struct
id|apm_info
id|apm_info
suffix:semicolon
DECL|struct|sys_desc_table_struct
r_struct
id|sys_desc_table_struct
(brace
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
DECL|member|table
r_int
r_char
id|table
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|e820
r_struct
id|e820map
id|e820
suffix:semicolon
DECL|variable|aux_device_present
r_int
r_char
id|aux_device_present
suffix:semicolon
r_extern
r_void
id|early_cpu_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|dmi_scan_machine
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|root_mountflags
suffix:semicolon
r_extern
r_char
id|_text
comma
id|_etext
comma
id|_edata
comma
id|_end
suffix:semicolon
r_extern
r_int
id|blk_nohighio
suffix:semicolon
r_void
id|__init
id|visws_get_board_type_and_rev
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|saved_videomode
r_int
r_int
id|saved_videomode
suffix:semicolon
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; */
DECL|macro|PARAM
mdefine_line|#define PARAM&t;((unsigned char *)empty_zero_page)
DECL|macro|SCREEN_INFO
mdefine_line|#define SCREEN_INFO (*(struct screen_info *) (PARAM+0))
DECL|macro|EXT_MEM_K
mdefine_line|#define EXT_MEM_K (*(unsigned short *) (PARAM+2))
DECL|macro|ALT_MEM_K
mdefine_line|#define ALT_MEM_K (*(unsigned long *) (PARAM+0x1e0))
DECL|macro|E820_MAP_NR
mdefine_line|#define E820_MAP_NR (*(char*) (PARAM+E820NR))
DECL|macro|E820_MAP
mdefine_line|#define E820_MAP    ((struct e820entry *) (PARAM+E820MAP))
DECL|macro|APM_BIOS_INFO
mdefine_line|#define APM_BIOS_INFO (*(struct apm_bios_info *) (PARAM+0x40))
DECL|macro|DRIVE_INFO
mdefine_line|#define DRIVE_INFO (*(struct drive_info_struct *) (PARAM+0x80))
DECL|macro|SYS_DESC_TABLE
mdefine_line|#define SYS_DESC_TABLE (*(struct sys_desc_table_struct*)(PARAM+0xa0))
DECL|macro|MOUNT_ROOT_RDONLY
mdefine_line|#define MOUNT_ROOT_RDONLY (*(unsigned short *) (PARAM+0x1F2))
DECL|macro|RAMDISK_FLAGS
mdefine_line|#define RAMDISK_FLAGS (*(unsigned short *) (PARAM+0x1F8))
DECL|macro|VIDEO_MODE
mdefine_line|#define VIDEO_MODE (*(unsigned short *) (PARAM+0x1FA))
DECL|macro|ORIG_ROOT_DEV
mdefine_line|#define ORIG_ROOT_DEV (*(unsigned short *) (PARAM+0x1FC))
DECL|macro|AUX_DEVICE_INFO
mdefine_line|#define AUX_DEVICE_INFO (*(unsigned char *) (PARAM+0x1FF))
DECL|macro|LOADER_TYPE
mdefine_line|#define LOADER_TYPE (*(unsigned char *) (PARAM+0x210))
DECL|macro|KERNEL_START
mdefine_line|#define KERNEL_START (*(unsigned long *) (PARAM+0x214))
DECL|macro|INITRD_START
mdefine_line|#define INITRD_START (*(unsigned long *) (PARAM+0x218))
DECL|macro|INITRD_SIZE
mdefine_line|#define INITRD_SIZE (*(unsigned long *) (PARAM+0x21c))
DECL|macro|COMMAND_LINE
mdefine_line|#define COMMAND_LINE ((char *) (PARAM+2048))
DECL|macro|COMMAND_LINE_SIZE
mdefine_line|#define COMMAND_LINE_SIZE 256
DECL|macro|RAMDISK_IMAGE_START_MASK
mdefine_line|#define RAMDISK_IMAGE_START_MASK  &t;0x07FF
DECL|macro|RAMDISK_PROMPT_FLAG
mdefine_line|#define RAMDISK_PROMPT_FLAG&t;&t;0x8000
DECL|macro|RAMDISK_LOAD_FLAG
mdefine_line|#define RAMDISK_LOAD_FLAG&t;&t;0x4000&t;
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|saved_command_line
r_char
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|standard_io_resources
r_struct
id|resource
id|standard_io_resources
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;dma1&quot;
comma
l_int|0x00
comma
l_int|0x1f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;pic1&quot;
comma
l_int|0x20
comma
l_int|0x3f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;timer&quot;
comma
l_int|0x40
comma
l_int|0x5f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;keyboard&quot;
comma
l_int|0x60
comma
l_int|0x6f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;dma page reg&quot;
comma
l_int|0x80
comma
l_int|0x8f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;pic2&quot;
comma
l_int|0xa0
comma
l_int|0xbf
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;dma2&quot;
comma
l_int|0xc0
comma
l_int|0xdf
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;fpu&quot;
comma
l_int|0xf0
comma
l_int|0xff
comma
id|IORESOURCE_BUSY
)brace
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_MELAN
id|standard_io_resources
(braket
l_int|1
)braket
op_assign
(brace
l_string|&quot;pic1&quot;
comma
l_int|0x20
comma
l_int|0x21
comma
id|IORESOURCE_BUSY
)brace
suffix:semicolon
id|standard_io_resources
(braket
l_int|5
)braket
op_assign
(brace
l_string|&quot;pic2&quot;
comma
l_int|0xa0
comma
l_int|0xa1
comma
id|IORESOURCE_BUSY
)brace
suffix:semicolon
macro_line|#endif
DECL|macro|STANDARD_IO_RESOURCES
mdefine_line|#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
DECL|variable|code_resource
r_static
r_struct
id|resource
id|code_resource
op_assign
(brace
l_string|&quot;Kernel code&quot;
comma
l_int|0x100000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|data_resource
r_static
r_struct
id|resource
id|data_resource
op_assign
(brace
l_string|&quot;Kernel data&quot;
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|vram_resource
r_static
r_struct
id|resource
id|vram_resource
op_assign
(brace
l_string|&quot;Video RAM area&quot;
comma
l_int|0xa0000
comma
l_int|0xbffff
comma
id|IORESOURCE_BUSY
)brace
suffix:semicolon
multiline_comment|/* System ROM resources */
DECL|macro|MAXROMS
mdefine_line|#define MAXROMS 6
DECL|variable|rom_resources
r_static
r_struct
id|resource
id|rom_resources
(braket
id|MAXROMS
)braket
op_assign
(brace
(brace
l_string|&quot;System ROM&quot;
comma
l_int|0xF0000
comma
l_int|0xFFFFF
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;Video ROM&quot;
comma
l_int|0xc0000
comma
l_int|0xc7fff
comma
id|IORESOURCE_BUSY
)brace
)brace
suffix:semicolon
DECL|macro|romsignature
mdefine_line|#define romsignature(x) (*(unsigned short *)(x) == 0xaa55)
DECL|function|probe_roms
r_static
r_void
id|__init
id|probe_roms
c_func
(paren
r_void
)paren
(brace
r_int
id|roms
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_char
op_star
id|romstart
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Video ROM is standard at C000:0000 - C7FF:0000, check signature */
r_for
c_loop
(paren
id|base
op_assign
l_int|0xC0000
suffix:semicolon
id|base
OL
l_int|0xE0000
suffix:semicolon
id|base
op_add_assign
l_int|2048
)paren
(brace
id|romstart
op_assign
id|isa_bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
r_continue
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
id|roms
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Extension roms at C800:0000 - DFFF:0000 */
r_for
c_loop
(paren
id|base
op_assign
l_int|0xC8000
suffix:semicolon
id|base
OL
l_int|0xE0000
suffix:semicolon
id|base
op_add_assign
l_int|2048
)paren
(brace
r_int
r_int
id|length
suffix:semicolon
id|romstart
op_assign
id|isa_bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|romstart
(braket
l_int|2
)braket
op_star
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|length
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|chksum
suffix:semicolon
id|chksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
id|chksum
op_add_assign
id|romstart
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Good checksum? */
r_if
c_cond
(paren
op_logical_neg
id|chksum
)paren
(brace
id|rom_resources
(braket
id|roms
)braket
dot
id|start
op_assign
id|base
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|end
op_assign
id|base
op_plus
id|length
op_minus
l_int|1
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|name
op_assign
l_string|&quot;Extension ROM&quot;
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|flags
op_assign
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
id|roms
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|roms
op_ge
id|MAXROMS
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Final check for motherboard extension rom at E000:0000 */
id|base
op_assign
l_int|0xE0000
suffix:semicolon
id|romstart
op_assign
id|isa_bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
(brace
id|rom_resources
(braket
id|roms
)braket
dot
id|start
op_assign
id|base
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|end
op_assign
id|base
op_plus
l_int|65535
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|name
op_assign
l_string|&quot;Extension ROM&quot;
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|flags
op_assign
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
)brace
)brace
DECL|function|limit_regions
r_static
r_void
id|__init
id|limit_regions
(paren
r_int
r_int
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
r_int
id|current_size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_eq
id|E820_RAM
)paren
(brace
id|current_size
op_add_assign
id|e820.map
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|current_size
op_ge
id|size
)paren
(brace
id|e820.map
(braket
id|i
)braket
dot
id|size
op_sub_assign
id|current_size
op_minus
id|size
suffix:semicolon
id|e820.nr_map
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|add_memory_region
r_static
r_void
id|__init
id|add_memory_region
c_func
(paren
r_int
r_int
r_int
id|start
comma
r_int
r_int
r_int
id|size
comma
r_int
id|type
)paren
(brace
r_int
id|x
op_assign
id|e820.nr_map
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|E820MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Ooops! Too many entries in the memory map!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|e820.map
(braket
id|x
)braket
dot
id|addr
op_assign
id|start
suffix:semicolon
id|e820.map
(braket
id|x
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|e820.map
(braket
id|x
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|e820.nr_map
op_increment
suffix:semicolon
)brace
multiline_comment|/* add_memory_region */
DECL|macro|E820_DEBUG
mdefine_line|#define E820_DEBUG&t;1
DECL|function|print_memory_map
r_static
r_void
id|__init
id|print_memory_map
c_func
(paren
r_char
op_star
id|who
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %s: %016Lx - %016Lx &quot;
comma
id|who
comma
id|e820.map
(braket
id|i
)braket
dot
id|addr
comma
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|E820_RAM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(usable)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_RESERVED
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(reserved)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_ACPI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(ACPI data)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_NVS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(ACPI NVS)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;type %lu&bslash;n&quot;
comma
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Sanitize the BIOS e820 map.&n; *&n; * Some e820 responses include overlapping entries.  The following &n; * replaces the original e820 map with a new one, removing overlaps.&n; *&n; */
DECL|function|sanitize_e820_map
r_static
r_int
id|__init
id|sanitize_e820_map
c_func
(paren
r_struct
id|e820entry
op_star
id|biosmap
comma
r_char
op_star
id|pnr_map
)paren
(brace
r_struct
id|change_member
(brace
r_struct
id|e820entry
op_star
id|pbios
suffix:semicolon
multiline_comment|/* pointer to original bios entry */
r_int
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* address for this change point */
)brace
suffix:semicolon
r_struct
id|change_member
id|change_point_list
(braket
l_int|2
op_star
id|E820MAX
)braket
suffix:semicolon
r_struct
id|change_member
op_star
id|change_point
(braket
l_int|2
op_star
id|E820MAX
)braket
suffix:semicolon
r_struct
id|e820entry
op_star
id|overlap_list
(braket
id|E820MAX
)braket
suffix:semicolon
r_struct
id|e820entry
id|new_bios
(braket
id|E820MAX
)braket
suffix:semicolon
r_struct
id|change_member
op_star
id|change_tmp
suffix:semicolon
r_int
r_int
id|current_type
comma
id|last_type
suffix:semicolon
r_int
r_int
r_int
id|last_addr
suffix:semicolon
r_int
id|chgidx
comma
id|still_changing
suffix:semicolon
r_int
id|overlap_entries
suffix:semicolon
r_int
id|new_bios_entry
suffix:semicolon
r_int
id|old_nr
comma
id|new_nr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;Visually we&squot;re performing the following (1,2,3,4 = memory types)...&n;&n;&t;&t;Sample memory map (w/overlaps):&n;&t;&t;   ____22__________________&n;&t;&t;   ______________________4_&n;&t;&t;   ____1111________________&n;&t;&t;   _44_____________________&n;&t;&t;   11111111________________&n;&t;&t;   ____________________33__&n;&t;&t;   ___________44___________&n;&t;&t;   __________33333_________&n;&t;&t;   ______________22________&n;&t;&t;   ___________________2222_&n;&t;&t;   _________111111111______&n;&t;&t;   _____________________11_&n;&t;&t;   _________________4______&n;&n;&t;&t;Sanitized equivalent (no overlap):&n;&t;&t;   1_______________________&n;&t;&t;   _44_____________________&n;&t;&t;   ___1____________________&n;&t;&t;   ____22__________________&n;&t;&t;   ______11________________&n;&t;&t;   _________1______________&n;&t;&t;   __________3_____________&n;&t;&t;   ___________44___________&n;&t;&t;   _____________33_________&n;&t;&t;   _______________2________&n;&t;&t;   ________________1_______&n;&t;&t;   _________________4______&n;&t;&t;   ___________________2____&n;&t;&t;   ____________________33__&n;&t;&t;   ______________________4_&n;&t;*/
multiline_comment|/* if there&squot;s only one memory region, don&squot;t bother */
r_if
c_cond
(paren
op_star
id|pnr_map
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|old_nr
op_assign
op_star
id|pnr_map
suffix:semicolon
multiline_comment|/* bail out if we find any unreasonable addresses in bios map */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|biosmap
(braket
id|i
)braket
dot
id|addr
op_plus
id|biosmap
(braket
id|i
)braket
dot
id|size
OL
id|biosmap
(braket
id|i
)braket
dot
id|addr
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* create pointers for initial change-point information (for sorting) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
op_star
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
id|change_point
(braket
id|i
)braket
op_assign
op_amp
id|change_point_list
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* record all known change-points (starting and ending addresses) */
id|chgidx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
op_assign
id|biosmap
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|change_point
(braket
id|chgidx
op_increment
)braket
op_member_access_from_pointer
id|pbios
op_assign
op_amp
id|biosmap
(braket
id|i
)braket
suffix:semicolon
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
op_assign
id|biosmap
(braket
id|i
)braket
dot
id|addr
op_plus
id|biosmap
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|change_point
(braket
id|chgidx
op_increment
)braket
op_member_access_from_pointer
id|pbios
op_assign
op_amp
id|biosmap
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* sort change-point list by memory addresses (low -&gt; high) */
id|still_changing
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|still_changing
)paren
(brace
id|still_changing
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|2
op_star
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* if &lt;current_addr&gt; &gt; &lt;last_addr&gt;, swap */
multiline_comment|/* or, if current=&lt;start_addr&gt; &amp; last=&lt;end_addr&gt;, swap */
r_if
c_cond
(paren
(paren
id|change_point
(braket
id|i
)braket
op_member_access_from_pointer
id|addr
OL
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|addr
)paren
op_logical_or
(paren
(paren
id|change_point
(braket
id|i
)braket
op_member_access_from_pointer
id|addr
op_eq
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|addr
)paren
op_logical_and
(paren
id|change_point
(braket
id|i
)braket
op_member_access_from_pointer
id|addr
op_eq
id|change_point
(braket
id|i
)braket
op_member_access_from_pointer
id|pbios-&gt;addr
)paren
op_logical_and
(paren
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|addr
op_ne
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|pbios-&gt;addr
)paren
)paren
)paren
(brace
id|change_tmp
op_assign
id|change_point
(braket
id|i
)braket
suffix:semicolon
id|change_point
(braket
id|i
)braket
op_assign
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|change_point
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|change_tmp
suffix:semicolon
id|still_changing
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* create a new bios memory map, removing overlaps */
id|overlap_entries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of entries in the overlap table */
id|new_bios_entry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index for creating new bios map entries */
id|last_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start with undefined memory type */
id|last_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start with 0 as last starting address */
multiline_comment|/* loop through change-points, determining affect on the new bios map */
r_for
c_loop
(paren
id|chgidx
op_assign
l_int|0
suffix:semicolon
id|chgidx
OL
l_int|2
op_star
id|old_nr
suffix:semicolon
id|chgidx
op_increment
)paren
(brace
multiline_comment|/* keep track of all overlapping bios entries */
r_if
c_cond
(paren
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
op_eq
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|pbios-&gt;addr
)paren
(brace
multiline_comment|/* add map entry to overlap list (&gt; 1 entry implies an overlap) */
id|overlap_list
(braket
id|overlap_entries
op_increment
)braket
op_assign
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|pbios
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* remove entry from list (order independent, so swap with last) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|overlap_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|overlap_list
(braket
id|i
)braket
op_eq
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|pbios
)paren
id|overlap_list
(braket
id|i
)braket
op_assign
id|overlap_list
(braket
id|overlap_entries
op_minus
l_int|1
)braket
suffix:semicolon
)brace
id|overlap_entries
op_decrement
suffix:semicolon
)brace
multiline_comment|/* if there are overlapping entries, decide which &quot;type&quot; to use */
multiline_comment|/* (larger value takes precedence -- 1=usable, 2,3,4,4+=unusable) */
id|current_type
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|overlap_entries
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|overlap_list
(braket
id|i
)braket
op_member_access_from_pointer
id|type
OG
id|current_type
)paren
id|current_type
op_assign
id|overlap_list
(braket
id|i
)braket
op_member_access_from_pointer
id|type
suffix:semicolon
multiline_comment|/* continue building up new bios map based on this information */
r_if
c_cond
(paren
id|current_type
op_ne
id|last_type
)paren
(brace
r_if
c_cond
(paren
id|last_type
op_ne
l_int|0
)paren
(brace
id|new_bios
(braket
id|new_bios_entry
)braket
dot
id|size
op_assign
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
op_minus
id|last_addr
suffix:semicolon
multiline_comment|/* move forward only if the new size was non-zero */
r_if
c_cond
(paren
id|new_bios
(braket
id|new_bios_entry
)braket
dot
id|size
op_ne
l_int|0
)paren
r_if
c_cond
(paren
op_increment
id|new_bios_entry
op_ge
id|E820MAX
)paren
r_break
suffix:semicolon
multiline_comment|/* no more space left for new bios entries */
)brace
r_if
c_cond
(paren
id|current_type
op_ne
l_int|0
)paren
(brace
id|new_bios
(braket
id|new_bios_entry
)braket
dot
id|addr
op_assign
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
suffix:semicolon
id|new_bios
(braket
id|new_bios_entry
)braket
dot
id|type
op_assign
id|current_type
suffix:semicolon
id|last_addr
op_assign
id|change_point
(braket
id|chgidx
)braket
op_member_access_from_pointer
id|addr
suffix:semicolon
)brace
id|last_type
op_assign
id|current_type
suffix:semicolon
)brace
)brace
id|new_nr
op_assign
id|new_bios_entry
suffix:semicolon
multiline_comment|/* retain count for new bios entries */
multiline_comment|/* copy new bios mapping into original location */
id|memcpy
c_func
(paren
id|biosmap
comma
id|new_bios
comma
id|new_nr
op_star
r_sizeof
(paren
r_struct
id|e820entry
)paren
)paren
suffix:semicolon
op_star
id|pnr_map
op_assign
id|new_nr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the BIOS e820 map into a safe place.&n; *&n; * Sanity-check it while we&squot;re at it..&n; *&n; * If we&squot;re lucky and live on a modern system, the setup code&n; * will have given us a memory map that we can use to properly&n; * set up memory.  If we aren&squot;t, we&squot;ll fake a memory map.&n; *&n; * We check to see that the memory map contains at least 2 elements&n; * before we&squot;ll use it, because the detection code in setup.S may&n; * not be perfect and most every PC known to man has two memory&n; * regions: one from 0 to 640k, and one from 1mb up.  (The IBM&n; * thinkpad 560x, for example, does not cooperate with the memory&n; * detection code.)&n; */
DECL|function|copy_e820_map
r_static
r_int
id|__init
id|copy_e820_map
c_func
(paren
r_struct
id|e820entry
op_star
id|biosmap
comma
r_int
id|nr_map
)paren
(brace
multiline_comment|/* Only one memory region (or negative)? Ignore it */
r_if
c_cond
(paren
id|nr_map
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_int
r_int
r_int
id|start
op_assign
id|biosmap-&gt;addr
suffix:semicolon
r_int
r_int
r_int
id|size
op_assign
id|biosmap-&gt;size
suffix:semicolon
r_int
r_int
r_int
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_int
r_int
id|type
op_assign
id|biosmap-&gt;type
suffix:semicolon
multiline_comment|/* Overflow in 64 bits? Ignore the memory map. */
r_if
c_cond
(paren
id|start
OG
id|end
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some BIOSes claim RAM in the 640k - 1M region.&n;&t;&t; * Not right. Fix it up.&n;&t;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|E820_RAM
)paren
(brace
r_if
c_cond
(paren
id|start
template_param
l_int|0xA0000ULL
)paren
(brace
r_if
c_cond
(paren
id|start
OL
l_int|0xA0000ULL
)paren
id|add_memory_region
c_func
(paren
id|start
comma
l_int|0xA0000ULL
op_minus
id|start
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_le
l_int|0x100000ULL
)paren
r_continue
suffix:semicolon
id|start
op_assign
l_int|0x100000ULL
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
)brace
)brace
id|add_memory_region
c_func
(paren
id|start
comma
id|size
comma
id|type
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|biosmap
op_increment
comma
op_decrement
id|nr_map
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Do NOT EVER look at the BIOS memory size location.&n; * It does not work on many machines.&n; */
DECL|macro|LOWMEMSIZE
mdefine_line|#define LOWMEMSIZE()&t;(0x9f000)
DECL|function|setup_memory_region
r_static
r_void
id|__init
id|setup_memory_region
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|who
op_assign
l_string|&quot;BIOS-e820&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Try to copy the BIOS-supplied E820-map.&n;&t; *&n;&t; * Otherwise fake a memory map; one section from 0k-&gt;640k,&n;&t; * the next section from 1mb-&gt;appropriate_mem_k&n;&t; */
id|sanitize_e820_map
c_func
(paren
id|E820_MAP
comma
op_amp
id|E820_MAP_NR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_e820_map
c_func
(paren
id|E820_MAP
comma
id|E820_MAP_NR
)paren
OL
l_int|0
)paren
(brace
r_int
r_int
id|mem_size
suffix:semicolon
multiline_comment|/* compare results from other methods and take the greater */
r_if
c_cond
(paren
id|ALT_MEM_K
OL
id|EXT_MEM_K
)paren
(brace
id|mem_size
op_assign
id|EXT_MEM_K
suffix:semicolon
id|who
op_assign
l_string|&quot;BIOS-88&quot;
suffix:semicolon
)brace
r_else
(brace
id|mem_size
op_assign
id|ALT_MEM_K
suffix:semicolon
id|who
op_assign
l_string|&quot;BIOS-e801&quot;
suffix:semicolon
)brace
id|e820.nr_map
op_assign
l_int|0
suffix:semicolon
id|add_memory_region
c_func
(paren
l_int|0
comma
id|LOWMEMSIZE
c_func
(paren
)paren
comma
id|E820_RAM
)paren
suffix:semicolon
id|add_memory_region
c_func
(paren
id|HIGH_MEMORY
comma
id|mem_size
op_lshift
l_int|10
comma
id|E820_RAM
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;BIOS-provided physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
id|who
)paren
suffix:semicolon
)brace
multiline_comment|/* setup_memory_region */
DECL|function|parse_mem_cmdline
r_static
r_void
id|__init
id|parse_mem_cmdline
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|COMMAND_LINE
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|userdef
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|memcpy
c_func
(paren
id|saved_command_line
comma
id|COMMAND_LINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;mem=nopentium&quot; disables the 4MB page tables.&n;&t;&t; * &quot;mem=XXX[kKmM]&quot; defines a memory region from HIGH_MEM&n;&t;&t; * to &lt;mem&gt;, overriding the bios size.&n;&t;&t; * &quot;mem=XXX[KkmM]@XXX[KkmM]&quot; defines a memory region from&n;&t;&t; * &lt;start&gt; to &lt;start&gt;+&lt;mem&gt;, overriding the bios size.&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|from
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|from
op_plus
l_int|4
comma
l_string|&quot;nopentium&quot;
comma
l_int|9
)paren
)paren
(brace
id|from
op_add_assign
l_int|9
op_plus
l_int|4
suffix:semicolon
id|clear_bit
c_func
(paren
id|X86_FEATURE_PSE
comma
id|boot_cpu_data.x86_capability
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|from
op_plus
l_int|4
comma
l_string|&quot;exactmap&quot;
comma
l_int|8
)paren
)paren
(brace
id|from
op_add_assign
l_int|8
op_plus
l_int|4
suffix:semicolon
id|e820.nr_map
op_assign
l_int|0
suffix:semicolon
id|userdef
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the user specifies memory size, we&n;&t;&t;&t;&t; * limit the BIOS-provided memory map to&n;&t;&t;&t;&t; * that size. exactmap can be used to specify&n;&t;&t;&t;&t; * the exact map. mem=number can be used to&n;&t;&t;&t;&t; * trim the existing memory map.&n;&t;&t;&t;&t; */
r_int
r_int
r_int
id|start_at
comma
id|mem_size
suffix:semicolon
id|mem_size
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;@&squot;
)paren
(brace
id|start_at
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|1
comma
op_amp
id|from
)paren
suffix:semicolon
id|add_memory_region
c_func
(paren
id|start_at
comma
id|mem_size
comma
id|E820_RAM
)paren
suffix:semicolon
)brace
r_else
(brace
id|limit_regions
c_func
(paren
id|mem_size
)paren
suffix:semicolon
id|userdef
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * highmem=size forces highmem to be exactly &squot;size&squot; bytes.&n;&t;&t; * This works even on boxes that have no highmem otherwise.&n;&t;&t; * This also works to reduce highmem size on bigger boxes.&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|from
comma
l_string|&quot;highmem=&quot;
comma
l_int|8
)paren
)paren
id|highmem_pages
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|8
comma
op_amp
id|from
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND_LINE_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
r_if
c_cond
(paren
id|userdef
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;user-defined physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
l_string|&quot;user&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_int
r_int
id|bootmap_size
comma
id|low_mem_size
suffix:semicolon
r_int
r_int
id|start_pfn
comma
id|max_low_pfn
suffix:semicolon
r_int
id|i
suffix:semicolon
id|early_cpu_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VISWS
id|visws_get_board_type_and_rev
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|ROOT_DEV
op_assign
id|to_kdev_t
c_func
(paren
id|ORIG_ROOT_DEV
)paren
suffix:semicolon
id|drive_info
op_assign
id|DRIVE_INFO
suffix:semicolon
id|screen_info
op_assign
id|SCREEN_INFO
suffix:semicolon
id|apm_info.bios
op_assign
id|APM_BIOS_INFO
suffix:semicolon
id|saved_videomode
op_assign
id|VIDEO_MODE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Video mode to be used for restore is %lx&bslash;n&quot;
comma
id|saved_videomode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SYS_DESC_TABLE.length
op_ne
l_int|0
)paren
(brace
id|MCA_bus
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|3
)braket
op_amp
l_int|0x2
suffix:semicolon
id|machine_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|0
)braket
suffix:semicolon
id|machine_submodel_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|1
)braket
suffix:semicolon
id|BIOS_revision
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|aux_device_present
op_assign
id|AUX_DEVICE_INFO
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_image_start
op_assign
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_IMAGE_START_MASK
suffix:semicolon
id|rd_prompt
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_PROMPT_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|rd_doload
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_LOAD_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|setup_memory_region
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOUNT_ROOT_RDONLY
)paren
id|root_mountflags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|init_mm.start_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_text
suffix:semicolon
id|init_mm.end_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
suffix:semicolon
id|init_mm.end_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_edata
suffix:semicolon
id|init_mm.brk
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
id|code_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_etext
)paren
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_etext
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_edata
)paren
op_minus
l_int|1
suffix:semicolon
id|parse_mem_cmdline
c_func
(paren
id|cmdline_p
)paren
suffix:semicolon
DECL|macro|PFN_UP
mdefine_line|#define PFN_UP(x)&t;(((x) + PAGE_SIZE-1) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_DOWN
mdefine_line|#define PFN_DOWN(x)&t;((x) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_PHYS
mdefine_line|#define PFN_PHYS(x)&t;((x) &lt;&lt; PAGE_SHIFT)
multiline_comment|/*&n; * Reserved space for vmalloc and iomap - defined in asm/page.h&n; */
DECL|macro|MAXMEM_PFN
mdefine_line|#define MAXMEM_PFN&t;PFN_DOWN(MAXMEM)
DECL|macro|MAX_NONPAE_PFN
mdefine_line|#define MAX_NONPAE_PFN&t;(1 &lt;&lt; 20)
multiline_comment|/*&n;&t; * partially used pages are not usable - thus&n;&t; * we are rounding upwards:&n;&t; */
id|start_pfn
op_assign
id|PFN_UP
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|_end
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the highest page frame number we have available&n;&t; */
id|max_pfn
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
suffix:semicolon
multiline_comment|/* RAM? */
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_ne
id|E820_RAM
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|PFN_UP
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|end
op_assign
id|PFN_DOWN
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|max_pfn
)paren
id|max_pfn
op_assign
id|end
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine low and high memory ranges:&n;&t; */
id|max_low_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_low_pfn
OG
id|MAXMEM_PFN
)paren
(brace
r_if
c_cond
(paren
id|highmem_pages
op_eq
op_minus
l_int|1
)paren
id|highmem_pages
op_assign
id|max_pfn
op_minus
id|MAXMEM_PFN
suffix:semicolon
r_if
c_cond
(paren
id|highmem_pages
op_plus
id|MAXMEM_PFN
OL
id|max_pfn
)paren
id|max_pfn
op_assign
id|MAXMEM_PFN
op_plus
id|highmem_pages
suffix:semicolon
r_if
c_cond
(paren
id|highmem_pages
op_plus
id|MAXMEM_PFN
OG
id|max_pfn
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;only %luMB highmem pages available, ignoring highmem size of %uMB.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|max_pfn
op_minus
id|MAXMEM_PFN
)paren
comma
id|pages_to_mb
c_func
(paren
id|highmem_pages
)paren
)paren
suffix:semicolon
id|highmem_pages
op_assign
l_int|0
suffix:semicolon
)brace
id|max_low_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
macro_line|#ifndef CONFIG_HIGHMEM
multiline_comment|/* Maximum memory usable is what is directly addressable */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning only %ldMB will be used.&bslash;n&quot;
comma
id|MAXMEM
op_rshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_pfn
OG
id|MAX_NONPAE_PFN
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a PAE enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a HIGHMEM enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
id|max_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
macro_line|#else /* !CONFIG_HIGHMEM */
macro_line|#ifndef CONFIG_X86_PAE
r_if
c_cond
(paren
id|max_pfn
OG
id|MAX_NONPAE_PFN
)paren
(brace
id|max_pfn
op_assign
id|MAX_NONPAE_PFN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning only 4GB will be used.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a PAE enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_X86_PAE */
macro_line|#endif /* !CONFIG_HIGHMEM */
)brace
r_else
(brace
r_if
c_cond
(paren
id|highmem_pages
op_eq
op_minus
l_int|1
)paren
id|highmem_pages
op_assign
l_int|0
suffix:semicolon
macro_line|#if CONFIG_HIGHMEM
r_if
c_cond
(paren
id|highmem_pages
op_ge
id|max_pfn
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;highmem size specified (%uMB) is bigger than pages available (%luMB)!.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|highmem_pages
)paren
comma
id|pages_to_mb
c_func
(paren
id|max_pfn
)paren
)paren
suffix:semicolon
id|highmem_pages
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|highmem_pages
)paren
(brace
r_if
c_cond
(paren
id|max_low_pfn
op_minus
id|highmem_pages
OL
l_int|64
op_star
l_int|1024
op_star
l_int|1024
op_div
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;highmem size %uMB results in smaller than 64MB lowmem, ignoring it.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|highmem_pages
)paren
)paren
suffix:semicolon
id|highmem_pages
op_assign
l_int|0
suffix:semicolon
)brace
id|max_low_pfn
op_sub_assign
id|highmem_pages
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|highmem_pages
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ignoring highmem size on non-highmem kernel!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_HIGHMEM
id|highstart_pfn
op_assign
id|highend_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_pfn
OG
id|max_low_pfn
)paren
(brace
id|highstart_pfn
op_assign
id|max_low_pfn
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%ldMB HIGHMEM available.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|highend_pfn
op_minus
id|highstart_pfn
)paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%ldMB LOWMEM available.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|max_low_pfn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the boot-time allocator (with low memory only):&n;&t; */
id|bootmap_size
op_assign
id|init_bootmem
c_func
(paren
id|start_pfn
comma
id|max_low_pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register fully available low RAM pages with the bootmem allocator.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|curr_pfn
comma
id|last_pfn
comma
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reserve usable low memory&n;&t;&t; */
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_ne
id|E820_RAM
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are rounding up the start address of usable memory:&n;&t;&t; */
id|curr_pfn
op_assign
id|PFN_UP
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
op_ge
id|max_low_pfn
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ... and at the end of the usable range downwards:&n;&t;&t; */
id|last_pfn
op_assign
id|PFN_DOWN
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_pfn
OG
id|max_low_pfn
)paren
id|last_pfn
op_assign
id|max_low_pfn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * .. finally, did all the rounding and playing&n;&t;&t; * around just make the area go away?&n;&t;&t; */
r_if
c_cond
(paren
id|last_pfn
op_le
id|curr_pfn
)paren
r_continue
suffix:semicolon
id|size
op_assign
id|last_pfn
op_minus
id|curr_pfn
suffix:semicolon
id|free_bootmem
c_func
(paren
id|PFN_PHYS
c_func
(paren
id|curr_pfn
)paren
comma
id|PFN_PHYS
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve the bootmem bitmap itself as well. We do this in two&n;&t; * steps (first step was init_bootmem()) because this catches&n;&t; * the (very unlikely) case of us accidentally initializing the&n;&t; * bootmem allocator with an invalid RAM area.&n;&t; */
id|reserve_bootmem
c_func
(paren
id|HIGH_MEMORY
comma
(paren
id|PFN_PHYS
c_func
(paren
id|start_pfn
)paren
op_plus
id|bootmap_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_minus
(paren
id|HIGH_MEMORY
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reserve physical page 0 - it&squot;s a special BIOS page on many boxes,&n;&t; * enabling clean reboots, SMP operation, laptop functions.&n;&t; */
id|reserve_bootmem
c_func
(paren
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * But first pinch a few for the stack/trampoline stuff&n;&t; * FIXME: Don&squot;t need the extra page at 4K, but need to fix&n;&t; * trampoline before removing it. (see the GDT stuff)&n;&t; */
id|reserve_bootmem
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ACPI_SLEEP
multiline_comment|/*&n;&t; * Reserve low memory region for sleep support.&n;&t; */
id|acpi_reserve_bootmem
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
multiline_comment|/*&n;&t; * Find and reserve possible boot-time SMP configuration:&n;&t; */
id|find_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|LOADER_TYPE
op_logical_and
id|INITRD_START
)paren
(brace
r_if
c_cond
(paren
id|INITRD_START
op_plus
id|INITRD_SIZE
op_le
(paren
id|max_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
)paren
(brace
id|reserve_bootmem
c_func
(paren
id|INITRD_START
comma
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_start
op_assign
id|INITRD_START
ques
c_cond
id|INITRD_START
op_plus
id|PAGE_OFFSET
suffix:colon
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%08lx &gt; 0x%08lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
id|INITRD_START
op_plus
id|INITRD_SIZE
comma
id|max_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * NOTE: before this point _nobody_ is allowed to allocate&n;&t; * any memory using the bootmem allocator.&n;&t; */
macro_line|#ifdef CONFIG_SMP
id|smp_alloc_memory
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* AP processor realmode stacks in low memory*/
macro_line|#endif
id|paging_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI_BOOT
multiline_comment|/*&n;&t; * Parse the ACPI tables for possible boot-time SMP configuration.&n;&t; */
id|acpi_boot_init
c_func
(paren
op_star
id|cmdline_p
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
r_if
c_cond
(paren
id|smp_found_config
)paren
id|get_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Request address space for all standard RAM and ROM resources&n;&t; * and also for regions reported as reserved by the e820.&n;&t; */
id|probe_roms
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
OG
l_int|0x100000000ULL
)paren
r_continue
suffix:semicolon
id|res
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|E820_RAM
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;System RAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_ACPI
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI Tables&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_NVS
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI Non-volatile Storage&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;reserved&quot;
suffix:semicolon
)brace
id|res-&gt;start
op_assign
id|e820.map
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
op_minus
l_int|1
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_eq
id|E820_RAM
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We dont&squot;t know which RAM region contains kernel data,&n;&t;&t;&t; *  so we try it repeatedly and let the resource manager&n;&t;&t;&t; *  test it.&n;&t;&t;&t; */
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|data_resource
)paren
suffix:semicolon
)brace
)brace
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|vram_resource
)paren
suffix:semicolon
multiline_comment|/* request I/O space for devices used on all i[345]86 PCs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_IO_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
id|standard_io_resources
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Tell the PCI layer not to allocate too close to the RAM area.. */
id|low_mem_size
op_assign
(paren
(paren
id|max_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
op_plus
l_int|0xfffff
)paren
op_amp
op_complement
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|low_mem_size
OG
id|pci_mem_start
)paren
id|pci_mem_start
op_assign
id|low_mem_size
suffix:semicolon
macro_line|#ifdef CONFIG_VT
macro_line|#if defined(CONFIG_VGA_CONSOLE)
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|dmi_scan_machine
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|highio_setup
r_static
r_int
id|__init
id|highio_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;i386: disabling HIGHMEM block I/O&bslash;n&quot;
)paren
suffix:semicolon
id|blk_nohighio
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nohighio&quot;
comma
id|highio_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * Local Variables:&n; * mode:c&n; * c-file-style:&quot;k&amp;r&quot;&n; * c-basic-offset:8&n; * End:&n; */
eof
