multiline_comment|/*&n; * i386 semaphore implementation.&n; *&n; * (C) Copyright 1999 Linus Torvalds&n; *&n; * Portions Copyright 1999 Red Hat, Inc.&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; * rw semaphores implemented November 1999 by Benjamin LaHaise &lt;bcrl@redhat.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter:&n; * The &quot;count&quot; variable is decremented for each process&n; * that tries to acquire the semaphore, while the &quot;sleeping&quot;&n; * variable is a count of such acquires.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can&n; * efficiently test if they need to do any extra work (up&n; * needs to do something only if count was negative before&n; * the increment operation.&n; *&n; * &quot;sleeping&quot; and the contention routine ordering is&n; * protected by the semaphore spinlock.&n; *&n; * Note that these functions are only called when there is&n; * contention on the lock, and as such all this is the&n; * &quot;non-critical&quot; part of the whole semaphore business. The&n; * critical part is the inline stuff in &lt;asm/semaphore.h&gt;&n; * where we want to avoid any extra jumps and calls.&n; */
multiline_comment|/*&n; * Logic:&n; *  - only on a boundary condition do we need to care. When we go&n; *    from a negative count to a non-negative, we wake people up.&n; *  - when we go from a non-negative count to a negative do we&n; *    (a) synchronize with the &quot;sleeper&quot; count and (b) make sure&n; *    that we&squot;re on the wakeup list before we synchronize so that&n; *    we cannot lose wakeup events.&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|semaphore_lock
r_static
id|spinlock_t
id|semaphore_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * With signals pending, this turns into&n;&t;&t; * the trylock failure case - we won&squot;t be&n;&t;&t; * sleeping, and we* can&squot;t get the lock as&n;&t;&t; * it has contention. Just correct the count&n;&t;&t; * and exit.&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
id|atomic_add
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock. The&n;&t;&t; * &quot;-1&quot; is because we&squot;re still hoping to get&n;&t;&t; * the lock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Trylock failed - make sure we correct for&n; * having decremented the count.&n; *&n; * We could have done the trylock with a&n; * single &quot;cmpxchg&quot; without failure cases,&n; * but then it wouldn&squot;t work on a 386.&n; */
DECL|function|__down_trylock
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|sleepers
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|sleepers
op_assign
id|sem-&gt;sleepers
op_plus
l_int|1
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Add &quot;everybody else&quot; and us into it. They aren&squot;t&n;&t; * playing, because we own the spinlock.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The semaphore operations have a special calling sequence that&n; * allow us to do a simpler in-line version of them. These routines&n; * need to convert that sequence back into the C sequence when&n; * there is contention on the semaphore.&n; *&n; * %ecx contains the semaphore pointer on entry. Save the C-clobbered&n; * registers (%eax, %edx and %ecx) except %eax when used as a return&n; * value..&n; */
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
l_string|&quot;.align 4&bslash;n&quot;
l_string|&quot;.globl __down_failed&bslash;n&quot;
l_string|&quot;__down_failed:&bslash;n&bslash;t&quot;
l_string|&quot;pushl %eax&bslash;n&bslash;t&quot;
l_string|&quot;pushl %edx&bslash;n&bslash;t&quot;
l_string|&quot;pushl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;call __down&bslash;n&bslash;t&quot;
l_string|&quot;popl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;popl %edx&bslash;n&bslash;t&quot;
l_string|&quot;popl %eax&bslash;n&bslash;t&quot;
l_string|&quot;ret&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
l_string|&quot;.align 4&bslash;n&quot;
l_string|&quot;.globl __down_failed_interruptible&bslash;n&quot;
l_string|&quot;__down_failed_interruptible:&bslash;n&bslash;t&quot;
l_string|&quot;pushl %edx&bslash;n&bslash;t&quot;
l_string|&quot;pushl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;call __down_interruptible&bslash;n&bslash;t&quot;
l_string|&quot;popl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;popl %edx&bslash;n&bslash;t&quot;
l_string|&quot;ret&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
l_string|&quot;.align 4&bslash;n&quot;
l_string|&quot;.globl __down_failed_trylock&bslash;n&quot;
l_string|&quot;__down_failed_trylock:&bslash;n&bslash;t&quot;
l_string|&quot;pushl %edx&bslash;n&bslash;t&quot;
l_string|&quot;pushl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;call __down_trylock&bslash;n&bslash;t&quot;
l_string|&quot;popl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;popl %edx&bslash;n&bslash;t&quot;
l_string|&quot;ret&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
l_string|&quot;.align 4&bslash;n&quot;
l_string|&quot;.globl __up_wakeup&bslash;n&quot;
l_string|&quot;__up_wakeup:&bslash;n&bslash;t&quot;
l_string|&quot;pushl %eax&bslash;n&bslash;t&quot;
l_string|&quot;pushl %edx&bslash;n&bslash;t&quot;
l_string|&quot;pushl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;call __up&bslash;n&bslash;t&quot;
l_string|&quot;popl %ecx&bslash;n&bslash;t&quot;
l_string|&quot;popl %edx&bslash;n&bslash;t&quot;
l_string|&quot;popl %eax&bslash;n&bslash;t&quot;
l_string|&quot;ret&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|align
l_int|4
dot
id|globl
id|__down_read_failed
id|__down_read_failed
suffix:colon
id|pushl
op_mod
id|edx
id|pushl
op_mod
id|ecx
id|call
id|down_read_failed
id|popl
op_mod
id|ecx
id|popl
op_mod
id|edx
id|ret
"&quot;"
)paren
suffix:semicolon
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|align
l_int|4
dot
id|globl
id|__down_write_failed
id|__down_write_failed
suffix:colon
id|pushl
op_mod
id|edx
id|pushl
op_mod
id|ecx
id|call
id|down_write_failed
id|popl
op_mod
id|ecx
id|popl
op_mod
id|edx
id|ret
"&quot;"
)paren
suffix:semicolon
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|align
l_int|4
dot
id|globl
id|__rwsem_wake
id|__rwsem_wake
suffix:colon
id|pushl
op_mod
id|edx
id|pushl
op_mod
id|ecx
id|call
id|rwsem_wake
id|popl
op_mod
id|ecx
id|popl
op_mod
id|edx
id|ret
"&quot;"
)paren
suffix:semicolon
r_struct
id|rw_semaphore
op_star
id|FASTCALL
c_func
(paren
id|rwsem_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
)paren
suffix:semicolon
r_struct
id|rw_semaphore
op_star
id|FASTCALL
c_func
(paren
id|down_read_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
)paren
suffix:semicolon
r_struct
id|rw_semaphore
op_star
id|FASTCALL
c_func
(paren
id|down_write_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * implement exchange and add functionality&n; */
DECL|function|rwsem_atomic_update
r_static
r_inline
r_int
id|rwsem_atomic_update
c_func
(paren
r_int
id|delta
comma
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|tmp
op_assign
id|delta
suffix:semicolon
macro_line|#ifndef CONFIG_USING_SPINLOCK_BASED_RWSEM
id|__asm__
id|__volatile__
c_func
(paren
id|LOCK_PREFIX
l_string|&quot;xadd %0,(%1)&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|sem
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
macro_line|#else
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;# beginning rwsem_atomic_update&bslash;n&bslash;t&quot;
macro_line|#ifdef CONFIG_SMP
id|LOCK_PREFIX
l_string|&quot;  decb      &quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%1)&bslash;n&bslash;t&quot;
multiline_comment|/* try to grab the spinlock */
l_string|&quot;  js        3f&bslash;n&quot;
multiline_comment|/* jump if failed */
l_string|&quot;1:&bslash;n&bslash;t&quot;
macro_line|#endif
l_string|&quot;  xchgl     %0,(%1)&bslash;n&bslash;t&quot;
multiline_comment|/* retrieve the old value */
l_string|&quot;  addl      %0,(%1)&bslash;n&bslash;t&quot;
multiline_comment|/* add 0xffff0001, result in memory */
macro_line|#ifdef CONFIG_SMP
l_string|&quot;  movb      $1,&quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%1)&bslash;n&bslash;t&quot;
multiline_comment|/* release the spinlock */
macro_line|#endif
l_string|&quot;.section .text.lock,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;3:&bslash;n&bslash;t&quot;
multiline_comment|/* spin on the spinlock till we get it */
l_string|&quot;  cmpb      $0,&quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%1)&bslash;n&bslash;t&quot;
l_string|&quot;  rep;nop   &bslash;n&bslash;t&quot;
l_string|&quot;  jle       3b&bslash;n&bslash;t&quot;
l_string|&quot;  jmp       1b&bslash;n&quot;
macro_line|#endif
l_string|&quot;.previous&bslash;n&quot;
l_string|&quot;# ending rwsem_atomic_update&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|sem
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|tmp
op_plus
id|delta
suffix:semicolon
)brace
multiline_comment|/*&n; * implement compare and exchange functionality on the rw-semaphore count LSW&n; */
DECL|function|rwsem_cmpxchgw
r_static
r_inline
id|__u16
id|rwsem_cmpxchgw
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
id|__u16
id|old
comma
id|__u16
r_new
)paren
(brace
macro_line|#ifndef CONFIG_USING_SPINLOCK_BASED_RWSEM
r_return
id|cmpxchg
c_func
(paren
(paren
id|__u16
op_star
)paren
op_amp
id|sem-&gt;count.counter
comma
l_int|0
comma
id|RWSEM_ACTIVE_BIAS
)paren
suffix:semicolon
macro_line|#else
id|__u16
id|prev
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;# beginning rwsem_cmpxchgw&bslash;n&bslash;t&quot;
macro_line|#ifdef CONFIG_SMP
id|LOCK_PREFIX
l_string|&quot;  decb      &quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%3)&bslash;n&bslash;t&quot;
multiline_comment|/* try to grab the spinlock */
l_string|&quot;  js        3f&bslash;n&quot;
multiline_comment|/* jump if failed */
l_string|&quot;1:&bslash;n&bslash;t&quot;
macro_line|#endif
l_string|&quot;  cmpw      %w1,(%3)&bslash;n&bslash;t&quot;
l_string|&quot;  jne       4f&bslash;n&bslash;t&quot;
multiline_comment|/* jump if old doesn&squot;t match sem-&gt;count LSW */
l_string|&quot;  movw      %w2,(%3)&bslash;n&bslash;t&quot;
multiline_comment|/* replace sem-&gt;count LSW with the new value */
l_string|&quot;2:&bslash;n&bslash;t&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;  movb      $1,&quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%3)&bslash;n&bslash;t&quot;
multiline_comment|/* release the spinlock */
macro_line|#endif
l_string|&quot;.section .text.lock,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;3:&bslash;n&bslash;t&quot;
multiline_comment|/* spin on the spinlock till we get it */
l_string|&quot;  cmpb      $0,&quot;
id|RWSEM_SPINLOCK_OFFSET_STR
l_string|&quot;(%3)&bslash;n&bslash;t&quot;
l_string|&quot;  rep;nop   &bslash;n&bslash;t&quot;
l_string|&quot;  jle       3b&bslash;n&bslash;t&quot;
l_string|&quot;  jmp       1b&bslash;n&quot;
macro_line|#endif
l_string|&quot;4:&bslash;n&bslash;t&quot;
l_string|&quot;  movw      (%3),%w0&bslash;n&quot;
multiline_comment|/* we&squot;ll want to return the current value */
l_string|&quot;  jmp       2b&bslash;n&quot;
l_string|&quot;.previous&bslash;n&quot;
l_string|&quot;# ending rwsem_cmpxchgw&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|prev
)paren
suffix:colon
l_string|&quot;r0&quot;
(paren
id|old
)paren
comma
l_string|&quot;r&quot;
(paren
r_new
)paren
comma
l_string|&quot;r&quot;
(paren
id|sem
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|prev
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * wait for the read lock to be granted&n; * - need to repeal the increment made inline by the caller&n; * - need to throw a write-lock style spanner into the works (sub 0x00010000 from count)&n; */
DECL|function|down_read_failed
r_struct
id|rw_semaphore
op_star
id|down_read_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
id|count
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering down_read_failed(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
multiline_comment|/* this waitqueue context flag will be cleared when we are granted the lock */
id|__set_bit
c_func
(paren
id|RWSEM_WAITING_FOR_READ
comma
op_amp
id|wait.flags
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* FIFO */
multiline_comment|/* note that we&squot;re now waiting on the lock, but no longer actively read-locking */
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
id|RWSEM_WAITING_BIAS
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;X(%08x)&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* if there are no longer active locks, wake the front queued process(es) up&n;&t; * - it might even be this process, since the waker takes a more active part&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
id|rwsem_wake
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|RWSEM_WAITING_FOR_READ
comma
op_amp
id|wait.flags
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving down_read_failed(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * wait for the write lock to be granted&n; */
DECL|function|down_write_failed
r_struct
id|rw_semaphore
op_star
id|down_write_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
id|count
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering down_write_failed(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
multiline_comment|/* this waitqueue context flag will be cleared when we are granted the lock */
id|__set_bit
c_func
(paren
id|RWSEM_WAITING_FOR_WRITE
comma
op_amp
id|wait.flags
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* FIFO */
multiline_comment|/* note that we&squot;re waiting on the lock, but no longer actively locking */
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] updated(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* if there are no longer active locks, wake the front queued process(es) up&n;&t; * - it might even be this process, since the waker takes a more active part&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
id|rwsem_wake
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|RWSEM_WAITING_FOR_WRITE
comma
op_amp
id|wait.flags
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving down_write_failed(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * handle the lock being released whilst there are processes blocked on it that can now run&n; * - if we come here, then:&n; *   - the &squot;active part&squot; of the count (&amp;0x0000ffff) reached zero (but may no longer be zero)&n; *   - the &squot;waiting part&squot; of the count (&amp;0xffff0000) is negative (and will still be so)&n; */
DECL|function|rwsem_wake
r_struct
id|rw_semaphore
op_star
id|rwsem_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|woken
comma
id|count
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering rwsem_wake(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
id|try_again
suffix:colon
multiline_comment|/* try to grab an &squot;activity&squot; marker&n;&t; * - need to make sure two copies of rwsem_wake() don&squot;t do this for two separate processes&n;&t; *   simultaneously&n;&t; * - be horribly naughty, and only deal with the LSW of the atomic counter&n;&t; */
r_if
c_cond
(paren
id|rwsem_cmpxchgw
c_func
(paren
id|sem
comma
l_int|0
comma
id|RWSEM_ACTIVE_BIAS
)paren
op_ne
l_int|0
)paren
(brace
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] rwsem_wake: abort wakeup due to renewed activity&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* try to grant a single write lock if there&squot;s a writer at the front of the queue&n;&t; * - note we leave the &squot;active part&squot; of the count incremented by 1 and the waiting part&n;&t; *   incremented by 0x00010000&n;&t; */
r_if
c_cond
(paren
id|wake_up_ctx
c_func
(paren
op_amp
id|sem-&gt;wait
comma
l_int|1
comma
op_minus
id|RWSEM_WAITING_FOR_WRITE
)paren
op_eq
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* grant an infinite number of read locks to the readers at the front of the queue&n;&t; * - note we increment the &squot;active part&squot; of the count by the number of readers just woken,&n;&t; *   less one for the activity decrement we&squot;ve already done&n;&t; */
id|woken
op_assign
id|wake_up_ctx
c_func
(paren
op_amp
id|sem-&gt;wait
comma
l_int|65535
comma
op_minus
id|RWSEM_WAITING_FOR_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|woken
op_le
l_int|0
)paren
r_goto
id|counter_correction
suffix:semicolon
id|woken
op_mul_assign
id|RWSEM_ACTIVE_BIAS
op_minus
id|RWSEM_WAITING_BIAS
suffix:semicolon
id|woken
op_sub_assign
id|RWSEM_ACTIVE_BIAS
suffix:semicolon
id|rwsem_atomic_update
c_func
(paren
id|woken
comma
id|sem
)paren
suffix:semicolon
id|out
suffix:colon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving rwsem_wake(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
multiline_comment|/* come here if we need to correct the counter for odd SMP-isms */
id|counter_correction
suffix:colon
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] corrected(%08x)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
r_goto
id|try_again
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * rw spinlock fallbacks&n; */
macro_line|#if defined(CONFIG_SMP)
id|asm
c_func
(paren
"&quot;"
dot
id|align
l_int|4
dot
id|globl
id|__write_lock_failed
id|__write_lock_failed
suffix:colon
l_string|&quot; LOCK &quot;
id|addl
"$"
l_string|&quot; RW_LOCK_BIAS_STR &quot;
comma
(paren
op_mod
id|eax
)paren
l_int|1
suffix:colon
id|cmpl
"$"
l_string|&quot; RW_LOCK_BIAS_STR &quot;
comma
(paren
op_mod
id|eax
)paren
id|jne
l_int|1
id|b
l_string|&quot; LOCK &quot;
id|subl
"$"
l_string|&quot; RW_LOCK_BIAS_STR &quot;
comma
(paren
op_mod
id|eax
)paren
id|jnz
id|__write_lock_failed
id|ret
dot
id|align
l_int|4
dot
id|globl
id|__read_lock_failed
id|__read_lock_failed
suffix:colon
id|lock
suffix:semicolon
id|incl
(paren
op_mod
id|eax
)paren
l_int|1
suffix:colon
id|cmpl
"$"
l_int|1
comma
(paren
op_mod
id|eax
)paren
id|js
l_int|1
id|b
id|lock
suffix:semicolon
id|decl
(paren
op_mod
id|eax
)paren
id|js
id|__read_lock_failed
id|ret
"&quot;"
)paren
suffix:semicolon
macro_line|#endif
eof
