multiline_comment|/*&n; * Extensible Firmware Interface&n; *&n; * Based on Extensible Firmware Interface Specification version 1.0&n; *&n; * Copyright (C) 1999 VA Linux Systems&n; * Copyright (C) 1999 Walt Drummond &lt;drummond@valinux.com&gt;&n; * Copyright (C) 1999-2002 Hewlett-Packard Co.&n; *&t;David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&t;Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; *&n; * All EFI Runtime Services are not implemented yet as EFI only&n; * supports physical mode addressing on SoftSDV. This is to be fixed&n; * in a future version.  --drummond 1999-07-20&n; *&n; * Implemented EFI runtime services and virtual mode calls.  --davidm&n; *&n; * Goutham Rao: &lt;goutham.rao@intel.com&gt;&n; *&t;Skip non-WB memory and ignore empty memory ranges.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
DECL|macro|EFI_DEBUG
mdefine_line|#define EFI_DEBUG&t;0
DECL|macro|PFX
mdefine_line|#define PFX &t;&t;&quot;EFI: &quot;
r_extern
id|efi_status_t
id|asmlinkage
id|efi_call_phys
c_func
(paren
r_void
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
DECL|variable|efi
r_struct
id|efi
id|efi
suffix:semicolon
DECL|variable|efi
id|EXPORT_SYMBOL
c_func
(paren
id|efi
)paren
suffix:semicolon
DECL|variable|__initdata
r_struct
id|efi
id|efi_phys
id|__initdata
suffix:semicolon
DECL|variable|__initdata
r_struct
id|efi_memory_map
id|memmap
id|__initdata
suffix:semicolon
multiline_comment|/*&n; * We require an early boot_ioremap mapping mechanism initially&n; */
r_extern
r_void
op_star
id|boot_ioremap
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * To make EFI call EFI runtime service in physical addressing mode we need&n; * prelog/epilog before/after the invocation to disable interrupt, to&n; * claim EFI runtime service handler exclusively and to duplicate a memory in&n; * low memory space say 0 - 3G.&n; */
DECL|variable|efi_rt_eflags
r_static
r_int
r_int
id|efi_rt_eflags
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|efi_rt_lock
)paren
suffix:semicolon
DECL|variable|efi_bak_pg_dir_pointer
r_static
id|pgd_t
id|efi_bak_pg_dir_pointer
(braket
l_int|2
)braket
suffix:semicolon
DECL|function|efi_call_phys_prelog
r_static
r_void
id|efi_call_phys_prelog
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cr4
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|efi_rt_lock
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|efi_rt_eflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If I don&squot;t have PSE, I should just duplicate two entries in page&n;&t; * directory. If I have PSE, I just need to duplicate one entry in&n;&t; * page directory.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%cr4, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cr4
op_amp
id|X86_CR4_PSE
)paren
(brace
id|efi_bak_pg_dir_pointer
(braket
l_int|0
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0
)paren
)braket
dot
id|pgd
suffix:semicolon
id|swapper_pg_dir
(braket
l_int|0
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
id|PAGE_OFFSET
)paren
)braket
dot
id|pgd
suffix:semicolon
)brace
r_else
(brace
id|efi_bak_pg_dir_pointer
(braket
l_int|0
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0
)paren
)braket
dot
id|pgd
suffix:semicolon
id|efi_bak_pg_dir_pointer
(braket
l_int|1
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0x400000
)paren
)braket
dot
id|pgd
suffix:semicolon
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0
)paren
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
id|PAGE_OFFSET
)paren
)braket
dot
id|pgd
suffix:semicolon
id|temp
op_assign
id|PAGE_OFFSET
op_plus
l_int|0x400000
suffix:semicolon
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0x400000
)paren
)braket
dot
id|pgd
op_assign
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
id|temp
)paren
)braket
dot
id|pgd
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * After the lock is released, the original page table is restored.&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|cpu_gdt_descr
(braket
l_int|0
)braket
dot
id|address
op_assign
id|__pa
c_func
(paren
id|cpu_gdt_descr
(braket
l_int|0
)braket
dot
id|address
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lgdt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_struct
id|Xgt_desc_struct
op_star
)paren
id|__pa
c_func
(paren
op_amp
id|cpu_gdt_descr
(braket
l_int|0
)braket
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|efi_call_phys_epilog
r_static
r_void
id|efi_call_phys_epilog
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cr4
suffix:semicolon
id|cpu_gdt_descr
(braket
l_int|0
)braket
dot
id|address
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|cpu_gdt_descr
(braket
l_int|0
)braket
dot
id|address
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lgdt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cpu_gdt_descr
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%cr4, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cr4
op_amp
id|X86_CR4_PSE
)paren
(brace
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0
)paren
)braket
dot
id|pgd
op_assign
id|efi_bak_pg_dir_pointer
(braket
l_int|0
)braket
dot
id|pgd
suffix:semicolon
)brace
r_else
(brace
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0
)paren
)braket
dot
id|pgd
op_assign
id|efi_bak_pg_dir_pointer
(braket
l_int|0
)braket
dot
id|pgd
suffix:semicolon
id|swapper_pg_dir
(braket
id|pgd_index
c_func
(paren
l_int|0x400000
)paren
)braket
dot
id|pgd
op_assign
id|efi_bak_pg_dir_pointer
(braket
l_int|1
)braket
dot
id|pgd
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * After the lock is released, the original page table is restored.&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|efi_rt_eflags
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|efi_rt_lock
)paren
suffix:semicolon
)brace
r_static
id|efi_status_t
DECL|function|phys_efi_set_virtual_address_map
id|phys_efi_set_virtual_address_map
c_func
(paren
r_int
r_int
id|memory_map_size
comma
r_int
r_int
id|descriptor_size
comma
id|u32
id|descriptor_version
comma
id|efi_memory_desc_t
op_star
id|virtual_map
)paren
(brace
id|efi_status_t
id|status
suffix:semicolon
id|efi_call_phys_prelog
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|efi_call_phys
c_func
(paren
id|efi_phys.set_virtual_address_map
comma
id|memory_map_size
comma
id|descriptor_size
comma
id|descriptor_version
comma
id|virtual_map
)paren
suffix:semicolon
id|efi_call_phys_epilog
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|efi_status_t
DECL|function|phys_efi_get_time
id|phys_efi_get_time
c_func
(paren
id|efi_time_t
op_star
id|tm
comma
id|efi_time_cap_t
op_star
id|tc
)paren
(brace
id|efi_status_t
id|status
suffix:semicolon
id|efi_call_phys_prelog
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|efi_call_phys
c_func
(paren
id|efi_phys.get_time
comma
id|tm
comma
id|tc
)paren
suffix:semicolon
id|efi_call_phys_epilog
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|efi_set_rtc_mmss
r_inline
r_int
id|efi_set_rtc_mmss
c_func
(paren
r_int
r_int
id|nowtime
)paren
(brace
r_int
id|real_seconds
comma
id|real_minutes
suffix:semicolon
id|efi_status_t
id|status
suffix:semicolon
id|efi_time_t
id|eft
suffix:semicolon
id|efi_time_cap_t
id|cap
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|efi_rt_lock
)paren
suffix:semicolon
id|status
op_assign
id|efi
dot
id|get_time
c_func
(paren
op_amp
id|eft
comma
op_amp
id|cap
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|efi_rt_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
id|panic
c_func
(paren
l_string|&quot;Ooops, efitime: can&squot;t read time!&bslash;n&quot;
)paren
suffix:semicolon
id|real_seconds
op_assign
id|nowtime
op_mod
l_int|60
suffix:semicolon
id|real_minutes
op_assign
id|nowtime
op_div
l_int|60
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|abs
c_func
(paren
id|real_minutes
op_minus
id|eft.minute
)paren
op_plus
l_int|15
)paren
op_div
l_int|30
)paren
op_amp
l_int|1
)paren
id|real_minutes
op_add_assign
l_int|30
suffix:semicolon
id|real_minutes
op_mod_assign
l_int|60
suffix:semicolon
id|eft.minute
op_assign
id|real_minutes
suffix:semicolon
id|eft.second
op_assign
id|real_seconds
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ooops: efitime: can&squot;t read time!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This should only be used during kernel init and before runtime&n; * services have been remapped, therefore, we&squot;ll need to call in physical&n; * mode.  Note, this call isn&squot;t used later, so mark it __init.&n; */
DECL|function|efi_get_time
r_inline
r_int
r_int
id|__init
id|efi_get_time
c_func
(paren
r_void
)paren
(brace
id|efi_status_t
id|status
suffix:semicolon
id|efi_time_t
id|eft
suffix:semicolon
id|efi_time_cap_t
id|cap
suffix:semicolon
id|status
op_assign
id|phys_efi_get_time
c_func
(paren
op_amp
id|eft
comma
op_amp
id|cap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
id|printk
c_func
(paren
l_string|&quot;Oops: efitime: can&squot;t read time status: 0x%lx&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|mktime
c_func
(paren
id|eft.year
comma
id|eft.month
comma
id|eft.day
comma
id|eft.hour
comma
id|eft.minute
comma
id|eft.second
)paren
suffix:semicolon
)brace
DECL|function|is_available_memory
r_int
id|is_available_memory
c_func
(paren
id|efi_memory_desc_t
op_star
id|md
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_WB
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|md-&gt;type
)paren
(brace
r_case
id|EFI_LOADER_CODE
suffix:colon
r_case
id|EFI_LOADER_DATA
suffix:colon
r_case
id|EFI_BOOT_SERVICES_CODE
suffix:colon
r_case
id|EFI_BOOT_SERVICES_DATA
suffix:colon
r_case
id|EFI_CONVENTIONAL_MEMORY
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to map the EFI memory map again after paging_init().&n; */
DECL|function|efi_map_memmap
r_void
id|__init
id|efi_map_memmap
c_func
(paren
r_void
)paren
(brace
id|memmap.map
op_assign
l_int|NULL
suffix:semicolon
id|memmap.map
op_assign
(paren
id|efi_memory_desc_t
op_star
)paren
id|bt_ioremap
c_func
(paren
(paren
r_int
r_int
)paren
id|memmap.phys_map
comma
(paren
id|memmap.nr_map
op_star
r_sizeof
(paren
id|efi_memory_desc_t
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memmap.map
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Could not remap the EFI memmap!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|print_efi_memmap
r_void
id|__init
id|print_efi_memmap
c_func
(paren
r_void
)paren
(brace
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;mem%02u: type=%u, attr=0x%llx, &quot;
l_string|&quot;range=[0x%016llx-0x%016llx) (%lluMB)&bslash;n&quot;
comma
id|i
comma
id|md-&gt;type
comma
id|md-&gt;attribute
comma
id|md-&gt;phys_addr
comma
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
comma
(paren
id|md-&gt;num_pages
op_rshift
(paren
l_int|20
op_minus
id|EFI_PAGE_SHIFT
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Walks the EFI memory map and calls CALLBACK once for each EFI&n; * memory descriptor that has memory that is available for kernel use.&n; */
DECL|function|efi_memmap_walk
r_void
id|efi_memmap_walk
c_func
(paren
id|efi_freemem_callback_t
id|callback
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|prev_valid
op_assign
l_int|0
suffix:semicolon
r_struct
id|range
(brace
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
)brace
id|prev
comma
id|curr
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|md-&gt;num_pages
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|is_available_memory
c_func
(paren
id|md
)paren
)paren
)paren
r_continue
suffix:semicolon
id|curr.start
op_assign
id|md-&gt;phys_addr
suffix:semicolon
id|curr.end
op_assign
id|curr.start
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev_valid
)paren
(brace
id|prev
op_assign
id|curr
suffix:semicolon
id|prev_valid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|curr.start
OL
id|prev.start
)paren
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Unordered memory map&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev.end
op_eq
id|curr.start
)paren
id|prev.end
op_assign
id|curr.end
suffix:semicolon
r_else
(brace
id|start
op_assign
(paren
r_int
r_int
)paren
(paren
id|PAGE_ALIGN
c_func
(paren
id|prev.start
)paren
)paren
suffix:semicolon
id|end
op_assign
(paren
r_int
r_int
)paren
(paren
id|prev.end
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|end
OG
id|start
)paren
op_logical_and
(paren
op_star
id|callback
)paren
(paren
id|start
comma
id|end
comma
id|arg
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|prev
op_assign
id|curr
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|prev_valid
)paren
(brace
id|start
op_assign
(paren
r_int
r_int
)paren
id|PAGE_ALIGN
c_func
(paren
id|prev.start
)paren
suffix:semicolon
id|end
op_assign
(paren
r_int
r_int
)paren
(paren
id|prev.end
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|start
)paren
(paren
op_star
id|callback
)paren
(paren
id|start
comma
id|end
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
DECL|function|efi_init
r_void
id|__init
id|efi_init
c_func
(paren
r_void
)paren
(brace
id|efi_config_table_t
op_star
id|config_tables
suffix:semicolon
id|efi_runtime_services_t
op_star
id|runtime
suffix:semicolon
id|efi_char16_t
op_star
id|c16
suffix:semicolon
r_char
id|vendor
(braket
l_int|100
)braket
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_int
r_int
id|num_config_tables
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|efi
comma
l_int|0
comma
r_sizeof
(paren
id|efi
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|efi_phys
comma
l_int|0
comma
r_sizeof
(paren
id|efi_phys
)paren
)paren
suffix:semicolon
id|efi_phys.systab
op_assign
id|EFI_SYSTAB
suffix:semicolon
id|memmap.phys_map
op_assign
id|EFI_MEMMAP
suffix:semicolon
id|memmap.nr_map
op_assign
id|EFI_MEMMAP_SIZE
op_div
id|EFI_MEMDESC_SIZE
suffix:semicolon
id|memmap.desc_version
op_assign
id|EFI_MEMDESC_VERSION
suffix:semicolon
id|efi.systab
op_assign
(paren
id|efi_system_table_t
op_star
)paren
id|boot_ioremap
c_func
(paren
(paren
r_int
r_int
)paren
id|efi_phys.systab
comma
r_sizeof
(paren
id|efi_system_table_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the EFI Table&n;&t; */
r_if
c_cond
(paren
id|efi.systab
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Woah! Couldn&squot;t map the EFI system table.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|efi.systab-&gt;hdr.signature
op_ne
id|EFI_SYSTEM_TABLE_SIGNATURE
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Woah! EFI system table signature incorrect&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|efi.systab-&gt;hdr.revision
op_xor
id|EFI_SYSTEM_TABLE_REVISION
)paren
op_rshift
l_int|16
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Warning: EFI system table major version mismatch: &quot;
l_string|&quot;got %d.%02d, expected %d.%02d&bslash;n&quot;
comma
id|efi.systab-&gt;hdr.revision
op_rshift
l_int|16
comma
id|efi.systab-&gt;hdr.revision
op_amp
l_int|0xffff
comma
id|EFI_SYSTEM_TABLE_REVISION
op_rshift
l_int|16
comma
id|EFI_SYSTEM_TABLE_REVISION
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab some details from the system table&n;&t; */
id|num_config_tables
op_assign
id|efi.systab-&gt;nr_tables
suffix:semicolon
id|config_tables
op_assign
(paren
id|efi_config_table_t
op_star
)paren
id|efi.systab-&gt;tables
suffix:semicolon
id|runtime
op_assign
id|efi.systab-&gt;runtime
suffix:semicolon
multiline_comment|/*&n;&t; * Show what we know for posterity&n;&t; */
id|c16
op_assign
(paren
id|efi_char16_t
op_star
)paren
id|boot_ioremap
c_func
(paren
id|efi.systab-&gt;fw_vendor
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c16
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|vendor
)paren
op_logical_and
op_star
id|c16
suffix:semicolon
op_increment
id|i
)paren
id|vendor
(braket
id|i
)braket
op_assign
op_star
id|c16
op_increment
suffix:semicolon
id|vendor
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Could not map the firmware vendor!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;EFI v%u.%.02u by %s &bslash;n&quot;
comma
id|efi.systab-&gt;hdr.revision
op_rshift
l_int|16
comma
id|efi.systab-&gt;hdr.revision
op_amp
l_int|0xffff
comma
id|vendor
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s see what config tables the firmware passed to us.&n;&t; */
id|config_tables
op_assign
(paren
id|efi_config_table_t
op_star
)paren
id|boot_ioremap
c_func
(paren
(paren
r_int
r_int
)paren
id|config_tables
comma
id|num_config_tables
op_star
r_sizeof
(paren
id|efi_config_table_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_tables
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Could not map EFI Configuration Table!&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_config_tables
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|MPS_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.mps
op_assign
(paren
r_void
op_star
)paren
id|config_tables
(braket
id|i
)braket
dot
id|table
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; MPS=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|ACPI_20_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.acpi20
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; ACPI 2.0=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|ACPI_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.acpi
op_assign
id|__va
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; ACPI=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|SMBIOS_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.smbios
op_assign
(paren
r_void
op_star
)paren
id|config_tables
(braket
id|i
)braket
dot
id|table
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; SMBIOS=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|HCDP_TABLE_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.hcdp
op_assign
(paren
r_void
op_star
)paren
id|config_tables
(braket
id|i
)braket
dot
id|table
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; HCDP=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|efi_guidcmp
c_func
(paren
id|config_tables
(braket
id|i
)braket
dot
id|guid
comma
id|UGA_IO_PROTOCOL_GUID
)paren
op_eq
l_int|0
)paren
(brace
id|efi.uga
op_assign
(paren
r_void
op_star
)paren
id|config_tables
(braket
id|i
)braket
dot
id|table
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; UGA=0x%lx &quot;
comma
id|config_tables
(braket
id|i
)braket
dot
id|table
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check out the runtime services table. We need to map&n;&t; * the runtime services table so that we can grab the physical&n;&t; * address of several of the EFI runtime functions, needed to&n;&t; * set the firmware into virtual mode.&n;&t; */
id|runtime
op_assign
(paren
id|efi_runtime_services_t
op_star
)paren
id|boot_ioremap
c_func
(paren
(paren
r_int
r_int
)paren
id|runtime
comma
r_sizeof
(paren
id|efi_runtime_services_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|runtime
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t; &t; * We will only need *early* access to the following&n;&t;&t; * two EFI runtime services before set_virtual_address_map&n;&t;&t; * is invoked.&n; &t; &t; */
id|efi_phys.get_time
op_assign
(paren
id|efi_get_time_t
op_star
)paren
id|runtime-&gt;get_time
suffix:semicolon
id|efi_phys.set_virtual_address_map
op_assign
(paren
id|efi_set_virtual_address_map_t
op_star
)paren
id|runtime-&gt;set_virtual_address_map
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Could not map the runtime service table!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Map the EFI memory map for use until paging_init() */
id|memmap.map
op_assign
(paren
id|efi_memory_desc_t
op_star
)paren
id|boot_ioremap
c_func
(paren
(paren
r_int
r_int
)paren
id|EFI_MEMMAP
comma
id|EFI_MEMMAP_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memmap.map
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Could not map the EFI memory map!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EFI_MEMDESC_SIZE
op_ne
r_sizeof
(paren
id|efi_memory_desc_t
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;Warning! Kernel-defined memdesc doesn&squot;t &quot;
l_string|&quot;match the one from EFI!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EFI_DEBUG
id|print_efi_memmap
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This function will switch the EFI runtime services to virtual mode.&n; * Essentially, look through the EFI memmap and map every region that&n; * has the runtime attribute bit set in its memory descriptor and update&n; * that memory descriptor with the virtual address obtained from ioremap().&n; * This enables the runtime services to be called without having to&n; * thunk back into physical mode for every invocation.&n; */
DECL|function|efi_enter_virtual_mode
r_void
id|__init
id|efi_enter_virtual_mode
c_func
(paren
r_void
)paren
(brace
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
id|efi_status_t
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|efi.systab
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|md-&gt;attribute
op_amp
id|EFI_MEMORY_RUNTIME
)paren
(brace
id|md-&gt;virt_addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|md-&gt;phys_addr
comma
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_int
r_int
)paren
id|md-&gt;virt_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;ioremap of 0x%lX failed&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|md-&gt;phys_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|md-&gt;phys_addr
op_le
(paren
r_int
r_int
)paren
id|efi_phys.systab
)paren
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|efi_phys.systab
OL
id|md-&gt;phys_addr
op_plus
(paren
(paren
r_int
r_int
)paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
id|addr
op_assign
id|md-&gt;virt_addr
op_minus
id|md-&gt;phys_addr
op_plus
(paren
r_int
r_int
)paren
id|efi_phys.systab
suffix:semicolon
id|efi.systab
op_assign
(paren
id|efi_system_table_t
op_star
)paren
id|addr
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|efi.systab
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|phys_efi_set_virtual_address_map
c_func
(paren
r_sizeof
(paren
id|efi_memory_desc_t
)paren
op_star
id|memmap.nr_map
comma
r_sizeof
(paren
id|efi_memory_desc_t
)paren
comma
id|memmap.desc_version
comma
id|memmap.phys_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|EFI_SUCCESS
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;You are screwed! &quot;
l_string|&quot;Unable to switch EFI into virtual mode &quot;
l_string|&quot;(status=%lx)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;EFI call to SetVirtualAddressMap() failed!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now that EFI is in virtual mode, update the function&n;&t; * pointers in the runtime service table to the new virtual addresses.&n;&t; */
id|efi.get_time
op_assign
(paren
id|efi_get_time_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;get_time
suffix:semicolon
id|efi.set_time
op_assign
(paren
id|efi_set_time_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;set_time
suffix:semicolon
id|efi.get_wakeup_time
op_assign
(paren
id|efi_get_wakeup_time_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;get_wakeup_time
suffix:semicolon
id|efi.set_wakeup_time
op_assign
(paren
id|efi_set_wakeup_time_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;set_wakeup_time
suffix:semicolon
id|efi.get_variable
op_assign
(paren
id|efi_get_variable_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;get_variable
suffix:semicolon
id|efi.get_next_variable
op_assign
(paren
id|efi_get_next_variable_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;get_next_variable
suffix:semicolon
id|efi.set_variable
op_assign
(paren
id|efi_set_variable_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;set_variable
suffix:semicolon
id|efi.get_next_high_mono_count
op_assign
(paren
id|efi_get_next_high_mono_count_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;get_next_high_mono_count
suffix:semicolon
id|efi.reset_system
op_assign
(paren
id|efi_reset_system_t
op_star
)paren
id|efi.systab-&gt;runtime-&gt;reset_system
suffix:semicolon
)brace
r_void
id|__init
DECL|function|efi_initialize_iomem_resources
id|efi_initialize_iomem_resources
c_func
(paren
r_struct
id|resource
op_star
id|code_resource
comma
r_struct
id|resource
op_star
id|data_resource
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|md-&gt;phys_addr
op_plus
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
OG
l_int|0x100000000ULL
)paren
r_continue
suffix:semicolon
id|res
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|md-&gt;type
)paren
(brace
r_case
id|EFI_RESERVED_TYPE
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Reserved Memory&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_LOADER_CODE
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Loader Code&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_LOADER_DATA
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Loader Data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_BOOT_SERVICES_DATA
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;BootServices Data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_BOOT_SERVICES_CODE
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;BootServices Code&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_RUNTIME_SERVICES_CODE
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Runtime Service Code&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_RUNTIME_SERVICES_DATA
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Runtime Service Data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_CONVENTIONAL_MEMORY
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Conventional Memory&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_UNUSABLE_MEMORY
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Unusable Memory&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_ACPI_RECLAIM_MEMORY
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI Reclaim&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_ACPI_MEMORY_NVS
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI NVS&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_MEMORY_MAPPED_IO
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Memory Mapped IO&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EFI_MEMORY_MAPPED_IO_PORT_SPACE
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Memory Mapped IO Port Space&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;Reserved&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|res-&gt;start
op_assign
id|md-&gt;phys_addr
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
(paren
(paren
id|md-&gt;num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Failed to allocate res %s : 0x%lx-0x%lx&bslash;n&quot;
comma
id|res-&gt;name
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t know which region contains kernel data so we try&n;&t;&t; * it repeatedly and let the resource manager test it.&n;&t;&t; */
r_if
c_cond
(paren
id|md-&gt;type
op_eq
id|EFI_CONVENTIONAL_MEMORY
)paren
(brace
id|request_resource
c_func
(paren
id|res
comma
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
id|data_resource
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Convenience functions to obtain memory types and attributes&n; */
DECL|function|efi_mem_type
id|u32
id|efi_mem_type
c_func
(paren
r_int
r_int
id|phys_addr
)paren
(brace
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|md-&gt;phys_addr
op_le
id|phys_addr
)paren
op_logical_and
(paren
id|phys_addr
OL
(paren
id|md-&gt;phys_addr
op_plus
(paren
id|md
op_member_access_from_pointer
id|num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
)paren
)paren
r_return
id|md-&gt;type
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|efi_mem_attributes
id|u64
id|efi_mem_attributes
c_func
(paren
r_int
r_int
id|phys_addr
)paren
(brace
id|efi_memory_desc_t
op_star
id|md
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|memmap.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md
op_assign
op_amp
id|memmap.map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|md-&gt;phys_addr
op_le
id|phys_addr
)paren
op_logical_and
(paren
id|phys_addr
OL
(paren
id|md-&gt;phys_addr
op_plus
(paren
id|md
op_member_access_from_pointer
id|num_pages
op_lshift
id|EFI_PAGE_SHIFT
)paren
)paren
)paren
)paren
r_return
id|md-&gt;attribute
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
