multiline_comment|/* smp.c: Sparc64 SMP support.&n; *&n; * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;asm/head.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/starfire.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
r_extern
r_int
id|linux_num_cpus
suffix:semicolon
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|prom_cpu_nodes
(braket
)braket
suffix:semicolon
DECL|variable|cpu_data
id|cpuinfo_sparc
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|__cpu_number_map
r_volatile
r_int
id|__cpu_number_map
(braket
id|NR_CPUS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
DECL|variable|__cpu_logical_map
r_volatile
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Please don&squot;t make this stuff initdata!!!  --DaveM */
DECL|variable|boot_cpu_id
r_static
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_activated
r_static
r_int
id|smp_activated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Kernel spinlock */
DECL|variable|__cacheline_aligned_in_smp
id|spinlock_t
id|kernel_flag
id|__cacheline_aligned_in_smp
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|smp_processors_ready
r_volatile
r_int
id|smp_processors_ready
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
DECL|function|smp_setup
r_void
id|__init
id|smp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* XXX implement me XXX */
)brace
DECL|variable|max_cpus
r_static
r_int
id|max_cpus
op_assign
id|NR_CPUS
suffix:semicolon
DECL|function|maxcpus
r_static
r_int
id|__init
id|maxcpus
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|max_cpus
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;maxcpus=&quot;
comma
id|maxcpus
)paren
suffix:semicolon
DECL|function|smp_info
r_void
id|smp_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;State:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;CPU%d:&bslash;t&bslash;tonline&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_bogo
r_void
id|smp_bogo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Cpu%dBogo&bslash;t: %lu.%02lu&bslash;n&quot;
l_string|&quot;Cpu%dClkTck&bslash;t: %016lx&bslash;n&quot;
comma
id|i
comma
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
comma
id|i
comma
id|cpu_data
(braket
id|i
)braket
dot
id|clock_tick
)paren
suffix:semicolon
)brace
DECL|function|smp_store_cpu_info
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_int
id|i
comma
id|no
suffix:semicolon
multiline_comment|/* multiplier and counter set by&n;&t;   smp_setup_percpu_timer()  */
id|cpu_data
(braket
id|id
)braket
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|linux_num_cpus
suffix:semicolon
id|no
op_increment
)paren
r_if
c_cond
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|mid
op_eq
id|id
)paren
r_break
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|clock_tick
op_assign
id|prom_getintdefault
c_func
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|prom_node
comma
l_string|&quot;clock-frequency&quot;
comma
l_int|0
)paren
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pte_cache
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pte_cache
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgdcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgd_cache
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|idle_volume
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|cpu_data
(braket
id|id
)braket
dot
id|irq_worklists
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|smp_commence
r_void
id|__init
id|smp_commence
c_func
(paren
r_void
)paren
(brace
)brace
r_static
r_void
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|callin_flag
r_static
r_volatile
r_int
r_int
id|callin_flag
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|inherit_locked_prom_mappings
c_func
(paren
r_int
id|save_p
)paren
suffix:semicolon
r_extern
r_void
id|cpu_probe
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|pstate
suffix:semicolon
r_extern
r_int
id|bigkernel
suffix:semicolon
r_extern
r_int
r_int
id|kern_locked_tte_data
suffix:semicolon
r_if
c_cond
(paren
id|bigkernel
)paren
(brace
id|prom_dtlb_load
c_func
(paren
id|sparc64_highest_locked_tlbent
c_func
(paren
)paren
op_minus
l_int|1
comma
id|kern_locked_tte_data
op_plus
l_int|0x400000
comma
id|KERNBASE
op_plus
l_int|0x400000
)paren
suffix:semicolon
id|prom_itlb_load
c_func
(paren
id|sparc64_highest_locked_tlbent
c_func
(paren
)paren
op_minus
l_int|1
comma
id|kern_locked_tte_data
op_plus
l_int|0x400000
comma
id|KERNBASE
op_plus
l_int|0x400000
)paren
suffix:semicolon
)brace
id|inherit_locked_prom_mappings
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|cpu_probe
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Guarentee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Set things up so user can access tick register for profiling&n;&t; * purposes.  Also workaround BB_ERRATA_1 by doing a dummy&n;&t; * read back of %tick after writing it.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g2
id|add
op_mod
op_mod
id|g2
comma
l_int|6
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wrpr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|tick
id|rdpr
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SPARC64_USE_STICK
)paren
(brace
multiline_comment|/* Let the user get at STICK too. */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
id|rd
op_mod
op_mod
id|asr24
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|asr24
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|smp_setup_percpu_timer
c_func
(paren
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #Sync&bslash;n&bslash;t&quot;
l_string|&quot;flush  %%g6&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear this or we will die instantly when we&n;&t; * schedule back to this idler...&n;&t; */
id|clear_thread_flag
c_func
(paren
id|TIF_NEWCHILD
)paren
suffix:semicolon
multiline_comment|/* Attach to the address space of init_task. */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|smp_threads_ready
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
DECL|function|cpu_panic
r_void
id|cpu_panic
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Returns from cpu_idle!&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;SMP bolixed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|prom_cpuinfo
id|linux_cpus
(braket
l_int|64
)braket
suffix:semicolon
r_extern
r_int
r_int
id|sparc64_cpu_startup
suffix:semicolon
multiline_comment|/* The OBP cpu startup callback truncates the 3rd arg cookie to&n; * 32-bits (I think) so to be safe we have it read the pointer&n; * contained here so we work on &gt;4GB machines. -DaveM&n; */
DECL|variable|cpu_new_thread
r_static
r_struct
id|thread_info
op_star
id|cpu_new_thread
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
id|smp_tune_scheduling
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_boot_cpus
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|cpucount
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Entering UltraSMPenguin Mode...&bslash;n&quot;
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linux_num_cpus
op_eq
l_int|1
)paren
(brace
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpu_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpucount
op_plus
l_int|1
)paren
op_eq
id|max_cpus
)paren
r_goto
id|ignorecpu
suffix:semicolon
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
r_int
r_int
id|entry
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|sparc64_cpu_startup
)paren
suffix:semicolon
r_int
r_int
id|cookie
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|cpu_new_thread
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|no
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Starting CPU %d... &quot;
comma
id|i
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|CLONE_PID
)paren
suffix:semicolon
id|cpucount
op_increment
suffix:semicolon
id|p
op_assign
id|init_task.prev_task
suffix:semicolon
id|init_idle
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
id|unhash_process
c_func
(paren
id|p
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|linux_num_cpus
suffix:semicolon
id|no
op_increment
)paren
r_if
c_cond
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|mid
op_eq
id|i
)paren
r_break
suffix:semicolon
id|cpu_new_thread
op_assign
id|p-&gt;thread_info
suffix:semicolon
id|prom_startcpu
c_func
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|prom_node
comma
id|entry
comma
id|cookie
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|5000000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|callin_flag
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callin_flag
)paren
(brace
id|__cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
id|prom_cpu_nodes
(braket
id|i
)braket
op_assign
id|linux_cpus
(braket
id|no
)braket
dot
id|prom_node
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpucount
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor %d is stuck.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;FAILED&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|callin_flag
)paren
(brace
id|ignorecpu
suffix:colon
id|cpu_present_map
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|i
)paren
suffix:semicolon
id|__cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|cpu_new_thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpucount
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|max_cpus
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_present_map
op_assign
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
id|bogosum
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|bogosum
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|smp_activated
op_assign
l_int|1
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We want to run this with all the other cpus spinning&n;&t; * in the kernel.&n;&t; */
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|smp_processors_ready
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
)brace
DECL|function|spitfire_xcall_helper
r_static
r_void
id|spitfire_xcall_helper
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|u64
id|pstate
comma
r_int
r_int
id|cpu
)paren
(brace
id|u64
id|result
comma
id|target
suffix:semicolon
r_int
id|stuck
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
)paren
(brace
multiline_comment|/* map to real upaid */
id|cpu
op_assign
(paren
(paren
(paren
id|cpu
op_amp
l_int|0x3c
)paren
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|cpu
op_amp
l_int|0x40
)paren
op_rshift
l_int|4
)paren
op_or
(paren
id|cpu
op_amp
l_int|0x3
)paren
)paren
suffix:semicolon
)brace
id|target
op_assign
(paren
id|cpu
op_lshift
l_int|14
)paren
op_or
l_int|0x70
suffix:semicolon
id|again
suffix:colon
multiline_comment|/* Ok, this is the real Spitfire Errata #54.&n;&t; * One must read back from a UDB internal register&n;&t; * after writes to the UDB interrupt dispatch, but&n;&t; * before the membar Sync for that write.&n;&t; * So we use the high UDB control register (ASI 0x7f,&n;&t; * ADDR 0x20) for the dummy read. -DaveM&n;&t; */
id|tmp
op_assign
l_int|0x40
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|wrpr
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|pstate
id|stxa
op_mod
l_int|4
comma
(braket
op_mod
l_int|0
)braket
op_mod
l_int|3
id|stxa
op_mod
l_int|5
comma
(braket
op_mod
l_int|0
op_plus
op_mod
l_int|8
)braket
op_mod
l_int|3
id|add
op_mod
l_int|0
comma
op_mod
l_int|8
comma
op_mod
l_int|0
id|stxa
op_mod
l_int|6
comma
(braket
op_mod
l_int|0
op_plus
op_mod
l_int|8
)braket
op_mod
l_int|3
id|membar
macro_line|#Sync
id|stxa
op_mod
op_mod
id|g0
comma
(braket
op_mod
l_int|7
)braket
op_mod
l_int|3
id|membar
macro_line|#Sync
id|mov
l_int|0x20
comma
op_mod
op_mod
id|g1
id|ldxa
(braket
op_mod
op_mod
id|g1
)braket
l_int|0x7f
comma
op_mod
op_mod
id|g0
id|membar
macro_line|#Sync&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
comma
l_string|&quot;r&quot;
(paren
id|data0
)paren
comma
l_string|&quot;r&quot;
(paren
id|data1
)paren
comma
l_string|&quot;r&quot;
(paren
id|data2
)paren
comma
l_string|&quot;r&quot;
(paren
id|target
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x10
)paren
comma
l_string|&quot;0&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTE: PSTATE_IE is still clear. */
id|stuck
op_assign
l_int|100000
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_DISPATCH_STAT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stuck
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
op_amp
l_int|0x1
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: mondo stuckage result[%016lx]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
DECL|function|spitfire_xcall_deliver
r_static
id|__inline__
r_void
id|spitfire_xcall_deliver
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|ncpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u64
id|pstate
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|NR_CPUS
)paren
op_logical_and
id|ncpus
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|spitfire_xcall_helper
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|pstate
comma
id|i
)paren
suffix:semicolon
id|ncpus
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Cheetah now allows to send the whole 64-bytes of data in the interrupt&n; * packet, but we have no use for that.  However we do take advantage of&n; * the new pipelining feature (ie. dispatch to multiple cpus simultaneously).&n; */
macro_line|#if NR_CPUS &gt; 32
macro_line|#error Fixup cheetah_xcall_deliver Dave...
macro_line|#endif
DECL|function|cheetah_xcall_deliver
r_static
r_void
id|cheetah_xcall_deliver
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
r_int
r_int
id|mask
)paren
(brace
id|u64
id|pstate
suffix:semicolon
r_int
id|nack_busy_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
r_return
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|retry
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, %1, %%pstate&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup the dispatch data registers. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa&t;%0, [%3] %6&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%1, [%4] %6&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%2, [%5] %6&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|data0
)paren
comma
l_string|&quot;r&quot;
(paren
id|data1
)paren
comma
l_string|&quot;r&quot;
(paren
id|data2
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x40
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x50
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x60
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
)paren
suffix:semicolon
id|nack_busy_id
op_assign
l_int|0
suffix:semicolon
(brace
r_int
id|i
comma
id|ncpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|NR_CPUS
)paren
op_logical_and
id|ncpus
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|u64
id|target
op_assign
(paren
id|i
op_lshift
l_int|14
)paren
op_or
l_int|0x70
suffix:semicolon
id|target
op_or_assign
(paren
id|nack_busy_id
op_increment
op_lshift
l_int|24
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa&t;%%g0, [%0] %1&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|target
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
)paren
suffix:semicolon
id|ncpus
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Now, poll for completion. */
(brace
id|u64
id|dispatch_stat
suffix:semicolon
r_int
id|stuck
suffix:semicolon
id|stuck
op_assign
l_int|100000
op_star
id|nack_busy_id
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa&t;[%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dispatch_stat
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_DISPATCH_STAT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dispatch_stat
op_eq
l_int|0UL
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|stuck
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dispatch_stat
op_amp
l_int|0x5555555555555555UL
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dispatch_stat
op_amp
op_complement
(paren
l_int|0x5555555555555555UL
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Busy bits will not clear, continue instead&n;&t;&t;&t; * of freezing up on this cpu.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: mondo stuckage result[%016lx]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|dispatch_stat
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
comma
id|this_busy_nack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Delay some random time with interrupts enabled&n;&t;&t;&t; * to prevent deadlock.&n;&t;&t;&t; */
id|udelay
c_func
(paren
l_int|2
op_star
id|nack_busy_id
)paren
suffix:semicolon
multiline_comment|/* Clear out the mask bits for cpus which did not&n;&t;&t;&t; * NACK us.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dispatch_stat
op_amp
(paren
l_int|0x2
op_lshift
id|this_busy_nack
)paren
)paren
op_eq
l_int|0
)paren
id|mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|i
)paren
suffix:semicolon
id|this_busy_nack
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Send cross call to all processors mentioned in MASK&n; * except self.&n; */
DECL|function|smp_cross_call_masked
r_static
r_void
id|smp_cross_call_masked
c_func
(paren
r_int
r_int
op_star
id|func
comma
id|u32
id|ctx
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
r_int
r_int
id|mask
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
id|u64
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
id|ctx
)paren
op_lshift
l_int|32
op_or
(paren
(paren
(paren
id|u64
)paren
id|func
)paren
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|mask
)paren
suffix:semicolon
r_else
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* NOTE: Caller runs local copy on master. */
)brace
)brace
multiline_comment|/* Send cross call to all processors except self. */
DECL|macro|smp_cross_call
mdefine_line|#define smp_cross_call(func, ctx, data1, data2) &bslash;&n;&t;smp_cross_call_masked(func, ctx, data1, data2, cpu_present_map)
DECL|struct|call_data_struct
r_struct
id|call_data_struct
(brace
DECL|member|func
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
suffix:semicolon
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
DECL|member|finished
id|atomic_t
id|finished
suffix:semicolon
DECL|member|wait
r_int
id|wait
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|call_lock
r_static
id|spinlock_t
id|call_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|call_data
r_static
r_struct
id|call_data_struct
op_star
id|call_data
suffix:semicolon
r_extern
r_int
r_int
id|xcall_call_function
suffix:semicolon
DECL|function|smp_call_function
r_int
id|smp_call_function
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|nonatomic
comma
r_int
id|wait
)paren
(brace
r_struct
id|call_data_struct
id|data
suffix:semicolon
r_int
id|cpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus
)paren
r_return
l_int|0
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.finished
comma
l_int|0
)paren
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
id|call_data
op_assign
op_amp
id|data
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_call_function
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Wait for other cpus to complete function or at&n;&t; * least snap the call data.&n;&t; */
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
op_ne
id|cpus
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
op_le
l_int|0
)paren
r_goto
id|out_timeout
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_timeout
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;XCALL: Remote cpus not responding, ncpus=%d finished=%d&bslash;n&quot;
comma
id|smp_num_cpus
op_minus
l_int|1
comma
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_call_function_client
r_void
id|smp_call_function_client
c_func
(paren
r_void
)paren
(brace
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
op_assign
id|call_data-&gt;func
suffix:semicolon
r_void
op_star
id|info
op_assign
id|call_data-&gt;info
suffix:semicolon
r_if
c_cond
(paren
id|call_data-&gt;wait
)paren
(brace
multiline_comment|/* let initiator proceed only after completion */
id|func
c_func
(paren
id|info
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* let initiator proceed after getting data */
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
id|func
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
r_extern
r_int
r_int
id|xcall_flush_tlb_page
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_mm
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_range
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_all
suffix:semicolon
r_extern
r_int
r_int
id|xcall_tlbcachesync
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_cache_all
suffix:semicolon
r_extern
r_int
r_int
id|xcall_report_regs
suffix:semicolon
r_extern
r_int
r_int
id|xcall_receive_signal
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_dcache_page_cheetah
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_dcache_page_spitfire
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
r_extern
id|atomic_t
id|dcpage_flushes
suffix:semicolon
r_extern
id|atomic_t
id|dcpage_flushes_xcall
suffix:semicolon
macro_line|#endif
DECL|function|__local_flush_dcache_page
r_static
id|__inline__
r_void
id|__local_flush_dcache_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
macro_line|#if (L1DCACHE_SIZE &gt; PAGE_SIZE)
id|__flush_dcache_page
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
comma
(paren
(paren
id|tlb_type
op_eq
id|spitfire
)paren
op_logical_and
id|page-&gt;mapping
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
l_int|NULL
op_logical_and
id|tlb_type
op_eq
id|spitfire
)paren
id|__flush_icache_page
c_func
(paren
id|__pa
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|smp_flush_dcache_page_impl
r_void
id|smp_flush_dcache_page_impl
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1UL
op_lshift
id|cpu
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|__local_flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cpu_present_map
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
id|u64
id|data0
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_spitfire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
l_int|NULL
)paren
id|data0
op_or_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
l_int|32
)paren
suffix:semicolon
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
)paren
comma
(paren
id|u64
)paren
id|page
op_member_access_from_pointer
r_virtual
comma
id|mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_cheetah
)paren
suffix:semicolon
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
)paren
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes_xcall
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
DECL|function|flush_dcache_page_all
r_void
id|flush_dcache_page_all
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
r_int
id|mask
op_assign
id|cpu_present_map
op_amp
op_complement
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|u64
id|data0
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mask
op_eq
l_int|0UL
)paren
r_goto
id|flush_self
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_spitfire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
l_int|NULL
)paren
id|data0
op_or_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
l_int|32
)paren
suffix:semicolon
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
)paren
comma
(paren
id|u64
)paren
id|page
op_member_access_from_pointer
r_virtual
comma
id|mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_cheetah
)paren
suffix:semicolon
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|page
op_member_access_from_pointer
r_virtual
)paren
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes_xcall
)paren
suffix:semicolon
macro_line|#endif
id|flush_self
suffix:colon
id|__local_flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_receive_signal
r_void
id|smp_receive_signal
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1UL
op_lshift
id|cpu
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpu_present_map
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
id|u64
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
op_amp
id|xcall_receive_signal
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
r_else
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|smp_report_regs
r_void
id|smp_report_regs
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_report_regs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_cache_all
r_void
id|smp_flush_cache_all
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_cache_all
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__flush_cache_all
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_tlb_all
r_void
id|smp_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_all
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that the window frames of the user have been flushed&n; * to the stack before we get here because all callers of us&n; * are flush_tlb_*() routines, and these run after flush_cache_*()&n; * which performs the flushw.&n; *&n; * The SMP TLB coherency scheme we use works as follows:&n; *&n; * 1) mm-&gt;cpu_vm_mask is a bit mask of which cpus an address&n; *    space has (potentially) executed on, this is the heuristic&n; *    we use to avoid doing cross calls.&n; *&n; *    Also, for flushing from kswapd and also for clones, we&n; *    use cpu_vm_mask as the list of cpus to make run the TLB.&n; *&n; * 2) TLB context numbers are shared globally across all processors&n; *    in the system, this allows us to play several games to avoid&n; *    cross calls.&n; *&n; *    One invariant is that when a cpu switches to a process, and&n; *    that processes tsk-&gt;active_mm-&gt;cpu_vm_mask does not have the&n; *    current cpu&squot;s bit set, that tlb context is flushed locally.&n; *&n; *    If the address space is non-shared (ie. mm-&gt;count == 1) we avoid&n; *    cross calls when we want to flush the currently running process&squot;s&n; *    tlb state.  This is done by clearing all cpu bits except the current&n; *    processor&squot;s in current-&gt;active_mm-&gt;cpu_vm_mask and performing the&n; *    flush locally only.  This will force any subsequent cpus which run&n; *    this task to flush the context from the local tlb if the process&n; *    migrates to another cpu (again).&n; *&n; * 3) For shared address spaces (threads) and swapping we bite the&n; *    bullet for most cases and perform the cross call (but only to&n; *    the cpus listed in cpu_vm_mask).&n; *&n; *    The performance gain from &quot;optimizing&quot; away the cross call for threads is&n; *    questionable (in theory the big win for threads is the massive sharing of&n; *    address space state across processors).&n; */
DECL|function|smp_flush_tlb_mm
r_void
id|smp_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/*&n;         * This code is called from two places, dup_mmap and exit_mmap. In the&n;         * former case, we really need a flush. In the later case, the callers&n;         * are single threaded exec_mmap (really need a flush), multithreaded&n;         * exec_mmap case (do not need to flush, since the caller gets a new&n;         * context via activate_mm), and all other callers of mmput() whence&n;         * the flush can be optimized since the associated threads are dead and&n;         * the mm is being torn down (__exit_mm and other mmput callers) or the&n;         * owning thread is dissociating itself from the mm. The&n;         * (atomic_read(&amp;mm-&gt;mm_users) == 0) check ensures real work is done&n;         * for single thread exec and dup_mmap cases. An alternate check might&n;         * have been (current-&gt;mm != mm).&n;         *                                              Kanoj Sarcar&n;         */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* See smp_flush_tlb_page for info about this. */
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_flush_tlb_mm
comma
id|ctx
comma
l_int|0
comma
l_int|0
comma
id|mm-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_mm
c_func
(paren
id|ctx
comma
id|SECONDARY_CONTEXT
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_flush_tlb_range
r_void
id|smp_flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|PAGE_ALIGN
c_func
(paren
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_flush_tlb_range
comma
id|ctx
comma
id|start
comma
id|end
comma
id|mm-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_range
c_func
(paren
id|ctx
comma
id|start
comma
id|SECONDARY_CONTEXT
comma
id|end
comma
id|PAGE_SIZE
comma
(paren
id|end
op_minus
id|start
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_flush_tlb_page
r_void
id|smp_flush_tlb_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|page
)paren
(brace
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* By virtue of being the current address space, and&n;&t;&t;&t; * having the only reference to it, the following operation&n;&t;&t;&t; * is safe.&n;&t;&t;&t; *&n;&t;&t;&t; * It would not be a win to perform the xcall tlb flush in&n;&t;&t;&t; * this case, because even if we switch back to one of the&n;&t;&t;&t; * other processors in cpu_vm_mask it is almost certain that&n;&t;&t;&t; * all TLB entries for this context will be replaced by the&n;&t;&t;&t; * time that happens.&n;&t;&t;&t; */
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* By virtue of running under the mm-&gt;page_table_lock,&n;&t;&t;&t; * and mmu_context.h:switch_mm doing the same, the following&n;&t;&t;&t; * operation is safe.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mm-&gt;cpu_vm_mask
op_eq
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
multiline_comment|/* OK, we have to actually perform the cross call.  Most likely&n;&t;&t; * this is a cloned mm or kswapd is kicking out pages for a task&n;&t;&t; * which has run recently on another cpu.&n;&t;&t; */
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_flush_tlb_page
comma
id|ctx
comma
id|page
comma
l_int|0
comma
id|mm-&gt;cpu_vm_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mm-&gt;cpu_vm_mask
op_amp
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
)paren
r_return
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_page
c_func
(paren
id|ctx
comma
id|page
comma
id|SECONDARY_CONTEXT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Process migration IPIs. */
r_extern
r_int
r_int
id|xcall_migrate_task
suffix:semicolon
DECL|variable|migration_lock
r_static
id|spinlock_t
id|migration_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|new_task
r_static
id|task_t
op_star
id|new_task
suffix:semicolon
DECL|function|smp_migrate_task
r_void
id|smp_migrate_task
c_func
(paren
r_int
id|cpu
comma
id|task_t
op_star
id|p
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1UL
op_lshift
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|smp_processors_ready
op_logical_and
(paren
id|cpu_present_map
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
id|u64
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
op_amp
id|xcall_migrate_task
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|migration_lock
)paren
suffix:semicolon
id|new_task
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
r_else
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Called at PIL level 1. */
DECL|function|smp_task_migration_interrupt
id|asmlinkage
r_void
id|smp_task_migration_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|task_t
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|PIL_MIGRATE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|p
op_assign
id|new_task
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|migration_lock
)paren
suffix:semicolon
id|sched_task_migrated
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* CPU capture. */
multiline_comment|/* #define CAPTURE_DEBUG */
r_extern
r_int
r_int
id|xcall_capture
suffix:semicolon
DECL|variable|smp_capture_depth
r_static
id|atomic_t
id|smp_capture_depth
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|smp_capture_registry
r_static
id|atomic_t
id|smp_capture_registry
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|penguins_are_doing_time
r_static
r_int
r_int
id|penguins_are_doing_time
op_assign
l_int|0
suffix:semicolon
DECL|function|smp_capture
r_void
id|smp_capture
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
id|result
op_assign
id|__atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|smp_capture_depth
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
(brace
r_int
id|ncpus
op_assign
id|smp_num_cpus
suffix:semicolon
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Sending penguins to jail...&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_capture
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|smp_capture_registry
)paren
op_ne
id|ncpus
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
DECL|function|smp_release
r_void
id|smp_release
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|smp_capture_depth
)paren
)paren
(brace
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Giving pardon to imprisoned penguins&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Imprisoned penguins run with %pil == 15, but PSTATE_IE set, so they&n; * can service tlb flush xcalls...&n; */
r_extern
r_void
id|prom_world
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|save_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|restore_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
DECL|function|smp_penguin_jailcell
r_void
id|smp_penguin_jailcell
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|global_save
(braket
l_int|24
)braket
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flushw&quot;
)paren
suffix:semicolon
id|save_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #StoreStore&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|penguins_are_doing_time
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|restore_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|xcall_promstop
suffix:semicolon
DECL|function|smp_promstop_others
r_void
id|smp_promstop_others
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_promstop
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_void
id|sparc64_do_profile
c_func
(paren
r_int
r_int
id|pc
comma
r_int
r_int
id|o7
)paren
suffix:semicolon
DECL|variable|current_tick_offset
r_static
r_int
r_int
id|current_tick_offset
suffix:semicolon
DECL|macro|prof_multiplier
mdefine_line|#define prof_multiplier(__cpu)&t;&t;cpu_data[(__cpu)].multiplier
DECL|macro|prof_counter
mdefine_line|#define prof_counter(__cpu)&t;&t;cpu_data[(__cpu)].counter
DECL|function|smp_percpu_timer_interrupt
r_void
id|smp_percpu_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|compare
comma
id|tick
comma
id|pstate
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|user
op_assign
id|user_mode
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for level 14 softint.&n;&t; */
(brace
r_int
r_int
id|tick_mask
suffix:semicolon
r_if
c_cond
(paren
id|SPARC64_USE_STICK
)paren
id|tick_mask
op_assign
(paren
l_int|1UL
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|tick_mask
op_assign
(paren
l_int|1UL
op_lshift
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|get_softint
c_func
(paren
)paren
op_amp
id|tick_mask
)paren
)paren
(brace
r_extern
r_void
id|handler_irq
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
id|handler_irq
c_func
(paren
l_int|14
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_softint
c_func
(paren
id|tick_mask
)paren
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
id|sparc64_do_profile
c_func
(paren
id|regs-&gt;tpc
comma
id|regs-&gt;u_regs
(braket
id|UREG_RETPC
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|prof_counter
c_func
(paren
id|cpu
)paren
)paren
(brace
r_if
c_cond
(paren
id|cpu
op_eq
id|boot_cpu_id
)paren
(brace
id|irq_enter
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|timer_tick_interrupt
c_func
(paren
id|regs
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
)brace
id|update_process_times
c_func
(paren
id|user
)paren
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
multiline_comment|/* Guarentee that the following sequences execute&n;&t;&t; * uninterrupted.&n;&t;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Workaround for Spitfire Errata (#54 I think??), I discovered&n;&t;&t; * this via Sun BugID 4008234, mentioned in Solaris-2.5.1 patch&n;&t;&t; * number 103640.&n;&t;&t; *&n;&t;&t; * On Blackbird writes to %tick_cmpr can fail, the&n;&t;&t; * workaround seems to be to execute the wr instruction&n;&t;&t; * at the start of an I-cache line, and perform a dummy&n;&t;&t; * read back from %tick_cmpr right after writing to it. -DaveM&n;&t;&t; *&n;&t;&t; * Just to be anal we add a workaround for Spitfire&n;&t;&t; * Errata 50 by preventing pipeline bypasses on the&n;&t;&t; * final read of the %tick register into a compare&n;&t;&t; * instruction.  The Errata 50 description states&n;&t;&t; * that %tick is not prone to this bug, but I am not&n;&t;&t; * taking any chances.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SPARC64_USE_STICK
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rd&t;%%tick_cmpr, %0&bslash;n&bslash;t&quot;
l_string|&quot;ba,pt&t;%%xcc, 1f&bslash;n&bslash;t&quot;
l_string|&quot; add&t;%0, %2, %0&bslash;n&bslash;t&quot;
l_string|&quot;.align&t;64&bslash;n&quot;
l_string|&quot;1: wr&t;%0, 0x0, %%tick_cmpr&bslash;n&bslash;t&quot;
l_string|&quot;rd&t;%%tick_cmpr, %%g0&bslash;n&bslash;t&quot;
l_string|&quot;rd&t;%%tick, %1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%1, %1&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|compare
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tick
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rd&t;%%asr25, %0&bslash;n&bslash;t&quot;
l_string|&quot;add&t;%0, %2, %0&bslash;n&bslash;t&quot;
l_string|&quot;wr&t;%0, 0x0, %%asr25&bslash;n&bslash;t&quot;
l_string|&quot;rd&t;%%asr24, %1&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|compare
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tick
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tick
op_ge
id|compare
)paren
suffix:semicolon
)brace
DECL|function|smp_setup_percpu_timer
r_static
r_void
id|__init
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|pstate
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Guarentee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Workaround for Spitfire Errata (#54 I think??), I discovered&n;&t; * this via Sun BugID 4008234, mentioned in Solaris-2.5.1 patch&n;&t; * number 103640.&n;&t; *&n;&t; * On Blackbird writes to %tick_cmpr can fail, the&n;&t; * workaround seems to be to execute the wr instruction&n;&t; * at the start of an I-cache line, and perform a dummy&n;&t; * read back from %tick_cmpr right after writing to it. -DaveM&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SPARC64_USE_STICK
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|tick_cmpr
id|rd
op_mod
op_mod
id|tick_cmpr
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|asr24
comma
op_mod
op_mod
id|g1
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|asr25
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|smp_tick_init
r_void
id|__init
id|smp_tick_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|boot_cpu_id
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|current_tick_offset
op_assign
id|timer_tick_offset
suffix:semicolon
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linux_num_cpus
suffix:semicolon
id|i
op_increment
)paren
id|cpu_present_map
op_or_assign
(paren
l_int|1UL
op_lshift
id|linux_cpus
(braket
id|i
)braket
dot
id|mid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|__cpu_logical_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|__cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_cpu_nodes
(braket
id|boot_cpu_id
)braket
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
id|prof_counter
c_func
(paren
id|boot_cpu_id
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|boot_cpu_id
)paren
op_assign
l_int|1
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|variable|cache_decay_ticks
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
r_extern
r_int
r_int
id|cheetah_tune_scheduling
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|timer_ticks_per_usec_quotient
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|__init
id|smp_tune_scheduling
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|orig_flush_base
comma
id|flush_base
comma
id|flags
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|ecache_size
comma
id|order
suffix:semicolon
id|cycles_t
id|tick1
comma
id|tick2
comma
id|raw
suffix:semicolon
multiline_comment|/* Approximate heuristic for SMP scheduling.  It is an&n;&t; * estimation of the time it takes to flush the L2 cache&n;&t; * on the local processor.&n;&t; *&n;&t; * The ia32 chooses to use the L1 cache flush time instead,&n;&t; * and I consider this complete nonsense.  The Ultra can service&n;&t; * a miss to the L1 with a hit to the L2 in 7 or 8 cycles, and&n;&t; * L2 misses are what create extra bus traffic (ie. the &quot;cost&quot;&n;&t; * of moving a process from one cpu to another).&n;&t; */
id|printk
c_func
(paren
l_string|&quot;SMP: Calibrating ecache flush... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|cheetah
)paren
(brace
id|cacheflush_time
op_assign
id|cheetah_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
r_goto
id|report
suffix:semicolon
)brace
id|ecache_size
op_assign
id|prom_getintdefault
c_func
(paren
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
comma
l_string|&quot;ecache-size&quot;
comma
(paren
l_int|512
op_star
l_int|1024
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecache_size
OG
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
id|ecache_size
op_assign
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|orig_flush_base
op_assign
id|flush_base
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
op_assign
id|get_order
c_func
(paren
id|ecache_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_base
op_ne
l_int|0UL
)paren
(brace
id|__save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Scan twice the size once just to get the TLB entries&n;&t;&t; * loaded and make sure the second scan measures pure misses.&n;&t;&t; */
r_for
c_loop
(paren
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|flush_base
suffix:semicolon
(paren
(paren
r_int
r_int
)paren
id|p
)paren
OL
(paren
id|flush_base
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|p
op_add_assign
(paren
l_int|64
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Now the real measurement. */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|b
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|rd
op_mod
op_mod
id|tick
comma
op_mod
l_int|0
dot
id|align
l_int|64
l_int|1
suffix:colon
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x000
)braket
comma
op_mod
op_mod
id|g1
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x040
)braket
comma
op_mod
op_mod
id|g2
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x080
)braket
comma
op_mod
op_mod
id|g3
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x0c0
)braket
comma
op_mod
op_mod
id|g5
id|add
op_mod
l_int|2
comma
l_int|0x100
comma
op_mod
l_int|2
id|cmp
op_mod
l_int|2
comma
op_mod
l_int|4
id|bne
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_int|1
id|b
id|nop
id|rd
op_mod
op_mod
id|tick
comma
op_mod
l_int|1
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tick1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tick2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|flush_base
)paren
suffix:colon
l_string|&quot;2&quot;
(paren
id|flush_base
)paren
comma
l_string|&quot;r&quot;
(paren
id|flush_base
op_plus
id|ecache_size
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;g5&quot;
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|raw
op_assign
(paren
id|tick2
op_minus
id|tick1
)paren
suffix:semicolon
multiline_comment|/* Dampen it a little, considering two processes&n;&t;&t; * sharing the cache and fitting.&n;&t;&t; */
id|cacheflush_time
op_assign
(paren
id|raw
op_minus
(paren
id|raw
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|orig_flush_base
comma
id|order
)paren
suffix:semicolon
)brace
r_else
(brace
id|cacheflush_time
op_assign
(paren
(paren
id|ecache_size
op_lshift
l_int|2
)paren
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|report
suffix:colon
multiline_comment|/* Convert cpu ticks to jiffie ticks. */
id|cache_decay_ticks
op_assign
(paren
(paren
r_int
)paren
id|cacheflush_time
op_star
id|timer_ticks_per_usec_quotient
)paren
suffix:semicolon
id|cache_decay_ticks
op_rshift_assign
l_int|32UL
suffix:semicolon
id|cache_decay_ticks
op_assign
(paren
id|cache_decay_ticks
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using heuristic of %ld cycles, %ld ticks.&bslash;n&quot;
comma
id|cacheflush_time
comma
id|cache_decay_ticks
)paren
suffix:semicolon
)brace
multiline_comment|/* /proc/profile writes can call this, don&squot;t __init it please. */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|multiplier
)paren
op_logical_or
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
OL
l_int|1000
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
id|prof_multiplier
c_func
(paren
id|i
)paren
op_assign
id|multiplier
suffix:semicolon
)brace
id|current_tick_offset
op_assign
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
