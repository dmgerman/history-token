multiline_comment|/* smp.c: Sparc64 SMP support.&n; *&n; * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;asm/head.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/cpudata.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/starfire.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
r_extern
r_int
id|linux_num_cpus
suffix:semicolon
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Please don&squot;t make this stuff initdata!!!  --DaveM */
DECL|variable|boot_cpu_id
r_static
r_int
r_char
id|boot_cpu_id
suffix:semicolon
DECL|variable|cpu_online_map
id|cpumask_t
id|cpu_online_map
op_assign
id|CPU_MASK_NONE
suffix:semicolon
DECL|variable|phys_cpu_present_map
id|cpumask_t
id|phys_cpu_present_map
op_assign
id|CPU_MASK_NONE
suffix:semicolon
DECL|variable|smp_commenced_mask
r_static
id|cpumask_t
id|smp_commenced_mask
suffix:semicolon
DECL|variable|cpu_callout_map
r_static
id|cpumask_t
id|cpu_callout_map
suffix:semicolon
DECL|function|smp_info
r_void
id|smp_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;State:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;CPU%d:&bslash;t&bslash;tonline&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_bogo
r_void
id|smp_bogo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Cpu%dBogo&bslash;t: %lu.%02lu&bslash;n&quot;
l_string|&quot;Cpu%dClkTck&bslash;t: %016lx&bslash;n&quot;
comma
id|i
comma
id|cpu_data
c_func
(paren
id|i
)paren
dot
id|udelay_val
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|cpu_data
c_func
(paren
id|i
)paren
dot
id|udelay_val
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
comma
id|i
comma
id|cpu_data
c_func
(paren
id|i
)paren
dot
id|clock_tick
)paren
suffix:semicolon
)brace
DECL|function|smp_store_cpu_info
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_int
id|cpu_node
suffix:semicolon
multiline_comment|/* multiplier and counter set by&n;&t;   smp_setup_percpu_timer()  */
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
id|cpu_find_by_mid
c_func
(paren
id|id
comma
op_amp
id|cpu_node
)paren
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|clock_tick
op_assign
id|prom_getintdefault
c_func
(paren
id|cpu_node
comma
l_string|&quot;clock-frequency&quot;
comma
l_int|0
)paren
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|pgcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|pte_cache
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|pte_cache
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|pgdcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|pgd_cache
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
c_func
(paren
id|id
)paren
dot
id|idle_volume
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|callin_flag
r_static
r_volatile
r_int
r_int
id|callin_flag
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|inherit_locked_prom_mappings
c_func
(paren
r_int
id|save_p
)paren
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|inherit_locked_prom_mappings
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|smp_setup_percpu_timer
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #Sync&bslash;n&bslash;t&quot;
l_string|&quot;flush  %%g6&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear this or we will die instantly when we&n;&t; * schedule back to this idler...&n;&t; */
id|clear_thread_flag
c_func
(paren
id|TIF_NEWCHILD
)paren
suffix:semicolon
multiline_comment|/* Attach to the address space of init_task. */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpuid
comma
id|smp_commenced_mask
)paren
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|cpu_online_map
)paren
suffix:semicolon
)brace
DECL|function|cpu_panic
r_void
id|cpu_panic
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Returns from cpu_idle!&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;SMP bolixed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|current_tick_offset
r_static
r_int
r_int
id|current_tick_offset
suffix:semicolon
multiline_comment|/* This tick register synchronization scheme is taken entirely from&n; * the ia64 port, see arch/ia64/kernel/smpboot.c for details and credit.&n; *&n; * The only change I&squot;ve made is to rework it so that the master&n; * initiates the synchonization instead of the slave. -DaveM&n; */
DECL|macro|MASTER
mdefine_line|#define MASTER&t;0
DECL|macro|SLAVE
mdefine_line|#define SLAVE&t;(SMP_CACHE_BYTES/sizeof(unsigned long))
DECL|macro|NUM_ROUNDS
mdefine_line|#define NUM_ROUNDS&t;64&t;/* magic value */
DECL|macro|NUM_ITERS
mdefine_line|#define NUM_ITERS&t;5&t;/* likewise */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|itc_sync_lock
)paren
suffix:semicolon
DECL|variable|go
r_static
r_int
r_int
id|go
(braket
id|SLAVE
op_plus
l_int|1
)braket
suffix:semicolon
DECL|macro|DEBUG_TICK_SYNC
mdefine_line|#define DEBUG_TICK_SYNC&t;0
DECL|function|get_delta
r_static
r_inline
r_int
id|get_delta
(paren
r_int
op_star
id|rt
comma
r_int
op_star
id|master
)paren
(brace
r_int
r_int
id|best_t0
op_assign
l_int|0
comma
id|best_t1
op_assign
op_complement
l_int|0UL
comma
id|best_tm
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tcenter
comma
id|t0
comma
id|t1
comma
id|tm
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ITERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t0
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
id|go
(braket
id|MASTER
)braket
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|tm
op_assign
id|go
(braket
id|SLAVE
)braket
)paren
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|go
(braket
id|SLAVE
)braket
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore&quot;
)paren
suffix:semicolon
id|t1
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t1
op_minus
id|t0
OL
id|best_t1
op_minus
id|best_t0
)paren
id|best_t0
op_assign
id|t0
comma
id|best_t1
op_assign
id|t1
comma
id|best_tm
op_assign
id|tm
suffix:semicolon
)brace
op_star
id|rt
op_assign
id|best_t1
op_minus
id|best_t0
suffix:semicolon
op_star
id|master
op_assign
id|best_tm
op_minus
id|best_t0
suffix:semicolon
multiline_comment|/* average best_t0 and best_t1 without overflow: */
id|tcenter
op_assign
(paren
id|best_t0
op_div
l_int|2
op_plus
id|best_t1
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_t0
op_mod
l_int|2
op_plus
id|best_t1
op_mod
l_int|2
op_eq
l_int|2
)paren
id|tcenter
op_increment
suffix:semicolon
r_return
id|tcenter
op_minus
id|best_tm
suffix:semicolon
)brace
DECL|function|smp_synchronize_tick_client
r_void
id|smp_synchronize_tick_client
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|delta
comma
id|adj
comma
id|adjust_latency
op_assign
l_int|0
comma
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
comma
id|rt
comma
id|master_time_stamp
comma
id|bound
suffix:semicolon
macro_line|#if DEBUG_TICK_SYNC
r_struct
(brace
r_int
id|rt
suffix:semicolon
multiline_comment|/* roundtrip time */
r_int
id|master
suffix:semicolon
multiline_comment|/* master&squot;s timestamp */
r_int
id|diff
suffix:semicolon
multiline_comment|/* difference between midpoint and master&squot;s timestamp */
r_int
id|lat
suffix:semicolon
multiline_comment|/* estimate of itc adjustment latency */
)brace
id|t
(braket
id|NUM_ROUNDS
)braket
suffix:semicolon
macro_line|#endif
id|go
(braket
id|MASTER
)braket
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|go
(braket
id|MASTER
)braket
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ROUNDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|delta
op_assign
id|get_delta
c_func
(paren
op_amp
id|rt
comma
op_amp
id|master_time_stamp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_eq
l_int|0
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* let&squot;s lock on to this... */
id|bound
op_assign
id|rt
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|adjust_latency
op_add_assign
op_minus
id|delta
suffix:semicolon
id|adj
op_assign
op_minus
id|delta
op_plus
id|adjust_latency
op_div
l_int|4
suffix:semicolon
)brace
r_else
id|adj
op_assign
op_minus
id|delta
suffix:semicolon
id|tick_ops
op_member_access_from_pointer
id|add_tick
c_func
(paren
id|adj
comma
id|current_tick_offset
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG_TICK_SYNC
id|t
(braket
id|i
)braket
dot
id|rt
op_assign
id|rt
suffix:semicolon
id|t
(braket
id|i
)braket
dot
id|master
op_assign
id|master_time_stamp
suffix:semicolon
id|t
(braket
id|i
)braket
dot
id|diff
op_assign
id|delta
suffix:semicolon
id|t
(braket
id|i
)braket
dot
id|lat
op_assign
id|adjust_latency
op_div
l_int|4
suffix:semicolon
macro_line|#endif
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if DEBUG_TICK_SYNC
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ROUNDS
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;rt=%5ld master=%5ld diff=%5ld adjlat=%5ld&bslash;n&quot;
comma
id|t
(braket
id|i
)braket
dot
id|rt
comma
id|t
(braket
id|i
)braket
dot
id|master
comma
id|t
(braket
id|i
)braket
dot
id|diff
comma
id|t
(braket
id|i
)braket
dot
id|lat
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CPU %d: synchronized TICK with master CPU (last diff %ld cycles,&quot;
l_string|&quot;maxerr %lu cycles)&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|delta
comma
id|rt
)paren
suffix:semicolon
)brace
r_static
r_void
id|smp_start_sync_tick_client
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
DECL|function|smp_synchronize_one_tick
r_static
r_void
id|smp_synchronize_one_tick
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
r_int
id|flags
comma
id|i
suffix:semicolon
id|go
(braket
id|MASTER
)braket
op_assign
l_int|0
suffix:semicolon
id|smp_start_sync_tick_client
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* wait for client to be ready */
r_while
c_loop
(paren
op_logical_neg
id|go
(braket
id|MASTER
)braket
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
multiline_comment|/* now let the client proceed into his loop */
id|go
(braket
id|MASTER
)braket
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|itc_sync_lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ROUNDS
op_star
id|NUM_ITERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|go
(braket
id|MASTER
)braket
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|go
(braket
id|MASTER
)braket
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore&quot;
)paren
suffix:semicolon
id|go
(braket
id|SLAVE
)braket
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad&quot;
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|itc_sync_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|sparc64_cpu_startup
suffix:semicolon
multiline_comment|/* The OBP cpu startup callback truncates the 3rd arg cookie to&n; * 32-bits (I think) so to be safe we have it read the pointer&n; * contained here so we work on &gt;4GB machines. -DaveM&n; */
DECL|variable|cpu_new_thread
r_static
r_struct
id|thread_info
op_star
id|cpu_new_thread
op_assign
l_int|NULL
suffix:semicolon
DECL|function|smp_boot_one_cpu
r_static
r_int
id|__devinit
id|smp_boot_one_cpu
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
r_int
r_int
id|entry
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|sparc64_cpu_startup
)paren
suffix:semicolon
r_int
r_int
id|cookie
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|cpu_new_thread
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|timeout
comma
id|ret
comma
id|cpu_node
suffix:semicolon
id|p
op_assign
id|fork_idle
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|0
suffix:semicolon
id|cpu_new_thread
op_assign
id|p-&gt;thread_info
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
suffix:semicolon
id|cpu_find_by_mid
c_func
(paren
id|cpu
comma
op_amp
id|cpu_node
)paren
suffix:semicolon
id|prom_startcpu
c_func
(paren
id|cpu_node
comma
id|entry
comma
id|cookie
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|5000000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|callin_flag
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callin_flag
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Processor %d is stuck.&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|cpu_clear
c_func
(paren
id|cpu
comma
id|cpu_callout_map
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
id|cpu_new_thread
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|spitfire_xcall_helper
r_static
r_void
id|spitfire_xcall_helper
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|u64
id|pstate
comma
r_int
r_int
id|cpu
)paren
(brace
id|u64
id|result
comma
id|target
suffix:semicolon
r_int
id|stuck
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
)paren
(brace
multiline_comment|/* map to real upaid */
id|cpu
op_assign
(paren
(paren
(paren
id|cpu
op_amp
l_int|0x3c
)paren
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|cpu
op_amp
l_int|0x40
)paren
op_rshift
l_int|4
)paren
op_or
(paren
id|cpu
op_amp
l_int|0x3
)paren
)paren
suffix:semicolon
)brace
id|target
op_assign
(paren
id|cpu
op_lshift
l_int|14
)paren
op_or
l_int|0x70
suffix:semicolon
id|again
suffix:colon
multiline_comment|/* Ok, this is the real Spitfire Errata #54.&n;&t; * One must read back from a UDB internal register&n;&t; * after writes to the UDB interrupt dispatch, but&n;&t; * before the membar Sync for that write.&n;&t; * So we use the high UDB control register (ASI 0x7f,&n;&t; * ADDR 0x20) for the dummy read. -DaveM&n;&t; */
id|tmp
op_assign
l_int|0x40
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%1, %2, %%pstate&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%4, [%0] %3&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%5, [%0+%8] %3&bslash;n&bslash;t&quot;
l_string|&quot;add&t;%0, %8, %0&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%6, [%0+%8] %3&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%%g0, [%7] %3&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;0x20, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;ldxa&t;[%%g1] 0x7f, %%g0&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
comma
l_string|&quot;r&quot;
(paren
id|data0
)paren
comma
l_string|&quot;r&quot;
(paren
id|data1
)paren
comma
l_string|&quot;r&quot;
(paren
id|data2
)paren
comma
l_string|&quot;r&quot;
(paren
id|target
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x10
)paren
comma
l_string|&quot;0&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTE: PSTATE_IE is still clear. */
id|stuck
op_assign
l_int|100000
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_DISPATCH_STAT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stuck
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
op_amp
l_int|0x1
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: mondo stuckage result[%016lx]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
DECL|function|spitfire_xcall_deliver
r_static
id|__inline__
r_void
id|spitfire_xcall_deliver
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|cpumask_t
id|mask
)paren
(brace
id|u64
id|pstate
suffix:semicolon
r_int
id|i
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|for_each_cpu_mask
c_func
(paren
id|i
comma
id|mask
)paren
id|spitfire_xcall_helper
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|pstate
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Cheetah now allows to send the whole 64-bytes of data in the interrupt&n; * packet, but we have no use for that.  However we do take advantage of&n; * the new pipelining feature (ie. dispatch to multiple cpus simultaneously).&n; */
DECL|function|cheetah_xcall_deliver
r_static
r_void
id|cheetah_xcall_deliver
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|cpumask_t
id|mask
)paren
(brace
id|u64
id|pstate
comma
id|ver
suffix:semicolon
r_int
id|nack_busy_id
comma
id|is_jalapeno
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|mask
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Unfortunately, someone at Sun had the brilliant idea to make the&n;&t; * busy/nack fields hard-coded by ITID number for this Ultra-III&n;&t; * derivative processor.&n;&t; */
id|__asm__
(paren
l_string|&quot;rdpr %%ver, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ver
)paren
)paren
suffix:semicolon
id|is_jalapeno
op_assign
(paren
(paren
id|ver
op_rshift
l_int|32
)paren
op_eq
l_int|0x003e0016
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|retry
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, %1, %%pstate&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup the dispatch data registers. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa&t;%0, [%3] %6&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%1, [%4] %6&bslash;n&bslash;t&quot;
l_string|&quot;stxa&t;%2, [%5] %6&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|data0
)paren
comma
l_string|&quot;r&quot;
(paren
id|data1
)paren
comma
l_string|&quot;r&quot;
(paren
id|data2
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x40
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x50
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x60
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
)paren
suffix:semicolon
id|nack_busy_id
op_assign
l_int|0
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|for_each_cpu_mask
c_func
(paren
id|i
comma
id|mask
)paren
(brace
id|u64
id|target
op_assign
(paren
id|i
op_lshift
l_int|14
)paren
op_or
l_int|0x70
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_jalapeno
)paren
id|target
op_or_assign
(paren
id|nack_busy_id
op_lshift
l_int|24
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa&t;%%g0, [%0] %1&bslash;n&bslash;t&quot;
l_string|&quot;membar&t;#Sync&bslash;n&bslash;t&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|target
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_W
)paren
)paren
suffix:semicolon
id|nack_busy_id
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now, poll for completion. */
(brace
id|u64
id|dispatch_stat
suffix:semicolon
r_int
id|stuck
suffix:semicolon
id|stuck
op_assign
l_int|100000
op_star
id|nack_busy_id
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa&t;[%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dispatch_stat
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_DISPATCH_STAT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dispatch_stat
op_eq
l_int|0UL
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|stuck
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dispatch_stat
op_amp
l_int|0x5555555555555555UL
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dispatch_stat
op_amp
op_complement
(paren
l_int|0x5555555555555555UL
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Busy bits will not clear, continue instead&n;&t;&t;&t; * of freezing up on this cpu.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: mondo stuckage result[%016lx]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|dispatch_stat
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
comma
id|this_busy_nack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Delay some random time with interrupts enabled&n;&t;&t;&t; * to prevent deadlock.&n;&t;&t;&t; */
id|udelay
c_func
(paren
l_int|2
op_star
id|nack_busy_id
)paren
suffix:semicolon
multiline_comment|/* Clear out the mask bits for cpus which did not&n;&t;&t;&t; * NACK us.&n;&t;&t;&t; */
id|for_each_cpu_mask
c_func
(paren
id|i
comma
id|mask
)paren
(brace
id|u64
id|check_mask
suffix:semicolon
r_if
c_cond
(paren
id|is_jalapeno
)paren
id|check_mask
op_assign
(paren
l_int|0x2UL
op_lshift
(paren
l_int|2
op_star
id|i
)paren
)paren
suffix:semicolon
r_else
id|check_mask
op_assign
(paren
l_int|0x2UL
op_lshift
id|this_busy_nack
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dispatch_stat
op_amp
id|check_mask
)paren
op_eq
l_int|0
)paren
id|cpu_clear
c_func
(paren
id|i
comma
id|mask
)paren
suffix:semicolon
id|this_busy_nack
op_add_assign
l_int|2
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Send cross call to all processors mentioned in MASK&n; * except self.&n; */
DECL|function|smp_cross_call_masked
r_static
r_void
id|smp_cross_call_masked
c_func
(paren
r_int
r_int
op_star
id|func
comma
id|u32
id|ctx
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|cpumask_t
id|mask
)paren
(brace
id|u64
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
id|ctx
)paren
op_lshift
l_int|32
op_or
(paren
(paren
(paren
id|u64
)paren
id|func
)paren
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
r_int
id|this_cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|cpus_and
c_func
(paren
id|mask
comma
id|mask
comma
id|cpu_online_map
)paren
suffix:semicolon
id|cpu_clear
c_func
(paren
id|this_cpu
comma
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|mask
)paren
suffix:semicolon
r_else
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* NOTE: Caller runs local copy on master. */
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|xcall_sync_tick
suffix:semicolon
DECL|function|smp_start_sync_tick_client
r_static
r_void
id|smp_start_sync_tick_client
c_func
(paren
r_int
id|cpu
)paren
(brace
id|cpumask_t
id|mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_sync_tick
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/* Send cross call to all processors except self. */
DECL|macro|smp_cross_call
mdefine_line|#define smp_cross_call(func, ctx, data1, data2) &bslash;&n;&t;smp_cross_call_masked(func, ctx, data1, data2, cpu_online_map)
DECL|struct|call_data_struct
r_struct
id|call_data_struct
(brace
DECL|member|func
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
suffix:semicolon
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
DECL|member|finished
id|atomic_t
id|finished
suffix:semicolon
DECL|member|wait
r_int
id|wait
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|call_lock
)paren
suffix:semicolon
DECL|variable|call_data
r_static
r_struct
id|call_data_struct
op_star
id|call_data
suffix:semicolon
r_extern
r_int
r_int
id|xcall_call_function
suffix:semicolon
multiline_comment|/*&n; * You must not call this function with disabled interrupts or from a&n; * hardware interrupt handler or from a bottom half handler.&n; */
DECL|function|smp_call_function
r_int
id|smp_call_function
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|nonatomic
comma
r_int
id|wait
)paren
(brace
r_struct
id|call_data_struct
id|data
suffix:semicolon
r_int
id|cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Can deadlock when called with interrupts disabled */
id|WARN_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.finished
comma
l_int|0
)paren
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
id|call_data
op_assign
op_amp
id|data
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_call_function
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Wait for other cpus to complete function or at&n;&t; * least snap the call data.&n;&t; */
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
op_ne
id|cpus
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
op_le
l_int|0
)paren
r_goto
id|out_timeout
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_timeout
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;XCALL: Remote cpus not responding, ncpus=%ld finished=%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1L
comma
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_call_function_client
r_void
id|smp_call_function_client
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
op_assign
id|call_data-&gt;func
suffix:semicolon
r_void
op_star
id|info
op_assign
id|call_data-&gt;info
suffix:semicolon
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_data-&gt;wait
)paren
(brace
multiline_comment|/* let initiator proceed only after completion */
id|func
c_func
(paren
id|info
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* let initiator proceed after getting data */
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
id|func
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
r_extern
r_int
r_int
id|xcall_flush_tlb_mm
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_pending
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_kernel_range
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_all_spitfire
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_all_cheetah
suffix:semicolon
r_extern
r_int
r_int
id|xcall_report_regs
suffix:semicolon
r_extern
r_int
r_int
id|xcall_receive_signal
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_dcache_page_cheetah
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_dcache_page_spitfire
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
r_extern
id|atomic_t
id|dcpage_flushes
suffix:semicolon
r_extern
id|atomic_t
id|dcpage_flushes_xcall
suffix:semicolon
macro_line|#endif
DECL|function|__local_flush_dcache_page
r_static
id|__inline__
r_void
id|__local_flush_dcache_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
macro_line|#if (L1DCACHE_SIZE &gt; PAGE_SIZE)
id|__flush_dcache_page
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
(paren
(paren
id|tlb_type
op_eq
id|spitfire
)paren
op_logical_and
id|page_mapping
c_func
(paren
id|page
)paren
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|page_mapping
c_func
(paren
id|page
)paren
op_ne
l_int|NULL
op_logical_and
id|tlb_type
op_eq
id|spitfire
)paren
id|__flush_icache_page
c_func
(paren
id|__pa
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|smp_flush_dcache_page_impl
r_void
id|smp_flush_dcache_page_impl
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cpu
)paren
(brace
id|cpumask_t
id|mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_int
id|this_cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cpu
op_eq
id|this_cpu
)paren
(brace
id|__local_flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
(brace
r_void
op_star
id|pg_addr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|u64
id|data0
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_spitfire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_mapping
c_func
(paren
id|page
)paren
op_ne
l_int|NULL
)paren
id|data0
op_or_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
l_int|32
)paren
suffix:semicolon
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|pg_addr
)paren
comma
(paren
id|u64
)paren
id|pg_addr
comma
id|mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_cheetah
)paren
suffix:semicolon
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|pg_addr
)paren
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes_xcall
)paren
suffix:semicolon
macro_line|#endif
)brace
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_dcache_page_all
r_void
id|flush_dcache_page_all
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_void
op_star
id|pg_addr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|cpumask_t
id|mask
op_assign
id|cpu_online_map
suffix:semicolon
id|u64
id|data0
suffix:semicolon
r_int
id|this_cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|cpu_clear
c_func
(paren
id|this_cpu
comma
id|mask
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|mask
)paren
)paren
r_goto
id|flush_self
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_spitfire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_mapping
c_func
(paren
id|page
)paren
op_ne
l_int|NULL
)paren
id|data0
op_or_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
l_int|32
)paren
suffix:semicolon
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|pg_addr
)paren
comma
(paren
id|u64
)paren
id|pg_addr
comma
id|mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|data0
op_assign
(paren
(paren
id|u64
)paren
op_amp
id|xcall_flush_dcache_page_cheetah
)paren
suffix:semicolon
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
id|__pa
c_func
(paren
id|pg_addr
)paren
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_DCFLUSH
id|atomic_inc
c_func
(paren
op_amp
id|dcpage_flushes_xcall
)paren
suffix:semicolon
macro_line|#endif
id|flush_self
suffix:colon
id|__local_flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_receive_signal
r_void
id|smp_receive_signal
c_func
(paren
r_int
id|cpu
)paren
(brace
id|cpumask_t
id|mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
(brace
id|u64
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
op_amp
id|xcall_receive_signal
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|spitfire_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
r_else
id|cheetah_xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_receive_signal_client
r_void
id|smp_receive_signal_client
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Just return, rtrap takes care of the rest. */
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
)brace
DECL|function|smp_report_regs
r_void
id|smp_report_regs
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_report_regs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_tlb_all
r_void
id|smp_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tlb_type
op_eq
id|spitfire
)paren
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_all_spitfire
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_else
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_all_cheetah
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that the window frames of the user have been flushed&n; * to the stack before we get here because all callers of us&n; * are flush_tlb_*() routines, and these run after flush_cache_*()&n; * which performs the flushw.&n; *&n; * The SMP TLB coherency scheme we use works as follows:&n; *&n; * 1) mm-&gt;cpu_vm_mask is a bit mask of which cpus an address&n; *    space has (potentially) executed on, this is the heuristic&n; *    we use to avoid doing cross calls.&n; *&n; *    Also, for flushing from kswapd and also for clones, we&n; *    use cpu_vm_mask as the list of cpus to make run the TLB.&n; *&n; * 2) TLB context numbers are shared globally across all processors&n; *    in the system, this allows us to play several games to avoid&n; *    cross calls.&n; *&n; *    One invariant is that when a cpu switches to a process, and&n; *    that processes tsk-&gt;active_mm-&gt;cpu_vm_mask does not have the&n; *    current cpu&squot;s bit set, that tlb context is flushed locally.&n; *&n; *    If the address space is non-shared (ie. mm-&gt;count == 1) we avoid&n; *    cross calls when we want to flush the currently running process&squot;s&n; *    tlb state.  This is done by clearing all cpu bits except the current&n; *    processor&squot;s in current-&gt;active_mm-&gt;cpu_vm_mask and performing the&n; *    flush locally only.  This will force any subsequent cpus which run&n; *    this task to flush the context from the local tlb if the process&n; *    migrates to another cpu (again).&n; *&n; * 3) For shared address spaces (threads) and swapping we bite the&n; *    bullet for most cases and perform the cross call (but only to&n; *    the cpus listed in cpu_vm_mask).&n; *&n; *    The performance gain from &quot;optimizing&quot; away the cross call for threads is&n; *    questionable (in theory the big win for threads is the massive sharing of&n; *    address space state across processors).&n; */
DECL|function|smp_flush_tlb_mm
r_void
id|smp_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/*&n;         * This code is called from two places, dup_mmap and exit_mmap. In the&n;         * former case, we really need a flush. In the later case, the callers&n;         * are single threaded exec_mmap (really need a flush), multithreaded&n;         * exec_mmap case (do not need to flush, since the caller gets a new&n;         * context via activate_mm), and all other callers of mmput() whence&n;         * the flush can be optimized since the associated threads are dead and&n;         * the mm is being torn down (__exit_mm and other mmput callers) or the&n;         * owning thread is dissociating itself from the mm. The&n;         * (atomic_read(&amp;mm-&gt;mm_users) == 0) check ensures real work is done&n;         * for single thread exec and dup_mmap cases. An alternate check might&n;         * have been (current-&gt;mm != mm).&n;         *                                              Kanoj Sarcar&n;         */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mm-&gt;cpu_vm_mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_flush_tlb_mm
comma
id|ctx
comma
l_int|0
comma
l_int|0
comma
id|mm-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_mm
c_func
(paren
id|ctx
comma
id|SECONDARY_CONTEXT
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_flush_tlb_pending
r_void
id|smp_flush_tlb_pending
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|nr
comma
r_int
r_int
op_star
id|vaddrs
)paren
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mm-&gt;cpu_vm_mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This optimization is not valid.  Normally&n;&t;&t; * we will be holding the page_table_lock, but&n;&t;&t; * there is an exception which is copy_page_range()&n;&t;&t; * when forking.  The lock is held during the individual&n;&t;&t; * page table updates in the parent, but not at the&n;&t;&t; * top level, which is where we are invoked.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
)paren
(brace
id|cpumask_t
id|this_cpu_mask
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* By virtue of running under the mm-&gt;page_table_lock,&n;&t;&t;&t; * and mmu_context.h:switch_mm doing the same, the&n;&t;&t;&t; * following operation is safe.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cpus_equal
c_func
(paren
id|mm-&gt;cpu_vm_mask
comma
id|this_cpu_mask
)paren
)paren
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
)brace
id|smp_cross_call_masked
c_func
(paren
op_amp
id|xcall_flush_tlb_pending
comma
id|ctx
comma
id|nr
comma
(paren
r_int
r_int
)paren
id|vaddrs
comma
id|mm-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_pending
c_func
(paren
id|ctx
comma
id|nr
comma
id|vaddrs
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_tlb_kernel_range
r_void
id|smp_flush_tlb_kernel_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|PAGE_ALIGN
c_func
(paren
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ne
id|end
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_kernel_range
comma
l_int|0
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|__flush_tlb_kernel_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* CPU capture. */
multiline_comment|/* #define CAPTURE_DEBUG */
r_extern
r_int
r_int
id|xcall_capture
suffix:semicolon
DECL|variable|smp_capture_depth
r_static
id|atomic_t
id|smp_capture_depth
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|smp_capture_registry
r_static
id|atomic_t
id|smp_capture_registry
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|penguins_are_doing_time
r_static
r_int
r_int
id|penguins_are_doing_time
suffix:semicolon
DECL|function|smp_capture
r_void
id|smp_capture
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
id|__atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|smp_capture_depth
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
(brace
r_int
id|ncpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Sending penguins to jail...&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_capture
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|smp_capture_registry
)paren
op_ne
id|ncpus
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|function|smp_release
r_void
id|smp_release
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|smp_capture_depth
)paren
)paren
(brace
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Giving pardon to &quot;
l_string|&quot;imprisoned penguins&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Imprisoned penguins run with %pil == 15, but PSTATE_IE set, so they&n; * can service tlb flush xcalls...&n; */
r_extern
r_void
id|prom_world
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|save_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|restore_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
DECL|function|smp_penguin_jailcell
r_void
id|smp_penguin_jailcell
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|global_save
(braket
l_int|24
)braket
suffix:semicolon
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flushw&quot;
)paren
suffix:semicolon
id|save_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #StoreStore&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|penguins_are_doing_time
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
id|restore_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|xcall_promstop
suffix:semicolon
DECL|function|smp_promstop_others
r_void
id|smp_promstop_others
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_promstop
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|macro|prof_multiplier
mdefine_line|#define prof_multiplier(__cpu)&t;&t;cpu_data(__cpu).multiplier
DECL|macro|prof_counter
mdefine_line|#define prof_counter(__cpu)&t;&t;cpu_data(__cpu).counter
DECL|function|smp_percpu_timer_interrupt
r_void
id|smp_percpu_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|compare
comma
id|tick
comma
id|pstate
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|user
op_assign
id|user_mode
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for level 14 softint.&n;&t; */
(brace
r_int
r_int
id|tick_mask
op_assign
id|tick_ops-&gt;softint_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|get_softint
c_func
(paren
)paren
op_amp
id|tick_mask
)paren
)paren
(brace
r_extern
r_void
id|handler_irq
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
id|handler_irq
c_func
(paren
l_int|14
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_softint
c_func
(paren
id|tick_mask
)paren
suffix:semicolon
)brace
r_do
(brace
id|profile_tick
c_func
(paren
id|CPU_PROFILING
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|prof_counter
c_func
(paren
id|cpu
)paren
)paren
(brace
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|boot_cpu_id
)paren
(brace
id|kstat_this_cpu.irqs
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|timer_tick_interrupt
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
id|update_process_times
c_func
(paren
id|user
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
multiline_comment|/* Guarantee that the following sequences execute&n;&t;&t; * uninterrupted.&n;&t;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
id|compare
op_assign
id|tick_ops
op_member_access_from_pointer
id|add_compare
c_func
(paren
id|current_tick_offset
)paren
suffix:semicolon
id|tick
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_after_eq
c_func
(paren
id|tick
comma
id|compare
)paren
)paren
suffix:semicolon
)brace
DECL|function|smp_setup_percpu_timer
r_static
r_void
id|__init
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|pstate
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Guarantee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
id|tick_ops
op_member_access_from_pointer
id|init_tick
c_func
(paren
id|current_tick_offset
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|smp_tick_init
r_void
id|__init
id|smp_tick_init
c_func
(paren
r_void
)paren
(brace
id|boot_cpu_id
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|current_tick_offset
op_assign
id|timer_tick_offset
suffix:semicolon
id|cpu_set
c_func
(paren
id|boot_cpu_id
comma
id|cpu_online_map
)paren
suffix:semicolon
id|prof_counter
c_func
(paren
id|boot_cpu_id
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|boot_cpu_id
)paren
op_assign
l_int|1
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|variable|cache_decay_ticks
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
r_extern
r_int
r_int
id|cheetah_tune_scheduling
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|__init
id|smp_tune_scheduling
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|orig_flush_base
comma
id|flush_base
comma
id|flags
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|ecache_size
comma
id|order
suffix:semicolon
id|cycles_t
id|tick1
comma
id|tick2
comma
id|raw
suffix:semicolon
r_int
id|cpu_node
suffix:semicolon
multiline_comment|/* Approximate heuristic for SMP scheduling.  It is an&n;&t; * estimation of the time it takes to flush the L2 cache&n;&t; * on the local processor.&n;&t; *&n;&t; * The ia32 chooses to use the L1 cache flush time instead,&n;&t; * and I consider this complete nonsense.  The Ultra can service&n;&t; * a miss to the L1 with a hit to the L2 in 7 or 8 cycles, and&n;&t; * L2 misses are what create extra bus traffic (ie. the &quot;cost&quot;&n;&t; * of moving a process from one cpu to another).&n;&t; */
id|printk
c_func
(paren
l_string|&quot;SMP: Calibrating ecache flush... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|cheetah
op_logical_or
id|tlb_type
op_eq
id|cheetah_plus
)paren
(brace
id|cacheflush_time
op_assign
id|cheetah_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
r_goto
id|report
suffix:semicolon
)brace
id|cpu_find_by_instance
c_func
(paren
l_int|0
comma
op_amp
id|cpu_node
comma
l_int|NULL
)paren
suffix:semicolon
id|ecache_size
op_assign
id|prom_getintdefault
c_func
(paren
id|cpu_node
comma
l_string|&quot;ecache-size&quot;
comma
(paren
l_int|512
op_star
l_int|1024
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecache_size
OG
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
id|ecache_size
op_assign
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|orig_flush_base
op_assign
id|flush_base
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
op_assign
id|get_order
c_func
(paren
id|ecache_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_base
op_ne
l_int|0UL
)paren
(brace
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Scan twice the size once just to get the TLB entries&n;&t;&t; * loaded and make sure the second scan measures pure misses.&n;&t;&t; */
r_for
c_loop
(paren
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|flush_base
suffix:semicolon
(paren
(paren
r_int
r_int
)paren
id|p
)paren
OL
(paren
id|flush_base
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|p
op_add_assign
(paren
l_int|64
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|p
)paren
suffix:semicolon
id|tick1
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;n&bslash;t&quot;
l_string|&quot;ldx&t;[%0 + 0x000], %%g1&bslash;n&bslash;t&quot;
l_string|&quot;ldx&t;[%0 + 0x040], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldx&t;[%0 + 0x080], %%g3&bslash;n&bslash;t&quot;
l_string|&quot;ldx&t;[%0 + 0x0c0], %%g5&bslash;n&bslash;t&quot;
l_string|&quot;add&t;%0, 0x100, %0&bslash;n&bslash;t&quot;
l_string|&quot;cmp&t;%0, %2&bslash;n&bslash;t&quot;
l_string|&quot;bne,pt&t;%%xcc, 1b&bslash;n&bslash;t&quot;
l_string|&quot; nop&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|flush_base
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|flush_base
)paren
comma
l_string|&quot;r&quot;
(paren
id|flush_base
op_plus
id|ecache_size
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;g5&quot;
)paren
suffix:semicolon
id|tick2
op_assign
id|tick_ops
op_member_access_from_pointer
id|get_tick
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|raw
op_assign
(paren
id|tick2
op_minus
id|tick1
)paren
suffix:semicolon
multiline_comment|/* Dampen it a little, considering two processes&n;&t;&t; * sharing the cache and fitting.&n;&t;&t; */
id|cacheflush_time
op_assign
(paren
id|raw
op_minus
(paren
id|raw
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|orig_flush_base
comma
id|order
)paren
suffix:semicolon
)brace
r_else
(brace
id|cacheflush_time
op_assign
(paren
(paren
id|ecache_size
op_lshift
l_int|2
)paren
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|report
suffix:colon
multiline_comment|/* Convert ticks/sticks to jiffies. */
id|cache_decay_ticks
op_assign
id|cacheflush_time
op_div
id|timer_tick_offset
suffix:semicolon
r_if
c_cond
(paren
id|cache_decay_ticks
OL
l_int|1
)paren
id|cache_decay_ticks
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using heuristic of %ld cycles, %ld ticks.&bslash;n&quot;
comma
id|cacheflush_time
comma
id|cache_decay_ticks
)paren
suffix:semicolon
)brace
multiline_comment|/* /proc/profile writes can call this, don&squot;t __init it please. */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|prof_setup_lock
)paren
suffix:semicolon
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|multiplier
)paren
op_logical_or
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
OL
l_int|1000
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|prof_setup_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|prof_multiplier
c_func
(paren
id|i
)paren
op_assign
id|multiplier
suffix:semicolon
id|current_tick_offset
op_assign
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|prof_setup_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_prepare_cpus
r_void
id|__init
id|smp_prepare_cpus
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
r_int
id|instance
comma
id|mid
suffix:semicolon
id|instance
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_find_by_instance
c_func
(paren
id|instance
comma
l_int|NULL
comma
op_amp
id|mid
)paren
)paren
(brace
r_if
c_cond
(paren
id|mid
OL
id|max_cpus
)paren
id|cpu_set
c_func
(paren
id|mid
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
id|instance
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_possible_cpus
c_func
(paren
)paren
OG
id|max_cpus
)paren
(brace
id|instance
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_find_by_instance
c_func
(paren
id|instance
comma
l_int|NULL
comma
op_amp
id|mid
)paren
)paren
(brace
r_if
c_cond
(paren
id|mid
op_ne
id|boot_cpu_id
)paren
(brace
id|cpu_clear
c_func
(paren
id|mid
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_possible_cpus
c_func
(paren
)paren
op_le
id|max_cpus
)paren
r_break
suffix:semicolon
)brace
id|instance
op_increment
suffix:semicolon
)brace
)brace
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
)brace
DECL|function|smp_prepare_boot_cpu
r_void
id|__devinit
id|smp_prepare_boot_cpu
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|hard_smp_processor_id
c_func
(paren
)paren
op_ge
id|NR_CPUS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Serious problem, boot cpu id &gt;= NR_CPUS&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|cpu
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_online_map
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
)brace
DECL|function|__cpu_up
r_int
id|__devinit
id|__cpu_up
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
r_int
id|ret
op_assign
id|smp_boot_one_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|cpu_set
c_func
(paren
id|cpu
comma
id|smp_commenced_mask
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_online_map
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_online_map
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|smp_synchronize_one_tick
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|smp_cpus_done
r_void
id|__init
id|smp_cpus_done
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
c_func
(paren
id|i
)paren
dot
id|udelay_val
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Total of %ld processors activated &quot;
l_string|&quot;(%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
(paren
r_int
)paren
id|num_online_cpus
c_func
(paren
)paren
comma
id|bogosum
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|bogosum
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
multiline_comment|/* We want to run this with all the other cpus spinning&n;&t; * in the kernel.&n;&t; */
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This needn&squot;t do anything as we do not sleep the cpu&n; * inside of the idler task, so an interrupt is not needed&n; * to get a clean fast response.&n; *&n; * XXX Reverify this assumption... -DaveM&n; *&n; * Addendum: We do want it to do something for the signal&n; *           delivery case, we detect that by just seeing&n; *           if we are trying to send this to an idler or not.&n; */
DECL|function|smp_send_reschedule
r_void
id|smp_send_reschedule
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|cpu_data
c_func
(paren
id|cpu
)paren
dot
id|idle_volume
op_eq
l_int|0
)paren
id|smp_receive_signal
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a nop because we capture all other cpus&n; * anyways when making the PROM active.&n; */
DECL|function|smp_send_stop
r_void
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
)brace
eof
