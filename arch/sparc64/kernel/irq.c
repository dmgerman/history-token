multiline_comment|/* $Id: irq.c,v 1.114 2002/01/11 08:45:38 davem Exp $&n; * irq.c: UltraSparc IRQ handling/init/registry.&n; *&n; * Copyright (C) 1997  David S. Miller  (davem@caip.rutgers.edu)&n; * Copyright (C) 1998  Eddie C. Dost    (ecd@skynet.be)&n; * Copyright (C) 1998  Jakub Jelinek    (jj@ultra.linux.cz)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/upa.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/starfire.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;asm/cpudata.h&gt;
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* UPA nodes send interrupt packet to UltraSparc with first data reg&n; * value low 5 (7 on Starfire) bits holding the IRQ identifier being&n; * delivered.  We must translate this into a non-vector IRQ so we can&n; * set the softint on this cpu.&n; *&n; * To make processing these packets efficient and race free we use&n; * an array of irq buckets below.  The interrupt vector handler in&n; * entry.S feeds incoming packets into per-cpu pil-indexed lists.&n; * The IVEC handler does not need to act atomically, the PIL dispatch&n; * code uses CAS to get an atomic snapshot of the list and clear it&n; * at the same time.&n; */
DECL|variable|ivector_table
r_struct
id|ino_bucket
id|ivector_table
(braket
id|NUM_IVECS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* This has to be in the main kernel image, it cannot be&n; * turned into per-cpu data.  The reason is that the main&n; * kernel image is locked into the TLB and this structure&n; * is accessed from the vectored interrupt trap handler.  If&n; * access to this structure takes a TLB miss it could cause&n; * the 5-level sparc v9 trap stack to overflow.&n; */
DECL|struct|irq_work_struct
r_struct
id|irq_work_struct
(brace
DECL|member|irq_worklists
r_int
r_int
id|irq_worklists
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__irq_work
r_struct
id|irq_work_struct
id|__irq_work
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|irq_work
mdefine_line|#define irq_work(__cpu, __pil)&t;&amp;(__irq_work[(__cpu)].irq_worklists[(__pil)])
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* This is a table of physical addresses used to deal with IBF_DMA_SYNC.&n; * It is used for PCI only to synchronize DMA transfers with IRQ delivery&n; * for devices behind busses other than APB on Sabre systems.&n; *&n; * Currently these physical addresses are just config space accesses&n; * to the command register for that device.&n; */
DECL|variable|pci_dma_wsync
r_int
r_int
id|pci_dma_wsync
suffix:semicolon
DECL|variable|dma_sync_reg_table
r_int
r_int
id|dma_sync_reg_table
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dma_sync_reg_table_entry
r_int
r_char
id|dma_sync_reg_table_entry
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* This is based upon code in the 32-bit Sparc kernel written mostly by&n; * David Redman (djhr@tadpole.co.uk).&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
suffix:semicolon
multiline_comment|/* This is exported so that fast IRQ handlers can get at it... -DaveM */
DECL|variable|irq_action
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* This only synchronizes entities which modify IRQ handler&n; * state and some selected user-level spots that want to&n; * read things in the table.  IRQ handler processing orders&n; * its&squot; accesses such that no locking is needed.&n; */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|irq_action_lock
)paren
suffix:semicolon
r_static
r_void
id|register_irq_proc
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n; * Upper 2b of irqaction-&gt;flags holds the ino.&n; * irqaction-&gt;mask holds the smp affinity information.&n; */
DECL|macro|put_ino_in_irqaction
mdefine_line|#define put_ino_in_irqaction(action, irq) &bslash;&n;&t;action-&gt;flags &amp;= 0xffffffffffffUL; &bslash;&n;&t;if (__bucket(irq) == &amp;pil0_dummy_bucket) &bslash;&n;&t;&t;action-&gt;flags |= 0xdeadUL &lt;&lt; 48;  &bslash;&n;&t;else &bslash;&n;&t;&t;action-&gt;flags |= __irq_ino(irq) &lt;&lt; 48;
DECL|macro|get_ino_in_irqaction
mdefine_line|#define get_ino_in_irqaction(action)&t;(action-&gt;flags &gt;&gt; 48)
DECL|macro|put_smpaff_in_irqaction
mdefine_line|#define put_smpaff_in_irqaction(action, smpaff)&t;(action)-&gt;mask = (smpaff)
DECL|macro|get_smpaff_in_irqaction
mdefine_line|#define get_smpaff_in_irqaction(action) &t;((action)-&gt;mask)
DECL|function|show_interrupts
r_int
id|show_interrupts
c_func
(paren
r_struct
id|seq_file
op_star
id|p
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
op_star
(paren
id|loff_t
op_star
)paren
id|v
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|j
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
id|NR_IRQS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|j
)paren
)paren
r_continue
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_cpu
c_func
(paren
id|j
)paren
dot
id|irqs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot; %s:%lx&quot;
comma
id|action-&gt;name
comma
id|get_ino_in_irqaction
c_func
(paren
id|action
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;, %s:%lx&quot;
comma
id|action-&gt;name
comma
id|get_ino_in_irqaction
c_func
(paren
id|action
)paren
)paren
suffix:semicolon
)brace
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Now these are always passed a true fully specified sun4u INO. */
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|0UL
)paren
r_return
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlb_type
op_eq
id|cheetah
op_logical_or
id|tlb_type
op_eq
id|cheetah_plus
)paren
(brace
r_int
r_int
id|ver
suffix:semicolon
id|__asm__
(paren
l_string|&quot;rdpr %%ver, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ver
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ver
op_rshift
l_int|32
)paren
op_eq
l_int|0x003e0016
)paren
(brace
multiline_comment|/* We set it to our JBUS ID. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_JBUS_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
(paren
l_int|0x1fUL
op_lshift
l_int|17
)paren
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|tid
op_and_assign
id|IMAP_TID_JBUS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We set it to our Safari AID. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_SAFARI_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
(paren
l_int|0x3ffUL
op_lshift
l_int|17
)paren
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|tid
op_and_assign
id|IMAP_AID_SAFARI
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We set it to our UPA MID. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_UPA_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
id|UPA_CONFIG_MID
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|tid
op_and_assign
id|IMAP_TID_UPA
suffix:semicolon
)brace
r_else
(brace
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
id|tid
op_and_assign
id|IMAP_TID_UPA
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE, IGN and INO are read-only, IGN is a product&n;&t; * of this SYSIO&squot;s preconfigured IGN in the SYSIO Control&n;&t; * Register, the hardware just mirrors that value here.&n;&t; * However for Graphics and UPA Slave devices the full&n;&t; * IMAP_INR field can be set by the programmer here.&n;&t; *&n;&t; * Things like FFB can now be handled via the new IRQ mechanism.&n;&t; */
id|upa_writel
c_func
(paren
id|tid
op_or
id|IMAP_VALID
comma
id|imap
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This now gets passed true ino&squot;s as well. */
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|imap
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_ne
l_int|0UL
)paren
(brace
id|u32
id|tmp
suffix:semicolon
multiline_comment|/* NOTE: We do not want to futz with the IRQ clear registers&n;&t;&t; *       and move the state to IDLE, the SCSI code does call&n;&t;&t; *       disable_irq() to assure atomicity in the queue cmd&n;&t;&t; *       SCSI adapter driver code.  Thus we&squot;d lose interrupts.&n;&t;&t; */
id|tmp
op_assign
id|upa_readl
c_func
(paren
id|imap
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|IMAP_VALID
suffix:semicolon
id|upa_writel
c_func
(paren
id|tmp
comma
id|imap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The timer is the one &quot;weird&quot; interrupt which is generated by&n; * the CPU %tick register and not by some normal vectored interrupt&n; * source.  To handle this special case, we use this dummy INO bucket.&n; */
DECL|variable|pil0_dummy_bucket
r_static
r_struct
id|ino_bucket
id|pil0_dummy_bucket
op_assign
(brace
l_int|0
comma
multiline_comment|/* irq_chain */
l_int|0
comma
multiline_comment|/* pil */
l_int|0
comma
multiline_comment|/* pending */
l_int|0
comma
multiline_comment|/* flags */
l_int|0
comma
multiline_comment|/* __unused */
l_int|NULL
comma
multiline_comment|/* irq_info */
l_int|0UL
comma
multiline_comment|/* iclr */
l_int|0UL
comma
multiline_comment|/* imap */
)brace
suffix:semicolon
DECL|function|build_irq
r_int
r_int
id|build_irq
c_func
(paren
r_int
id|pil
comma
r_int
id|inofixup
comma
r_int
r_int
id|iclr
comma
r_int
r_int
id|imap
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|pil
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|iclr
op_ne
l_int|0UL
op_logical_or
id|imap
op_ne
l_int|0UL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid dummy bucket for PIL0 (%lx:%lx)&bslash;n&quot;
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|__irq
c_func
(paren
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
)brace
multiline_comment|/* RULE: Both must be specified in all other cases. */
r_if
c_cond
(paren
id|iclr
op_eq
l_int|0UL
op_logical_or
id|imap
op_eq
l_int|0UL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid build_irq %d %d %016lx %016lx&bslash;n&quot;
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|ino
op_assign
(paren
id|upa_readl
c_func
(paren
id|imap
)paren
op_amp
(paren
id|IMAP_IGN
op_or
id|IMAP_INO
)paren
)paren
op_plus
id|inofixup
suffix:semicolon
r_if
c_cond
(paren
id|ino
OG
id|NUM_IVECS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, looks good, set it up.  Don&squot;t touch the irq_chain or&n;&t; * the pending flag.&n;&t; */
id|bucket
op_assign
op_amp
id|ivector_table
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_logical_or
(paren
id|bucket-&gt;irq_info
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* This is a gross fatal error if it happens here. */
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Trying to reinit INO bucket, fatal error.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Request INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Existing (%d:%016lx:%016lx)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|bucket-&gt;iclr
comma
id|bucket-&gt;imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Cannot continue, halting...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|bucket-&gt;imap
op_assign
id|imap
suffix:semicolon
id|bucket-&gt;iclr
op_assign
id|iclr
suffix:semicolon
id|bucket-&gt;pil
op_assign
id|pil
suffix:semicolon
id|bucket-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
)brace
DECL|function|atomic_bucket_insert
r_static
r_void
id|atomic_bucket_insert
c_func
(paren
r_struct
id|ino_bucket
op_star
id|bucket
)paren
(brace
r_int
r_int
id|pstate
suffix:semicolon
r_int
r_int
op_star
id|ent
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, %1, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
id|ent
op_assign
id|irq_work
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|bucket-&gt;irq_chain
op_assign
op_star
id|ent
suffix:semicolon
op_star
id|ent
op_assign
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
id|irqreturn_t
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SAMPLE_RANDOM
)paren
)paren
(brace
multiline_comment|/*&n;&t; &t; * This function might sleep, we want to call it first,&n;&t; &t; * outside of the atomic block. In SA_STATIC_ALLOC case,&n;&t;&t; * random driver&squot;s kmalloc will fail, but it is safe.&n;&t;&t; * If already initialized, random driver will not reinit.&n;&t; &t; * Yes, this might clear the entropy pool if the wrong&n;&t; &t; * driver is attempted to be loaded, without actually&n;&t; &t; * installing a new handler, but is this really a problem,&n;&t; &t; * only the sysadmin is able to do this.&n;&t; &t; */
id|rand_initialize_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bucket
op_eq
op_amp
id|pil0_dummy_bucket
)paren
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_void
op_star
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
r_void
op_star
op_star
id|vector
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ: Trying to share non-PCI bucket.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
id|vector
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
op_eq
l_int|NULL
)paren
r_goto
id|free_and_enomem
suffix:semicolon
multiline_comment|/* We might have slept. */
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|ent
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bucket-&gt;irq_info
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_else
(brace
id|vector
(braket
l_int|0
)braket
op_assign
id|orig
suffix:semicolon
id|vector
(braket
l_int|1
)braket
op_assign
id|action
suffix:semicolon
id|vector
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vector
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|vector
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_MULTI
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|ent
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
id|pending
op_assign
id|bucket-&gt;pending
suffix:semicolon
r_if
c_cond
(paren
id|pending
)paren
id|bucket-&gt;pending
op_assign
l_int|0
suffix:semicolon
)brace
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
id|put_ino_in_irqaction
c_func
(paren
id|action
comma
id|irq
)paren
suffix:semicolon
id|put_smpaff_in_irqaction
c_func
(paren
id|action
comma
id|CPU_MASK_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* We ate the IVEC already, this makes sure it does not get lost. */
r_if
c_cond
(paren
id|pending
)paren
(brace
id|atomic_bucket_insert
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|set_softint
c_func
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
)paren
)paren
id|register_irq_proc
c_func
(paren
id|__irq_ino
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|free_and_ebusy
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
id|free_and_enomem
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|variable|request_irq
id|EXPORT_SYMBOL
c_func
(paren
id|request_irq
)paren
suffix:semicolon
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
comma
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;free_irq: Old style IRQ removal attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing free IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
r_break
suffix:semicolon
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ %d with NULL device ID&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ %d (%s)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|action-&gt;name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
(brace
r_int
r_int
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_void
op_star
op_star
id|vector
comma
op_star
id|orig
suffix:semicolon
r_int
id|ent
suffix:semicolon
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|other
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|orphan
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
id|action
)paren
id|vector
(braket
id|ent
)braket
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_ne
l_int|NULL
)paren
(brace
id|orphan
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
id|other
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Only free when no other shared irq&n;&t;&t;&t; * uses this bucket.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|other
)paren
(brace
r_if
c_cond
(paren
id|other
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Convert back to non-shared bucket. */
id|bucket-&gt;irq_info
op_assign
id|orphan
suffix:semicolon
id|bucket-&gt;flags
op_and_assign
op_complement
(paren
id|IBF_MULTI
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This unique interrupt source is now inactive. */
id|bucket-&gt;flags
op_and_assign
op_complement
id|IBF_ACTIVE
suffix:semicolon
multiline_comment|/* See if any other buckets share this bucket&squot;s IMAP&n;&t;&t; * and are still active.&n;&t;&t; */
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
id|NUM_IVECS
suffix:semicolon
id|ent
op_increment
)paren
(brace
id|bp
op_assign
op_amp
id|ivector_table
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
id|bucket
op_logical_and
id|bp-&gt;imap
op_eq
id|imap
op_logical_and
(paren
id|bp-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Only disable when no other sub-irq levels of&n;&t;&t; * the same IMAP are active.&n;&t;&t; */
r_if
c_cond
(paren
id|ent
op_eq
id|NUM_IVECS
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|free_irq
id|EXPORT_SYMBOL
c_func
(paren
id|free_irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* The following is how I wish I could implement this.&n;&t; * Unfortunately the ICLR registers are read-only, you can&n;&t; * only write ICLR_foo values to them.  To get the current&n;&t; * IRQ status you would need to get at the IRQ diag registers&n;&t; * in the PCI/SBUS controller and the layout of those vary&n;&t; * from one controller to the next, sigh... -DaveM&n;&t; */
r_int
r_int
id|iclr
op_assign
id|bucket-&gt;iclr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|u32
id|tmp
op_assign
id|upa_readl
c_func
(paren
id|iclr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|ICLR_TRANSMIT
op_logical_or
id|tmp
op_eq
id|ICLR_PENDING
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* So we have to do this with a INPROGRESS bit just like x86.  */
r_while
c_loop
(paren
id|bucket-&gt;flags
op_amp
id|IBF_INPROGRESS
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|function|catch_disabled_ivec
r_void
id|catch_disabled_ivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* We can actually see this on Ultra/PCI PCI cards, which are bridges&n;&t; * to other devices.  Here a single IMAP enabled potentially multiple&n;&t; * unique interrupt sources (which each do have a unique ICLR register.&n;&t; *&n;&t; * So what we do is just register that the IVEC arrived, when registered&n;&t; * for real the request_irq() code will check the bit and signal&n;&t; * a local CPU interrupt for it.&n;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;IVEC: Spurious interrupt vector (%x) received at (%016lx)&bslash;n&quot;
comma
id|bucket
op_minus
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
macro_line|#endif
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;pending
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Tune this... */
DECL|macro|FORWARD_VOLUME
mdefine_line|#define FORWARD_VOLUME&t;&t;12
macro_line|#ifdef CONFIG_SMP
DECL|function|redirect_intr
r_static
r_inline
r_void
id|redirect_intr
c_func
(paren
r_int
id|cpu
comma
r_struct
id|ino_bucket
op_star
id|bp
)paren
(brace
multiline_comment|/* Ok, here is what is going on:&n;&t; * 1) Retargeting IRQs on Starfire is very&n;&t; *    expensive so just forget about it on them.&n;&t; * 2) Moving around very high priority interrupts&n;&t; *    is a losing game.&n;&t; * 3) If the current cpu is idle, interrupts are&n;&t; *    useful work, so keep them here.  But do not&n;&t; *    pass to our neighbour if he is not very idle.&n;&t; * 4) If sysadmin explicitly asks for directed intrs,&n;&t; *    Just Do It.&n;&t; */
r_struct
id|irqaction
op_star
id|ap
op_assign
id|bp-&gt;irq_info
suffix:semicolon
id|cpumask_t
id|cpu_mask
suffix:semicolon
r_int
r_int
id|buddy
comma
id|ticks
suffix:semicolon
id|cpu_mask
op_assign
id|get_smpaff_in_irqaction
c_func
(paren
id|ap
)paren
suffix:semicolon
id|cpus_and
c_func
(paren
id|cpu_mask
comma
id|cpu_mask
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|cpu_mask
)paren
)paren
id|cpu_mask
op_assign
id|cpu_online_map
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
op_ne
l_int|0
op_logical_or
id|bp-&gt;pil
op_ge
l_int|10
op_logical_or
id|current-&gt;pid
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &squot;cpu&squot; is the MID (ie. UPAID), calculate the MID&n;&t; * of our buddy.&n;&t; */
id|buddy
op_assign
id|cpu
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buddy
op_ge
id|NR_CPUS
)paren
id|buddy
op_assign
l_int|0
suffix:semicolon
id|ticks
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|buddy
comma
id|cpu_mask
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|buddy
op_ge
id|NR_CPUS
)paren
id|buddy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ticks
OG
id|NR_CPUS
)paren
(brace
id|put_smpaff_in_irqaction
c_func
(paren
id|ap
comma
id|CPU_MASK_NONE
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buddy
op_eq
id|cpu
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Voo-doo programming. */
r_if
c_cond
(paren
id|cpu_data
c_func
(paren
id|buddy
)paren
dot
id|idle_volume
OL
id|FORWARD_VOLUME
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* This just so happens to be correct on Cheetah&n;&t; * at the moment.&n;&t; */
id|buddy
op_lshift_assign
l_int|26
suffix:semicolon
multiline_comment|/* Push it to our buddy. */
id|upa_writel
c_func
(paren
id|buddy
op_or
id|IMAP_VALID
comma
id|bp-&gt;imap
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
macro_line|#endif
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bp
comma
op_star
id|nbp
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
multiline_comment|/*&n;&t; * Check for TICK_INT on level 14 softint.&n;&t; */
(brace
r_int
r_int
id|clr_mask
op_assign
l_int|1
op_lshift
id|irq
suffix:semicolon
r_int
r_int
id|tick_mask
op_assign
id|tick_ops-&gt;softint_mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|14
)paren
op_logical_and
(paren
id|get_softint
c_func
(paren
)paren
op_amp
id|tick_mask
)paren
)paren
(brace
id|irq
op_assign
l_int|0
suffix:semicolon
id|clr_mask
op_assign
id|tick_mask
suffix:semicolon
)brace
id|clear_softint
c_func
(paren
id|clr_mask
)paren
suffix:semicolon
)brace
macro_line|#else
r_int
id|should_forward
op_assign
l_int|1
suffix:semicolon
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
macro_line|#endif
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
id|kstat_this_cpu.irqs
(braket
id|irq
)braket
op_increment
suffix:semicolon
multiline_comment|/* Sliiiick... */
macro_line|#ifndef CONFIG_SMP
id|bp
op_assign
(paren
(paren
id|irq
op_ne
l_int|0
)paren
ques
c_cond
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:colon
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
macro_line|#else
id|bp
op_assign
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|bp
op_ne
l_int|NULL
suffix:semicolon
id|bp
op_assign
id|nbp
)paren
(brace
r_int
r_char
id|flags
op_assign
id|bp-&gt;flags
suffix:semicolon
r_int
r_char
id|random
op_assign
l_int|0
suffix:semicolon
id|nbp
op_assign
id|__bucket
c_func
(paren
id|bp-&gt;irq_chain
)paren
suffix:semicolon
id|bp-&gt;irq_chain
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;flags
op_or_assign
id|IBF_INPROGRESS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_DMA_SYNC
)paren
op_ne
l_int|0
)paren
(brace
id|upa_readl
c_func
(paren
id|dma_sync_reg_table
(braket
id|bp-&gt;synctab_ent
)braket
)paren
suffix:semicolon
id|upa_readq
c_func
(paren
id|pci_dma_wsync
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|bp-&gt;irq_info
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|IRQ_HANDLED
)paren
id|random
op_or_assign
id|ap-&gt;flags
suffix:semicolon
)brace
r_else
(brace
r_void
op_star
op_star
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bp-&gt;irq_info
suffix:semicolon
r_int
id|ent
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
l_int|NULL
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|IRQ_HANDLED
)paren
id|random
op_or_assign
id|ap-&gt;flags
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Only the dummy bucket lacks IMAP/ICLR. */
r_if
c_cond
(paren
id|bp-&gt;pil
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|should_forward
)paren
(brace
id|redirect_intr
c_func
(paren
id|cpu
comma
id|bp
)paren
suffix:semicolon
id|should_forward
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|upa_writel
c_func
(paren
id|ICLR_IDLE
comma
id|bp-&gt;iclr
)paren
suffix:semicolon
multiline_comment|/* Test and add entropy */
r_if
c_cond
(paren
id|random
op_amp
id|SA_SAMPLE_RANDOM
)paren
id|add_interrupt_randomness
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
)brace
r_else
id|bp-&gt;pending
op_assign
l_int|1
suffix:semicolon
id|bp-&gt;flags
op_and_assign
op_complement
id|IBF_INPROGRESS
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|sparc_floppy_irq
r_void
id|sparc_floppy_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
id|kstat_this_cpu.irqs
(braket
id|irq
)braket
op_increment
suffix:semicolon
op_star
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket
op_assign
id|get_ino_in_irqaction
c_func
(paren
id|action
)paren
op_plus
id|ivector_table
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_INPROGRESS
suffix:semicolon
id|floppy_interrupt
c_func
(paren
id|irq
comma
id|dev_cookie
comma
id|regs
)paren
suffix:semicolon
id|upa_writel
c_func
(paren
id|ICLR_IDLE
comma
id|bucket-&gt;iclr
)paren
suffix:semicolon
id|bucket-&gt;flags
op_and_assign
op_complement
id|IBF_INPROGRESS
suffix:semicolon
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The following assumes that the branch lies before the place we&n; * are branching to.  This is the case for a trap vector...&n; * You have been warned.&n; */
DECL|macro|SPARC_BRANCH
mdefine_line|#define SPARC_BRANCH(dest_addr, inst_addr) &bslash;&n;          (0x10800000 | ((((dest_addr)-(inst_addr))&gt;&gt;2)&amp;0x3fffff))
DECL|macro|SPARC_NOP
mdefine_line|#define SPARC_NOP (0x01000000)
DECL|function|install_fast_irq
r_static
r_void
id|install_fast_irq
c_func
(paren
r_int
r_int
id|cpu_irq
comma
id|irqreturn_t
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_extern
r_int
r_int
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
id|ttent
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
op_star
id|insns
suffix:semicolon
id|ttent
op_add_assign
l_int|0x820
suffix:semicolon
id|ttent
op_add_assign
(paren
id|cpu_irq
op_minus
l_int|1
)paren
op_lshift
l_int|5
suffix:semicolon
id|insns
op_assign
(paren
r_int
r_int
op_star
)paren
id|ttent
suffix:semicolon
id|insns
(braket
l_int|0
)braket
op_assign
id|SPARC_BRANCH
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|handler
)paren
comma
(paren
(paren
r_int
r_int
)paren
op_amp
id|insns
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|insns
(braket
l_int|1
)braket
op_assign
id|SPARC_NOP
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #StoreStore; flush %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ttent
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
id|irqreturn_t
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* No pil0 dummy buckets allowed here. */
r_if
c_cond
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_fast_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bucket-&gt;pil
op_eq
l_int|14
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register shared IRQ 0 or 14.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq when already shared.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq as shared.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register yet already owned.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We do not check for SA_SAMPLE_RANDOM in this path. Neither do we&n;&t; * support smp intr affinity in this path.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|install_fast_irq
c_func
(paren
id|bucket-&gt;pil
comma
id|handler
)paren
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;dev_id
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|put_ino_in_irqaction
c_func
(paren
id|action
comma
id|irq
)paren
suffix:semicolon
id|put_smpaff_in_irqaction
c_func
(paren
id|action
comma
id|CPU_MASK_NONE
)paren
suffix:semicolon
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|probe_irq_on
id|EXPORT_SYMBOL
c_func
(paren
id|probe_irq_on
)paren
suffix:semicolon
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|probe_irq_off
id|EXPORT_SYMBOL
c_func
(paren
id|probe_irq_off
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|function|retarget_one_irq
r_static
r_int
id|retarget_one_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|p
comma
r_int
id|goal_cpu
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|get_ino_in_irqaction
c_func
(paren
id|p
)paren
op_plus
id|ivector_table
suffix:semicolon
r_int
r_int
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|goal_cpu
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|goal_cpu
op_ge
id|NR_CPUS
)paren
id|goal_cpu
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tlb_type
op_eq
id|cheetah
op_logical_or
id|tlb_type
op_eq
id|cheetah_plus
)paren
(brace
id|tid
op_assign
id|goal_cpu
op_lshift
l_int|26
suffix:semicolon
id|tid
op_and_assign
id|IMAP_AID_SAFARI
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
id|tid
op_assign
id|goal_cpu
op_lshift
l_int|26
suffix:semicolon
id|tid
op_and_assign
id|IMAP_TID_UPA
suffix:semicolon
)brace
r_else
(brace
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|goal_cpu
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
id|tid
op_and_assign
id|IMAP_TID_UPA
suffix:semicolon
)brace
id|upa_writel
c_func
(paren
id|tid
op_or
id|IMAP_VALID
comma
id|imap
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|goal_cpu
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|goal_cpu
op_ge
id|NR_CPUS
)paren
id|goal_cpu
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|goal_cpu
suffix:semicolon
)brace
multiline_comment|/* Called from request_irq. */
DECL|function|distribute_irqs
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
comma
id|level
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Skip the timer at [0], and very rare error/power intrs at [15].&n;&t; * Also level [12], it causes problems on Ex000 systems.&n;&t; */
r_for
c_loop
(paren
id|level
op_assign
l_int|1
suffix:semicolon
id|level
OL
id|NR_IRQS
suffix:semicolon
id|level
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|p
op_assign
id|irq_action
(braket
id|level
)braket
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|12
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|cpu
op_assign
id|retarget_one_irq
c_func
(paren
id|p
comma
id|cpu
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_action_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|prom_timers
r_struct
id|sun5_timer
op_star
id|prom_timers
suffix:semicolon
DECL|variable|prom_limit0
DECL|variable|prom_limit1
r_static
id|u64
id|prom_limit0
comma
id|prom_limit1
suffix:semicolon
DECL|function|map_prom_timers
r_static
r_void
id|map_prom_timers
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|tnode
comma
id|err
suffix:semicolon
multiline_comment|/* PROM timer node hangs out in the top level of device siblings... */
id|tnode
op_assign
id|prom_finddevice
c_func
(paren
l_string|&quot;/counter-timer&quot;
)paren
suffix:semicolon
multiline_comment|/* Assume if node is not present, PROM uses different tick mechanism&n;&t; * which we should not care about.&n;&t; */
r_if
c_cond
(paren
id|tnode
op_eq
l_int|0
op_logical_or
id|tnode
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If PROM is really using this, it must be mapped by him. */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|tnode
comma
l_string|&quot;address&quot;
comma
(paren
r_char
op_star
)paren
id|addr
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PROM does not have timer mapped, trying to continue.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|kill_prom_timer
r_static
r_void
id|kill_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
r_return
suffix:semicolon
multiline_comment|/* Save them away for later. */
id|prom_limit0
op_assign
id|prom_timers-&gt;limit0
suffix:semicolon
id|prom_limit1
op_assign
id|prom_timers-&gt;limit1
suffix:semicolon
multiline_comment|/* Just as in sun4c/sun4m PROM uses timer which ticks at IRQ 14.&n;&t; * We turn both off here just to be paranoid.&n;&t; */
id|prom_timers-&gt;limit0
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wheee, eat the interrupt packet too... */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&t;mov&t;0x40, %%g2&bslash;n&quot;
l_string|&quot;&t;ldxa&t;[%%g0] %0, %%g1&bslash;n&quot;
l_string|&quot;&t;ldxa&t;[%%g2] %1, %%g1&bslash;n&quot;
l_string|&quot;&t;stxa&t;%%g0, [%%g0] %0&bslash;n&quot;
l_string|&quot;&t;membar&t;#Sync&bslash;n&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_RECEIVE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_INTR_R
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
)brace
DECL|function|enable_prom_timer
r_void
id|enable_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
r_return
suffix:semicolon
multiline_comment|/* Set it to whatever was there before. */
id|prom_timers-&gt;limit1
op_assign
id|prom_limit1
suffix:semicolon
id|prom_timers-&gt;count1
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit0
op_assign
id|prom_limit0
suffix:semicolon
id|prom_timers-&gt;count0
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|init_irqwork_curcpu
r_void
id|init_irqwork_curcpu
c_func
(paren
r_void
)paren
(brace
r_register
r_struct
id|irq_work_struct
op_star
id|workp
id|asm
c_func
(paren
l_string|&quot;o2&quot;
)paren
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|cpu
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|__irq_work
op_plus
id|cpu
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|workp
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we are called with PSTATE_IE disabled.  */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|PSTATE_IE
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;BUG: init_irqwork_curcpu() called with &quot;
l_string|&quot;PSTATE_IE enabled, bailing.&bslash;n&quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov&t;%%i7, %0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;BUG: Called from %lx&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set interrupt globals.  */
id|workp
op_assign
op_amp
id|__irq_work
(braket
id|cpu
)braket
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%2, %%g6&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IG
)paren
comma
l_string|&quot;r&quot;
(paren
id|workp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Only invoked on boot processor. */
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
id|map_prom_timers
c_func
(paren
)paren
suffix:semicolon
id|kill_prom_timer
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ivector_table
)paren
)paren
suffix:semicolon
multiline_comment|/* We need to clear any IRQ&squot;s pending in the soft interrupt&n;&t; * registers, a spurious one could be left around from the&n;&t; * PROM timer which we just disabled.&n;&t; */
id|clear_softint
c_func
(paren
id|get_softint
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that ivector table is initialized, it is safe&n;&t; * to receive IRQ vector traps.  We will normally take&n;&t; * one or two right now, in case some device PROM used&n;&t; * to boot us wants to speak to us.  We just ignore them.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;or&t;%%g1, %0, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g1, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
DECL|variable|root_irq_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|root_irq_dir
suffix:semicolon
DECL|variable|irq_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|irq_dir
(braket
id|NUM_IVECS
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|function|irq_affinity_read_proc
r_static
r_int
id|irq_affinity_read_proc
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bp
op_assign
id|ivector_table
op_plus
(paren
r_int
)paren
id|data
suffix:semicolon
r_struct
id|irqaction
op_star
id|ap
op_assign
id|bp-&gt;irq_info
suffix:semicolon
id|cpumask_t
id|mask
suffix:semicolon
r_int
id|len
suffix:semicolon
id|mask
op_assign
id|get_smpaff_in_irqaction
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|mask
)paren
)paren
id|mask
op_assign
id|cpu_online_map
suffix:semicolon
id|len
op_assign
id|cpumask_scnprintf
c_func
(paren
id|page
comma
id|count
comma
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_minus
id|len
OL
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|set_intr_affinity
r_static
r_inline
r_void
id|set_intr_affinity
c_func
(paren
r_int
id|irq
comma
id|cpumask_t
id|hw_aff
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bp
op_assign
id|ivector_table
op_plus
id|irq
suffix:semicolon
multiline_comment|/* Users specify affinity in terms of hw cpu ids.&n;&t; * As soon as we do this, handler_irq() might see and take action.&n;&t; */
id|put_smpaff_in_irqaction
c_func
(paren
(paren
r_struct
id|irqaction
op_star
)paren
id|bp-&gt;irq_info
comma
id|hw_aff
)paren
suffix:semicolon
multiline_comment|/* Migration is simply done by the next cpu to service this&n;&t; * interrupt.&n;&t; */
)brace
DECL|function|irq_affinity_write_proc
r_static
r_int
id|irq_affinity_write_proc
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|irq
op_assign
(paren
r_int
)paren
id|data
comma
id|full_count
op_assign
id|count
comma
id|err
suffix:semicolon
id|cpumask_t
id|new_value
suffix:semicolon
id|err
op_assign
id|cpumask_parse
c_func
(paren
id|buffer
comma
id|count
comma
id|new_value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not allow disabling IRQs completely - it&squot;s a too easy&n;&t; * way to make the system unusable accidentally :-) At least&n;&t; * one online CPU still has to be targeted.&n;&t; */
id|cpus_and
c_func
(paren
id|new_value
comma
id|new_value
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|new_value
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|set_intr_affinity
c_func
(paren
id|irq
comma
id|new_value
)paren
suffix:semicolon
r_return
id|full_count
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|MAX_NAMELEN
mdefine_line|#define MAX_NAMELEN 10
DECL|function|register_irq_proc
r_static
r_void
id|register_irq_proc
(paren
r_int
r_int
id|irq
)paren
(brace
r_char
id|name
(braket
id|MAX_NAMELEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_irq_dir
op_logical_or
id|irq_dir
(braket
id|irq
)braket
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
id|MAX_NAMELEN
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/* create /proc/irq/1234 */
id|irq_dir
(braket
id|irq
)braket
op_assign
id|proc_mkdir
c_func
(paren
id|name
comma
id|root_irq_dir
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* XXX SMP affinity not supported on starfire yet. */
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* create /proc/irq/1234/smp_affinity */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;smp_affinity&quot;
comma
l_int|0600
comma
id|irq_dir
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|entry-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;data
op_assign
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|irq
suffix:semicolon
id|entry-&gt;read_proc
op_assign
id|irq_affinity_read_proc
suffix:semicolon
id|entry-&gt;write_proc
op_assign
id|irq_affinity_write_proc
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|function|init_irq_proc
r_void
id|init_irq_proc
(paren
r_void
)paren
(brace
multiline_comment|/* create /proc/irq */
id|root_irq_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;irq&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
eof
