multiline_comment|/* $Id: chmc.c,v 1.4 2002/01/08 16:00:14 davem Exp $&n; * memctrlr.c: Driver for UltraSPARC-III memory controller.&n; *&n; * Copyright (C) 2001 David S. Miller (davem@redhat.com)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/spitfire.h&gt;
macro_line|#include &lt;asm/chmctrl.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|CHMCTRL_NDGRPS
mdefine_line|#define CHMCTRL_NDGRPS&t;2
DECL|macro|CHMCTRL_NDIMMS
mdefine_line|#define CHMCTRL_NDIMMS&t;4
DECL|macro|DIMMS_PER_MC
mdefine_line|#define DIMMS_PER_MC&t;(CHMCTRL_NDGRPS * CHMCTRL_NDIMMS)
multiline_comment|/* OBP memory-layout property format. */
DECL|struct|obp_map
r_struct
id|obp_map
(brace
DECL|member|dimm_map
r_int
r_char
id|dimm_map
(braket
l_int|144
)braket
suffix:semicolon
DECL|member|pin_map
r_int
r_char
id|pin_map
(braket
l_int|576
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|DIMM_LABEL_SZ
mdefine_line|#define DIMM_LABEL_SZ&t;8
DECL|struct|obp_mem_layout
r_struct
id|obp_mem_layout
(brace
multiline_comment|/* One max 8-byte string label per DIMM.  Usually&n;&t; * this matches the label on the motherboard where&n;&t; * that DIMM resides.&n;&t; */
DECL|member|dimm_labels
r_char
id|dimm_labels
(braket
id|DIMMS_PER_MC
)braket
(braket
id|DIMM_LABEL_SZ
)braket
suffix:semicolon
multiline_comment|/* If symmetric use map[0], else it is&n;&t; * asymmetric and map[1] should be used.&n;&t; */
DECL|member|symmetric
r_char
id|symmetric
suffix:semicolon
DECL|member|map
r_struct
id|obp_map
id|map
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CHMCTRL_NBANKS
mdefine_line|#define CHMCTRL_NBANKS&t;4
DECL|struct|bank_info
r_struct
id|bank_info
(brace
DECL|member|mp
r_struct
id|mctrl_info
op_star
id|mp
suffix:semicolon
DECL|member|bank_id
r_int
id|bank_id
suffix:semicolon
DECL|member|raw_reg
id|u64
id|raw_reg
suffix:semicolon
DECL|member|valid
r_int
id|valid
suffix:semicolon
DECL|member|uk
r_int
id|uk
suffix:semicolon
DECL|member|um
r_int
id|um
suffix:semicolon
DECL|member|lk
r_int
id|lk
suffix:semicolon
DECL|member|lm
r_int
id|lm
suffix:semicolon
DECL|member|interleave
r_int
id|interleave
suffix:semicolon
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|mctrl_info
r_struct
id|mctrl_info
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|portid
r_int
id|portid
suffix:semicolon
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|layout_prop
r_struct
id|obp_mem_layout
id|layout_prop
suffix:semicolon
DECL|member|layout_size
r_int
id|layout_size
suffix:semicolon
DECL|member|regs
r_void
op_star
id|regs
suffix:semicolon
DECL|member|timing_control1
id|u64
id|timing_control1
suffix:semicolon
DECL|member|timing_control2
id|u64
id|timing_control2
suffix:semicolon
DECL|member|timing_control3
id|u64
id|timing_control3
suffix:semicolon
DECL|member|timing_control4
id|u64
id|timing_control4
suffix:semicolon
DECL|member|memaddr_control
id|u64
id|memaddr_control
suffix:semicolon
DECL|member|logical_banks
r_struct
id|bank_info
id|logical_banks
(braket
id|CHMCTRL_NBANKS
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|mctrl_list
)paren
suffix:semicolon
multiline_comment|/* Does BANK decode PHYS_ADDR? */
DECL|function|bank_match
r_static
r_int
id|bank_match
c_func
(paren
r_struct
id|bank_info
op_star
id|bp
comma
r_int
r_int
id|phys_addr
)paren
(brace
r_int
r_int
id|upper_bits
op_assign
(paren
id|phys_addr
op_amp
id|PA_UPPER_BITS
)paren
op_rshift
id|PA_UPPER_BITS_SHIFT
suffix:semicolon
r_int
r_int
id|lower_bits
op_assign
(paren
id|phys_addr
op_amp
id|PA_LOWER_BITS
)paren
op_rshift
id|PA_LOWER_BITS_SHIFT
suffix:semicolon
multiline_comment|/* Bank must be enabled to match. */
r_if
c_cond
(paren
id|bp-&gt;valid
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Would BANK match upper bits? */
id|upper_bits
op_xor_assign
id|bp-&gt;um
suffix:semicolon
multiline_comment|/* What bits are different? */
id|upper_bits
op_assign
op_complement
id|upper_bits
suffix:semicolon
multiline_comment|/* Invert. */
id|upper_bits
op_or_assign
id|bp-&gt;uk
suffix:semicolon
multiline_comment|/* What bits don&squot;t matter for matching? */
id|upper_bits
op_assign
op_complement
id|upper_bits
suffix:semicolon
multiline_comment|/* Invert. */
r_if
c_cond
(paren
id|upper_bits
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Would BANK match lower bits? */
id|lower_bits
op_xor_assign
id|bp-&gt;lm
suffix:semicolon
multiline_comment|/* What bits are different? */
id|lower_bits
op_assign
op_complement
id|lower_bits
suffix:semicolon
multiline_comment|/* Invert. */
id|lower_bits
op_or_assign
id|bp-&gt;lk
suffix:semicolon
multiline_comment|/* What bits don&squot;t matter for matching? */
id|lower_bits
op_assign
op_complement
id|lower_bits
suffix:semicolon
multiline_comment|/* Invert. */
r_if
c_cond
(paren
id|lower_bits
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* I always knew you&squot;d be the one. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Given PHYS_ADDR, search memory controller banks for a match. */
DECL|function|find_bank
r_static
r_struct
id|bank_info
op_star
id|find_bank
c_func
(paren
r_int
r_int
id|phys_addr
)paren
(brace
r_struct
id|list_head
op_star
id|mctrl_head
op_assign
op_amp
id|mctrl_list
suffix:semicolon
r_struct
id|list_head
op_star
id|mctrl_entry
op_assign
id|mctrl_head-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|mctrl_info
op_star
id|mp
op_assign
id|list_entry
c_func
(paren
id|mctrl_entry
comma
r_struct
id|mctrl_info
comma
id|list
)paren
suffix:semicolon
r_int
id|bank_no
suffix:semicolon
r_if
c_cond
(paren
id|mctrl_entry
op_eq
id|mctrl_head
)paren
r_break
suffix:semicolon
id|mctrl_entry
op_assign
id|mctrl_entry-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|bank_no
op_assign
l_int|0
suffix:semicolon
id|bank_no
OL
id|CHMCTRL_NBANKS
suffix:semicolon
id|bank_no
op_increment
)paren
(brace
r_struct
id|bank_info
op_star
id|bp
suffix:semicolon
id|bp
op_assign
op_amp
id|mp-&gt;logical_banks
(braket
id|bank_no
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bank_match
c_func
(paren
id|bp
comma
id|phys_addr
)paren
)paren
r_return
id|bp
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This is the main purpose of this driver. */
DECL|macro|SYNDROME_MIN
mdefine_line|#define SYNDROME_MIN&t;-1
DECL|macro|SYNDROME_MAX
mdefine_line|#define SYNDROME_MAX&t;144
DECL|function|chmc_getunumber
r_int
id|chmc_getunumber
c_func
(paren
r_int
id|syndrome_code
comma
r_int
r_int
id|phys_addr
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|bank_info
op_star
id|bp
suffix:semicolon
r_struct
id|obp_mem_layout
op_star
id|prop
suffix:semicolon
r_int
id|bank_in_controller
comma
id|first_dimm
suffix:semicolon
id|bp
op_assign
id|find_bank
c_func
(paren
id|phys_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
op_logical_or
id|syndrome_code
template_param
id|SYNDROME_MAX
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|prop
op_assign
op_amp
id|bp-&gt;mp-&gt;layout_prop
suffix:semicolon
id|bank_in_controller
op_assign
id|bp-&gt;bank_id
op_amp
(paren
id|CHMCTRL_NBANKS
op_minus
l_int|1
)paren
suffix:semicolon
id|first_dimm
op_assign
(paren
id|bank_in_controller
op_amp
(paren
id|CHMCTRL_NDGRPS
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|first_dimm
op_mul_assign
id|CHMCTRL_NDIMMS
suffix:semicolon
r_if
c_cond
(paren
id|syndrome_code
op_ne
id|SYNDROME_MIN
)paren
(brace
r_struct
id|obp_map
op_star
id|map
suffix:semicolon
r_int
id|qword
comma
id|where_in_line
comma
id|where
comma
id|map_index
comma
id|map_offset
suffix:semicolon
r_int
r_int
id|map_val
suffix:semicolon
multiline_comment|/* Yaay, single bit error so we can figure out&n;&t;&t; * the exact dimm.&n;&t;&t; */
r_if
c_cond
(paren
id|prop-&gt;symmetric
)paren
id|map
op_assign
op_amp
id|prop-&gt;map
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|map
op_assign
op_amp
id|prop-&gt;map
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Covert syndrome code into the way the bits are&n;&t;&t; * positioned on the bus.&n;&t;&t; */
r_if
c_cond
(paren
id|syndrome_code
OL
l_int|144
op_minus
l_int|16
)paren
id|syndrome_code
op_add_assign
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|syndrome_code
OL
l_int|144
)paren
id|syndrome_code
op_sub_assign
(paren
l_int|144
op_minus
l_int|7
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|syndrome_code
OL
(paren
l_int|144
op_plus
l_int|3
)paren
)paren
id|syndrome_code
op_sub_assign
(paren
l_int|144
op_plus
l_int|3
op_minus
l_int|4
)paren
suffix:semicolon
r_else
id|syndrome_code
op_sub_assign
l_int|144
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* All this magic has to do with how a cache line&n;&t;&t; * comes over the wire on Safari.  A 64-bit line&n;&t;&t; * comes over in 4 quadword cycles, each of which&n;&t;&t; * transmit ECC/MTAG info as well as the actual&n;&t;&t; * data.  144 bits per quadword, 576 total.&n;&t;&t; */
DECL|macro|LINE_SIZE
mdefine_line|#define LINE_SIZE&t;64
DECL|macro|LINE_ADDR_MSK
mdefine_line|#define LINE_ADDR_MSK&t;(LINE_SIZE - 1)
DECL|macro|QW_PER_LINE
mdefine_line|#define QW_PER_LINE&t;4
DECL|macro|QW_BYTES
mdefine_line|#define QW_BYTES&t;(LINE_SIZE / QW_PER_LINE)
DECL|macro|QW_BITS
mdefine_line|#define QW_BITS&t;&t;144
DECL|macro|LAST_BIT
mdefine_line|#define LAST_BIT&t;(576 - 1)
id|qword
op_assign
(paren
id|phys_addr
op_amp
id|LINE_ADDR_MSK
)paren
op_div
id|QW_BYTES
suffix:semicolon
id|where_in_line
op_assign
(paren
(paren
l_int|3
op_minus
id|qword
)paren
op_star
id|QW_BITS
)paren
op_plus
id|syndrome_code
suffix:semicolon
id|where
op_assign
(paren
id|LAST_BIT
op_minus
id|where_in_line
)paren
suffix:semicolon
id|map_index
op_assign
id|where
op_rshift
l_int|2
suffix:semicolon
id|map_offset
op_assign
id|where
op_amp
l_int|0x3
suffix:semicolon
id|map_val
op_assign
id|map-&gt;dimm_map
(braket
id|map_index
)braket
suffix:semicolon
id|map_val
op_assign
(paren
(paren
id|map_val
op_rshift
(paren
(paren
l_int|3
op_minus
id|map_offset
)paren
op_lshift
l_int|1
)paren
)paren
op_amp
(paren
l_int|2
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s, pin %3d&quot;
comma
id|prop-&gt;dimm_labels
(braket
id|first_dimm
op_plus
id|map_val
)braket
comma
id|map-&gt;pin_map
(braket
id|where_in_line
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|dimm
suffix:semicolon
multiline_comment|/* Multi-bit error, we just dump out all the&n;&t;&t; * dimm labels associated with this bank.&n;&t;&t; */
r_for
c_loop
(paren
id|dimm
op_assign
l_int|0
suffix:semicolon
id|dimm
OL
id|CHMCTRL_NDIMMS
suffix:semicolon
id|dimm
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s &quot;
comma
id|prop-&gt;dimm_labels
(braket
id|first_dimm
op_plus
id|dimm
)braket
)paren
suffix:semicolon
id|buf
op_add_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Accessing the registers is slightly complicated.  If you want&n; * to get at the memory controller which is on the same processor&n; * the code is executing, you must use special ASI load/store else&n; * you go through the global mapping.&n; */
DECL|function|read_mcreg
r_static
id|u64
id|read_mcreg
c_func
(paren
r_struct
id|mctrl_info
op_star
id|mp
comma
r_int
r_int
id|offset
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;portid
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa&t;[%1] %2, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|offset
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_MCU_CTRL_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa&t;[%1] %2, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|mp-&gt;regs
op_plus
id|offset
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_PHYS_BYPASS_EC_E
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if 0 /* currently unused */
r_static
r_void
id|write_mcreg
c_func
(paren
r_struct
id|mctrl_info
op_star
id|mp
comma
r_int
r_int
id|offset
comma
id|u64
id|val
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;portid
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa&t;%0, [%1] %2&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|offset
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_MCU_CTRL_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa&t;%0, [%1] %2&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|mp-&gt;regs
op_plus
id|offset
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_PHYS_BYPASS_EC_E
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|interpret_one_decode_reg
r_static
r_void
id|interpret_one_decode_reg
c_func
(paren
r_struct
id|mctrl_info
op_star
id|mp
comma
r_int
id|which_bank
comma
id|u64
id|val
)paren
(brace
r_struct
id|bank_info
op_star
id|p
op_assign
op_amp
id|mp-&gt;logical_banks
(braket
id|which_bank
)braket
suffix:semicolon
id|p-&gt;mp
op_assign
id|mp
suffix:semicolon
id|p-&gt;bank_id
op_assign
(paren
id|CHMCTRL_NBANKS
op_star
id|mp-&gt;portid
)paren
op_plus
id|which_bank
suffix:semicolon
id|p-&gt;raw_reg
op_assign
id|val
suffix:semicolon
id|p-&gt;valid
op_assign
(paren
id|val
op_amp
id|MEM_DECODE_VALID
)paren
op_rshift
id|MEM_DECODE_VALID_SHIFT
suffix:semicolon
id|p-&gt;uk
op_assign
(paren
id|val
op_amp
id|MEM_DECODE_UK
)paren
op_rshift
id|MEM_DECODE_UK_SHIFT
suffix:semicolon
id|p-&gt;um
op_assign
(paren
id|val
op_amp
id|MEM_DECODE_UM
)paren
op_rshift
id|MEM_DECODE_UM_SHIFT
suffix:semicolon
id|p-&gt;lk
op_assign
(paren
id|val
op_amp
id|MEM_DECODE_LK
)paren
op_rshift
id|MEM_DECODE_LK_SHIFT
suffix:semicolon
id|p-&gt;lm
op_assign
(paren
id|val
op_amp
id|MEM_DECODE_LM
)paren
op_rshift
id|MEM_DECODE_LM_SHIFT
suffix:semicolon
id|p-&gt;base
op_assign
(paren
id|p-&gt;um
)paren
suffix:semicolon
id|p-&gt;base
op_and_assign
op_complement
(paren
id|p-&gt;uk
)paren
suffix:semicolon
id|p-&gt;base
op_lshift_assign
id|PA_UPPER_BITS_SHIFT
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;lk
)paren
(brace
r_case
l_int|0xf
suffix:colon
r_default
suffix:colon
id|p-&gt;interleave
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe
suffix:colon
id|p-&gt;interleave
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc
suffix:colon
id|p-&gt;interleave
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
id|p-&gt;interleave
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
id|p-&gt;interleave
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* UK[10] is reserved, and UK[11] is not set for the SDRAM&n;&t; * bank size definition.&n;&t; */
id|p-&gt;size
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|p-&gt;uk
op_amp
(paren
(paren
l_int|1UL
op_lshift
l_int|10UL
)paren
op_minus
l_int|1UL
)paren
)paren
op_plus
l_int|1UL
)paren
op_lshift
id|PA_UPPER_BITS_SHIFT
suffix:semicolon
id|p-&gt;size
op_div_assign
id|p-&gt;interleave
suffix:semicolon
)brace
DECL|function|fetch_decode_regs
r_static
r_void
id|fetch_decode_regs
c_func
(paren
r_struct
id|mctrl_info
op_star
id|mp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;layout_size
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|interpret_one_decode_reg
c_func
(paren
id|mp
comma
l_int|0
comma
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_DECODE1
)paren
)paren
suffix:semicolon
id|interpret_one_decode_reg
c_func
(paren
id|mp
comma
l_int|1
comma
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_DECODE2
)paren
)paren
suffix:semicolon
id|interpret_one_decode_reg
c_func
(paren
id|mp
comma
l_int|2
comma
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_DECODE3
)paren
)paren
suffix:semicolon
id|interpret_one_decode_reg
c_func
(paren
id|mp
comma
l_int|3
comma
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_DECODE4
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_one_mctrl
r_static
r_int
id|init_one_mctrl
c_func
(paren
r_int
id|node
comma
r_int
id|index
)paren
(brace
r_struct
id|mctrl_info
op_star
id|mp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|portid
op_assign
id|prom_getintdefault
c_func
(paren
id|node
comma
l_string|&quot;portid&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|linux_prom64_registers
id|p_reg_prop
suffix:semicolon
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|mp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portid
op_eq
op_minus
l_int|1
)paren
r_goto
id|fail
suffix:semicolon
id|mp-&gt;portid
op_assign
id|portid
suffix:semicolon
id|mp-&gt;layout_size
op_assign
id|prom_getproplen
c_func
(paren
id|node
comma
l_string|&quot;memory-layout&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;layout_size
OL
l_int|0
)paren
id|mp-&gt;layout_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;layout_size
OG
r_sizeof
(paren
id|mp-&gt;layout_prop
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;layout_size
OG
l_int|0
)paren
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;memory-layout&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|mp-&gt;layout_prop
comma
id|mp-&gt;layout_size
)paren
suffix:semicolon
id|t
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|p_reg_prop
comma
r_sizeof
(paren
id|p_reg_prop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|0
op_logical_or
id|p_reg_prop.reg_size
op_ne
l_int|0x48
)paren
r_goto
id|fail
suffix:semicolon
id|mp-&gt;regs
op_assign
id|ioremap
c_func
(paren
id|p_reg_prop.phys_addr
comma
id|p_reg_prop.reg_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;regs
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;layout_size
op_ne
l_int|0UL
)paren
(brace
id|mp-&gt;timing_control1
op_assign
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_TCTRL1
)paren
suffix:semicolon
id|mp-&gt;timing_control2
op_assign
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_TCTRL2
)paren
suffix:semicolon
id|mp-&gt;timing_control3
op_assign
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_TCTRL3
)paren
suffix:semicolon
id|mp-&gt;timing_control4
op_assign
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_TCTRL4
)paren
suffix:semicolon
id|mp-&gt;memaddr_control
op_assign
id|read_mcreg
c_func
(paren
id|mp
comma
id|CHMCTRL_MACTRL
)paren
suffix:semicolon
)brace
id|fetch_decode_regs
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mp-&gt;index
op_assign
id|index
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mp-&gt;list
comma
op_amp
id|mctrl_list
)paren
suffix:semicolon
multiline_comment|/* Report the device. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;chmc%d: US3 memory controller at %p [%s]&bslash;n&quot;
comma
id|mp-&gt;index
comma
id|mp-&gt;regs
comma
(paren
id|mp-&gt;layout_size
ques
c_cond
l_string|&quot;ACTIVE&quot;
suffix:colon
l_string|&quot;INACTIVE&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|mp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;regs
op_ne
l_int|NULL
)paren
id|iounmap
c_func
(paren
id|mp-&gt;regs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|probe_for_string
r_static
r_int
id|__init
id|probe_for_string
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|index
)paren
(brace
r_int
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|ret
op_assign
id|init_one_mctrl
c_func
(paren
id|node
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|index
op_increment
suffix:semicolon
id|node
op_assign
id|prom_getsibling
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_break
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
)brace
DECL|function|chmc_init
r_static
r_int
id|__init
id|chmc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
multiline_comment|/* This driver is only for cheetah platforms. */
r_if
c_cond
(paren
id|tlb_type
op_ne
id|cheetah
op_logical_and
id|tlb_type
op_ne
id|cheetah_plus
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|index
op_assign
id|probe_for_string
c_func
(paren
l_string|&quot;memory-controller&quot;
comma
l_int|0
)paren
suffix:semicolon
id|index
op_assign
id|probe_for_string
c_func
(paren
l_string|&quot;mc-us3&quot;
comma
id|index
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|chmc_cleanup
r_static
r_void
id|__exit
id|chmc_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|mctrl_list
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|mctrl_info
op_star
id|p
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|mctrl_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|head
)paren
r_break
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|p-&gt;list
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|p-&gt;regs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
DECL|variable|chmc_init
id|module_init
c_func
(paren
id|chmc_init
)paren
suffix:semicolon
DECL|variable|chmc_cleanup
id|module_exit
c_func
(paren
id|chmc_cleanup
)paren
suffix:semicolon
eof
