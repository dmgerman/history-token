multiline_comment|/*&n; * linux/arch/h8300/boot/traps.c -- general exception handling code&n; * H8/300 support Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;&n; * &n; * Cloned from Linux/m68k.&n; *&n; * No original Copyright holder listed,&n; * Probabily original (C) Roman Zippel (assigned DJD, 1999)&n; *&n; * Copyright 1999-2000 D. Jeff Dionne, &lt;jeff@rt-control.com&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/gpio.h&gt;
multiline_comment|/*&n; * this must be called very early as the kernel might&n; * use some instruction that are emulated on the 060&n; */
DECL|function|base_trap_init
r_void
id|__init
id|base_trap_init
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
(paren
r_void
)paren
(brace
)brace
DECL|function|set_esp0
id|asmlinkage
r_void
id|set_esp0
(paren
r_int
r_int
id|ssp
)paren
(brace
id|current-&gt;thread.esp0
op_assign
id|ssp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Generic dumping code. Used for panic and debug.&n; */
DECL|function|dump
r_static
r_void
id|dump
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
op_star
id|sp
suffix:semicolon
r_int
r_char
op_star
id|tp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCURRENT PROCESS:&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_extern
r_int
id|swt_lastjiffies
comma
id|swt_reference
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WATCHDOG: jiffies=%d lastjiffies=%d [%d] reference=%d&bslash;n&quot;
comma
id|jiffies
comma
id|swt_lastjiffies
comma
(paren
id|swt_lastjiffies
op_minus
id|jiffies
)paren
comma
id|swt_reference
)paren
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;COMM=%s PID=%d&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;mm
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_code
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_code
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;brk
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;USER-STACK=%08x  KERNEL-STACK=%08lx&bslash;n&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_stack
comma
(paren
r_int
)paren
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PC: %08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|fp-&gt;pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CCR: %02x   SP: %08lx&bslash;n&quot;
comma
id|fp-&gt;ccr
comma
(paren
r_int
)paren
id|fp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ER0: %08lx  ER1: %08lx   ER2: %08lx   ER3: %08lx&bslash;n&quot;
comma
id|fp-&gt;er0
comma
id|fp-&gt;er1
comma
id|fp-&gt;er2
comma
id|fp-&gt;er3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ER4: %08lx  ER5: %08lx   ER6: %08lx&bslash;n&quot;
comma
id|fp-&gt;er4
comma
id|fp-&gt;er5
comma
id|fp-&gt;er6
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCODE:&quot;
)paren
suffix:semicolon
id|tp
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|fp-&gt;pc
)paren
op_minus
l_int|0x20
suffix:semicolon
r_for
c_loop
(paren
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|tp
comma
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|0x40
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|0x10
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%08x: &quot;
comma
(paren
r_int
)paren
(paren
id|tp
op_plus
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08x &quot;
comma
(paren
r_int
)paren
op_star
id|sp
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nKERNEL STACK:&quot;
)paren
suffix:semicolon
id|tp
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|fp
)paren
op_minus
l_int|0x40
suffix:semicolon
r_for
c_loop
(paren
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|tp
comma
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|0xc0
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|0x10
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%08x: &quot;
comma
(paren
r_int
)paren
(paren
id|tp
op_plus
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08x &quot;
comma
(paren
r_int
)paren
op_star
id|sp
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|STACK_MAGIC
op_ne
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|current
op_plus
id|PAGE_SIZE
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(Possibly corrupted stack page??)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_trace_task
r_void
id|show_trace_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/* DAVIDM: we can do better, need a proper stack dump */
id|printk
c_func
(paren
l_string|&quot;STACK ksp=0x%lx, usp=0x%lx&bslash;n&quot;
comma
id|tsk-&gt;thread.ksp
comma
id|tsk-&gt;thread.usp
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_void
id|die_if_kernel
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_int
id|nr
)paren
(brace
r_extern
r_int
id|console_loglevel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fp-&gt;ccr
op_amp
id|PS_S
)paren
)paren
r_return
suffix:semicolon
id|console_loglevel
op_assign
l_int|15
suffix:semicolon
id|dump
c_func
(paren
id|fp
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
r_extern
r_char
id|_start
comma
id|_etext
suffix:semicolon
DECL|macro|check_kernel_text
mdefine_line|#define check_kernel_text(addr) &bslash;&n;        ((addr &gt;= (unsigned long)(&amp;_start)) &amp;&amp; &bslash;&n;         (addr &lt;  (unsigned long)(&amp;_etext))) 
DECL|variable|kstack_depth_to_print
r_static
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|esp
)paren
(brace
r_int
r_int
op_star
id|stack
comma
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|esp
op_eq
l_int|NULL
)paren
id|esp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|esp
suffix:semicolon
id|stack
op_assign
id|esp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack from %08lx:&quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_mod
l_int|8
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %08lx&quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace:&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|stack
op_assign
id|esp
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the address is either in the text segment of the&n;&t;&t; * kernel, or in the region which contains vmalloc&squot;ed&n;&t;&t; * memory, it *may* be the address of a calling&n;&t;&t; * routine; if so, print it so that someone tracing&n;&t;&t; * down the cause of the crash will be able to figure&n;&t;&t; * out the call path that was taken.&n;&t;&t; */
r_if
c_cond
(paren
id|check_kernel_text
c_func
(paren
id|addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|4
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [&lt;%08lx&gt;]&quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
