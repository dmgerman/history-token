multiline_comment|/* pci-vdk.c: MB93090-MB00 (VDK) PCI support&n; *&n; * Copyright (C) 2003, 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mb-regs.h&gt;
macro_line|#include &lt;asm/mb86943a.h&gt;
macro_line|#include &quot;pci-frv.h&quot;
DECL|variable|pci_probe
r_int
r_int
id|__nongpreldata
id|pci_probe
op_assign
l_int|1
suffix:semicolon
DECL|variable|pcibios_last_bus
r_int
id|__nongpreldata
id|pcibios_last_bus
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|pci_root_bus
r_struct
id|pci_bus
op_star
id|__nongpreldata
id|pci_root_bus
suffix:semicolon
DECL|variable|pci_root_ops
r_struct
id|pci_ops
op_star
id|__nongpreldata
id|pci_root_ops
suffix:semicolon
multiline_comment|/*&n; * Functions for accessing PCI configuration space&n; */
DECL|macro|CONFIG_CMD
mdefine_line|#define CONFIG_CMD(bus, dev, where) &bslash;&n;&t;(0x80000000 | (bus-&gt;number &lt;&lt; 16) | (devfn &lt;&lt; 8) | (where &amp; ~3))
DECL|macro|__set_PciCfgAddr
mdefine_line|#define __set_PciCfgAddr(A) writel((A), (volatile void __iomem *) __region_CS1 + 0x80)
DECL|macro|__get_PciCfgDataB
mdefine_line|#define __get_PciCfgDataB(A) readb((volatile void __iomem *) __region_CS1 + 0x88 + ((A) &amp; 3))
DECL|macro|__get_PciCfgDataW
mdefine_line|#define __get_PciCfgDataW(A) readw((volatile void __iomem *) __region_CS1 + 0x88 + ((A) &amp; 2))
DECL|macro|__get_PciCfgDataL
mdefine_line|#define __get_PciCfgDataL(A) readl((volatile void __iomem *) __region_CS1 + 0x88)
DECL|macro|__set_PciCfgDataB
mdefine_line|#define __set_PciCfgDataB(A,V) writeb((V), (volatile void __iomem *) __region_CS1 + 0x88 + ((A) &amp; 3))
DECL|macro|__set_PciCfgDataW
mdefine_line|#define __set_PciCfgDataW(A,V) writew((V), (volatile void __iomem *) __region_CS1 + 0x88 + ((A) &amp; 2))
DECL|macro|__set_PciCfgDataL
mdefine_line|#define __set_PciCfgDataL(A,V) writel((V), (volatile void __iomem *) __region_CS1 + 0x88)
DECL|macro|__get_PciBridgeDataB
mdefine_line|#define __get_PciBridgeDataB(A) readb((volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|macro|__get_PciBridgeDataW
mdefine_line|#define __get_PciBridgeDataW(A) readw((volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|macro|__get_PciBridgeDataL
mdefine_line|#define __get_PciBridgeDataL(A) readl((volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|macro|__set_PciBridgeDataB
mdefine_line|#define __set_PciBridgeDataB(A,V) writeb((V), (volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|macro|__set_PciBridgeDataW
mdefine_line|#define __set_PciBridgeDataW(A,V) writew((V), (volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|macro|__set_PciBridgeDataL
mdefine_line|#define __set_PciBridgeDataL(A,V) writel((V), (volatile void __iomem *) __region_CS1 + 0x800 + (A))
DECL|function|__query
r_static
r_inline
r_int
id|__query
c_func
(paren
r_const
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
singleline_comment|//&t;return dev-&gt;bus-&gt;number==0 &amp;&amp; (dev-&gt;devfn==PCI_DEVFN(0,0));
singleline_comment|//&t;return dev-&gt;bus-&gt;number==1;
singleline_comment|//&t;return dev-&gt;bus-&gt;number==0 &amp;&amp;
singleline_comment|//&t;&t;(dev-&gt;devfn==PCI_DEVFN(2,0) || dev-&gt;devfn==PCI_DEVFN(3,0));
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&n; */
DECL|function|pci_frv_read_config
r_static
r_int
id|pci_frv_read_config
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
op_star
id|val
)paren
(brace
id|u32
id|_value
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;number
op_eq
l_int|0
op_logical_and
id|devfn
op_eq
id|PCI_DEVFN
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|_value
op_assign
id|__get_PciBridgeDataL
c_func
(paren
id|where
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|__set_PciCfgAddr
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
)paren
)paren
suffix:semicolon
id|_value
op_assign
id|__get_PciCfgDataL
c_func
(paren
id|where
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
id|_value
op_assign
id|_value
op_rshift
(paren
(paren
id|where
op_amp
l_int|3
)paren
op_star
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|_value
op_assign
id|_value
op_rshift
(paren
(paren
id|where
op_amp
l_int|2
)paren
op_star
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|val
op_assign
id|_value
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pci_frv_write_config
r_static
r_int
id|pci_frv_write_config
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
id|value
)paren
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|bus-&gt;number
op_eq
l_int|0
op_logical_and
id|devfn
op_eq
id|PCI_DEVFN
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|__set_PciBridgeDataB
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_else
(brace
id|__set_PciCfgAddr
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
)paren
)paren
suffix:semicolon
id|__set_PciCfgDataB
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|bus-&gt;number
op_eq
l_int|0
op_logical_and
id|devfn
op_eq
id|PCI_DEVFN
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|__set_PciBridgeDataW
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_else
(brace
id|__set_PciCfgAddr
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
)paren
)paren
suffix:semicolon
id|__set_PciCfgDataW
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|bus-&gt;number
op_eq
l_int|0
op_logical_and
id|devfn
op_eq
id|PCI_DEVFN
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|__set_PciBridgeDataL
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_else
(brace
id|__set_PciCfgAddr
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
)paren
)paren
suffix:semicolon
id|__set_PciCfgDataL
c_func
(paren
id|where
comma
id|value
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|variable|pci_direct_frv
r_static
r_struct
id|pci_ops
id|pci_direct_frv
op_assign
(brace
id|pci_frv_read_config
comma
id|pci_frv_write_config
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Before we decide to use direct hardware access mechanisms, we try to do some&n; * trivial checks to ensure it at least _seems_ to be working -- we just test&n; * whether bus 00 contains a host bridge (this is similar to checking&n; * techniques used in XFree86, but ours should be more reliable since we&n; * attempt to make use of direct access hints provided by the PCI BIOS).&n; *&n; * This should be close to trivial, but it isn&squot;t, because there are buggy&n; * chipsets (yes, you guessed it, by Intel and Compaq) that have no class ID.&n; */
DECL|function|pci_sanity_check
r_static
r_int
id|__init
id|pci_sanity_check
c_func
(paren
r_struct
id|pci_ops
op_star
id|o
)paren
(brace
r_struct
id|pci_bus
id|bus
suffix:semicolon
multiline_comment|/* Fake bus and device */
id|u32
id|id
suffix:semicolon
id|bus.number
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|o
op_member_access_from_pointer
id|read
c_func
(paren
op_amp
id|bus
comma
l_int|0
comma
id|PCI_VENDOR_ID
comma
l_int|4
comma
op_amp
id|id
)paren
op_eq
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: VDK Bridge device:vendor: %08x&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0x200e10cf
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PCI: VDK Bridge: Sanity check failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pci_check_direct
r_static
r_struct
id|pci_ops
op_star
id|__init
id|pci_check_direct
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* check if access works */
r_if
c_cond
(paren
id|pci_sanity_check
c_func
(paren
op_amp
id|pci_direct_frv
)paren
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Using configuration frv&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//&t;&t;request_mem_region(0xBE040000, 256, &quot;FRV bridge&quot;);
singleline_comment|//&t;&t;request_mem_region(0xBFFFFFF4, 12, &quot;PCI frv&quot;);
r_return
op_amp
id|pci_direct_frv
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Several buggy motherboards address only 16 devices and mirror&n; * them to next 16 IDs. We try to detect this `feature&squot; on all&n; * primary buses (those containing host bridges as they are&n; * expected to be unique) and remove the ghost devices.&n; */
DECL|function|pcibios_fixup_ghosts
r_static
r_void
id|__init
id|pcibios_fixup_ghosts
c_func
(paren
r_struct
id|pci_bus
op_star
id|b
)paren
(brace
r_struct
id|list_head
op_star
id|ln
comma
op_star
id|mn
suffix:semicolon
r_struct
id|pci_dev
op_star
id|d
comma
op_star
id|e
suffix:semicolon
r_int
id|mirror
op_assign
id|PCI_DEVFN
c_func
(paren
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_int
id|seen_host_bridge
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|b-&gt;devices.next
suffix:semicolon
id|ln
op_ne
op_amp
id|b-&gt;devices
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|d
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_HOST
)paren
id|seen_host_bridge
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|mn
op_assign
id|ln-&gt;next
suffix:semicolon
id|mn
op_ne
op_amp
id|b-&gt;devices
suffix:semicolon
id|mn
op_assign
id|mn-&gt;next
)paren
(brace
id|e
op_assign
id|pci_dev_b
c_func
(paren
id|mn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;devfn
op_ne
id|d-&gt;devfn
op_plus
id|mirror
op_logical_or
id|e-&gt;vendor
op_ne
id|d-&gt;vendor
op_logical_or
id|e-&gt;device
op_ne
id|d-&gt;device
op_logical_or
id|e
op_member_access_from_pointer
r_class
op_ne
id|d
op_member_access_from_pointer
r_class
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|e-&gt;resource
(braket
id|i
)braket
dot
id|start
op_ne
id|d-&gt;resource
(braket
id|i
)braket
dot
id|start
op_logical_or
id|e-&gt;resource
(braket
id|i
)braket
dot
id|end
op_ne
id|d-&gt;resource
(braket
id|i
)braket
dot
id|end
op_logical_or
id|e-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_ne
id|d-&gt;resource
(braket
id|i
)braket
dot
id|flags
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mn
op_eq
op_amp
id|b-&gt;devices
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|seen_host_bridge
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Ignoring ghost devices on bus %02x&bslash;n&quot;
comma
id|b-&gt;number
)paren
suffix:semicolon
id|ln
op_assign
op_amp
id|b-&gt;devices
suffix:semicolon
r_while
c_loop
(paren
id|ln-&gt;next
op_ne
op_amp
id|b-&gt;devices
)paren
(brace
id|d
op_assign
id|pci_dev_b
c_func
(paren
id|ln-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;devfn
op_ge
id|mirror
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|d-&gt;global_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|d-&gt;bus_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|d
)paren
suffix:semicolon
)brace
r_else
id|ln
op_assign
id|ln-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Discover remaining PCI buses in case there are peer host bridges.&n; * We use the number of last PCI bus provided by the PCI BIOS.&n; */
DECL|function|pcibios_fixup_peer_bridges
r_static
r_void
id|__init
id|pcibios_fixup_peer_bridges
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_bus
id|bus
suffix:semicolon
r_struct
id|pci_dev
id|dev
suffix:semicolon
r_int
id|n
suffix:semicolon
id|u16
id|l
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_last_bus
op_le
l_int|0
op_logical_or
id|pcibios_last_bus
op_ge
l_int|0xff
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Peer bridge fixup&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|pcibios_last_bus
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_find_bus
c_func
(paren
l_int|0
comma
id|n
)paren
)paren
r_continue
suffix:semicolon
id|bus.number
op_assign
id|n
suffix:semicolon
id|bus.ops
op_assign
id|pci_root_ops
suffix:semicolon
id|dev.bus
op_assign
op_amp
id|bus
suffix:semicolon
r_for
c_loop
(paren
id|dev.devfn
op_assign
l_int|0
suffix:semicolon
id|dev.devfn
OL
l_int|256
suffix:semicolon
id|dev.devfn
op_add_assign
l_int|8
)paren
r_if
c_cond
(paren
op_logical_neg
id|pci_read_config_word
c_func
(paren
op_amp
id|dev
comma
id|PCI_VENDOR_ID
comma
op_amp
id|l
)paren
op_logical_and
id|l
op_ne
l_int|0x0000
op_logical_and
id|l
op_ne
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Found device at %02x:%02x [%04x]&bslash;n&quot;
comma
id|n
comma
id|dev.devfn
comma
id|l
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Discovered peer bus %02x&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
id|pci_scan_bus
c_func
(paren
id|n
comma
id|pci_root_ops
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Exceptions for specific devices. Usually work-arounds for fatal design flaws.&n; */
DECL|function|pci_fixup_umc_ide
r_static
r_void
id|__init
id|pci_fixup_umc_ide
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
(brace
multiline_comment|/*&n;&t; * UM8886BF IDE controller sets region type bits incorrectly,&n;&t; * therefore they look like memory despite of them being I/O.&n;&t; */
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Fixing base address flags for device %s&bslash;n&quot;
comma
id|d-&gt;slot_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_or_assign
id|PCI_BASE_ADDRESS_SPACE_IO
suffix:semicolon
)brace
)brace
DECL|function|pci_fixup_ide_bases
r_static
r_void
id|__init
id|pci_fixup_ide_bases
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * PCI IDE controllers use non-standard I/O port decoding, respect it.&n;&t; */
r_if
c_cond
(paren
(paren
id|d
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_ne
id|PCI_CLASS_STORAGE_IDE
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: IDE base address fixup for %s&bslash;n&quot;
comma
id|d-&gt;slot_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|r
op_assign
op_amp
id|d-&gt;resource
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r-&gt;start
op_amp
op_complement
l_int|0x80
)paren
op_eq
l_int|0x374
)paren
(brace
id|r-&gt;start
op_or_assign
l_int|2
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
suffix:semicolon
)brace
)brace
)brace
DECL|function|pci_fixup_ide_trash
r_static
r_void
id|__init
id|pci_fixup_ide_trash
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * There exist PCI IDE controllers which have utter garbage&n;&t; * in first four base registers. Ignore that.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;PCI: IDE base address trash cleared for %s&bslash;n&quot;
comma
id|d-&gt;slot_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d-&gt;resource
(braket
id|i
)braket
dot
id|start
op_assign
id|d-&gt;resource
(braket
id|i
)braket
dot
id|end
op_assign
id|d-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|pci_fixup_latency
r_static
r_void
id|__devinit
id|pci_fixup_latency
c_func
(paren
r_struct
id|pci_dev
op_star
id|d
)paren
(brace
multiline_comment|/*&n;&t; *  SiS 5597 and 5598 chipsets require latency timer set to&n;&t; *  at most 32 to avoid lockups.&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;PCI: Setting max latency to 32&bslash;n&quot;
)paren
suffix:semicolon
id|pcibios_max_latency
op_assign
l_int|32
suffix:semicolon
)brace
id|DECLARE_PCI_FIXUP_HEADER
c_func
(paren
id|PCI_VENDOR_ID_UMC
comma
id|PCI_DEVICE_ID_UMC_UM8886BF
comma
id|pci_fixup_umc_ide
)paren
suffix:semicolon
id|DECLARE_PCI_FIXUP_HEADER
c_func
(paren
id|PCI_VENDOR_ID_SI
comma
id|PCI_DEVICE_ID_SI_5513
comma
id|pci_fixup_ide_trash
)paren
suffix:semicolon
id|DECLARE_PCI_FIXUP_HEADER
c_func
(paren
id|PCI_VENDOR_ID_SI
comma
id|PCI_DEVICE_ID_SI_5597
comma
id|pci_fixup_latency
)paren
suffix:semicolon
id|DECLARE_PCI_FIXUP_HEADER
c_func
(paren
id|PCI_VENDOR_ID_SI
comma
id|PCI_DEVICE_ID_SI_5598
comma
id|pci_fixup_latency
)paren
suffix:semicolon
id|DECLARE_PCI_FIXUP_HEADER
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|pci_fixup_ide_bases
)paren
suffix:semicolon
multiline_comment|/*&n; *  Called after each bus is probed, but before its children&n; *  are examined.&n; */
DECL|function|pcibios_fixup_bus
r_void
id|__init
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;### PCIBIOS_FIXUP_BUS(%d)&bslash;n&quot;
comma
id|bus-&gt;number
)paren
suffix:semicolon
macro_line|#endif
id|pcibios_fixup_ghosts
c_func
(paren
id|bus
)paren
suffix:semicolon
id|pci_read_bridge_bases
c_func
(paren
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;number
op_eq
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|bus-&gt;devices.next
suffix:semicolon
id|ln
op_ne
op_amp
id|bus-&gt;devices
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;devfn
op_eq
l_int|0
)paren
(brace
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Initialization. Try all known PCI access methods. Note that we support&n; * using both PCI BIOS and direct access: in such cases, we use I/O ports&n; * to access config space, but we still keep BIOS order of cards to be&n; * compatible with 2.0.X. This should go away some day.&n; */
DECL|function|pcibios_init
r_int
id|__init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_ops
op_star
id|dir
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mb93090_mb00_detected
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|__reg_MB86943_sl_ctl
op_or_assign
id|MB86943_SL_CTL_DRCT_MASTER_SWAP
op_or
id|MB86943_SL_CTL_DRCT_SLAVE_SWAP
suffix:semicolon
id|__reg_MB86943_ecs_base
c_func
(paren
l_int|1
)paren
op_assign
(paren
(paren
id|__region_CS2
op_plus
l_int|0x01000000
)paren
op_rshift
l_int|9
)paren
op_or
l_int|0x08000000
suffix:semicolon
id|__reg_MB86943_ecs_base
c_func
(paren
l_int|2
)paren
op_assign
(paren
(paren
id|__region_CS2
op_plus
l_int|0x00000000
)paren
op_rshift
l_int|9
)paren
op_or
l_int|0x08000000
suffix:semicolon
op_star
(paren
r_volatile
r_uint32
op_star
)paren
(paren
id|__region_CS1
op_plus
l_int|0x848
)paren
op_assign
l_int|0xe0000000
suffix:semicolon
op_star
(paren
r_volatile
r_uint32
op_star
)paren
(paren
id|__region_CS1
op_plus
l_int|0x8b8
)paren
op_assign
l_int|0x00000000
suffix:semicolon
id|__reg_MB86943_sl_pci_io_base
op_assign
(paren
id|__region_CS2
op_plus
l_int|0x04000000
)paren
op_rshift
l_int|9
suffix:semicolon
id|__reg_MB86943_sl_pci_mem_base
op_assign
(paren
id|__region_CS2
op_plus
l_int|0x08000000
)paren
op_rshift
l_int|9
suffix:semicolon
id|__reg_MB86943_pci_sl_io_base
op_assign
id|__region_CS2
op_plus
l_int|0x04000000
suffix:semicolon
id|__reg_MB86943_pci_sl_mem_base
op_assign
id|__region_CS2
op_plus
l_int|0x08000000
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|__region_CS2
op_plus
l_int|0x01300014
)paren
op_eq
l_int|1
suffix:semicolon
id|ioport_resource.start
op_assign
(paren
id|__reg_MB86943_sl_pci_io_base
op_lshift
l_int|9
)paren
op_amp
l_int|0xfffffc00
suffix:semicolon
id|ioport_resource.end
op_assign
(paren
id|__reg_MB86943_sl_pci_io_range
op_lshift
l_int|9
)paren
op_or
l_int|0x3ff
suffix:semicolon
id|ioport_resource.end
op_add_assign
id|ioport_resource.start
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI IO window:  %08lx-%08lx&bslash;n&quot;
comma
id|ioport_resource.start
comma
id|ioport_resource.end
)paren
suffix:semicolon
id|iomem_resource.start
op_assign
(paren
id|__reg_MB86943_sl_pci_mem_base
op_lshift
l_int|9
)paren
op_amp
l_int|0xfffffc00
suffix:semicolon
multiline_comment|/* Reserve somewhere to write to flush posted writes. */
id|iomem_resource.start
op_add_assign
l_int|0x400
suffix:semicolon
id|iomem_resource.end
op_assign
(paren
id|__reg_MB86943_sl_pci_mem_range
op_lshift
l_int|9
)paren
op_or
l_int|0x3ff
suffix:semicolon
id|iomem_resource.end
op_add_assign
id|iomem_resource.start
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI MEM window: %08lx-%08lx&bslash;n&quot;
comma
id|iomem_resource.start
comma
id|iomem_resource.end
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI DMA memory: %08lx-%08lx&bslash;n&quot;
comma
id|dma_coherent_mem_start
comma
id|dma_coherent_mem_end
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_probe
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|dir
op_assign
id|pci_check_direct
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
id|pci_root_ops
op_assign
id|dir
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: No PCI bus detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PCI: Probing PCI hardware&bslash;n&quot;
)paren
suffix:semicolon
id|pci_root_bus
op_assign
id|pci_scan_bus
c_func
(paren
l_int|0
comma
id|pci_root_ops
comma
l_int|NULL
)paren
suffix:semicolon
id|pcibios_irq_init
c_func
(paren
)paren
suffix:semicolon
id|pcibios_fixup_peer_bridges
c_func
(paren
)paren
suffix:semicolon
id|pcibios_fixup_irqs
c_func
(paren
)paren
suffix:semicolon
id|pcibios_resource_survey
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pcibios_init
id|arch_initcall
c_func
(paren
id|pcibios_init
)paren
suffix:semicolon
DECL|function|pcibios_setup
r_char
op_star
id|__init
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;off&quot;
)paren
)paren
(brace
id|pci_probe
op_assign
l_int|0
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;lastbus=&quot;
comma
l_int|8
)paren
)paren
(brace
id|pcibios_last_bus
op_assign
id|simple_strtol
c_func
(paren
id|str
op_plus
l_int|8
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|str
suffix:semicolon
)brace
DECL|function|pcibios_enable_device
r_int
id|pcibios_enable_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|mask
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|pcibios_enable_resources
c_func
(paren
id|dev
comma
id|mask
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|pcibios_enable_irq
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
