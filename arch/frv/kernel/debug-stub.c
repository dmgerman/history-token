multiline_comment|/* debug-stub.c: debug-mode stub&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/serial-regs.h&gt;
macro_line|#include &lt;asm/timer-regs.h&gt;
macro_line|#include &lt;asm/irc-regs.h&gt;
macro_line|#include &lt;asm/gdb-stub.h&gt;
macro_line|#include &quot;gdb-io.h&quot;
multiline_comment|/* CPU board CON5 */
DECL|macro|__UART0
mdefine_line|#define __UART0(X) (*(volatile uint8_t *)(UART0_BASE + (UART_##X)))
DECL|macro|LSR_WAIT_FOR0
mdefine_line|#define LSR_WAIT_FOR0(STATE)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;} while (!(__UART0(LSR) &amp; UART_LSR_##STATE))
DECL|macro|FLOWCTL_QUERY0
mdefine_line|#define FLOWCTL_QUERY0(LINE)&t;({ __UART0(MSR) &amp; UART_MSR_##LINE; })
DECL|macro|FLOWCTL_CLEAR0
mdefine_line|#define FLOWCTL_CLEAR0(LINE)&t;do { __UART0(MCR) &amp;= ~UART_MCR_##LINE; } while (0)
DECL|macro|FLOWCTL_SET0
mdefine_line|#define FLOWCTL_SET0(LINE)&t;do { __UART0(MCR) |= UART_MCR_##LINE; } while (0)
DECL|macro|FLOWCTL_WAIT_FOR0
mdefine_line|#define FLOWCTL_WAIT_FOR0(LINE)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;gdbstub_do_rx();&t;&t;&t;&bslash;&n;} while(!FLOWCTL_QUERY(LINE))
r_static
r_void
id|__init
id|debug_stub_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|__break_hijack_kernel_event
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|__break_hijack_kernel_event_breaks_here
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * debug mode handler stub&n; * - we come here with the CPU in debug mode and with exceptions disabled&n; * - handle debugging services for userspace&n; */
DECL|function|debug_stub
id|asmlinkage
r_void
id|debug_stub
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|hsr0
suffix:semicolon
r_int
id|type
op_assign
l_int|0
suffix:semicolon
r_static
id|u8
id|inited
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inited
)paren
(brace
id|debug_stub_init
c_func
(paren
)paren
suffix:semicolon
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
id|inited
op_assign
l_int|1
suffix:semicolon
)brace
id|hsr0
op_assign
id|__get_HSR
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hsr0
op_amp
id|HSR0_ETMD
)paren
id|__set_HSR
c_func
(paren
l_int|0
comma
id|hsr0
op_amp
op_complement
id|HSR0_ETMD
)paren
suffix:semicolon
multiline_comment|/* disable single stepping */
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
id|DCR_SE
suffix:semicolon
multiline_comment|/* kernel mode can propose an exception be handled in debug mode by jumping to a special&n;&t; * location */
r_if
c_cond
(paren
id|__debug_frame-&gt;pc
op_eq
(paren
r_int
r_int
)paren
id|__break_hijack_kernel_event_breaks_here
)paren
(brace
multiline_comment|/* replace the debug frame with the kernel frame and discard&n;&t;&t; * the top kernel context */
op_star
id|__debug_frame
op_assign
op_star
id|__frame
suffix:semicolon
id|__frame
op_assign
id|__debug_frame-&gt;next_frame
suffix:semicolon
id|__debug_regs-&gt;brr
op_assign
(paren
id|__debug_frame-&gt;tbr
op_amp
id|TBR_TT
)paren
op_lshift
l_int|12
suffix:semicolon
id|__debug_regs-&gt;brr
op_or_assign
id|BRR_EB
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__debug_frame-&gt;pc
op_eq
(paren
r_int
r_int
)paren
id|__debug_bug_trap
op_plus
l_int|4
)paren
(brace
id|__debug_frame-&gt;pc
op_assign
id|__debug_frame-&gt;lr
suffix:semicolon
id|type
op_assign
id|__debug_frame-&gt;gr8
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_GDBSTUB
id|gdbstub
c_func
(paren
id|type
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hsr0
op_amp
id|HSR0_ETMD
)paren
id|__set_HSR
c_func
(paren
l_int|0
comma
id|__get_HSR
c_func
(paren
l_int|0
)paren
op_or
id|HSR0_ETMD
)paren
suffix:semicolon
)brace
multiline_comment|/* end debug_stub() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * debug stub initialisation&n; */
DECL|function|debug_stub_init
r_static
r_void
id|__init
id|debug_stub_init
c_func
(paren
r_void
)paren
(brace
id|__set_IRR
c_func
(paren
l_int|6
comma
l_int|0xff000000
)paren
suffix:semicolon
multiline_comment|/* map ERRs to NMI */
id|__set_IITMR
c_func
(paren
l_int|1
comma
l_int|0x20000000
)paren
suffix:semicolon
multiline_comment|/* ERR0/1, UART0/1 IRQ detect levels */
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,ibar0&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,ibar1&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,ibar2&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,ibar3&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbar0&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr01&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr01&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbar1&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr11&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr11&t;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* deal with debugging stub initialisation and initial pause */
r_if
c_cond
(paren
id|__debug_frame-&gt;pc
op_eq
(paren
r_int
r_int
)paren
id|__debug_stub_init_break
)paren
id|__debug_frame-&gt;pc
op_assign
(paren
r_int
r_int
)paren
id|start_kernel
suffix:semicolon
multiline_comment|/* enable the debug events we want to trap */
id|__debug_regs-&gt;dcr
op_assign
id|DCR_EBE
suffix:semicolon
macro_line|#ifdef CONFIG_GDBSTUB
id|gdbstub_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|__clr_MASK_all
c_func
(paren
)paren
suffix:semicolon
id|__clr_MASK
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|__clr_RC
c_func
(paren
l_int|15
)paren
suffix:semicolon
)brace
multiline_comment|/* end debug_stub_init() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * kernel &quot;exit&quot; trap for gdb stub&n; */
DECL|function|debug_stub_exit
r_void
id|debug_stub_exit
c_func
(paren
r_int
id|status
)paren
(brace
macro_line|#ifdef CONFIG_GDBSTUB
id|gdbstub_exit
c_func
(paren
id|status
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* end debug_stub_exit() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send string to serial port&n; */
DECL|function|debug_to_serial
r_void
id|debug_to_serial
c_func
(paren
r_const
r_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
id|n
op_decrement
)paren
(brace
id|ch
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|FLOWCTL_SET0
c_func
(paren
id|DTR
)paren
suffix:semicolon
id|LSR_WAIT_FOR0
c_func
(paren
id|THRE
)paren
suffix:semicolon
singleline_comment|// FLOWCTL_WAIT_FOR(CTS);
r_if
c_cond
(paren
id|ch
op_eq
l_int|0x0a
)paren
(brace
id|__UART0
c_func
(paren
id|TX
)paren
op_assign
l_int|0x0d
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|LSR_WAIT_FOR0
c_func
(paren
id|THRE
)paren
suffix:semicolon
singleline_comment|// FLOWCTL_WAIT_FOR(CTS);
)brace
id|__UART0
c_func
(paren
id|TX
)paren
op_assign
id|ch
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|FLOWCTL_CLEAR0
c_func
(paren
id|DTR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end debug_to_serial() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send string to serial port&n; */
DECL|function|debug_to_serial2
r_void
id|debug_to_serial2
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|va
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|n
suffix:semicolon
id|va_start
c_func
(paren
id|va
comma
id|fmt
)paren
suffix:semicolon
id|n
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|va
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|va
)paren
suffix:semicolon
id|debug_to_serial
c_func
(paren
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/* end debug_to_serial2() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * set up the ttyS0 serial port baud rate timers&n; */
DECL|function|console_set_baud
r_void
id|__init
id|console_set_baud
c_func
(paren
r_int
id|baud
)paren
(brace
r_int
id|value
comma
id|high
comma
id|low
suffix:semicolon
id|u8
id|lcr
suffix:semicolon
multiline_comment|/* work out the divisor to give us the nearest higher baud rate */
id|value
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
id|baud
suffix:semicolon
multiline_comment|/* determine the baud rate range */
id|high
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
id|value
suffix:semicolon
id|low
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
(paren
id|value
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* pick the nearest bound */
r_if
c_cond
(paren
id|low
op_plus
(paren
id|high
op_minus
id|low
)paren
op_div
l_int|2
OG
id|baud
)paren
id|value
op_increment
suffix:semicolon
id|lcr
op_assign
id|__UART0
c_func
(paren
id|LCR
)paren
suffix:semicolon
id|__UART0
c_func
(paren
id|LCR
)paren
op_or_assign
id|UART_LCR_DLAB
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|__UART0
c_func
(paren
id|DLL
)paren
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
id|__UART0
c_func
(paren
id|DLM
)paren
op_assign
(paren
id|value
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|__UART0
c_func
(paren
id|LCR
)paren
op_assign
id|lcr
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end console_set_baud() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&n; */
DECL|function|console_get_baud
r_int
id|__init
id|console_get_baud
c_func
(paren
r_void
)paren
(brace
r_int
id|value
suffix:semicolon
id|u8
id|lcr
suffix:semicolon
id|lcr
op_assign
id|__UART0
c_func
(paren
id|LCR
)paren
suffix:semicolon
id|__UART0
c_func
(paren
id|LCR
)paren
op_or_assign
id|UART_LCR_DLAB
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
id|__UART0
c_func
(paren
id|DLM
)paren
op_lshift
l_int|8
suffix:semicolon
id|value
op_or_assign
id|__UART0
c_func
(paren
id|DLL
)paren
suffix:semicolon
id|__UART0
c_func
(paren
id|LCR
)paren
op_assign
id|lcr
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* end console_get_baud() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * display BUG() info&n; */
macro_line|#ifndef CONFIG_NO_KERNEL_MSG
DECL|function|__debug_bug_printk
r_void
id|__debug_bug_printk
c_func
(paren
r_const
r_char
op_star
id|file
comma
r_int
id|line
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kernel BUG at %s:%d!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/* end __debug_bug_printk() */
macro_line|#endif
eof
