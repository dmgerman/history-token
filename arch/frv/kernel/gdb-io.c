multiline_comment|/* gdb-io.c: FR403 GDB stub I/O&n; *&n; * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irc-regs.h&gt;
macro_line|#include &lt;asm/timer-regs.h&gt;
macro_line|#include &lt;asm/gdb-stub.h&gt;
macro_line|#include &quot;gdb-io.h&quot;
macro_line|#ifdef CONFIG_GDBSTUB_UART0
DECL|macro|__UART
mdefine_line|#define __UART(X) (*(volatile uint8_t *)(UART0_BASE + (UART_##X)))
DECL|macro|__UART_IRR_NMI
mdefine_line|#define __UART_IRR_NMI 0xff0f0000
macro_line|#else /* CONFIG_GDBSTUB_UART1 */
DECL|macro|__UART
mdefine_line|#define __UART(X) (*(volatile uint8_t *)(UART1_BASE + (UART_##X)))
DECL|macro|__UART_IRR_NMI
mdefine_line|#define __UART_IRR_NMI 0xfff00000
macro_line|#endif
DECL|macro|LSR_WAIT_FOR
mdefine_line|#define LSR_WAIT_FOR(STATE)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;gdbstub_do_rx();&t;&t;&t;&bslash;&n;} while (!(__UART(LSR) &amp; UART_LSR_##STATE))
DECL|macro|FLOWCTL_QUERY
mdefine_line|#define FLOWCTL_QUERY(LINE)&t;({ __UART(MSR) &amp; UART_MSR_##LINE; })
DECL|macro|FLOWCTL_CLEAR
mdefine_line|#define FLOWCTL_CLEAR(LINE)&t;do { __UART(MCR) &amp;= ~UART_MCR_##LINE; mb(); } while (0)
DECL|macro|FLOWCTL_SET
mdefine_line|#define FLOWCTL_SET(LINE)&t;do { __UART(MCR) |= UART_MCR_##LINE;  mb(); } while (0)
DECL|macro|FLOWCTL_WAIT_FOR
mdefine_line|#define FLOWCTL_WAIT_FOR(LINE)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;gdbstub_do_rx();&t;&t;&t;&bslash;&n;} while(!FLOWCTL_QUERY(LINE))
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * initialise the GDB stub&n; * - called with PSR.ET==0, so can&squot;t incur external interrupts&n; */
DECL|function|gdbstub_io_init
r_void
id|gdbstub_io_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* set up the serial port */
id|__UART
c_func
(paren
id|LCR
)paren
op_assign
id|UART_LCR_WLEN8
suffix:semicolon
multiline_comment|/* 1N8 */
id|__UART
c_func
(paren
id|FCR
)paren
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
op_or
id|UART_FCR_TRIGGER_1
suffix:semicolon
id|FLOWCTL_CLEAR
c_func
(paren
id|DTR
)paren
suffix:semicolon
id|FLOWCTL_SET
c_func
(paren
id|RTS
)paren
suffix:semicolon
singleline_comment|//&t;gdbstub_set_baud(115200);
multiline_comment|/* we want to get serial receive interrupts */
id|__UART
c_func
(paren
id|IER
)paren
op_assign
id|UART_IER_RDI
op_or
id|UART_IER_RLSI
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|__set_IRR
c_func
(paren
l_int|6
comma
id|__UART_IRR_NMI
)paren
suffix:semicolon
multiline_comment|/* map ERRs and UARTx to NMI */
)brace
multiline_comment|/* end gdbstub_io_init() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * set up the GDB stub serial port baud rate timers&n; */
DECL|function|gdbstub_set_baud
r_void
id|gdbstub_set_baud
c_func
(paren
r_int
id|baud
)paren
(brace
r_int
id|value
comma
id|high
comma
id|low
suffix:semicolon
id|u8
id|lcr
suffix:semicolon
multiline_comment|/* work out the divisor to give us the nearest higher baud rate */
id|value
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
id|baud
suffix:semicolon
multiline_comment|/* determine the baud rate range */
id|high
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
id|value
suffix:semicolon
id|low
op_assign
id|__serial_clock_speed_HZ
op_div
l_int|16
op_div
(paren
id|value
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* pick the nearest bound */
r_if
c_cond
(paren
id|low
op_plus
(paren
id|high
op_minus
id|low
)paren
op_div
l_int|2
OG
id|baud
)paren
id|value
op_increment
suffix:semicolon
id|lcr
op_assign
id|__UART
c_func
(paren
id|LCR
)paren
suffix:semicolon
id|__UART
c_func
(paren
id|LCR
)paren
op_or_assign
id|UART_LCR_DLAB
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|__UART
c_func
(paren
id|DLL
)paren
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
id|__UART
c_func
(paren
id|DLM
)paren
op_assign
(paren
id|value
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|__UART
c_func
(paren
id|LCR
)paren
op_assign
id|lcr
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_set_baud() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * receive characters into the receive FIFO&n; */
DECL|function|gdbstub_do_rx
r_void
id|gdbstub_do_rx
c_func
(paren
r_void
)paren
(brace
r_int
id|ix
comma
id|nix
suffix:semicolon
id|ix
op_assign
id|gdbstub_rx_inp
suffix:semicolon
r_while
c_loop
(paren
id|__UART
c_func
(paren
id|LSR
)paren
op_amp
id|UART_LSR_DR
)paren
(brace
id|nix
op_assign
(paren
id|ix
op_plus
l_int|2
)paren
op_amp
l_int|0xfff
suffix:semicolon
r_if
c_cond
(paren
id|nix
op_eq
id|gdbstub_rx_outp
)paren
r_break
suffix:semicolon
id|gdbstub_rx_buffer
(braket
id|ix
op_increment
)braket
op_assign
id|__UART
c_func
(paren
id|LSR
)paren
suffix:semicolon
id|gdbstub_rx_buffer
(braket
id|ix
op_increment
)braket
op_assign
id|__UART
c_func
(paren
id|RX
)paren
suffix:semicolon
id|ix
op_assign
id|nix
suffix:semicolon
)brace
id|gdbstub_rx_inp
op_assign
id|ix
suffix:semicolon
id|__clr_RC
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|__clr_IRL
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_do_rx() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * wait for a character to come from the debugger&n; */
DECL|function|gdbstub_rx_char
r_int
id|gdbstub_rx_char
c_func
(paren
r_int
r_char
op_star
id|_ch
comma
r_int
id|nonblock
)paren
(brace
r_int
id|ix
suffix:semicolon
id|u8
id|ch
comma
id|st
suffix:semicolon
op_star
id|_ch
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|gdbstub_rx_unget
)paren
(brace
op_star
id|_ch
op_assign
id|gdbstub_rx_unget
suffix:semicolon
id|gdbstub_rx_unget
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|try_again
suffix:colon
id|gdbstub_do_rx
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* pull chars out of the buffer */
id|ix
op_assign
id|gdbstub_rx_outp
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_eq
id|gdbstub_rx_inp
)paren
(brace
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
singleline_comment|//watchdog_alert_counter = 0;
r_goto
id|try_again
suffix:semicolon
)brace
id|st
op_assign
id|gdbstub_rx_buffer
(braket
id|ix
op_increment
)braket
suffix:semicolon
id|ch
op_assign
id|gdbstub_rx_buffer
(braket
id|ix
op_increment
)braket
suffix:semicolon
id|gdbstub_rx_outp
op_assign
id|ix
op_amp
l_int|0x00000fff
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|UART_LSR_BI
)paren
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx Break Detected ###&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st
op_amp
(paren
id|UART_LSR_FE
op_or
id|UART_LSR_OE
op_or
id|UART_LSR_PE
)paren
)paren
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx Error (st=%02x) ###&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx %02x (st=%02x) ###&bslash;n&quot;
comma
id|ch
comma
id|st
)paren
suffix:semicolon
op_star
id|_ch
op_assign
id|ch
op_amp
l_int|0x7f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* end gdbstub_rx_char() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send a character to the debugger&n; */
DECL|function|gdbstub_tx_char
r_void
id|gdbstub_tx_char
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
id|FLOWCTL_SET
c_func
(paren
id|DTR
)paren
suffix:semicolon
id|LSR_WAIT_FOR
c_func
(paren
id|THRE
)paren
suffix:semicolon
singleline_comment|//&t;FLOWCTL_WAIT_FOR(CTS);
r_if
c_cond
(paren
id|ch
op_eq
l_int|0x0a
)paren
(brace
id|__UART
c_func
(paren
id|TX
)paren
op_assign
l_int|0x0d
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|LSR_WAIT_FOR
c_func
(paren
id|THRE
)paren
suffix:semicolon
singleline_comment|//&t;&t;FLOWCTL_WAIT_FOR(CTS);
)brace
id|__UART
c_func
(paren
id|TX
)paren
op_assign
id|ch
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|FLOWCTL_CLEAR
c_func
(paren
id|DTR
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_tx_char() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send a character to the debugger&n; */
DECL|function|gdbstub_tx_flush
r_void
id|gdbstub_tx_flush
c_func
(paren
r_void
)paren
(brace
id|LSR_WAIT_FOR
c_func
(paren
id|TEMT
)paren
suffix:semicolon
id|LSR_WAIT_FOR
c_func
(paren
id|THRE
)paren
suffix:semicolon
id|FLOWCTL_CLEAR
c_func
(paren
id|DTR
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_tx_flush() */
eof
