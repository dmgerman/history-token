multiline_comment|/* gdb-stub.c: FRV GDB stub&n; *&n; * Copyright (C) 2003,4 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; * - Derived from Linux/MIPS version, Copyright (C) 1995 Andreas Busse&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to set_debug_traps() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint().  Breakpoint()&n; *  simulates a breakpoint by executing a BREAK instruction.&n; *&n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *    bBB..BB&t;    Set baud rate to BB..BB&t;&t;   OK or BNN, then sets&n; *&t;&t;&t;&t;&t;&t;&t;   baud rate&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; *&n; *  ==============&n; *  MORE EXAMPLES:&n; *  ==============&n; *&n; *  For reference -- the following are the steps that one&n; *  company took (RidgeRun Inc) to get remote gdb debugging&n; *  going. In this scenario the host machine was a PC and the&n; *  target platform was a Galileo EVB64120A MIPS evaluation&n; *  board.&n; *&n; *  Step 1:&n; *  First download gdb-5.0.tar.gz from the internet.&n; *  and then build/install the package.&n; *&n; *  Example:&n; *    $ tar zxf gdb-5.0.tar.gz&n; *    $ cd gdb-5.0&n; *    $ ./configure --target=frv-elf-gdb&n; *    $ make&n; *    $ frv-elf-gdb&n; *&n; *  Step 2:&n; *  Configure linux for remote debugging and build it.&n; *&n; *  Example:&n; *    $ cd ~/linux&n; *    $ make menuconfig &lt;go to &quot;Kernel Hacking&quot; and turn on remote debugging&gt;&n; *    $ make dep; make vmlinux&n; *&n; *  Step 3:&n; *  Download the kernel to the remote target and start&n; *  the kernel running. It will promptly halt and wait&n; *  for the host gdb session to connect. It does this&n; *  since the &quot;Kernel Hacking&quot; option has defined&n; *  CONFIG_REMOTE_DEBUG which in turn enables your calls&n; *  to:&n; *     set_debug_traps();&n; *     breakpoint();&n; *&n; *  Step 4:&n; *  Start the gdb session on the host.&n; *&n; *  Example:&n; *    $ frv-elf-gdb vmlinux&n; *    (gdb) set remotebaud 115200&n; *    (gdb) target remote /dev/ttyS1&n; *    ...at this point you are connected to&n; *       the remote target and can use gdb&n; *       in the normal fasion. Setting&n; *       breakpoints, single stepping,&n; *       printing variables, etc.&n; *&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/nmi.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/gdb-stub.h&gt;
DECL|macro|LEDS
mdefine_line|#define LEDS(x) do { /* *(u32*)0xe1200004 = ~(x); mb(); */ } while(0)
DECL|macro|GDBSTUB_DEBUG_PROTOCOL
macro_line|#undef GDBSTUB_DEBUG_PROTOCOL
r_extern
r_void
id|debug_to_serial
c_func
(paren
r_const
r_char
op_star
id|p
comma
r_int
id|n
)paren
suffix:semicolon
r_extern
r_void
id|gdbstub_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|p
comma
r_int
id|n
)paren
suffix:semicolon
r_extern
r_volatile
r_uint32
id|__break_error_detect
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* ESFR1, ESR15, EAR15 */
r_extern
r_struct
id|user_context
id|__break_user_context
suffix:semicolon
DECL|struct|__debug_amr
r_struct
id|__debug_amr
(brace
DECL|member|L
DECL|member|P
r_int
r_int
id|L
comma
id|P
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
DECL|struct|__debug_mmu
r_struct
id|__debug_mmu
(brace
r_struct
(brace
DECL|member|hsr0
DECL|member|pcsr
DECL|member|esr0
DECL|member|ear0
DECL|member|epcr0
r_int
r_int
id|hsr0
comma
id|pcsr
comma
id|esr0
comma
id|ear0
comma
id|epcr0
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
DECL|member|tplr
DECL|member|tppr
DECL|member|tpxr
DECL|member|cxnr
r_int
r_int
id|tplr
comma
id|tppr
comma
id|tpxr
comma
id|cxnr
suffix:semicolon
macro_line|#endif
DECL|member|regs
)brace
id|regs
suffix:semicolon
DECL|member|iamr
r_struct
id|__debug_amr
id|iamr
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|damr
r_struct
id|__debug_amr
id|damr
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
DECL|member|tlb
r_struct
id|__debug_amr
id|tlb
(braket
l_int|64
op_star
l_int|2
)braket
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|__debug_mmu
r_static
r_struct
id|__debug_mmu
id|__debug_mmu
suffix:semicolon
multiline_comment|/*&n; * BUFMAX defines the maximum number of characters in inbound/outbound buffers&n; * at least NUMREGBYTES*2 are needed for register packets&n; */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 2048
DECL|macro|BREAK_INSN
mdefine_line|#define BREAK_INSN&t;0x801000c0&t;/* use &quot;break&quot; as bkpt */
DECL|variable|gdbstub_banner
r_static
r_const
r_char
id|gdbstub_banner
(braket
)braket
op_assign
l_string|&quot;Linux/FR-V GDB Stub (c) RedHat 2003&bslash;n&quot;
suffix:semicolon
DECL|variable|gdbstub_rx_buffer
r_volatile
id|u8
id|gdbstub_rx_buffer
(braket
id|PAGE_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
DECL|variable|gdbstub_rx_inp
r_volatile
id|u32
id|gdbstub_rx_inp
op_assign
l_int|0
suffix:semicolon
DECL|variable|gdbstub_rx_outp
r_volatile
id|u32
id|gdbstub_rx_outp
op_assign
l_int|0
suffix:semicolon
DECL|variable|gdbstub_rx_overflow
r_volatile
id|u8
id|gdbstub_rx_overflow
op_assign
l_int|0
suffix:semicolon
DECL|variable|gdbstub_rx_unget
id|u8
id|gdbstub_rx_unget
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set with GDB whilst running to permit step through exceptions */
r_extern
r_volatile
id|u32
id|__attribute__
c_func
(paren
(paren
id|section
c_func
(paren
l_string|&quot;.bss&quot;
)paren
)paren
)paren
id|gdbstub_trace_through_exceptions
suffix:semicolon
DECL|variable|input_buffer
r_static
r_char
id|input_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|output_buffer
r_static
r_char
id|output_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
DECL|variable|regnames
r_static
r_const
r_char
op_star
id|regnames
(braket
)braket
op_assign
(brace
l_string|&quot;PSR &quot;
comma
l_string|&quot;ISR &quot;
comma
l_string|&quot;CCR &quot;
comma
l_string|&quot;CCCR&quot;
comma
l_string|&quot;LR  &quot;
comma
l_string|&quot;LCR &quot;
comma
l_string|&quot;PC  &quot;
comma
l_string|&quot;_stt&quot;
comma
l_string|&quot;sys &quot;
comma
l_string|&quot;GR8*&quot;
comma
l_string|&quot;GNE0&quot;
comma
l_string|&quot;GNE1&quot;
comma
l_string|&quot;IACH&quot;
comma
l_string|&quot;IACL&quot;
comma
l_string|&quot;TBR &quot;
comma
l_string|&quot;SP  &quot;
comma
l_string|&quot;FP  &quot;
comma
l_string|&quot;GR3 &quot;
comma
l_string|&quot;GR4 &quot;
comma
l_string|&quot;GR5 &quot;
comma
l_string|&quot;GR6 &quot;
comma
l_string|&quot;GR7 &quot;
comma
l_string|&quot;GR8 &quot;
comma
l_string|&quot;GR9 &quot;
comma
l_string|&quot;GR10&quot;
comma
l_string|&quot;GR11&quot;
comma
l_string|&quot;GR12&quot;
comma
l_string|&quot;GR13&quot;
comma
l_string|&quot;GR14&quot;
comma
l_string|&quot;GR15&quot;
comma
l_string|&quot;GR16&quot;
comma
l_string|&quot;GR17&quot;
comma
l_string|&quot;GR18&quot;
comma
l_string|&quot;GR19&quot;
comma
l_string|&quot;GR20&quot;
comma
l_string|&quot;GR21&quot;
comma
l_string|&quot;GR22&quot;
comma
l_string|&quot;GR23&quot;
comma
l_string|&quot;GR24&quot;
comma
l_string|&quot;GR25&quot;
comma
l_string|&quot;GR26&quot;
comma
l_string|&quot;GR27&quot;
comma
l_string|&quot;EFRM&quot;
comma
l_string|&quot;CURR&quot;
comma
l_string|&quot;GR30&quot;
comma
l_string|&quot;BFRM&quot;
)brace
suffix:semicolon
DECL|struct|gdbstub_bkpt
r_struct
id|gdbstub_bkpt
(brace
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* address of breakpoint */
DECL|member|len
r_int
id|len
suffix:semicolon
multiline_comment|/* size of breakpoint */
DECL|member|originsns
r_uint32
id|originsns
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* original instructions */
)brace
suffix:semicolon
DECL|variable|gdbstub_bkpts
r_static
r_struct
id|gdbstub_bkpt
id|gdbstub_bkpts
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n; * local prototypes&n; */
r_static
r_void
id|gdbstub_recv_packet
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|gdbstub_send_packet
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|gdbstub_compute_signal
c_func
(paren
r_int
r_int
id|tbr
)paren
suffix:semicolon
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
r_int
op_star
id|intValue
)paren
suffix:semicolon
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_const
r_void
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_void
op_star
id|_mem
comma
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Convert ch from a hex digit to an int&n; */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|gdbstub_printk
r_void
id|gdbstub_printk
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Emit the output into the temporary buffer */
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|debug_to_serial
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_strcpy
r_static
r_inline
r_char
op_star
id|gdbstub_strcpy
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_int
id|loop
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dst
(braket
id|loop
)braket
op_assign
id|src
(braket
id|loop
)braket
)paren
)paren
id|loop
op_increment
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
DECL|function|gdbstub_purge_cache
r_static
r_void
id|gdbstub_purge_cache
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;&t;dcef&t;@(gr0,gr0),#1&t;&bslash;n&quot;
l_string|&quot;&t;icei&t;@(gr0,gr0),#1&t;&bslash;n&quot;
l_string|&quot;&t;membar&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;bar&t;&t;&t;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * scan for the sequence $&lt;data&gt;#&lt;checksum&gt;&n; */
DECL|function|gdbstub_recv_packet
r_static
r_void
id|gdbstub_recv_packet
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_int
id|count
comma
id|i
comma
id|ret
comma
id|error
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* wait around for the start character, ignore all other characters */
r_do
(brace
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now, read until a # or end of buffer is found */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ret
op_assign
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|error
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EIO
)paren
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx Error - Skipping packet ###&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx NAK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
id|BUFMAX
op_logical_or
id|error
)paren
r_continue
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read the checksum */
id|ret
op_assign
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|error
op_assign
id|ret
suffix:semicolon
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|ch
)paren
op_lshift
l_int|4
suffix:semicolon
id|ret
op_assign
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|error
op_assign
id|ret
suffix:semicolon
id|xmitcsum
op_or_assign
id|hex
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EIO
)paren
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx Error - Skipping packet&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx NAK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* check the checksum */
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx NAK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* failed checksum */
r_continue
suffix:semicolon
)brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx &squot;$%s#%02x&squot; ###&bslash;n&quot;
comma
id|buffer
comma
id|checksum
)paren
suffix:semicolon
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx ACK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* successful transfer */
multiline_comment|/* if a sequence char is present, reply the sequence ID */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|gdbstub_tx_char
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* remove sequence chars from buffer */
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buffer
(braket
id|count
)braket
)paren
id|count
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end gdbstub_recv_packet() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send the packet in buffer.&n; * - return 0 if successfully ACK&squot;d&n; * - return 1 if abandoned due to new incoming packet&n; */
DECL|function|gdbstub_send_packet
r_static
r_int
id|gdbstub_send_packet
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/* $&lt;packet info&gt;#&lt;checksum&gt; */
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx &squot;%s&squot; ###&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
r_do
(brace
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|gdbstub_tx_char
c_func
(paren
id|ch
)paren
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
comma
macro_line|#ifdef GDBSTUB_DEBUG_PROTOCOL
id|ch
op_eq
l_char|&squot;-&squot;
op_logical_and
(paren
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx NAK&bslash;n&quot;
)paren
comma
l_int|0
)paren
comma
id|ch
op_ne
l_char|&squot;-&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;+&squot;
op_logical_and
(paren
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx ??? %02x&bslash;n&quot;
comma
id|ch
)paren
comma
l_int|0
)paren
comma
macro_line|#endif
id|ch
op_ne
l_char|&squot;+&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Rx ACK&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx Abandoned&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_rx_unget
op_assign
id|ch
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_send_packet() */
multiline_comment|/*&n; * While we find nice hex chars, build an int.&n; * Return number of chars processed.&n; */
DECL|function|hexToInt
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
r_int
op_star
id|_value
)paren
(brace
r_int
id|count
op_assign
l_int|0
comma
id|ch
suffix:semicolon
op_star
id|_value
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|_value
op_assign
(paren
op_star
id|_value
op_lshift
l_int|4
)paren
op_or
(paren
(paren
r_uint8
)paren
id|ch
op_amp
l_int|0xf
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * probe an address to see whether it maps to anything&n; */
DECL|function|gdbstub_addr_probe
r_static
r_inline
r_int
id|gdbstub_addr_probe
c_func
(paren
r_const
r_void
op_star
id|vaddr
)paren
(brace
macro_line|#ifdef CONFIG_MMU
r_int
r_int
id|paddr
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;lrad %1,%0,#1,#0,#0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|paddr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|vaddr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|paddr
op_amp
id|xAMPRx_V
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_addr_probe() */
macro_line|#ifdef CONFIG_MMU
DECL|variable|__saved_dampr
DECL|variable|__saved_damlr
r_static
r_int
r_int
id|__saved_dampr
comma
id|__saved_damlr
suffix:semicolon
DECL|function|gdbstub_virt_to_pte
r_static
r_inline
r_int
r_int
id|gdbstub_virt_to_pte
c_func
(paren
r_int
r_int
id|vaddr
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|val
comma
id|dampr5
suffix:semicolon
id|pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|__get_DAMLR
c_func
(paren
l_int|3
)paren
op_plus
id|pgd_index
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|vaddr
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
op_logical_or
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* make sure dampr5 maps to the correct pmd */
id|dampr5
op_assign
id|__get_DAMPR
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|val
op_assign
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
id|__set_DAMPR
c_func
(paren
l_int|5
comma
id|val
op_or
id|xAMPRx_L
op_or
id|xAMPRx_SS_16Kb
op_or
id|xAMPRx_S
op_or
id|xAMPRx_C
op_or
id|xAMPRx_V
)paren
suffix:semicolon
multiline_comment|/* now its safe to access pmd */
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|__get_DAMLR
c_func
(paren
l_int|5
)paren
op_plus
id|__pte_index
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
id|val
op_assign
id|pte_val
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
r_else
id|val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* restore original dampr5 */
id|__set_DAMPR
c_func
(paren
l_int|5
comma
id|dampr5
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
macro_line|#endif
DECL|function|gdbstub_addr_map
r_static
r_inline
r_int
id|gdbstub_addr_map
c_func
(paren
r_const
r_void
op_star
id|vaddr
)paren
(brace
macro_line|#ifdef CONFIG_MMU
r_int
r_int
id|pte
suffix:semicolon
id|__saved_dampr
op_assign
id|__get_DAMPR
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|__saved_damlr
op_assign
id|__get_DAMLR
c_func
(paren
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|gdbstub_addr_probe
c_func
(paren
id|vaddr
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
id|pte
op_assign
id|gdbstub_virt_to_pte
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte
)paren
(brace
id|__set_DAMPR
c_func
(paren
l_int|2
comma
id|pte
)paren
suffix:semicolon
id|__set_DAMLR
c_func
(paren
l_int|2
comma
(paren
r_int
r_int
)paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gdbstub_addr_unmap
r_static
r_inline
r_void
id|gdbstub_addr_unmap
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_MMU
id|__set_DAMPR
c_func
(paren
l_int|2
comma
id|__saved_dampr
)paren
suffix:semicolon
id|__set_DAMLR
c_func
(paren
l_int|2
comma
id|__saved_damlr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * access potentially dodgy memory through a potentially dodgy pointer&n; */
DECL|function|gdbstub_read_dword
r_static
r_inline
r_int
id|gdbstub_read_dword
c_func
(paren
r_const
r_void
op_star
id|addr
comma
r_uint32
op_star
id|_res
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_uint32
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;ld%I2&t;%M2,%0&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%1&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
comma
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint32
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
op_star
id|_res
op_assign
id|res
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_write_dword
r_static
r_inline
r_int
id|gdbstub_write_dword
c_func
(paren
r_void
op_star
id|addr
comma
r_uint32
id|val
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;st%I2&t;%1,%M2&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%0&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint32
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_read_word
r_static
r_inline
r_int
id|gdbstub_read_word
c_func
(paren
r_const
r_void
op_star
id|addr
comma
r_uint16
op_star
id|_res
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_uint16
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;lduh%I2&t;%M2,%0&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%1&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
comma
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint16
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
op_star
id|_res
op_assign
id|res
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_write_word
r_static
r_inline
r_int
id|gdbstub_write_word
c_func
(paren
r_void
op_star
id|addr
comma
r_uint16
id|val
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;sth%I2&t;%1,%M2&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%0&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint16
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_read_byte
r_static
r_inline
r_int
id|gdbstub_read_byte
c_func
(paren
r_const
r_void
op_star
id|addr
comma
r_uint8
op_star
id|_res
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_uint8
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;ldub%I2&t;%M2,%0&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%1&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
comma
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint8
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
op_star
id|_res
op_assign
id|res
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|gdbstub_write_byte
r_static
r_inline
r_int
id|gdbstub_write_byte
c_func
(paren
r_void
op_star
id|addr
comma
r_uint8
id|val
)paren
(brace
r_int
r_int
id|brr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_addr_map
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,brr&t;&bslash;n&quot;
l_string|&quot;&t;stb%I2&t;%1,%M2&t;&bslash;n&quot;
l_string|&quot;&t;movsg&t;brr,%0&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|brr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
(paren
r_uint8
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
id|gdbstub_addr_unmap
c_func
(paren
)paren
suffix:semicolon
r_return
id|likely
c_func
(paren
op_logical_neg
id|brr
)paren
suffix:semicolon
)brace
DECL|function|__gdbstub_console_write
r_static
r_void
id|__gdbstub_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
r_char
id|outbuf
(braket
l_int|26
)braket
suffix:semicolon
r_int
id|qty
suffix:semicolon
id|outbuf
(braket
l_int|0
)braket
op_assign
l_char|&squot;O&squot;
suffix:semicolon
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
id|qty
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|n
OG
l_int|0
op_logical_and
id|qty
OL
l_int|20
)paren
(brace
id|mem2hex
c_func
(paren
id|p
comma
id|outbuf
op_plus
id|qty
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|qty
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0x0a
)paren
(brace
id|outbuf
(braket
id|qty
op_increment
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|outbuf
(braket
id|qty
op_increment
)braket
op_assign
l_char|&squot;d&squot;
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|n
op_decrement
suffix:semicolon
)brace
id|outbuf
(braket
id|qty
)braket
op_assign
l_int|0
suffix:semicolon
id|gdbstub_send_packet
c_func
(paren
id|outbuf
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
r_void
id|debug_to_serial
c_func
(paren
r_const
r_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
id|gdbstub_console_write
c_func
(paren
l_int|NULL
comma
id|p
comma
id|n
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_GDBSTUB_CONSOLE
DECL|function|gdbstub_console_dev
r_static
id|kdev_t
id|gdbstub_console_dev
c_func
(paren
r_struct
id|console
op_star
id|con
)paren
(brace
r_return
id|MKDEV
c_func
(paren
l_int|1
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* /dev/null */
)brace
DECL|variable|gdbstub_console
r_static
r_struct
id|console
id|gdbstub_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;gdb&quot;
comma
dot
id|write
op_assign
id|gdbstub_console_write
comma
multiline_comment|/* in break.S */
dot
id|device
op_assign
id|gdbstub_console_dev
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * Convert the memory pointed to by mem into hex, placing result in buf.&n; * - if successful, return a pointer to the last char put in buf (NUL)&n; * - in case of mem fault, return NULL&n; * may_fault is non-zero if we are reading from arbitrary memory, but is currently&n; * not used.&n; */
DECL|function|mem2hex
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_const
r_void
op_star
id|_mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_const
r_uint8
op_star
id|mem
op_assign
id|_mem
suffix:semicolon
r_uint8
id|ch
(braket
l_int|4
)braket
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_uint32
)paren
id|mem
op_amp
l_int|1
op_logical_and
id|count
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_byte
c_func
(paren
id|mem
comma
id|ch
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
id|mem
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_uint32
)paren
id|mem
op_amp
l_int|3
op_logical_and
id|count
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_word
c_func
(paren
id|mem
comma
(paren
r_uint16
op_star
)paren
id|ch
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
id|mem
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_dword
c_func
(paren
id|mem
comma
(paren
r_uint32
op_star
)paren
id|ch
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|2
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|2
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|3
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|3
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
id|mem
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_word
c_func
(paren
id|mem
comma
(paren
r_uint16
op_star
)paren
id|ch
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|1
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
id|mem
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_byte
c_func
(paren
id|mem
comma
id|ch
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
(braket
l_int|0
)braket
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/* end mem2hex() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * convert the hex array pointed to by buf into binary to be placed in mem&n; * return a pointer to the character AFTER the last byte of buffer consumed&n; */
DECL|function|hex2mem
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_void
op_star
id|_mem
comma
r_int
id|count
)paren
(brace
r_uint8
op_star
id|mem
op_assign
id|_mem
suffix:semicolon
r_union
(brace
r_uint32
id|l
suffix:semicolon
r_uint16
id|w
suffix:semicolon
r_uint8
id|b
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|ch
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u32
)paren
id|mem
op_amp
l_int|1
op_logical_and
id|count
op_ge
l_int|1
)paren
(brace
id|ch.b
(braket
l_int|0
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|0
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_byte
c_func
(paren
id|mem
comma
id|ch.b
(braket
l_int|0
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|mem
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|u32
)paren
id|mem
op_amp
l_int|3
op_logical_and
id|count
op_ge
l_int|2
)paren
(brace
id|ch.b
(braket
l_int|0
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|0
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_word
c_func
(paren
id|mem
comma
id|ch.w
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|mem
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
l_int|4
)paren
(brace
id|ch.b
(braket
l_int|0
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|0
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ch.b
(braket
l_int|2
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|2
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ch.b
(braket
l_int|3
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|3
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_dword
c_func
(paren
id|mem
comma
id|ch.l
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|mem
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|2
)paren
(brace
id|ch.b
(braket
l_int|0
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|0
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|1
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_word
c_func
(paren
id|mem
comma
id|ch.w
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|mem
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|1
)paren
(brace
id|ch.b
(braket
l_int|0
)braket
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch.b
(braket
l_int|0
)braket
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_byte
c_func
(paren
id|mem
comma
id|ch.b
(braket
l_int|0
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
)brace
multiline_comment|/* end hex2mem() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * This table contains the mapping between FRV TBR.TT exception codes,&n; * and signals, which are primarily what GDB understands.  It also&n; * indicates which hardware traps we need to commandeer when&n; * initializing the stub.&n; */
DECL|struct|brr_to_sig_map
r_static
r_const
r_struct
id|brr_to_sig_map
(brace
DECL|member|brr_mask
r_int
r_int
id|brr_mask
suffix:semicolon
multiline_comment|/* BRR bitmask */
DECL|member|tbr_tt
r_int
r_int
id|tbr_tt
suffix:semicolon
multiline_comment|/* TBR.TT code (in BRR.EBTT) */
DECL|member|signo
r_int
r_int
id|signo
suffix:semicolon
multiline_comment|/* Signal that we map this into */
DECL|variable|brr_to_sig_map
)brace
id|brr_to_sig_map
(braket
)braket
op_assign
(brace
(brace
id|BRR_EB
comma
id|TBR_TT_INSTR_ACC_ERROR
comma
id|SIGSEGV
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_ILLEGAL_INSTR
comma
id|SIGILL
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_PRIV_INSTR
comma
id|SIGILL
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_MP_EXCEPTION
comma
id|SIGFPE
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_DATA_ACC_ERROR
comma
id|SIGSEGV
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_DATA_STR_ERROR
comma
id|SIGSEGV
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_DIVISION_EXCEP
comma
id|SIGFPE
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_COMPOUND_EXCEP
comma
id|SIGSEGV
)brace
comma
(brace
id|BRR_EB
comma
id|TBR_TT_INTERRUPT_13
comma
id|SIGALRM
)brace
comma
multiline_comment|/* watchdog */
(brace
id|BRR_EB
comma
id|TBR_TT_INTERRUPT_14
comma
id|SIGINT
)brace
comma
multiline_comment|/* GDB serial */
(brace
id|BRR_EB
comma
id|TBR_TT_INTERRUPT_15
comma
id|SIGQUIT
)brace
comma
multiline_comment|/* NMI */
(brace
id|BRR_CB
comma
l_int|0
comma
id|SIGUSR1
)brace
comma
(brace
id|BRR_TB
comma
l_int|0
comma
id|SIGUSR2
)brace
comma
(brace
id|BRR_DBNEx
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
(brace
id|BRR_DBx
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* h/w watchpoint */
(brace
id|BRR_IBx
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* h/w breakpoint */
(brace
id|BRR_CBB
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
(brace
id|BRR_SB
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
(brace
id|BRR_ST
comma
l_int|0
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* single step */
(brace
l_int|0
comma
l_int|0
comma
id|SIGHUP
)brace
multiline_comment|/* default */
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * convert the FRV BRR register contents into a UNIX signal number&n; */
DECL|function|gdbstub_compute_signal
r_static
r_inline
r_int
id|gdbstub_compute_signal
c_func
(paren
r_int
r_int
id|brr
)paren
(brace
r_const
r_struct
id|brr_to_sig_map
op_star
id|map
suffix:semicolon
r_int
r_int
id|tbr
op_assign
(paren
id|brr
op_amp
id|BRR_EBTT
)paren
op_rshift
l_int|12
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|brr_to_sig_map
suffix:semicolon
id|map-&gt;brr_mask
suffix:semicolon
id|map
op_increment
)paren
r_if
c_cond
(paren
id|map-&gt;brr_mask
op_amp
id|brr
)paren
r_if
c_cond
(paren
op_logical_neg
id|map-&gt;tbr_tt
op_logical_or
id|map-&gt;tbr_tt
op_eq
id|tbr
)paren
r_break
suffix:semicolon
r_return
id|map-&gt;signo
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_compute_signal() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * set a software breakpoint or a hardware breakpoint or watchpoint&n; */
DECL|function|gdbstub_set_breakpoint
r_static
r_int
id|gdbstub_set_breakpoint
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|bkpt
comma
id|loop
comma
id|xloop
suffix:semicolon
r_union
(brace
r_struct
(brace
r_int
r_int
id|mask0
comma
id|mask1
suffix:semicolon
)brace
suffix:semicolon
r_uint8
id|bytes
(braket
l_int|8
)braket
suffix:semicolon
)brace
id|dbmr
suffix:semicolon
singleline_comment|//gdbstub_printk(&quot;setbkpt(%ld,%08lx,%ld)&bslash;n&quot;, type, addr, len);
r_switch
c_cond
(paren
id|type
)paren
(brace
multiline_comment|/* set software breakpoint */
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|addr
op_amp
l_int|3
op_logical_or
id|len
OG
l_int|7
op_star
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|bkpt
op_assign
l_int|255
suffix:semicolon
id|bkpt
op_ge
l_int|0
suffix:semicolon
id|bkpt
op_decrement
)paren
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bkpt
OL
l_int|0
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
op_div
l_int|4
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_read_dword
c_func
(paren
op_amp
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
id|loop
)braket
comma
op_amp
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|originsns
(braket
id|loop
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
op_div
l_int|4
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_dword
c_func
(paren
op_amp
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
id|loop
)braket
comma
id|BREAK_INSN
)paren
)paren
(brace
multiline_comment|/* need to undo the changes if possible */
r_for
c_loop
(paren
id|xloop
op_assign
l_int|0
suffix:semicolon
id|xloop
OL
id|loop
suffix:semicolon
id|xloop
op_increment
)paren
id|gdbstub_write_dword
c_func
(paren
op_amp
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
id|xloop
)braket
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|originsns
(braket
id|xloop
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
macro_line|#if 0
id|gdbstub_printk
c_func
(paren
l_string|&quot;Set BKPT[%02x]: %08lx #%d {%04x, %04x} -&gt; { %04x, %04x }&bslash;n&quot;
comma
id|bkpt
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|len
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|originsns
(braket
l_int|0
)braket
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|originsns
(braket
l_int|1
)braket
comma
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* set hardware breakpoint */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|addr
op_amp
l_int|3
op_logical_or
id|len
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE0
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w break 0: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_or_assign
id|DCR_IBE0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,ibar0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE1
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w break 1: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_or_assign
id|DCR_IBE1
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,ibar1&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE2
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w break 2: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_or_assign
id|DCR_IBE2
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,ibar2&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE3
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w break 3: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_or_assign
id|DCR_IBE3
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,ibar3&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* set data read/write/access watchpoint */
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
l_int|7
)paren
op_ne
(paren
(paren
id|addr
op_plus
id|len
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|7
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|addr
op_amp
l_int|7
suffix:semicolon
id|memset
c_func
(paren
id|dbmr.bytes
comma
l_int|0xff
comma
r_sizeof
(paren
id|dbmr.bytes
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
suffix:semicolon
id|loop
op_increment
)paren
id|dbmr.bytes
(braket
id|tmp
op_plus
id|loop
)braket
op_assign
l_int|0
suffix:semicolon
id|addr
op_and_assign
op_complement
l_int|7
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
(paren
id|DCR_DRBE0
op_or
id|DCR_DWBE0
)paren
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w watchpoint 0 type %ld: %08lx&bslash;n&quot;, type, addr);
id|tmp
op_assign
id|type
op_eq
l_int|2
ques
c_cond
id|DCR_DWBE0
suffix:colon
id|type
op_eq
l_int|3
ques
c_cond
id|DCR_DRBE0
suffix:colon
id|DCR_DRBE0
op_or
id|DCR_DWBE0
suffix:semicolon
id|__debug_regs-&gt;dcr
op_or_assign
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;%0,dbar0&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;%1,dbmr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;%2,dbmr01&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr01&t;&bslash;n&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
comma
l_string|&quot;r&quot;
(paren
id|dbmr.mask0
)paren
comma
l_string|&quot;r&quot;
(paren
id|dbmr.mask1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|__debug_regs-&gt;dcr
op_amp
(paren
id|DCR_DRBE1
op_or
id|DCR_DWBE1
)paren
)paren
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;set h/w watchpoint 1 type %ld: %08lx&bslash;n&quot;, type, addr);
id|tmp
op_assign
id|type
op_eq
l_int|2
ques
c_cond
id|DCR_DWBE1
suffix:colon
id|type
op_eq
l_int|3
ques
c_cond
id|DCR_DRBE1
suffix:colon
id|DCR_DRBE1
op_or
id|DCR_DWBE1
suffix:semicolon
id|__debug_regs-&gt;dcr
op_or_assign
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;%0,dbar1&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;%1,dbmr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;%2,dbmr11&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr11&t;&bslash;n&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
comma
l_string|&quot;r&quot;
(paren
id|dbmr.mask0
)paren
comma
l_string|&quot;r&quot;
(paren
id|dbmr.mask1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* end gdbstub_set_breakpoint() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * clear a breakpoint or watchpoint&n; */
DECL|function|gdbstub_clear_breakpoint
r_int
id|gdbstub_clear_breakpoint
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|bkpt
comma
id|loop
suffix:semicolon
r_union
(brace
r_struct
(brace
r_int
r_int
id|mask0
comma
id|mask1
suffix:semicolon
)brace
suffix:semicolon
r_uint8
id|bytes
(braket
l_int|8
)braket
suffix:semicolon
)brace
id|dbmr
suffix:semicolon
singleline_comment|//gdbstub_printk(&quot;clearbkpt(%ld,%08lx,%ld)&bslash;n&quot;, type, addr, len);
r_switch
c_cond
(paren
id|type
)paren
(brace
multiline_comment|/* clear software breakpoint */
r_case
l_int|0
suffix:colon
r_for
c_loop
(paren
id|bkpt
op_assign
l_int|255
suffix:semicolon
id|bkpt
op_ge
l_int|0
suffix:semicolon
id|bkpt
op_decrement
)paren
r_if
c_cond
(paren
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
op_eq
id|addr
op_logical_and
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|len
op_eq
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bkpt
OL
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
op_div
l_int|4
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|gdbstub_write_dword
c_func
(paren
op_amp
(paren
(paren
r_uint32
op_star
)paren
id|addr
)paren
(braket
id|loop
)braket
comma
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|originsns
(braket
id|loop
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* clear hardware breakpoint */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|addr
op_amp
l_int|3
op_logical_or
id|len
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
DECL|macro|__get_ibar
mdefine_line|#define __get_ibar(X) ({ unsigned long x; asm volatile(&quot;movsg ibar&quot;#X&quot;,%0&quot; : &quot;=r&quot;(x)); x; })
r_if
c_cond
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE0
op_logical_and
id|__get_ibar
c_func
(paren
l_int|0
)paren
op_eq
id|addr
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;clear h/w break 0: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
id|DCR_IBE0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs gr0,ibar0&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE1
op_logical_and
id|__get_ibar
c_func
(paren
l_int|1
)paren
op_eq
id|addr
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;clear h/w break 1: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
id|DCR_IBE1
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs gr0,ibar1&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE2
op_logical_and
id|__get_ibar
c_func
(paren
l_int|2
)paren
op_eq
id|addr
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;clear h/w break 2: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
id|DCR_IBE2
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs gr0,ibar2&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__debug_regs-&gt;dcr
op_amp
id|DCR_IBE3
op_logical_and
id|__get_ibar
c_func
(paren
l_int|3
)paren
op_eq
id|addr
)paren
(brace
singleline_comment|//gdbstub_printk(&quot;clear h/w break 3: %08lx&bslash;n&quot;, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
id|DCR_IBE3
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs gr0,ibar3&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* clear data read/write/access watchpoint */
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
l_int|7
)paren
op_ne
(paren
(paren
id|addr
op_plus
id|len
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|7
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|addr
op_amp
l_int|7
suffix:semicolon
id|memset
c_func
(paren
id|dbmr.bytes
comma
l_int|0xff
comma
r_sizeof
(paren
id|dbmr.bytes
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
suffix:semicolon
id|loop
op_increment
)paren
id|dbmr.bytes
(braket
id|tmp
op_plus
id|loop
)braket
op_assign
l_int|0
suffix:semicolon
id|addr
op_and_assign
op_complement
l_int|7
suffix:semicolon
DECL|macro|__get_dbar
mdefine_line|#define __get_dbar(X) ({ unsigned long x; asm volatile(&quot;movsg dbar&quot;#X&quot;,%0&quot; : &quot;=r&quot;(x)); x; })
DECL|macro|__get_dbmr0
mdefine_line|#define __get_dbmr0(X) ({ unsigned long x; asm volatile(&quot;movsg dbmr&quot;#X&quot;0,%0&quot; : &quot;=r&quot;(x)); x; })
DECL|macro|__get_dbmr1
mdefine_line|#define __get_dbmr1(X) ({ unsigned long x; asm volatile(&quot;movsg dbmr&quot;#X&quot;1,%0&quot; : &quot;=r&quot;(x)); x; })
multiline_comment|/* consider DBAR 0 */
id|tmp
op_assign
id|type
op_eq
l_int|2
ques
c_cond
id|DCR_DWBE0
suffix:colon
id|type
op_eq
l_int|3
ques
c_cond
id|DCR_DRBE0
suffix:colon
id|DCR_DRBE0
op_or
id|DCR_DWBE0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__debug_regs-&gt;dcr
op_amp
(paren
id|DCR_DRBE0
op_or
id|DCR_DWBE0
)paren
)paren
op_ne
id|tmp
op_logical_or
id|__get_dbar
c_func
(paren
l_int|0
)paren
op_ne
id|addr
op_logical_or
id|__get_dbmr0
c_func
(paren
l_int|0
)paren
op_ne
id|dbmr.mask0
op_logical_or
id|__get_dbmr1
c_func
(paren
l_int|0
)paren
op_ne
id|dbmr.mask1
)paren
r_goto
id|skip_dbar0
suffix:semicolon
singleline_comment|//gdbstub_printk(&quot;clear h/w watchpoint 0 type %ld: %08lx&bslash;n&quot;, type, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
(paren
id|DCR_DRBE0
op_or
id|DCR_DWBE0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,dbar0&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr01&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr00&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr01&t;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|skip_dbar0
suffix:colon
multiline_comment|/* consider DBAR 0 */
id|tmp
op_assign
id|type
op_eq
l_int|2
ques
c_cond
id|DCR_DWBE1
suffix:colon
id|type
op_eq
l_int|3
ques
c_cond
id|DCR_DRBE1
suffix:colon
id|DCR_DRBE1
op_or
id|DCR_DWBE1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__debug_regs-&gt;dcr
op_amp
(paren
id|DCR_DRBE1
op_or
id|DCR_DWBE1
)paren
)paren
op_ne
id|tmp
op_logical_or
id|__get_dbar
c_func
(paren
l_int|1
)paren
op_ne
id|addr
op_logical_or
id|__get_dbmr0
c_func
(paren
l_int|1
)paren
op_ne
id|dbmr.mask0
op_logical_or
id|__get_dbmr1
c_func
(paren
l_int|1
)paren
op_ne
id|dbmr.mask1
)paren
r_goto
id|skip_dbar1
suffix:semicolon
singleline_comment|//gdbstub_printk(&quot;clear h/w watchpoint 1 type %ld: %08lx&bslash;n&quot;, type, addr);
id|__debug_regs-&gt;dcr
op_and_assign
op_complement
(paren
id|DCR_DRBE1
op_or
id|DCR_DWBE1
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;movgs&t;gr0,dbar1&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbmr11&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr10&t;&bslash;n&quot;
l_string|&quot;&t;movgs&t;gr0,dbdr11&t;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|skip_dbar1
suffix:colon
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* end gdbstub_clear_breakpoint() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * check a for an internal software breakpoint, and wind the PC back if necessary&n; */
DECL|function|gdbstub_check_breakpoint
r_static
r_void
id|gdbstub_check_breakpoint
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
op_assign
id|__debug_frame-&gt;pc
op_minus
l_int|4
suffix:semicolon
r_int
id|bkpt
suffix:semicolon
r_for
c_loop
(paren
id|bkpt
op_assign
l_int|255
suffix:semicolon
id|bkpt
op_ge
l_int|0
suffix:semicolon
id|bkpt
op_decrement
)paren
r_if
c_cond
(paren
id|gdbstub_bkpts
(braket
id|bkpt
)braket
dot
id|addr
op_eq
id|addr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bkpt
op_ge
l_int|0
)paren
id|__debug_frame-&gt;pc
op_assign
id|addr
suffix:semicolon
singleline_comment|//gdbstub_printk(&quot;alter pc [%d] %08lx&bslash;n&quot;, bkpt, __debug_frame-&gt;pc);
)brace
multiline_comment|/* end gdbstub_check_breakpoint() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&n; */
DECL|function|gdbstub_show_regs
r_static
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|gdbstub_show_regs
c_func
(paren
r_void
)paren
(brace
r_uint32
op_star
id|reg
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;Frame: @%p [%s]&bslash;n&quot;
comma
id|__debug_frame
comma
id|__debug_frame-&gt;psr
op_amp
id|PSR_S
ques
c_cond
l_string|&quot;kernel&quot;
suffix:colon
l_string|&quot;user&quot;
)paren
suffix:semicolon
id|reg
op_assign
(paren
r_uint32
op_star
)paren
id|__debug_frame
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|REG__END
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s %08x&quot;
comma
id|regnames
(braket
id|loop
op_plus
l_int|0
)braket
comma
id|reg
(braket
id|loop
op_plus
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loop
op_eq
id|REG__END
op_minus
l_int|1
op_logical_or
id|loop
op_mod
l_int|5
op_eq
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; | &quot;
)paren
suffix:semicolon
)brace
id|gdbstub_printk
c_func
(paren
l_string|&quot;Process %s (pid: %d)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_show_regs() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dump debugging regs&n; */
DECL|function|gdbstub_dump_debugregs
r_static
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|gdbstub_dump_debugregs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
id|x
op_assign
id|__debug_regs-&gt;dcr
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DCR    %08lx  &quot;
comma
id|x
)paren
suffix:semicolon
id|x
op_assign
id|__debug_regs-&gt;brr
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;BRR %08lx&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;IBAR0  %08lx  &quot;
comma
id|__get_ibar
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;IBAR1  %08lx  &quot;
comma
id|__get_ibar
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;IBAR2  %08lx  &quot;
comma
id|__get_ibar
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;IBAR3  %08lx&bslash;n&quot;
comma
id|__get_ibar
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBAR0  %08lx  &quot;
comma
id|__get_dbar
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBMR00 %08lx  &quot;
comma
id|__get_dbmr0
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBMR01 %08lx&bslash;n&quot;
comma
id|__get_dbmr1
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBAR1  %08lx  &quot;
comma
id|__get_dbar
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBMR10 %08lx  &quot;
comma
id|__get_dbmr0
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DBMR11 %08lx&bslash;n&quot;
comma
id|__get_dbmr1
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_dump_debugregs() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dump the MMU state into a structure so that it can be accessed with GDB&n; */
DECL|function|gdbstub_get_mmu_state
r_void
id|gdbstub_get_mmu_state
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;movsg hsr0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.hsr0
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg pcsr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.pcsr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg esr0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.esr0
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg ear0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.ear0
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg epcr0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.epcr0
)paren
)paren
suffix:semicolon
multiline_comment|/* read the protection / SAT registers */
id|__debug_mmu.iamr
(braket
l_int|0
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|0
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|1
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|1
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|2
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|2
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|3
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|3
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|4
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|4
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|5
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|5
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|6
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|6
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|7
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|7
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|8
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|8
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|9
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|9
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|10
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|10
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|11
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|11
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|12
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|12
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|13
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|13
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|14
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|14
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|15
)braket
dot
id|L
op_assign
id|__get_IAMLR
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|__debug_mmu.iamr
(braket
l_int|15
)braket
dot
id|P
op_assign
id|__get_IAMPR
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|0
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|0
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|1
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|1
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|2
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|2
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|3
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|3
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|4
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|4
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|5
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|5
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|6
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|6
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|7
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|7
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|8
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|8
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|9
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|9
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|10
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|10
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|11
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|11
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|12
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|12
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|13
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|13
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|14
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|14
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|15
)braket
dot
id|L
op_assign
id|__get_DAMLR
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|__debug_mmu.damr
(braket
l_int|15
)braket
dot
id|P
op_assign
id|__get_DAMPR
c_func
(paren
l_int|15
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
r_do
(brace
multiline_comment|/* read the DAT entries from the TLB */
r_struct
id|__debug_amr
op_star
id|p
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tplr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.tplr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tppr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.tppr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tpxr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.tpxr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg cxnr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_mmu.regs.cxnr
)paren
)paren
suffix:semicolon
id|p
op_assign
id|__debug_mmu.tlb
suffix:semicolon
multiline_comment|/* way 0 */
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,tpxr&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
l_int|0
op_lshift
id|TPXR_WAY_SHIFT
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|64
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;tlbpr %0,gr0,#1,#0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|loop
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tplr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|p-&gt;L
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tppr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|p-&gt;P
)paren
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* way 1 */
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,tpxr&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
l_int|1
op_lshift
id|TPXR_WAY_SHIFT
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|64
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;tlbpr %0,gr0,#1,#0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|loop
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tplr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|p-&gt;L
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg tppr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|p-&gt;P
)paren
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,tplr&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|__debug_mmu.regs.tplr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,tppr&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|__debug_mmu.regs.tppr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,tpxr&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|__debug_mmu.regs.tpxr
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* end gdbstub_get_mmu_state() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * handle event interception and GDB remote protocol processing&n; * - on entry:&n; *&t;PSR.ET==0, PSR.S==1 and the CPU is in debug mode&n; *&t;__debug_frame points to the saved registers&n; *&t;__frame points to the kernel mode exception frame, if it was in kernel&n; *      mode when the break happened&n; */
DECL|function|gdbstub
r_void
id|gdbstub
c_func
(paren
r_int
id|sigval
)paren
(brace
r_int
r_int
id|addr
comma
id|length
comma
id|loop
comma
id|dbar
comma
id|temp
comma
id|temp2
comma
id|temp3
suffix:semicolon
r_uint32
id|zero
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|flush_cache
op_assign
l_int|0
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sigval
OL
l_int|0
)paren
(brace
macro_line|#ifndef CONFIG_GDBSTUB_IMMEDIATE
multiline_comment|/* return immediately if GDB immediate activation option not set */
r_return
suffix:semicolon
macro_line|#else
id|sigval
op_assign
id|SIGINT
suffix:semicolon
macro_line|#endif
)brace
id|save_user_regs
c_func
(paren
op_amp
id|__break_user_context
)paren
suffix:semicolon
macro_line|#if 0
id|gdbstub_printk
c_func
(paren
l_string|&quot;--&gt; gdbstub() %08x %p %08x %08x&bslash;n&quot;
comma
id|__debug_frame-&gt;pc
comma
id|__debug_frame
comma
id|__debug_regs-&gt;brr
comma
id|__debug_regs-&gt;bpsr
)paren
suffix:semicolon
singleline_comment|//&t;gdbstub_show_regs();
macro_line|#endif
id|LEDS
c_func
(paren
l_int|0x5001
)paren
suffix:semicolon
multiline_comment|/* if we were interrupted by input on the serial gdbstub serial port,&n;&t; * restore the context prior to the interrupt so that we return to that&n;&t; * directly&n;&t; */
id|temp
op_assign
(paren
r_int
r_int
)paren
id|__entry_kerneltrap_table
suffix:semicolon
id|temp2
op_assign
(paren
r_int
r_int
)paren
id|__entry_usertrap_table
suffix:semicolon
id|temp3
op_assign
id|__debug_frame-&gt;pc
op_amp
op_complement
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|temp3
op_eq
id|temp
op_plus
id|TBR_TT_INTERRUPT_15
op_logical_or
id|temp3
op_eq
id|temp2
op_plus
id|TBR_TT_INTERRUPT_15
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;movsg pcsr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_frame-&gt;pc
)paren
)paren
suffix:semicolon
id|__debug_frame-&gt;psr
op_or_assign
id|PSR_ET
suffix:semicolon
id|__debug_frame-&gt;psr
op_and_assign
op_complement
id|PSR_S
suffix:semicolon
r_if
c_cond
(paren
id|__debug_frame-&gt;psr
op_amp
id|PSR_PS
)paren
id|__debug_frame-&gt;psr
op_or_assign
id|PSR_S
suffix:semicolon
id|__debug_regs-&gt;brr
op_assign
(paren
id|__debug_frame-&gt;tbr
op_amp
id|TBR_TT
)paren
op_lshift
l_int|12
suffix:semicolon
id|__debug_regs-&gt;brr
op_or_assign
id|BRR_EB
suffix:semicolon
id|sigval
op_assign
id|SIGINT
suffix:semicolon
)brace
multiline_comment|/* handle the decrement timer going off (FR451 only) */
r_if
c_cond
(paren
id|temp3
op_eq
id|temp
op_plus
id|TBR_TT_DECREMENT_TIMER
op_logical_or
id|temp3
op_eq
id|temp2
op_plus
id|TBR_TT_DECREMENT_TIMER
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,timerd&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
l_int|10000000
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg pcsr,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__debug_frame-&gt;pc
)paren
)paren
suffix:semicolon
id|__debug_frame-&gt;psr
op_or_assign
id|PSR_ET
suffix:semicolon
id|__debug_frame-&gt;psr
op_and_assign
op_complement
id|PSR_S
suffix:semicolon
r_if
c_cond
(paren
id|__debug_frame-&gt;psr
op_amp
id|PSR_PS
)paren
id|__debug_frame-&gt;psr
op_or_assign
id|PSR_S
suffix:semicolon
id|__debug_regs-&gt;brr
op_assign
(paren
id|__debug_frame-&gt;tbr
op_amp
id|TBR_TT
)paren
op_lshift
l_int|12
suffix:semicolon
id|__debug_regs-&gt;brr
op_or_assign
id|BRR_EB
suffix:semicolon
id|sigval
op_assign
id|SIGXCPU
suffix:semicolon
suffix:semicolon
)brace
id|LEDS
c_func
(paren
l_int|0x5002
)paren
suffix:semicolon
multiline_comment|/* after a BREAK insn, the PC lands on the far side of it */
r_if
c_cond
(paren
id|__debug_regs-&gt;brr
op_amp
id|BRR_SB
)paren
id|gdbstub_check_breakpoint
c_func
(paren
)paren
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5003
)paren
suffix:semicolon
multiline_comment|/* handle attempts to write console data via GDB &quot;O&quot; commands */
r_if
c_cond
(paren
id|__debug_frame-&gt;pc
op_eq
(paren
r_int
r_int
)paren
id|gdbstub_console_write
op_plus
l_int|4
)paren
(brace
id|__gdbstub_console_write
c_func
(paren
(paren
r_struct
id|console
op_star
)paren
id|__debug_frame-&gt;gr8
comma
(paren
r_const
r_char
op_star
)paren
id|__debug_frame-&gt;gr9
comma
(paren
r_int
)paren
id|__debug_frame-&gt;gr10
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gdbstub_rx_unget
)paren
(brace
id|sigval
op_assign
id|SIGINT
suffix:semicolon
r_goto
id|packet_waiting
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sigval
)paren
id|sigval
op_assign
id|gdbstub_compute_signal
c_func
(paren
id|__debug_regs-&gt;brr
)paren
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5004
)paren
suffix:semicolon
multiline_comment|/* send a message to the debugger&squot;s user saying what happened if it may&n;&t; * not be clear cut (we can&squot;t map exceptions onto signals properly)&n;&t; */
r_if
c_cond
(paren
id|sigval
op_ne
id|SIGINT
op_logical_and
id|sigval
op_ne
id|SIGTRAP
op_logical_and
id|sigval
op_ne
id|SIGILL
)paren
(brace
r_static
r_const
r_char
id|title
(braket
)braket
op_assign
l_string|&quot;Break &quot;
suffix:semicolon
r_static
r_const
r_char
id|crlf
(braket
)braket
op_assign
l_string|&quot;&bslash;r&bslash;n&quot;
suffix:semicolon
r_int
r_int
id|brr
op_assign
id|__debug_regs-&gt;brr
suffix:semicolon
r_char
id|hx
suffix:semicolon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;O&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
id|title
comma
id|ptr
comma
r_sizeof
(paren
id|title
)paren
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0xf0000000
)paren
op_rshift
l_int|28
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x0f000000
)paren
op_rshift
l_int|24
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x00f00000
)paren
op_rshift
l_int|20
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x000f0000
)paren
op_rshift
l_int|16
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x0000f000
)paren
op_rshift
l_int|12
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x00000f00
)paren
op_rshift
l_int|8
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x000000f0
)paren
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|hx
op_assign
id|hexchars
(braket
(paren
id|brr
op_amp
l_int|0x0000000f
)paren
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|hx
op_amp
l_int|0xf
)braket
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
id|crlf
comma
id|ptr
comma
r_sizeof
(paren
id|crlf
)paren
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
id|gdbstub_send_packet
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
multiline_comment|/* send it off... */
)brace
id|LEDS
c_func
(paren
l_int|0x5005
)paren
suffix:semicolon
multiline_comment|/* tell the debugger that an exception has occurred */
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/* Send trap type (converted to signal) */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
multiline_comment|/* Send Error PC */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_PC
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_PC
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;pc
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send frame pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_FP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_FP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;fp
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send stack pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_SP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDB_REG_SP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;sp
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|gdbstub_send_packet
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
multiline_comment|/* send it off... */
id|LEDS
c_func
(paren
l_int|0x5006
)paren
suffix:semicolon
id|packet_waiting
suffix:colon
id|gdbstub_get_mmu_state
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for input from remote GDB */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5007
)paren
suffix:semicolon
id|gdbstub_recv_packet
c_func
(paren
id|input_buffer
)paren
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5600
op_or
id|input_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* request repeat of last signal number */
r_case
l_char|&squot;?&squot;
suffix:colon
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|output_buffer
(braket
l_int|1
)braket
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|2
)braket
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* toggle debug flag */
r_break
suffix:semicolon
multiline_comment|/* return the value of the CPU registers&n;&t;&t;&t; * - GR0,  GR1,  GR2,  GR3,  GR4,  GR5,  GR6,  GR7,&n;&t;&t;&t; * - GR8,  GR9,  GR10, GR11, GR12, GR13, GR14, GR15,&n;&t;&t;&t; * - GR16, GR17, GR18, GR19, GR20, GR21, GR22, GR23,&n;&t;&t;&t; * - GR24, GR25, GR26, GR27, GR28, GR29, GR30, GR31,&n;&t;&t;&t; * - GR32, GR33, GR34, GR35, GR36, GR37, GR38, GR39,&n;&t;&t;&t; * - GR40, GR41, GR42, GR43, GR44, GR45, GR46, GR47,&n;&t;&t;&t; * - GR48, GR49, GR50, GR51, GR52, GR53, GR54, GR55,&n;&t;&t;&t; * - GR56, GR57, GR58, GR59, GR60, GR61, GR62, GR63,&n;&t;&t;&t; * - FP0,  FP1,  FP2,  FP3,  FP4,  FP5,  FP6,  FP7,&n;&t;&t;&t; * - FP8,  FP9,  FP10, FP11, FP12, FP13, FP14, FP15,&n;&t;&t;&t; * - FP16, FP17, FP18, FP19, FP20, FP21, FP22, FP23,&n;&t;&t;&t; * - FP24, FP25, FP26, FP27, FP28, FP29, FP30, FP31,&n;&t;&t;&t; * - FP32, FP33, FP34, FP35, FP36, FP37, FP38, FP39,&n;&t;&t;&t; * - FP40, FP41, FP42, FP43, FP44, FP45, FP46, FP47,&n;&t;&t;&t; * - FP48, FP49, FP50, FP51, FP52, FP53, FP54, FP55,&n;&t;&t;&t; * - FP56, FP57, FP58, FP59, FP60, FP61, FP62, FP63,&n;&t;&t;&t; * - PC, PSR, CCR, CCCR,&n;&t;&t;&t; * - _X132, _X133, _X134&n;&t;&t;&t; * - TBR, BRR, DBAR0, DBAR1, DBAR2, DBAR3,&n;&t;&t;&t; * - _X141, _X142, _X143, _X144,&n;&t;&t;&t; * - LR, LCR&n;&t;&t;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
id|zero
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/* deal with GR0, GR1-GR27, GR28-GR31, GR32-GR63 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|zero
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|1
suffix:semicolon
id|loop
op_le
l_int|27
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
id|loop
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|temp
op_assign
(paren
r_int
r_int
)paren
id|__frame
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|temp
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
l_int|29
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
l_int|30
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
l_int|31
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|temp
op_assign
(paren
r_int
r_int
)paren
id|__debug_frame
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|temp
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|loop
op_assign
l_int|32
suffix:semicolon
id|loop
op_le
l_int|63
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
id|loop
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* deal with FR0-FR63 */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|63
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|__break_user_context
op_plus
id|__FPMEDIA_FR
c_func
(paren
id|loop
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* deal with special registers */
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;pc
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;psr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;ccr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;cccr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|zero
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|zero
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|zero
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;tbr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_regs-&gt;brr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg dbar0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg dbar1,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg dbar2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg dbar3,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg scr0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg scr1,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg scr2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movsg scr3,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dbar
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|dbar
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;lr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;lcr
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;iacc0
comma
id|ptr
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.fsr
(braket
l_int|0
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|7
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.acc
(braket
id|loop
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.accg
comma
id|ptr
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|1
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.msr
(braket
id|loop
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;gner0
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__debug_frame-&gt;gner1
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.fner
(braket
l_int|0
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
op_amp
id|__break_user_context.f.fner
(braket
l_int|1
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set the values of the CPU registers */
r_case
l_char|&squot;G&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* deal with GR0, GR1-GR27, GR28-GR31, GR32-GR63 */
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|1
suffix:semicolon
id|loop
op_le
l_int|27
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
id|loop
)paren
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|__frame
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|temp
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;gr29
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;gr30
comma
l_int|4
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;gr31
comma
l_int|4
)paren
suffix:semicolon
macro_line|#else
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|loop
op_assign
l_int|32
suffix:semicolon
id|loop
op_le
l_int|63
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_int
r_int
op_star
)paren
id|__debug_frame
op_plus
id|REG_GR
c_func
(paren
id|loop
)paren
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* deal with FR0-FR63 */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|63
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|__break_user_context
op_plus
id|__FPMEDIA_FR
c_func
(paren
id|loop
)paren
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* deal with special registers */
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;pc
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;psr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;ccr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;cccr
comma
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|132
suffix:semicolon
id|loop
op_le
l_int|140
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,scr0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|temp
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,scr1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|temp
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,scr2&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|temp
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|temp
comma
l_int|4
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movgs %0,scr3&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|temp
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;lr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;lcr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;iacc0
comma
l_int|8
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.fsr
(braket
l_int|0
)braket
comma
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|7
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.acc
(braket
id|loop
)braket
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.accg
comma
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
op_le
l_int|1
suffix:semicolon
id|loop
op_increment
)paren
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.msr
(braket
id|loop
)braket
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;gner0
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__debug_frame-&gt;gner1
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.fner
(braket
l_int|0
)braket
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
op_amp
id|__break_user_context.f.fner
(braket
l_int|1
)braket
comma
l_int|4
)paren
suffix:semicolon
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
r_case
l_char|&squot;m&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|output_buffer
comma
id|length
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|gdbstub_strcpy
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
r_case
l_char|&squot;M&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
)paren
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
id|flush_cache
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* PNN,=RRRRRRRR: Write value R to reg N return OK */
r_case
l_char|&squot;P&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_or
op_star
id|ptr
op_increment
op_ne
l_char|&squot;=&squot;
op_logical_or
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|temp
)paren
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|temp2
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|addr
)paren
(brace
r_case
id|GDB_REG_GR
c_func
(paren
l_int|0
)paren
suffix:colon
r_break
suffix:semicolon
r_case
id|GDB_REG_GR
c_func
(paren
l_int|1
)paren
dot
dot
dot
id|GDB_REG_GR
c_func
(paren
l_int|63
)paren
suffix:colon
id|__break_user_context.i.gr
(braket
id|addr
op_minus
id|GDB_REG_GR
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_FR
c_func
(paren
l_int|0
)paren
dot
dot
dot
id|GDB_REG_FR
c_func
(paren
l_int|63
)paren
suffix:colon
id|__break_user_context.f.fr
(braket
id|addr
op_minus
id|GDB_REG_FR
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_PC
suffix:colon
id|__break_user_context.i.pc
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_PSR
suffix:colon
id|__break_user_context.i.psr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_CCR
suffix:colon
id|__break_user_context.i.ccr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_CCCR
suffix:colon
id|__break_user_context.i.cccr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_BRR
suffix:colon
id|__debug_regs-&gt;brr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_LR
suffix:colon
id|__break_user_context.i.lr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_LCR
suffix:colon
id|__break_user_context.i.lcr
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_FSR0
suffix:colon
id|__break_user_context.f.fsr
(braket
l_int|0
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_ACC
c_func
(paren
l_int|0
)paren
dot
dot
dot
id|GDB_REG_ACC
c_func
(paren
l_int|7
)paren
suffix:colon
id|__break_user_context.f.acc
(braket
id|addr
op_minus
id|GDB_REG_ACC
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_ACCG
c_func
(paren
l_int|0
)paren
suffix:colon
op_star
(paren
r_uint32
op_star
)paren
op_amp
id|__break_user_context.f.accg
(braket
l_int|0
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_ACCG
c_func
(paren
l_int|4
)paren
suffix:colon
op_star
(paren
r_uint32
op_star
)paren
op_amp
id|__break_user_context.f.accg
(braket
l_int|4
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_MSR
c_func
(paren
l_int|0
)paren
dot
dot
dot
id|GDB_REG_MSR
c_func
(paren
l_int|1
)paren
suffix:colon
id|__break_user_context.f.msr
(braket
id|addr
op_minus
id|GDB_REG_MSR
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_GNER
c_func
(paren
l_int|0
)paren
dot
dot
dot
id|GDB_REG_GNER
c_func
(paren
l_int|1
)paren
suffix:colon
id|__break_user_context.i.gner
(braket
id|addr
op_minus
id|GDB_REG_GNER
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_REG_FNER
c_func
(paren
l_int|0
)paren
dot
dot
dot
id|GDB_REG_FNER
c_func
(paren
l_int|1
)paren
suffix:colon
id|__break_user_context.f.fner
(braket
id|addr
op_minus
id|GDB_REG_FNER
c_func
(paren
l_int|0
)paren
)braket
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|temp2
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp2
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* cAA..AA    Continue at address AA..AA(optional) */
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* try to read optional parameter, pc unchanged if no parm */
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|__debug_frame-&gt;pc
op_assign
id|addr
suffix:semicolon
r_goto
id|done
suffix:semicolon
multiline_comment|/* kill the program */
r_case
l_char|&squot;k&squot;
suffix:colon
r_goto
id|done
suffix:semicolon
multiline_comment|/* just continue */
multiline_comment|/* reset the whole machine (FIXME: system dependent) */
r_case
l_char|&squot;r&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* step to next instruction */
r_case
l_char|&squot;s&squot;
suffix:colon
id|__debug_regs-&gt;dcr
op_or_assign
id|DCR_SE
suffix:semicolon
r_goto
id|done
suffix:semicolon
multiline_comment|/* set baud rate (bBB) */
r_case
l_char|&squot;b&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|temp
)paren
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;B01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
)paren
(brace
multiline_comment|/* ack before changing speed */
id|gdbstub_send_packet
c_func
(paren
l_string|&quot;OK&quot;
)paren
suffix:semicolon
id|gdbstub_set_baud
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* set breakpoint */
r_case
l_char|&squot;Z&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|temp
)paren
op_logical_or
op_star
id|ptr
op_increment
op_ne
l_char|&squot;,&squot;
op_logical_or
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_or
op_star
id|ptr
op_increment
op_ne
l_char|&squot;,&squot;
op_logical_or
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
op_ge
l_int|5
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gdbstub_set_breakpoint
c_func
(paren
id|temp
comma
id|addr
comma
id|length
)paren
OL
l_int|0
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
op_eq
l_int|0
)paren
id|flush_cache
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* soft bkpt by modified memory */
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* clear breakpoint */
r_case
l_char|&squot;z&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|temp
)paren
op_logical_or
op_star
id|ptr
op_increment
op_ne
l_char|&squot;,&squot;
op_logical_or
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_or
op_star
id|ptr
op_increment
op_ne
l_char|&squot;,&squot;
op_logical_or
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
op_ge
l_int|5
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gdbstub_clear_breakpoint
c_func
(paren
id|temp
comma
id|addr
comma
id|length
)paren
OL
l_int|0
)paren
(brace
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
op_eq
l_int|0
)paren
id|flush_cache
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* soft bkpt by modified memory */
id|gdbstub_strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Unsupported Cmd &squot;%s&squot;&bslash;n&quot;
comma
id|input_buffer
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* reply to the request */
id|LEDS
c_func
(paren
l_int|0x5009
)paren
suffix:semicolon
id|gdbstub_send_packet
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|restore_user_regs
c_func
(paren
op_amp
id|__break_user_context
)paren
suffix:semicolon
singleline_comment|//gdbstub_dump_debugregs();
singleline_comment|//gdbstub_printk(&quot;&lt;-- gdbstub() %08x&bslash;n&quot;, __debug_frame-&gt;pc);
multiline_comment|/* need to flush the instruction cache before resuming, as we may have&n;&t; * deposited a breakpoint, and the icache probably has no way of&n;&t; * knowing that a data ref to some location may have changed something&n;&t; * that is in the instruction cache.  NB: We flush both caches, just to&n;&t; * be sure...&n;&t; */
multiline_comment|/* note: flushing the icache will clobber EAR0 on the FR451 */
r_if
c_cond
(paren
id|flush_cache
)paren
id|gdbstub_purge_cache
c_func
(paren
)paren
suffix:semicolon
id|LEDS
c_func
(paren
l_int|0x5666
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * initialise the GDB stub&n; */
DECL|function|gdbstub_init
r_void
id|__init
id|gdbstub_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_GDBSTUB_IMMEDIATE
r_int
r_char
id|ch
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#endif
id|gdbstub_printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|gdbstub_banner
)paren
suffix:semicolon
id|gdbstub_printk
c_func
(paren
l_string|&quot;DCR: %x&bslash;n&quot;
comma
id|__debug_regs-&gt;dcr
)paren
suffix:semicolon
id|gdbstub_io_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* try to talk to GDB (or anyone insane enough to want to type GDB protocol by hand) */
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx ACK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* &squot;hello world&squot; */
macro_line|#ifdef CONFIG_GDBSTUB_IMMEDIATE
id|gdbstub_printk
c_func
(paren
l_string|&quot;GDB Stub waiting for packet&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In case GDB is started before us, ack any packets&n;&t; * (presumably &quot;$?#xx&quot;) sitting there.&n;&t; */
r_do
(brace
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
r_do
(brace
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;#&squot;
)paren
suffix:semicolon
r_do
(brace
id|ret
op_assign
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* eat first csum byte */
r_do
(brace
id|ret
op_assign
id|gdbstub_rx_char
c_func
(paren
op_amp
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* eat second csum byte */
id|gdbstub_proto
c_func
(paren
l_string|&quot;### GDB Tx NAK&bslash;n&quot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* nak it */
macro_line|#else
id|gdbstub_printk
c_func
(paren
l_string|&quot;GDB Stub set&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/* send banner */
id|ptr
op_assign
id|output_buffer
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;O&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
id|gdbstub_banner
comma
id|ptr
comma
r_sizeof
(paren
id|gdbstub_banner
)paren
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|gdbstub_send_packet
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_GDBSTUB_CONSOLE) &amp;&amp; defined(CONFIG_GDBSTUB_IMMEDIATE)
id|register_console
c_func
(paren
op_amp
id|gdbstub_console
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* end gdbstub_init() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * register the console at a more appropriate time&n; */
macro_line|#if defined (CONFIG_GDBSTUB_CONSOLE) &amp;&amp; !defined(CONFIG_GDBSTUB_IMMEDIATE)
DECL|function|gdbstub_postinit
r_static
r_int
id|__init
id|gdbstub_postinit
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;registering console&bslash;n&quot;
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|gdbstub_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_postinit() */
DECL|variable|gdbstub_postinit
id|__initcall
c_func
(paren
id|gdbstub_postinit
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * send an exit message to GDB&n; */
DECL|function|gdbstub_exit
r_void
id|gdbstub_exit
c_func
(paren
r_int
id|status
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
id|sprintf
c_func
(paren
id|output_buffer
comma
l_string|&quot;W%02x&quot;
comma
id|status
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|output_buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|gdbstub_tx_char
c_func
(paren
id|ch
)paren
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|gdbstub_tx_char
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
multiline_comment|/* make sure the output is flushed, or else RedBoot might clobber it */
id|gdbstub_tx_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
id|gdbstub_tx_flush
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end gdbstub_exit() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * GDB wants to call malloc() and free() to allocate memory for calling kernel&n; * functions directly from its command line&n; */
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
suffix:semicolon
DECL|function|malloc
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|p
)paren
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
suffix:semicolon
DECL|function|free
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|p
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_static
r_uint32
id|___get_HSR0
c_func
(paren
r_void
)paren
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
suffix:semicolon
DECL|function|___get_HSR0
r_static
r_uint32
id|___get_HSR0
c_func
(paren
r_void
)paren
(brace
r_return
id|__get_HSR
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_uint32
id|___set_HSR0
c_func
(paren
r_uint32
id|x
)paren
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
suffix:semicolon
DECL|function|___set_HSR0
r_static
r_uint32
id|___set_HSR0
c_func
(paren
r_uint32
id|x
)paren
(brace
id|__set_HSR
c_func
(paren
l_int|0
comma
id|x
)paren
suffix:semicolon
r_return
id|__get_HSR
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
