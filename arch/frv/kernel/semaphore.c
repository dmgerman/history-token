multiline_comment|/* semaphore.c: FR-V semaphores&n; *&n; * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; * - Derived from lib/rwsem-spinlock.c&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
DECL|struct|sem_waiter
r_struct
id|sem_waiter
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if SEM_DEBUG
DECL|function|semtrace
r_void
id|semtrace
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;[%d] %s({%d,%d})&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|str
comma
id|sem-&gt;counter
comma
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|semtrace
mdefine_line|#define semtrace(SEM,STR) do { } while(0)
macro_line|#endif
multiline_comment|/*&n; * wait for a token to be granted from a semaphore&n; * - entered with lock held and interrupts disabled&n; */
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|sem_waiter
id|waiter
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down&quot;
)paren
suffix:semicolon
multiline_comment|/* set up my own style of waitqueue */
id|waiter.task
op_assign
id|tsk
suffix:semicolon
id|get_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|waiter.list
comma
op_amp
id|sem-&gt;wait_list
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t need to touch the semaphore struct anymore */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sem-&gt;wait_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* wait to be given the semaphore */
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|waiter.list
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down&quot;
)paren
suffix:semicolon
)brace
DECL|variable|__down
id|EXPORT_SYMBOL
c_func
(paren
id|__down
)paren
suffix:semicolon
multiline_comment|/*&n; * interruptibly wait for a token to be granted from a semaphore&n; * - entered with lock held and interrupts disabled&n; */
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|sem_waiter
id|waiter
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down_interruptible&quot;
)paren
suffix:semicolon
multiline_comment|/* set up my own style of waitqueue */
id|waiter.task
op_assign
id|tsk
suffix:semicolon
id|get_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|waiter.list
comma
op_amp
id|sem-&gt;wait_list
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t need to touch the semaphore struct anymore */
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sem-&gt;wait_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* wait to be given the semaphore */
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|waiter.list
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
)paren
r_goto
id|interrupted
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down_interruptible&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|interrupted
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sem-&gt;wait_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|waiter.list
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|waiter.list
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sem-&gt;wait_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINTR
)paren
id|put_task_struct
c_func
(paren
id|current
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|__down_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|__down_interruptible
)paren
suffix:semicolon
multiline_comment|/*&n; * release a single token back to a semaphore&n; * - entered with lock held and interrupts disabled&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_struct
id|sem_waiter
op_star
id|waiter
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __up&quot;
)paren
suffix:semicolon
multiline_comment|/* grant the token to the process at the front of the queue */
id|waiter
op_assign
id|list_entry
c_func
(paren
id|sem-&gt;wait_list.next
comma
r_struct
id|sem_waiter
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* We must be careful not to touch &squot;waiter&squot; after we set -&gt;task = NULL.&n;&t; * It is an allocated on the waiter&squot;s stack and may become invalid at&n;&t; * any time after that point (due to a wakeup from another source).&n;&t; */
id|list_del_init
c_func
(paren
op_amp
id|waiter-&gt;list
)paren
suffix:semicolon
id|tsk
op_assign
id|waiter-&gt;task
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|waiter-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_process
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|put_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|semtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __up&quot;
)paren
suffix:semicolon
)brace
DECL|variable|__up
id|EXPORT_SYMBOL
c_func
(paren
id|__up
)paren
suffix:semicolon
eof
