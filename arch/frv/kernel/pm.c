multiline_comment|/*&n; * FR-V Power Management Routines&n; *&n; * Copyright (c) 2004 Red Hat, Inc.&n; *&n; * Based on SA1100 version:&n; * Copyright (c) 2001 Cliff Brake &lt;cbrake@accelent.com&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mb86943a.h&gt;
macro_line|#include &quot;local.h&quot;
DECL|variable|pm_power_off
r_void
(paren
op_star
id|pm_power_off
)paren
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|frv_change_cmode
c_func
(paren
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Debug macros&n; */
DECL|macro|DEBUG
mdefine_line|#define DEBUG
DECL|function|pm_do_suspend
r_int
id|pm_do_suspend
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|__set_LEDS
c_func
(paren
l_int|0xb1
)paren
suffix:semicolon
multiline_comment|/* go zzz */
id|frv_cpu_suspend
c_func
(paren
id|pdm_suspend_mode
)paren
suffix:semicolon
id|__set_LEDS
c_func
(paren
l_int|0xb2
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__irq_mask
r_static
r_int
r_int
id|__irq_mask
suffix:semicolon
multiline_comment|/*&n; * Setup interrupt masks, etc to enable wakeup by power switch&n; */
DECL|function|__default_power_switch_setup
r_static
r_void
id|__default_power_switch_setup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* default is to mask all interrupt sources. */
id|__irq_mask
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xfeff9820
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xfeff9820
op_assign
l_int|0xfffe0000
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup interrupt masks, etc after wakeup by power switch&n; */
DECL|function|__default_power_switch_cleanup
r_static
r_void
id|__default_power_switch_cleanup
c_func
(paren
r_void
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xfeff9820
op_assign
id|__irq_mask
suffix:semicolon
)brace
multiline_comment|/*&n; * Return non-zero if wakeup irq was caused by power switch&n; */
DECL|function|__default_power_switch_check
r_static
r_int
id|__default_power_switch_check
c_func
(paren
r_void
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|__power_switch_wake_setup
r_void
(paren
op_star
id|__power_switch_wake_setup
)paren
(paren
r_void
)paren
op_assign
id|__default_power_switch_setup
suffix:semicolon
DECL|variable|__power_switch_wake_check
r_int
(paren
op_star
id|__power_switch_wake_check
)paren
(paren
r_void
)paren
op_assign
id|__default_power_switch_check
suffix:semicolon
DECL|variable|__power_switch_wake_cleanup
r_void
(paren
op_star
id|__power_switch_wake_cleanup
)paren
(paren
r_void
)paren
op_assign
id|__default_power_switch_cleanup
suffix:semicolon
DECL|function|pm_do_bus_sleep
r_int
id|pm_do_bus_sleep
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Here is where we need some platform-dependent setup&n;&t; * of the interrupt state so that appropriate wakeup&n;&t; * sources are allowed and all others are masked.&n;&t; */
id|__power_switch_wake_setup
c_func
(paren
)paren
suffix:semicolon
id|__set_LEDS
c_func
(paren
l_int|0xa1
)paren
suffix:semicolon
multiline_comment|/* go zzz&n;&t; *&n;&t; * This is in a loop in case power switch shares an irq with other&n;&t; * devices. The wake_check() tells us if we need to finish waking&n;&t; * or go back to sleep.&n;&t; */
r_do
(brace
id|frv_cpu_suspend
c_func
(paren
id|HSR0_PDM_BUS_SLEEP
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|__power_switch_wake_check
op_logical_and
op_logical_neg
id|__power_switch_wake_check
c_func
(paren
)paren
)paren
suffix:semicolon
id|__set_LEDS
c_func
(paren
l_int|0xa2
)paren
suffix:semicolon
multiline_comment|/*&n;         * Here is where we need some platform-dependent restore&n;&t; * of the interrupt state prior to being called.&n;&t; */
id|__power_switch_wake_cleanup
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sleep_phys_sp
r_int
r_int
id|sleep_phys_sp
c_func
(paren
r_void
op_star
id|sp
)paren
(brace
r_return
id|virt_to_phys
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYSCTL
multiline_comment|/*&n; * Use a temporary sysctl number. Horrid, but will be cleaned up in 2.6&n; * when all the PM interfaces exist nicely.&n; */
DECL|macro|CTL_PM
mdefine_line|#define CTL_PM 9899
DECL|macro|CTL_PM_SUSPEND
mdefine_line|#define CTL_PM_SUSPEND 1
DECL|macro|CTL_PM_CMODE
mdefine_line|#define CTL_PM_CMODE 2
DECL|macro|CTL_PM_P0
mdefine_line|#define CTL_PM_P0 4
DECL|macro|CTL_PM_CM
mdefine_line|#define CTL_PM_CM 5
DECL|function|user_atoi
r_static
r_int
id|user_atoi
c_func
(paren
r_char
op_star
id|ubuf
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|15
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|ubuf
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
id|INT_MAX
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Send us to sleep.&n; */
DECL|function|sysctl_pm_do_suspend
r_static
r_int
id|sysctl_pm_do_suspend
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|fpos
)paren
(brace
r_int
id|retval
comma
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_star
id|lenp
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|mode
op_assign
id|user_atoi
c_func
(paren
id|buffer
comma
op_star
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_ne
l_int|1
)paren
op_logical_and
(paren
id|mode
op_ne
l_int|5
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
l_int|5
)paren
id|retval
op_assign
id|pm_do_bus_sleep
c_func
(paren
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|pm_do_suspend
c_func
(paren
)paren
suffix:semicolon
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|try_set_cmode
r_static
r_int
id|try_set_cmode
c_func
(paren
r_int
id|new_cmode
)paren
(brace
r_if
c_cond
(paren
id|new_cmode
OG
l_int|15
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|clock_cmodes_permitted
op_amp
(paren
l_int|1
op_lshift
id|new_cmode
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* tell all the drivers we&squot;re suspending */
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* now change cmode */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|frv_dma_pause_all
c_func
(paren
)paren
suffix:semicolon
id|frv_change_cmode
c_func
(paren
id|new_cmode
)paren
suffix:semicolon
id|determine_clocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|time_divisor_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|determine_clocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|frv_dma_resume_all
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* tell all the drivers we&squot;re resuming */
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmode_procctl
r_static
r_int
id|cmode_procctl
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|fpos
)paren
(brace
r_int
id|new_cmode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
r_return
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
comma
id|fpos
)paren
suffix:semicolon
id|new_cmode
op_assign
id|user_atoi
c_func
(paren
id|buffer
comma
op_star
id|lenp
)paren
suffix:semicolon
r_return
id|try_set_cmode
c_func
(paren
id|new_cmode
)paren
ques
c_cond
suffix:colon
op_star
id|lenp
suffix:semicolon
)brace
DECL|function|cmode_sysctl
r_static
r_int
id|cmode_sysctl
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
op_star
id|name
comma
r_int
id|nlen
comma
r_void
op_star
id|oldval
comma
r_int
op_star
id|oldlenp
comma
r_void
op_star
id|newval
comma
r_int
id|newlen
comma
r_void
op_star
op_star
id|context
)paren
(brace
r_if
c_cond
(paren
id|oldval
op_logical_and
id|oldlenp
)paren
(brace
r_int
id|oldlen
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|oldlen
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|oldlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|clock_cmode_current
comma
(paren
r_int
r_int
op_star
)paren
id|oldval
)paren
op_logical_or
id|put_user
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newval
op_logical_and
id|newlen
)paren
(brace
r_int
id|new_cmode
suffix:semicolon
r_if
c_cond
(paren
id|newlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|new_cmode
comma
(paren
r_int
op_star
)paren
id|newval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|try_set_cmode
c_func
(paren
id|new_cmode
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|try_set_p0
r_static
r_int
id|try_set_p0
c_func
(paren
r_int
id|new_p0
)paren
(brace
r_int
r_int
id|flags
comma
id|clkc
suffix:semicolon
r_if
c_cond
(paren
id|new_p0
template_param
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__set_PSR
c_func
(paren
id|flags
op_amp
op_complement
id|PSR_ET
)paren
suffix:semicolon
id|frv_dma_pause_all
c_func
(paren
)paren
suffix:semicolon
id|clkc
op_assign
id|__get_CLKC
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_p0
)paren
id|clkc
op_or_assign
id|CLKC_P0
suffix:semicolon
r_else
id|clkc
op_and_assign
op_complement
id|CLKC_P0
suffix:semicolon
id|__set_CLKC
c_func
(paren
id|clkc
)paren
suffix:semicolon
id|determine_clocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|time_divisor_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|determine_clocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|frv_dma_resume_all
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_set_cm
r_static
r_int
id|try_set_cm
c_func
(paren
r_int
id|new_cm
)paren
(brace
r_int
r_int
id|flags
comma
id|clkc
suffix:semicolon
r_if
c_cond
(paren
id|new_cm
template_param
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__set_PSR
c_func
(paren
id|flags
op_amp
op_complement
id|PSR_ET
)paren
suffix:semicolon
id|frv_dma_pause_all
c_func
(paren
)paren
suffix:semicolon
id|clkc
op_assign
id|__get_CLKC
c_func
(paren
)paren
suffix:semicolon
id|clkc
op_and_assign
op_complement
id|CLKC_CM
suffix:semicolon
id|clkc
op_or_assign
id|new_cm
suffix:semicolon
id|__set_CLKC
c_func
(paren
id|clkc
)paren
suffix:semicolon
id|determine_clocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|time_divisor_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 1 
singleline_comment|//def DEBUG
id|determine_clocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|frv_dma_resume_all
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|p0_procctl
r_static
r_int
id|p0_procctl
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|fpos
)paren
(brace
r_int
id|new_p0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
r_return
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
comma
id|fpos
)paren
suffix:semicolon
id|new_p0
op_assign
id|user_atoi
c_func
(paren
id|buffer
comma
op_star
id|lenp
)paren
suffix:semicolon
r_return
id|try_set_p0
c_func
(paren
id|new_p0
)paren
ques
c_cond
suffix:colon
op_star
id|lenp
suffix:semicolon
)brace
DECL|function|p0_sysctl
r_static
r_int
id|p0_sysctl
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
op_star
id|name
comma
r_int
id|nlen
comma
r_void
op_star
id|oldval
comma
r_int
op_star
id|oldlenp
comma
r_void
op_star
id|newval
comma
r_int
id|newlen
comma
r_void
op_star
op_star
id|context
)paren
(brace
r_if
c_cond
(paren
id|oldval
op_logical_and
id|oldlenp
)paren
(brace
r_int
id|oldlen
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|oldlen
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|oldlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|clock_p0_current
comma
(paren
r_int
r_int
op_star
)paren
id|oldval
)paren
op_logical_or
id|put_user
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newval
op_logical_and
id|newlen
)paren
(brace
r_int
id|new_p0
suffix:semicolon
r_if
c_cond
(paren
id|newlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|new_p0
comma
(paren
r_int
op_star
)paren
id|newval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|try_set_p0
c_func
(paren
id|new_p0
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cm_procctl
r_static
r_int
id|cm_procctl
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|fpos
)paren
(brace
r_int
id|new_cm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
r_return
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
comma
id|fpos
)paren
suffix:semicolon
id|new_cm
op_assign
id|user_atoi
c_func
(paren
id|buffer
comma
op_star
id|lenp
)paren
suffix:semicolon
r_return
id|try_set_cm
c_func
(paren
id|new_cm
)paren
ques
c_cond
suffix:colon
op_star
id|lenp
suffix:semicolon
)brace
DECL|function|cm_sysctl
r_static
r_int
id|cm_sysctl
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
op_star
id|name
comma
r_int
id|nlen
comma
r_void
op_star
id|oldval
comma
r_int
op_star
id|oldlenp
comma
r_void
op_star
id|newval
comma
r_int
id|newlen
comma
r_void
op_star
op_star
id|context
)paren
(brace
r_if
c_cond
(paren
id|oldval
op_logical_and
id|oldlenp
)paren
(brace
r_int
id|oldlen
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|oldlen
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|oldlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|clock_cm_current
comma
(paren
r_int
r_int
op_star
)paren
id|oldval
)paren
op_logical_or
id|put_user
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newval
op_logical_and
id|newlen
)paren
(brace
r_int
id|new_cm
suffix:semicolon
r_if
c_cond
(paren
id|newlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|new_cm
comma
(paren
r_int
op_star
)paren
id|newval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|try_set_cm
c_func
(paren
id|new_cm
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|pm_table
r_static
r_struct
id|ctl_table
id|pm_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_PM_SUSPEND
comma
l_string|&quot;suspend&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0200
comma
l_int|NULL
comma
op_amp
id|sysctl_pm_do_suspend
)brace
comma
(brace
id|CTL_PM_CMODE
comma
l_string|&quot;cmode&quot;
comma
op_amp
id|clock_cmode_current
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cmode_procctl
comma
op_amp
id|cmode_sysctl
comma
l_int|NULL
)brace
comma
(brace
id|CTL_PM_P0
comma
l_string|&quot;p0&quot;
comma
op_amp
id|clock_p0_current
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|p0_procctl
comma
op_amp
id|p0_sysctl
comma
l_int|NULL
)brace
comma
(brace
id|CTL_PM_CM
comma
l_string|&quot;cm&quot;
comma
op_amp
id|clock_cm_current
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cm_procctl
comma
op_amp
id|cm_sysctl
comma
l_int|NULL
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pm_dir_table
r_static
r_struct
id|ctl_table
id|pm_dir_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_PM
comma
l_string|&quot;pm&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|pm_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize power interface&n; */
DECL|function|pm_init
r_static
r_int
id|__init
id|pm_init
c_func
(paren
r_void
)paren
(brace
id|register_sysctl_table
c_func
(paren
id|pm_dir_table
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pm_init
id|__initcall
c_func
(paren
id|pm_init
)paren
suffix:semicolon
macro_line|#endif
eof
