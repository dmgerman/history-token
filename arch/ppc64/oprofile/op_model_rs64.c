multiline_comment|/*&n; * Copyright (C) 2004 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/oprofile.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/cputable.h&gt;
DECL|macro|dbg
mdefine_line|#define dbg(args...)
macro_line|#include &quot;op_impl.h&quot;
DECL|function|ctrl_write
r_static
r_void
id|ctrl_write
c_func
(paren
r_int
r_int
id|i
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|shift
op_assign
l_int|0
comma
id|mask
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ctrl_write %d %x&bslash;n&quot;
comma
id|i
comma
id|val
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
l_int|0
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
suffix:semicolon
id|shift
op_assign
l_int|6
suffix:semicolon
id|mask
op_assign
l_int|0x7F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
suffix:semicolon
id|shift
op_assign
l_int|0
suffix:semicolon
id|mask
op_assign
l_int|0x3F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|4
suffix:semicolon
id|mask
op_assign
l_int|0x1F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|9
suffix:semicolon
id|mask
op_assign
l_int|0x1F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|14
suffix:semicolon
id|mask
op_assign
l_int|0x1F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|19
suffix:semicolon
id|mask
op_assign
l_int|0x1F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|24
suffix:semicolon
id|mask
op_assign
l_int|0x1F
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|tmp
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
suffix:semicolon
id|shift
op_assign
l_int|31
op_minus
l_int|28
suffix:semicolon
id|mask
op_assign
l_int|0xF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp
op_amp
op_complement
(paren
id|mask
op_lshift
id|shift
)paren
suffix:semicolon
id|tmp
op_or_assign
id|val
op_lshift
id|shift
suffix:semicolon
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mtspr
c_func
(paren
id|SPRN_MMCR1
comma
id|tmp
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;ctrl_write mmcr0 %lx mmcr1 %lx&bslash;n&quot;
comma
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
comma
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
)paren
suffix:semicolon
)brace
DECL|variable|reset_value
r_static
r_int
r_int
id|reset_value
(braket
id|OP_MAX_COUNTER
)braket
suffix:semicolon
DECL|variable|num_counters
r_static
r_int
id|num_counters
suffix:semicolon
DECL|function|rs64_reg_setup
r_static
r_void
id|rs64_reg_setup
c_func
(paren
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_struct
id|op_system_config
op_star
id|sys
comma
r_int
id|num_ctrs
)paren
(brace
r_int
id|i
suffix:semicolon
id|num_counters
op_assign
id|num_ctrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_counters
suffix:semicolon
op_increment
id|i
)paren
id|reset_value
(braket
id|i
)braket
op_assign
l_int|0x80000000UL
op_minus
id|ctr
(braket
id|i
)braket
dot
id|count
suffix:semicolon
multiline_comment|/* XXX setup user and kernel profiling */
)brace
DECL|function|rs64_cpu_setup
r_static
r_void
id|rs64_cpu_setup
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
r_int
id|mmcr0
suffix:semicolon
multiline_comment|/* reset MMCR0 and set the freeze bit */
id|mmcr0
op_assign
id|MMCR0_FC
suffix:semicolon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|mmcr0
)paren
suffix:semicolon
multiline_comment|/* reset MMCR1, MMCRA */
id|mtspr
c_func
(paren
id|SPRN_MMCR1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_MMCRA
)paren
id|mtspr
c_func
(paren
id|SPRN_MMCRA
comma
l_int|0
)paren
suffix:semicolon
id|mmcr0
op_or_assign
id|MMCR0_FCM1
op_or
id|MMCR0_PMXE
op_or
id|MMCR0_FCECE
suffix:semicolon
multiline_comment|/* Only applies to POWER3, but should be safe on RS64 */
id|mmcr0
op_or_assign
id|MMCR0_PMC1INTCONTROL
op_or
id|MMCR0_PMCNINTCONTROL
suffix:semicolon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|mmcr0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;setup on cpu %d, mmcr0 %lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;setup on cpu %d, mmcr1 %lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|mfspr
c_func
(paren
id|SPRN_MMCR1
)paren
)paren
suffix:semicolon
)brace
DECL|function|rs64_start
r_static
r_void
id|rs64_start
c_func
(paren
r_struct
id|op_counter_config
op_star
id|ctr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|mmcr0
suffix:semicolon
multiline_comment|/* set the PMM bit (see comment below) */
id|mtmsrd
c_func
(paren
id|mfmsr
c_func
(paren
)paren
op_or
id|MSR_PMM
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_counters
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|ctr
(braket
id|i
)braket
dot
id|enabled
)paren
(brace
id|ctr_write
c_func
(paren
id|i
comma
id|reset_value
(braket
id|i
)braket
)paren
suffix:semicolon
id|ctrl_write
c_func
(paren
id|i
comma
id|ctr
(braket
id|i
)braket
dot
id|event
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctr_write
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|mmcr0
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now clear the freeze bit, counting will not start until we&n;&t; * rfid from this excetion, because only at that point will&n;&t; * the PMM bit be cleared&n;&t; */
id|mmcr0
op_and_assign
op_complement
id|MMCR0_FC
suffix:semicolon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|mmcr0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;start on cpu %d, mmcr0 %x&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|mmcr0
)paren
suffix:semicolon
)brace
DECL|function|rs64_stop
r_static
r_void
id|rs64_stop
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mmcr0
suffix:semicolon
multiline_comment|/* freeze counters */
id|mmcr0
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
suffix:semicolon
id|mmcr0
op_or_assign
id|MMCR0_FC
suffix:semicolon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|mmcr0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;stop on cpu %d, mmcr0 %x&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|mmcr0
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rs64_handle_interrupt
r_static
r_void
id|rs64_handle_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|op_counter_config
op_star
id|ctr
)paren
(brace
r_int
r_int
id|mmcr0
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|pc
op_assign
id|mfspr
c_func
(paren
id|SPRN_SIAR
)paren
suffix:semicolon
r_int
id|is_kernel
op_assign
(paren
id|pc
op_ge
id|KERNELBASE
)paren
suffix:semicolon
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the PMM bit (see comment below) */
id|mtmsrd
c_func
(paren
id|mfmsr
c_func
(paren
)paren
op_or
id|MSR_PMM
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_counters
suffix:semicolon
op_increment
id|i
)paren
(brace
id|val
op_assign
id|ctr_read
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ctr
(braket
id|i
)braket
dot
id|enabled
)paren
(brace
id|oprofile_add_sample
c_func
(paren
id|pc
comma
id|is_kernel
comma
id|i
comma
id|cpu
)paren
suffix:semicolon
id|ctr_write
c_func
(paren
id|i
comma
id|reset_value
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctr_write
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|mmcr0
op_assign
id|mfspr
c_func
(paren
id|SPRN_MMCR0
)paren
suffix:semicolon
multiline_comment|/* reset the perfmon trigger */
id|mmcr0
op_or_assign
id|MMCR0_PMXE
suffix:semicolon
multiline_comment|/*&n;&t; * now clear the freeze bit, counting will not start until we&n;&t; * rfid from this exception, because only at that point will&n;&t; * the PMM bit be cleared&n;&t; */
id|mmcr0
op_and_assign
op_complement
id|MMCR0_FC
suffix:semicolon
id|mtspr
c_func
(paren
id|SPRN_MMCR0
comma
id|mmcr0
)paren
suffix:semicolon
)brace
DECL|variable|op_model_rs64
r_struct
id|op_ppc64_model
id|op_model_rs64
op_assign
(brace
dot
id|reg_setup
op_assign
id|rs64_reg_setup
comma
dot
id|cpu_setup
op_assign
id|rs64_cpu_setup
comma
dot
id|start
op_assign
id|rs64_start
comma
dot
id|stop
op_assign
id|rs64_stop
comma
dot
id|handle_interrupt
op_assign
id|rs64_handle_interrupt
comma
)brace
suffix:semicolon
eof
