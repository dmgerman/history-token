multiline_comment|/*&n; * &n; *&n; * Procedures for interfacing to Open Firmware.&n; *&n; * Paul Mackerras&t;August 1996.&n; * Copyright (C) 1996 Paul Mackerras.&n; * &n; *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.&n; *    {engebret|bergner}@us.ibm.com &n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
DECL|macro|DEBUG_PROM
macro_line|#undef DEBUG_PROM
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stringify.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/abs_addr.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#ifdef CONFIG_LOGO_LINUX_CLUT224
macro_line|#include &lt;linux/linux_logo.h&gt;
r_extern
r_const
r_struct
id|linux_logo
id|logo_linux_clut224
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Properties whose value is longer than this get excluded from our&n; * copy of the device tree. This value does need to be big enough to&n; * ensure that we don&squot;t lose things like the interrupt-map property&n; * on a PCI-PCI bridge.&n; */
DECL|macro|MAX_PROPERTY_LENGTH
mdefine_line|#define MAX_PROPERTY_LENGTH&t;(1UL * 1024 * 1024)
multiline_comment|/*&n; * Eventually bump that one up&n; */
DECL|macro|DEVTREE_CHUNK_SIZE
mdefine_line|#define DEVTREE_CHUNK_SIZE&t;0x100000
multiline_comment|/*&n; * This is the size of the local memory reserve map that gets copied&n; * into the boot params passed to the kernel. That size is totally&n; * flexible as the kernel just reads the list until it encounters an&n; * entry with size 0, so it can be changed without breaking binary&n; * compatibility&n; */
DECL|macro|MEM_RESERVE_MAP_SIZE
mdefine_line|#define MEM_RESERVE_MAP_SIZE&t;8
multiline_comment|/*&n; * prom_init() is called very early on, before the kernel text&n; * and data have been mapped to KERNELBASE.  At this point the code&n; * is running at whatever address it has been loaded at, so&n; * references to extern and static variables must be relocated&n; * explicitly.  The procedure reloc_offset() returns the address&n; * we&squot;re currently running at minus the address we were linked at.&n; * (Note that strings count as static variables.)&n; *&n; * Because OF may have mapped I/O devices into the area starting at&n; * KERNELBASE, particularly on CHRP machines, we can&squot;t safely call&n; * OF once the kernel has been mapped to KERNELBASE.  Therefore all&n; * OF calls should be done within prom_init(), and prom_init()&n; * and all routines called within it must be careful to relocate&n; * references as necessary.&n; *&n; * Note that the bss is cleared *after* prom_init runs, so we have&n; * to make sure that any static or extern variables it accesses&n; * are put in the data segment.&n; */
DECL|macro|PROM_BUG
mdefine_line|#define PROM_BUG() do {&t;&t;&t;&t;&t;&t;&bslash;&n;        prom_printf(&quot;kernel BUG at %s line 0x%x!&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;    RELOC(__FILE__), __LINE__);&t;&t;&t;&bslash;&n;        __asm__ __volatile__(&quot;.long &quot; BUG_ILLEGAL_INSTR);&t;&bslash;&n;} while (0)
macro_line|#ifdef DEBUG_PROM
DECL|macro|prom_debug
mdefine_line|#define prom_debug(x...)&t;prom_printf(x)
macro_line|#else
DECL|macro|prom_debug
mdefine_line|#define prom_debug(x...)
macro_line|#endif
DECL|typedef|prom_arg_t
r_typedef
id|u32
id|prom_arg_t
suffix:semicolon
DECL|struct|prom_args
r_struct
id|prom_args
(brace
DECL|member|service
id|u32
id|service
suffix:semicolon
DECL|member|nargs
id|u32
id|nargs
suffix:semicolon
DECL|member|nret
id|u32
id|nret
suffix:semicolon
DECL|member|args
id|prom_arg_t
id|args
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|rets
id|prom_arg_t
op_star
id|rets
suffix:semicolon
multiline_comment|/* Pointer to return values in args[16]. */
)brace
suffix:semicolon
DECL|struct|prom_t
r_struct
id|prom_t
(brace
DECL|member|entry
r_int
r_int
id|entry
suffix:semicolon
DECL|member|root
id|ihandle
id|root
suffix:semicolon
DECL|member|chosen
id|ihandle
id|chosen
suffix:semicolon
DECL|member|cpu
r_int
id|cpu
suffix:semicolon
DECL|member|stdout
id|ihandle
id|stdout
suffix:semicolon
DECL|member|disp_node
id|ihandle
id|disp_node
suffix:semicolon
DECL|member|args
r_struct
id|prom_args
id|args
suffix:semicolon
DECL|member|version
r_int
r_int
id|version
suffix:semicolon
DECL|member|root_size_cells
r_int
r_int
id|root_size_cells
suffix:semicolon
DECL|member|root_addr_cells
r_int
r_int
id|root_addr_cells
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
id|u32
id|size_hi
suffix:semicolon
DECL|member|size_lo
id|u32
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|mem_map_entry
r_struct
id|mem_map_entry
(brace
DECL|member|base
id|u64
id|base
suffix:semicolon
DECL|member|size
id|u64
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|cell_t
r_typedef
id|u32
id|cell_t
suffix:semicolon
r_extern
r_void
id|__start
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
)paren
suffix:semicolon
r_extern
r_int
r_int
id|reloc_offset
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|enter_prom
c_func
(paren
r_struct
id|prom_args
op_star
id|args
comma
r_int
r_int
id|entry
)paren
suffix:semicolon
r_extern
r_void
id|copy_and_flush
c_func
(paren
r_int
r_int
id|dest
comma
r_int
r_int
id|src
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
r_extern
r_int
r_int
id|klimit
suffix:semicolon
multiline_comment|/* prom structure */
DECL|variable|prom
r_static
r_struct
id|prom_t
id|__initdata
id|prom
suffix:semicolon
DECL|macro|PROM_SCRATCH_SIZE
mdefine_line|#define PROM_SCRATCH_SIZE 256
DECL|variable|of_stdout_device
r_static
r_char
id|__initdata
id|of_stdout_device
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|prom_scratch
r_static
r_char
id|__initdata
id|prom_scratch
(braket
id|PROM_SCRATCH_SIZE
)braket
suffix:semicolon
DECL|variable|dt_header_start
r_static
r_int
r_int
id|__initdata
id|dt_header_start
suffix:semicolon
DECL|variable|dt_struct_start
DECL|variable|dt_struct_end
r_static
r_int
r_int
id|__initdata
id|dt_struct_start
comma
id|dt_struct_end
suffix:semicolon
DECL|variable|dt_string_start
DECL|variable|dt_string_end
r_static
r_int
r_int
id|__initdata
id|dt_string_start
comma
id|dt_string_end
suffix:semicolon
DECL|variable|prom_initrd_start
DECL|variable|prom_initrd_end
r_static
r_int
r_int
id|__initdata
id|prom_initrd_start
comma
id|prom_initrd_end
suffix:semicolon
DECL|variable|iommu_force_on
r_static
r_int
id|__initdata
id|iommu_force_on
suffix:semicolon
DECL|variable|ppc64_iommu_off
r_static
r_int
id|__initdata
id|ppc64_iommu_off
suffix:semicolon
DECL|variable|of_platform
r_static
r_int
id|__initdata
id|of_platform
suffix:semicolon
DECL|variable|prom_cmd_line
r_static
r_char
id|__initdata
id|prom_cmd_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|alloc_top
r_static
r_int
r_int
id|__initdata
id|alloc_top
suffix:semicolon
DECL|variable|alloc_top_high
r_static
r_int
r_int
id|__initdata
id|alloc_top_high
suffix:semicolon
DECL|variable|alloc_bottom
r_static
r_int
r_int
id|__initdata
id|alloc_bottom
suffix:semicolon
DECL|variable|rmo_top
r_static
r_int
r_int
id|__initdata
id|rmo_top
suffix:semicolon
DECL|variable|ram_top
r_static
r_int
r_int
id|__initdata
id|ram_top
suffix:semicolon
DECL|variable|mem_reserve_map
r_static
r_struct
id|mem_map_entry
id|__initdata
id|mem_reserve_map
(braket
id|MEM_RESERVE_MAP_SIZE
)braket
suffix:semicolon
DECL|variable|mem_reserve_cnt
r_static
r_int
id|__initdata
id|mem_reserve_cnt
suffix:semicolon
DECL|variable|regbuf
r_static
id|cell_t
id|__initdata
id|regbuf
(braket
l_int|1024
)braket
suffix:semicolon
DECL|macro|MAX_CPU_THREADS
mdefine_line|#define MAX_CPU_THREADS 2
multiline_comment|/* TO GO */
macro_line|#ifdef CONFIG_HMT
r_struct
(brace
DECL|member|pir
r_int
r_int
id|pir
suffix:semicolon
DECL|member|threadid
r_int
r_int
id|threadid
suffix:semicolon
DECL|variable|hmt_thread_data
)brace
id|hmt_thread_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif /* CONFIG_HMT */
multiline_comment|/*&n; * This are used in calls to call_prom.  The 4th and following&n; * arguments to call_prom should be 32-bit values.  64 bit values&n; * are truncated to 32 bits (and fortunately don&squot;t get interpreted&n; * as two arguments).&n; */
DECL|macro|ADDR
mdefine_line|#define ADDR(x)&t;&t;(u32) ((unsigned long)(x) - offset)
multiline_comment|/* This is the one and *ONLY* place where we actually call open&n; * firmware from, since we need to make sure we&squot;re running in 32b&n; * mode when we do.  We switch back to 64b mode upon return.&n; */
DECL|macro|PROM_ERROR
mdefine_line|#define PROM_ERROR&t;(-1)
DECL|function|call_prom
r_static
r_int
id|__init
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|va_list
id|list
suffix:semicolon
id|_prom-&gt;args.service
op_assign
id|ADDR
c_func
(paren
id|service
)paren
suffix:semicolon
id|_prom-&gt;args.nargs
op_assign
id|nargs
suffix:semicolon
id|_prom-&gt;args.nret
op_assign
id|nret
suffix:semicolon
id|_prom-&gt;args.rets
op_assign
(paren
id|prom_arg_t
op_star
)paren
op_amp
(paren
id|_prom-&gt;args.args
(braket
id|nargs
)braket
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
id|i
op_increment
)paren
id|_prom-&gt;args.args
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
id|prom_arg_t
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
id|i
op_increment
)paren
id|_prom-&gt;args.rets
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|enter_prom
c_func
(paren
op_amp
id|_prom-&gt;args
comma
id|_prom-&gt;entry
)paren
suffix:semicolon
r_return
(paren
id|nret
OG
l_int|0
)paren
ques
c_cond
id|_prom-&gt;args.rets
(braket
l_int|0
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|prom_claim
r_static
r_int
r_int
id|__init
id|prom_claim
c_func
(paren
r_int
r_int
id|virt
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;claim&quot;
comma
l_int|3
comma
l_int|1
comma
(paren
id|prom_arg_t
)paren
id|virt
comma
(paren
id|prom_arg_t
)paren
id|size
comma
(paren
id|prom_arg_t
)paren
id|align
)paren
suffix:semicolon
)brace
DECL|function|prom_print
r_static
r_void
id|__init
id|prom_print
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;stdout
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|msg
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
op_ne
l_int|0
op_logical_and
op_star
id|q
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_increment
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
OG
id|p
)paren
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|p
comma
id|q
op_minus
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_eq
l_int|0
)paren
r_break
suffix:semicolon
op_increment
id|q
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|ADDR
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
DECL|function|prom_print_hex
r_static
r_void
id|__init
id|prom_print_hex
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
comma
id|nibbles
op_assign
r_sizeof
(paren
id|val
)paren
op_star
l_int|2
suffix:semicolon
r_char
id|buf
(braket
r_sizeof
(paren
id|val
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nibbles
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
(paren
id|val
op_amp
l_int|0xf
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
OG
l_char|&squot;9&squot;
)paren
id|buf
(braket
id|i
)braket
op_add_assign
(paren
l_char|&squot;a&squot;
op_minus
l_char|&squot;0&squot;
op_minus
l_int|10
)paren
suffix:semicolon
id|val
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|buf
(braket
id|nibbles
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|buf
comma
id|nibbles
)paren
suffix:semicolon
)brace
DECL|function|prom_printf
r_static
r_void
id|__init
id|prom_printf
c_func
(paren
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_const
r_char
op_star
id|p
comma
op_star
id|q
comma
op_star
id|s
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|format
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|PTRRELOC
c_func
(paren
id|format
)paren
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
op_ne
l_int|0
op_logical_and
op_star
id|q
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
op_star
id|q
op_ne
l_char|&squot;%&squot;
suffix:semicolon
op_increment
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
OG
id|p
)paren
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|p
comma
id|q
op_minus
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_increment
id|q
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|ADDR
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
comma
l_int|2
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_increment
id|q
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|q
)paren
(brace
r_case
l_char|&squot;s&squot;
suffix:colon
op_increment
id|q
suffix:semicolon
id|s
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
op_increment
id|q
suffix:semicolon
id|v
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|v
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|prom_panic
r_static
r_void
id|__init
id|__attribute__
c_func
(paren
(paren
id|noreturn
)paren
)paren
id|prom_panic
c_func
(paren
r_const
r_char
op_star
id|reason
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|PTRRELOC
c_func
(paren
id|reason
)paren
)paren
suffix:semicolon
multiline_comment|/* ToDo: should put up an SRC here */
id|call_prom
c_func
(paren
l_string|&quot;exit&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
multiline_comment|/* should never get here */
suffix:semicolon
)brace
DECL|function|prom_next_node
r_static
r_int
id|__init
id|prom_next_node
c_func
(paren
id|phandle
op_star
id|nodep
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node
op_assign
op_star
id|nodep
)paren
op_ne
l_int|0
op_logical_and
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;child&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|node
op_assign
id|call_prom
c_func
(paren
l_string|&quot;parent&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|prom_getprop
r_static
r_int
id|__init
id|prom_getprop
c_func
(paren
id|phandle
id|node
comma
r_const
r_char
op_star
id|pname
comma
r_void
op_star
id|value
comma
r_int
id|valuelen
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_return
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|ADDR
c_func
(paren
id|pname
)paren
comma
(paren
id|u32
)paren
(paren
r_int
r_int
)paren
id|value
comma
(paren
id|u32
)paren
id|valuelen
)paren
suffix:semicolon
)brace
DECL|function|prom_getproplen
r_static
r_int
id|__init
id|prom_getproplen
c_func
(paren
id|phandle
id|node
comma
r_const
r_char
op_star
id|pname
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_return
id|call_prom
c_func
(paren
l_string|&quot;getproplen&quot;
comma
l_int|2
comma
l_int|1
comma
id|node
comma
id|ADDR
c_func
(paren
id|pname
)paren
)paren
suffix:semicolon
)brace
DECL|function|prom_setprop
r_static
r_int
id|__init
id|prom_setprop
c_func
(paren
id|phandle
id|node
comma
r_const
r_char
op_star
id|pname
comma
r_void
op_star
id|value
comma
r_int
id|valuelen
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_return
id|call_prom
c_func
(paren
l_string|&quot;setprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|ADDR
c_func
(paren
id|pname
)paren
comma
(paren
id|u32
)paren
(paren
r_int
r_int
)paren
id|value
comma
(paren
id|u32
)paren
id|valuelen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Early parsing of the command line passed to the kernel, used for&n; * the options that affect the iommu&n; */
DECL|function|early_cmdline_parse
r_static
r_void
id|__init
id|early_cmdline_parse
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
op_star
id|opt
comma
op_star
id|p
suffix:semicolon
r_int
id|l
op_assign
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|prom_cmd_line
(braket
l_int|0
)braket
)paren
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|RELOC
c_func
(paren
id|prom_cmd_line
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;chosen
OG
l_int|0
)paren
id|l
op_assign
id|prom_getprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;bootargs&quot;
comma
id|p
comma
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CMDLINE
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
multiline_comment|/* dbl check */
id|strlcpy
c_func
(paren
id|RELOC
c_func
(paren
id|prom_cmd_line
)paren
comma
id|RELOC
c_func
(paren
id|CONFIG_CMDLINE
)paren
comma
r_sizeof
(paren
id|prom_cmd_line
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_CMDLINE */
id|prom_printf
c_func
(paren
l_string|&quot;command line: %s&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|prom_cmd_line
)paren
)paren
suffix:semicolon
id|opt
op_assign
id|strstr
c_func
(paren
id|RELOC
c_func
(paren
id|prom_cmd_line
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;iommu=&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;iommu opt is: %s&bslash;n&quot;
comma
id|opt
)paren
suffix:semicolon
id|opt
op_add_assign
l_int|6
suffix:semicolon
r_while
c_loop
(paren
op_star
id|opt
op_logical_and
op_star
id|opt
op_eq
l_char|&squot; &squot;
)paren
id|opt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|opt
comma
id|RELOC
c_func
(paren
l_string|&quot;off&quot;
)paren
comma
l_int|3
)paren
)paren
id|RELOC
c_func
(paren
id|ppc64_iommu_off
)paren
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|opt
comma
id|RELOC
c_func
(paren
l_string|&quot;force&quot;
)paren
comma
l_int|5
)paren
)paren
id|RELOC
c_func
(paren
id|iommu_force_on
)paren
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Memory allocation strategy... our layout is normally:&n; *&n; *  at 14Mb or more we vmlinux, then a gap and initrd. In some rare cases, initrd&n; *  might end up beeing before the kernel though. We assume this won&squot;t override&n; *  the final kernel at 0, we have no provision to handle that in this version,&n; *  but it should hopefully never happen.&n; *&n; *  alloc_top is set to the top of RMO, eventually shrink down if the TCEs overlap&n; *  alloc_bottom is set to the top of kernel/initrd&n; *&n; *  from there, allocations are done that way : rtas is allocated topmost, and&n; *  the device-tree is allocated from the bottom. We try to grow the device-tree&n; *  allocation as we progress. If we can&squot;t, then we fail, we don&squot;t currently have&n; *  a facility to restart elsewhere, but that shouldn&squot;t be necessary neither&n; *&n; *  Note that calls to reserve_mem have to be done explicitely, memory allocated&n; *  with either alloc_up or alloc_down isn&squot;t automatically reserved.&n; */
multiline_comment|/*&n; * Allocates memory in the RMO upward from the kernel/initrd&n; *&n; * When align is 0, this is a special case, it means to allocate in place&n; * at the current location of alloc_bottom or fail (that is basically&n; * extending the previous allocation). Used for the device-tree flattening&n; */
DECL|function|alloc_up
r_static
r_int
r_int
id|__init
id|alloc_up
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|base
op_assign
id|_ALIGN_UP
c_func
(paren
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
comma
id|align
)paren
suffix:semicolon
r_int
r_int
id|addr
op_assign
l_int|0
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;alloc_up(%x, %x)&bslash;n&quot;
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|ram_top
)paren
op_eq
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;alloc_up() called with mem not initialized&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|align
)paren
id|base
op_assign
id|_ALIGN_UP
c_func
(paren
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
comma
id|align
)paren
suffix:semicolon
r_else
id|base
op_assign
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|base
op_plus
id|size
)paren
op_le
id|RELOC
c_func
(paren
id|alloc_top
)paren
suffix:semicolon
id|base
op_assign
id|_ALIGN_UP
c_func
(paren
id|base
op_plus
l_int|0x100000
comma
id|align
)paren
)paren
(brace
id|prom_debug
c_func
(paren
l_string|&quot;    trying: 0x%x&bslash;n&bslash;r&quot;
comma
id|base
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|prom_claim
c_func
(paren
id|base
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|addr
op_ne
id|PROM_ERROR
)paren
r_break
suffix:semicolon
id|addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|align
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
op_assign
id|addr
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot; -&gt; %x&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_bottom : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_top    : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_top_hi : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  rmo_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|rmo_top
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  ram_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|ram_top
)paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates memory downard, either from top of RMO, or if highmem&n; * is set, from the top of RAM. Note that this one doesn&squot;t handle&n; * failures. In does claim memory if highmem is not set.&n; */
DECL|function|alloc_down
r_static
r_int
r_int
id|__init
id|alloc_down
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|align
comma
r_int
id|highmem
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|base
comma
id|addr
op_assign
l_int|0
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;alloc_down(%x, %x, %s)&bslash;n&quot;
comma
id|size
comma
id|align
comma
id|highmem
ques
c_cond
id|RELOC
c_func
(paren
l_string|&quot;(high)&quot;
)paren
suffix:colon
id|RELOC
c_func
(paren
l_string|&quot;(low)&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|ram_top
)paren
op_eq
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;alloc_down() called with mem not initialized&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|highmem
)paren
(brace
multiline_comment|/* Carve out storage for the TCE table. */
id|addr
op_assign
id|_ALIGN_DOWN
c_func
(paren
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
op_minus
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_le
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* Will we bump into the RMO ? If yes, check out that we&n;&t;&t;&t; * didn&squot;t overlap existing allocations there, if we did,&n;&t;&t;&t; * we are dead, we must be the first in town !&n;&t;&t;&t; */
r_if
c_cond
(paren
id|addr
OL
id|RELOC
c_func
(paren
id|rmo_top
)paren
)paren
(brace
multiline_comment|/* Good, we are first */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_eq
id|RELOC
c_func
(paren
id|rmo_top
)paren
)paren
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_assign
id|RELOC
c_func
(paren
id|rmo_top
)paren
op_assign
id|addr
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
op_assign
id|addr
suffix:semicolon
)brace
r_goto
id|bail
suffix:semicolon
)brace
id|base
op_assign
id|_ALIGN_DOWN
c_func
(paren
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_minus
id|size
comma
id|align
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|base
OG
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
suffix:semicolon
id|base
op_assign
id|_ALIGN_DOWN
c_func
(paren
id|base
op_minus
l_int|0x100000
comma
id|align
)paren
)paren
(brace
id|prom_debug
c_func
(paren
l_string|&quot;    trying: 0x%x&bslash;n&bslash;r&quot;
comma
id|base
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|prom_claim
c_func
(paren
id|base
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|addr
op_ne
id|PROM_ERROR
)paren
r_break
suffix:semicolon
id|addr
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_assign
id|addr
suffix:semicolon
id|bail
suffix:colon
id|prom_debug
c_func
(paren
l_string|&quot; -&gt; %x&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_bottom : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_top    : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  alloc_top_hi : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  rmo_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|rmo_top
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  ram_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|ram_top
)paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a &quot;reg&quot; cell&n; */
DECL|function|prom_next_cell
r_static
r_int
r_int
id|__init
id|prom_next_cell
c_func
(paren
r_int
id|s
comma
id|cell_t
op_star
op_star
id|cellp
)paren
(brace
id|cell_t
op_star
id|p
op_assign
op_star
id|cellp
suffix:semicolon
r_int
r_int
id|r
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ignore more than 2 cells */
r_while
c_loop
(paren
id|s
OG
l_int|2
)paren
(brace
id|p
op_increment
suffix:semicolon
id|s
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|s
)paren
(brace
id|r
op_lshift_assign
l_int|32
suffix:semicolon
id|r
op_or_assign
op_star
(paren
id|p
op_increment
)paren
suffix:semicolon
id|s
op_decrement
suffix:semicolon
)brace
op_star
id|cellp
op_assign
id|p
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Very dumb function for adding to the memory reserve list, but&n; * we don&squot;t need anything smarter at this point&n; *&n; * XXX Eventually check for collisions. They should NEVER happen&n; * if problems seem to show up, it would be a good start to track&n; * them down.&n; */
DECL|function|reserve_mem
r_static
r_void
id|reserve_mem
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|top
op_assign
id|base
op_plus
id|size
suffix:semicolon
r_int
r_int
id|cnt
op_assign
id|RELOC
c_func
(paren
id|mem_reserve_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* We need to always keep one empty entry so that we&n;&t; * have our terminator with &quot;size&quot; set to 0 since we are&n;&t; * dumb and just copy this entire array to the boot params&n;&t; */
id|base
op_assign
id|_ALIGN_DOWN
c_func
(paren
id|base
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|top
op_assign
id|_ALIGN_UP
c_func
(paren
id|top
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|size
op_assign
id|top
op_minus
id|base
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
(paren
id|MEM_RESERVE_MAP_SIZE
op_minus
l_int|1
)paren
)paren
id|prom_panic
c_func
(paren
l_string|&quot;Memory reserve map exhausted !&bslash;n&quot;
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|mem_reserve_map
)paren
(braket
id|cnt
)braket
dot
id|base
op_assign
id|base
suffix:semicolon
id|RELOC
c_func
(paren
id|mem_reserve_map
)paren
(braket
id|cnt
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|RELOC
c_func
(paren
id|mem_reserve_cnt
)paren
op_assign
id|cnt
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize memory allocation mecanism, parse &quot;memory&quot; nodes and&n; * obtain that way the top of memory and RMO to setup out local allocator&n; */
DECL|function|prom_init_mem
r_static
r_void
id|__init
id|prom_init_mem
c_func
(paren
r_void
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_char
op_star
id|path
comma
id|type
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|plen
suffix:semicolon
id|cell_t
op_star
id|p
comma
op_star
id|endp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We iterate the memory nodes to find&n;&t; * 1) top of RMO (first node)&n;&t; * 2) top of memory&n;&t; */
id|prom_debug
c_func
(paren
l_string|&quot;root_addr_cells: %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|_prom-&gt;root_addr_cells
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;root_size_cells: %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|_prom-&gt;root_size_cells
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;scanning memory:&bslash;n&quot;
)paren
suffix:semicolon
id|path
op_assign
id|RELOC
c_func
(paren
id|prom_scratch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;memory&quot;
)paren
)paren
)paren
r_continue
suffix:semicolon
id|plen
op_assign
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
id|RELOC
c_func
(paren
id|regbuf
)paren
comma
r_sizeof
(paren
id|regbuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plen
OG
r_sizeof
(paren
id|regbuf
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;memory node too large for buffer !&bslash;n&quot;
)paren
suffix:semicolon
id|plen
op_assign
r_sizeof
(paren
id|regbuf
)paren
suffix:semicolon
)brace
id|p
op_assign
id|RELOC
c_func
(paren
id|regbuf
)paren
suffix:semicolon
id|endp
op_assign
id|p
op_plus
(paren
id|plen
op_div
r_sizeof
(paren
id|cell_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
id|PROM_SCRATCH_SIZE
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
id|PROM_SCRATCH_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;  node %s :&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_PROM */
r_while
c_loop
(paren
(paren
id|endp
op_minus
id|p
)paren
op_ge
(paren
id|_prom-&gt;root_addr_cells
op_plus
id|_prom-&gt;root_size_cells
)paren
)paren
(brace
r_int
r_int
id|base
comma
id|size
suffix:semicolon
id|base
op_assign
id|prom_next_cell
c_func
(paren
id|_prom-&gt;root_addr_cells
comma
op_amp
id|p
)paren
suffix:semicolon
id|size
op_assign
id|prom_next_cell
c_func
(paren
id|_prom-&gt;root_size_cells
comma
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    %x %x&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
id|RELOC
c_func
(paren
id|rmo_top
)paren
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
id|RELOC
c_func
(paren
id|ram_top
)paren
)paren
id|RELOC
c_func
(paren
id|ram_top
)paren
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup our top/bottom alloc points, that is top of RMO or top of&n;&t; * segment 0 when running non-LPAR&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|of_platform
)paren
op_eq
id|PLATFORM_PSERIES_LPAR
)paren
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_assign
id|RELOC
c_func
(paren
id|rmo_top
)paren
suffix:semicolon
r_else
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_assign
id|RELOC
c_func
(paren
id|rmo_top
)paren
op_assign
id|min
c_func
(paren
l_int|0x40000000ul
comma
id|RELOC
c_func
(paren
id|ram_top
)paren
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
op_assign
id|PAGE_ALIGN
c_func
(paren
id|RELOC
c_func
(paren
id|klimit
)paren
op_minus
id|offset
op_plus
l_int|0x4000
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
op_assign
id|RELOC
c_func
(paren
id|ram_top
)paren
suffix:semicolon
multiline_comment|/* Check if we have an initrd after the kernel, if we do move our bottom&n;&t; * point to after it&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
op_plus
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
)paren
OG
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
op_assign
id|PAGE_ALIGN
c_func
(paren
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
)paren
suffix:semicolon
)brace
id|prom_printf
c_func
(paren
l_string|&quot;memory layout at init:&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;  alloc_bottom : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;  alloc_top    : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;  alloc_top_hi : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;  rmo_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|rmo_top
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;  ram_top      : %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|ram_top
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate room for and instanciate RTAS&n; */
DECL|function|prom_instantiate_rtas
r_static
r_void
id|__init
id|prom_instantiate_rtas
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|phandle
id|prom_rtas
comma
id|rtas_node
suffix:semicolon
id|u32
id|base
comma
id|entry
op_assign
l_int|0
suffix:semicolon
id|u32
id|size
op_assign
l_int|0
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;prom_instantiate_rtas: start...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_rtas
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;prom_rtas: %x&bslash;n&quot;
comma
id|prom_rtas
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_rtas
op_eq
(paren
id|phandle
)paren
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|prom_getprop
c_func
(paren
id|prom_rtas
comma
l_string|&quot;rtas-size&quot;
comma
op_amp
id|size
comma
r_sizeof
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|base
op_assign
id|alloc_down
c_func
(paren
id|size
comma
id|PAGE_SIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;RTAS allocation failed !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_printf
c_func
(paren
l_string|&quot;instantiating rtas at 0x%x&quot;
comma
id|base
)paren
suffix:semicolon
id|rtas_node
op_assign
id|call_prom
c_func
(paren
l_string|&quot;open&quot;
comma
l_int|1
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_prom
c_func
(paren
l_string|&quot;call-method&quot;
comma
l_int|3
comma
l_int|2
comma
id|ADDR
c_func
(paren
l_string|&quot;instantiate-rtas&quot;
)paren
comma
id|rtas_node
comma
id|base
)paren
op_ne
id|PROM_ERROR
)paren
(brace
id|entry
op_assign
(paren
r_int
)paren
id|_prom-&gt;args.rets
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot; failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_printf
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
id|reserve_mem
c_func
(paren
id|base
comma
id|size
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|prom_rtas
comma
l_string|&quot;linux,rtas-base&quot;
comma
op_amp
id|base
comma
r_sizeof
(paren
id|base
)paren
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|prom_rtas
comma
l_string|&quot;linux,rtas-entry&quot;
comma
op_amp
id|entry
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;rtas base     = 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;rtas entry    = 0x%x&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;rtas size     = 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|size
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;prom_instantiate_rtas: end...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate room for and initialize TCE tables&n; */
DECL|function|prom_initialize_tce_table
r_static
r_void
id|__init
id|prom_initialize_tce_table
c_func
(paren
r_void
)paren
(brace
id|phandle
id|node
suffix:semicolon
id|ihandle
id|phb_node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|compatible
(braket
l_int|64
)braket
comma
id|type
(braket
l_int|64
)braket
comma
id|model
(braket
l_int|64
)braket
suffix:semicolon
r_char
op_star
id|path
op_assign
id|RELOC
c_func
(paren
id|prom_scratch
)paren
suffix:semicolon
id|u64
id|base
comma
id|align
suffix:semicolon
id|u32
id|minalign
comma
id|minsize
suffix:semicolon
id|u64
id|tce_entry
comma
op_star
id|tce_entryp
suffix:semicolon
id|u64
id|local_alloc_top
comma
id|local_alloc_bottom
suffix:semicolon
id|u64
id|i
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|ppc64_iommu_off
)paren
)paren
r_return
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;starting prom_initialize_tce_table&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Cache current top of allocs so we reserve a single block */
id|local_alloc_top
op_assign
id|RELOC
c_func
(paren
id|alloc_top_high
)paren
suffix:semicolon
id|local_alloc_bottom
op_assign
id|local_alloc_top
suffix:semicolon
multiline_comment|/* Search all nodes looking for PHBs. */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|compatible
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|model
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;compatible&quot;
comma
id|compatible
comma
r_sizeof
(paren
id|compatible
)paren
)paren
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;model&quot;
comma
id|model
comma
r_sizeof
(paren
id|model
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strstr
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;pci&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Keep the old logic in tack to avoid regression. */
r_if
c_cond
(paren
id|compatible
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;python&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;Speedwagon&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;Winnipeg&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|model
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;ython&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;peedwagon&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;innipeg&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;tce-table-minalign&quot;
comma
op_amp
id|minalign
comma
r_sizeof
(paren
id|minalign
)paren
)paren
op_eq
id|PROM_ERROR
)paren
id|minalign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;tce-table-minsize&quot;
comma
op_amp
id|minsize
comma
r_sizeof
(paren
id|minsize
)paren
)paren
op_eq
id|PROM_ERROR
)paren
id|minsize
op_assign
l_int|4UL
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Even though we read what OF wants, we just set the table&n;&t;&t; * size to 4 MB.  This is enough to map 2GB of PCI DMA space.&n;&t;&t; * By doing this, we avoid the pitfalls of trying to DMA to&n;&t;&t; * MMIO space and the DMA alias hole.&n;&t;&t; *&n;&t;&t; * On POWER4, firmware sets the TCE region by assuming&n;&t;&t; * each TCE table is 8MB. Using this memory for anything&n;&t;&t; * else will impact performance, so we always allocate 8MB.&n;&t;&t; * Anton&n;&t;&t; */
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_POWER4p
)paren
)paren
id|minsize
op_assign
l_int|8UL
op_lshift
l_int|20
suffix:semicolon
r_else
id|minsize
op_assign
l_int|4UL
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/* Align to the greater of the align or size */
id|align
op_assign
id|max
c_func
(paren
id|minalign
comma
id|minsize
)paren
suffix:semicolon
id|base
op_assign
id|alloc_down
c_func
(paren
id|minsize
comma
id|align
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;ERROR, cannot find space for TCE table.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|local_alloc_bottom
)paren
id|local_alloc_bottom
op_assign
id|base
suffix:semicolon
multiline_comment|/* Save away the TCE table attributes for later use. */
id|prom_setprop
c_func
(paren
id|node
comma
l_string|&quot;linux,tce-base&quot;
comma
op_amp
id|base
comma
r_sizeof
(paren
id|base
)paren
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|node
comma
l_string|&quot;linux,tce-size&quot;
comma
op_amp
id|minsize
comma
r_sizeof
(paren
id|minsize
)paren
)paren
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
r_sizeof
(paren
id|path
)paren
)paren
suffix:semicolon
multiline_comment|/* Call OF to setup the TCE hardware */
r_if
c_cond
(paren
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
id|PROM_SCRATCH_SIZE
op_minus
l_int|1
)paren
op_eq
id|PROM_ERROR
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;package-to-path failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|prom_debug
c_func
(paren
l_string|&quot;TCE table: %s&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;&bslash;tnode = 0x%x&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;&bslash;tbase = 0x%x&bslash;n&quot;
comma
id|vbase
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;&bslash;tsize = 0x%x&bslash;n&quot;
comma
id|minsize
)paren
suffix:semicolon
multiline_comment|/* Initialize the table to have a one-to-one mapping&n;&t;&t; * over the allocated size.&n;&t;&t; */
id|tce_entryp
op_assign
(paren
r_int
r_int
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|minsize
op_rshift
l_int|3
)paren
suffix:semicolon
id|tce_entryp
op_increment
comma
id|i
op_increment
)paren
(brace
id|tce_entry
op_assign
(paren
id|i
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|tce_entry
op_or_assign
l_int|0x3
suffix:semicolon
op_star
id|tce_entryp
op_assign
id|tce_entry
suffix:semicolon
)brace
id|prom_printf
c_func
(paren
l_string|&quot;opening PHB %s&quot;
comma
id|path
)paren
suffix:semicolon
id|phb_node
op_assign
id|call_prom
c_func
(paren
l_string|&quot;open&quot;
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|phb_node
op_le
l_int|0
)paren
id|prom_printf
c_func
(paren
l_string|&quot;... failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|prom_printf
c_func
(paren
l_string|&quot;... done&bslash;n&quot;
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;call-method&quot;
comma
l_int|6
comma
l_int|0
comma
id|ADDR
c_func
(paren
l_string|&quot;set-64-bit-addressing&quot;
)paren
comma
id|phb_node
comma
op_minus
l_int|1
comma
id|minsize
comma
(paren
id|u32
)paren
id|base
comma
(paren
id|u32
)paren
(paren
id|base
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;close&quot;
comma
l_int|1
comma
l_int|0
comma
id|phb_node
)paren
suffix:semicolon
)brace
id|reserve_mem
c_func
(paren
id|local_alloc_bottom
comma
id|local_alloc_top
op_minus
id|local_alloc_bottom
)paren
suffix:semicolon
multiline_comment|/* Flag the first invalid entry */
id|prom_debug
c_func
(paren
l_string|&quot;ending prom_initialize_tce_table&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * With CHRP SMP we need to use the OF to start the other&n; * processors so we can&squot;t wait until smp_boot_cpus (the OF is&n; * trashed by then) so we have to put the processors into&n; * a holding pattern controlled by the kernel (not OF) before&n; * we destroy the OF.&n; *&n; * This uses a chunk of low memory, puts some holding pattern&n; * code there and sends the other processors off to there until&n; * smp_boot_cpus tells them to do something.  The holding pattern&n; * checks that address until its cpu # is there, when it is that&n; * cpu jumps to __secondary_start().  smp_boot_cpus() takes care&n; * of setting those values.&n; *&n; * We also use physical address 0x4 here to tell when a cpu&n; * is in its holding pattern code.&n; *&n; * Fixup comment... DRENG / PPPBBB - Peter&n; *&n; * -- Cort&n; */
DECL|function|prom_hold_cpus
r_static
r_void
id|__init
id|prom_hold_cpus
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|cpuid
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|interrupt_server
(braket
id|MAX_CPU_THREADS
)braket
suffix:semicolon
r_int
r_int
id|cpu_threads
comma
id|hw_cpu_num
suffix:semicolon
r_int
id|propsize
suffix:semicolon
r_extern
r_void
id|__secondary_hold
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__secondary_hold_spinloop
suffix:semicolon
r_extern
r_int
r_int
id|__secondary_hold_acknowledge
suffix:semicolon
r_int
r_int
op_star
id|spinloop
op_assign
(paren
r_void
op_star
)paren
id|virt_to_abs
c_func
(paren
op_amp
id|__secondary_hold_spinloop
)paren
suffix:semicolon
r_int
r_int
op_star
id|acknowledge
op_assign
(paren
r_void
op_star
)paren
id|virt_to_abs
c_func
(paren
op_amp
id|__secondary_hold_acknowledge
)paren
suffix:semicolon
r_int
r_int
id|secondary_hold
op_assign
id|virt_to_abs
c_func
(paren
op_star
id|PTRRELOC
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__secondary_hold
)paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;prom_hold_cpus: start...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    1) spinloop       = 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|spinloop
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    1) *spinloop      = 0x%x&bslash;n&quot;
comma
op_star
id|spinloop
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    1) acknowledge    = 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|acknowledge
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    1) *acknowledge   = 0x%x&bslash;n&quot;
comma
op_star
id|acknowledge
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;    1) secondary_hold = 0x%x&bslash;n&quot;
comma
id|secondary_hold
)paren
suffix:semicolon
multiline_comment|/* Set the common spinloop variable, so all of the secondary cpus&n;&t; * will block when they are awakened from their OF spinloop.&n;&t; * This must occur for both SMP and non SMP kernels, since OF will&n;&t; * be trashed when we move the kernel.&n;&t; */
op_star
id|spinloop
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_HMT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
l_int|0xdeadbeef
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* look for cpus */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;cpu&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Skip non-configured cpus. */
r_if
c_cond
(paren
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;status&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
OG
l_int|0
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;okay&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;&bslash;ncpuid        = 0x%x&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;cpu hw idx   = 0x%x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/* Init the acknowledge var which will be reset by&n;&t;&t; * the secondary cpu when it awakens from its OF&n;&t;&t; * spinloop.&n;&t;&t; */
op_star
id|acknowledge
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
id|propsize
op_assign
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;ibm,ppc-interrupt-server#s&quot;
comma
op_amp
id|interrupt_server
comma
r_sizeof
(paren
id|interrupt_server
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|propsize
OL
l_int|0
)paren
(brace
multiline_comment|/* no property.  old hardware has no SMT */
id|cpu_threads
op_assign
l_int|1
suffix:semicolon
id|interrupt_server
(braket
l_int|0
)braket
op_assign
id|reg
suffix:semicolon
multiline_comment|/* fake it with phys id */
)brace
r_else
(brace
multiline_comment|/* We have a threaded processor */
id|cpu_threads
op_assign
id|propsize
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_threads
OG
id|MAX_CPU_THREADS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;SMT: too many threads!&bslash;n&quot;
l_string|&quot;SMT: found %x, max is %x&bslash;n&quot;
comma
id|cpu_threads
comma
id|MAX_CPU_THREADS
)paren
suffix:semicolon
id|cpu_threads
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ToDo: panic? */
)brace
)brace
id|hw_cpu_num
op_assign
id|interrupt_server
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hw_cpu_num
op_ne
id|_prom-&gt;cpu
)paren
(brace
multiline_comment|/* Primary Thread of non-boot cpu */
id|prom_printf
c_func
(paren
l_string|&quot;%x : starting cpu hw idx %x... &quot;
comma
id|cpuid
comma
id|reg
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;start-cpu&quot;
comma
l_int|3
comma
l_int|0
comma
id|node
comma
id|secondary_hold
comma
id|reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|100000000
)paren
op_logical_and
(paren
op_star
id|acknowledge
op_eq
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|acknowledge
op_eq
id|reg
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We have to get every CPU out of OF,&n;&t;&t;&t;&t; * even if we never start it. */
r_if
c_cond
(paren
id|cpuid
op_ge
id|NR_CPUS
)paren
r_goto
id|next
suffix:semicolon
)brace
r_else
(brace
id|prom_printf
c_func
(paren
l_string|&quot;failed: %x&bslash;n&quot;
comma
op_star
id|acknowledge
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
r_else
id|prom_printf
c_func
(paren
l_string|&quot;%x : boot cpu     %x&bslash;n&quot;
comma
id|cpuid
comma
id|reg
)paren
suffix:semicolon
macro_line|#endif
id|next
suffix:colon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Init paca for secondary threads.   They start later. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cpu_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpuid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpuid
op_ge
id|NR_CPUS
)paren
r_continue
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
id|cpuid
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HMT
multiline_comment|/* Only enable HMT on processors that provide support. */
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_PULSAR
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_ICESTAR
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_SSTAR
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;    starting secondary threads&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|pir
op_assign
id|mfspr
c_func
(paren
id|SPRN_PIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_PULSAR
)paren
)paren
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
id|pir
op_amp
l_int|0x1f
suffix:semicolon
)brace
r_else
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
id|pir
op_amp
l_int|0x3ff
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Processor is not HMT capable&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cpuid
OG
id|NR_CPUS
)paren
id|prom_printf
c_func
(paren
l_string|&quot;WARNING: maximum CPUs (&quot;
id|__stringify
c_func
(paren
id|NR_CPUS
)paren
l_string|&quot;) exceeded: ignoring extras&bslash;n&quot;
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;prom_hold_cpus: end...&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|prom_init_client_services
r_static
r_void
id|__init
id|prom_init_client_services
c_func
(paren
r_int
r_int
id|pp
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
multiline_comment|/* Get a handle to the prom entry point before anything else */
id|_prom-&gt;entry
op_assign
id|pp
suffix:semicolon
multiline_comment|/* Init default value for phys size */
id|_prom-&gt;root_size_cells
op_assign
l_int|1
suffix:semicolon
id|_prom-&gt;root_addr_cells
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* get a handle for the stdout device */
id|_prom-&gt;chosen
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;/chosen&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;chosen
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;cannot find chosen&quot;
)paren
suffix:semicolon
multiline_comment|/* msg won&squot;t be printed :( */
multiline_comment|/* get device tree root */
id|_prom-&gt;root
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;/&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;root
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;cannot find device tree root&quot;
)paren
suffix:semicolon
multiline_comment|/* msg won&squot;t be printed :( */
)brace
DECL|function|prom_init_stdout
r_static
r_void
id|__init
id|prom_init_stdout
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
op_star
id|path
op_assign
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|16
)braket
suffix:semicolon
id|u32
id|val
suffix:semicolon
r_if
c_cond
(paren
id|prom_getprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;stdout&quot;
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;cannot find stdout&quot;
)paren
suffix:semicolon
id|_prom-&gt;stdout
op_assign
id|val
suffix:semicolon
multiline_comment|/* Get the full OF pathname of the stdout device */
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;instance-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|path
comma
l_int|255
)paren
suffix:semicolon
id|val
op_assign
id|call_prom
c_func
(paren
l_string|&quot;instance-to-package&quot;
comma
l_int|1
comma
l_int|1
comma
id|_prom-&gt;stdout
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,stdout-package&quot;
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;OF stdout device is: %s&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,stdout-path&quot;
comma
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
comma
id|strlen
c_func
(paren
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If it&squot;s a display, note it */
id|memset
c_func
(paren
id|type
comma
l_int|0
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
id|prom_getprop
c_func
(paren
id|val
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;display&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|_prom-&gt;disp_node
op_assign
id|val
suffix:semicolon
id|prom_setprop
c_func
(paren
id|val
comma
l_string|&quot;linux,boot-display&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|prom_find_machine_type
r_static
r_int
id|__init
id|prom_find_machine_type
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
id|compat
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|len
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|phandle
id|rtas
suffix:semicolon
id|len
op_assign
id|prom_getprop
c_func
(paren
id|_prom-&gt;root
comma
l_string|&quot;compatible&quot;
comma
id|compat
comma
r_sizeof
(paren
id|compat
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|compat
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|len
)paren
(brace
r_char
op_star
id|p
op_assign
op_amp
id|compat
(braket
id|i
)braket
suffix:semicolon
r_int
id|sl
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sl
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
id|RELOC
c_func
(paren
l_string|&quot;Power Macintosh&quot;
)paren
)paren
op_logical_or
id|strstr
c_func
(paren
id|p
comma
id|RELOC
c_func
(paren
l_string|&quot;MacRISC4&quot;
)paren
)paren
)paren
r_return
id|PLATFORM_POWERMAC
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
id|RELOC
c_func
(paren
l_string|&quot;Momentum,Maple&quot;
)paren
)paren
)paren
r_return
id|PLATFORM_MAPLE
suffix:semicolon
id|i
op_add_assign
id|sl
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Default to pSeries. We need to know if we are running LPAR */
id|rtas
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtas
op_ne
(paren
id|phandle
)paren
op_minus
l_int|1
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
id|x
op_assign
id|prom_getproplen
c_func
(paren
id|rtas
comma
l_string|&quot;ibm,hypertas-functions&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ne
id|PROM_ERROR
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Hypertas detected, assuming LPAR !&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|PLATFORM_PSERIES_LPAR
suffix:semicolon
)brace
)brace
r_return
id|PLATFORM_PSERIES
suffix:semicolon
)brace
DECL|function|prom_set_color
r_static
r_int
id|__init
id|prom_set_color
c_func
(paren
id|ihandle
id|ih
comma
r_int
id|i
comma
r_int
id|r
comma
r_int
id|g
comma
r_int
id|b
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_return
id|call_prom
c_func
(paren
l_string|&quot;call-method&quot;
comma
l_int|6
comma
l_int|1
comma
id|ADDR
c_func
(paren
l_string|&quot;color!&quot;
)paren
comma
id|ih
comma
id|i
comma
id|b
comma
id|g
comma
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we have a display that we don&squot;t know how to drive,&n; * we will want to try to execute OF&squot;s open method for it&n; * later.  However, OF will probably fall over if we do that&n; * we&squot;ve taken over the MMU.&n; * So we check whether we will need to open the display,&n; * and if so, open it now.&n; */
DECL|function|prom_check_displays
r_static
r_void
id|__init
id|prom_check_displays
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|16
)braket
comma
op_star
id|path
suffix:semicolon
id|phandle
id|node
suffix:semicolon
id|ihandle
id|ih
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
r_int
r_char
id|default_colors
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_const
r_int
r_char
op_star
id|clut
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Looking for displays&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|memset
c_func
(paren
id|type
comma
l_int|0
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
id|prom_getprop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;display&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|path
op_assign
id|RELOC
c_func
(paren
id|prom_scratch
)paren
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
id|PROM_SCRATCH_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leave some room at the end of the path for appending extra&n;&t;&t; * arguments&n;&t;&t; */
r_if
c_cond
(paren
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
id|PROM_SCRATCH_SIZE
op_minus
l_int|10
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;found display   : %s, opening ... &quot;
comma
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|call_prom
c_func
(paren
l_string|&quot;open&quot;
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih
op_eq
(paren
id|ihandle
)paren
l_int|0
op_logical_or
id|ih
op_eq
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Success */
id|prom_printf
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|node
comma
l_string|&quot;linux,opened&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * stdout wasn&squot;t a display node, pick the first we can find&n;&t;&t; * for btext&n;&t;&t; */
r_if
c_cond
(paren
id|_prom-&gt;disp_node
op_eq
l_int|0
)paren
id|_prom-&gt;disp_node
op_assign
id|node
suffix:semicolon
multiline_comment|/* Setup a useable color table when the appropriate&n;&t;&t; * method is available. Should update this to set-colors */
id|clut
op_assign
id|RELOC
c_func
(paren
id|default_colors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
comma
id|clut
op_add_assign
l_int|3
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
comma
id|clut
(braket
l_int|0
)braket
comma
id|clut
(braket
l_int|1
)braket
comma
id|clut
(braket
l_int|2
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_LOGO_LINUX_CLUT224
id|clut
op_assign
id|PTRRELOC
c_func
(paren
id|RELOC
c_func
(paren
id|logo_linux_clut224.clut
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RELOC
c_func
(paren
id|logo_linux_clut224.clutsize
)paren
suffix:semicolon
id|i
op_increment
comma
id|clut
op_add_assign
l_int|3
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
op_plus
l_int|32
comma
id|clut
(braket
l_int|0
)braket
comma
id|clut
(braket
l_int|1
)braket
comma
id|clut
(braket
l_int|2
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_LOGO_LINUX_CLUT224 */
)brace
)brace
multiline_comment|/* Return (relocated) pointer to this much memory: moves initrd if reqd. */
DECL|function|make_room
r_static
r_void
id|__init
op_star
id|make_room
c_func
(paren
r_int
r_int
op_star
id|mem_start
comma
r_int
r_int
op_star
id|mem_end
comma
r_int
r_int
id|needed
comma
r_int
r_int
id|align
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
op_star
id|mem_start
op_assign
id|_ALIGN
c_func
(paren
op_star
id|mem_start
comma
id|align
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|mem_start
op_plus
id|needed
)paren
OG
op_star
id|mem_end
)paren
(brace
r_int
r_int
id|room
comma
id|chunk
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;Chunk exhausted, claiming more at %x...&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
suffix:semicolon
id|room
op_assign
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_minus
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|room
OG
id|DEVTREE_CHUNK_SIZE
)paren
id|room
op_assign
id|DEVTREE_CHUNK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|room
OL
id|PAGE_SIZE
)paren
id|prom_panic
c_func
(paren
l_string|&quot;No memory for flatten_device_tree (no room)&quot;
)paren
suffix:semicolon
id|chunk
op_assign
id|alloc_up
c_func
(paren
id|room
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk
op_eq
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;No memory for flatten_device_tree (claim failed)&quot;
)paren
suffix:semicolon
op_star
id|mem_end
op_assign
id|RELOC
c_func
(paren
id|alloc_top
)paren
suffix:semicolon
)brace
id|ret
op_assign
(paren
r_void
op_star
)paren
op_star
id|mem_start
suffix:semicolon
op_star
id|mem_start
op_add_assign
id|needed
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|dt_push_token
mdefine_line|#define dt_push_token(token, mem_start, mem_end) &bslash;&n;&t;do { *((u32 *)make_room(mem_start, mem_end, 4, 4)) = token; } while(0)
DECL|function|dt_find_string
r_static
r_int
r_int
id|__init
id|dt_find_string
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|s
comma
op_star
id|os
suffix:semicolon
id|s
op_assign
id|os
op_assign
(paren
r_char
op_star
)paren
id|RELOC
c_func
(paren
id|dt_string_start
)paren
suffix:semicolon
id|s
op_add_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|s
OL
(paren
r_char
op_star
)paren
id|RELOC
c_func
(paren
id|dt_string_end
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|s
comma
id|str
)paren
op_eq
l_int|0
)paren
r_return
id|s
op_minus
id|os
suffix:semicolon
id|s
op_add_assign
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scan_dt_build_strings
r_static
r_void
id|__init
id|scan_dt_build_strings
c_func
(paren
id|phandle
id|node
comma
r_int
r_int
op_star
id|mem_start
comma
r_int
r_int
op_star
id|mem_end
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|prev_name
comma
op_star
id|namep
comma
op_star
id|sstart
suffix:semicolon
r_int
r_int
id|soff
suffix:semicolon
id|phandle
id|child
suffix:semicolon
id|sstart
op_assign
(paren
r_char
op_star
)paren
id|RELOC
c_func
(paren
id|dt_string_start
)paren
suffix:semicolon
multiline_comment|/* get and store all property names */
id|prev_name
op_assign
id|RELOC
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* 32 is max len of name including nul. */
id|namep
op_assign
id|make_room
c_func
(paren
id|mem_start
comma
id|mem_end
comma
l_int|32
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_prom
c_func
(paren
l_string|&quot;nextprop&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|prev_name
comma
id|namep
)paren
op_le
l_int|0
)paren
(brace
multiline_comment|/* No more nodes: unwind alloc */
op_star
id|mem_start
op_assign
(paren
r_int
r_int
)paren
id|namep
suffix:semicolon
r_break
suffix:semicolon
)brace
id|soff
op_assign
id|dt_find_string
c_func
(paren
id|namep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff
op_ne
l_int|0
)paren
(brace
op_star
id|mem_start
op_assign
(paren
r_int
r_int
)paren
id|namep
suffix:semicolon
id|namep
op_assign
id|sstart
op_plus
id|soff
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Trim off some if we can */
op_star
id|mem_start
op_assign
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_string_end
)paren
op_assign
op_star
id|mem_start
suffix:semicolon
)brace
id|prev_name
op_assign
id|namep
suffix:semicolon
)brace
multiline_comment|/* do all our children */
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;child&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|child
op_ne
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|scan_dt_build_strings
c_func
(paren
id|child
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|child
)paren
suffix:semicolon
)brace
)brace
DECL|function|scan_dt_build_struct
r_static
r_void
id|__init
id|scan_dt_build_struct
c_func
(paren
id|phandle
id|node
comma
r_int
r_int
op_star
id|mem_start
comma
r_int
r_int
op_star
id|mem_end
)paren
(brace
r_int
id|l
comma
id|align
suffix:semicolon
id|phandle
id|child
suffix:semicolon
r_char
op_star
id|namep
comma
op_star
id|prev_name
comma
op_star
id|sstart
suffix:semicolon
r_int
r_int
id|soff
suffix:semicolon
r_int
r_char
op_star
id|valp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|pname
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
id|path
op_assign
id|RELOC
c_func
(paren
id|prom_scratch
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
id|OF_DT_BEGIN_NODE
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
multiline_comment|/* get the node&squot;s full name */
id|namep
op_assign
(paren
r_char
op_star
)paren
op_star
id|mem_start
suffix:semicolon
id|l
op_assign
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|namep
comma
op_star
id|mem_end
op_minus
op_star
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Didn&squot;t fit?  Get more room. */
r_if
c_cond
(paren
id|l
op_plus
l_int|1
OG
op_star
id|mem_end
op_minus
op_star
id|mem_start
)paren
(brace
id|namep
op_assign
id|make_room
c_func
(paren
id|mem_start
comma
id|mem_end
comma
id|l
op_plus
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|namep
comma
id|l
)paren
suffix:semicolon
)brace
id|namep
(braket
id|l
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|mem_start
op_assign
id|_ALIGN
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|namep
)paren
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* get it again for debugging */
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
id|PROM_SCRATCH_SIZE
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
id|PROM_SCRATCH_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* get and store all properties */
id|prev_name
op_assign
id|RELOC
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|sstart
op_assign
(paren
r_char
op_star
)paren
id|RELOC
c_func
(paren
id|dt_string_start
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|call_prom
c_func
(paren
l_string|&quot;nextprop&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|prev_name
comma
id|pname
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* find string offset */
id|soff
op_assign
id|dt_find_string
c_func
(paren
id|pname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;WARNING: Can&squot;t find string index for &lt;%s&gt;, node %s&bslash;n&quot;
comma
id|pname
comma
id|path
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev_name
op_assign
id|sstart
op_plus
id|soff
suffix:semicolon
multiline_comment|/* get length */
id|l
op_assign
id|call_prom
c_func
(paren
l_string|&quot;getproplen&quot;
comma
l_int|2
comma
l_int|1
comma
id|node
comma
id|pname
)paren
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|l
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|MAX_PROPERTY_LENGTH
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;WARNING: ignoring large property &quot;
)paren
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|prom_printf
c_func
(paren
l_string|&quot;[%s] &quot;
comma
id|path
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;%s length 0x%x&bslash;n&quot;
comma
id|pname
comma
id|l
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* push property head */
id|dt_push_token
c_func
(paren
id|OF_DT_PROP
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
id|l
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
id|soff
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
multiline_comment|/* push property content */
id|align
op_assign
(paren
id|l
op_ge
l_int|8
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|4
suffix:semicolon
id|valp
op_assign
id|make_room
c_func
(paren
id|mem_start
comma
id|mem_end
comma
id|l
comma
id|align
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|pname
comma
id|valp
comma
id|l
)paren
suffix:semicolon
op_star
id|mem_start
op_assign
id|_ALIGN
c_func
(paren
op_star
id|mem_start
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a &quot;linux,phandle&quot; property. */
id|soff
op_assign
id|dt_find_string
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;linux,phandle&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff
op_eq
l_int|0
)paren
id|prom_printf
c_func
(paren
l_string|&quot;WARNING: Can&squot;t find string index for &lt;linux-phandle&gt;&quot;
l_string|&quot; node %s&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_else
(brace
id|dt_push_token
c_func
(paren
id|OF_DT_PROP
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
l_int|4
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
id|soff
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|valp
op_assign
id|make_room
c_func
(paren
id|mem_start
comma
id|mem_end
comma
l_int|4
comma
l_int|4
)paren
suffix:semicolon
op_star
(paren
id|u32
op_star
)paren
id|valp
op_assign
id|node
suffix:semicolon
)brace
multiline_comment|/* do all our children */
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;child&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|child
op_ne
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|scan_dt_build_struct
c_func
(paren
id|child
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|child
)paren
suffix:semicolon
)brace
id|dt_push_token
c_func
(paren
id|OF_DT_END_NODE
comma
id|mem_start
comma
id|mem_end
)paren
suffix:semicolon
)brace
DECL|function|flatten_device_tree
r_static
r_void
id|__init
id|flatten_device_tree
c_func
(paren
r_void
)paren
(brace
id|phandle
id|root
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|mem_start
comma
id|mem_end
comma
id|room
suffix:semicolon
r_struct
id|boot_param_header
op_star
id|hdr
suffix:semicolon
r_char
op_star
id|namep
suffix:semicolon
id|u64
op_star
id|rsvmap
suffix:semicolon
multiline_comment|/*&n;&t; * Check how much room we have between alloc top &amp; bottom (+/- a&n;&t; * few pages), crop to 4Mb, as this is our &quot;chuck&quot; size&n;&t; */
id|room
op_assign
id|RELOC
c_func
(paren
id|alloc_top
)paren
op_minus
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
op_minus
l_int|0x4000
suffix:semicolon
r_if
c_cond
(paren
id|room
OG
id|DEVTREE_CHUNK_SIZE
)paren
id|room
op_assign
id|DEVTREE_CHUNK_SIZE
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;starting device tree allocs at %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|alloc_bottom
)paren
)paren
suffix:semicolon
multiline_comment|/* Now try to claim that */
id|mem_start
op_assign
(paren
r_int
r_int
)paren
id|alloc_up
c_func
(paren
id|room
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_start
op_eq
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;Can&squot;t allocate initial device-tree chunk&bslash;n&quot;
)paren
suffix:semicolon
id|mem_end
op_assign
id|RELOC
c_func
(paren
id|alloc_top
)paren
suffix:semicolon
multiline_comment|/* Get root of tree */
id|root
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
(paren
id|phandle
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
(paren
id|phandle
)paren
l_int|0
)paren
id|prom_panic
(paren
l_string|&quot;couldn&squot;t get device tree root&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Build header and make room for mem rsv map */
id|mem_start
op_assign
id|_ALIGN
c_func
(paren
id|mem_start
comma
l_int|4
)paren
suffix:semicolon
id|hdr
op_assign
id|make_room
c_func
(paren
op_amp
id|mem_start
comma
op_amp
id|mem_end
comma
r_sizeof
(paren
r_struct
id|boot_param_header
)paren
comma
l_int|4
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_header_start
)paren
op_assign
(paren
r_int
r_int
)paren
id|hdr
suffix:semicolon
id|rsvmap
op_assign
id|make_room
c_func
(paren
op_amp
id|mem_start
comma
op_amp
id|mem_end
comma
r_sizeof
(paren
id|mem_reserve_map
)paren
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Start of strings */
id|mem_start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mem_start
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_string_start
)paren
op_assign
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* hole */
multiline_comment|/* Add &quot;linux,phandle&quot; in there, we&squot;ll need it */
id|namep
op_assign
id|make_room
c_func
(paren
op_amp
id|mem_start
comma
op_amp
id|mem_end
comma
l_int|16
comma
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|namep
comma
id|RELOC
c_func
(paren
l_string|&quot;linux,phandle&quot;
)paren
)paren
suffix:semicolon
id|mem_start
op_assign
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_string_end
)paren
op_assign
id|mem_start
suffix:semicolon
multiline_comment|/* Build string array */
id|prom_printf
c_func
(paren
l_string|&quot;Building dt strings...&bslash;n&quot;
)paren
suffix:semicolon
id|scan_dt_build_strings
c_func
(paren
id|root
comma
op_amp
id|mem_start
comma
op_amp
id|mem_end
)paren
suffix:semicolon
multiline_comment|/* Build structure */
id|mem_start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mem_start
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_struct_start
)paren
op_assign
id|mem_start
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Building dt structure...&bslash;n&quot;
)paren
suffix:semicolon
id|scan_dt_build_struct
c_func
(paren
id|root
comma
op_amp
id|mem_start
comma
op_amp
id|mem_end
)paren
suffix:semicolon
id|dt_push_token
c_func
(paren
id|OF_DT_END
comma
op_amp
id|mem_start
comma
op_amp
id|mem_end
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|dt_struct_end
)paren
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mem_start
)paren
suffix:semicolon
multiline_comment|/* Finish header */
id|hdr-&gt;magic
op_assign
id|OF_DT_HEADER
suffix:semicolon
id|hdr-&gt;totalsize
op_assign
id|RELOC
c_func
(paren
id|dt_struct_end
)paren
op_minus
id|RELOC
c_func
(paren
id|dt_header_start
)paren
suffix:semicolon
id|hdr-&gt;off_dt_struct
op_assign
id|RELOC
c_func
(paren
id|dt_struct_start
)paren
op_minus
id|RELOC
c_func
(paren
id|dt_header_start
)paren
suffix:semicolon
id|hdr-&gt;off_dt_strings
op_assign
id|RELOC
c_func
(paren
id|dt_string_start
)paren
op_minus
id|RELOC
c_func
(paren
id|dt_header_start
)paren
suffix:semicolon
id|hdr-&gt;off_mem_rsvmap
op_assign
(paren
(paren
r_int
r_int
)paren
id|rsvmap
)paren
op_minus
id|RELOC
c_func
(paren
id|dt_header_start
)paren
suffix:semicolon
id|hdr-&gt;version
op_assign
id|OF_DT_VERSION
suffix:semicolon
id|hdr-&gt;last_comp_version
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Reserve the whole thing and copy the reserve map in, we&n;&t; * also bump mem_reserve_cnt to cause further reservations to&n;&t; * fail since it&squot;s too late.&n;&t; */
id|reserve_mem
c_func
(paren
id|RELOC
c_func
(paren
id|dt_header_start
)paren
comma
id|hdr-&gt;totalsize
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|rsvmap
comma
id|RELOC
c_func
(paren
id|mem_reserve_map
)paren
comma
r_sizeof
(paren
id|mem_reserve_map
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
(brace
r_int
id|i
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;reserved memory map:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RELOC
c_func
(paren
id|mem_reserve_cnt
)paren
suffix:semicolon
id|i
op_increment
)paren
id|prom_printf
c_func
(paren
l_string|&quot;  %x - %x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|mem_reserve_map
)paren
(braket
id|i
)braket
dot
id|base
comma
id|RELOC
c_func
(paren
id|mem_reserve_map
)paren
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
id|RELOC
c_func
(paren
id|mem_reserve_cnt
)paren
op_assign
id|MEM_RESERVE_MAP_SIZE
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Device tree strings 0x%x -&gt; 0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|dt_string_start
)paren
comma
id|RELOC
c_func
(paren
id|dt_string_end
)paren
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Device tree struct  0x%x -&gt; 0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|dt_struct_start
)paren
comma
id|RELOC
c_func
(paren
id|dt_struct_end
)paren
)paren
suffix:semicolon
)brace
DECL|function|prom_find_boot_cpu
r_static
r_void
id|__init
id|prom_find_boot_cpu
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|u32
id|getprop_rval
suffix:semicolon
id|ihandle
id|prom_cpu
suffix:semicolon
id|phandle
id|cpu_pkg
suffix:semicolon
r_if
c_cond
(paren
id|prom_getprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;cpu&quot;
comma
op_amp
id|prom_cpu
comma
r_sizeof
(paren
id|prom_cpu
)paren
)paren
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
l_string|&quot;cannot find boot cpu&quot;
)paren
suffix:semicolon
id|cpu_pkg
op_assign
id|call_prom
c_func
(paren
l_string|&quot;instance-to-package&quot;
comma
l_int|1
comma
l_int|1
comma
id|prom_cpu
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|cpu_pkg
comma
l_string|&quot;linux,boot-cpu&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|prom_getprop
c_func
(paren
id|cpu_pkg
comma
l_string|&quot;reg&quot;
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_prom-&gt;cpu
op_assign
id|getprop_rval
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;Booting CPU hw index = 0x%x&bslash;n&quot;
comma
id|_prom-&gt;cpu
)paren
suffix:semicolon
)brace
DECL|function|prom_check_initrd
r_static
r_void
id|__init
id|prom_check_initrd
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_logical_and
id|r4
op_logical_and
id|r4
op_ne
l_int|0xdeadbeef
)paren
(brace
id|u64
id|val
suffix:semicolon
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
op_assign
(paren
id|r3
op_ge
id|KERNELBASE
)paren
ques
c_cond
id|__pa
c_func
(paren
id|r3
)paren
suffix:colon
id|r3
suffix:semicolon
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
op_assign
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
op_plus
id|r4
suffix:semicolon
id|val
op_assign
(paren
id|u64
)paren
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,initrd-start&quot;
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
suffix:semicolon
id|val
op_assign
(paren
id|u64
)paren
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,initrd-end&quot;
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
suffix:semicolon
id|reserve_mem
c_func
(paren
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
comma
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
op_minus
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;initrd_start=0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|prom_initrd_start
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;initrd_end=0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|prom_initrd_end
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
)brace
multiline_comment|/*&n; * We enter here early on, when the Open Firmware prom is still&n; * handling exceptions and the MMU hash table for us.&n; */
DECL|function|prom_init
r_int
r_int
id|__init
id|prom_init
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|pp
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_int
r_int
id|phys
op_assign
id|KERNELBASE
op_minus
id|offset
suffix:semicolon
id|u32
id|getprop_rval
suffix:semicolon
multiline_comment|/*&n;&t; * First zero the BSS&n;&t; */
id|memset
c_func
(paren
id|PTRRELOC
c_func
(paren
op_amp
id|__bss_start
)paren
comma
l_int|0
comma
id|__bss_stop
op_minus
id|__bss_start
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Init interface to Open Firmware, get some node references,&n;&t; * like /chosen&n;&t; */
id|prom_init_client_services
c_func
(paren
id|pp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Init prom stdout device&n;&t; */
id|prom_init_stdout
c_func
(paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;klimit=0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|klimit
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;offset=0x%x&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for an initrd&n;&t; */
id|prom_check_initrd
c_func
(paren
id|r3
comma
id|r4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get default machine type. At this point, we do not differenciate&n;&t; * between pSeries SMP and pSeries LPAR&n;&t; */
id|RELOC
c_func
(paren
id|of_platform
)paren
op_assign
id|prom_find_machine_type
c_func
(paren
)paren
suffix:semicolon
id|getprop_rval
op_assign
id|RELOC
c_func
(paren
id|of_platform
)paren
suffix:semicolon
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,platform&quot;
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * On pSeries, copy the CPU hold code&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|of_platform
)paren
op_amp
id|PLATFORM_PSERIES
)paren
id|copy_and_flush
c_func
(paren
l_int|0
comma
id|KERNELBASE
op_minus
id|offset
comma
l_int|0x100
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get memory cells format&n;&t; */
id|getprop_rval
op_assign
l_int|1
suffix:semicolon
id|prom_getprop
c_func
(paren
id|_prom-&gt;root
comma
l_string|&quot;#size-cells&quot;
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_prom-&gt;root_size_cells
op_assign
id|getprop_rval
suffix:semicolon
id|getprop_rval
op_assign
l_int|2
suffix:semicolon
id|prom_getprop
c_func
(paren
id|_prom-&gt;root
comma
l_string|&quot;#address-cells&quot;
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_prom-&gt;root_addr_cells
op_assign
id|getprop_rval
suffix:semicolon
multiline_comment|/*&n;&t; * Do early parsing of command line&n;&t; */
id|early_cmdline_parse
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize memory management within prom_init&n;&t; */
id|prom_init_mem
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine which cpu is actually running right _now_&n;&t; */
id|prom_find_boot_cpu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Initialize display devices&n;&t; */
id|prom_check_displays
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize IOMMU (TCE tables) on pSeries. Do that before anything else&n;&t; * that uses the allocator, we need to make sure we get the top of memory&n;&t; * available for us here...&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|of_platform
)paren
op_eq
id|PLATFORM_PSERIES
)paren
id|prom_initialize_tce_table
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * On non-powermacs, try to instantiate RTAS and puts all CPUs&n;&t; * in spin-loops. PowerMacs don&squot;t have a working RTAS and use&n;&t; * a different way to spin CPUs&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|of_platform
)paren
op_ne
id|PLATFORM_POWERMAC
)paren
(brace
id|prom_instantiate_rtas
c_func
(paren
)paren
suffix:semicolon
id|prom_hold_cpus
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in some infos for use by the kernel later on&n;&t; */
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|ppc64_iommu_off
)paren
)paren
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,iommu-off&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|iommu_force_on
)paren
)paren
id|prom_setprop
c_func
(paren
id|_prom-&gt;chosen
comma
l_string|&quot;linux,iommu-force-on&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now finally create the flattened device-tree&n;&t; */
id|prom_printf
c_func
(paren
l_string|&quot;copying OF device tree ...&bslash;n&quot;
)paren
suffix:semicolon
id|flatten_device_tree
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Call OF &quot;quiesce&quot; method to shut down pending DMA&squot;s from&n;&t; * devices etc...&n;&t; */
id|prom_printf
c_func
(paren
l_string|&quot;Calling quiesce ...&bslash;n&quot;
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;quiesce&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And finally, call the kernel passing it the flattened device&n;&t; * tree and NULL as r5, thus triggering the new entry point which&n;&t; * is common to us and kexec&n;&t; */
id|prom_printf
c_func
(paren
l_string|&quot;returning from prom_init&bslash;n&quot;
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;-&gt;dt_header_start=0x%x&bslash;n&quot;
comma
id|RELOC
c_func
(paren
id|dt_header_start
)paren
)paren
suffix:semicolon
id|prom_debug
c_func
(paren
l_string|&quot;-&gt;phys=0x%x&bslash;n&quot;
comma
id|phys
)paren
suffix:semicolon
id|__start
c_func
(paren
id|RELOC
c_func
(paren
id|dt_header_start
)paren
comma
id|phys
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
