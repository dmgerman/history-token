multiline_comment|/*&n; * SMP support for power macintosh.&n; *&n; * We support both the old &quot;powersurge&quot; SMP architecture&n; * and the current Core99 (G4 PowerMac) machines.&n; *&n; * Note that we don&squot;t support the very first rev. of&n; * Apple/DayStar 2 CPUs board, the one with the funky&n; * watchdog. Hopefully, none of these should be there except&n; * maybe internally to Apple. I should probably still add some&n; * code to detect this card though and disable SMP. --BenH.&n; *&n; * Support Macintosh G4 SMP by Troy Benjegerdes (hozer@drgw.net)&n; * and Ben Herrenschmidt &lt;benh@kernel.crashing.org&gt;.&n; *&n; * Support for DayStar quad CPU cards&n; * Copyright (C) XLR8, Inc. 1994-2000&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/keylargo.h&gt;
macro_line|#include &lt;asm/pmac_low_i2c.h&gt;
macro_line|#include &quot;mpic.h&quot;
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(fmt...) udbg_printf(fmt)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(fmt...)
macro_line|#endif
r_extern
r_void
id|pmac_secondary_start_1
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pmac_secondary_start_2
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pmac_secondary_start_3
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|smp_ops_t
op_star
id|smp_ops
suffix:semicolon
DECL|variable|pmac_tb_freeze
r_static
r_void
(paren
op_star
id|pmac_tb_freeze
)paren
(paren
r_int
id|freeze
)paren
suffix:semicolon
DECL|variable|pmac_tb_clock_chip_host
r_static
r_struct
id|device_node
op_star
id|pmac_tb_clock_chip_host
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|timebase_lock
)paren
suffix:semicolon
DECL|variable|timebase
r_static
r_int
r_int
id|timebase
suffix:semicolon
DECL|function|smp_core99_cypress_tb_freeze
r_static
r_void
id|smp_core99_cypress_tb_freeze
c_func
(paren
r_int
id|freeze
)paren
(brace
id|u8
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Strangely, the device-tree says address is 0xd2, but darwin&n;&t; * accesses 0xd0 ...&n;&t; */
id|pmac_low_i2c_setmode
c_func
(paren
id|pmac_tb_clock_chip_host
comma
id|pmac_low_i2c_mode_combined
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_low_i2c_xfer
c_func
(paren
id|pmac_tb_clock_chip_host
comma
l_int|0xd0
op_or
id|pmac_low_i2c_read
comma
l_int|0x81
comma
op_amp
id|data
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_goto
id|bail
suffix:semicolon
id|data
op_assign
(paren
id|data
op_amp
l_int|0xf3
)paren
op_or
(paren
id|freeze
ques
c_cond
l_int|0x00
suffix:colon
l_int|0x0c
)paren
suffix:semicolon
id|pmac_low_i2c_setmode
c_func
(paren
id|pmac_tb_clock_chip_host
comma
id|pmac_low_i2c_mode_stdsub
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_low_i2c_xfer
c_func
(paren
id|pmac_tb_clock_chip_host
comma
l_int|0xd0
op_or
id|pmac_low_i2c_write
comma
l_int|0x81
comma
op_amp
id|data
comma
l_int|1
)paren
suffix:semicolon
id|bail
suffix:colon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cypress Timebase %s rc: %d&bslash;n&quot;
comma
id|freeze
ques
c_cond
l_string|&quot;freeze&quot;
suffix:colon
l_string|&quot;unfreeze&quot;
comma
id|rc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Timebase freeze failed !&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_core99_pulsar_tb_freeze
r_static
r_void
id|smp_core99_pulsar_tb_freeze
c_func
(paren
r_int
id|freeze
)paren
(brace
id|u8
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Strangely, the device-tree says address is 0xd2, but darwin&n;&t; * accesses 0xd0 ...&n;&t; */
id|pmac_low_i2c_setmode
c_func
(paren
id|pmac_tb_clock_chip_host
comma
id|pmac_low_i2c_mode_combined
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_low_i2c_xfer
c_func
(paren
id|pmac_tb_clock_chip_host
comma
l_int|0xd4
op_or
id|pmac_low_i2c_read
comma
l_int|0x2e
comma
op_amp
id|data
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_goto
id|bail
suffix:semicolon
id|data
op_assign
(paren
id|data
op_amp
l_int|0x88
)paren
op_or
(paren
id|freeze
ques
c_cond
l_int|0x11
suffix:colon
l_int|0x22
)paren
suffix:semicolon
id|pmac_low_i2c_setmode
c_func
(paren
id|pmac_tb_clock_chip_host
comma
id|pmac_low_i2c_mode_stdsub
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_low_i2c_xfer
c_func
(paren
id|pmac_tb_clock_chip_host
comma
l_int|0xd4
op_or
id|pmac_low_i2c_write
comma
l_int|0x2e
comma
op_amp
id|data
comma
l_int|1
)paren
suffix:semicolon
id|bail
suffix:colon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Pulsar Timebase %s rc: %d&bslash;n&quot;
comma
id|freeze
ques
c_cond
l_string|&quot;freeze&quot;
suffix:colon
l_string|&quot;unfreeze&quot;
comma
id|rc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Timebase freeze failed !&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_core99_give_timebase
r_static
r_void
id|smp_core99_give_timebase
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Open i2c bus for synchronous access */
r_if
c_cond
(paren
id|pmac_low_i2c_open
c_func
(paren
id|pmac_tb_clock_chip_host
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Can&squot;t open i2c for TB sync !&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
(paren
op_star
id|pmac_tb_freeze
)paren
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|timebase
op_assign
id|get_tb
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timebase
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
(paren
op_star
id|pmac_tb_freeze
)paren
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
multiline_comment|/* Close i2c bus */
id|pmac_low_i2c_close
c_func
(paren
id|pmac_tb_clock_chip_host
)paren
suffix:semicolon
)brace
DECL|function|smp_core99_take_timebase
r_static
r_void
id|__devinit
id|smp_core99_take_timebase
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|timebase
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
id|set_tb
c_func
(paren
id|timebase
op_rshift
l_int|32
comma
id|timebase
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|timebase
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|timebase_lock
)paren
suffix:semicolon
)brace
DECL|function|smp_core99_probe
r_static
r_int
id|__init
id|smp_core99_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|cpus
suffix:semicolon
r_struct
id|device_node
op_star
id|cc
suffix:semicolon
r_int
id|ncpus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Maybe use systemconfiguration here ? */
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_probe&quot;
comma
l_int|0x345
)paren
suffix:semicolon
multiline_comment|/* Count CPUs in the device-tree */
r_for
c_loop
(paren
id|cpus
op_assign
l_int|NULL
suffix:semicolon
(paren
id|cpus
op_assign
id|of_find_node_by_type
c_func
(paren
id|cpus
comma
l_string|&quot;cpu&quot;
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
op_increment
id|ncpus
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PowerMac SMP probe found %d cpus&bslash;n&quot;
comma
id|ncpus
)paren
suffix:semicolon
multiline_comment|/* Nothing more to do if less than 2 of them */
r_if
c_cond
(paren
id|ncpus
op_le
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Look for the clock chip */
r_for
c_loop
(paren
id|cc
op_assign
l_int|NULL
suffix:semicolon
(paren
id|cc
op_assign
id|of_find_node_by_name
c_func
(paren
id|cc
comma
l_string|&quot;i2c-hwclock&quot;
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_struct
id|device_node
op_star
id|p
op_assign
id|of_get_parent
c_func
(paren
id|cc
)paren
suffix:semicolon
id|u32
op_star
id|reg
suffix:semicolon
r_int
id|ok
suffix:semicolon
id|ok
op_assign
id|p
op_logical_and
id|device_is_compatible
c_func
(paren
id|p
comma
l_string|&quot;uni-n-i2c&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
r_goto
id|next
suffix:semicolon
id|reg
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|cc
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
l_int|NULL
)paren
r_goto
id|next
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|reg
)paren
(brace
r_case
l_int|0xd2
suffix:colon
id|pmac_tb_freeze
op_assign
id|smp_core99_cypress_tb_freeze
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Timebase clock is Cypress chip&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd4
suffix:colon
id|pmac_tb_freeze
op_assign
id|smp_core99_pulsar_tb_freeze
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Timebase clock is Pulsar chip&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmac_tb_freeze
op_ne
l_int|NULL
)paren
(brace
id|pmac_tb_clock_chip_host
op_assign
id|p
suffix:semicolon
id|smp_ops-&gt;give_timebase
op_assign
id|smp_core99_give_timebase
suffix:semicolon
id|smp_ops-&gt;take_timebase
op_assign
id|smp_core99_take_timebase
suffix:semicolon
r_break
suffix:semicolon
)brace
id|next
suffix:colon
id|of_node_put
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|mpic_request_ipis
c_func
(paren
)paren
suffix:semicolon
r_return
id|ncpus
suffix:semicolon
)brace
DECL|function|smp_core99_kick_cpu
r_static
r_void
id|__init
id|smp_core99_kick_cpu
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
id|save_vector
comma
id|j
suffix:semicolon
r_int
r_int
id|new_vector
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_int
op_star
id|vector
op_assign
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|KERNELBASE
op_plus
l_int|0x100
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
template_param
l_int|3
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_kick_cpu&quot;
comma
l_int|0x346
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save reset vector */
id|save_vector
op_assign
op_star
id|vector
suffix:semicolon
multiline_comment|/* Setup fake reset vector that does&t;&n;&t; *   b .pmac_secondary_start - KERNELBASE&n;&t; */
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|1
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|pmac_secondary_start_1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|pmac_secondary_start_2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_default
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|pmac_secondary_start_3
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|vector
op_assign
l_int|0x48000002
op_plus
(paren
id|new_vector
op_minus
id|KERNELBASE
)paren
suffix:semicolon
multiline_comment|/* flush data cache and inval instruction cache */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|vector
comma
(paren
r_int
r_int
)paren
id|vector
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Put some life in our friend */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_RESET_CPU
comma
l_int|NULL
comma
id|nr
comma
l_int|0
)paren
suffix:semicolon
id|paca
(braket
id|nr
)braket
dot
id|cpu_start
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FIXME: We wait a bit for the CPU to take the exception, I should&n;&t; * instead wait for the entry code to set something for me. Well,&n;&t; * ideally, all that crap will be done in prom.c and the CPU left&n;&t; * in a RAM-based wait loop like CHRP.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|1000000
suffix:semicolon
id|j
op_increment
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore our exception vector */
op_star
id|vector
op_assign
id|save_vector
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|vector
comma
(paren
r_int
r_int
)paren
id|vector
op_plus
l_int|4
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_kick_cpu done&quot;
comma
l_int|0x347
)paren
suffix:semicolon
)brace
DECL|function|smp_core99_setup_cpu
r_static
r_void
id|__init
id|smp_core99_setup_cpu
c_func
(paren
r_int
id|cpu_nr
)paren
(brace
multiline_comment|/* Setup MPIC */
id|mpic_setup_this_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_nr
op_eq
l_int|0
)paren
(brace
r_extern
r_void
id|g5_phy_disable_cpu1
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t start the second CPU, we must take&n;&t;&t; * it off the bus&n;&t;&t; */
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OL
l_int|2
)paren
id|g5_phy_disable_cpu1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_setup_cpu 0 done&quot;
comma
l_int|0x349
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__pmacdata
r_struct
id|smp_ops_t
id|core99_smp_ops
id|__pmacdata
op_assign
(brace
dot
id|message_pass
op_assign
id|smp_mpic_message_pass
comma
dot
id|probe
op_assign
id|smp_core99_probe
comma
dot
id|kick_cpu
op_assign
id|smp_core99_kick_cpu
comma
dot
id|setup_cpu
op_assign
id|smp_core99_setup_cpu
comma
dot
id|give_timebase
op_assign
id|smp_generic_give_timebase
comma
dot
id|take_timebase
op_assign
id|smp_generic_take_timebase
comma
)brace
suffix:semicolon
DECL|function|pmac_setup_smp
r_void
id|__init
id|pmac_setup_smp
c_func
(paren
r_void
)paren
(brace
id|smp_ops
op_assign
op_amp
id|core99_smp_ops
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
id|smp_ops-&gt;cpu_enable
op_assign
id|generic_cpu_enable
suffix:semicolon
id|smp_ops-&gt;cpu_disable
op_assign
id|generic_cpu_disable
suffix:semicolon
id|smp_ops-&gt;cpu_die
op_assign
id|generic_cpu_die
suffix:semicolon
macro_line|#endif
)brace
eof
