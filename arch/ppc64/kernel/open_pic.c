multiline_comment|/*&n; *  arch/ppc/kernel/open_pic.c -- OpenPIC Interrupt Handling&n; *&n; *  Copyright (C) 1997 Geert Uytterhoeven&n; *&n; *  This file is subject to the terms and conditions of the GNU General Public&n; *  License.  See the file COPYING in the main directory of this archive&n; *  for more details.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &quot;local_irq.h&quot;
macro_line|#include &quot;open_pic.h&quot;
macro_line|#include &quot;open_pic_defs.h&quot;
macro_line|#include &quot;i8259.h&quot;
macro_line|#include &lt;asm/ppcdebug.h&gt;
DECL|variable|OpenPIC_Addr
r_void
op_star
id|OpenPIC_Addr
suffix:semicolon
DECL|variable|OpenPIC
r_static
r_volatile
r_struct
id|OpenPIC
op_star
id|OpenPIC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|__initdata
id|u_int
id|OpenPIC_NumInitSenses
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
id|u_char
op_star
id|OpenPIC_InitSenses
id|__initdata
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_int
id|use_of_interrupt_tree
suffix:semicolon
r_void
id|find_ISUs
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|NumProcessors
r_static
id|u_int
id|NumProcessors
suffix:semicolon
DECL|variable|NumSources
r_static
id|u_int
id|NumSources
suffix:semicolon
DECL|variable|NumISUs
r_static
r_int
id|NumISUs
suffix:semicolon
DECL|variable|open_pic_irq_offset
r_static
r_int
id|open_pic_irq_offset
suffix:semicolon
DECL|variable|chrp_int_ack_special
r_static
r_volatile
r_int
r_char
op_star
id|chrp_int_ack_special
suffix:semicolon
DECL|variable|broken_ipi_registers
r_static
r_int
id|broken_ipi_registers
suffix:semicolon
DECL|variable|ISU
id|OpenPIC_SourcePtr
id|ISU
(braket
id|OPENPIC_MAX_ISU
)braket
suffix:semicolon
r_static
r_void
id|openpic_end_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_void
id|openpic_set_affinity
c_func
(paren
r_int
r_int
id|irq_nr
comma
r_int
r_int
id|cpumask
)paren
suffix:semicolon
DECL|variable|open_pic
r_struct
id|hw_interrupt_type
id|open_pic
op_assign
(brace
l_string|&quot; OpenPIC  &quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|openpic_enable_irq
comma
id|openpic_disable_irq
comma
l_int|NULL
comma
id|openpic_end_irq
comma
id|openpic_set_affinity
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|openpic_end_ipi
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_void
id|openpic_enable_ipi
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_void
id|openpic_disable_ipi
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
DECL|variable|open_pic_ipi
r_struct
id|hw_interrupt_type
id|open_pic_ipi
op_assign
(brace
l_string|&quot; OpenPIC  &quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|openpic_enable_ipi
comma
id|openpic_disable_ipi
comma
l_int|NULL
comma
id|openpic_end_ipi
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
DECL|variable|openpic_vec_ipi
r_int
r_int
id|openpic_vec_ipi
suffix:semicolon
DECL|variable|openpic_vec_timer
r_int
r_int
id|openpic_vec_timer
suffix:semicolon
DECL|variable|openpic_vec_spurious
r_int
r_int
id|openpic_vec_spurious
suffix:semicolon
multiline_comment|/*&n; *  Accesses to the current processor&squot;s openpic registers&n; */
macro_line|#ifdef CONFIG_SMP
DECL|macro|THIS_CPU
mdefine_line|#define THIS_CPU&t;&t;Processor[cpu]
DECL|macro|DECL_THIS_CPU
mdefine_line|#define DECL_THIS_CPU&t;&t;int cpu = hard_smp_processor_id()
DECL|macro|CHECK_THIS_CPU
mdefine_line|#define CHECK_THIS_CPU&t;&t;check_arg_cpu(cpu)
macro_line|#else
DECL|macro|THIS_CPU
mdefine_line|#define THIS_CPU&t;&t;Processor[hard_smp_processor_id()]
DECL|macro|DECL_THIS_CPU
mdefine_line|#define DECL_THIS_CPU
DECL|macro|CHECK_THIS_CPU
mdefine_line|#define CHECK_THIS_CPU
macro_line|#endif /* CONFIG_SMP */
macro_line|#if 0
mdefine_line|#define check_arg_ipi(ipi) &bslash;&n;    if (ipi &lt; 0 || ipi &gt;= OPENPIC_NUM_IPI) &bslash;&n;&t;printk(KERN_ERR &quot;open_pic.c:%d: illegal ipi %d&bslash;n&quot;, __LINE__, ipi);
mdefine_line|#define check_arg_timer(timer) &bslash;&n;    if (timer &lt; 0 || timer &gt;= OPENPIC_NUM_TIMERS) &bslash;&n;&t;printk(KERN_ERR &quot;open_pic.c:%d: illegal timer %d&bslash;n&quot;, __LINE__, timer);
mdefine_line|#define check_arg_vec(vec) &bslash;&n;    if (vec &lt; 0 || vec &gt;= OPENPIC_NUM_VECTORS) &bslash;&n;&t;printk(KERN_ERR &quot;open_pic.c:%d: illegal vector %d&bslash;n&quot;, __LINE__, vec);
mdefine_line|#define check_arg_pri(pri) &bslash;&n;    if (pri &lt; 0 || pri &gt;= OPENPIC_NUM_PRI) &bslash;&n;&t;printk(KERN_ERR &quot;open_pic.c:%d: illegal priority %d&bslash;n&quot;, __LINE__, pri);
multiline_comment|/*&n; * Print out a backtrace if it&squot;s out of range, since if it&squot;s larger than NR_IRQ&squot;s&n; * data has probably been corrupted and we&squot;re going to panic or deadlock later&n; * anyway --Troy&n; */
r_extern
r_int
r_int
op_star
id|_get_SP
c_func
(paren
r_void
)paren
suffix:semicolon
mdefine_line|#define check_arg_irq(irq) &bslash;&n;    if (irq &lt; open_pic_irq_offset || irq &gt;= (NumSources+open_pic_irq_offset)){ &bslash;&n;      printk(KERN_ERR &quot;open_pic.c:%d: illegal irq %d&bslash;n&quot;, __LINE__, irq); &bslash;&n;      print_backtrace(_get_SP()); }
mdefine_line|#define check_arg_cpu(cpu) &bslash;&n;    if (cpu &lt; 0 || cpu &gt;= OPENPIC_MAX_PROCESSORS){ &bslash;&n;&t;printk(KERN_ERR &quot;open_pic.c:%d: illegal cpu %d&bslash;n&quot;, __LINE__, cpu); &bslash;&n;&t;print_backtrace(_get_SP()); }
macro_line|#else
DECL|macro|check_arg_ipi
mdefine_line|#define check_arg_ipi(ipi)&t;do {} while (0)
DECL|macro|check_arg_timer
mdefine_line|#define check_arg_timer(timer)&t;do {} while (0)
DECL|macro|check_arg_vec
mdefine_line|#define check_arg_vec(vec)&t;do {} while (0)
DECL|macro|check_arg_pri
mdefine_line|#define check_arg_pri(pri)&t;do {} while (0)
DECL|macro|check_arg_irq
mdefine_line|#define check_arg_irq(irq)&t;do {} while (0)
DECL|macro|check_arg_cpu
mdefine_line|#define check_arg_cpu(cpu)&t;do {} while (0)
macro_line|#endif
DECL|macro|GET_ISU
mdefine_line|#define GET_ISU(source)&t;ISU[(source) &gt;&gt; 4][(source) &amp; 0xf]
DECL|function|openpic_init_IRQ
r_void
id|__init
id|openpic_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|addrp
suffix:semicolon
r_int
r_char
op_star
id|chrp_int_ack_special
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|init_senses
(braket
id|NR_IRQS
op_minus
id|NUM_8259_INTERRUPTS
)braket
suffix:semicolon
r_int
id|nmi_irq
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#if defined(CONFIG_VT) &amp;&amp; defined(CONFIG_ADB_KEYBOARD) &amp;&amp; defined(XMON)
r_struct
id|device_node
op_star
id|kbd
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|np
op_assign
id|find_devices
c_func
(paren
l_string|&quot;pci&quot;
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|addrp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;8259-interrupt-acknowledge&quot;
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Cannot find pci to get ack address&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|chrp_int_ack_special
op_assign
(paren
r_int
r_char
op_star
)paren
id|__ioremap
c_func
(paren
id|addrp
(braket
id|prom_n_addr_cells
c_func
(paren
id|np
)paren
op_minus
l_int|1
)braket
comma
l_int|1
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
multiline_comment|/* hydra still sets OpenPIC_InitSenses to a static set of values */
r_if
c_cond
(paren
id|OpenPIC_InitSenses
op_eq
l_int|NULL
)paren
(brace
id|prom_get_irq_senses
c_func
(paren
id|init_senses
comma
id|NUM_8259_INTERRUPTS
comma
id|NR_IRQS
)paren
suffix:semicolon
id|OpenPIC_InitSenses
op_assign
id|init_senses
suffix:semicolon
id|OpenPIC_NumInitSenses
op_assign
id|NR_IRQS
op_minus
id|NUM_8259_INTERRUPTS
suffix:semicolon
)brace
id|openpic_init
c_func
(paren
l_int|1
comma
id|NUM_8259_INTERRUPTS
comma
id|chrp_int_ack_special
comma
id|nmi_irq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_8259_INTERRUPTS
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|i8259_pic
suffix:semicolon
id|i8259_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_read
r_static
r_inline
id|u_int
id|openpic_read
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
)paren
(brace
id|u_int
id|val
suffix:semicolon
id|val
op_assign
id|in_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|openpic_write
r_static
r_inline
r_void
id|openpic_write
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|val
)paren
(brace
id|out_le32
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|openpic_readfield
r_static
r_inline
id|u_int
id|openpic_readfield
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
)paren
(brace
id|u_int
id|val
op_assign
id|openpic_read
c_func
(paren
id|addr
)paren
suffix:semicolon
r_return
id|val
op_amp
id|mask
suffix:semicolon
)brace
DECL|function|openpic_writefield
r_static
r_inline
r_void
id|openpic_writefield
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
comma
id|u_int
id|field
)paren
(brace
id|u_int
id|val
op_assign
id|openpic_read
c_func
(paren
id|addr
)paren
suffix:semicolon
id|openpic_write
c_func
(paren
id|addr
comma
(paren
id|val
op_amp
op_complement
id|mask
)paren
op_or
(paren
id|field
op_amp
id|mask
)paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_clearfield
r_static
r_inline
r_void
id|openpic_clearfield
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
)paren
(brace
id|openpic_writefield
c_func
(paren
id|addr
comma
id|mask
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|openpic_setfield
r_static
r_inline
r_void
id|openpic_setfield
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
)paren
(brace
id|openpic_writefield
c_func
(paren
id|addr
comma
id|mask
comma
id|mask
)paren
suffix:semicolon
)brace
DECL|function|openpic_safe_writefield
r_static
r_void
id|openpic_safe_writefield
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
comma
id|u_int
id|field
)paren
(brace
r_int
r_int
id|loops
op_assign
l_int|100000
suffix:semicolon
id|openpic_setfield
c_func
(paren
id|addr
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|openpic_read
c_func
(paren
id|addr
)paren
op_amp
id|OPENPIC_ACTIVITY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|loops
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;openpic_safe_writefield timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|openpic_writefield
c_func
(paren
id|addr
comma
id|mask
op_or
id|OPENPIC_MASK
comma
id|field
op_or
id|OPENPIC_MASK
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|openpic_read_IPI
r_static
id|u_int
id|openpic_read_IPI
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
)paren
(brace
id|u_int
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|broken_ipi_registers
)paren
multiline_comment|/* yes this is right ... bug, feature, you decide! -- tgall */
id|val
op_assign
id|in_be32
c_func
(paren
id|addr
)paren
suffix:semicolon
r_else
id|val
op_assign
id|in_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|openpic_test_broken_IPI
r_static
r_void
id|openpic_test_broken_IPI
c_func
(paren
r_void
)paren
(brace
id|u_int
id|t
suffix:semicolon
id|openpic_write
c_func
(paren
op_amp
id|OpenPIC-&gt;Global
dot
id|IPI_Vector_Priority
c_func
(paren
l_int|0
)paren
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
id|t
op_assign
id|openpic_read
c_func
(paren
op_amp
id|OpenPIC-&gt;Global
dot
id|IPI_Vector_Priority
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
id|le32_to_cpu
c_func
(paren
id|OPENPIC_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;OpenPIC reversed IPI registers detected&bslash;n&quot;
)paren
suffix:semicolon
id|broken_ipi_registers
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* because of the power3 be / le above, this is needed */
DECL|function|openpic_writefield_IPI
r_static
r_inline
r_void
id|openpic_writefield_IPI
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
comma
id|u_int
id|field
)paren
(brace
id|u_int
id|val
op_assign
id|openpic_read_IPI
c_func
(paren
id|addr
)paren
suffix:semicolon
id|openpic_write
c_func
(paren
id|addr
comma
(paren
id|val
op_amp
op_complement
id|mask
)paren
op_or
(paren
id|field
op_amp
id|mask
)paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_clearfield_IPI
r_static
r_inline
r_void
id|openpic_clearfield_IPI
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
)paren
(brace
id|openpic_writefield_IPI
c_func
(paren
id|addr
comma
id|mask
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|openpic_setfield_IPI
r_static
r_inline
r_void
id|openpic_setfield_IPI
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
)paren
(brace
id|openpic_writefield_IPI
c_func
(paren
id|addr
comma
id|mask
comma
id|mask
)paren
suffix:semicolon
)brace
DECL|function|openpic_safe_writefield_IPI
r_static
r_void
id|openpic_safe_writefield_IPI
c_func
(paren
r_volatile
id|u_int
op_star
id|addr
comma
id|u_int
id|mask
comma
id|u_int
id|field
)paren
(brace
r_int
r_int
id|loops
op_assign
l_int|100000
suffix:semicolon
id|openpic_setfield_IPI
c_func
(paren
id|addr
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
multiline_comment|/* wait until it&squot;s not in use */
multiline_comment|/* BenH: Is this code really enough ? I would rather check the result&n;         *       and eventually retry ...&n;         */
r_while
c_loop
(paren
id|openpic_read_IPI
c_func
(paren
id|addr
)paren
op_amp
id|OPENPIC_ACTIVITY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|loops
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;openpic_safe_writefield timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|openpic_writefield_IPI
c_func
(paren
id|addr
comma
id|mask
comma
id|field
op_or
id|OPENPIC_MASK
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|function|openpic_init
r_void
id|__init
id|openpic_init
c_func
(paren
r_int
id|main_pic
comma
r_int
id|offset
comma
r_int
r_char
op_star
id|chrp_ack
comma
r_int
id|programmer_switch_irq
)paren
(brace
id|u_int
id|t
comma
id|i
suffix:semicolon
id|u_int
id|timerfreq
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OpenPIC_Addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;No OpenPIC found !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|OpenPIC
op_assign
(paren
r_volatile
r_struct
id|OpenPIC
op_star
)paren
id|OpenPIC_Addr
suffix:semicolon
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic enter&quot;
comma
l_int|0x122
)paren
suffix:semicolon
id|t
op_assign
id|openpic_read
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Feature_Reporting0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|t
op_amp
id|OPENPIC_FEATURE_VERSION_MASK
)paren
(brace
r_case
l_int|1
suffix:colon
id|version
op_assign
l_string|&quot;1.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|version
op_assign
l_string|&quot;1.2&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|version
op_assign
l_string|&quot;1.3&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|version
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|NumProcessors
op_assign
(paren
(paren
id|t
op_amp
id|OPENPIC_FEATURE_LAST_PROCESSOR_MASK
)paren
op_rshift
id|OPENPIC_FEATURE_LAST_PROCESSOR_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|NumSources
op_assign
(paren
(paren
id|t
op_amp
id|OPENPIC_FEATURE_LAST_SOURCE_MASK
)paren
op_rshift
id|OPENPIC_FEATURE_LAST_SOURCE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;OpenPIC Version %s (%d CPUs and %d IRQ sources) at %p&bslash;n&quot;
comma
id|version
comma
id|NumProcessors
comma
id|NumSources
comma
id|OpenPIC
)paren
suffix:semicolon
id|timerfreq
op_assign
id|openpic_read
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Timer_Frequency
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timerfreq
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;OpenPIC timer frequency is %d.%06d MHz&bslash;n&quot;
comma
id|timerfreq
op_div
l_int|1000000
comma
id|timerfreq
op_mod
l_int|1000000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|main_pic
)paren
r_return
suffix:semicolon
id|open_pic_irq_offset
op_assign
id|offset
suffix:semicolon
id|chrp_int_ack_special
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|chrp_ack
suffix:semicolon
id|find_ISUs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize timer interrupts */
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic timer&quot;
comma
l_int|0x3ba
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPENPIC_NUM_TIMERS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Disabled, Priority 0 */
id|openpic_inittimer
c_func
(paren
id|i
comma
l_int|0
comma
id|openpic_vec_timer
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* No processor */
id|openpic_maptimer
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Initialize IPI interrupts */
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic ipi&quot;
comma
l_int|0x3bb
)paren
suffix:semicolon
id|openpic_test_broken_IPI
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPENPIC_NUM_IPI
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Disabled, Priority 10..13 */
id|openpic_initipi
c_func
(paren
id|i
comma
l_int|10
op_plus
id|i
comma
id|openpic_vec_ipi
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* IPIs are per-CPU */
id|irq_desc
(braket
id|openpic_vec_ipi
op_plus
id|i
)braket
dot
id|status
op_or_assign
id|IRQ_PER_CPU
suffix:semicolon
id|irq_desc
(braket
id|openpic_vec_ipi
op_plus
id|i
)braket
dot
id|handler
op_assign
op_amp
id|open_pic_ipi
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize external interrupts */
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic ext&quot;
comma
l_int|0x3bc
)paren
suffix:semicolon
id|openpic_set_priority
c_func
(paren
l_int|0xf
)paren
suffix:semicolon
multiline_comment|/* SIOint (8259 cascade) is special */
r_if
c_cond
(paren
id|offset
)paren
(brace
id|openpic_initirq
c_func
(paren
l_int|0
comma
l_int|8
comma
id|offset
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|openpic_mapirq
c_func
(paren
l_int|0
comma
l_int|1
op_lshift
id|get_hard_smp_processor_id
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Init all external sources */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NumSources
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|pri
comma
id|sense
suffix:semicolon
multiline_comment|/* the bootloader may have left it enabled (bad !) */
id|openpic_disable_irq
c_func
(paren
id|i
op_plus
id|offset
)paren
suffix:semicolon
id|pri
op_assign
(paren
id|i
op_eq
id|programmer_switch_irq
)paren
ques
c_cond
l_int|9
suffix:colon
l_int|8
suffix:semicolon
id|sense
op_assign
(paren
id|i
OL
id|OpenPIC_NumInitSenses
)paren
ques
c_cond
id|OpenPIC_InitSenses
(braket
id|i
)braket
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sense
)paren
id|irq_desc
(braket
id|i
op_plus
id|offset
)braket
dot
id|status
op_assign
id|IRQ_LEVEL
suffix:semicolon
multiline_comment|/* Enabled, Priority 8 or 9 */
id|openpic_initirq
c_func
(paren
id|i
comma
id|pri
comma
id|i
op_plus
id|offset
comma
op_logical_neg
id|sense
comma
id|sense
)paren
suffix:semicolon
multiline_comment|/* Processor 0 */
id|openpic_mapirq
c_func
(paren
id|i
comma
l_int|1
op_lshift
id|get_hard_smp_processor_id
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Init descriptors */
r_for
c_loop
(paren
id|i
op_assign
id|offset
suffix:semicolon
id|i
OL
id|NumSources
op_plus
id|offset
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|open_pic
suffix:semicolon
multiline_comment|/* Initialize the spurious interrupt */
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic spurious&quot;
comma
l_int|0x3bd
)paren
suffix:semicolon
id|openpic_set_spurious
c_func
(paren
id|openpic_vec_spurious
)paren
suffix:semicolon
multiline_comment|/* Initialize the cascade */
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|offset
comma
id|no_action
comma
id|SA_INTERRUPT
comma
l_string|&quot;82c59 cascade&quot;
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get OpenPIC IRQ 0 for cascade&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|openpic_set_priority
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|openpic_disable_8259_pass_through
c_func
(paren
)paren
suffix:semicolon
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;openpic exit&quot;
comma
l_int|0x222
)paren
suffix:semicolon
)brace
DECL|function|openpic_setup_ISU
r_void
id|openpic_setup_ISU
c_func
(paren
r_int
id|isu_num
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|isu_num
op_ge
id|OPENPIC_MAX_ISU
)paren
r_return
suffix:semicolon
id|ISU
(braket
id|isu_num
)braket
op_assign
(paren
id|OpenPIC_SourcePtr
)paren
id|__ioremap
c_func
(paren
id|addr
comma
l_int|0x400
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isu_num
op_ge
id|NumISUs
)paren
id|NumISUs
op_assign
id|isu_num
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|find_ISUs
r_void
id|find_ISUs
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Use /interrupt-controller/reg and&n;         * /interrupt-controller/interrupt-ranges from OF device tree&n;&t; * the ISU array is setup in chrp_pci.c in ibm_add_bridges&n;&t; * as a result&n;&t; * -- tgall&n;         */
multiline_comment|/* basically each ISU is a bus, and this assumes that&n;&t; * open_pic_isu_count interrupts per bus are possible &n;&t; * ISU == Interrupt Source&n;&t; */
id|NumSources
op_assign
id|NumISUs
op_star
l_int|0x10
suffix:semicolon
id|openpic_vec_ipi
op_assign
id|NumSources
op_plus
id|open_pic_irq_offset
suffix:semicolon
id|openpic_vec_timer
op_assign
id|openpic_vec_ipi
op_plus
id|OPENPIC_NUM_IPI
suffix:semicolon
id|openpic_vec_spurious
op_assign
id|openpic_vec_timer
op_plus
id|OPENPIC_NUM_TIMERS
suffix:semicolon
)brace
DECL|function|openpic_reset
r_static
r_inline
r_void
id|openpic_reset
c_func
(paren
r_void
)paren
(brace
id|openpic_setfield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Global_Configuration0
comma
id|OPENPIC_CONFIG_RESET
)paren
suffix:semicolon
)brace
DECL|function|openpic_enable_8259_pass_through
r_static
r_inline
r_void
id|openpic_enable_8259_pass_through
c_func
(paren
r_void
)paren
(brace
id|openpic_clearfield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Global_Configuration0
comma
id|OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE
)paren
suffix:semicolon
)brace
DECL|function|openpic_disable_8259_pass_through
r_static
r_void
id|openpic_disable_8259_pass_through
c_func
(paren
r_void
)paren
(brace
id|openpic_setfield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Global_Configuration0
comma
id|OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Find out the current interrupt&n; */
DECL|function|openpic_irq
r_static
id|u_int
id|openpic_irq
c_func
(paren
r_void
)paren
(brace
id|u_int
id|vec
suffix:semicolon
id|DECL_THIS_CPU
suffix:semicolon
id|CHECK_THIS_CPU
suffix:semicolon
id|vec
op_assign
id|openpic_readfield
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU.Interrupt_Acknowledge
comma
id|OPENPIC_VECTOR_MASK
)paren
suffix:semicolon
r_return
id|vec
suffix:semicolon
)brace
DECL|function|openpic_eoi
r_static
r_void
id|openpic_eoi
c_func
(paren
r_void
)paren
(brace
id|DECL_THIS_CPU
suffix:semicolon
id|CHECK_THIS_CPU
suffix:semicolon
id|openpic_write
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU.EOI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Handle PCI write posting */
(paren
r_void
)paren
id|openpic_read
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU.EOI
)paren
suffix:semicolon
)brace
DECL|function|openpic_get_priority
r_static
r_inline
id|u_int
id|openpic_get_priority
c_func
(paren
r_void
)paren
(brace
id|DECL_THIS_CPU
suffix:semicolon
id|CHECK_THIS_CPU
suffix:semicolon
r_return
id|openpic_readfield
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU.Current_Task_Priority
comma
id|OPENPIC_CURRENT_TASK_PRIORITY_MASK
)paren
suffix:semicolon
)brace
DECL|function|openpic_set_priority
r_static
r_void
id|openpic_set_priority
c_func
(paren
id|u_int
id|pri
)paren
(brace
id|DECL_THIS_CPU
suffix:semicolon
id|CHECK_THIS_CPU
suffix:semicolon
id|check_arg_pri
c_func
(paren
id|pri
)paren
suffix:semicolon
id|openpic_writefield
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU.Current_Task_Priority
comma
id|OPENPIC_CURRENT_TASK_PRIORITY_MASK
comma
id|pri
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get/set the spurious vector&n; */
DECL|function|openpic_get_spurious
r_static
r_inline
id|u_int
id|openpic_get_spurious
c_func
(paren
r_void
)paren
(brace
r_return
id|openpic_readfield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Spurious_Vector
comma
id|OPENPIC_VECTOR_MASK
)paren
suffix:semicolon
)brace
DECL|function|openpic_set_spurious
r_static
r_void
id|openpic_set_spurious
c_func
(paren
id|u_int
id|vec
)paren
(brace
id|check_arg_vec
c_func
(paren
id|vec
)paren
suffix:semicolon
id|openpic_writefield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Spurious_Vector
comma
id|OPENPIC_VECTOR_MASK
comma
id|vec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a cpu mask from logical to physical cpu numbers.&n; */
DECL|function|physmask
r_static
r_inline
id|u32
id|physmask
c_func
(paren
id|u32
id|cpumask
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
op_increment
id|i
comma
id|cpumask
op_rshift_assign
l_int|1
)paren
id|mask
op_or_assign
(paren
id|cpumask
op_amp
l_int|1
)paren
op_lshift
id|get_hard_smp_processor_id
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|openpic_init_processor
r_void
id|openpic_init_processor
c_func
(paren
id|u_int
id|cpumask
)paren
(brace
id|openpic_write
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Processor_Initialization
comma
id|physmask
c_func
(paren
id|cpumask
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; *  Initialize an interprocessor interrupt (and disable it)&n; *&n; *  ipi: OpenPIC interprocessor interrupt number&n; *  pri: interrupt source priority&n; *  vec: the vector it will produce&n; */
DECL|function|openpic_initipi
r_static
r_void
id|__init
id|openpic_initipi
c_func
(paren
id|u_int
id|ipi
comma
id|u_int
id|pri
comma
id|u_int
id|vec
)paren
(brace
id|check_arg_ipi
c_func
(paren
id|ipi
)paren
suffix:semicolon
id|check_arg_pri
c_func
(paren
id|pri
)paren
suffix:semicolon
id|check_arg_vec
c_func
(paren
id|vec
)paren
suffix:semicolon
id|openpic_safe_writefield_IPI
c_func
(paren
op_amp
id|OpenPIC-&gt;Global
dot
id|IPI_Vector_Priority
c_func
(paren
id|ipi
)paren
comma
id|OPENPIC_PRIORITY_MASK
op_or
id|OPENPIC_VECTOR_MASK
comma
(paren
id|pri
op_lshift
id|OPENPIC_PRIORITY_SHIFT
)paren
op_or
id|vec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send an IPI to one or more CPUs&n; *  &n; *  Externally called, however, it takes an IPI number (0...OPENPIC_NUM_IPI)&n; *  and not a system-wide interrupt number&n; */
DECL|function|openpic_cause_IPI
r_void
id|openpic_cause_IPI
c_func
(paren
id|u_int
id|ipi
comma
id|u_int
id|cpumask
)paren
(brace
id|DECL_THIS_CPU
suffix:semicolon
id|CHECK_THIS_CPU
suffix:semicolon
id|check_arg_ipi
c_func
(paren
id|ipi
)paren
suffix:semicolon
id|openpic_write
c_func
(paren
op_amp
id|OpenPIC-&gt;THIS_CPU
dot
id|IPI_Dispatch
c_func
(paren
id|ipi
)paren
comma
id|physmask
c_func
(paren
id|cpumask
)paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_request_IPIs
r_void
id|openpic_request_IPIs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure this matches what is defined in smp.c for &n;&t; * smp_message_{pass|recv}() or what shows up in &n;&t; * /proc/interrupts will be wrong!!! --Troy */
r_if
c_cond
(paren
id|OpenPIC
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|request_irq
c_func
(paren
id|openpic_vec_ipi
comma
id|openpic_ipi_action
comma
l_int|0
comma
l_string|&quot;IPI0 (call function)&quot;
comma
l_int|0
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|openpic_vec_ipi
op_plus
l_int|1
comma
id|openpic_ipi_action
comma
l_int|0
comma
l_string|&quot;IPI1 (reschedule)&quot;
comma
l_int|0
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|openpic_vec_ipi
op_plus
l_int|2
comma
id|openpic_ipi_action
comma
l_int|0
comma
l_string|&quot;IPI2 (invalidate tlb)&quot;
comma
l_int|0
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|openpic_vec_ipi
op_plus
l_int|3
comma
id|openpic_ipi_action
comma
l_int|0
comma
l_string|&quot;IPI3 (xmon break)&quot;
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPENPIC_NUM_IPI
suffix:semicolon
id|i
op_increment
)paren
id|openpic_enable_ipi
c_func
(paren
id|openpic_vec_ipi
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do per-cpu setup for SMP systems.&n; *&n; * Get IPI&squot;s working and start taking interrupts.&n; *   -- Cort&n; */
DECL|variable|__initdata
r_static
id|spinlock_t
id|openpic_setup_lock
id|__initdata
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|do_openpic_setup_cpu
r_void
id|__init
id|do_openpic_setup_cpu
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_IRQ_ALL_CPUS
r_int
id|i
suffix:semicolon
id|u32
id|msk
op_assign
l_int|1
op_lshift
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|openpic_setup_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRQ_ALL_CPUS
multiline_comment|/* let the openpic know we want intrs. default affinity&n; &t; * is 0xffffffff until changed via /proc&n; &t; * That&squot;s how it&squot;s done on x86. If we want it differently, then&n; &t; * we should make sure we also change the default values of irq_affinity&n; &t; * in irq.c.&n; &t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NumSources
suffix:semicolon
id|i
op_increment
)paren
id|openpic_mapirq
c_func
(paren
id|i
comma
id|openpic_read
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|i
)paren
dot
id|Destination
)paren
op_or
id|msk
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IRQ_ALL_CPUS */
id|openpic_set_priority
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|openpic_setup_lock
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; *  Initialize a timer interrupt (and disable it)&n; *&n; *  timer: OpenPIC timer number&n; *  pri: interrupt source priority&n; *  vec: the vector it will produce&n; */
DECL|function|openpic_inittimer
r_static
r_void
id|__init
id|openpic_inittimer
c_func
(paren
id|u_int
id|timer
comma
id|u_int
id|pri
comma
id|u_int
id|vec
)paren
(brace
id|check_arg_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|check_arg_pri
c_func
(paren
id|pri
)paren
suffix:semicolon
id|check_arg_vec
c_func
(paren
id|vec
)paren
suffix:semicolon
id|openpic_safe_writefield
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Timer
(braket
id|timer
)braket
dot
id|Vector_Priority
comma
id|OPENPIC_PRIORITY_MASK
op_or
id|OPENPIC_VECTOR_MASK
comma
(paren
id|pri
op_lshift
id|OPENPIC_PRIORITY_SHIFT
)paren
op_or
id|vec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Map a timer interrupt to one or more CPUs&n; */
DECL|function|openpic_maptimer
r_static
r_void
id|__init
id|openpic_maptimer
c_func
(paren
id|u_int
id|timer
comma
id|u_int
id|cpumask
)paren
(brace
id|check_arg_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|openpic_write
c_func
(paren
op_amp
id|OpenPIC-&gt;Global.Timer
(braket
id|timer
)braket
dot
id|Destination
comma
id|physmask
c_func
(paren
id|cpumask
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * All functions below take an offset&squot;ed irq argument&n; *&n; */
multiline_comment|/*&n; *  Enable/disable an external interrupt source&n; *&n; *  Externally called, irq is an offseted system-wide interrupt number&n; */
DECL|function|openpic_enable_irq
r_static
r_void
id|openpic_enable_irq
c_func
(paren
id|u_int
id|irq
)paren
(brace
r_int
r_int
id|loops
op_assign
l_int|100000
suffix:semicolon
id|check_arg_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|openpic_clearfield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
op_minus
id|open_pic_irq_offset
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
multiline_comment|/* make sure mask gets to controller before we return to user */
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|loops
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;openpic_enable_irq timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sync is probably useless here */
)brace
r_while
c_loop
(paren
id|openpic_readfield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
op_minus
id|open_pic_irq_offset
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_MASK
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|openpic_disable_irq
r_static
r_void
id|openpic_disable_irq
c_func
(paren
id|u_int
id|irq
)paren
(brace
id|u32
id|vp
suffix:semicolon
r_int
r_int
id|loops
op_assign
l_int|100000
suffix:semicolon
id|check_arg_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|openpic_setfield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
op_minus
id|open_pic_irq_offset
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
multiline_comment|/* make sure mask gets to controller before we return to user */
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|loops
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;openpic_disable_irq timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sync is probably useless here */
id|vp
op_assign
id|openpic_readfield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
op_minus
id|open_pic_irq_offset
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_MASK
op_or
id|OPENPIC_ACTIVITY
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|vp
op_amp
id|OPENPIC_ACTIVITY
)paren
op_logical_and
op_logical_neg
(paren
id|vp
op_amp
id|OPENPIC_MASK
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; *  Enable/disable an IPI interrupt source&n; *  &n; *  Externally called, irq is an offseted system-wide interrupt number&n; */
DECL|function|openpic_enable_ipi
r_void
id|openpic_enable_ipi
c_func
(paren
id|u_int
id|irq
)paren
(brace
id|irq
op_sub_assign
id|openpic_vec_ipi
suffix:semicolon
id|check_arg_ipi
c_func
(paren
id|irq
)paren
suffix:semicolon
id|openpic_clearfield_IPI
c_func
(paren
op_amp
id|OpenPIC-&gt;Global
dot
id|IPI_Vector_Priority
c_func
(paren
id|irq
)paren
comma
id|OPENPIC_MASK
)paren
suffix:semicolon
)brace
DECL|function|openpic_disable_ipi
r_void
id|openpic_disable_ipi
c_func
(paren
id|u_int
id|irq
)paren
(brace
multiline_comment|/* NEVER disable an IPI... that&squot;s just plain wrong! */
)brace
macro_line|#endif
multiline_comment|/*&n; *  Initialize an interrupt source (and disable it!)&n; *&n; *  irq: OpenPIC interrupt number&n; *  pri: interrupt source priority&n; *  vec: the vector it will produce&n; *  pol: polarity (1 for positive, 0 for negative)&n; *  sense: 1 for level, 0 for edge&n; */
DECL|function|openpic_initirq
r_static
r_void
id|openpic_initirq
c_func
(paren
id|u_int
id|irq
comma
id|u_int
id|pri
comma
id|u_int
id|vec
comma
r_int
id|pol
comma
r_int
id|sense
)paren
(brace
id|openpic_safe_writefield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_PRIORITY_MASK
op_or
id|OPENPIC_VECTOR_MASK
op_or
id|OPENPIC_SENSE_MASK
op_or
id|OPENPIC_POLARITY_MASK
comma
(paren
id|pri
op_lshift
id|OPENPIC_PRIORITY_SHIFT
)paren
op_or
id|vec
op_or
(paren
id|pol
ques
c_cond
id|OPENPIC_POLARITY_POSITIVE
suffix:colon
id|OPENPIC_POLARITY_NEGATIVE
)paren
op_or
(paren
id|sense
ques
c_cond
id|OPENPIC_SENSE_LEVEL
suffix:colon
id|OPENPIC_SENSE_EDGE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Map an interrupt source to one or more CPUs&n; */
DECL|function|openpic_mapirq
r_static
r_void
id|openpic_mapirq
c_func
(paren
id|u_int
id|irq
comma
id|u_int
id|physmask
)paren
(brace
id|openpic_write
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
)paren
dot
id|Destination
comma
id|physmask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Set the sense for an interrupt source (and disable it!)&n; *&n; *  sense: 1 for level, 0 for edge&n; */
DECL|function|openpic_set_sense
r_static
r_inline
r_void
id|openpic_set_sense
c_func
(paren
id|u_int
id|irq
comma
r_int
id|sense
)paren
(brace
id|openpic_safe_writefield
c_func
(paren
op_amp
id|GET_ISU
c_func
(paren
id|irq
)paren
dot
id|Vector_Priority
comma
id|OPENPIC_SENSE_LEVEL
comma
(paren
id|sense
ques
c_cond
id|OPENPIC_SENSE_LEVEL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_end_irq
r_static
r_void
id|openpic_end_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_desc
(braket
id|irq_nr
)braket
dot
id|status
op_amp
id|IRQ_LEVEL
)paren
op_ne
l_int|0
)paren
id|openpic_eoi
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_set_affinity
r_static
r_void
id|openpic_set_affinity
c_func
(paren
r_int
r_int
id|irq_nr
comma
r_int
r_int
id|cpumask
)paren
(brace
id|openpic_mapirq
c_func
(paren
id|irq_nr
op_minus
id|open_pic_irq_offset
comma
id|physmask
c_func
(paren
id|cpumask
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|openpic_end_ipi
r_static
r_void
id|openpic_end_ipi
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
multiline_comment|/* IPIs are marked IRQ_PER_CPU. This has the side effect of&n;&t; * preventing the IRQ_PENDING/IRQ_INPROGRESS logic from&n;&t; * applying to them. We EOI them late to avoid re-entering.&n;&t; * however, I&squot;m wondering if we could simply let them have the&n;&t; * SA_INTERRUPT flag and let them execute with all interrupts OFF.&n;&t; * This would have the side effect of either running cross-CPU&n;&t; * functions with interrupts off, or we can re-enable them explicitely&n;&t; * with a __sti() in smp_call_function_interrupt(), since&n;&t; * smp_call_function() is protected by a spinlock.&n;&t; * Or maybe we shouldn&squot;t set the IRQ_PER_CPU flag on cross-CPU&n;&t; * function calls IPI at all but that would make a special case.&n;&t; */
id|openpic_eoi
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|openpic_ipi_action
r_static
r_void
id|openpic_ipi_action
c_func
(paren
r_int
id|cpl
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|smp_message_recv
c_func
(paren
id|cpl
op_minus
id|openpic_vec_ipi
comma
id|regs
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|function|openpic_get_irq
r_int
id|openpic_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_extern
r_int
id|i8259_irq
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
r_int
id|irq
op_assign
id|openpic_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Management of the cascade should be moved out of here */
r_if
c_cond
(paren
id|open_pic_irq_offset
op_logical_and
id|irq
op_eq
id|open_pic_irq_offset
)paren
(brace
multiline_comment|/*&n;                 * This magic address generates a PCI IACK cycle.&n;                 */
r_if
c_cond
(paren
id|chrp_int_ack_special
)paren
id|irq
op_assign
op_star
id|chrp_int_ack_special
suffix:semicolon
r_else
id|irq
op_assign
id|i8259_irq
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|openpic_eoi
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_eq
id|openpic_vec_spurious
)paren
id|irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
eof
