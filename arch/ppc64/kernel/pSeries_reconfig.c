multiline_comment|/*&n; * pSeries_reconfig.c - support for dynamic reconfiguration (including PCI&n; * Hotplug and Dynamic Logical Partitioning on RPA platforms).&n; *&n; * Copyright (C) 2005 Nathan Lynch&n; * Copyright (C) 2005 IBM Corporation&n; *&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License version&n; *&t;2 as published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kref.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/pSeries_reconfig.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * Routines for &quot;runtime&quot; addition and removal of device tree nodes.&n; */
macro_line|#ifdef CONFIG_PROC_DEVICETREE
multiline_comment|/*&n; * Add a node to /proc/device-tree.&n; */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|proc_mkdir
c_func
(paren
id|strrchr
c_func
(paren
id|np-&gt;full_name
comma
l_char|&squot;/&squot;
)paren
op_plus
l_int|1
comma
id|np-&gt;parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
id|proc_device_tree_add_node
c_func
(paren
id|np
comma
id|ent
)paren
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
r_struct
id|device_node
op_star
id|parent
op_assign
id|np-&gt;parent
suffix:semicolon
r_while
c_loop
(paren
id|pp
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|pp-&gt;name
comma
id|np-&gt;pde
)paren
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Assuming that symlinks have the same parent directory as&n;&t; * np-&gt;pde.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;name_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;name_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;addr_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;addr_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;pde
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;pde-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PROC_DEVICETREE */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_DEVICETREE */
multiline_comment|/**&n; *&t;derive_parent - basically like dirname(1)&n; *&t;@path:  the full_name of a node to be added to the tree&n; *&n; *&t;Returns the node which should be the parent of the node&n; *&t;described by path.  E.g., for path = &quot;/foo/bar&quot;, returns&n; *&t;the node with full_name = &quot;/foo&quot;.&n; */
DECL|function|derive_parent
r_static
r_struct
id|device_node
op_star
id|derive_parent
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|parent_path
op_assign
l_string|&quot;/&quot;
suffix:semicolon
r_int
id|parent_path_len
op_assign
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_minus
id|path
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* reject if path is &quot;/&quot; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|path
comma
l_string|&quot;/&quot;
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_ne
id|path
)paren
(brace
id|parent_path
op_assign
id|kmalloc
c_func
(paren
id|parent_path_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent_path
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|parent_path
comma
id|path
comma
id|parent_path_len
)paren
suffix:semicolon
)brace
id|parent
op_assign
id|of_find_node_by_path
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|parent_path
comma
l_string|&quot;/&quot;
)paren
)paren
id|kfree
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_return
id|parent
suffix:semicolon
)brace
DECL|variable|pSeries_reconfig_chain
r_static
r_struct
id|notifier_block
op_star
id|pSeries_reconfig_chain
suffix:semicolon
DECL|function|pSeries_reconfig_notifier_register
r_int
id|pSeries_reconfig_notifier_register
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|pSeries_reconfig_chain
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|pSeries_reconfig_notifier_unregister
r_void
id|pSeries_reconfig_notifier_unregister
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
id|notifier_chain_unregister
c_func
(paren
op_amp
id|pSeries_reconfig_chain
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|pSeries_reconfig_add_node
r_static
r_int
id|pSeries_reconfig_add_node
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|property
op_star
id|proplist
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|np
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|out_err
suffix:semicolon
id|np-&gt;full_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;full_name
)paren
r_goto
id|out_err
suffix:semicolon
id|strcpy
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
suffix:semicolon
id|np-&gt;properties
op_assign
id|proplist
suffix:semicolon
id|OF_MARK_DYNAMIC
c_func
(paren
id|np
)paren
suffix:semicolon
id|kref_init
c_func
(paren
op_amp
id|np-&gt;kref
)paren
suffix:semicolon
id|np-&gt;parent
op_assign
id|derive_parent
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|np-&gt;parent
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|err
op_assign
id|notifier_call_chain
c_func
(paren
op_amp
id|pSeries_reconfig_chain
comma
id|PSERIES_RECONFIG_ADD
comma
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|NOTIFY_BAD
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to add device node %s&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* For now, safe to assume kmalloc failure */
r_goto
id|out_err
suffix:semicolon
)brace
id|of_attach_node
c_func
(paren
id|np
)paren
suffix:semicolon
id|add_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
r_if
c_cond
(paren
id|np
)paren
(brace
id|of_node_put
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|np-&gt;full_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare an OF node for removal from system&n; * XXX move this to pSeries_iommu.c&n; */
DECL|function|of_cleanup_node
r_static
r_void
id|of_cleanup_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;iommu_table
op_logical_and
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|NULL
)paren
)paren
id|iommu_free_table
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
DECL|function|pSeries_reconfig_remove_node
r_static
r_int
id|pSeries_reconfig_remove_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|parent
comma
op_star
id|child
suffix:semicolon
id|parent
op_assign
id|of_get_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|of_node_put
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|of_cleanup_node
c_func
(paren
id|np
)paren
suffix:semicolon
id|remove_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|pSeries_reconfig_chain
comma
id|PSERIES_RECONFIG_REMOVE
comma
id|np
)paren
suffix:semicolon
id|of_detach_node
c_func
(paren
id|np
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|parent
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* Must decrement the refcount */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * /proc/ppc64/ofdt - yucky binary interface for adding and removing&n; * OF device nodes.  Should be deprecated as soon as we get an&n; * in-kernel wrapper for the RTAS ibm,configure-connector call.&n; */
DECL|function|release_prop_list
r_static
r_void
id|release_prop_list
c_func
(paren
r_const
r_struct
id|property
op_star
id|prop
)paren
(brace
r_struct
id|property
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|prop
suffix:semicolon
id|prop
op_assign
id|next
)paren
(brace
id|next
op_assign
id|prop-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;value
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * parse_next_property - process the next property from raw input buffer&n; * @buf: input buffer, must be nul-terminated&n; * @end: end of the input buffer + 1, for validation&n; * @name: return value; set to property name in buf&n; * @length: return value; set to length of value&n; * @value: return value; set to the property value in buf&n; *&n; * Note that the caller must make copies of the name and value returned,&n; * this function does no allocation or copying of the data.  Return value&n; * is set to the next name in buf, or NULL on error.&n; */
DECL|function|parse_next_property
r_static
r_char
op_star
id|parse_next_property
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|end
comma
r_char
op_star
op_star
id|name
comma
r_int
op_star
id|length
comma
r_int
r_char
op_star
op_star
id|value
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
op_star
id|name
op_assign
id|buf
suffix:semicolon
id|tmp
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|tmp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|tmp
op_ge
id|end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* now we&squot;re on the length */
op_star
id|length
op_assign
op_minus
l_int|1
suffix:semicolon
op_star
id|length
op_assign
id|simple_strtoul
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|length
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|tmp
op_ne
l_char|&squot; &squot;
op_logical_or
op_increment
id|tmp
op_ge
id|end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* now we&squot;re on the value */
op_star
id|value
op_assign
id|tmp
suffix:semicolon
id|tmp
op_add_assign
op_star
id|length
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
id|end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
OL
id|end
op_logical_and
op_star
id|tmp
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|tmp
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;property parse failed in %s at line %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tmp
op_increment
suffix:semicolon
multiline_comment|/* and now we should be on the next name, or the end */
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|new_property
r_static
r_struct
id|property
op_star
id|new_property
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
id|length
comma
r_const
r_int
r_char
op_star
id|value
comma
r_struct
id|property
op_star
id|last
)paren
(brace
r_struct
id|property
op_star
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
r_new
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
op_star
r_new
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_member_access_from_pointer
id|name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_member_access_from_pointer
id|value
op_assign
id|kmalloc
c_func
(paren
id|length
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|strcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|name
)paren
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|value
comma
id|value
comma
id|length
)paren
suffix:semicolon
op_star
(paren
(paren
(paren
r_char
op_star
)paren
r_new
op_member_access_from_pointer
id|value
)paren
op_plus
id|length
)paren
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|length
op_assign
id|length
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
id|last
suffix:semicolon
r_return
r_new
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|name
)paren
id|kfree
c_func
(paren
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|value
)paren
id|kfree
c_func
(paren
r_new
op_member_access_from_pointer
id|value
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|do_add_node
r_static
r_int
id|do_add_node
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|bufsize
)paren
(brace
r_char
op_star
id|path
comma
op_star
id|end
comma
op_star
id|name
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|prop
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|value
suffix:semicolon
r_int
id|length
comma
id|rv
op_assign
l_int|0
suffix:semicolon
id|end
op_assign
id|buf
op_plus
id|bufsize
suffix:semicolon
id|path
op_assign
id|buf
suffix:semicolon
id|buf
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|buf
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np
op_assign
id|of_find_node_by_path
c_func
(paren
id|path
)paren
)paren
)paren
(brace
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* rv = build_prop_list(tmp, bufsize - (tmp - buf), &amp;proplist); */
r_while
c_loop
(paren
id|buf
OL
id|end
op_logical_and
(paren
id|buf
op_assign
id|parse_next_property
c_func
(paren
id|buf
comma
id|end
comma
op_amp
id|name
comma
op_amp
id|length
comma
op_amp
id|value
)paren
)paren
)paren
(brace
r_struct
id|property
op_star
id|last
op_assign
id|prop
suffix:semicolon
id|prop
op_assign
id|new_property
c_func
(paren
id|name
comma
id|length
comma
id|value
comma
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prop
)paren
(brace
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|prop
op_assign
id|last
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|rv
op_assign
id|pSeries_reconfig_add_node
c_func
(paren
id|path
comma
id|prop
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|rv
)paren
id|release_prop_list
c_func
(paren
id|prop
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|do_remove_node
r_static
r_int
id|do_remove_node
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_struct
id|device_node
op_star
id|node
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node
op_assign
id|of_find_node_by_path
c_func
(paren
id|buf
)paren
)paren
)paren
id|rv
op_assign
id|pSeries_reconfig_remove_node
c_func
(paren
id|node
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|node
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/**&n; * ofdt_write - perform operations on the Open Firmware device tree&n; *&n; * @file: not used&n; * @buf: command and arguments&n; * @count: size of the command buffer&n; * @off: not used&n; *&n; * Operations supported at this time are addition and removal of&n; * whole nodes along with their properties.  Operations on individual&n; * properties are not implemented (yet).&n; */
DECL|function|ofdt_write
r_static
id|ssize_t
id|ofdt_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|kbuf
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|count
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kbuf
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kbuf
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_assign
id|strchr
c_func
(paren
id|kbuf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|tmp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|kbuf
comma
l_string|&quot;add_node&quot;
)paren
)paren
id|rv
op_assign
id|do_add_node
c_func
(paren
id|tmp
comma
id|count
op_minus
(paren
id|tmp
op_minus
id|kbuf
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|kbuf
comma
l_string|&quot;remove_node&quot;
)paren
)paren
id|rv
op_assign
id|do_remove_node
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_else
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|kbuf
)paren
suffix:semicolon
r_return
id|rv
ques
c_cond
id|rv
suffix:colon
id|count
suffix:semicolon
)brace
DECL|variable|ofdt_fops
r_static
r_struct
id|file_operations
id|ofdt_fops
op_assign
(brace
dot
id|write
op_assign
id|ofdt_write
)brace
suffix:semicolon
multiline_comment|/* create /proc/ppc64/ofdt write-only by root */
DECL|function|proc_ppc64_create_ofdt
r_static
r_int
id|proc_ppc64_create_ofdt
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|systemcfg-&gt;platform
op_amp
id|PLATFORM_PSERIES
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ent
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;ppc64/ofdt&quot;
comma
id|S_IWUSR
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
(brace
id|ent-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|ent-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|ent-&gt;size
op_assign
l_int|0
suffix:semicolon
id|ent-&gt;proc_fops
op_assign
op_amp
id|ofdt_fops
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|proc_ppc64_create_ofdt
id|__initcall
c_func
(paren
id|proc_ppc64_create_ofdt
)paren
suffix:semicolon
eof
