multiline_comment|/*&n; * eeh.c&n; * Copyright (C) 2001 Dave Engebretsen &amp; Todd Inglett IBM Corporation&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &quot;pci.h&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|BUID_HI
mdefine_line|#define BUID_HI(buid) ((buid) &gt;&gt; 32)
DECL|macro|BUID_LO
mdefine_line|#define BUID_LO(buid) ((buid) &amp; 0xffffffff)
DECL|macro|CONFIG_ADDR
mdefine_line|#define CONFIG_ADDR(busno, devfn) &bslash;&n;&t;&t;(((((busno) &amp; 0xff) &lt;&lt; 8) | ((devfn) &amp; 0xf8)) &lt;&lt; 8)
multiline_comment|/* RTAS tokens */
DECL|variable|ibm_set_eeh_option
r_static
r_int
id|ibm_set_eeh_option
suffix:semicolon
DECL|variable|ibm_set_slot_reset
r_static
r_int
id|ibm_set_slot_reset
suffix:semicolon
DECL|variable|ibm_read_slot_reset_state
r_static
r_int
id|ibm_read_slot_reset_state
suffix:semicolon
DECL|variable|eeh_subsystem_enabled
r_static
r_int
id|eeh_subsystem_enabled
suffix:semicolon
DECL|macro|EEH_MAX_OPTS
mdefine_line|#define EEH_MAX_OPTS 4096
DECL|variable|eeh_opts
r_static
r_char
op_star
id|eeh_opts
suffix:semicolon
DECL|variable|eeh_opts_last
r_static
r_int
id|eeh_opts_last
suffix:semicolon
multiline_comment|/* System monitoring statistics */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|total_mmio_ffs
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|false_positives
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|ignored_failures
)paren
suffix:semicolon
r_static
r_int
id|eeh_check_opts_config
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_int
id|class_code
comma
r_int
id|vendor_id
comma
r_int
id|device_id
comma
r_int
id|default_state
)paren
suffix:semicolon
multiline_comment|/**&n; * The pci address cache subsystem.  This subsystem places&n; * PCI device address resources into a red-black tree, sorted&n; * according to the address range, so that given only an i/o&n; * address, the corresponding PCI device can be **quickly**&n; * found.&n; *&n; * Currently, the only customer of this code is the EEH subsystem;&n; * thus, this code has been somewhat tailored to suit EEH better.&n; * In particular, the cache does *not* hold the addresses of devices&n; * for which EEH is not enabled.&n; *&n; * (Implementation Note: The RB tree seems to be better/faster&n; * than any hash algo I could think of for this problem, even&n; * with the penalty of slow pointer chases for d-cache misses).&n; */
DECL|struct|pci_io_addr_range
r_struct
id|pci_io_addr_range
(brace
DECL|member|rb_node
r_struct
id|rb_node
id|rb_node
suffix:semicolon
DECL|member|addr_lo
r_int
r_int
id|addr_lo
suffix:semicolon
DECL|member|addr_hi
r_int
r_int
id|addr_hi
suffix:semicolon
DECL|member|pcidev
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_io_addr_cache
r_static
r_struct
id|pci_io_addr_cache
(brace
DECL|member|rb_root
r_struct
id|rb_root
id|rb_root
suffix:semicolon
DECL|member|piar_lock
id|spinlock_t
id|piar_lock
suffix:semicolon
DECL|variable|pci_io_addr_cache_root
)brace
id|pci_io_addr_cache_root
suffix:semicolon
DECL|function|__pci_get_device_by_addr
r_static
r_inline
r_struct
id|pci_dev
op_star
id|__pci_get_device_by_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|pci_io_addr_cache_root.rb_root.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|piar-&gt;addr_lo
)paren
(brace
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|addr
OG
id|piar-&gt;addr_hi
)paren
(brace
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
)brace
r_else
(brace
id|pci_dev_get
c_func
(paren
id|piar-&gt;pcidev
)paren
suffix:semicolon
r_return
id|piar-&gt;pcidev
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_get_device_by_addr - Get device, given only address&n; * @addr: mmio (PIO) phys address or i/o port number&n; *&n; * Given an mmio phys address, or a port number, find a pci device&n; * that implements this address.  Be sure to pci_dev_put the device&n; * when finished.  I/O port numbers are assumed to be offset&n; * from zero (that is, they do *not* have pci_io_addr added in).&n; * It is safe to call this function within an interrupt.&n; */
DECL|function|pci_get_device_by_addr
r_static
r_struct
id|pci_dev
op_star
id|pci_get_device_by_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|dev
op_assign
id|__pci_get_device_by_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Handy-dandy debug print routine, does nothing more&n; * than print out the contents of our addr cache.&n; */
DECL|function|pci_addr_cache_print
r_static
r_void
id|pci_addr_cache_print
c_func
(paren
r_struct
id|pci_io_addr_cache
op_star
id|cache
)paren
(brace
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|cache-&gt;rb_root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PCI: %s addr range %d [%lx-%lx]: %s %s&bslash;n&quot;
comma
(paren
id|piar-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
ques
c_cond
l_string|&quot;i/o&quot;
suffix:colon
l_string|&quot;mem&quot;
comma
id|cnt
comma
id|piar-&gt;addr_lo
comma
id|piar-&gt;addr_hi
comma
id|pci_name
c_func
(paren
id|piar-&gt;pcidev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|piar-&gt;pcidev
)paren
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
id|n
op_assign
id|rb_next
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Insert address range into the rb tree. */
r_static
r_struct
id|pci_io_addr_range
op_star
DECL|function|pci_addr_cache_insert
id|pci_addr_cache_insert
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
r_int
id|alo
comma
r_int
r_int
id|ahi
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|pci_io_addr_cache_root.rb_root.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
multiline_comment|/* Walk tree, find a place to insert into tree */
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alo
OL
id|piar-&gt;addr_lo
)paren
(brace
id|p
op_assign
op_amp
id|parent-&gt;rb_left
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahi
OG
id|piar-&gt;addr_hi
)paren
(brace
id|p
op_assign
op_amp
id|parent-&gt;rb_right
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev
op_ne
id|piar-&gt;pcidev
op_logical_or
id|alo
op_ne
id|piar-&gt;addr_lo
op_logical_or
id|ahi
op_ne
id|piar-&gt;addr_hi
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PIAR: overlapping address range&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|piar
suffix:semicolon
)brace
)brace
id|piar
op_assign
(paren
r_struct
id|pci_io_addr_range
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_io_addr_range
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|piar
)paren
r_return
l_int|NULL
suffix:semicolon
id|piar-&gt;addr_lo
op_assign
id|alo
suffix:semicolon
id|piar-&gt;addr_hi
op_assign
id|ahi
suffix:semicolon
id|piar-&gt;pcidev
op_assign
id|dev
suffix:semicolon
id|piar-&gt;flags
op_assign
id|flags
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|piar-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|piar-&gt;rb_node
comma
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
r_return
id|piar
suffix:semicolon
)brace
DECL|function|__pci_addr_cache_insert_device
r_static
r_void
id|__pci_addr_cache_insert_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: no pci dn found for dev=%s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Skip any devices for which EEH is not enabled. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
op_logical_or
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_NOCHECK
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PCI: skip building address cache for=%s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Walk resources on this device, poke them into the tree */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEVICE_COUNT_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_int
r_int
id|end
op_assign
id|pci_resource_end
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|pci_resource_flags
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* We are interested only bus addresses, not dma or other stuff */
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|flags
op_amp
(paren
id|IORESOURCE_IO
op_or
id|IORESOURCE_MEM
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
l_int|0
op_logical_or
op_complement
id|start
op_eq
l_int|0
op_logical_or
id|end
op_eq
l_int|0
op_logical_or
op_complement
id|end
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pci_addr_cache_insert
c_func
(paren
id|dev
comma
id|start
comma
id|end
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * pci_addr_cache_insert_device - Add a device to the address cache&n; * @dev: PCI device whose I/O addresses we are interested in.&n; *&n; * In order to support the fast lookup of devices based on addresses,&n; * we maintain a cache of devices that can be quickly searched.&n; * This routine adds a device to that cache.&n; */
DECL|function|pci_addr_cache_insert_device
r_void
id|pci_addr_cache_insert_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|__pci_addr_cache_insert_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__pci_addr_cache_remove_device
r_static
r_inline
r_void
id|__pci_addr_cache_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
id|restart
suffix:colon
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|piar-&gt;pcidev
op_eq
id|dev
)paren
(brace
id|rb_erase
c_func
(paren
id|n
comma
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|piar
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|n
op_assign
id|rb_next
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_addr_cache_remove_device - remove pci device from addr cache&n; * @dev: device to remove&n; *&n; * Remove a device from the addr-cache tree.&n; * This is potentially expensive, since it will walk&n; * the tree multiple times (once per resource).&n; * But so what; device removal doesn&squot;t need to be that fast.&n; */
DECL|function|pci_addr_cache_remove_device
r_void
id|pci_addr_cache_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|__pci_addr_cache_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_addr_cache_build - Build a cache of I/O addresses&n; *&n; * Build a cache of pci i/o addresses.  This cache will be used to&n; * find the pci device that corresponds to a given address.&n; * This routine scans all pci busses to build the cache.&n; * Must be run late in boot process, after the pci controllers&n; * have been scaned for devices (after all device resources are known).&n; */
DECL|function|pci_addr_cache_build
r_void
id|__init
id|pci_addr_cache_build
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_get_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Ignore PCI bridges ( XXX why ??) */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_BRIDGE
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pci_addr_cache_insert_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/* Verify tree built up above, echo back the list of addrs. */
id|pci_addr_cache_print
c_func
(paren
op_amp
id|pci_io_addr_cache_root
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * eeh_token_to_phys - convert EEH address token to phys address&n; * @token i/o token, should be address in the form 0xA....&n; *&n; * Converts EEH address tokens into physical addresses.  Note that&n; * ths routine does *not* convert I/O BAR addresses (which start&n; * with 0xE...) to phys addresses!&n; */
DECL|function|eeh_token_to_phys
r_static
r_int
r_int
id|eeh_token_to_phys
c_func
(paren
r_int
r_int
id|token
)paren
(brace
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
r_int
id|pa
comma
id|vaddr
suffix:semicolon
r_if
c_cond
(paren
id|REGION_ID
c_func
(paren
id|token
)paren
op_eq
id|EEH_REGION_ID
)paren
id|vaddr
op_assign
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|token
)paren
suffix:semicolon
r_else
r_return
id|token
suffix:semicolon
id|ptep
op_assign
id|find_linux_pte
c_func
(paren
id|ioremap_mm.pgd
comma
id|vaddr
)paren
suffix:semicolon
id|pa
op_assign
id|pte_pfn
c_func
(paren
op_star
id|ptep
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
r_return
id|pa
op_or
(paren
id|vaddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_check_failure - check if all 1&squot;s data is due to EEH slot freeze&n; * @token i/o token, should be address in the form 0xA....&n; * @val value, should be all 1&squot;s (XXX why do we need this arg??)&n; *&n; * Check for an eeh failure at the given token address.&n; * The given value has been read and it should be 1&squot;s (0xff, 0xffff or&n; * 0xffffffff).&n; *&n; * Probe to determine if an error actually occurred.  If not return val.&n; * Otherwise panic.&n; *&n; * Note this routine might be called in an interrupt context ...&n; */
DECL|function|eeh_check_failure
r_int
r_int
id|eeh_check_failure
c_func
(paren
r_void
op_star
id|token
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_int
r_int
id|ret
comma
id|rets
(braket
l_int|2
)braket
suffix:semicolon
r_static
id|spinlock_t
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* dont want this on the stack */
r_static
r_int
r_char
id|slot_err_buf
(braket
id|RTAS_ERROR_LOG_MAX
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|total_mmio_ffs
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
id|val
suffix:semicolon
multiline_comment|/* Finding the phys addr + pci device; this is pretty quick. */
id|addr
op_assign
id|eeh_token_to_phys
c_func
(paren
(paren
r_int
r_int
)paren
id|token
)paren
suffix:semicolon
id|dev
op_assign
id|pci_get_device_by_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|val
suffix:semicolon
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/* Access to IO BARs might get this far and still not want checking. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
op_logical_or
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_NOCHECK
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dn-&gt;eeh_config_addr
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now test for an EEH failure.  This is VERY expensive.&n;&t; * Note that the eeh_config_addr may be a parent device&n;&t; * in the case of a device behind a bridge, or it may be&n;&t; * function zero of a multi-function device.&n;&t; * In any case they must share a common PHB.&n;&t; */
id|ret
op_assign
id|rtas_call
c_func
(paren
id|ibm_read_slot_reset_state
comma
l_int|3
comma
l_int|3
comma
id|rets
comma
id|dn-&gt;eeh_config_addr
comma
id|BUID_HI
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
id|BUID_LO
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|rets
(braket
l_int|1
)braket
op_eq
l_int|1
op_logical_and
id|rets
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
r_int
r_int
id|slot_err_ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
id|memset
c_func
(paren
id|slot_err_buf
comma
l_int|0
comma
id|RTAS_ERROR_LOG_MAX
)paren
suffix:semicolon
id|slot_err_ret
op_assign
id|rtas_call
c_func
(paren
id|rtas_token
c_func
(paren
l_string|&quot;ibm,slot-error-detail&quot;
)paren
comma
l_int|8
comma
l_int|1
comma
l_int|NULL
comma
id|dn-&gt;eeh_config_addr
comma
id|BUID_HI
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
id|BUID_LO
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
l_int|NULL
comma
l_int|0
comma
id|__pa
c_func
(paren
id|slot_err_buf
)paren
comma
id|RTAS_ERROR_LOG_MAX
comma
l_int|2
multiline_comment|/* Permanent Error */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot_err_ret
op_eq
l_int|0
)paren
id|log_error
c_func
(paren
id|slot_err_buf
comma
id|ERR_TYPE_RTAS_LOG
comma
l_int|1
multiline_comment|/* Fatal */
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX We should create a separate sysctl for this.&n;&t;&t; *&n;&t;&t; * Since the panic_on_oops sysctl is used to halt&n;&t;&t; * the system in light of potential corruption, we&n;&t;&t; * can use it here.&n;&t;&t; */
r_if
c_cond
(paren
id|panic_on_oops
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;EEH: MMIO failure (%ld) on device:%s %s&bslash;n&quot;
comma
id|rets
(braket
l_int|0
)braket
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__get_cpu_var
c_func
(paren
id|ignored_failures
)paren
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: MMIO failure (%ld) on device:%s %s&bslash;n&quot;
comma
id|rets
(braket
l_int|0
)braket
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|__get_cpu_var
c_func
(paren
id|false_positives
)paren
op_increment
suffix:semicolon
)brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|variable|eeh_check_failure
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_check_failure
)paren
suffix:semicolon
DECL|struct|eeh_early_enable_info
r_struct
id|eeh_early_enable_info
(brace
DECL|member|buid_hi
r_int
r_int
id|buid_hi
suffix:semicolon
DECL|member|buid_lo
r_int
r_int
id|buid_lo
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Enable eeh for the given device node. */
DECL|function|early_enable_eeh
r_static
r_void
op_star
id|early_enable_eeh
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|eeh_early_enable_info
op_star
id|info
op_assign
id|data
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|status
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;status&quot;
comma
l_int|0
)paren
suffix:semicolon
id|u32
op_star
id|class_code
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;class-code&quot;
comma
l_int|0
)paren
suffix:semicolon
id|u32
op_star
id|vendor_id
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;vendor-id&quot;
comma
l_int|0
)paren
suffix:semicolon
id|u32
op_star
id|device_id
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;device-id&quot;
comma
l_int|0
)paren
suffix:semicolon
id|u32
op_star
id|regs
suffix:semicolon
r_int
id|enable
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
id|strcmp
c_func
(paren
id|status
comma
l_string|&quot;ok&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* ignore devices with bad status */
multiline_comment|/* Weed out PHBs or other bad nodes. */
r_if
c_cond
(paren
op_logical_neg
id|class_code
op_logical_or
op_logical_neg
id|vendor_id
op_logical_or
op_logical_neg
id|device_id
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Ignore known PHBs and EADs bridges */
r_if
c_cond
(paren
op_star
id|vendor_id
op_eq
id|PCI_VENDOR_ID_IBM
op_logical_and
(paren
op_star
id|device_id
op_eq
l_int|0x0102
op_logical_or
op_star
id|device_id
op_eq
l_int|0x008b
op_logical_or
op_star
id|device_id
op_eq
l_int|0x0188
op_logical_or
op_star
id|device_id
op_eq
l_int|0x0302
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Now decide if we are going to &quot;Disable&quot; EEH checking&n;&t; * for this device.  We still run with the EEH hardware active,&n;&t; * but we won&squot;t be checking for ff&squot;s.  This means a driver&n;&t; * could return bad data (very bad!), an interrupt handler could&n;&t; * hang waiting on status bits that won&squot;t change, etc.&n;&t; * But there are a few cases like display devices that make sense.&n;&t; */
id|enable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* i.e. we will do checking */
r_if
c_cond
(paren
(paren
op_star
id|class_code
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eeh_check_opts_config
c_func
(paren
id|dn
comma
op_star
id|class_code
comma
op_star
id|vendor_id
comma
op_star
id|device_id
comma
id|enable
)paren
)paren
(brace
r_if
c_cond
(paren
id|enable
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: %s user requested to run &quot;
l_string|&quot;without EEH.&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|enable
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|enable
)paren
(brace
id|dn-&gt;eeh_mode
op_assign
id|EEH_MODE_NOCHECK
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This device may already have an EEH parent. */
r_if
c_cond
(paren
id|dn-&gt;parent
op_logical_and
(paren
id|dn-&gt;parent-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
)paren
(brace
multiline_comment|/* Parent supports EEH. */
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_SUPPORTED
suffix:semicolon
id|dn-&gt;eeh_config_addr
op_assign
id|dn-&gt;parent-&gt;eeh_config_addr
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Ok... see if this device supports EEH. */
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;reg&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs
)paren
(brace
multiline_comment|/* First register entry is addr (00BBSS00)  */
multiline_comment|/* Try to enable eeh */
id|ret
op_assign
id|rtas_call
c_func
(paren
id|ibm_set_eeh_option
comma
l_int|4
comma
l_int|1
comma
l_int|NULL
comma
id|regs
(braket
l_int|0
)braket
comma
id|info-&gt;buid_hi
comma
id|info-&gt;buid_lo
comma
id|EEH_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|eeh_subsystem_enabled
op_assign
l_int|1
suffix:semicolon
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_SUPPORTED
suffix:semicolon
id|dn-&gt;eeh_config_addr
op_assign
id|regs
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: %s: eeh enabled&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: %s: rtas_call failed.&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: %s: unable to get reg property.&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize EEH by trying to enable it for all of the adapters in the system.&n; * As a side effect we can determine here if eeh is supported at all.&n; * Note that we leave EEH on so failed config cycles won&squot;t cause a machine&n; * check.  If a user turns off EEH for a particular adapter they are really&n; * telling Linux to ignore errors.&n; *&n; * We should probably distinguish between &quot;ignore errors&quot; and &quot;turn EEH off&quot;&n; * but for now disabling EEH for adapters is mostly to work around drivers that&n; * directly access mmio space (without using the macros).&n; *&n; * The eeh-force-off option does literally what it says, so if Linux must&n; * avoid enabling EEH this must be done.&n; */
DECL|function|eeh_init
r_void
id|__init
id|eeh_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|phb
suffix:semicolon
r_struct
id|eeh_early_enable_info
id|info
suffix:semicolon
r_char
op_star
id|eeh_force_off
op_assign
id|strstr
c_func
(paren
id|saved_command_line
comma
l_string|&quot;eeh-force-off&quot;
)paren
suffix:semicolon
id|ibm_set_eeh_option
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,set-eeh-option&quot;
)paren
suffix:semicolon
id|ibm_set_slot_reset
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,set-slot-reset&quot;
)paren
suffix:semicolon
id|ibm_read_slot_reset_state
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,read-slot-reset-state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibm_set_eeh_option
op_eq
id|RTAS_UNKNOWN_SERVICE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|eeh_force_off
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: WARNING: PCI Enhanced I/O Error &quot;
l_string|&quot;Handling is user disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Enable EEH for all adapters.  Note that eeh requires buid&squot;s */
r_for
c_loop
(paren
id|phb
op_assign
id|of_find_node_by_name
c_func
(paren
l_int|NULL
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
id|phb
suffix:semicolon
id|phb
op_assign
id|of_find_node_by_name
c_func
(paren
id|phb
comma
l_string|&quot;pci&quot;
)paren
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
op_star
id|buid_vals
suffix:semicolon
id|buid_vals
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|phb
comma
l_string|&quot;ibm,fw-phb-id&quot;
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buid_vals
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
r_sizeof
(paren
r_int
)paren
)paren
(brace
id|info.buid_lo
op_assign
id|buid_vals
(braket
l_int|0
)braket
suffix:semicolon
id|info.buid_hi
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_eq
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
)paren
(brace
id|info.buid_hi
op_assign
id|buid_vals
(braket
l_int|0
)braket
suffix:semicolon
id|info.buid_lo
op_assign
id|buid_vals
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: odd ibm,fw-phb-id len returned: %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|traverse_pci_devices
c_func
(paren
id|phb
comma
id|early_enable_eeh
comma
l_int|NULL
comma
op_amp
id|info
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeh_subsystem_enabled
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: PCI Enhanced I/O Error Handling Enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_add_device - perform EEH initialization for the indicated pci device&n; * @dev: pci device for which to set up EEH&n; *&n; * This routine can be used to perform EEH initialization for PCI&n; * devices that were added after system boot (e.g. hotplug, dlpar).&n; * Whether this actually enables EEH or not for this device depends&n; * on the type of the device, on earlier boot command-line&n; * arguments &amp; etc.&n; */
DECL|function|eeh_add_device
r_void
id|eeh_add_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_struct
id|eeh_early_enable_info
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: adding device %s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|dn
)paren
r_return
suffix:semicolon
id|phb
op_assign
id|PCI_GET_PHB_PTR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|phb
op_logical_or
l_int|0
op_eq
id|phb-&gt;buid
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: Expected buid but found none&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info.buid_hi
op_assign
id|BUID_HI
c_func
(paren
id|phb-&gt;buid
)paren
suffix:semicolon
id|info.buid_lo
op_assign
id|BUID_LO
c_func
(paren
id|phb-&gt;buid
)paren
suffix:semicolon
id|early_enable_eeh
c_func
(paren
id|dn
comma
op_amp
id|info
)paren
suffix:semicolon
id|pci_addr_cache_insert_device
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|eeh_add_device
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_add_device
)paren
suffix:semicolon
multiline_comment|/**&n; * eeh_remove_device - undo EEH setup for the indicated pci device&n; * @dev: pci device to be removed&n; *&n; * This routine should be when a device is removed from a running&n; * system (e.g. by hotplug or dlpar).&n; */
DECL|function|eeh_remove_device
r_void
id|eeh_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
suffix:semicolon
multiline_comment|/* Unregister the device with the EEH/PCI address search system */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: remove device %s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|pci_addr_cache_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|eeh_remove_device
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_remove_device
)paren
suffix:semicolon
multiline_comment|/*&n; * If EEH is implemented, find the PCI device using given phys addr&n; * and check to see if eeh failure checking is disabled.&n; * Remap the addr (trivially) to the EEH region if EEH checking enabled.&n; * For addresses not known to PCI the vaddr is simply returned unchanged.&n; */
DECL|function|eeh_ioremap
r_void
op_star
id|eeh_ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|vaddr
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
id|vaddr
suffix:semicolon
id|dev
op_assign
id|pci_get_device_by_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|vaddr
suffix:semicolon
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|vaddr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_NOCHECK
)paren
(brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|vaddr
suffix:semicolon
)brace
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|IO_ADDR_TO_TOKEN
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|proc_eeh_show
r_static
r_int
id|proc_eeh_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
r_int
id|ffs
op_assign
l_int|0
comma
id|positives
op_assign
l_int|0
comma
id|failures
op_assign
l_int|0
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|cpu
)paren
(brace
id|ffs
op_add_assign
id|per_cpu
c_func
(paren
id|total_mmio_ffs
comma
id|cpu
)paren
suffix:semicolon
id|positives
op_add_assign
id|per_cpu
c_func
(paren
id|false_positives
comma
id|cpu
)paren
suffix:semicolon
id|failures
op_add_assign
id|per_cpu
c_func
(paren
id|ignored_failures
comma
id|cpu
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_eq
id|eeh_subsystem_enabled
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;EEH Subsystem is globally disabled&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;eeh_total_mmio_ffs=%ld&bslash;n&quot;
comma
id|ffs
)paren
suffix:semicolon
)brace
r_else
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;EEH Subsystem is enabled&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;eeh_total_mmio_ffs=%ld&bslash;n&quot;
l_string|&quot;eeh_false_positives=%ld&bslash;n&quot;
l_string|&quot;eeh_ignored_failures=%ld&bslash;n&quot;
comma
id|ffs
comma
id|positives
comma
id|failures
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|proc_eeh_open
r_static
r_int
id|proc_eeh_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|proc_eeh_show
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|proc_eeh_operations
r_static
r_struct
id|file_operations
id|proc_eeh_operations
op_assign
(brace
dot
id|open
op_assign
id|proc_eeh_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
DECL|function|eeh_init_proc
r_static
r_int
id|__init
id|eeh_init_proc
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_amp
id|PLATFORM_PSERIES
)paren
(brace
id|e
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;ppc64/eeh&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
id|e-&gt;proc_fops
op_assign
op_amp
id|proc_eeh_operations
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|eeh_init_proc
id|__initcall
c_func
(paren
id|eeh_init_proc
)paren
suffix:semicolon
multiline_comment|/*&n; * Test if &quot;dev&quot; should be configured on or off.&n; * This processes the options literally from left to right.&n; * This lets the user specify stupid combinations of options,&n; * but at least the result should be very predictable.&n; */
DECL|function|eeh_check_opts_config
r_static
r_int
id|eeh_check_opts_config
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_int
id|class_code
comma
r_int
id|vendor_id
comma
r_int
id|device_id
comma
r_int
id|default_state
)paren
(brace
r_char
id|devname
(braket
l_int|32
)braket
comma
id|classname
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|strs
(braket
l_int|8
)braket
comma
op_star
id|s
suffix:semicolon
r_int
id|nstrs
comma
id|i
suffix:semicolon
r_int
id|ret
op_assign
id|default_state
suffix:semicolon
multiline_comment|/* Build list of strings to match */
id|nstrs
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,loc-code&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
id|strs
(braket
id|nstrs
op_increment
)braket
op_assign
id|s
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;dev%04x:%04x&quot;
comma
id|vendor_id
comma
id|device_id
)paren
suffix:semicolon
id|strs
(braket
id|nstrs
op_increment
)braket
op_assign
id|devname
suffix:semicolon
id|sprintf
c_func
(paren
id|classname
comma
l_string|&quot;class%04x&quot;
comma
id|class_code
)paren
suffix:semicolon
id|strs
(braket
id|nstrs
op_increment
)braket
op_assign
id|classname
suffix:semicolon
id|strs
(braket
id|nstrs
op_increment
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* yes, this matches the empty string */
multiline_comment|/*&n;&t; * Now see if any string matches the eeh_opts list.&n;&t; * The eeh_opts list entries start with + or -.&n;&t; */
r_for
c_loop
(paren
id|s
op_assign
id|eeh_opts
suffix:semicolon
id|s
op_logical_and
(paren
id|s
OL
(paren
id|eeh_opts
op_plus
id|eeh_opts_last
)paren
)paren
suffix:semicolon
id|s
op_add_assign
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nstrs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|strs
(braket
id|i
)braket
comma
id|s
op_plus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
(paren
id|strs
(braket
id|i
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle kernel eeh-on &amp; eeh-off cmd line options for eeh.&n; *&n; * We support:&n; *&t;eeh-off=loc1,loc2,loc3...&n; *&n; * and this option can be repeated so&n; *      eeh-off=loc1,loc2 eeh-off=loc3&n; * is the same as eeh-off=loc1,loc2,loc3&n; *&n; * loc is an IBM location code that can be found in a manual or&n; * via openfirmware (or the Hardware Management Console).&n; *&n; * We also support these additional &quot;loc&quot; values:&n; *&n; *&t;dev#:#    vendor:device id in hex (e.g. dev1022:2000)&n; *&t;class#    class id in hex (e.g. class0200)&n; *&n; * If no location code is specified all devices are assumed&n; * so eeh-off means eeh by default is off.&n; */
multiline_comment|/*&n; * This is implemented as a null separated list of strings.&n; * Each string looks like this:  &quot;+X&quot; or &quot;-X&quot;&n; * where X is a loc code, vendor:device, class (as shown above)&n; * or empty which is used to indicate all.&n; *&n; * We interpret this option string list so that it will literally&n; * behave left-to-right even if some combinations don&squot;t make sense.&n; */
DECL|function|eeh_parm
r_static
r_int
id|__init
id|eeh_parm
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|state
)paren
(brace
r_char
op_star
id|s
comma
op_star
id|cur
comma
op_star
id|curend
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eeh_opts
)paren
(brace
id|eeh_opts
op_assign
id|alloc_bootmem
c_func
(paren
id|EEH_MAX_OPTS
)paren
suffix:semicolon
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
l_char|&squot;+&squot;
suffix:semicolon
multiline_comment|/* default */
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
id|state
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot;-&squot;
suffix:semicolon
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;=&squot;
)paren
id|str
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|str
suffix:semicolon
id|s
op_logical_and
op_star
id|s
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|s
op_assign
id|curend
)paren
(brace
id|cur
op_assign
id|s
suffix:semicolon
multiline_comment|/* ignore empties.  Don&squot;t treat as &quot;all-on&quot; or &quot;all-off&quot; */
r_while
c_loop
(paren
op_star
id|cur
op_eq
l_char|&squot;,&squot;
)paren
id|cur
op_increment
suffix:semicolon
id|curend
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curend
)paren
id|curend
op_assign
id|cur
op_plus
id|strlen
c_func
(paren
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cur
)paren
(brace
r_int
id|curlen
op_assign
id|curend
op_minus
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|eeh_opts_last
op_plus
id|curlen
OG
id|EEH_MAX_OPTS
op_minus
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: sorry...too many &quot;
l_string|&quot;eeh cmd line options&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
id|state
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot;-&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|eeh_opts
op_plus
id|eeh_opts_last
comma
id|cur
comma
id|curlen
)paren
suffix:semicolon
id|eeh_opts_last
op_add_assign
id|curlen
suffix:semicolon
id|eeh_opts
(braket
id|eeh_opts_last
op_increment
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|eehoff_parm
r_static
r_int
id|__init
id|eehoff_parm
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|eeh_parm
c_func
(paren
id|str
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|eehon_parm
r_static
r_int
id|__init
id|eehon_parm
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|eeh_parm
c_func
(paren
id|str
comma
l_int|1
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;eeh-off&quot;
comma
id|eehoff_parm
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;eeh-on&quot;
comma
id|eehon_parm
)paren
suffix:semicolon
eof
