multiline_comment|/*&n; * eeh.c&n; * Copyright (C) 2001 Dave Engebretsen &amp; Todd Inglett IBM Corporation&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/eeh.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/systemcfg.h&gt;
macro_line|#include &quot;pci.h&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
multiline_comment|/** Overview:&n; *  EEH, or &quot;Extended Error Handling&quot; is a PCI bridge technology for&n; *  dealing with PCI bus errors that can&squot;t be dealt with within the&n; *  usual PCI framework, except by check-stopping the CPU.  Systems&n; *  that are designed for high-availability/reliability cannot afford&n; *  to crash due to a &quot;mere&quot; PCI error, thus the need for EEH.&n; *  An EEH-capable bridge operates by converting a detected error&n; *  into a &quot;slot freeze&quot;, taking the PCI adapter off-line, making&n; *  the slot behave, from the OS&squot;es point of view, as if the slot&n; *  were &quot;empty&quot;: all reads return 0xff&squot;s and all writes are silently&n; *  ignored.  EEH slot isolation events can be triggered by parity&n; *  errors on the address or data busses (e.g. during posted writes),&n; *  which in turn might be caused by dust, vibration, humidity,&n; *  radioactivity or plain-old failed hardware.&n; *&n; *  Note, however, that one of the leading causes of EEH slot&n; *  freeze events are buggy device drivers, buggy device microcode,&n; *  or buggy device hardware.  This is because any attempt by the&n; *  device to bus-master data to a memory address that is not&n; *  assigned to the device will trigger a slot freeze.   (The idea&n; *  is to prevent devices-gone-wild from corrupting system memory).&n; *  Buggy hardware/drivers will have a miserable time co-existing&n; *  with EEH.&n; *&n; *  Ideally, a PCI device driver, when suspecting that an isolation&n; *  event has occured (e.g. by reading 0xff&squot;s), will then ask EEH&n; *  whether this is the case, and then take appropriate steps to&n; *  reset the PCI slot, the PCI device, and then resume operations.&n; *  However, until that day,  the checking is done here, with the&n; *  eeh_check_failure() routine embedded in the MMIO macros.  If&n; *  the slot is found to be isolated, an &quot;EEH Event&quot; is synthesized&n; *  and sent out for processing.&n; */
multiline_comment|/** Bus Unit ID macros; get low and hi 32-bits of the 64-bit BUID */
DECL|macro|BUID_HI
mdefine_line|#define BUID_HI(buid) ((buid) &gt;&gt; 32)
DECL|macro|BUID_LO
mdefine_line|#define BUID_LO(buid) ((buid) &amp; 0xffffffff)
multiline_comment|/* EEH event workqueue setup. */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|eeh_eventlist_lock
)paren
suffix:semicolon
DECL|variable|eeh_eventlist
id|LIST_HEAD
c_func
(paren
id|eeh_eventlist
)paren
suffix:semicolon
r_static
r_void
id|eeh_event_handler
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
id|DECLARE_WORK
c_func
(paren
id|eeh_event_wq
comma
id|eeh_event_handler
comma
l_int|NULL
)paren
suffix:semicolon
DECL|variable|eeh_notifier_chain
r_static
r_struct
id|notifier_block
op_star
id|eeh_notifier_chain
suffix:semicolon
multiline_comment|/*&n; * If a device driver keeps reading an MMIO register in an interrupt&n; * handler after a slot isolation event has occurred, we assume it&n; * is broken and panic.  This sets the threshold for how many read&n; * attempts we allow before panicking.&n; */
DECL|macro|EEH_MAX_FAILS
mdefine_line|#define EEH_MAX_FAILS&t;1000
DECL|variable|eeh_fail_count
r_static
id|atomic_t
id|eeh_fail_count
suffix:semicolon
multiline_comment|/* RTAS tokens */
DECL|variable|ibm_set_eeh_option
r_static
r_int
id|ibm_set_eeh_option
suffix:semicolon
DECL|variable|ibm_set_slot_reset
r_static
r_int
id|ibm_set_slot_reset
suffix:semicolon
DECL|variable|ibm_read_slot_reset_state
r_static
r_int
id|ibm_read_slot_reset_state
suffix:semicolon
DECL|variable|ibm_read_slot_reset_state2
r_static
r_int
id|ibm_read_slot_reset_state2
suffix:semicolon
DECL|variable|ibm_slot_error_detail
r_static
r_int
id|ibm_slot_error_detail
suffix:semicolon
DECL|variable|eeh_subsystem_enabled
r_static
r_int
id|eeh_subsystem_enabled
suffix:semicolon
multiline_comment|/* Buffer for reporting slot-error-detail rtas calls */
DECL|variable|slot_errbuf
r_static
r_int
r_char
id|slot_errbuf
(braket
id|RTAS_ERROR_LOG_MAX
)braket
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|slot_errbuf_lock
)paren
suffix:semicolon
DECL|variable|eeh_error_buf_size
r_static
r_int
id|eeh_error_buf_size
suffix:semicolon
multiline_comment|/* System monitoring statistics */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|total_mmio_ffs
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|false_positives
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|ignored_failures
)paren
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|slot_resets
)paren
suffix:semicolon
multiline_comment|/**&n; * The pci address cache subsystem.  This subsystem places&n; * PCI device address resources into a red-black tree, sorted&n; * according to the address range, so that given only an i/o&n; * address, the corresponding PCI device can be **quickly**&n; * found. It is safe to perform an address lookup in an interrupt&n; * context; this ability is an important feature.&n; *&n; * Currently, the only customer of this code is the EEH subsystem;&n; * thus, this code has been somewhat tailored to suit EEH better.&n; * In particular, the cache does *not* hold the addresses of devices&n; * for which EEH is not enabled.&n; *&n; * (Implementation Note: The RB tree seems to be better/faster&n; * than any hash algo I could think of for this problem, even&n; * with the penalty of slow pointer chases for d-cache misses).&n; */
DECL|struct|pci_io_addr_range
r_struct
id|pci_io_addr_range
(brace
DECL|member|rb_node
r_struct
id|rb_node
id|rb_node
suffix:semicolon
DECL|member|addr_lo
r_int
r_int
id|addr_lo
suffix:semicolon
DECL|member|addr_hi
r_int
r_int
id|addr_hi
suffix:semicolon
DECL|member|pcidev
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_io_addr_cache
r_static
r_struct
id|pci_io_addr_cache
(brace
DECL|member|rb_root
r_struct
id|rb_root
id|rb_root
suffix:semicolon
DECL|member|piar_lock
id|spinlock_t
id|piar_lock
suffix:semicolon
DECL|variable|pci_io_addr_cache_root
)brace
id|pci_io_addr_cache_root
suffix:semicolon
DECL|function|__pci_get_device_by_addr
r_static
r_inline
r_struct
id|pci_dev
op_star
id|__pci_get_device_by_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|pci_io_addr_cache_root.rb_root.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|piar-&gt;addr_lo
)paren
(brace
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|addr
OG
id|piar-&gt;addr_hi
)paren
(brace
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
)brace
r_else
(brace
id|pci_dev_get
c_func
(paren
id|piar-&gt;pcidev
)paren
suffix:semicolon
r_return
id|piar-&gt;pcidev
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_get_device_by_addr - Get device, given only address&n; * @addr: mmio (PIO) phys address or i/o port number&n; *&n; * Given an mmio phys address, or a port number, find a pci device&n; * that implements this address.  Be sure to pci_dev_put the device&n; * when finished.  I/O port numbers are assumed to be offset&n; * from zero (that is, they do *not* have pci_io_addr added in).&n; * It is safe to call this function within an interrupt.&n; */
DECL|function|pci_get_device_by_addr
r_static
r_struct
id|pci_dev
op_star
id|pci_get_device_by_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|dev
op_assign
id|__pci_get_device_by_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Handy-dandy debug print routine, does nothing more&n; * than print out the contents of our addr cache.&n; */
DECL|function|pci_addr_cache_print
r_static
r_void
id|pci_addr_cache_print
c_func
(paren
r_struct
id|pci_io_addr_cache
op_star
id|cache
)paren
(brace
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|cache-&gt;rb_root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PCI: %s addr range %d [%lx-%lx]: %s %s&bslash;n&quot;
comma
(paren
id|piar-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
ques
c_cond
l_string|&quot;i/o&quot;
suffix:colon
l_string|&quot;mem&quot;
comma
id|cnt
comma
id|piar-&gt;addr_lo
comma
id|piar-&gt;addr_hi
comma
id|pci_name
c_func
(paren
id|piar-&gt;pcidev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|piar-&gt;pcidev
)paren
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
id|n
op_assign
id|rb_next
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Insert address range into the rb tree. */
r_static
r_struct
id|pci_io_addr_range
op_star
DECL|function|pci_addr_cache_insert
id|pci_addr_cache_insert
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
r_int
id|alo
comma
r_int
r_int
id|ahi
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|pci_io_addr_cache_root.rb_root.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
multiline_comment|/* Walk tree, find a place to insert into tree */
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alo
OL
id|piar-&gt;addr_lo
)paren
(brace
id|p
op_assign
op_amp
id|parent-&gt;rb_left
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahi
OG
id|piar-&gt;addr_hi
)paren
(brace
id|p
op_assign
op_amp
id|parent-&gt;rb_right
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev
op_ne
id|piar-&gt;pcidev
op_logical_or
id|alo
op_ne
id|piar-&gt;addr_lo
op_logical_or
id|ahi
op_ne
id|piar-&gt;addr_hi
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PIAR: overlapping address range&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|piar
suffix:semicolon
)brace
)brace
id|piar
op_assign
(paren
r_struct
id|pci_io_addr_range
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_io_addr_range
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|piar
)paren
r_return
l_int|NULL
suffix:semicolon
id|piar-&gt;addr_lo
op_assign
id|alo
suffix:semicolon
id|piar-&gt;addr_hi
op_assign
id|ahi
suffix:semicolon
id|piar-&gt;pcidev
op_assign
id|dev
suffix:semicolon
id|piar-&gt;flags
op_assign
id|flags
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|piar-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|piar-&gt;rb_node
comma
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
r_return
id|piar
suffix:semicolon
)brace
DECL|function|__pci_addr_cache_insert_device
r_static
r_void
id|__pci_addr_cache_insert_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|inserted
op_assign
l_int|0
suffix:semicolon
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: no pci dn found for dev=%s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Skip any devices for which EEH is not enabled. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
op_logical_or
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_NOCHECK
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PCI: skip building address cache for=%s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* The cache holds a reference to the device... */
id|pci_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Walk resources on this device, poke them into the tree */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEVICE_COUNT_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_int
r_int
id|end
op_assign
id|pci_resource_end
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|pci_resource_flags
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* We are interested only bus addresses, not dma or other stuff */
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|flags
op_amp
(paren
id|IORESOURCE_IO
op_or
id|IORESOURCE_MEM
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
l_int|0
op_logical_or
op_complement
id|start
op_eq
l_int|0
op_logical_or
id|end
op_eq
l_int|0
op_logical_or
op_complement
id|end
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|pci_addr_cache_insert
c_func
(paren
id|dev
comma
id|start
comma
id|end
comma
id|flags
)paren
suffix:semicolon
id|inserted
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If there was nothing to add, the cache has no reference... */
r_if
c_cond
(paren
op_logical_neg
id|inserted
)paren
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_addr_cache_insert_device - Add a device to the address cache&n; * @dev: PCI device whose I/O addresses we are interested in.&n; *&n; * In order to support the fast lookup of devices based on addresses,&n; * we maintain a cache of devices that can be quickly searched.&n; * This routine adds a device to that cache.&n; */
DECL|function|pci_addr_cache_insert_device
r_void
id|pci_addr_cache_insert_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|__pci_addr_cache_insert_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__pci_addr_cache_remove_device
r_static
r_inline
r_void
id|__pci_addr_cache_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_int
id|removed
op_assign
l_int|0
suffix:semicolon
id|restart
suffix:colon
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|pci_io_addr_range
op_star
id|piar
suffix:semicolon
id|piar
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pci_io_addr_range
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|piar-&gt;pcidev
op_eq
id|dev
)paren
(brace
id|rb_erase
c_func
(paren
id|n
comma
op_amp
id|pci_io_addr_cache_root.rb_root
)paren
suffix:semicolon
id|removed
op_assign
l_int|1
suffix:semicolon
id|kfree
c_func
(paren
id|piar
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|n
op_assign
id|rb_next
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/* The cache no longer holds its reference to this device... */
r_if
c_cond
(paren
id|removed
)paren
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_addr_cache_remove_device - remove pci device from addr cache&n; * @dev: device to remove&n; *&n; * Remove a device from the addr-cache tree.&n; * This is potentially expensive, since it will walk&n; * the tree multiple times (once per resource).&n; * But so what; device removal doesn&squot;t need to be that fast.&n; */
DECL|function|pci_addr_cache_remove_device
r_void
id|pci_addr_cache_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
id|__pci_addr_cache_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_addr_cache_build - Build a cache of I/O addresses&n; *&n; * Build a cache of pci i/o addresses.  This cache will be used to&n; * find the pci device that corresponds to a given address.&n; * This routine scans all pci busses to build the cache.&n; * Must be run late in boot process, after the pci controllers&n; * have been scaned for devices (after all device resources are known).&n; */
DECL|function|pci_addr_cache_build
r_void
id|__init
id|pci_addr_cache_build
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pci_io_addr_cache_root.piar_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_get_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Ignore PCI bridges ( XXX why ??) */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_BRIDGE
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pci_addr_cache_insert_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/* Verify tree built up above, echo back the list of addrs. */
id|pci_addr_cache_print
c_func
(paren
op_amp
id|pci_io_addr_cache_root
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* --------------------------------------------------------------- */
multiline_comment|/* Above lies the PCI Address Cache. Below lies the EEH event infrastructure */
multiline_comment|/**&n; * eeh_register_notifier - Register to find out about EEH events.&n; * @nb: notifier block to callback on events&n; */
DECL|function|eeh_register_notifier
r_int
id|eeh_register_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|eeh_notifier_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_unregister_notifier - Unregister to an EEH event notifier.&n; * @nb: notifier block to callback on events&n; */
DECL|function|eeh_unregister_notifier
r_int
id|eeh_unregister_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|eeh_notifier_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * read_slot_reset_state - Read the reset state of a device node&squot;s slot&n; * @dn: device node to read&n; * @rets: array to return results in&n; */
DECL|function|read_slot_reset_state
r_static
r_int
id|read_slot_reset_state
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_int
id|rets
(braket
)braket
)paren
(brace
r_int
id|token
comma
id|outputs
suffix:semicolon
r_if
c_cond
(paren
id|ibm_read_slot_reset_state2
op_ne
id|RTAS_UNKNOWN_SERVICE
)paren
(brace
id|token
op_assign
id|ibm_read_slot_reset_state2
suffix:semicolon
id|outputs
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|token
op_assign
id|ibm_read_slot_reset_state
suffix:semicolon
id|outputs
op_assign
l_int|3
suffix:semicolon
)brace
r_return
id|rtas_call
c_func
(paren
id|token
comma
l_int|3
comma
id|outputs
comma
id|rets
comma
id|dn-&gt;eeh_config_addr
comma
id|BUID_HI
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
id|BUID_LO
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_panic - call panic() for an eeh event that cannot be handled.&n; * The philosophy of this routine is that it is better to panic and&n; * halt the OS than it is to risk possible data corruption by&n; * oblivious device drivers that don&squot;t know better.&n; *&n; * @dev pci device that had an eeh event&n; * @reset_state current reset state of the device slot&n; */
DECL|function|eeh_panic
r_static
r_void
id|eeh_panic
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|reset_state
)paren
(brace
multiline_comment|/*&n;&t; * XXX We should create a separate sysctl for this.&n;&t; *&n;&t; * Since the panic_on_oops sysctl is used to halt the system&n;&t; * in light of potential corruption, we can use it here.&n;&t; */
r_if
c_cond
(paren
id|panic_on_oops
)paren
id|panic
c_func
(paren
l_string|&quot;EEH: MMIO failure (%d) on device:%s %s&bslash;n&quot;
comma
id|reset_state
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_else
(brace
id|__get_cpu_var
c_func
(paren
id|ignored_failures
)paren
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: Ignored MMIO failure (%d) on device:%s %s&bslash;n&quot;
comma
id|reset_state
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * eeh_event_handler - dispatch EEH events.  The detection of a frozen&n; * slot can occur inside an interrupt, where it can be hard to do&n; * anything about it.  The goal of this routine is to pull these&n; * detection events out of the context of the interrupt handler, and&n; * re-dispatch them for processing at a later time in a normal context.&n; *&n; * @dummy - unused&n; */
DECL|function|eeh_event_handler
r_static
r_void
id|eeh_event_handler
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|eeh_event
op_star
id|event
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|eeh_eventlist_lock
comma
id|flags
)paren
suffix:semicolon
id|event
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|eeh_eventlist
)paren
)paren
(brace
id|event
op_assign
id|list_entry
c_func
(paren
id|eeh_eventlist.next
comma
r_struct
id|eeh_event
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|event-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|eeh_eventlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: MMIO failure (%d), notifiying device &quot;
l_string|&quot;%s %s&bslash;n&quot;
comma
id|event-&gt;reset_state
comma
id|pci_name
c_func
(paren
id|event-&gt;dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|event-&gt;dev
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|eeh_fail_count
comma
l_int|0
)paren
suffix:semicolon
id|notifier_call_chain
(paren
op_amp
id|eeh_notifier_chain
comma
id|EEH_NOTIFY_FREEZE
comma
id|event
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|slot_resets
)paren
op_increment
suffix:semicolon
id|pci_dev_put
c_func
(paren
id|event-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * eeh_token_to_phys - convert EEH address token to phys address&n; * @token i/o token, should be address in the form 0xE....&n; */
DECL|function|eeh_token_to_phys
r_static
r_inline
r_int
r_int
id|eeh_token_to_phys
c_func
(paren
r_int
r_int
id|token
)paren
(brace
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
r_int
id|pa
suffix:semicolon
id|ptep
op_assign
id|find_linux_pte
c_func
(paren
id|ioremap_mm.pgd
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptep
)paren
r_return
id|token
suffix:semicolon
id|pa
op_assign
id|pte_pfn
c_func
(paren
op_star
id|ptep
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
r_return
id|pa
op_or
(paren
id|token
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_dn_check_failure - check if all 1&squot;s data is due to EEH slot freeze&n; * @dn device node&n; * @dev pci device, if known&n; *&n; * Check for an EEH failure for the given device node.  Call this&n; * routine if the result of a read was all 0xff&squot;s and you want to&n; * find out if this is due to an EEH slot freeze.  This routine&n; * will query firmware for the EEH status.&n; *&n; * Returns 0 if there has not been an EEH error; otherwise returns&n; * a non-zero value and queues up a solt isolation event notification.&n; *&n; * It is safe to call this routine in an interrupt context.&n; */
DECL|function|eeh_dn_check_failure
r_int
id|eeh_dn_check_failure
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|rets
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
comma
id|reset_state
suffix:semicolon
r_struct
id|eeh_event
op_star
id|event
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|total_mmio_ffs
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Access to IO BARs might get this far and still not want checking. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
op_logical_or
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_NOCHECK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dn-&gt;eeh_config_addr
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we already have a pending isolation event for this&n;&t; * slot, we know it&squot;s bad already, we don&squot;t need to check...&n;&t; */
r_if
c_cond
(paren
id|dn-&gt;eeh_mode
op_amp
id|EEH_MODE_ISOLATED
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|eeh_fail_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|eeh_fail_count
)paren
op_ge
id|EEH_MAX_FAILS
)paren
(brace
multiline_comment|/* re-read the slot reset state */
r_if
c_cond
(paren
id|read_slot_reset_state
c_func
(paren
id|dn
comma
id|rets
)paren
op_ne
l_int|0
)paren
id|rets
(braket
l_int|0
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* reset state unknown */
id|eeh_panic
c_func
(paren
id|dev
comma
id|rets
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now test for an EEH failure.  This is VERY expensive.&n;&t; * Note that the eeh_config_addr may be a parent device&n;&t; * in the case of a device behind a bridge, or it may be&n;&t; * function zero of a multi-function device.&n;&t; * In any case they must share a common PHB.&n;&t; */
id|ret
op_assign
id|read_slot_reset_state
c_func
(paren
id|dn
comma
id|rets
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|rets
(braket
l_int|1
)braket
op_eq
l_int|1
op_logical_and
(paren
id|rets
(braket
l_int|0
)braket
op_eq
l_int|2
op_logical_or
id|rets
(braket
l_int|0
)braket
op_eq
l_int|4
)paren
)paren
)paren
(brace
id|__get_cpu_var
c_func
(paren
id|false_positives
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* prevent repeated reports of this failure */
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_ISOLATED
suffix:semicolon
id|reset_state
op_assign
id|rets
(braket
l_int|0
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|slot_errbuf_lock
comma
id|flags
)paren
suffix:semicolon
id|memset
c_func
(paren
id|slot_errbuf
comma
l_int|0
comma
id|eeh_error_buf_size
)paren
suffix:semicolon
id|rc
op_assign
id|rtas_call
c_func
(paren
id|ibm_slot_error_detail
comma
l_int|8
comma
l_int|1
comma
l_int|NULL
comma
id|dn-&gt;eeh_config_addr
comma
id|BUID_HI
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
id|BUID_LO
c_func
(paren
id|dn-&gt;phb-&gt;buid
)paren
comma
l_int|NULL
comma
l_int|0
comma
id|virt_to_phys
c_func
(paren
id|slot_errbuf
)paren
comma
id|eeh_error_buf_size
comma
l_int|1
multiline_comment|/* Temporary Error */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|log_error
c_func
(paren
id|slot_errbuf
comma
id|ERR_TYPE_RTAS_LOG
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|slot_errbuf_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: MMIO failure (%d) on device: %s %s&bslash;n&quot;
comma
id|rets
(braket
l_int|0
)braket
comma
id|dn-&gt;name
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|event
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|event
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
l_int|NULL
)paren
(brace
id|eeh_panic
c_func
(paren
id|dev
comma
id|reset_state
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|event-&gt;dev
op_assign
id|dev
suffix:semicolon
id|event-&gt;dn
op_assign
id|dn
suffix:semicolon
id|event-&gt;reset_state
op_assign
id|reset_state
suffix:semicolon
multiline_comment|/* We may or may not be called in an interrupt context */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|eeh_eventlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|event-&gt;list
comma
op_amp
id|eeh_eventlist
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|eeh_eventlist_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Most EEH events are due to device driver bugs.  Having&n;&t; * a stack trace will help the device-driver authors figure&n;&t; * out what happened.  So print that out. */
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|eeh_event_wq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|eeh_dn_check_failure
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_dn_check_failure
)paren
suffix:semicolon
multiline_comment|/**&n; * eeh_check_failure - check if all 1&squot;s data is due to EEH slot freeze&n; * @token i/o token, should be address in the form 0xA....&n; * @val value, should be all 1&squot;s (XXX why do we need this arg??)&n; *&n; * Check for an eeh failure at the given token address.&n; * Check for an EEH failure at the given token address.  Call this&n; * routine if the result of a read was all 0xff&squot;s and you want to&n; * find out if this is due to an EEH slot freeze event.  This routine&n; * will query firmware for the EEH status.&n; *&n; * Note this routine is safe to call in an interrupt context.&n; */
DECL|function|eeh_check_failure
r_int
r_int
id|eeh_check_failure
c_func
(paren
r_const
r_volatile
r_void
id|__iomem
op_star
id|token
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
multiline_comment|/* Finding the phys addr + pci device; this is pretty quick. */
id|addr
op_assign
id|eeh_token_to_phys
c_func
(paren
(paren
r_int
r_int
id|__force
)paren
id|token
)paren
suffix:semicolon
id|dev
op_assign
id|pci_get_device_by_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|val
suffix:semicolon
id|dn
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eeh_dn_check_failure
(paren
id|dn
comma
id|dev
)paren
suffix:semicolon
id|pci_dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|variable|eeh_check_failure
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_check_failure
)paren
suffix:semicolon
DECL|struct|eeh_early_enable_info
r_struct
id|eeh_early_enable_info
(brace
DECL|member|buid_hi
r_int
r_int
id|buid_hi
suffix:semicolon
DECL|member|buid_lo
r_int
r_int
id|buid_lo
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Enable eeh for the given device node. */
DECL|function|early_enable_eeh
r_static
r_void
op_star
id|early_enable_eeh
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|eeh_early_enable_info
op_star
id|info
op_assign
id|data
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|status
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;status&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|u32
op_star
id|class_code
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;class-code&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|u32
op_star
id|vendor_id
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;vendor-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|u32
op_star
id|device_id
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;device-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|u32
op_star
id|regs
suffix:semicolon
r_int
id|enable
suffix:semicolon
id|dn-&gt;eeh_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
id|strcmp
c_func
(paren
id|status
comma
l_string|&quot;ok&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* ignore devices with bad status */
multiline_comment|/* Ignore bad nodes. */
r_if
c_cond
(paren
op_logical_neg
id|class_code
op_logical_or
op_logical_neg
id|vendor_id
op_logical_or
op_logical_neg
id|device_id
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* There is nothing to check on PCI to ISA bridges */
r_if
c_cond
(paren
id|dn-&gt;type
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|dn-&gt;type
comma
l_string|&quot;isa&quot;
)paren
)paren
(brace
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_NOCHECK
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now decide if we are going to &quot;Disable&quot; EEH checking&n;&t; * for this device.  We still run with the EEH hardware active,&n;&t; * but we won&squot;t be checking for ff&squot;s.  This means a driver&n;&t; * could return bad data (very bad!), an interrupt handler could&n;&t; * hang waiting on status bits that won&squot;t change, etc.&n;&t; * But there are a few cases like display devices that make sense.&n;&t; */
id|enable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* i.e. we will do checking */
r_if
c_cond
(paren
(paren
op_star
id|class_code
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enable
)paren
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_NOCHECK
suffix:semicolon
multiline_comment|/* Ok... see if this device supports EEH.  Some do, some don&squot;t,&n;&t; * and the only way to find out is to check each and every one. */
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs
)paren
(brace
multiline_comment|/* First register entry is addr (00BBSS00)  */
multiline_comment|/* Try to enable eeh */
id|ret
op_assign
id|rtas_call
c_func
(paren
id|ibm_set_eeh_option
comma
l_int|4
comma
l_int|1
comma
l_int|NULL
comma
id|regs
(braket
l_int|0
)braket
comma
id|info-&gt;buid_hi
comma
id|info-&gt;buid_lo
comma
id|EEH_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|eeh_subsystem_enabled
op_assign
l_int|1
suffix:semicolon
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_SUPPORTED
suffix:semicolon
id|dn-&gt;eeh_config_addr
op_assign
id|regs
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: %s: eeh enabled&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* This device doesn&squot;t support EEH, but it may have an&n;&t;&t;&t; * EEH parent, in which case we mark it as supported. */
r_if
c_cond
(paren
id|dn-&gt;parent
op_logical_and
(paren
id|dn-&gt;parent-&gt;eeh_mode
op_amp
id|EEH_MODE_SUPPORTED
)paren
)paren
(brace
multiline_comment|/* Parent supports EEH. */
id|dn-&gt;eeh_mode
op_or_assign
id|EEH_MODE_SUPPORTED
suffix:semicolon
id|dn-&gt;eeh_config_addr
op_assign
id|dn-&gt;parent-&gt;eeh_config_addr
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: %s: unable to get reg property.&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize EEH by trying to enable it for all of the adapters in the system.&n; * As a side effect we can determine here if eeh is supported at all.&n; * Note that we leave EEH on so failed config cycles won&squot;t cause a machine&n; * check.  If a user turns off EEH for a particular adapter they are really&n; * telling Linux to ignore errors.  Some hardware (e.g. POWER5) won&squot;t&n; * grant access to a slot if EEH isn&squot;t enabled, and so we always enable&n; * EEH for all slots/all devices.&n; *&n; * The eeh-force-off option disables EEH checking globally, for all slots.&n; * Even if force-off is set, the EEH hardware is still enabled, so that&n; * newer systems can boot.&n; */
DECL|function|eeh_init
r_void
id|__init
id|eeh_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|phb
comma
op_star
id|np
suffix:semicolon
r_struct
id|eeh_early_enable_info
id|info
suffix:semicolon
id|np
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|ibm_set_eeh_option
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,set-eeh-option&quot;
)paren
suffix:semicolon
id|ibm_set_slot_reset
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,set-slot-reset&quot;
)paren
suffix:semicolon
id|ibm_read_slot_reset_state2
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,read-slot-reset-state2&quot;
)paren
suffix:semicolon
id|ibm_read_slot_reset_state
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,read-slot-reset-state&quot;
)paren
suffix:semicolon
id|ibm_slot_error_detail
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;ibm,slot-error-detail&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibm_set_eeh_option
op_eq
id|RTAS_UNKNOWN_SERVICE
)paren
r_return
suffix:semicolon
id|eeh_error_buf_size
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;rtas-error-log-max&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeh_error_buf_size
op_eq
id|RTAS_UNKNOWN_SERVICE
)paren
(brace
id|eeh_error_buf_size
op_assign
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeh_error_buf_size
OG
id|RTAS_ERROR_LOG_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: rtas-error-log-max is bigger than allocated &quot;
l_string|&quot;buffer ! (%d vs %d)&quot;
comma
id|eeh_error_buf_size
comma
id|RTAS_ERROR_LOG_MAX
)paren
suffix:semicolon
id|eeh_error_buf_size
op_assign
id|RTAS_ERROR_LOG_MAX
suffix:semicolon
)brace
multiline_comment|/* Enable EEH for all adapters.  Note that eeh requires buid&squot;s */
r_for
c_loop
(paren
id|phb
op_assign
id|of_find_node_by_name
c_func
(paren
l_int|NULL
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
id|phb
suffix:semicolon
id|phb
op_assign
id|of_find_node_by_name
c_func
(paren
id|phb
comma
l_string|&quot;pci&quot;
)paren
)paren
(brace
r_int
r_int
id|buid
suffix:semicolon
id|buid
op_assign
id|get_phb_buid
c_func
(paren
id|phb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buid
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|info.buid_lo
op_assign
id|BUID_LO
c_func
(paren
id|buid
)paren
suffix:semicolon
id|info.buid_hi
op_assign
id|BUID_HI
c_func
(paren
id|buid
)paren
suffix:semicolon
id|traverse_pci_devices
c_func
(paren
id|phb
comma
id|early_enable_eeh
comma
op_amp
id|info
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeh_subsystem_enabled
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EEH: PCI Enhanced I/O Error Handling Enabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: No capable adapters found&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * eeh_add_device_early - enable EEH for the indicated device_node&n; * @dn: device node for which to set up EEH&n; *&n; * This routine must be used to perform EEH initialization for PCI&n; * devices that were added after system boot (e.g. hotplug, dlpar).&n; * This routine must be called before any i/o is performed to the&n; * adapter (inluding any config-space i/o).&n; * Whether this actually enables EEH or not for this device depends&n; * on the CEC architecture, type of the device, on earlier boot&n; * command-line arguments &amp; etc.&n; */
DECL|function|eeh_add_device_early
r_void
id|eeh_add_device_early
c_func
(paren
r_struct
id|device_node
op_star
id|dn
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_struct
id|eeh_early_enable_info
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dn
op_logical_or
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
suffix:semicolon
id|phb
op_assign
id|dn-&gt;phb
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|phb
op_logical_or
l_int|0
op_eq
id|phb-&gt;buid
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEH: Expected buid but found none&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info.buid_hi
op_assign
id|BUID_HI
c_func
(paren
id|phb-&gt;buid
)paren
suffix:semicolon
id|info.buid_lo
op_assign
id|BUID_LO
c_func
(paren
id|phb-&gt;buid
)paren
suffix:semicolon
id|early_enable_eeh
c_func
(paren
id|dn
comma
op_amp
id|info
)paren
suffix:semicolon
)brace
DECL|variable|eeh_add_device_early
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_add_device_early
)paren
suffix:semicolon
multiline_comment|/**&n; * eeh_add_device_late - perform EEH initialization for the indicated pci device&n; * @dev: pci device for which to set up EEH&n; *&n; * This routine must be used to complete EEH initialization for PCI&n; * devices that were added after system boot (e.g. hotplug, dlpar).&n; */
DECL|function|eeh_add_device_late
r_void
id|eeh_add_device_late
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: adding device %s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|pci_addr_cache_insert_device
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|eeh_add_device_late
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_add_device_late
)paren
suffix:semicolon
multiline_comment|/**&n; * eeh_remove_device - undo EEH setup for the indicated pci device&n; * @dev: pci device to be removed&n; *&n; * This routine should be when a device is removed from a running&n; * system (e.g. by hotplug or dlpar).&n; */
DECL|function|eeh_remove_device
r_void
id|eeh_remove_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|eeh_subsystem_enabled
)paren
r_return
suffix:semicolon
multiline_comment|/* Unregister the device with the EEH/PCI address search system */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EEH: remove device %s %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|pci_pretty_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|pci_addr_cache_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|eeh_remove_device
id|EXPORT_SYMBOL
c_func
(paren
id|eeh_remove_device
)paren
suffix:semicolon
DECL|function|proc_eeh_show
r_static
r_int
id|proc_eeh_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
r_int
id|ffs
op_assign
l_int|0
comma
id|positives
op_assign
l_int|0
comma
id|failures
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|resets
op_assign
l_int|0
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|cpu
)paren
(brace
id|ffs
op_add_assign
id|per_cpu
c_func
(paren
id|total_mmio_ffs
comma
id|cpu
)paren
suffix:semicolon
id|positives
op_add_assign
id|per_cpu
c_func
(paren
id|false_positives
comma
id|cpu
)paren
suffix:semicolon
id|failures
op_add_assign
id|per_cpu
c_func
(paren
id|ignored_failures
comma
id|cpu
)paren
suffix:semicolon
id|resets
op_add_assign
id|per_cpu
c_func
(paren
id|slot_resets
comma
id|cpu
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_eq
id|eeh_subsystem_enabled
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;EEH Subsystem is globally disabled&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;eeh_total_mmio_ffs=%ld&bslash;n&quot;
comma
id|ffs
)paren
suffix:semicolon
)brace
r_else
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;EEH Subsystem is enabled&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;eeh_total_mmio_ffs=%ld&bslash;n&quot;
l_string|&quot;eeh_false_positives=%ld&bslash;n&quot;
l_string|&quot;eeh_ignored_failures=%ld&bslash;n&quot;
l_string|&quot;eeh_slot_resets=%ld&bslash;n&quot;
l_string|&quot;eeh_fail_count=%d&bslash;n&quot;
comma
id|ffs
comma
id|positives
comma
id|failures
comma
id|resets
comma
id|eeh_fail_count.counter
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|proc_eeh_open
r_static
r_int
id|proc_eeh_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|proc_eeh_show
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|proc_eeh_operations
r_static
r_struct
id|file_operations
id|proc_eeh_operations
op_assign
(brace
dot
id|open
op_assign
id|proc_eeh_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
DECL|function|eeh_init_proc
r_static
r_int
id|__init
id|eeh_init_proc
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_amp
id|PLATFORM_PSERIES
)paren
(brace
id|e
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;ppc64/eeh&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
id|e-&gt;proc_fops
op_assign
op_amp
id|proc_eeh_operations
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|eeh_init_proc
id|__initcall
c_func
(paren
id|eeh_init_proc
)paren
suffix:semicolon
eof
