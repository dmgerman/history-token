multiline_comment|/*&n; * pci_dn.c&n; *&n; * Copyright (C) 2001 Todd Inglett, IBM Corporation&n; *&n; * PCI manipulation via device_nodes.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *    &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/init.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/pci_dma.h&gt;
macro_line|#include &quot;pci.h&quot;
multiline_comment|/* Traverse_func that inits the PCI fields of the device node.&n; * NOTE: this *must* be done before read/write config to the device.&n; */
r_static
r_void
op_star
id|__init
DECL|function|update_dn_pci_info
id|update_dn_pci_info
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
op_assign
(paren
r_struct
id|pci_controller
op_star
)paren
id|data
suffix:semicolon
id|u32
op_star
id|regs
suffix:semicolon
r_char
op_star
id|device_type
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
id|dn-&gt;phb
op_assign
id|phb
suffix:semicolon
r_if
c_cond
(paren
id|device_type
op_logical_and
id|strcmp
c_func
(paren
id|device_type
comma
l_string|&quot;pci&quot;
)paren
op_eq
l_int|0
op_logical_and
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;class-code&quot;
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* special case for PHB&squot;s.  Sigh. */
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;bus-range&quot;
comma
l_int|0
)paren
suffix:semicolon
id|dn-&gt;busno
op_assign
id|regs
(braket
l_int|0
)braket
suffix:semicolon
id|dn-&gt;devfn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assumption */
)brace
r_else
(brace
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;reg&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs
)paren
(brace
multiline_comment|/* First register entry is addr (00BBSS00)  */
id|dn-&gt;busno
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dn-&gt;devfn
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Hit all the BARs of all the devices with values from OF.&n; * This is unnecessary on most systems, but also harmless.&n; */
r_static
r_void
op_star
id|__init
DECL|function|write_OF_bars
id|write_OF_bars
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|oldbar
comma
id|newbar
comma
id|newbartest
suffix:semicolon
id|u8
id|config_offset
suffix:semicolon
r_char
op_star
id|name
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;name&quot;
comma
l_int|0
)paren
suffix:semicolon
r_char
op_star
id|device_type
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
r_char
id|devname
(braket
l_int|128
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;%04x:%02x.%x %s (%s)&quot;
comma
id|dn-&gt;busno
comma
id|PCI_SLOT
c_func
(paren
id|dn-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dn-&gt;devfn
)paren
comma
id|name
ques
c_cond
id|name
suffix:colon
l_string|&quot;&lt;no name&gt;&quot;
comma
id|device_type
ques
c_cond
id|device_type
suffix:colon
l_string|&quot;&lt;unknown type&gt;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_type
op_logical_and
id|strcmp
c_func
(paren
id|device_type
comma
l_string|&quot;pci&quot;
)paren
op_eq
l_int|0
op_logical_and
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;class-code&quot;
comma
l_int|0
)paren
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* This is probably a phb.  Skip it. */
r_if
c_cond
(paren
id|dn-&gt;n_addrs
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* This is normal for some adapters or bridges */
r_if
c_cond
(paren
id|dn-&gt;addrs
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This shouldn&squot;t happen. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_OF_bars %s: device has %d BARs, but no addrs recorded&bslash;n&quot;
comma
id|devname
comma
id|dn-&gt;n_addrs
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_PPC_ISERIES 
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dn-&gt;n_addrs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|newbar
op_assign
id|dn-&gt;addrs
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|config_offset
op_assign
id|dn-&gt;addrs
(braket
id|i
)braket
dot
id|space
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md
dot
id|pcibios_read_config_dword
c_func
(paren
id|dn
comma
id|config_offset
comma
op_amp
id|oldbar
)paren
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_OF_bars %s: read BAR%d failed&bslash;n&quot;
comma
id|devname
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Need to update this BAR. */
r_if
c_cond
(paren
id|ppc_md
dot
id|pcibios_write_config_dword
c_func
(paren
id|dn
comma
id|config_offset
comma
id|newbar
)paren
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_OF_bars %s: write BAR%d with 0x%08x failed (old was 0x%08x)&bslash;n&quot;
comma
id|devname
comma
id|i
comma
id|newbar
comma
id|oldbar
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|ppc_md
dot
id|pcibios_read_config_dword
c_func
(paren
id|dn
comma
id|config_offset
comma
op_amp
id|newbartest
)paren
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_OF_bars %s: sanity test read BAR%d failed?&bslash;n&quot;
comma
id|devname
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|newbar
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_ne
(paren
id|newbartest
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_OF_bars %s: oops...BAR%d read back as 0x%08x%s!&bslash;n&quot;
comma
id|devname
comma
id|i
comma
id|newbartest
comma
(paren
id|oldbar
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_eq
(paren
id|newbartest
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
ques
c_cond
l_string|&quot; (original value)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Traverse_func that starts the BIST (self test) */
r_static
r_void
op_star
id|__init
id|startBIST
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
op_assign
(paren
r_struct
id|pci_controller
op_star
)paren
id|data
suffix:semicolon
id|u8
id|bist
suffix:semicolon
r_char
op_star
id|name
op_assign
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;name&quot;
comma
l_int|0
)paren
suffix:semicolon
id|udbg_printf
c_func
(paren
l_string|&quot;startBIST: %s phb=%p, device=%p&bslash;n&quot;
comma
id|name
ques
c_cond
id|name
suffix:colon
l_string|&quot;&lt;unknown&gt;&quot;
comma
id|phb
comma
id|dn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md
dot
id|pcibios_read_config_byte
c_func
(paren
id|dn
comma
id|PCI_BIST
comma
op_amp
id|bist
)paren
op_eq
id|PCIBIOS_SUCCESSFUL
)paren
(brace
r_if
c_cond
(paren
id|bist
op_amp
id|PCI_BIST_CAPABLE
)paren
(brace
id|udbg_printf
c_func
(paren
l_string|&quot;  -&gt; is BIST capable!&bslash;n&quot;
comma
id|phb
comma
id|dn
)paren
suffix:semicolon
multiline_comment|/* Start bist here */
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/******************************************************************&n; * Traverse a device tree stopping each PCI device in the tree.&n; * This is done depth first.  As each node is processed, a &quot;pre&quot;&n; * function is called, the children are processed recursively, and&n; * then a &quot;post&quot; function is called.&n; *&n; * The &quot;pre&quot; and &quot;post&quot; funcs return a value.  If non-zero&n; * is returned from the &quot;pre&quot; func, the traversal stops and this&n; * value is returned.  The return value from &quot;post&quot; is not used.&n; * This return value is useful when using traverse as&n; * a method of finding a device.&n; *&n; * NOTE: we do not run the funcs for devices that do not appear to&n; * be PCI except for the start node which we assume (this is good&n; * because the start node is often a phb which may be missing PCI&n; * properties).&n; * We use the class-code as an indicator. If we run into&n; * one of these nodes we also assume its siblings are non-pci for&n; * performance.&n; *&n; ******************************************************************/
DECL|function|traverse_pci_devices
r_void
op_star
id|traverse_pci_devices
c_func
(paren
r_struct
id|device_node
op_star
id|start
comma
id|traverse_func
id|pre
comma
id|traverse_func
id|post
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|device_node
op_star
id|dn
comma
op_star
id|nextdn
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|pre
op_logical_and
(paren
id|ret
op_assign
id|pre
c_func
(paren
id|start
comma
id|data
)paren
)paren
op_ne
l_int|NULL
)paren
r_return
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|dn
op_assign
id|start-&gt;child
suffix:semicolon
id|dn
suffix:semicolon
id|dn
op_assign
id|nextdn
)paren
(brace
id|nextdn
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;class-code&quot;
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|pre
op_logical_and
(paren
id|ret
op_assign
id|pre
c_func
(paren
id|dn
comma
id|data
)paren
)paren
op_ne
l_int|NULL
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dn-&gt;child
)paren
(brace
multiline_comment|/* Depth first...do children */
id|nextdn
op_assign
id|dn-&gt;child
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dn-&gt;sibling
)paren
(brace
multiline_comment|/* ok, try next sibling instead. */
id|nextdn
op_assign
id|dn-&gt;sibling
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no more children or siblings...call &quot;post&quot; */
r_if
c_cond
(paren
id|post
)paren
id|post
c_func
(paren
id|dn
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|nextdn
)paren
(brace
multiline_comment|/* Walk up to next valid sibling. */
r_do
(brace
id|dn
op_assign
id|dn-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|dn
op_eq
id|start
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dn-&gt;sibling
op_eq
l_int|NULL
)paren
suffix:semicolon
id|nextdn
op_assign
id|dn-&gt;sibling
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Same as traverse_pci_devices except this does it for all phbs.&n; */
DECL|function|traverse_all_pci_devices
r_void
op_star
id|traverse_all_pci_devices
c_func
(paren
id|traverse_func
id|pre
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|phb
op_assign
id|hose_head
suffix:semicolon
id|phb
suffix:semicolon
id|phb
op_assign
id|phb-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|traverse_pci_devices
c_func
(paren
(paren
r_struct
id|device_node
op_star
)paren
id|phb-&gt;arch_data
comma
id|pre
comma
l_int|NULL
comma
id|phb
)paren
)paren
op_ne
l_int|NULL
)paren
r_return
id|ret
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Traversal func that looks for a &lt;busno,devfcn&gt; value.&n; * If found, the device_node is returned (thus terminating the traversal).&n; */
r_static
r_void
op_star
DECL|function|is_devfn_node
id|is_devfn_node
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|busno
op_assign
(paren
(paren
r_int
r_int
)paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_int
id|devfn
op_assign
(paren
(paren
r_int
r_int
)paren
id|data
)paren
op_amp
l_int|0xff
suffix:semicolon
r_return
(paren
id|devfn
op_eq
id|dn-&gt;devfn
op_logical_and
id|busno
op_eq
id|dn-&gt;busno
)paren
ques
c_cond
id|dn
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Same as is_devfn_node except ignore the &quot;fn&quot; part of the &quot;devfn&quot;.&n; */
r_static
r_void
op_star
DECL|function|is_devfn_sub_node
id|is_devfn_sub_node
c_func
(paren
r_struct
id|device_node
op_star
id|dn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|busno
op_assign
(paren
(paren
r_int
r_int
)paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_int
id|devfn
op_assign
(paren
(paren
r_int
r_int
)paren
id|data
)paren
op_amp
l_int|0xf8
suffix:semicolon
r_return
(paren
id|devfn
op_eq
(paren
id|dn-&gt;devfn
op_amp
l_int|0xf8
)paren
op_logical_and
id|busno
op_eq
id|dn-&gt;busno
)paren
ques
c_cond
id|dn
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Given an existing EADs (pci bridge) device node create a fake one&n; * that will simulate function zero.  Make it a sibling of other_eads.&n; */
r_static
r_struct
id|device_node
op_star
DECL|function|create_eads_node
id|create_eads_node
c_func
(paren
r_struct
id|device_node
op_star
id|other_eads
)paren
(brace
r_struct
id|device_node
op_star
id|eads
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eads
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* huh? */
op_star
id|eads
op_assign
op_star
id|other_eads
suffix:semicolon
id|eads-&gt;devfn
op_and_assign
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* make it function zero */
id|eads-&gt;tce_table
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NOTE: share properties.  We could copy but for now this should suffice.&n;&t; * The full_name is also incorrect...but seems harmless.&n;&t; */
id|eads-&gt;child
op_assign
l_int|NULL
suffix:semicolon
id|eads-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|other_eads-&gt;allnext
op_assign
id|eads
suffix:semicolon
id|other_eads-&gt;sibling
op_assign
id|eads
suffix:semicolon
r_return
id|eads
suffix:semicolon
)brace
multiline_comment|/* This is the &quot;slow&quot; path for looking up a device_node from a&n; * pci_dev.  It will hunt for the device under it&squot;s parent&squot;s&n; * phb and then update sysdata for a future fastpath.&n; *&n; * It may also do fixups on the actual device since this happens&n; * on the first read/write.&n; *&n; * Note that it also must deal with devices that don&squot;t exist.&n; * In this case it may probe for real hardware (&quot;just in case&quot;)&n; * and add a device_node to the device tree if necessary.&n; *&n; */
DECL|function|fetch_dev_dn
r_struct
id|device_node
op_star
id|fetch_dev_dn
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|device_node
op_star
id|orig_dn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|dev-&gt;sysdata
suffix:semicolon
r_struct
id|pci_controller
op_star
id|phb
op_assign
id|orig_dn-&gt;phb
suffix:semicolon
multiline_comment|/* assume same phb as orig_dn */
r_struct
id|device_node
op_star
id|phb_dn
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_int
r_int
id|searchval
op_assign
(paren
id|dev-&gt;bus-&gt;number
op_lshift
l_int|8
)paren
op_or
id|dev-&gt;devfn
suffix:semicolon
id|phb_dn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|phb-&gt;arch_data
)paren
suffix:semicolon
id|dn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|traverse_pci_devices
c_func
(paren
id|phb_dn
comma
id|is_devfn_node
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|searchval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dn
)paren
(brace
id|dev-&gt;sysdata
op_assign
id|dn
suffix:semicolon
multiline_comment|/* ToDo: call some device init hook here */
)brace
r_else
(brace
multiline_comment|/* Now it is very possible that we can&squot;t find the device because it is&n;&t;&t; * not the zero&squot;th device of a mutifunction device and we don&squot;t have&n;&t;&t; * permission to read the zero&squot;th device.  If this is the case, Linux&n;&t;&t; * would ordinarily skip all the other functions.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|searchval
op_amp
l_int|0x7
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|device_node
op_star
id|thisdevdn
suffix:semicolon
multiline_comment|/* Ok, we are looking for fn == 0.  Let&squot;s check for other functions. */
id|thisdevdn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|traverse_pci_devices
c_func
(paren
id|phb_dn
comma
id|is_devfn_sub_node
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|searchval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisdevdn
)paren
(brace
multiline_comment|/* Ah ha!  There does exist a sub function.  Now this isn&squot;t an exact&n;&t;&t;&t;&t; * match for searchval, but in order to get Linux to believe the sub&n;&t;&t;&t;&t; * functions exist we will need to manufacture a fake device_node&n;&t;&t;&t;&t; * for this zero&squot;th function.  To keept this simple for now we only&n;&t;&t;&t;&t; * handle pci bridges and we just hand back the found node which&n;&t;&t;&t;&t; * isn&squot;t correct, but Linux won&squot;t care.&n;&t;&t;&t;&t; */
r_char
op_star
id|device_type
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|thisdevdn
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_type
op_logical_and
id|strcmp
c_func
(paren
id|device_type
comma
l_string|&quot;pci&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_return
id|create_eads_node
c_func
(paren
id|thisdevdn
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ToDo: device not found...probe for it anyway with a fake dn?&n;&t;&t;struct device_node fake_dn;&n;&t;&t;memset(&amp;fake_dn, 0, sizeof(fake_dn));&n;&t;&t;fake_dn.phb = phb;&n;&t;&t;fake_dn.busno = dev-&gt;bus-&gt;number;&n;&t;&t;fake_dn.devfn = dev-&gt;devfn;&n;&t;&t;... now do ppc_md.pcibios_read_config_dword(&amp;fake_dn.....)&n;&t;&t; ... if ok, alloc a real device_node and dn = real_dn;&n;&t;&t; */
)brace
r_return
id|dn
suffix:semicolon
)brace
multiline_comment|/******************************************************************&n; * Actually initialize the phbs.&n; * The buswalk on this phb has not happened yet.&n; ******************************************************************/
r_void
id|__init
DECL|function|pci_devs_phb_init
id|pci_devs_phb_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* This must be done first so the device nodes have valid pci info! */
id|traverse_all_pci_devices
c_func
(paren
id|update_dn_pci_info
)paren
suffix:semicolon
multiline_comment|/* Hack for regatta which does not init the bars correctly */
id|traverse_all_pci_devices
c_func
(paren
id|write_OF_bars
)paren
suffix:semicolon
macro_line|#if 0
id|traverse_all_pci_devices
c_func
(paren
id|startBIST
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5000
)paren
suffix:semicolon
id|traverse_all_pci_devices
c_func
(paren
id|checkBIST
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
id|__init
DECL|function|pci_fixup_bus_sysdata_list
id|pci_fixup_bus_sysdata_list
c_func
(paren
r_struct
id|list_head
op_star
id|bus_list
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_int
id|newnum
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|bus_list-&gt;next
suffix:semicolon
id|ln
op_ne
id|bus_list
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|bus
op_assign
id|pci_bus_b
c_func
(paren
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
id|bus-&gt;sysdata
op_assign
id|bus-&gt;self-&gt;sysdata
suffix:semicolon
multiline_comment|/* Also fixup the bus number on large bus systems to&n;&t;&t;&t; * include the PHB# in the next byte&n;&t;&t;&t; */
id|phb
op_assign
id|PCI_GET_DN
c_func
(paren
id|bus
)paren
op_member_access_from_pointer
id|phb
suffix:semicolon
r_if
c_cond
(paren
id|phb
op_logical_and
id|phb-&gt;buid
)paren
(brace
id|newnum
op_assign
(paren
id|phb-&gt;global_number
op_lshift
l_int|8
)paren
op_or
id|bus-&gt;number
suffix:semicolon
id|bus-&gt;number
op_assign
id|newnum
suffix:semicolon
id|sprintf
c_func
(paren
id|bus-&gt;name
comma
l_string|&quot;PCI Bus #%x&quot;
comma
id|bus-&gt;number
)paren
suffix:semicolon
)brace
)brace
id|pci_fixup_bus_sysdata_list
c_func
(paren
op_amp
id|bus-&gt;children
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************&n; * Fixup the bus-&gt;sysdata ptrs to point to the bus&squot; device_node.&n; * This is done late in pcibios_init().  We do this mostly for&n; * sanity, but pci_dma.c uses these at DMA time so they must be&n; * correct.&n; * To do this we recurse down the bus hierarchy.  Note that PHB&squot;s&n; * have bus-&gt;self == NULL, but fortunately bus-&gt;sysdata is already&n; * correct in this case.&n; ******************************************************************/
r_void
id|__init
DECL|function|pci_fix_bus_sysdata
id|pci_fix_bus_sysdata
c_func
(paren
r_void
)paren
(brace
id|pci_fixup_bus_sysdata_list
c_func
(paren
op_amp
id|pci_root_buses
)paren
suffix:semicolon
)brace
eof
