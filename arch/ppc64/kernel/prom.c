multiline_comment|/*&n; * &n; *&n; * Procedures for interfacing to Open Firmware.&n; *&n; * Paul Mackerras&t;August 1996.&n; * Copyright (C) 1996 Paul Mackerras.&n; * &n; *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.&n; *    {engebret|bergner}@us.ibm.com &n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#if 0
mdefine_line|#define DEBUG_PROM
macro_line|#endif
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/lmb.h&gt;
macro_line|#include &lt;asm/abs_addr.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/pci_dma.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &quot;open_pic.h&quot;
macro_line|#ifdef CONFIG_LOGO_LINUX_CLUT224
macro_line|#include &lt;linux/linux_logo.h&gt;
r_extern
r_const
r_struct
id|linux_logo
id|logo_linux_clut224
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * prom_init() is called very early on, before the kernel text&n; * and data have been mapped to KERNELBASE.  At this point the code&n; * is running at whatever address it has been loaded at, so&n; * references to extern and static variables must be relocated&n; * explicitly.  The procedure reloc_offset() returns the address&n; * we&squot;re currently running at minus the address we were linked at.&n; * (Note that strings count as static variables.)&n; *&n; * Because OF may have mapped I/O devices into the area starting at&n; * KERNELBASE, particularly on CHRP machines, we can&squot;t safely call&n; * OF once the kernel has been mapped to KERNELBASE.  Therefore all&n; * OF calls should be done within prom_init(), and prom_init()&n; * and all routines called within it must be careful to relocate&n; * references as necessary.&n; *&n; * Note that the bss is cleared *after* prom_init runs, so we have&n; * to make sure that any static or extern variables it accesses&n; * are put in the data segment.&n; */
DECL|macro|PROM_BUG
mdefine_line|#define PROM_BUG() do { &bslash;&n;        prom_print(RELOC(&quot;kernel BUG at &quot;)); &bslash;&n;        prom_print(RELOC(__FILE__)); &bslash;&n;        prom_print(RELOC(&quot;:&quot;)); &bslash;&n;        prom_print_hex(__LINE__); &bslash;&n;        prom_print(RELOC(&quot;!&bslash;n&quot;)); &bslash;&n;        __asm__ __volatile__(&quot;.long &quot; BUG_ILLEGAL_INSTR); &bslash;&n;} while (0)
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
id|u32
id|size_hi
suffix:semicolon
DECL|member|size_lo
id|u32
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|isa_reg_property
r_struct
id|isa_reg_property
(brace
DECL|member|space
id|u32
id|space
suffix:semicolon
DECL|member|address
id|u32
id|address
suffix:semicolon
DECL|member|size
id|u32
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_intr_map
r_struct
id|pci_intr_map
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|dunno
id|u32
id|dunno
suffix:semicolon
DECL|member|int_ctrler
id|phandle
id|int_ctrler
suffix:semicolon
DECL|member|intr
id|u32
id|intr
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|interpret_func
r_typedef
r_int
r_int
id|interpret_func
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|variable|interpret_pci_props
r_static
id|interpret_func
id|interpret_pci_props
suffix:semicolon
DECL|variable|interpret_isa_props
r_static
id|interpret_func
id|interpret_isa_props
suffix:semicolon
DECL|variable|interpret_root_props
r_static
id|interpret_func
id|interpret_root_props
suffix:semicolon
DECL|variable|interpret_dbdma_props
r_static
id|interpret_func
id|interpret_dbdma_props
suffix:semicolon
DECL|variable|interpret_macio_props
r_static
id|interpret_func
id|interpret_macio_props
suffix:semicolon
macro_line|#ifndef FB_MAX&t;&t;&t;/* avoid pulling in all of the fb stuff */
DECL|macro|FB_MAX
mdefine_line|#define FB_MAX&t;8
macro_line|#endif
multiline_comment|/* prom structure */
DECL|variable|prom
r_struct
id|prom_t
id|prom
suffix:semicolon
DECL|variable|__initdata
r_char
op_star
id|prom_display_paths
(braket
id|FB_MAX
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|prom_num_displays
r_int
r_int
id|prom_num_displays
op_assign
l_int|0
suffix:semicolon
DECL|variable|of_stdout_device
r_char
op_star
id|of_stdout_device
op_assign
l_int|0
suffix:semicolon
r_extern
r_struct
id|rtas_t
id|rtas
suffix:semicolon
r_extern
r_int
r_int
id|klimit
suffix:semicolon
r_extern
r_struct
id|lmb
id|lmb
suffix:semicolon
DECL|macro|MAX_PHB
mdefine_line|#define MAX_PHB 16 * 3  
singleline_comment|// 16 Towers * 3 PHBs/tower
DECL|variable|of_tce_table
r_struct
id|_of_tce_table
id|of_tce_table
(braket
id|MAX_PHB
op_plus
l_int|1
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|bootpath
r_char
op_star
id|bootpath
op_assign
l_int|0
suffix:semicolon
DECL|variable|bootdevice
r_char
op_star
id|bootdevice
op_assign
l_int|0
suffix:semicolon
DECL|variable|boot_cpuid
r_int
id|boot_cpuid
op_assign
l_int|0
suffix:semicolon
DECL|macro|MAX_CPU_THREADS
mdefine_line|#define MAX_CPU_THREADS 2
DECL|variable|allnodes
r_struct
id|device_node
op_star
id|allnodes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* use when traversing tree through the allnext, child, sibling,&n; * or parent members of struct device_node.&n; */
DECL|variable|devtree_lock
r_static
id|rwlock_t
id|devtree_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|UNDEFINED_IRQ
mdefine_line|#define UNDEFINED_IRQ 0xffff
DECL|variable|real_irq_to_virt_map
r_int
r_int
id|real_irq_to_virt_map
(braket
id|NR_HW_IRQS
)braket
suffix:semicolon
DECL|variable|virt_irq_to_real_map
r_int
r_int
id|virt_irq_to_real_map
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|variable|last_virt_irq
r_int
id|last_virt_irq
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* index of last virt_irq.  Skip through IPI */
r_static
r_int
r_int
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_void
id|prom_panic
c_func
(paren
r_const
r_char
op_star
id|reason
)paren
suffix:semicolon
r_static
r_int
r_int
id|copy_device_tree
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|inspect_node
c_func
(paren
id|phandle
comma
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|device_node
op_star
op_star
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
id|interpret_func
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|finish_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|check_display
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|prom_next_node
c_func
(paren
id|phandle
op_star
)paren
suffix:semicolon
r_static
r_struct
id|bi_record
op_star
id|prom_bi_rec_verify
c_func
(paren
r_struct
id|bi_record
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|prom_bi_rec_reserve
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_struct
id|device_node
op_star
id|find_phandle
c_func
(paren
id|phandle
)paren
suffix:semicolon
r_static
r_void
id|of_node_cleanup
c_func
(paren
r_struct
id|device_node
op_star
)paren
suffix:semicolon
r_static
r_struct
id|device_node
op_star
id|derive_parent
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
)paren
suffix:semicolon
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
)paren
suffix:semicolon
r_static
r_int
id|of_finish_dynamic_node
c_func
(paren
r_struct
id|device_node
op_star
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
r_void
id|prom_dump_lmb
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_int
r_int
id|reloc_offset
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|enter_prom
c_func
(paren
r_void
op_star
id|dummy
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_void
id|copy_and_flush
c_func
(paren
r_int
r_int
id|dest
comma
r_int
r_int
id|src
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
r_extern
r_char
id|cmd_line
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* XXX */
DECL|variable|dev_tree_size
r_int
r_int
id|dev_tree_size
suffix:semicolon
r_int
r_int
id|_get_PIR
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HMT
r_struct
(brace
DECL|member|pir
r_int
r_int
id|pir
suffix:semicolon
DECL|member|threadid
r_int
r_int
id|threadid
suffix:semicolon
DECL|variable|hmt_thread_data
)brace
id|hmt_thread_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif /* CONFIG_HMT */
DECL|variable|testString
r_char
id|testString
(braket
)braket
op_assign
l_string|&quot;LINUX&bslash;n&quot;
suffix:semicolon
multiline_comment|/* This is the one and *ONLY* place where we actually call open&n; * firmware from, since we need to make sure we&squot;re running in 32b&n; * mode when we do.  We switch back to 64b mode upon return.&n; */
r_static
r_int
r_int
id|__init
DECL|function|call_prom
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|va_list
id|list
suffix:semicolon
id|_prom-&gt;args.service
op_assign
(paren
id|u32
)paren
id|LONG_LSW
c_func
(paren
id|service
)paren
suffix:semicolon
id|_prom-&gt;args.nargs
op_assign
id|nargs
suffix:semicolon
id|_prom-&gt;args.nret
op_assign
id|nret
suffix:semicolon
id|_prom-&gt;args.rets
op_assign
(paren
id|prom_arg_t
op_star
)paren
op_amp
(paren
id|_prom-&gt;args.args
(braket
id|nargs
)braket
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
id|i
op_increment
)paren
id|_prom-&gt;args.args
(braket
id|i
)braket
op_assign
(paren
id|prom_arg_t
)paren
id|LONG_LSW
c_func
(paren
id|va_arg
c_func
(paren
id|list
comma
r_int
r_int
)paren
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
id|i
op_increment
)paren
id|_prom-&gt;args.rets
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|enter_prom
c_func
(paren
op_amp
id|_prom-&gt;args
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
(paren
(paren
id|nret
OG
l_int|0
)paren
ques
c_cond
id|_prom-&gt;args.rets
(braket
l_int|0
)braket
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|prom_panic
id|prom_panic
c_func
(paren
r_const
r_char
op_star
id|reason
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|reason
)paren
suffix:semicolon
multiline_comment|/* ToDo: should put up an SRC here */
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;exit&quot;
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
multiline_comment|/* should never get here */
suffix:semicolon
)brace
r_void
id|__init
DECL|function|prom_enter
id|prom_enter
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;enter&quot;
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|prom_print
id|prom_print
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;stdout
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|msg
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
op_ne
l_int|0
op_logical_and
op_star
id|q
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_increment
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
OG
id|p
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;write&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|p
comma
id|q
op_minus
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_ne
l_int|0
)paren
(brace
op_increment
id|q
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;write&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|RELOC
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|prom_print_hex
id|prom_print_hex
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
id|i
comma
id|nibbles
op_assign
r_sizeof
(paren
id|val
)paren
op_star
l_int|2
suffix:semicolon
r_char
id|buf
(braket
r_sizeof
(paren
id|val
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nibbles
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
(paren
id|val
op_amp
l_int|0xf
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
OG
l_char|&squot;9&squot;
)paren
id|buf
(braket
id|i
)braket
op_add_assign
(paren
l_char|&squot;a&squot;
op_minus
l_char|&squot;0&squot;
op_minus
l_int|10
)paren
suffix:semicolon
id|val
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|buf
(braket
id|nibbles
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|prom_print
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_void
DECL|function|prom_print_nl
id|prom_print_nl
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|prom_initialize_naca
id|prom_initialize_naca
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_char
id|type
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|num_cpus
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_struct
id|naca_struct
op_star
id|_naca
op_assign
id|RELOC
c_func
(paren
id|naca
)paren
suffix:semicolon
r_struct
id|systemcfg
op_star
id|_systemcfg
op_assign
id|RELOC
c_func
(paren
id|systemcfg
)paren
suffix:semicolon
multiline_comment|/* NOTE: _naca-&gt;debug_switch is already initialized. */
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_initialize_naca: start...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
id|_naca-&gt;pftSize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ilog2 of htab size.  computed below. */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;cpu&quot;
)paren
)paren
)paren
(brace
id|num_cpus
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* We&squot;re assuming *all* of the CPUs have the same&n;&t;&t;&t; * d-cache and i-cache sizes... -Peter&n;&t;&t;&t; */
r_if
c_cond
(paren
id|num_cpus
op_eq
l_int|1
)paren
(brace
id|u32
id|size
comma
id|lsize
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;d-cache-size&quot;
)paren
comma
op_amp
id|size
comma
r_sizeof
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;d-cache-block-size&quot;
)paren
comma
op_amp
id|lsize
comma
r_sizeof
(paren
id|lsize
)paren
)paren
suffix:semicolon
r_else
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;d-cache-line-size&quot;
)paren
comma
op_amp
id|lsize
comma
r_sizeof
(paren
id|lsize
)paren
)paren
suffix:semicolon
id|_systemcfg-&gt;dCacheL1Size
op_assign
id|size
suffix:semicolon
id|_systemcfg-&gt;dCacheL1LineSize
op_assign
id|lsize
suffix:semicolon
id|_naca-&gt;dCacheL1LogLineSize
op_assign
id|__ilog2
c_func
(paren
id|lsize
)paren
suffix:semicolon
id|_naca-&gt;dCacheL1LinesPerPage
op_assign
id|PAGE_SIZE
op_div
id|lsize
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;i-cache-size&quot;
)paren
comma
op_amp
id|size
comma
r_sizeof
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;i-cache-block-size&quot;
)paren
comma
op_amp
id|lsize
comma
r_sizeof
(paren
id|lsize
)paren
)paren
suffix:semicolon
r_else
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;i-cache-line-size&quot;
)paren
comma
op_amp
id|lsize
comma
r_sizeof
(paren
id|lsize
)paren
)paren
suffix:semicolon
id|_systemcfg-&gt;iCacheL1Size
op_assign
id|size
suffix:semicolon
id|_systemcfg-&gt;iCacheL1LineSize
op_assign
id|lsize
suffix:semicolon
id|_naca-&gt;iCacheL1LogLineSize
op_assign
id|__ilog2
c_func
(paren
id|lsize
)paren
suffix:semicolon
id|_naca-&gt;iCacheL1LinesPerPage
op_assign
id|PAGE_SIZE
op_div
id|lsize
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
)paren
(brace
id|u32
id|pft_size
(braket
l_int|2
)braket
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,pft-size&quot;
)paren
comma
op_amp
id|pft_size
comma
r_sizeof
(paren
id|pft_size
)paren
)paren
suffix:semicolon
multiline_comment|/* pft_size[0] is the NUMA CEC cookie */
id|_naca-&gt;pftSize
op_assign
id|pft_size
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;serial&quot;
)paren
)paren
)paren
(brace
id|phandle
id|isa
comma
id|pci
suffix:semicolon
r_struct
id|isa_reg_property
id|reg
suffix:semicolon
r_union
id|pci_range
id|ranges
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
r_continue
suffix:semicolon
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,aix-loc&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;S1&quot;
)paren
)paren
)paren
r_continue
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;reg&quot;
)paren
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
id|isa
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;parent&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isa
)paren
id|PROM_BUG
c_func
(paren
)paren
suffix:semicolon
id|pci
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;parent&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|isa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci
)paren
id|PROM_BUG
c_func
(paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|pci
comma
id|RELOC
c_func
(paren
l_string|&quot;ranges&quot;
)paren
comma
op_amp
id|ranges
comma
r_sizeof
(paren
id|ranges
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;encode_phys_size
op_eq
l_int|32
)paren
id|_naca-&gt;serialPortAddr
op_assign
id|ranges.pci32.phys
op_plus
id|reg.address
suffix:semicolon
r_else
(brace
id|_naca-&gt;serialPortAddr
op_assign
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|ranges.pci64.phys_hi
)paren
op_lshift
l_int|32
)paren
op_or
(paren
id|ranges.pci64.phys_lo
)paren
)paren
op_plus
id|reg.address
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
id|_naca-&gt;interrupt_controller
op_assign
id|IC_OPEN_PIC
suffix:semicolon
r_else
(brace
id|_naca-&gt;interrupt_controller
op_assign
id|IC_INVALID
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;name&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;interrupt-controller&quot;
)paren
)paren
)paren
r_continue
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;compatible&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;open-pic&quot;
)paren
)paren
)paren
id|_naca-&gt;interrupt_controller
op_assign
id|IC_OPEN_PIC
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;ppc-xicp&quot;
)paren
)paren
)paren
id|_naca-&gt;interrupt_controller
op_assign
id|IC_PPC_XIC
suffix:semicolon
r_else
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom: failed to recognize&quot;
l_string|&quot; interrupt-controller&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|_naca-&gt;interrupt_controller
op_eq
id|IC_INVALID
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom: failed to find interrupt-controller&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|PROM_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We gotta have at least 1 cpu... */
r_if
c_cond
(paren
(paren
id|_systemcfg-&gt;processorCount
op_assign
id|num_cpus
)paren
OL
l_int|1
)paren
id|PROM_BUG
c_func
(paren
)paren
suffix:semicolon
id|_systemcfg-&gt;physicalMemorySize
op_assign
id|lmb_phys_mem_size
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES
op_logical_or
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
(brace
r_int
r_int
id|rnd_mem_size
comma
id|pteg_count
suffix:semicolon
multiline_comment|/* round mem_size up to next power of 2 */
id|rnd_mem_size
op_assign
l_int|1UL
op_lshift
id|__ilog2
c_func
(paren
id|_systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rnd_mem_size
OL
id|_systemcfg-&gt;physicalMemorySize
)paren
id|rnd_mem_size
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* # pages / 2 */
id|pteg_count
op_assign
(paren
id|rnd_mem_size
op_rshift
(paren
l_int|12
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|_naca-&gt;pftSize
op_assign
id|__ilog2
c_func
(paren
id|pteg_count
op_lshift
l_int|7
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_naca-&gt;pftSize
op_eq
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom: failed to compute pftSize!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|PROM_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Hardcode to GP size.  I am not sure where to get this info&n;&t; * in general, as there does not appear to be a slb-size OF&n;&t; * entry.  At least in Condor and earlier.  DRENG &n;&t; */
id|_naca-&gt;slb_size
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* Add an eye catcher and the systemcfg layout version number */
id|strcpy
c_func
(paren
id|_systemcfg-&gt;eye_catcher
comma
id|RELOC
c_func
(paren
l_string|&quot;SYSTEMCFG:PPC64&quot;
)paren
)paren
suffix:semicolon
id|_systemcfg-&gt;version.major
op_assign
id|SYSTEMCFG_MAJOR
suffix:semicolon
id|_systemcfg-&gt;version.minor
op_assign
id|SYSTEMCFG_MINOR
suffix:semicolon
id|_systemcfg-&gt;processor
op_assign
id|_get_PVR
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;systemcfg-&gt;processorCount       = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_systemcfg-&gt;processorCount
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;systemcfg-&gt;physicalMemorySize   = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;naca-&gt;pftSize                   = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_naca-&gt;pftSize
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;systemcfg-&gt;dCacheL1LineSize     = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_systemcfg-&gt;dCacheL1LineSize
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;systemcfg-&gt;iCacheL1LineSize     = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_systemcfg-&gt;iCacheL1LineSize
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;naca-&gt;serialPortAddr            = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_naca-&gt;serialPortAddr
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;naca-&gt;interrupt_controller      = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_naca-&gt;interrupt_controller
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;systemcfg-&gt;platform             = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_systemcfg-&gt;platform
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_initialize_naca: end...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|mem
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|prom_initialize_lmb
id|prom_initialize_lmb
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_char
id|type
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|i
comma
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_struct
id|systemcfg
op_star
id|_systemcfg
op_assign
id|RELOC
c_func
(paren
id|systemcfg
)paren
suffix:semicolon
r_union
id|lmb_reg_property
id|reg
suffix:semicolon
r_int
r_int
id|lmb_base
comma
id|lmb_size
suffix:semicolon
r_int
r_int
id|num_regs
comma
id|bytes_per_reg
op_assign
(paren
id|_prom-&gt;encode_phys_size
op_star
l_int|2
)paren
op_div
l_int|8
suffix:semicolon
id|lmb_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* XXX Quick HACK. Proper fix is to drop those structures and properly use&n;&t; * #address-cells. PowerMac has #size-cell set to 1 and #address-cells to 2&n;&t; */
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
id|bytes_per_reg
op_assign
l_int|12
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;memory&quot;
)paren
)paren
)paren
r_continue
suffix:semicolon
id|num_regs
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;reg&quot;
)paren
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
op_div
id|bytes_per_reg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_regs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
(brace
id|lmb_base
op_assign
(paren
(paren
r_int
r_int
)paren
id|reg.addrPM
(braket
id|i
)braket
dot
id|address_hi
)paren
op_lshift
l_int|32
suffix:semicolon
id|lmb_base
op_or_assign
(paren
r_int
r_int
)paren
id|reg.addrPM
(braket
id|i
)braket
dot
id|address_lo
suffix:semicolon
id|lmb_size
op_assign
id|reg.addrPM
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|lmb_base
OG
l_int|0x80000000ull
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Skipping memory above 2Gb for now, not yet supported&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|_prom-&gt;encode_phys_size
op_eq
l_int|32
)paren
(brace
id|lmb_base
op_assign
id|reg.addr32
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|lmb_size
op_assign
id|reg.addr32
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_else
(brace
id|lmb_base
op_assign
id|reg.addr64
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|lmb_size
op_assign
id|reg.addr64
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lmb_add
c_func
(paren
id|lmb_base
comma
id|lmb_size
)paren
OL
l_int|0
)paren
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Too many LMB&squot;s, discarding this one...&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
id|lmb_analyze
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_dump_lmb
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_PROM */
r_return
id|mem
suffix:semicolon
)brace
DECL|variable|hypertas_funcs
r_static
r_char
id|hypertas_funcs
(braket
l_int|1024
)braket
suffix:semicolon
r_static
r_void
id|__init
DECL|function|prom_instantiate_rtas
id|prom_instantiate_rtas
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_struct
id|rtas_t
op_star
id|_rtas
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|rtas
)paren
suffix:semicolon
r_struct
id|systemcfg
op_star
id|_systemcfg
op_assign
id|RELOC
c_func
(paren
id|systemcfg
)paren
suffix:semicolon
id|ihandle
id|prom_rtas
suffix:semicolon
id|u32
id|getprop_rval
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_instantiate_rtas: start...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
id|prom_rtas
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_rtas
op_ne
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|prom_rtas
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,hypertas-functions&quot;
)paren
comma
id|hypertas_funcs
comma
r_sizeof
(paren
id|hypertas_funcs
)paren
)paren
)paren
OG
l_int|0
)paren
(brace
id|_systemcfg-&gt;platform
op_assign
id|PLATFORM_PSERIES_LPAR
suffix:semicolon
)brace
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|prom_rtas
comma
id|RELOC
c_func
(paren
l_string|&quot;rtas-size&quot;
)paren
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_rtas-&gt;size
op_assign
id|getprop_rval
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;instantiating rtas&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_rtas-&gt;size
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|rtas_region
op_assign
id|RTAS_INSTANTIATE_MAX
suffix:semicolon
multiline_comment|/* Grab some space within the first RTAS_INSTANTIATE_MAX bytes&n;&t;&t;&t; * of physical memory (or within the RMO region) because RTAS&n;&t;&t;&t; * runs in 32-bit mode and relocate off.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
)paren
(brace
r_struct
id|lmb
op_star
id|_lmb
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|lmb
)paren
suffix:semicolon
id|rtas_region
op_assign
id|min
c_func
(paren
id|_lmb-&gt;rmo_size
comma
id|RTAS_INSTANTIATE_MAX
)paren
suffix:semicolon
)brace
id|_rtas-&gt;base
op_assign
id|lmb_alloc_base
c_func
(paren
id|_rtas-&gt;size
comma
id|PAGE_SIZE
comma
id|rtas_region
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; at 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_rtas-&gt;base
)paren
suffix:semicolon
id|prom_rtas
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;call-method&quot;
)paren
comma
l_int|3
comma
l_int|2
comma
id|RELOC
c_func
(paren
l_string|&quot;instantiate-rtas&quot;
)paren
comma
id|prom_rtas
comma
id|_rtas-&gt;base
)paren
op_ge
l_int|0
)paren
(brace
id|_rtas-&gt;entry
op_assign
(paren
r_int
)paren
id|_prom-&gt;args.rets
(braket
l_int|1
)braket
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|rtas_rmo_buf
)paren
op_assign
id|lmb_alloc_base
c_func
(paren
id|RTAS_RMOBUF_MAX
comma
id|PAGE_SIZE
comma
id|rtas_region
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_rtas-&gt;entry
op_le
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;rtas-&gt;base                 = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_rtas-&gt;base
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;rtas-&gt;entry                = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_rtas-&gt;entry
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;rtas-&gt;size                 = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_rtas-&gt;size
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_instantiate_rtas: end...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|prom_strtoul
r_int
r_int
id|prom_strtoul
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_int
r_int
id|result
op_assign
l_int|0
comma
id|value
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
id|value
op_assign
op_star
id|cp
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|result
op_assign
id|result
op_star
l_int|10
op_plus
id|value
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROM
r_void
DECL|function|prom_dump_lmb
id|prom_dump_lmb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|lmb
op_star
id|_lmb
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|lmb
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;nprom_dump_lmb:&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    memory.cnt                  = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;memory.cnt
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    memory.size                 = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;memory.size
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|_lmb-&gt;memory.cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    memory.region[0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|i
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;].base       = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;memory.region
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;                      .physbase = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;memory.region
(braket
id|i
)braket
dot
id|physbase
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;                      .size     = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;memory.region
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
)brace
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    reserved.cnt                  = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;reserved.cnt
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    reserved.size                 = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;reserved.size
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|_lmb-&gt;reserved.cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    reserved.region[0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|i
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;].base       = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;reserved.region
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;                      .physbase = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;reserved.region
(braket
id|i
)braket
dot
id|physbase
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;                      .size     = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_lmb-&gt;reserved.region
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG_PROM */
r_void
DECL|function|prom_initialize_tce_table
id|prom_initialize_tce_table
c_func
(paren
r_void
)paren
(brace
id|phandle
id|node
suffix:semicolon
id|ihandle
id|phb_node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|compatible
(braket
l_int|64
)braket
comma
id|path
(braket
l_int|64
)braket
comma
id|type
(braket
l_int|64
)braket
comma
id|model
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|i
comma
id|table
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|base
comma
id|vbase
comma
id|align
suffix:semicolon
r_int
r_int
id|minalign
comma
id|minsize
suffix:semicolon
r_struct
id|_of_tce_table
op_star
id|prom_tce_table
op_assign
id|RELOC
c_func
(paren
id|of_tce_table
)paren
suffix:semicolon
r_int
r_int
id|tce_entry
comma
op_star
id|tce_entryp
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;starting prom_initialize_tce_table&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Search all nodes looking for PHBs. */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|compatible
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|model
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;compatible&quot;
)paren
comma
id|compatible
comma
r_sizeof
(paren
id|compatible
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;model&quot;
)paren
comma
id|model
comma
r_sizeof
(paren
id|model
)paren
)paren
suffix:semicolon
multiline_comment|/* Keep the old logic in tack to avoid regression. */
r_if
c_cond
(paren
id|compatible
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;python&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;Speedwagon&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|compatible
comma
id|RELOC
c_func
(paren
l_string|&quot;Winnipeg&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|model
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;ython&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;peedwagon&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|strstr
c_func
(paren
id|model
comma
id|RELOC
c_func
(paren
l_string|&quot;innipeg&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|type
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strstr
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;pci&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;tce-table-minalign&quot;
)paren
comma
op_amp
id|minalign
comma
r_sizeof
(paren
id|minalign
)paren
)paren
OL
l_int|0
)paren
(brace
id|minalign
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;tce-table-minsize&quot;
)paren
comma
op_amp
id|minsize
comma
r_sizeof
(paren
id|minsize
)paren
)paren
OL
l_int|0
)paren
(brace
id|minsize
op_assign
l_int|4UL
op_lshift
l_int|20
suffix:semicolon
)brace
multiline_comment|/* Even though we read what OF wants, we just set the table&n;&t;&t; * size to 4 MB.  This is enough to map 2GB of PCI DMA space.&n;&t;&t; * By doing this, we avoid the pitfalls of trying to DMA to&n;&t;&t; * MMIO space and the DMA alias hole.&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * On POWER4, firmware sets the TCE region by assuming&n;&t;&t; * each TCE table is 8MB. Using this memory for anything&n;&t;&t; * else will impact performance, so we always allocate 8MB.&n;&t;&t; * Anton&n;&t;&t; *&n;&t;&t; * XXX FIXME use a cpu feature here&n;&t;&t; */
id|minsize
op_assign
l_int|8UL
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/* Align to the greater of the align or size */
id|align
op_assign
id|max
c_func
(paren
id|minalign
comma
id|minsize
)paren
suffix:semicolon
multiline_comment|/* Carve out storage for the TCE table. */
id|base
op_assign
id|lmb_alloc
c_func
(paren
id|minsize
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;ERROR, cannot find space for TCE table.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|vbase
op_assign
id|absolute_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Save away the TCE table attributes for later use. */
id|prom_tce_table
(braket
id|table
)braket
dot
id|node
op_assign
id|node
suffix:semicolon
id|prom_tce_table
(braket
id|table
)braket
dot
id|base
op_assign
id|vbase
suffix:semicolon
id|prom_tce_table
(braket
id|table
)braket
dot
id|size
op_assign
id|minsize
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;TCE table: 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|table
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;tnode = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|node
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;tbase = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|vbase
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;tsize = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|minsize
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the table to have a one-to-one mapping&n;&t;&t; * over the allocated size.&n;&t;&t; */
id|tce_entryp
op_assign
(paren
r_int
r_int
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|minsize
op_rshift
l_int|3
)paren
suffix:semicolon
id|tce_entryp
op_increment
comma
id|i
op_increment
)paren
(brace
id|tce_entry
op_assign
(paren
id|i
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|tce_entry
op_or_assign
l_int|0x3
suffix:semicolon
op_star
id|tce_entryp
op_assign
id|tce_entry
suffix:semicolon
)brace
multiline_comment|/* Call OF to setup the TCE hardware */
r_if
c_cond
(paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
op_le
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;opened &quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
)brace
id|phb_node
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|phb_node
op_le
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open success&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;call-method&quot;
)paren
comma
l_int|6
comma
l_int|0
comma
id|RELOC
c_func
(paren
l_string|&quot;set-64-bit-addressing&quot;
)paren
comma
id|phb_node
comma
op_minus
l_int|1
comma
id|minsize
comma
id|base
op_amp
l_int|0xffffffff
comma
(paren
id|base
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;close&quot;
)paren
comma
l_int|1
comma
l_int|0
comma
id|phb_node
)paren
suffix:semicolon
id|table
op_increment
suffix:semicolon
)brace
multiline_comment|/* Flag the first invalid entry */
id|prom_tce_table
(braket
id|table
)braket
dot
id|node
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;ending prom_initialize_tce_table&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * With CHRP SMP we need to use the OF to start the other&n; * processors so we can&squot;t wait until smp_boot_cpus (the OF is&n; * trashed by then) so we have to put the processors into&n; * a holding pattern controlled by the kernel (not OF) before&n; * we destroy the OF.&n; *&n; * This uses a chunk of low memory, puts some holding pattern&n; * code there and sends the other processors off to there until&n; * smp_boot_cpus tells them to do something.  The holding pattern&n; * checks that address until its cpu # is there, when it is that&n; * cpu jumps to __secondary_start().  smp_boot_cpus() takes care&n; * of setting those values.&n; *&n; * We also use physical address 0x4 here to tell when a cpu&n; * is in its holding pattern code.&n; *&n; * Fixup comment... DRENG / PPPBBB - Peter&n; *&n; * -- Cort&n; */
r_static
r_void
DECL|function|prom_hold_cpus
id|prom_hold_cpus
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|64
)braket
comma
op_star
id|path
suffix:semicolon
r_int
id|cpuid
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|interrupt_server
(braket
id|MAX_CPU_THREADS
)braket
suffix:semicolon
r_int
r_int
id|cpu_threads
comma
id|hw_cpu_num
suffix:semicolon
r_int
id|propsize
suffix:semicolon
r_extern
r_void
id|__secondary_hold
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__secondary_hold_spinloop
suffix:semicolon
r_extern
r_int
r_int
id|__secondary_hold_acknowledge
suffix:semicolon
r_int
r_int
op_star
id|spinloop
op_assign
id|__v2a
c_func
(paren
op_amp
id|__secondary_hold_spinloop
)paren
suffix:semicolon
r_int
r_int
op_star
id|acknowledge
op_assign
id|__v2a
c_func
(paren
op_amp
id|__secondary_hold_acknowledge
)paren
suffix:semicolon
r_int
r_int
id|secondary_hold
op_assign
(paren
r_int
r_int
)paren
id|__v2a
c_func
(paren
op_star
id|PTRRELOC
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|__secondary_hold
)paren
)paren
suffix:semicolon
r_struct
id|naca_struct
op_star
id|_naca
op_assign
id|RELOC
c_func
(paren
id|naca
)paren
suffix:semicolon
r_struct
id|systemcfg
op_star
id|_systemcfg
op_assign
id|RELOC
c_func
(paren
id|systemcfg
)paren
suffix:semicolon
r_struct
id|paca_struct
op_star
id|_xPaca
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|paca
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
multiline_comment|/* On pmac, we just fill out the various global bitmasks and&n;&t; * arrays indicating our CPUs are here, they are actually started&n;&t; * later on from pmac_smp&n;&t; */
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
(brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;cpu&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;reg&quot;
)paren
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
id|_xPaca
(braket
id|cpuid
)braket
dot
id|xHwProcNum
op_assign
id|reg
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_available_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_possible_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_present_at_boot
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
l_int|0
)paren
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_online_map
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|cpuid
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Initially, we must have one active CPU. */
id|_systemcfg-&gt;processorCount
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_hold_cpus: start...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    1) spinloop       = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
(paren
r_int
r_int
)paren
id|spinloop
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    1) *spinloop      = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
op_star
id|spinloop
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    1) acknowledge    = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
(paren
r_int
r_int
)paren
id|acknowledge
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    1) *acknowledge   = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
op_star
id|acknowledge
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    1) secondary_hold = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|secondary_hold
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set the common spinloop variable, so all of the secondary cpus&n;&t; * will block when they are awakened from their OF spinloop.&n;&t; * This must occur for both SMP and non SMP kernels, since OF will&n;&t; * be trashed when we move the kernel.&n;         */
op_star
id|spinloop
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_HMT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
l_int|0xdeadbeef
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* look for cpus */
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;cpu&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Skip non-configured cpus. */
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;status&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;okay&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;reg&quot;
)paren
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
id|path
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cpuid        = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cpu hw idx   = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|reg
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|_xPaca
(braket
id|cpuid
)braket
dot
id|xHwProcNum
op_assign
id|reg
suffix:semicolon
multiline_comment|/* Init the acknowledge var which will be reset by&n;&t;&t; * the secondary cpu when it awakens from its OF&n;&t;&t; * spinloop.&n;&t;&t; */
op_star
id|acknowledge
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
id|propsize
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,ppc-interrupt-server#s&quot;
)paren
comma
op_amp
id|interrupt_server
comma
r_sizeof
(paren
id|interrupt_server
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|propsize
OL
l_int|0
)paren
(brace
multiline_comment|/* no property.  old hardware has no SMT */
id|cpu_threads
op_assign
l_int|1
suffix:semicolon
id|interrupt_server
(braket
l_int|0
)braket
op_assign
id|reg
suffix:semicolon
multiline_comment|/* fake it with phys id */
)brace
r_else
(brace
multiline_comment|/* We have a threaded processor */
id|cpu_threads
op_assign
id|propsize
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_threads
OG
id|MAX_CPU_THREADS
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;SMT: too many threads!&bslash;nSMT: found &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|cpu_threads
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;, max is &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|MAX_CPU_THREADS
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|cpu_threads
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ToDo: panic? */
)brace
)brace
id|hw_cpu_num
op_assign
id|interrupt_server
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hw_cpu_num
op_ne
id|_prom-&gt;cpu
)paren
(brace
multiline_comment|/* Primary Thread of non-boot cpu */
id|prom_print_hex
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; : starting cpu &quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;...&quot;
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;start-cpu&quot;
)paren
comma
l_int|3
comma
l_int|0
comma
id|node
comma
id|secondary_hold
comma
id|cpuid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|100000000
)paren
op_logical_and
(paren
op_star
id|acknowledge
op_eq
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|acknowledge
op_eq
id|cpuid
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Set the number of active processors. */
id|_systemcfg-&gt;processorCount
op_increment
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_available_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_possible_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_present_at_boot
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;failed: &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
op_star
id|acknowledge
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* prom_panic(RELOC(&quot;cpu failed to start&quot;)); */
)brace
)brace
macro_line|#ifdef CONFIG_SMP
r_else
(brace
id|prom_print_hex
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; : booting  cpu &quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_available_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_possible_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_online_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_present_at_boot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Init paca for secondary threads.   They start later. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cpu_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpuid
op_increment
suffix:semicolon
id|_xPaca
(braket
id|cpuid
)braket
dot
id|xHwProcNum
op_assign
id|interrupt_server
(braket
id|i
)braket
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|interrupt_server
(braket
id|i
)braket
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; : preparing thread ... &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_naca-&gt;smt_state
)paren
(brace
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_available_map
)paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpuid
comma
id|RELOC
c_func
(paren
id|cpu_present_at_boot
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;available&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;not available&quot;
)paren
)paren
suffix:semicolon
)brace
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|cpuid
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HMT
multiline_comment|/* Only enable HMT on processors that provide support. */
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_PULSAR
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_ICESTAR
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_SSTAR
)paren
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;    starting secondary threads&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|pir
op_assign
id|_get_PIR
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_PULSAR
)paren
)paren
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
id|pir
op_amp
l_int|0x1f
suffix:semicolon
)brace
r_else
(brace
id|RELOC
c_func
(paren
id|hmt_thread_data
)paren
(braket
id|i
)braket
dot
id|pir
op_assign
id|pir
op_amp
l_int|0x3ff
suffix:semicolon
)brace
)brace
multiline_comment|/* &t;&t;&t;cpu_set(i+1, cpu_online_map); */
id|cpu_set
c_func
(paren
id|i
op_plus
l_int|1
comma
id|RELOC
c_func
(paren
id|cpu_possible_map
)paren
)paren
suffix:semicolon
)brace
id|_systemcfg-&gt;processorCount
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Processor is not HMT capable&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;prom_hold_cpus: end...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|smt_setup
id|smt_setup
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_char
id|my_smt_enabled
op_assign
id|SMT_DYNAMIC
suffix:semicolon
r_int
r_int
id|my_smt_snooze_delay
suffix:semicolon
id|ihandle
id|prom_options
op_assign
l_int|NULL
suffix:semicolon
r_char
id|option
(braket
l_int|9
)braket
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|naca_struct
op_star
id|_naca
op_assign
id|RELOC
c_func
(paren
id|naca
)paren
suffix:semicolon
r_char
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|RELOC
c_func
(paren
id|cmd_line
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;smt-enabled=&quot;
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|RELOC
c_func
(paren
id|cmd_line
)paren
suffix:semicolon
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|q
comma
id|RELOC
c_func
(paren
l_string|&quot;smt-enabled=&quot;
)paren
)paren
)paren
op_ne
l_int|0
suffix:semicolon
)paren
(brace
id|q
op_assign
id|p
op_plus
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|p
OG
id|RELOC
c_func
(paren
id|cmd_line
)paren
op_logical_and
id|p
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|q
(braket
l_int|0
)braket
op_eq
l_char|&squot;o&squot;
op_logical_and
id|q
(braket
l_int|1
)braket
op_eq
l_char|&squot;f&squot;
op_logical_and
id|q
(braket
l_int|2
)braket
op_eq
l_char|&squot;f&squot;
op_logical_and
(paren
id|q
(braket
l_int|3
)braket
op_eq
l_char|&squot; &squot;
op_logical_or
id|q
(braket
l_int|3
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
id|my_smt_enabled
op_assign
id|SMT_OFF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|q
(braket
l_int|0
)braket
op_eq
l_char|&squot;o&squot;
op_logical_and
id|q
(braket
l_int|1
)braket
op_eq
l_char|&squot;n&squot;
op_logical_and
(paren
id|q
(braket
l_int|2
)braket
op_eq
l_char|&squot; &squot;
op_logical_or
id|q
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
id|my_smt_enabled
op_assign
id|SMT_ON
suffix:semicolon
)brace
r_else
(brace
id|my_smt_enabled
op_assign
id|SMT_DYNAMIC
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|prom_options
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/options&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_options
op_ne
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|prom_options
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,smt-enabled&quot;
)paren
comma
id|option
comma
r_sizeof
(paren
id|option
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|option
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;off&quot;
)paren
)paren
id|my_smt_enabled
op_assign
id|SMT_OFF
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;on&quot;
)paren
)paren
id|my_smt_enabled
op_assign
id|SMT_ON
suffix:semicolon
r_else
id|my_smt_enabled
op_assign
id|SMT_DYNAMIC
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|my_smt_enabled
op_assign
id|SMT_DYNAMIC
suffix:semicolon
multiline_comment|/* default to on */
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|my_smt_enabled
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|RELOC
c_func
(paren
id|cmd_line
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;smt-snooze-delay=&quot;
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|RELOC
c_func
(paren
id|cmd_line
)paren
suffix:semicolon
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|q
comma
id|RELOC
c_func
(paren
l_string|&quot;smt-snooze-delay=&quot;
)paren
)paren
)paren
op_ne
l_int|0
suffix:semicolon
)paren
(brace
id|q
op_assign
id|p
op_plus
l_int|17
suffix:semicolon
r_if
c_cond
(paren
id|p
OG
id|RELOC
c_func
(paren
id|cmd_line
)paren
op_logical_and
id|p
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t use simple_strtoul() because _ctype &amp; others aren&squot;t RELOC&squot;d */
id|my_smt_snooze_delay
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|q
op_le
l_char|&squot;9&squot;
)paren
(brace
id|my_smt_snooze_delay
op_assign
id|my_smt_snooze_delay
op_star
l_int|10
op_plus
op_star
id|q
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|prom_options
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/options&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_options
op_ne
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|prom_options
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,smt-snooze-delay&quot;
)paren
comma
id|option
comma
r_sizeof
(paren
id|option
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|option
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t use simple_strtoul() because _ctype &amp; others aren&squot;t RELOC&squot;d */
id|my_smt_snooze_delay
op_assign
l_int|0
suffix:semicolon
id|q
op_assign
id|option
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|q
op_le
l_char|&squot;9&squot;
)paren
(brace
id|my_smt_snooze_delay
op_assign
id|my_smt_snooze_delay
op_star
l_int|10
op_plus
op_star
id|q
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|my_smt_snooze_delay
op_assign
l_int|30000
suffix:semicolon
multiline_comment|/* default value */
)brace
)brace
r_else
(brace
id|my_smt_snooze_delay
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default value */
)brace
id|_naca-&gt;smt_snooze_delay
op_assign
id|my_smt_snooze_delay
suffix:semicolon
id|_naca-&gt;smt_state
op_assign
id|my_smt_enabled
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BOOTX_TEXT
multiline_comment|/* This function will enable the early boot text when doing OF booting. This&n; * way, xmon output should work too&n; */
DECL|function|setup_disp_fake_bi
r_static
r_void
id|__init
id|setup_disp_fake_bi
c_func
(paren
id|ihandle
id|dp
)paren
(brace
r_int
id|width
op_assign
l_int|640
comma
id|height
op_assign
l_int|480
comma
id|depth
op_assign
l_int|8
comma
id|pitch
suffix:semicolon
r_int
id|address
suffix:semicolon
r_struct
id|pci_reg_property
id|addrs
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
comma
id|naddrs
suffix:semicolon
r_char
id|name
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|getprop
op_assign
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Initializing fake screen: &quot;
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;name&quot;
)paren
comma
id|name
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
id|name
(braket
r_sizeof
(paren
id|name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_print
c_func
(paren
id|name
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;width&quot;
)paren
comma
op_amp
id|width
comma
r_sizeof
(paren
id|width
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;height&quot;
)paren
comma
op_amp
id|height
comma
r_sizeof
(paren
id|height
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;depth&quot;
)paren
comma
op_amp
id|depth
comma
r_sizeof
(paren
id|depth
)paren
)paren
suffix:semicolon
id|pitch
op_assign
id|width
op_star
(paren
(paren
id|depth
op_plus
l_int|7
)paren
op_div
l_int|8
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;linebytes&quot;
)paren
comma
op_amp
id|pitch
comma
r_sizeof
(paren
id|pitch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pitch
op_eq
l_int|1
)paren
id|pitch
op_assign
l_int|0x1000
suffix:semicolon
multiline_comment|/* for strange IBM display */
id|address
op_assign
l_int|0
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;width &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|width
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; height &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|height
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; depth &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|depth
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; linebytes &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|pitch
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;address&quot;
)paren
comma
op_amp
id|address
comma
r_sizeof
(paren
id|address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
l_int|0
)paren
(brace
multiline_comment|/* look for an assigned address with a size of &gt;= 1MB */
id|naddrs
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
id|RELOC
c_func
(paren
l_string|&quot;assigned-addresses&quot;
)paren
comma
id|addrs
comma
r_sizeof
(paren
id|addrs
)paren
)paren
suffix:semicolon
id|naddrs
op_div_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naddrs
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|addrs
(braket
id|i
)braket
dot
id|size_lo
op_ge
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
(brace
id|address
op_assign
id|addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
multiline_comment|/* use the BE aperture if possible */
r_if
c_cond
(paren
id|addrs
(braket
id|i
)braket
dot
id|size_lo
op_ge
(paren
l_int|16
op_lshift
l_int|20
)paren
)paren
id|address
op_add_assign
(paren
l_int|8
op_lshift
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|address
op_eq
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Failed to get address of frame buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|btext_setup_display
c_func
(paren
id|width
comma
id|height
comma
id|depth
comma
id|pitch
comma
id|address
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Addr of fb: &quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|address
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|boot_text_mapped
)paren
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BOOTX_TEXT */
DECL|function|prom_init_client_services
r_static
r_void
id|__init
id|prom_init_client_services
c_func
(paren
r_int
r_int
id|pp
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
multiline_comment|/* Get a handle to the prom entry point before anything else */
id|_prom-&gt;entry
op_assign
id|pp
suffix:semicolon
multiline_comment|/* Init default value for phys size */
id|_prom-&gt;encode_phys_size
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* get a handle for the stdout device */
id|_prom-&gt;chosen
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/chosen&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;chosen
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cannot find chosen&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* msg won&squot;t be printed :( */
multiline_comment|/* get device tree root */
id|_prom-&gt;root
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;root
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cannot find device tree root&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* msg won&squot;t be printed :( */
)brace
DECL|function|prom_init_stdout
r_static
r_void
id|__init
id|prom_init_stdout
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
id|u32
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;chosen
comma
id|RELOC
c_func
(paren
l_string|&quot;stdout&quot;
)paren
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cannot find stdout&quot;
)paren
)paren
suffix:semicolon
id|_prom-&gt;stdout
op_assign
(paren
id|ihandle
)paren
(paren
r_int
r_int
)paren
id|val
suffix:semicolon
)brace
DECL|function|prom_find_machine_type
r_static
r_int
id|__init
id|prom_find_machine_type
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
id|compat
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|len
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;root
comma
id|RELOC
c_func
(paren
l_string|&quot;compatible&quot;
)paren
comma
id|compat
comma
r_sizeof
(paren
id|compat
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|compat
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|len
)paren
(brace
r_char
op_star
id|p
op_assign
op_amp
id|compat
(braket
id|i
)braket
suffix:semicolon
r_int
id|sl
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sl
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
id|RELOC
c_func
(paren
l_string|&quot;Power Macintosh&quot;
)paren
)paren
op_logical_or
id|strstr
c_func
(paren
id|p
comma
id|RELOC
c_func
(paren
l_string|&quot;MacRISC4&quot;
)paren
)paren
)paren
r_return
id|PLATFORM_POWERMAC
suffix:semicolon
id|i
op_add_assign
id|sl
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Default to pSeries */
r_return
id|PLATFORM_PSERIES
suffix:semicolon
)brace
multiline_comment|/*&n; * We enter here early on, when the Open Firmware prom is still&n; * handling exceptions and the MMU hash table for us.&n; */
r_int
r_int
id|__init
DECL|function|prom_init
id|prom_init
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|pp
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
)paren
(brace
r_int
r_int
id|mem
suffix:semicolon
id|ihandle
id|prom_cpu
suffix:semicolon
id|phandle
id|cpu_pkg
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
id|l
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|d
suffix:semicolon
r_int
r_int
id|phys
suffix:semicolon
id|u32
id|getprop_rval
suffix:semicolon
r_struct
id|systemcfg
op_star
id|_systemcfg
suffix:semicolon
r_struct
id|paca_struct
op_star
id|_xPaca
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|paca
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
multiline_comment|/* First zero the BSS -- use memset, some arches don&squot;t have&n;&t; * caches on yet */
id|memset
c_func
(paren
id|PTRRELOC
c_func
(paren
op_amp
id|__bss_start
)paren
comma
l_int|0
comma
id|__bss_stop
op_minus
id|__bss_start
)paren
suffix:semicolon
multiline_comment|/* Setup systemcfg and NACA pointers now */
id|RELOC
c_func
(paren
id|systemcfg
)paren
op_assign
id|_systemcfg
op_assign
(paren
r_struct
id|systemcfg
op_star
)paren
(paren
id|SYSTEMCFG_VIRT_ADDR
op_minus
id|offset
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|naca
)paren
op_assign
(paren
r_struct
id|naca_struct
op_star
)paren
(paren
id|NACA_VIRT_ADDR
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* Init interface to Open Firmware and pickup bi-recs */
id|prom_init_client_services
c_func
(paren
id|pp
)paren
suffix:semicolon
multiline_comment|/* Init prom stdout device */
id|prom_init_stdout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check out if we have bi_recs */
id|_prom-&gt;bi_recs
op_assign
id|prom_bi_rec_verify
c_func
(paren
(paren
r_struct
id|bi_record
op_star
)paren
id|r6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;bi_recs
op_ne
l_int|NULL
)paren
id|RELOC
c_func
(paren
id|klimit
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
(paren
r_int
r_int
)paren
id|_prom-&gt;bi_recs
op_plus
id|_prom-&gt;bi_recs-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Default machine type. */
id|_systemcfg-&gt;platform
op_assign
id|prom_find_machine_type
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* On pSeries, copy the CPU hold code */
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES
)paren
id|copy_and_flush
c_func
(paren
l_int|0
comma
id|KERNELBASE
op_minus
id|offset
comma
l_int|0x100
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Start storing things at klimit */
id|mem
op_assign
id|RELOC
c_func
(paren
id|klimit
)paren
op_minus
id|offset
suffix:semicolon
multiline_comment|/* Get the full OF pathname of the stdout device */
id|p
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;instance-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|_prom-&gt;stdout
comma
id|p
comma
l_int|255
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|p
)paren
suffix:semicolon
id|mem
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
suffix:semicolon
id|getprop_rval
op_assign
l_int|1
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;root
comma
id|RELOC
c_func
(paren
l_string|&quot;#size-cells&quot;
)paren
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_prom-&gt;encode_phys_size
op_assign
(paren
id|getprop_rval
op_eq
l_int|1
)paren
ques
c_cond
l_int|32
suffix:colon
l_int|64
suffix:semicolon
multiline_comment|/* Determine which cpu is actually running right _now_ */
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;chosen
comma
id|RELOC
c_func
(paren
l_string|&quot;cpu&quot;
)paren
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
op_le
l_int|0
)paren
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;cannot find boot cpu&quot;
)paren
)paren
suffix:semicolon
id|prom_cpu
op_assign
(paren
id|ihandle
)paren
(paren
r_int
r_int
)paren
id|getprop_rval
suffix:semicolon
id|cpu_pkg
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;instance-to-package&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|prom_cpu
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|cpu_pkg
comma
id|RELOC
c_func
(paren
l_string|&quot;reg&quot;
)paren
comma
op_amp
id|getprop_rval
comma
r_sizeof
(paren
id|getprop_rval
)paren
)paren
suffix:semicolon
id|_prom-&gt;cpu
op_assign
(paren
r_int
)paren
(paren
r_int
r_int
)paren
id|getprop_rval
suffix:semicolon
id|_xPaca
(braket
l_int|0
)braket
dot
id|xHwProcNum
op_assign
id|_prom-&gt;cpu
suffix:semicolon
id|RELOC
c_func
(paren
id|boot_cpuid
)paren
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Booting CPU hw index = 0x&quot;
)paren
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|_prom-&gt;cpu
)paren
suffix:semicolon
id|prom_print_nl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Get the boot device and translate it to a full OF pathname. */
id|p
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;chosen
comma
id|RELOC
c_func
(paren
l_string|&quot;bootpath&quot;
)paren
comma
id|p
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|0
)paren
(brace
id|p
(braket
id|l
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* should already be null-terminated */
id|RELOC
c_func
(paren
id|bootpath
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|p
)paren
suffix:semicolon
id|mem
op_add_assign
id|l
op_plus
l_int|1
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
op_star
id|d
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;canon&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|p
comma
id|d
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|bootdevice
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|d
)paren
suffix:semicolon
id|mem
op_assign
id|DOUBLEWORD_ALIGN
c_func
(paren
id|mem
op_plus
id|strlen
c_func
(paren
id|d
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|cmd_line
(braket
l_int|0
)braket
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|_prom-&gt;chosen
OG
l_int|0
)paren
(brace
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|_prom-&gt;chosen
comma
id|RELOC
c_func
(paren
l_string|&quot;bootargs&quot;
)paren
comma
id|p
comma
r_sizeof
(paren
id|cmd_line
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
op_logical_and
id|p
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|strncpy
c_func
(paren
id|RELOC
c_func
(paren
id|cmd_line
)paren
comma
id|p
comma
r_sizeof
(paren
id|cmd_line
)paren
)paren
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|cmd_line
(braket
r_sizeof
(paren
id|cmd_line
)paren
op_minus
l_int|1
)braket
)paren
op_assign
l_int|0
suffix:semicolon
id|mem
op_assign
id|prom_initialize_lmb
c_func
(paren
id|mem
)paren
suffix:semicolon
id|mem
op_assign
id|prom_bi_rec_reserve
c_func
(paren
id|mem
)paren
suffix:semicolon
id|mem
op_assign
id|check_display
c_func
(paren
id|mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_ne
id|PLATFORM_POWERMAC
)paren
id|prom_instantiate_rtas
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize some system info into the Naca early... */
id|mem
op_assign
id|prom_initialize_naca
c_func
(paren
id|mem
)paren
suffix:semicolon
id|smt_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we are on an SMP machine, then we *MUST* do the&n;         * following, regardless of whether we have an SMP&n;         * kernel or not.&n;         */
id|prom_hold_cpus
c_func
(paren
id|mem
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROM
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;copying OF device tree...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mem
op_assign
id|copy_device_tree
c_func
(paren
id|mem
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|klimit
)paren
op_assign
id|mem
op_plus
id|offset
suffix:semicolon
id|lmb_reserve
c_func
(paren
l_int|0
comma
id|__pa
c_func
(paren
id|RELOC
c_func
(paren
id|klimit
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES
)paren
id|prom_initialize_tce_table
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BOOTX_TEXT
r_if
c_cond
(paren
id|_prom-&gt;disp_node
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Setting up bi display...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|setup_disp_fake_bi
c_func
(paren
id|_prom-&gt;disp_node
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BOOTX_TEXT */
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;Calling quiesce ...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;quiesce&quot;
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|phys
op_assign
id|KERNELBASE
op_minus
id|offset
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;returning from prom_init&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|phys
suffix:semicolon
)brace
r_static
r_int
DECL|function|prom_set_color
id|prom_set_color
c_func
(paren
id|ihandle
id|ih
comma
r_int
id|i
comma
r_int
id|r
comma
r_int
id|g
comma
r_int
id|b
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;call-method&quot;
)paren
comma
l_int|6
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;color!&quot;
)paren
comma
id|ih
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|i
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|b
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|g
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we have a display that we don&squot;t know how to drive,&n; * we will want to try to execute OF&squot;s open method for it&n; * later.  However, OF will probably fall over if we do that&n; * we&squot;ve taken over the MMU.&n; * So we check whether we will need to open the display,&n; * and if so, open it now.&n; */
r_static
r_int
r_int
id|__init
DECL|function|check_display
id|check_display
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
id|phandle
id|node
suffix:semicolon
id|ihandle
id|ih
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|64
)braket
comma
op_star
id|path
suffix:semicolon
r_static
r_int
r_char
id|default_colors
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_const
r_int
r_char
op_star
id|clut
suffix:semicolon
id|_prom-&gt;disp_node
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;display&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|path
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;opening display &quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
(paren
id|ihandle
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih
op_eq
(paren
id|ihandle
)paren
l_int|0
op_logical_or
id|ih
op_eq
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;... failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;... ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;disp_node
op_eq
l_int|0
)paren
id|_prom-&gt;disp_node
op_assign
(paren
id|ihandle
)paren
(paren
r_int
r_int
)paren
id|node
suffix:semicolon
multiline_comment|/* Setup a useable color table when the appropriate&n;&t;&t; * method is available. Should update this to set-colors */
id|clut
op_assign
id|RELOC
c_func
(paren
id|default_colors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
comma
id|clut
op_add_assign
l_int|3
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
comma
id|clut
(braket
l_int|0
)braket
comma
id|clut
(braket
l_int|1
)braket
comma
id|clut
(braket
l_int|2
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_LOGO_LINUX_CLUT224
id|clut
op_assign
id|PTRRELOC
c_func
(paren
id|RELOC
c_func
(paren
id|logo_linux_clut224.clut
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RELOC
c_func
(paren
id|logo_linux_clut224.clutsize
)paren
suffix:semicolon
id|i
op_increment
comma
id|clut
op_add_assign
l_int|3
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
op_plus
l_int|32
comma
id|clut
(braket
l_int|0
)braket
comma
id|clut
(braket
l_int|1
)braket
comma
id|clut
(braket
l_int|2
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_LOGO_LINUX_CLUT224 */
multiline_comment|/*&n;&t;&t; * If this display is the device that OF is using for stdout,&n;&t;&t; * move it to the front of the list.&n;&t;&t; */
id|mem
op_add_assign
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
suffix:semicolon
id|i
op_assign
id|RELOC
c_func
(paren
id|prom_num_displays
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
op_ne
l_int|0
op_logical_and
id|i
OG
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|PTRRELOC
c_func
(paren
id|RELOC
c_func
(paren
id|of_stdout_device
)paren
)paren
comma
id|path
)paren
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
id|RELOC
c_func
(paren
id|prom_display_paths
(braket
id|i
)braket
)paren
op_assign
id|RELOC
c_func
(paren
id|prom_display_paths
(braket
id|i
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|prom_display_paths
(braket
id|i
)braket
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|prom_num_displays
)paren
op_ge
id|FB_MAX
)paren
r_break
suffix:semicolon
multiline_comment|/* XXX Temporary workaround: only open the first display so we don&squot;t&n;&t;&t; * lose debug output&n;&t;&t; */
r_break
suffix:semicolon
)brace
r_return
id|DOUBLEWORD_ALIGN
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
r_void
DECL|function|virt_irq_init
id|virt_irq_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|virt_irq_to_real_map
(braket
id|i
)braket
op_assign
id|UNDEFINED_IRQ
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|real_irq_to_virt_map
(braket
id|i
)braket
op_assign
id|UNDEFINED_IRQ
suffix:semicolon
)brace
multiline_comment|/* Create a mapping for a real_irq if it doesn&squot;t already exist.&n; * Return the virtual irq as a convenience.&n; */
r_int
r_int
DECL|function|virt_irq_create_mapping
id|virt_irq_create_mapping
c_func
(paren
r_int
r_int
id|real_irq
)paren
(brace
r_int
r_int
id|virq
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;interrupt_controller
op_eq
id|IC_OPEN_PIC
)paren
r_return
id|real_irq
suffix:semicolon
multiline_comment|/* no mapping for openpic (for now) */
id|virq
op_assign
id|real_irq_to_virt
c_func
(paren
id|real_irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|virq
op_eq
id|UNDEFINED_IRQ
)paren
(brace
multiline_comment|/* Assign a virtual IRQ number */
r_if
c_cond
(paren
id|real_irq
OL
id|NR_IRQS
op_logical_and
id|virt_irq_to_real
c_func
(paren
id|real_irq
)paren
op_eq
id|UNDEFINED_IRQ
)paren
(brace
multiline_comment|/* A 1-1 mapping will work. */
id|virq
op_assign
id|real_irq
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|last_virt_irq
OL
id|NR_IRQS
op_logical_and
id|virt_irq_to_real
c_func
(paren
op_increment
id|last_virt_irq
)paren
op_ne
id|UNDEFINED_IRQ
)paren
multiline_comment|/* skip irq&squot;s in use */
suffix:semicolon
r_if
c_cond
(paren
id|last_virt_irq
op_ge
id|NR_IRQS
)paren
id|panic
c_func
(paren
l_string|&quot;Too many IRQs are required on this system.  NR_IRQS=%d&bslash;n&quot;
comma
id|NR_IRQS
)paren
suffix:semicolon
id|virq
op_assign
id|last_virt_irq
suffix:semicolon
)brace
id|virt_irq_to_real_map
(braket
id|virq
)braket
op_assign
id|real_irq
suffix:semicolon
id|real_irq_to_virt_map
(braket
id|real_irq
)braket
op_assign
id|virq
suffix:semicolon
)brace
r_return
id|virq
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|prom_next_node
id|prom_next_node
c_func
(paren
id|phandle
op_star
id|nodep
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node
op_assign
op_star
id|nodep
)paren
op_ne
l_int|0
op_logical_and
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;child&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|node
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;parent&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Make a copy of the device tree from the PROM.&n; */
r_static
r_int
r_int
id|__init
DECL|function|copy_device_tree
id|copy_device_tree
c_func
(paren
r_int
r_int
id|mem_start
)paren
(brace
id|phandle
id|root
suffix:semicolon
r_int
r_int
id|new_start
suffix:semicolon
r_struct
id|device_node
op_star
op_star
id|allnextp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|mem_end
op_assign
id|mem_start
op_plus
(paren
l_int|8
op_lshift
l_int|20
)paren
suffix:semicolon
id|root
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
(paren
id|phandle
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|prom_panic
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;couldn&squot;t get device tree root&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|allnextp
op_assign
op_amp
id|RELOC
c_func
(paren
id|allnodes
)paren
suffix:semicolon
id|mem_start
op_assign
id|DOUBLEWORD_ALIGN
c_func
(paren
id|mem_start
)paren
suffix:semicolon
id|new_start
op_assign
id|inspect_node
c_func
(paren
id|root
comma
l_int|0
comma
id|mem_start
comma
id|mem_end
comma
op_amp
id|allnextp
)paren
suffix:semicolon
op_star
id|allnextp
op_assign
l_int|0
suffix:semicolon
r_return
id|new_start
suffix:semicolon
)brace
id|__init
r_static
r_int
r_int
DECL|function|inspect_node
id|inspect_node
c_func
(paren
id|phandle
id|node
comma
r_struct
id|device_node
op_star
id|dad
comma
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
comma
r_struct
id|device_node
op_star
op_star
op_star
id|allnextpp
)paren
(brace
r_int
id|l
suffix:semicolon
id|phandle
id|child
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|pp
comma
op_star
op_star
id|prev_propp
suffix:semicolon
r_char
op_star
id|prev_name
comma
op_star
id|namep
suffix:semicolon
r_int
r_char
op_star
id|valp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|np
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
r_sizeof
(paren
r_struct
id|device_node
)paren
suffix:semicolon
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;node
op_assign
id|node
suffix:semicolon
op_star
op_star
id|allnextpp
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
op_star
id|allnextpp
op_assign
op_amp
id|np-&gt;allnext
suffix:semicolon
r_if
c_cond
(paren
id|dad
op_ne
l_int|0
)paren
(brace
id|np-&gt;parent
op_assign
id|PTRUNRELOC
c_func
(paren
id|dad
)paren
suffix:semicolon
multiline_comment|/* we temporarily use the `next&squot; field as `last_child&squot;. */
r_if
c_cond
(paren
id|dad-&gt;next
op_eq
l_int|0
)paren
id|dad-&gt;child
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
id|dad-&gt;next-&gt;sibling
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
id|dad-&gt;next
op_assign
id|np
suffix:semicolon
)brace
multiline_comment|/* get and store all properties */
id|prev_propp
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prev_name
op_assign
id|RELOC
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pp
op_assign
(paren
r_struct
id|property
op_star
)paren
id|mem_start
suffix:semicolon
id|namep
op_assign
(paren
r_char
op_star
)paren
(paren
id|pp
op_plus
l_int|1
)paren
suffix:semicolon
id|pp-&gt;name
op_assign
id|PTRUNRELOC
c_func
(paren
id|namep
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;nextprop&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|prev_name
comma
id|namep
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|mem_start
op_assign
id|DOUBLEWORD_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|prev_name
op_assign
id|namep
suffix:semicolon
id|valp
op_assign
(paren
r_int
r_char
op_star
)paren
id|mem_start
suffix:semicolon
id|pp-&gt;value
op_assign
id|PTRUNRELOC
c_func
(paren
id|valp
)paren
suffix:semicolon
id|pp-&gt;length
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|namep
comma
id|valp
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|mem_start
op_assign
id|DOUBLEWORD_ALIGN
c_func
(paren
id|mem_start
op_plus
id|pp-&gt;length
)paren
suffix:semicolon
op_star
id|prev_propp
op_assign
id|PTRUNRELOC
c_func
(paren
id|pp
)paren
suffix:semicolon
id|prev_propp
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Add a &quot;linux_phandle&quot; value */
r_if
c_cond
(paren
id|np-&gt;node
)paren
(brace
id|u32
id|ibm_phandle
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* First see if &quot;ibm,phandle&quot; exists and use its value */
id|len
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;ibm,phandle&quot;
)paren
comma
op_amp
id|ibm_phandle
comma
r_sizeof
(paren
id|ibm_phandle
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|np-&gt;linux_phandle
op_assign
id|np-&gt;node
suffix:semicolon
)brace
r_else
(brace
id|np-&gt;linux_phandle
op_assign
id|ibm_phandle
suffix:semicolon
)brace
)brace
op_star
id|prev_propp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get the node&squot;s full name */
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
(paren
r_char
op_star
)paren
id|mem_start
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ge
l_int|0
)paren
(brace
id|np-&gt;full_name
op_assign
id|PTRUNRELOC
c_func
(paren
(paren
r_char
op_star
)paren
id|mem_start
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
(paren
id|mem_start
op_plus
id|l
)paren
op_assign
l_int|0
suffix:semicolon
id|mem_start
op_assign
id|DOUBLEWORD_ALIGN
c_func
(paren
id|mem_start
op_plus
id|l
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* do all our children */
id|child
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;child&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|child
op_ne
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|mem_start
op_assign
id|inspect_node
c_func
(paren
id|child
comma
id|np
comma
id|mem_start
comma
id|mem_end
comma
id|allnextpp
)paren
suffix:semicolon
id|child
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|child
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * finish_device_tree is called once things are running normally&n; * (i.e. with text and data mapped to the address they were linked at).&n; * It traverses the device tree and fills in the name, type,&n; * {n_}addrs and {n_}intrs fields of each node.&n; */
r_void
id|__init
DECL|function|finish_device_tree
id|finish_device_tree
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mem
op_assign
id|klimit
suffix:semicolon
id|virt_irq_init
c_func
(paren
)paren
suffix:semicolon
id|mem
op_assign
id|finish_node
c_func
(paren
id|allnodes
comma
id|mem
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|dev_tree_size
op_assign
id|mem
op_minus
(paren
r_int
r_int
)paren
id|allnodes
suffix:semicolon
id|mem
op_assign
id|_ALIGN
c_func
(paren
id|mem
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|lmb_reserve
c_func
(paren
id|__pa
c_func
(paren
id|klimit
)paren
comma
id|mem
op_minus
id|klimit
)paren
suffix:semicolon
id|klimit
op_assign
id|mem
suffix:semicolon
id|rtas.dev
op_assign
id|of_find_node_by_name
c_func
(paren
l_int|NULL
comma
l_string|&quot;rtas&quot;
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|finish_node
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
id|interpret_func
op_star
id|ifunc
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|device_node
op_star
id|child
suffix:semicolon
r_int
op_star
id|ip
suffix:semicolon
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;name&quot;
comma
l_int|0
)paren
suffix:semicolon
id|np-&gt;type
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* get the device addresses and interrupts */
r_if
c_cond
(paren
id|ifunc
op_ne
l_int|NULL
)paren
id|mem_start
op_assign
id|ifunc
c_func
(paren
id|np
comma
id|mem_start
comma
id|naddrc
comma
id|nsizec
)paren
suffix:semicolon
id|mem_start
op_assign
id|finish_node_interrupts
c_func
(paren
id|np
comma
id|mem_start
)paren
suffix:semicolon
multiline_comment|/* Look for #address-cells and #size-cells properties. */
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|naddrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|nsizec
op_assign
op_star
id|ip
suffix:semicolon
multiline_comment|/* the f50 sets the name to &squot;display&squot; and &squot;compatible&squot; to what we&n;&t; * expect for the name -- Cort&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;display&quot;
)paren
)paren
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;compatible&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;device-tree&quot;
)paren
op_logical_or
id|np-&gt;parent
op_eq
l_int|NULL
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;type
op_eq
l_int|0
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;pci&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;vci&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_pci_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_dbdma_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
id|ifunc
op_assign
id|interpret_macio_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;isa&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_isa_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;uni-n&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ifunc
op_eq
id|interpret_dbdma_props
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
op_logical_and
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;escc&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
)paren
)paren
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|np-&gt;child
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;sibling
)paren
id|mem_start
op_assign
id|finish_node
c_func
(paren
id|child
comma
id|mem_start
comma
id|ifunc
comma
id|naddrc
comma
id|nsizec
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the interrupt parent of a node.&n; */
r_static
r_struct
id|device_node
op_star
id|__devinit
DECL|function|intr_parent
id|intr_parent
c_func
(paren
r_struct
id|device_node
op_star
id|p
)paren
(brace
id|phandle
op_star
id|parp
suffix:semicolon
id|parp
op_assign
(paren
id|phandle
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-parent&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parp
op_eq
l_int|NULL
)paren
r_return
id|p-&gt;parent
suffix:semicolon
r_return
id|find_phandle
c_func
(paren
op_star
id|parp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find out the size of each entry of the interrupts property&n; * for a node.&n; */
r_static
r_int
id|__devinit
DECL|function|prom_n_intr_cells
id|prom_n_intr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|p
suffix:semicolon
r_int
r_int
op_star
id|icp
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|np
suffix:semicolon
(paren
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|icp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icp
op_ne
l_int|NULL
)paren
r_return
op_star
id|icp
suffix:semicolon
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
op_logical_or
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, node %s doesn&squot;t have #interrupt-cells&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_IRQ
id|printk
c_func
(paren
l_string|&quot;prom_n_intr_cells failed for %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Map an interrupt from a device up to the platform interrupt&n; * descriptor.&n; */
r_static
r_int
id|__devinit
DECL|function|map_interrupt
id|map_interrupt
c_func
(paren
r_int
r_int
op_star
op_star
id|irq
comma
r_struct
id|device_node
op_star
op_star
id|ictrler
comma
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
op_star
id|ints
comma
r_int
id|nintrc
)paren
(brace
r_struct
id|device_node
op_star
id|p
comma
op_star
id|ipar
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|imask
comma
op_star
id|ip
suffix:semicolon
r_int
id|i
comma
id|imaplen
comma
id|match
suffix:semicolon
r_int
id|newintrc
comma
id|newaddrc
suffix:semicolon
r_int
r_int
op_star
id|reg
suffix:semicolon
r_int
id|naddrc
suffix:semicolon
id|reg
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|naddrc
op_assign
id|prom_n_addr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|p
op_assign
id|intr_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
multiline_comment|/* this node is an interrupt controller, stop here */
r_break
suffix:semicolon
id|imap
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
op_amp
id|imaplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|imask
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map-mask&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imask
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, %s has interrupt-map but no mask&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|imaplen
op_div_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|match
op_assign
l_int|0
suffix:semicolon
id|ipar
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|imaplen
OG
l_int|0
op_logical_and
op_logical_neg
id|match
)paren
(brace
multiline_comment|/* check the child-interrupt field */
id|match
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naddrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|reg
(braket
id|i
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|naddrc
op_plus
id|nintrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|ints
(braket
id|i
op_minus
id|naddrc
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
id|imap
op_add_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
multiline_comment|/* grab the interrupt parent */
id|ipar
op_assign
id|find_phandle
c_func
(paren
(paren
id|phandle
)paren
op_star
id|imap
op_increment
)paren
suffix:semicolon
op_decrement
id|imaplen
suffix:semicolon
r_if
c_cond
(paren
id|ipar
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no int parent %x in map of %s&bslash;n&quot;
comma
id|imap
(braket
op_minus
l_int|1
)braket
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* find the parent&squot;s # addr and intr cells */
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no #interrupt-cells on %s&bslash;n&quot;
comma
id|ipar-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|newintrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|newaddrc
op_assign
(paren
id|ip
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
op_star
id|ip
suffix:semicolon
id|imap
op_add_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imaplen
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, error decoding int-map on %s, len=%d&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|imaplen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
macro_line|#ifdef DEBUG_IRQ
id|printk
c_func
(paren
l_string|&quot;oops, no match in %s int-map for %s&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|ipar
suffix:semicolon
id|naddrc
op_assign
id|newaddrc
suffix:semicolon
id|nintrc
op_assign
id|newintrc
suffix:semicolon
id|ints
op_assign
id|imap
op_minus
id|nintrc
suffix:semicolon
id|reg
op_assign
id|ints
op_minus
id|naddrc
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IRQ
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;hmmm, int tree for %s doesn&squot;t have ctrler&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
op_star
id|irq
op_assign
id|ints
suffix:semicolon
op_star
id|ictrler
op_assign
id|p
suffix:semicolon
r_return
id|nintrc
suffix:semicolon
)brace
multiline_comment|/*&n; * New version of finish_node_interrupts.&n; */
r_static
r_int
r_int
id|__init
DECL|function|finish_node_interrupts
id|finish_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_int
r_int
op_star
id|ints
suffix:semicolon
r_int
id|intlen
comma
id|intrcells
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|n
suffix:semicolon
r_int
r_int
op_star
id|irq
suffix:semicolon
r_struct
id|device_node
op_star
id|ic
suffix:semicolon
id|ints
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|intlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
op_eq
l_int|NULL
)paren
r_return
id|mem_start
suffix:semicolon
id|intrcells
op_assign
id|prom_n_intr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|intlen
op_div_assign
id|intrcells
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|intlen
suffix:semicolon
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
id|intlen
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intlen
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
l_int|0
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|map_interrupt
c_func
(paren
op_amp
id|irq
comma
op_amp
id|ic
comma
id|np
comma
id|ints
comma
id|intrcells
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
id|openpic_to_irq
c_func
(paren
id|virt_irq_create_mapping
c_func
(paren
id|irq
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* We offset irq numbers for the u3 MPIC by 128 in PowerMac */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
op_logical_and
id|ic
op_logical_and
id|ic-&gt;parent
)paren
(brace
r_char
op_star
id|name
op_assign
id|get_property
c_func
(paren
id|ic-&gt;parent
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_add_assign
l_int|128
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
l_int|1
)paren
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
id|irq
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hmmm, got %d intr cells for %s:&quot;
comma
id|n
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|irq
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ints
op_add_assign
id|intrcells
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_int
DECL|function|prom_n_addr_cells
id|prom_n_addr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #address-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|prom_n_size_cells
id|prom_n_size_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #size-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_pci_props
id|interpret_pci_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_dbdma_props
id|interpret_dbdma_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|reg_property32
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_macio_props
id|interpret_macio_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|reg_property32
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_isa_props
id|interpret_isa_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|isa_reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|isa_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|isa_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|rp
(braket
id|i
)braket
dot
id|space
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_root_props
id|interpret_root_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_int
r_int
op_star
id|rp
suffix:semicolon
r_int
id|rpsize
op_assign
(paren
id|naddrc
op_plus
id|nsizec
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
id|rpsize
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
id|rpsize
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|0
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|naddrc
op_minus
l_int|1
)braket
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|naddrc
op_plus
id|nsizec
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|i
suffix:semicolon
id|rp
op_add_assign
id|naddrc
op_plus
id|nsizec
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Work out the sense (active-low level / active-high edge)&n; * of each interrupt from the device tree.&n; */
r_void
id|__init
DECL|function|prom_get_irq_senses
id|prom_get_irq_senses
c_func
(paren
r_int
r_char
op_star
id|senses
comma
r_int
id|off
comma
r_int
id|max
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* default to level-triggered */
id|memset
c_func
(paren
id|senses
comma
l_int|1
comma
id|max
op_minus
id|off
)paren
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|np-&gt;n_intrs
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|line
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|off
op_logical_and
id|i
OL
id|max
)paren
id|senses
(braket
id|i
op_minus
id|off
)braket
op_assign
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|sense
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_devices
id|find_devices
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type.&n; */
r_struct
id|device_node
op_star
DECL|function|find_type_devices
id|find_type_devices
c_func
(paren
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns all nodes linked together&n; */
r_struct
id|device_node
op_star
DECL|function|find_all_nodes
id|find_all_nodes
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/* Checks if the given &quot;compat&quot; string matches one of the strings in&n; * the device&squot;s &quot;compatible&quot; property&n; */
r_int
DECL|function|device_is_compatible
id|device_is_compatible
c_func
(paren
r_struct
id|device_node
op_star
id|device
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
id|cplen
comma
id|l
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|device
comma
l_string|&quot;compatible&quot;
comma
op_amp
id|cplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cplen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|strncasecmp
c_func
(paren
id|cp
comma
id|compat
comma
id|strlen
c_func
(paren
id|compat
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|cp
)paren
op_plus
l_int|1
suffix:semicolon
id|cp
op_add_assign
id|l
suffix:semicolon
id|cplen
op_sub_assign
id|l
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Indicates whether the root node has a given value in its&n; * compatible property.&n; */
r_int
DECL|function|machine_is_compatible
id|machine_is_compatible
c_func
(paren
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|root
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|root
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
)paren
(brace
id|rc
op_assign
id|device_is_compatible
c_func
(paren
id|root
comma
id|compat
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|root
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type&n; * and compatible property.&n; */
r_struct
id|device_node
op_star
DECL|function|find_compatible_devices
id|find_compatible_devices
c_func
(paren
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compat
)paren
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device_node with a given full_name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_path_device
id|find_path_device
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*******&n; *&n; * New implementation of the OF &quot;find&quot; APIs, return a refcounted&n; * object, call of_node_put() when done.  The device tree and list&n; * are protected by a rw_lock.&n; *&n; * Note that property management will need some locking as well,&n; * this isn&squot;t dealt with yet.&n; *&n; *******/
multiline_comment|/**&n; *&t;of_find_node_by_name - Find a node by its &quot;name&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The name string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_name
r_struct
id|device_node
op_star
id|of_find_node_by_name
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_name
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_name
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_node_by_type - Find a node by its &quot;device_type&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The type string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_type
r_struct
id|device_node
op_star
id|of_find_node_by_type
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_type
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_type
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_compatible_node - Find a node based on type and one of the&n; *                                tokens in its &quot;compatible&quot; property&n; *&t;@from:&t;&t;The node to start searching from or NULL, the node&n; *&t;&t;&t;you pass will not be searched, only the next one&n; *&t;&t;&t;will; typically, you pass what the previous call&n; *&t;&t;&t;returned. of_node_put() will be called on it&n; *&t;@type:&t;&t;The type string to match &quot;device_type&quot; or NULL to ignore&n; *&t;@compatible:&t;The string to match to one of the tokens in the device&n; *&t;&t;&t;&quot;compatible&quot; list.&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_compatible_node
r_struct
id|device_node
op_star
id|of_find_compatible_node
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compatible
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compatible
)paren
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_compatible_node
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_compatible_node
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_node_by_path - Find a node matching a full OF path&n; *&t;@path:&t;The full path to match&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_path
r_struct
id|device_node
op_star
id|of_find_node_by_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|allnodes
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_path
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_path
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_all_nodes - Get next node in global list&n; *&t;@prev:&t;Previous node or NULL to start iteration&n; *&t;&t;of_node_put() will be called on it&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_all_nodes
r_struct
id|device_node
op_star
id|of_find_all_nodes
c_func
(paren
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|prev
ques
c_cond
id|prev-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|of_node_put
c_func
(paren
id|prev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_all_nodes
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_all_nodes
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_get_parent - Get a node&squot;s parent if any&n; *&t;@node:&t;Node to get parent&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_parent
r_struct
id|device_node
op_star
id|of_get_parent
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|of_node_get
c_func
(paren
id|node-&gt;parent
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_get_parent
id|EXPORT_SYMBOL
c_func
(paren
id|of_get_parent
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_get_next_child - Iterate a node childs&n; *&t;@node:&t;parent node&n; *&t;@prev:&t;previous child of the parent node, or NULL to get first&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_next_child
r_struct
id|device_node
op_star
id|of_get_next_child
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
comma
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_struct
id|device_node
op_star
id|next
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|next
op_assign
id|prev
ques
c_cond
id|prev-&gt;sibling
suffix:colon
id|node-&gt;child
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|next
op_ne
l_int|0
suffix:semicolon
id|next
op_assign
id|next-&gt;sibling
)paren
r_if
c_cond
(paren
id|of_node_get
c_func
(paren
id|next
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|of_node_put
c_func
(paren
id|prev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
DECL|variable|of_get_next_child
id|EXPORT_SYMBOL
c_func
(paren
id|of_get_next_child
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_node_get - Increment refcount of a node&n; *&t;@node:&t;Node to inc refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; *&t;Returns the node itself or NULL if gone.&n; */
DECL|function|of_node_get
r_struct
id|device_node
op_star
id|of_node_get
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
id|node
op_logical_and
op_logical_neg
id|OF_IS_STALE
c_func
(paren
id|node
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|node-&gt;_users
)paren
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|of_node_get
id|EXPORT_SYMBOL
c_func
(paren
id|of_node_get
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_node_put - Decrement refcount of a node&n; *&t;@node:&t;Node to dec refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; */
DECL|function|of_node_put
r_void
id|of_node_put
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|0
op_eq
id|atomic_read
c_func
(paren
op_amp
id|node-&gt;_users
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OF_IS_STALE
c_func
(paren
id|node
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|node-&gt;_users
)paren
)paren
(brace
id|of_node_cleanup
c_func
(paren
id|node
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
id|atomic_dec
c_func
(paren
op_amp
id|node-&gt;_users
)paren
suffix:semicolon
)brace
DECL|variable|of_node_put
id|EXPORT_SYMBOL
c_func
(paren
id|of_node_put
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_node_cleanup - release a dynamically allocated node&n; *&t;@arg:  Node to be released&n; */
DECL|function|of_node_cleanup
r_static
r_void
id|of_node_cleanup
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_struct
id|property
op_star
id|prop
op_assign
id|node-&gt;properties
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OF_IS_DYNAMIC
c_func
(paren
id|node
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|prop
)paren
(brace
r_struct
id|property
op_star
id|next
op_assign
id|prop-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;value
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop
)paren
suffix:semicolon
id|prop
op_assign
id|next
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|node-&gt;intrs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node-&gt;addrs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node-&gt;full_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;derive_parent - basically like dirname(1)&n; *&t;@path:  the full_name of a node to be added to the tree&n; *&n; *&t;Returns the node which should be the parent of the node&n; *&t;described by path.  E.g., for path = &quot;/foo/bar&quot;, returns&n; *&t;the node with full_name = &quot;/foo&quot;.&n; */
DECL|function|derive_parent
r_static
r_struct
id|device_node
op_star
id|derive_parent
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|parent_path
op_assign
l_string|&quot;/&quot;
suffix:semicolon
r_int
id|parent_path_len
op_assign
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_minus
id|path
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* reject if path is &quot;/&quot; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|path
comma
l_string|&quot;/&quot;
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_ne
id|path
)paren
(brace
id|parent_path
op_assign
id|kmalloc
c_func
(paren
id|parent_path_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent_path
)paren
r_return
l_int|NULL
suffix:semicolon
id|strlcpy
c_func
(paren
id|parent_path
comma
id|path
comma
id|parent_path_len
)paren
suffix:semicolon
)brace
id|parent
op_assign
id|of_find_node_by_path
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|parent_path
comma
l_string|&quot;/&quot;
)paren
)paren
id|kfree
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_return
id|parent
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines for &quot;runtime&quot; addition and removal of device tree nodes.&n; */
multiline_comment|/*&n; * Given a path and a property list, construct an OF device node, add&n; * it to the device tree and global list, and place it in&n; * /proc/device-tree.  This function may sleep.&n; */
DECL|function|of_add_node
r_int
id|of_add_node
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|property
op_star
id|proplist
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|np
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;full_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;full_name
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
suffix:semicolon
id|np-&gt;properties
op_assign
id|proplist
suffix:semicolon
id|OF_MARK_DYNAMIC
c_func
(paren
id|np
)paren
suffix:semicolon
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;parent
op_assign
id|derive_parent
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;parent
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* could also be ENOMEM, though */
)brace
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|err
op_assign
id|of_finish_dynamic_node
c_func
(paren
id|np
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np-&gt;sibling
op_assign
id|np-&gt;parent-&gt;child
suffix:semicolon
id|np-&gt;allnext
op_assign
id|allnodes
suffix:semicolon
id|np-&gt;parent-&gt;child
op_assign
id|np
suffix:semicolon
id|allnodes
op_assign
id|np
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|add_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an OF device node from the system.&n; * Caller should have already &quot;gotten&quot; np.&n; */
DECL|function|of_remove_node
r_int
id|of_remove_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|parent
comma
op_star
id|child
suffix:semicolon
id|parent
op_assign
id|of_get_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Make sure we are not recursively removing&n;&t; * more than one level of nodes.  We need to&n;&t; * allow this so we can remove a slot containing&n;&t; * an IOA.&n;&t; */
r_for
c_loop
(paren
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
l_int|NULL
)paren
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
id|child
)paren
)paren
(brace
r_struct
id|device_node
op_star
id|grandchild
suffix:semicolon
r_if
c_cond
(paren
(paren
id|grandchild
op_assign
id|of_get_next_child
c_func
(paren
id|child
comma
l_int|NULL
)paren
)paren
)paren
(brace
multiline_comment|/* Too deep */
id|of_node_put
c_func
(paren
id|grandchild
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/* Now that we&squot;re reasonably sure that we won&squot;t&n;&t; * overflow our stack, remove any children of np.&n;&t; */
r_for
c_loop
(paren
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
l_int|NULL
)paren
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
id|child
)paren
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|of_remove_node
c_func
(paren
id|child
)paren
)paren
)paren
(brace
id|of_node_put
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
id|write_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|OF_MARK_STALE
c_func
(paren
id|np
)paren
suffix:semicolon
id|remove_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allnodes
op_eq
id|np
)paren
id|allnodes
op_assign
id|np-&gt;allnext
suffix:semicolon
r_else
(brace
r_struct
id|device_node
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
id|allnodes
suffix:semicolon
id|prev-&gt;allnext
op_ne
id|np
suffix:semicolon
id|prev
op_assign
id|prev-&gt;allnext
)paren
suffix:semicolon
id|prev-&gt;allnext
op_assign
id|np-&gt;allnext
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parent-&gt;child
op_eq
id|np
)paren
id|parent-&gt;child
op_assign
id|np-&gt;sibling
suffix:semicolon
r_else
(brace
r_struct
id|device_node
op_star
id|prevsib
suffix:semicolon
r_for
c_loop
(paren
id|prevsib
op_assign
id|np-&gt;parent-&gt;child
suffix:semicolon
id|prevsib-&gt;sibling
op_ne
id|np
suffix:semicolon
id|prevsib
op_assign
id|prevsib-&gt;sibling
)paren
suffix:semicolon
id|prevsib-&gt;sibling
op_assign
id|np-&gt;sibling
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_DEVICETREE
multiline_comment|/*&n; * Add a node to /proc/device-tree.&n; */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|proc_mkdir
c_func
(paren
id|strrchr
c_func
(paren
id|np-&gt;full_name
comma
l_char|&squot;/&squot;
)paren
op_plus
l_int|1
comma
id|np-&gt;parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
id|proc_device_tree_add_node
c_func
(paren
id|np
comma
id|ent
)paren
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
r_struct
id|device_node
op_star
id|parent
op_assign
id|np-&gt;parent
suffix:semicolon
r_while
c_loop
(paren
id|pp
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|pp-&gt;name
comma
id|np-&gt;pde
)paren
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Assuming that symlinks have the same parent directory as&n;&t; * np-&gt;pde.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;name_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;name_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;addr_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;addr_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;pde
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;pde-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PROC_DEVICETREE */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_DEVICETREE */
multiline_comment|/*&n; * Fix up the uninitialized fields in a new device node:&n; * name, type, n_addrs, addrs, n_intrs, intrs, and pci-specific fields&n; *&n; * A lot of boot-time code is duplicated here, because functions such&n; * as finish_node_interrupts, interpret_pci_props, etc. cannot use the&n; * slab allocator.&n; *&n; * This should probably be split up into smaller chunks.&n; */
DECL|function|of_finish_dynamic_node
r_static
r_int
id|of_finish_dynamic_node
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_struct
id|device_node
op_star
id|parent
op_assign
id|of_get_parent
c_func
(paren
id|node
)paren
suffix:semicolon
id|u32
op_star
id|regs
suffix:semicolon
r_int
r_int
op_star
id|ints
suffix:semicolon
r_int
id|intlen
comma
id|intrcells
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|n
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|irq
suffix:semicolon
r_struct
id|device_node
op_star
id|ic
suffix:semicolon
id|node-&gt;name
op_assign
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
l_int|0
)paren
suffix:semicolon
id|node-&gt;type
op_assign
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t support that function on PowerMac, at least&n;&t; * not yet&n;&t; */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* do the work of interpret_pci_props */
r_if
c_cond
(paren
id|parent-&gt;type
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|parent-&gt;type
comma
l_string|&quot;pci&quot;
)paren
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|address_range
)paren
op_star
(paren
id|l
op_div
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|node-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|node-&gt;n_addrs
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* now do the work of finish_node_interrupts */
id|ints
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|intlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ints
)paren
r_goto
id|out
suffix:semicolon
id|intrcells
op_assign
id|prom_n_intr_cells
c_func
(paren
id|node
)paren
suffix:semicolon
id|intlen
op_div_assign
id|intrcells
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|node-&gt;n_intrs
op_assign
id|intlen
suffix:semicolon
id|node-&gt;intrs
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
op_star
id|intlen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;intrs
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intlen
suffix:semicolon
op_increment
id|i
)paren
(brace
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
l_int|0
suffix:semicolon
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|map_interrupt
c_func
(paren
op_amp
id|irq
comma
op_amp
id|ic
comma
id|node
comma
id|ints
comma
id|intrcells
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
id|openpic_to_irq
c_func
(paren
id|virt_irq_create_mapping
c_func
(paren
id|irq
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|1
)paren
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
id|irq
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;hmmm, got %d intr cells for %s:&quot;
comma
id|n
comma
id|node-&gt;full_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|irq
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ints
op_add_assign
id|intrcells
suffix:semicolon
)brace
multiline_comment|/* now do the rough equivalent of update_dn_pci_info, this&n;        * probably is not correct for phb&squot;s, but should work for&n;&t;* IOAs and slots.&n;        */
id|node-&gt;phb
op_assign
id|parent-&gt;phb
suffix:semicolon
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs
)paren
(brace
id|node-&gt;busno
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|node-&gt;devfn
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* fixing up tce_table */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|node-&gt;name
comma
l_string|&quot;pci&quot;
)paren
op_eq
l_int|0
op_logical_and
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|node-&gt;bussubno
op_assign
id|node-&gt;busno
suffix:semicolon
id|create_pci_bus_tce_table
c_func
(paren
(paren
r_int
r_int
)paren
id|node
)paren
suffix:semicolon
)brace
r_else
id|node-&gt;tce_table
op_assign
id|parent-&gt;tce_table
suffix:semicolon
id|out
suffix:colon
id|of_node_put
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device_node with a given phandle.&n; */
r_static
r_struct
id|device_node
op_star
id|__devinit
DECL|function|find_phandle
id|find_phandle
c_func
(paren
id|phandle
id|ph
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;linux_phandle
op_eq
id|ph
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a property with a given name for a given node&n; * and return the value.&n; */
r_int
r_char
op_star
DECL|function|get_property
id|get_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pp-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lenp
op_ne
l_int|0
)paren
op_star
id|lenp
op_assign
id|pp-&gt;length
suffix:semicolon
r_return
id|pp-&gt;value
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a property to a node&n; */
r_void
DECL|function|prom_add_property
id|prom_add_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_struct
id|property
op_star
id|prop
)paren
(brace
r_struct
id|property
op_star
op_star
id|next
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prop-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|next
)paren
id|next
op_assign
op_amp
(paren
op_star
id|next
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
op_star
id|next
op_assign
id|prop
suffix:semicolon
)brace
macro_line|#if 0
r_void
id|print_properties
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|pp-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|strlen
c_func
(paren
id|pp-&gt;name
)paren
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pp-&gt;length
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|cp
)paren
r_if
c_cond
(paren
(paren
id|i
OG
l_int|1
op_logical_and
(paren
op_star
id|cp
template_param
l_int|0x7e
)paren
)paren
op_logical_or
(paren
id|i
op_eq
l_int|1
op_logical_and
op_star
id|cp
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|pp-&gt;length
OG
l_int|1
)paren
(brace
multiline_comment|/* looks like a string */
id|printk
c_func
(paren
l_string|&quot; %s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|pp-&gt;value
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dump it in hex */
id|n
op_assign
id|pp-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|64
)paren
id|n
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
op_mod
l_int|4
op_eq
l_int|0
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pp-&gt;value
suffix:semicolon
id|n
op_div_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %08x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
op_star
id|bp
op_assign
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|bp
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OG
l_int|64
)paren
id|printk
c_func
(paren
l_string|&quot;                 ... (length = %d)&bslash;n&quot;
comma
id|pp-&gt;length
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/* Verify bi_recs are good */
r_static
r_struct
id|bi_record
op_star
DECL|function|prom_bi_rec_verify
id|prom_bi_rec_verify
c_func
(paren
r_struct
id|bi_record
op_star
id|bi_recs
)paren
(brace
r_struct
id|bi_record
op_star
id|first
comma
op_star
id|last
suffix:semicolon
r_if
c_cond
(paren
id|bi_recs
op_eq
l_int|NULL
op_logical_or
id|bi_recs-&gt;tag
op_ne
id|BI_FIRST
)paren
r_return
l_int|NULL
suffix:semicolon
id|last
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
r_int
)paren
id|bi_recs-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_int|NULL
op_logical_or
id|last-&gt;tag
op_ne
id|BI_LAST
)paren
r_return
l_int|NULL
suffix:semicolon
id|first
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
r_int
)paren
id|last-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_int|NULL
op_logical_or
id|first
op_ne
id|bi_recs
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|bi_recs
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|prom_bi_rec_reserve
id|prom_bi_rec_reserve
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_t
op_star
id|_prom
op_assign
id|PTRRELOC
c_func
(paren
op_amp
id|prom
)paren
suffix:semicolon
r_struct
id|bi_record
op_star
id|rec
suffix:semicolon
r_if
c_cond
(paren
id|_prom-&gt;bi_recs
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|rec
op_assign
id|_prom-&gt;bi_recs
suffix:semicolon
id|rec-&gt;tag
op_ne
id|BI_LAST
suffix:semicolon
id|rec
op_assign
id|bi_rec_next
c_func
(paren
id|rec
)paren
)paren
(brace
r_switch
c_cond
(paren
id|rec-&gt;tag
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_case
id|BI_INITRD
suffix:colon
id|lmb_reserve
c_func
(paren
id|rec-&gt;data
(braket
l_int|0
)braket
comma
id|rec-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
)brace
)brace
multiline_comment|/* The next use of this field will be after relocation&n;&t; &t; * is enabled, so convert this physical address into a&n;&t; &t; * virtual address.&n;&t; &t; */
id|_prom-&gt;bi_recs
op_assign
id|PTRUNRELOC
c_func
(paren
id|_prom-&gt;bi_recs
)paren
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
eof
