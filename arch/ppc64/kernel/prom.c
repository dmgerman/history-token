multiline_comment|/*&n; * &n; *&n; * Procedures for interfacing to Open Firmware.&n; *&n; * Paul Mackerras&t;August 1996.&n; * Copyright (C) 1996 Paul Mackerras.&n; * &n; *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.&n; *    {engebret|bergner}@us.ibm.com &n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stringify.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/lmb.h&gt;
macro_line|#include &lt;asm/abs_addr.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(fmt...) udbg_printf(fmt)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(fmt...)
macro_line|#endif
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
id|u32
id|size_hi
suffix:semicolon
DECL|member|size_lo
id|u32
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|isa_reg_property
r_struct
id|isa_reg_property
(brace
DECL|member|space
id|u32
id|space
suffix:semicolon
DECL|member|address
id|u32
id|address
suffix:semicolon
DECL|member|size
id|u32
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|interpret_func
r_typedef
r_int
r_int
id|interpret_func
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_struct
id|rtas_t
id|rtas
suffix:semicolon
r_extern
r_struct
id|lmb
id|lmb
suffix:semicolon
r_extern
r_int
r_int
id|klimit
suffix:semicolon
DECL|variable|dt_root_addr_cells
r_static
r_int
id|__initdata
id|dt_root_addr_cells
suffix:semicolon
DECL|variable|dt_root_size_cells
r_static
r_int
id|__initdata
id|dt_root_size_cells
suffix:semicolon
DECL|variable|iommu_is_off
r_static
r_int
id|__initdata
id|iommu_is_off
suffix:semicolon
DECL|variable|iommu_force_on
r_int
id|__initdata
id|iommu_force_on
suffix:semicolon
DECL|typedef|cell_t
r_typedef
id|u32
id|cell_t
suffix:semicolon
macro_line|#if 0
r_static
r_struct
id|boot_param_header
op_star
id|initial_boot_params
id|__initdata
suffix:semicolon
macro_line|#else
DECL|variable|initial_boot_params
r_struct
id|boot_param_header
op_star
id|initial_boot_params
suffix:semicolon
macro_line|#endif
DECL|variable|allnodes
r_static
r_struct
id|device_node
op_star
id|allnodes
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* use when traversing tree through the allnext, child, sibling,&n; * or parent members of struct device_node.&n; */
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|devtree_lock
)paren
suffix:semicolon
multiline_comment|/* export that to outside world */
DECL|variable|of_chosen
r_struct
id|device_node
op_star
id|of_chosen
suffix:semicolon
multiline_comment|/*&n; * Find the device_node with a given phandle.&n; */
DECL|function|find_phandle
r_static
r_struct
id|device_node
op_star
id|find_phandle
c_func
(paren
id|phandle
id|ph
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;linux_phandle
op_eq
id|ph
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the interrupt parent of a node.&n; */
DECL|function|intr_parent
r_static
r_struct
id|device_node
op_star
id|__devinit
id|intr_parent
c_func
(paren
r_struct
id|device_node
op_star
id|p
)paren
(brace
id|phandle
op_star
id|parp
suffix:semicolon
id|parp
op_assign
(paren
id|phandle
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-parent&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parp
op_eq
l_int|NULL
)paren
r_return
id|p-&gt;parent
suffix:semicolon
r_return
id|find_phandle
c_func
(paren
op_star
id|parp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find out the size of each entry of the interrupts property&n; * for a node.&n; */
DECL|function|prom_n_intr_cells
r_int
id|__devinit
id|prom_n_intr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|p
suffix:semicolon
r_int
r_int
op_star
id|icp
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|np
suffix:semicolon
(paren
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|icp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icp
op_ne
l_int|NULL
)paren
r_return
op_star
id|icp
suffix:semicolon
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
op_logical_or
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, node %s doesn&squot;t have #interrupt-cells&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_IRQ
id|printk
c_func
(paren
l_string|&quot;prom_n_intr_cells failed for %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Map an interrupt from a device up to the platform interrupt&n; * descriptor.&n; */
DECL|function|map_interrupt
r_static
r_int
id|__devinit
id|map_interrupt
c_func
(paren
r_int
r_int
op_star
op_star
id|irq
comma
r_struct
id|device_node
op_star
op_star
id|ictrler
comma
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
op_star
id|ints
comma
r_int
id|nintrc
)paren
(brace
r_struct
id|device_node
op_star
id|p
comma
op_star
id|ipar
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|imask
comma
op_star
id|ip
suffix:semicolon
r_int
id|i
comma
id|imaplen
comma
id|match
suffix:semicolon
r_int
id|newintrc
op_assign
l_int|0
comma
id|newaddrc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|reg
suffix:semicolon
r_int
id|naddrc
suffix:semicolon
id|reg
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|naddrc
op_assign
id|prom_n_addr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|p
op_assign
id|intr_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
multiline_comment|/* this node is an interrupt controller, stop here */
r_break
suffix:semicolon
id|imap
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
op_amp
id|imaplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|imask
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map-mask&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imask
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, %s has interrupt-map but no mask&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|imaplen
op_div_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|match
op_assign
l_int|0
suffix:semicolon
id|ipar
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|imaplen
OG
l_int|0
op_logical_and
op_logical_neg
id|match
)paren
(brace
multiline_comment|/* check the child-interrupt field */
id|match
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naddrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|reg
(braket
id|i
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|naddrc
op_plus
id|nintrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|ints
(braket
id|i
op_minus
id|naddrc
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
id|imap
op_add_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
multiline_comment|/* grab the interrupt parent */
id|ipar
op_assign
id|find_phandle
c_func
(paren
(paren
id|phandle
)paren
op_star
id|imap
op_increment
)paren
suffix:semicolon
op_decrement
id|imaplen
suffix:semicolon
r_if
c_cond
(paren
id|ipar
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no int parent %x in map of %s&bslash;n&quot;
comma
id|imap
(braket
op_minus
l_int|1
)braket
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* find the parent&squot;s # addr and intr cells */
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no #interrupt-cells on %s&bslash;n&quot;
comma
id|ipar-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|newintrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|newaddrc
op_assign
(paren
id|ip
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
op_star
id|ip
suffix:semicolon
id|imap
op_add_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imaplen
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, error decoding int-map on %s, len=%d&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|imaplen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
macro_line|#ifdef DEBUG_IRQ
id|printk
c_func
(paren
l_string|&quot;oops, no match in %s int-map for %s&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|ipar
suffix:semicolon
id|naddrc
op_assign
id|newaddrc
suffix:semicolon
id|nintrc
op_assign
id|newintrc
suffix:semicolon
id|ints
op_assign
id|imap
op_minus
id|nintrc
suffix:semicolon
id|reg
op_assign
id|ints
op_minus
id|naddrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_IRQ
id|printk
c_func
(paren
l_string|&quot;hmmm, int tree for %s doesn&squot;t have ctrler&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|irq
op_assign
id|ints
suffix:semicolon
op_star
id|ictrler
op_assign
id|p
suffix:semicolon
r_return
id|nintrc
suffix:semicolon
)brace
DECL|function|finish_node_interrupts
r_static
r_int
r_int
id|__init
id|finish_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|measure_only
)paren
(brace
r_int
r_int
op_star
id|ints
suffix:semicolon
r_int
id|intlen
comma
id|intrcells
comma
id|intrcount
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|n
suffix:semicolon
r_int
r_int
op_star
id|irq
comma
id|virq
suffix:semicolon
r_struct
id|device_node
op_star
id|ic
suffix:semicolon
id|ints
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|intlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
op_eq
l_int|NULL
)paren
r_return
id|mem_start
suffix:semicolon
id|intrcells
op_assign
id|prom_n_intr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|intlen
op_div_assign
id|intrcells
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
id|intlen
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|measure_only
)paren
r_return
id|mem_start
suffix:semicolon
id|intrcount
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intlen
suffix:semicolon
op_increment
id|i
comma
id|ints
op_add_assign
id|intrcells
)paren
(brace
id|n
op_assign
id|map_interrupt
c_func
(paren
op_amp
id|irq
comma
op_amp
id|ic
comma
id|np
comma
id|ints
comma
id|intrcells
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* don&squot;t map IRQ numbers under a cascaded 8259 controller */
r_if
c_cond
(paren
id|ic
op_logical_and
id|device_is_compatible
c_func
(paren
id|ic
comma
l_string|&quot;chrp,iic&quot;
)paren
)paren
(brace
id|np-&gt;intrs
(braket
id|intrcount
)braket
dot
id|line
op_assign
id|irq
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|virq
op_assign
id|virt_irq_create_mapping
c_func
(paren
id|irq
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|virq
op_eq
id|NO_IRQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Could not allocate interrupt&quot;
l_string|&quot; number for %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|np-&gt;intrs
(braket
id|intrcount
)braket
dot
id|line
op_assign
id|irq_offset_up
c_func
(paren
id|virq
)paren
suffix:semicolon
)brace
multiline_comment|/* We offset irq numbers for the u3 MPIC by 128 in PowerMac */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
op_logical_and
id|ic
op_logical_and
id|ic-&gt;parent
)paren
(brace
r_char
op_star
id|name
op_assign
id|get_property
c_func
(paren
id|ic-&gt;parent
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|np-&gt;intrs
(braket
id|intrcount
)braket
dot
id|line
op_add_assign
l_int|128
suffix:semicolon
)brace
id|np-&gt;intrs
(braket
id|intrcount
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|1
)paren
id|np-&gt;intrs
(braket
id|intrcount
)braket
dot
id|sense
op_assign
id|irq
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hmmm, got %d intr cells for %s:&quot;
comma
id|n
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|irq
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
op_increment
id|intrcount
suffix:semicolon
)brace
id|np-&gt;n_intrs
op_assign
id|intrcount
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|interpret_pci_props
r_static
r_int
r_int
id|__init
id|interpret_pci_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|interpret_dbdma_props
r_static
r_int
r_int
id|__init
id|interpret_dbdma_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|reg_property32
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|interpret_macio_props
r_static
r_int
r_int
id|__init
id|interpret_macio_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|reg_property32
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property32
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|interpret_isa_props
r_static
r_int
r_int
id|__init
id|interpret_isa_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|isa_reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|isa_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|isa_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|isa_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|rp
(braket
id|i
)braket
dot
id|space
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|interpret_root_props
r_static
r_int
r_int
id|__init
id|interpret_root_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_int
r_int
op_star
id|rp
suffix:semicolon
r_int
id|rpsize
op_assign
(paren
id|naddrc
op_plus
id|nsizec
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
id|rpsize
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
id|rpsize
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|measure_only
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|0
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|naddrc
op_minus
l_int|1
)braket
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|naddrc
op_plus
id|nsizec
op_minus
l_int|1
)braket
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
id|rp
op_add_assign
id|naddrc
op_plus
id|nsizec
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|finish_node
r_static
r_int
r_int
id|__init
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
id|interpret_func
op_star
id|ifunc
comma
r_int
id|naddrc
comma
r_int
id|nsizec
comma
r_int
id|measure_only
)paren
(brace
r_struct
id|device_node
op_star
id|child
suffix:semicolon
r_int
op_star
id|ip
suffix:semicolon
multiline_comment|/* get the device addresses and interrupts */
r_if
c_cond
(paren
id|ifunc
op_ne
l_int|NULL
)paren
id|mem_start
op_assign
id|ifunc
c_func
(paren
id|np
comma
id|mem_start
comma
id|naddrc
comma
id|nsizec
comma
id|measure_only
)paren
suffix:semicolon
id|mem_start
op_assign
id|finish_node_interrupts
c_func
(paren
id|np
comma
id|mem_start
comma
id|measure_only
)paren
suffix:semicolon
multiline_comment|/* Look for #address-cells and #size-cells properties. */
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|naddrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|nsizec
op_assign
op_star
id|ip
suffix:semicolon
multiline_comment|/* the f50 sets the name to &squot;display&squot; and &squot;compatible&squot; to what we&n;&t; * expect for the name -- Cort&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;display&quot;
)paren
)paren
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;compatible&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;device-tree&quot;
)paren
op_logical_or
id|np-&gt;parent
op_eq
l_int|NULL
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;type
op_eq
l_int|0
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;pci&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;vci&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_pci_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_dbdma_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
id|ifunc
op_assign
id|interpret_macio_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;isa&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_isa_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;uni-n&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ifunc
op_eq
id|interpret_dbdma_props
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
op_logical_and
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;escc&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
)paren
)paren
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|np-&gt;child
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;sibling
)paren
id|mem_start
op_assign
id|finish_node
c_func
(paren
id|child
comma
id|mem_start
comma
id|ifunc
comma
id|naddrc
comma
id|nsizec
comma
id|measure_only
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/**&n; * finish_device_tree is called once things are running normally&n; * (i.e. with text and data mapped to the address they were linked at).&n; * It traverses the device tree and fills in some of the additional,&n; * fields in each node like {n_}addrs and {n_}intrs, the virt interrupt&n; * mapping is also initialized at this point.&n; */
DECL|function|finish_device_tree
r_void
id|__init
id|finish_device_tree
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mem
comma
id|size
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; finish_device_tree&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc64_interrupt_controller
op_eq
id|IC_INVALID
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;failed to configure interrupt controller type&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;failed to configure interrupt controller type&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize virtual IRQ map */
id|virt_irq_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Finish device-tree (pre-parsing some properties etc...) */
id|size
op_assign
id|finish_node
c_func
(paren
id|allnodes
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|mem
op_assign
(paren
r_int
r_int
)paren
id|abs_to_virt
c_func
(paren
id|lmb_alloc
c_func
(paren
id|size
comma
l_int|128
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finish_node
c_func
(paren
id|allnodes
comma
id|mem
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_ne
id|mem
op_plus
id|size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- finish_device_tree&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|macro|printk
mdefine_line|#define printk udbg_printf
macro_line|#endif
DECL|function|find_flat_dt_string
r_static
r_inline
r_char
op_star
id|find_flat_dt_string
c_func
(paren
id|u32
id|offset
)paren
(brace
r_return
(paren
(paren
r_char
op_star
)paren
id|initial_boot_params
)paren
op_plus
id|initial_boot_params-&gt;off_dt_strings
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/**&n; * This function is used to scan the flattened device-tree, it is&n; * used to extract the memory informations at boot before we can&n; * unflatten the tree&n; */
DECL|function|scan_flat_dt
r_static
r_int
id|__init
id|scan_flat_dt
c_func
(paren
r_int
(paren
op_star
id|it
)paren
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|full_path
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_int
r_int
id|p
op_assign
(paren
(paren
r_int
r_int
)paren
id|initial_boot_params
)paren
op_plus
id|initial_boot_params-&gt;off_dt_struct
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|u32
id|tag
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
suffix:semicolon
r_char
op_star
id|pathp
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|OF_DT_END_NODE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|OF_DT_END
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|OF_DT_PROP
)paren
(brace
id|u32
id|sz
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|8
suffix:semicolon
id|p
op_assign
id|_ALIGN
c_func
(paren
id|p
comma
id|sz
op_ge
l_int|8
ques
c_cond
l_int|8
suffix:colon
l_int|4
)paren
suffix:semicolon
id|p
op_add_assign
id|sz
suffix:semicolon
id|p
op_assign
id|_ALIGN
c_func
(paren
id|p
comma
l_int|4
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_ne
id|OF_DT_BEGIN_NODE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid tag %x scanning flattened&quot;
l_string|&quot; device tree !&bslash;n&quot;
comma
id|tag
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pathp
op_assign
(paren
r_char
op_star
)paren
id|p
suffix:semicolon
id|p
op_assign
id|_ALIGN
c_func
(paren
id|p
op_plus
id|strlen
c_func
(paren
id|pathp
)paren
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
id|rc
op_assign
id|it
c_func
(paren
id|p
comma
id|pathp
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * This  function can be used within scan_flattened_dt callback to get&n; * access to properties&n; */
DECL|function|get_flat_dt_prop
r_static
r_void
op_star
id|__init
id|get_flat_dt_prop
c_func
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_int
r_int
id|p
op_assign
id|node
suffix:semicolon
r_do
(brace
id|u32
id|tag
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
suffix:semicolon
id|u32
id|sz
comma
id|noff
suffix:semicolon
r_const
r_char
op_star
id|nstr
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
id|OF_DT_PROP
)paren
r_return
l_int|NULL
suffix:semicolon
id|sz
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
suffix:semicolon
id|noff
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
id|p
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|p
op_add_assign
l_int|8
suffix:semicolon
id|p
op_assign
id|_ALIGN
c_func
(paren
id|p
comma
id|sz
op_ge
l_int|8
ques
c_cond
l_int|8
suffix:colon
l_int|4
)paren
suffix:semicolon
id|nstr
op_assign
id|find_flat_dt_string
c_func
(paren
id|noff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nstr
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t find property index name !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|nstr
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|size
)paren
op_star
id|size
op_assign
id|sz
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
)brace
id|p
op_add_assign
id|sz
suffix:semicolon
id|p
op_assign
id|_ALIGN
c_func
(paren
id|p
comma
l_int|4
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|unflatten_dt_alloc
r_static
r_void
op_star
id|__init
id|unflatten_dt_alloc
c_func
(paren
r_int
r_int
op_star
id|mem
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_void
op_star
id|res
suffix:semicolon
op_star
id|mem
op_assign
id|_ALIGN
c_func
(paren
op_star
id|mem
comma
id|align
)paren
suffix:semicolon
id|res
op_assign
(paren
r_void
op_star
)paren
op_star
id|mem
suffix:semicolon
op_star
id|mem
op_add_assign
id|size
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|unflatten_dt_node
r_static
r_int
r_int
id|__init
id|unflatten_dt_node
c_func
(paren
r_int
r_int
id|mem
comma
r_int
r_int
op_star
id|p
comma
r_struct
id|device_node
op_star
id|dad
comma
r_struct
id|device_node
op_star
op_star
op_star
id|allnextpp
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|pp
comma
op_star
op_star
id|prev_pp
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|pathp
suffix:semicolon
id|u32
id|tag
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
id|tag
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
id|OF_DT_BEGIN_NODE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Weird tag at start of node: %x&bslash;n&quot;
comma
id|tag
)paren
suffix:semicolon
r_return
id|mem
suffix:semicolon
)brace
op_star
id|p
op_add_assign
l_int|4
suffix:semicolon
id|pathp
op_assign
(paren
r_char
op_star
)paren
op_star
id|p
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|pathp
)paren
op_plus
l_int|1
suffix:semicolon
op_star
id|p
op_assign
id|_ALIGN
c_func
(paren
op_star
id|p
op_plus
id|l
comma
l_int|4
)paren
suffix:semicolon
id|np
op_assign
id|unflatten_dt_alloc
c_func
(paren
op_amp
id|mem
comma
r_sizeof
(paren
r_struct
id|device_node
)paren
op_plus
id|l
comma
id|__alignof__
c_func
(paren
r_struct
id|device_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allnextpp
)paren
(brace
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;full_name
op_assign
(paren
(paren
r_char
op_star
)paren
id|np
)paren
op_plus
r_sizeof
(paren
r_struct
id|device_node
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|np-&gt;full_name
comma
id|pathp
comma
id|l
)paren
suffix:semicolon
id|prev_pp
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
op_star
op_star
id|allnextpp
op_assign
id|np
suffix:semicolon
op_star
id|allnextpp
op_assign
op_amp
id|np-&gt;allnext
suffix:semicolon
r_if
c_cond
(paren
id|dad
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;parent
op_assign
id|dad
suffix:semicolon
multiline_comment|/* we temporarily use the `next&squot; field as `last_child&squot;. */
r_if
c_cond
(paren
id|dad-&gt;next
op_eq
l_int|0
)paren
id|dad-&gt;child
op_assign
id|np
suffix:semicolon
r_else
id|dad-&gt;next-&gt;sibling
op_assign
id|np
suffix:semicolon
id|dad-&gt;next
op_assign
id|np
suffix:semicolon
)brace
id|kref_init
c_func
(paren
op_amp
id|np-&gt;kref
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|u32
id|sz
comma
id|noff
suffix:semicolon
r_char
op_star
id|pname
suffix:semicolon
id|tag
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
id|OF_DT_PROP
)paren
r_break
suffix:semicolon
op_star
id|p
op_add_assign
l_int|4
suffix:semicolon
id|sz
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|noff
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
(paren
op_star
id|p
)paren
op_plus
l_int|4
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
id|_ALIGN
c_func
(paren
(paren
op_star
id|p
)paren
op_plus
l_int|8
comma
id|sz
op_ge
l_int|8
ques
c_cond
l_int|8
suffix:colon
l_int|4
)paren
suffix:semicolon
id|pname
op_assign
id|find_flat_dt_string
c_func
(paren
id|noff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pname
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t find property name in list !&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|l
op_assign
id|strlen
c_func
(paren
id|pname
)paren
op_plus
l_int|1
suffix:semicolon
id|pp
op_assign
id|unflatten_dt_alloc
c_func
(paren
op_amp
id|mem
comma
r_sizeof
(paren
r_struct
id|property
)paren
comma
id|__alignof__
c_func
(paren
r_struct
id|property
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allnextpp
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pname
comma
l_string|&quot;linux,phandle&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|np-&gt;node
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;linux_phandle
op_eq
l_int|0
)paren
id|np-&gt;linux_phandle
op_assign
id|np-&gt;node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pname
comma
l_string|&quot;ibm,phandle&quot;
)paren
op_eq
l_int|0
)paren
id|np-&gt;linux_phandle
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
op_star
id|p
)paren
suffix:semicolon
id|pp-&gt;name
op_assign
id|pname
suffix:semicolon
id|pp-&gt;length
op_assign
id|sz
suffix:semicolon
id|pp-&gt;value
op_assign
(paren
r_void
op_star
)paren
op_star
id|p
suffix:semicolon
op_star
id|prev_pp
op_assign
id|pp
suffix:semicolon
id|prev_pp
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
)brace
op_star
id|p
op_assign
id|_ALIGN
c_func
(paren
(paren
op_star
id|p
)paren
op_plus
id|sz
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|allnextpp
)paren
(brace
op_star
id|prev_pp
op_assign
l_int|NULL
suffix:semicolon
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|np-&gt;type
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;device_type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;name
)paren
id|np-&gt;name
op_assign
l_string|&quot;&lt;NULL&gt;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;type
)paren
id|np-&gt;type
op_assign
l_string|&quot;&lt;NULL&gt;&quot;
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tag
op_eq
id|OF_DT_BEGIN_NODE
)paren
(brace
id|mem
op_assign
id|unflatten_dt_node
c_func
(paren
id|mem
comma
id|p
comma
id|np
comma
id|allnextpp
)paren
suffix:semicolon
id|tag
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_ne
id|OF_DT_END_NODE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Weird tag at start of node: %x&bslash;n&quot;
comma
id|tag
)paren
suffix:semicolon
r_return
id|mem
suffix:semicolon
)brace
op_star
id|p
op_add_assign
l_int|4
suffix:semicolon
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/**&n; * unflattens the device-tree passed by the firmware, creating the&n; * tree of struct device_node. It also fills the &quot;name&quot; and &quot;type&quot;&n; * pointers of the nodes so the normal device-tree walking functions&n; * can be used (this used to be done by finish_device_tree)&n; */
DECL|function|unflatten_device_tree
r_void
id|__init
id|unflatten_device_tree
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|start
comma
id|mem
comma
id|size
suffix:semicolon
r_struct
id|device_node
op_star
op_star
id|allnextp
op_assign
op_amp
id|allnodes
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|l
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; unflatten_device_tree()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* First pass, scan for size */
id|start
op_assign
(paren
(paren
r_int
r_int
)paren
id|initial_boot_params
)paren
op_plus
id|initial_boot_params-&gt;off_dt_struct
suffix:semicolon
id|size
op_assign
id|unflatten_dt_node
c_func
(paren
l_int|0
comma
op_amp
id|start
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  size is %lx, allocating...&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Allocate memory for the expanded device tree */
id|mem
op_assign
(paren
r_int
r_int
)paren
id|abs_to_virt
c_func
(paren
id|lmb_alloc
c_func
(paren
id|size
comma
id|__alignof__
c_func
(paren
r_struct
id|device_node
)paren
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  unflattening...&bslash;n&quot;
comma
id|mem
)paren
suffix:semicolon
multiline_comment|/* Second pass, do actual unflattening */
id|start
op_assign
(paren
(paren
r_int
r_int
)paren
id|initial_boot_params
)paren
op_plus
id|initial_boot_params-&gt;off_dt_struct
suffix:semicolon
id|unflatten_dt_node
c_func
(paren
id|mem
comma
op_amp
id|start
comma
l_int|NULL
comma
op_amp
id|allnextp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
id|start
)paren
op_ne
id|OF_DT_END
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Weird tag at end of tree: %x&bslash;n&quot;
comma
op_star
(paren
(paren
id|u32
op_star
)paren
id|start
)paren
)paren
suffix:semicolon
op_star
id|allnextp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get pointer to OF &quot;/chosen&quot; node for use everywhere */
id|of_chosen
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/chosen&quot;
)paren
suffix:semicolon
multiline_comment|/* Retreive command line */
r_if
c_cond
(paren
id|of_chosen
op_ne
l_int|NULL
)paren
(brace
id|p
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|of_chosen
comma
l_string|&quot;bootargs&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
op_logical_and
id|l
OG
l_int|0
)paren
id|strlcpy
c_func
(paren
id|cmd_line
comma
id|p
comma
id|min
c_func
(paren
id|l
comma
id|COMMAND_LINE_SIZE
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_CMDLINE
r_if
c_cond
(paren
id|l
op_eq
l_int|0
op_logical_or
(paren
id|l
op_eq
l_int|1
op_logical_and
(paren
op_star
id|p
)paren
op_eq
l_int|0
)paren
)paren
id|strlcpy
c_func
(paren
id|cmd_line
comma
id|CONFIG_CMDLINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_CMDLINE */
id|DBG
c_func
(paren
l_string|&quot;Command line is: %s&bslash;n&quot;
comma
id|cmd_line
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- unflatten_device_tree()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|early_init_dt_scan_cpus
r_static
r_int
id|__init
id|early_init_dt_scan_cpus
c_func
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|full_path
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|type
op_assign
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* We are scanning &quot;cpu&quot; nodes only */
r_if
c_cond
(paren
id|type
op_eq
l_int|NULL
op_logical_or
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;cpu&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* On LPAR, look for the first ibm,pft-size property for the  hash table size&n;&t; */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
op_logical_and
id|ppc64_pft_size
op_eq
l_int|0
)paren
(brace
id|u32
op_star
id|pft_size
suffix:semicolon
id|pft_size
op_assign
(paren
id|u32
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;ibm,pft-size&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pft_size
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* pft_size[0] is the NUMA CEC cookie */
id|ppc64_pft_size
op_assign
id|pft_size
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|initial_boot_params
op_logical_and
id|initial_boot_params-&gt;version
op_ge
l_int|2
)paren
(brace
multiline_comment|/* version 2 of the kexec param format adds the phys cpuid&n;&t;&t; * of booted proc.&n;&t;&t; */
id|boot_cpuid_phys
op_assign
id|initial_boot_params-&gt;boot_cpuid_phys
suffix:semicolon
id|boot_cpuid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Check if it&squot;s the boot-cpu, set it&squot;s hw index in paca now */
r_if
c_cond
(paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,boot-cpu&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
(brace
id|u32
op_star
id|prop
op_assign
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|set_hard_smp_processor_id
c_func
(paren
l_int|0
comma
id|prop
op_eq
l_int|NULL
ques
c_cond
l_int|0
suffix:colon
op_star
id|prop
)paren
suffix:semicolon
id|boot_cpuid_phys
op_assign
id|get_hard_smp_processor_id
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|early_init_dt_scan_chosen
r_static
r_int
id|__init
id|early_init_dt_scan_chosen
c_func
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|full_path
comma
r_void
op_star
id|data
)paren
(brace
id|u32
op_star
id|prop
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|full_path
comma
l_string|&quot;/chosen&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* get platform type */
id|prop
op_assign
(paren
id|u32
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,platform&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|systemcfg-&gt;platform
op_assign
op_star
id|prop
suffix:semicolon
multiline_comment|/* check if iommu is forced on or off */
r_if
c_cond
(paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,iommu-off&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
id|iommu_is_off
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,iommu-force-on&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
id|iommu_force_on
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_PSERIES
multiline_comment|/* To help early debugging via the front panel, we retreive a minimal&n;&t; * set of RTAS infos now if available&n;&t; */
(brace
id|u64
op_star
id|basep
comma
op_star
id|entryp
suffix:semicolon
id|basep
op_assign
(paren
id|u64
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,rtas-base&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|entryp
op_assign
(paren
id|u64
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,rtas-entry&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|prop
op_assign
(paren
id|u32
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;linux,rtas-size&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basep
op_logical_and
id|entryp
op_logical_and
id|prop
)paren
(brace
id|rtas.base
op_assign
op_star
id|basep
suffix:semicolon
id|rtas.entry
op_assign
op_star
id|entryp
suffix:semicolon
id|rtas.size
op_assign
op_star
id|prop
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PPC_PSERIES */
multiline_comment|/* break now */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|early_init_dt_scan_root
r_static
r_int
id|__init
id|early_init_dt_scan_root
c_func
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|full_path
comma
r_void
op_star
id|data
)paren
(brace
id|u32
op_star
id|prop
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|full_path
comma
l_string|&quot;/&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|prop
op_assign
(paren
id|u32
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|dt_root_size_cells
op_assign
(paren
id|prop
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|1
suffix:colon
op_star
id|prop
suffix:semicolon
id|prop
op_assign
(paren
id|u32
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|dt_root_addr_cells
op_assign
(paren
id|prop
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|2
suffix:colon
op_star
id|prop
suffix:semicolon
multiline_comment|/* break now */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|dt_mem_next_cell
r_static
r_int
r_int
id|__init
id|dt_mem_next_cell
c_func
(paren
r_int
id|s
comma
id|cell_t
op_star
op_star
id|cellp
)paren
(brace
id|cell_t
op_star
id|p
op_assign
op_star
id|cellp
suffix:semicolon
r_int
r_int
id|r
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ignore more than 2 cells */
r_while
c_loop
(paren
id|s
OG
l_int|2
)paren
(brace
id|p
op_increment
suffix:semicolon
id|s
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|s
)paren
(brace
id|r
op_lshift_assign
l_int|32
suffix:semicolon
id|r
op_or_assign
op_star
(paren
id|p
op_increment
)paren
suffix:semicolon
id|s
op_decrement
suffix:semicolon
)brace
op_star
id|cellp
op_assign
id|p
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|early_init_dt_scan_memory
r_static
r_int
id|__init
id|early_init_dt_scan_memory
c_func
(paren
r_int
r_int
id|node
comma
r_const
r_char
op_star
id|full_path
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|type
op_assign
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|cell_t
op_star
id|reg
comma
op_star
id|endp
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
multiline_comment|/* We are scanning &quot;memory&quot; nodes only */
r_if
c_cond
(paren
id|type
op_eq
l_int|NULL
op_logical_or
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;memory&quot;
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|reg
op_assign
(paren
id|cell_t
op_star
)paren
id|get_flat_dt_prop
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|endp
op_assign
id|reg
op_plus
(paren
id|l
op_div
r_sizeof
(paren
id|cell_t
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;memory scan node %s ...&bslash;n&quot;
comma
id|full_path
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|endp
op_minus
id|reg
)paren
op_ge
(paren
id|dt_root_addr_cells
op_plus
id|dt_root_size_cells
)paren
)paren
(brace
r_int
r_int
id|base
comma
id|size
suffix:semicolon
id|base
op_assign
id|dt_mem_next_cell
c_func
(paren
id|dt_root_addr_cells
comma
op_amp
id|reg
)paren
suffix:semicolon
id|size
op_assign
id|dt_mem_next_cell
c_func
(paren
id|dt_root_size_cells
comma
op_amp
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; - %lx ,  %lx&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iommu_is_off
)paren
(brace
r_if
c_cond
(paren
id|base
op_ge
l_int|0x80000000ul
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
OG
l_int|0x80000000ul
)paren
id|size
op_assign
l_int|0x80000000ul
op_minus
id|base
suffix:semicolon
)brace
id|lmb_add
c_func
(paren
id|base
comma
id|size
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|early_reserve_mem
r_static
r_void
id|__init
id|early_reserve_mem
c_func
(paren
r_void
)paren
(brace
id|u64
id|base
comma
id|size
suffix:semicolon
id|u64
op_star
id|reserve_map
op_assign
(paren
id|u64
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|initial_boot_params
)paren
op_plus
id|initial_boot_params-&gt;off_mem_rsvmap
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|base
op_assign
op_star
(paren
id|reserve_map
op_increment
)paren
suffix:semicolon
id|size
op_assign
op_star
(paren
id|reserve_map
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;reserving: %lx -&gt; %lx&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
id|lmb_reserve
c_func
(paren
id|base
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|DBG
c_func
(paren
l_string|&quot;memory reserved, lmbs :&bslash;n&quot;
)paren
suffix:semicolon
id|lmb_dump_all
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|early_init_devtree
r_void
id|__init
id|early_init_devtree
c_func
(paren
r_void
op_star
id|params
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; -&gt; early_init_devtree()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup flat device-tree pointer */
id|initial_boot_params
op_assign
id|params
suffix:semicolon
multiline_comment|/* By default, hash size is not set */
id|ppc64_pft_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Retreive various informations from the /chosen node of the&n;&t; * device-tree, including the platform type, initrd location and&n;&t; * size, TCE reserve, and more ...&n;&t; */
id|scan_flat_dt
c_func
(paren
id|early_init_dt_scan_chosen
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Scan memory nodes and rebuild LMBs */
id|lmb_init
c_func
(paren
)paren
suffix:semicolon
id|scan_flat_dt
c_func
(paren
id|early_init_dt_scan_root
comma
l_int|NULL
)paren
suffix:semicolon
id|scan_flat_dt
c_func
(paren
id|early_init_dt_scan_memory
comma
l_int|NULL
)paren
suffix:semicolon
id|lmb_analyze
c_func
(paren
)paren
suffix:semicolon
id|systemcfg-&gt;physicalMemorySize
op_assign
id|lmb_phys_mem_size
c_func
(paren
)paren
suffix:semicolon
id|lmb_reserve
c_func
(paren
l_int|0
comma
id|__pa
c_func
(paren
id|klimit
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Phys. mem: %lx&bslash;n&quot;
comma
id|systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
multiline_comment|/* Reserve LMB regions used by kernel, initrd, dt, etc... */
id|early_reserve_mem
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Scanning CPUs ...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Retreive hash table size from flattened tree */
id|scan_flat_dt
c_func
(paren
id|early_init_dt_scan_cpus
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If hash size wasn&squot;t obtained above, we calculate it now based on&n;&t; * the total RAM size&n;&t; */
r_if
c_cond
(paren
id|ppc64_pft_size
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|rnd_mem_size
comma
id|pteg_count
suffix:semicolon
multiline_comment|/* round mem_size up to next power of 2 */
id|rnd_mem_size
op_assign
l_int|1UL
op_lshift
id|__ilog2
c_func
(paren
id|systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rnd_mem_size
OL
id|systemcfg-&gt;physicalMemorySize
)paren
id|rnd_mem_size
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* # pages / 2 */
id|pteg_count
op_assign
id|max
c_func
(paren
id|rnd_mem_size
op_rshift
(paren
l_int|12
op_plus
l_int|1
)paren
comma
l_int|1UL
op_lshift
l_int|11
)paren
suffix:semicolon
id|ppc64_pft_size
op_assign
id|__ilog2
c_func
(paren
id|pteg_count
op_lshift
l_int|7
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;Hash pftSize: %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|ppc64_pft_size
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- early_init_devtree()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|printk
macro_line|#undef printk
r_int
DECL|function|prom_n_addr_cells
id|prom_n_addr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #address-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|prom_n_size_cells
id|prom_n_size_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #size-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Work out the sense (active-low level / active-high edge)&n; * of each interrupt from the device tree.&n; */
DECL|function|prom_get_irq_senses
r_void
id|__init
id|prom_get_irq_senses
c_func
(paren
r_int
r_char
op_star
id|senses
comma
r_int
id|off
comma
r_int
id|max
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* default to level-triggered */
id|memset
c_func
(paren
id|senses
comma
l_int|1
comma
id|max
op_minus
id|off
)paren
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|np-&gt;n_intrs
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|line
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|off
op_logical_and
id|i
OL
id|max
)paren
id|senses
(braket
id|i
op_minus
id|off
)braket
op_assign
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|sense
ques
c_cond
id|IRQ_SENSE_LEVEL
op_or
id|IRQ_POLARITY_NEGATIVE
suffix:colon
id|IRQ_SENSE_EDGE
op_or
id|IRQ_POLARITY_POSITIVE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * Construct and return a list of the device_nodes with a given name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_devices
id|find_devices
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/**&n; * Construct and return a list of the device_nodes with a given type.&n; */
r_struct
id|device_node
op_star
DECL|function|find_type_devices
id|find_type_devices
c_func
(paren
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns all nodes linked together&n; */
r_struct
id|device_node
op_star
DECL|function|find_all_nodes
id|find_all_nodes
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/** Checks if the given &quot;compat&quot; string matches one of the strings in&n; * the device&squot;s &quot;compatible&quot; property&n; */
r_int
DECL|function|device_is_compatible
id|device_is_compatible
c_func
(paren
r_struct
id|device_node
op_star
id|device
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
id|cplen
comma
id|l
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|device
comma
l_string|&quot;compatible&quot;
comma
op_amp
id|cplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cplen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|strncasecmp
c_func
(paren
id|cp
comma
id|compat
comma
id|strlen
c_func
(paren
id|compat
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|cp
)paren
op_plus
l_int|1
suffix:semicolon
id|cp
op_add_assign
id|l
suffix:semicolon
id|cplen
op_sub_assign
id|l
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Indicates whether the root node has a given value in its&n; * compatible property.&n; */
r_int
DECL|function|machine_is_compatible
id|machine_is_compatible
c_func
(paren
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|root
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|root
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
)paren
(brace
id|rc
op_assign
id|device_is_compatible
c_func
(paren
id|root
comma
id|compat
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|root
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * Construct and return a list of the device_nodes with a given type&n; * and compatible property.&n; */
r_struct
id|device_node
op_star
DECL|function|find_compatible_devices
id|find_compatible_devices
c_func
(paren
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compat
)paren
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/**&n; * Find the device_node with a given full_name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_path_device
id|find_path_device
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*******&n; *&n; * New implementation of the OF &quot;find&quot; APIs, return a refcounted&n; * object, call of_node_put() when done.  The device tree and list&n; * are protected by a rw_lock.&n; *&n; * Note that property management will need some locking as well,&n; * this isn&squot;t dealt with yet.&n; *&n; *******/
multiline_comment|/**&n; *&t;of_find_node_by_name - Find a node by its &quot;name&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The name string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_name
r_struct
id|device_node
op_star
id|of_find_node_by_name
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_name
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_name
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_node_by_type - Find a node by its &quot;device_type&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The type string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_type
r_struct
id|device_node
op_star
id|of_find_node_by_type
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_type
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_type
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_compatible_node - Find a node based on type and one of the&n; *                                tokens in its &quot;compatible&quot; property&n; *&t;@from:&t;&t;The node to start searching from or NULL, the node&n; *&t;&t;&t;you pass will not be searched, only the next one&n; *&t;&t;&t;will; typically, you pass what the previous call&n; *&t;&t;&t;returned. of_node_put() will be called on it&n; *&t;@type:&t;&t;The type string to match &quot;device_type&quot; or NULL to ignore&n; *&t;@compatible:&t;The string to match to one of the tokens in the device&n; *&t;&t;&t;&quot;compatible&quot; list.&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_compatible_node
r_struct
id|device_node
op_star
id|of_find_compatible_node
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compatible
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compatible
)paren
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_compatible_node
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_compatible_node
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_node_by_path - Find a node matching a full OF path&n; *&t;@path:&t;The full path to match&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_path
r_struct
id|device_node
op_star
id|of_find_node_by_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|allnodes
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
op_logical_and
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_path
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_path
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_node_by_phandle - Find a node given a phandle&n; *&t;@handle:&t;phandle of the node to find&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_phandle
r_struct
id|device_node
op_star
id|of_find_node_by_phandle
c_func
(paren
id|phandle
id|handle
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;linux_phandle
op_eq
id|handle
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_node_by_phandle
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_node_by_phandle
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_find_all_nodes - Get next node in global list&n; *&t;@prev:&t;Previous node or NULL to start iteration&n; *&t;&t;of_node_put() will be called on it&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_all_nodes
r_struct
id|device_node
op_star
id|of_find_all_nodes
c_func
(paren
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|prev
ques
c_cond
id|prev-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|of_node_get
c_func
(paren
id|np
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|of_node_put
c_func
(paren
id|prev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_find_all_nodes
id|EXPORT_SYMBOL
c_func
(paren
id|of_find_all_nodes
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_get_parent - Get a node&squot;s parent if any&n; *&t;@node:&t;Node to get parent&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_parent
r_struct
id|device_node
op_star
id|of_get_parent
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np
op_assign
id|of_node_get
c_func
(paren
id|node-&gt;parent
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|np
suffix:semicolon
)brace
DECL|variable|of_get_parent
id|EXPORT_SYMBOL
c_func
(paren
id|of_get_parent
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_get_next_child - Iterate a node childs&n; *&t;@node:&t;parent node&n; *&t;@prev:&t;previous child of the parent node, or NULL to get first&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_next_child
r_struct
id|device_node
op_star
id|of_get_next_child
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
comma
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_struct
id|device_node
op_star
id|next
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|next
op_assign
id|prev
ques
c_cond
id|prev-&gt;sibling
suffix:colon
id|node-&gt;child
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|next
op_ne
l_int|0
suffix:semicolon
id|next
op_assign
id|next-&gt;sibling
)paren
r_if
c_cond
(paren
id|of_node_get
c_func
(paren
id|next
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|of_node_put
c_func
(paren
id|prev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
DECL|variable|of_get_next_child
id|EXPORT_SYMBOL
c_func
(paren
id|of_get_next_child
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;of_node_get - Increment refcount of a node&n; *&t;@node:&t;Node to inc refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; *&t;Returns node.&n; */
DECL|function|of_node_get
r_struct
id|device_node
op_star
id|of_node_get
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
id|node
)paren
id|kref_get
c_func
(paren
op_amp
id|node-&gt;kref
)paren
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
DECL|variable|of_node_get
id|EXPORT_SYMBOL
c_func
(paren
id|of_node_get
)paren
suffix:semicolon
DECL|function|kref_to_device_node
r_static
r_inline
r_struct
id|device_node
op_star
id|kref_to_device_node
c_func
(paren
r_struct
id|kref
op_star
id|kref
)paren
(brace
r_return
id|container_of
c_func
(paren
id|kref
comma
r_struct
id|device_node
comma
id|kref
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_node_release - release a dynamically allocated node&n; *&t;@kref:  kref element of the node to be released&n; *&n; *&t;In of_node_put() this function is passed to kref_put()&n; *&t;as the destructor.&n; */
DECL|function|of_node_release
r_static
r_void
id|of_node_release
c_func
(paren
r_struct
id|kref
op_star
id|kref
)paren
(brace
r_struct
id|device_node
op_star
id|node
op_assign
id|kref_to_device_node
c_func
(paren
id|kref
)paren
suffix:semicolon
r_struct
id|property
op_star
id|prop
op_assign
id|node-&gt;properties
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OF_IS_DYNAMIC
c_func
(paren
id|node
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|prop
)paren
(brace
r_struct
id|property
op_star
id|next
op_assign
id|prop-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop-&gt;value
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prop
)paren
suffix:semicolon
id|prop
op_assign
id|next
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|node-&gt;intrs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node-&gt;addrs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node-&gt;full_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_node_put - Decrement refcount of a node&n; *&t;@node:&t;Node to dec refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; */
DECL|function|of_node_put
r_void
id|of_node_put
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
id|node
)paren
id|kref_put
c_func
(paren
op_amp
id|node-&gt;kref
comma
id|of_node_release
)paren
suffix:semicolon
)brace
DECL|variable|of_node_put
id|EXPORT_SYMBOL
c_func
(paren
id|of_node_put
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;derive_parent - basically like dirname(1)&n; *&t;@path:  the full_name of a node to be added to the tree&n; *&n; *&t;Returns the node which should be the parent of the node&n; *&t;described by path.  E.g., for path = &quot;/foo/bar&quot;, returns&n; *&t;the node with full_name = &quot;/foo&quot;.&n; */
DECL|function|derive_parent
r_static
r_struct
id|device_node
op_star
id|derive_parent
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|parent_path
op_assign
l_string|&quot;/&quot;
suffix:semicolon
r_int
id|parent_path_len
op_assign
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_minus
id|path
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* reject if path is &quot;/&quot; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|path
comma
l_string|&quot;/&quot;
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
op_ne
id|path
)paren
(brace
id|parent_path
op_assign
id|kmalloc
c_func
(paren
id|parent_path_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent_path
)paren
r_return
l_int|NULL
suffix:semicolon
id|strlcpy
c_func
(paren
id|parent_path
comma
id|path
comma
id|parent_path_len
)paren
suffix:semicolon
)brace
id|parent
op_assign
id|of_find_node_by_path
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|parent_path
comma
l_string|&quot;/&quot;
)paren
)paren
id|kfree
c_func
(paren
id|parent_path
)paren
suffix:semicolon
r_return
id|parent
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines for &quot;runtime&quot; addition and removal of device tree nodes.&n; */
macro_line|#ifdef CONFIG_PROC_DEVICETREE
multiline_comment|/*&n; * Add a node to /proc/device-tree.&n; */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|proc_mkdir
c_func
(paren
id|strrchr
c_func
(paren
id|np-&gt;full_name
comma
l_char|&squot;/&squot;
)paren
op_plus
l_int|1
comma
id|np-&gt;parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
id|proc_device_tree_add_node
c_func
(paren
id|np
comma
id|ent
)paren
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
r_struct
id|device_node
op_star
id|parent
op_assign
id|np-&gt;parent
suffix:semicolon
r_while
c_loop
(paren
id|pp
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|pp-&gt;name
comma
id|np-&gt;pde
)paren
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Assuming that symlinks have the same parent directory as&n;&t; * np-&gt;pde.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;name_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;name_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;addr_link
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;addr_link-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;pde
)paren
id|remove_proc_entry
c_func
(paren
id|np-&gt;pde-&gt;name
comma
id|parent-&gt;pde
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PROC_DEVICETREE */
DECL|function|add_node_proc_entries
r_static
r_void
id|add_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|remove_node_proc_entries
r_static
r_void
id|remove_node_proc_entries
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_DEVICETREE */
multiline_comment|/*&n; * Fix up n_intrs and intrs fields in a new device node&n; *&n; */
DECL|function|of_finish_dynamic_node_interrupts
r_static
r_int
id|of_finish_dynamic_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_int
id|intrcells
comma
id|intlen
comma
id|i
suffix:semicolon
r_int
op_star
id|irq
comma
op_star
id|ints
comma
id|virq
suffix:semicolon
r_struct
id|device_node
op_star
id|ic
suffix:semicolon
id|ints
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|intlen
)paren
suffix:semicolon
id|intrcells
op_assign
id|prom_n_intr_cells
c_func
(paren
id|node
)paren
suffix:semicolon
id|intlen
op_div_assign
id|intrcells
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|node-&gt;n_intrs
op_assign
id|intlen
suffix:semicolon
id|node-&gt;intrs
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
op_star
id|intlen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;intrs
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intlen
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|n
comma
id|j
suffix:semicolon
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
l_int|0
suffix:semicolon
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|map_interrupt
c_func
(paren
op_amp
id|irq
comma
op_amp
id|ic
comma
id|node
comma
id|ints
comma
id|intrcells
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|virq
op_assign
id|virt_irq_create_mapping
c_func
(paren
id|irq
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|virq
op_eq
id|NO_IRQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Could not allocate interrupt &quot;
l_string|&quot;number for %s&bslash;n&quot;
comma
id|node-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
id|irq_offset_up
c_func
(paren
id|virq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|1
)paren
id|node-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
id|irq
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;hmmm, got %d intr cells for %s:&quot;
comma
id|n
comma
id|node-&gt;full_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|irq
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ints
op_add_assign
id|intrcells
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Fix up the uninitialized fields in a new device node:&n; * name, type, n_addrs, addrs, n_intrs, intrs, and pci-specific fields&n; *&n; * A lot of boot-time code is duplicated here, because functions such&n; * as finish_node_interrupts, interpret_pci_props, etc. cannot use the&n; * slab allocator.&n; *&n; * This should probably be split up into smaller chunks.&n; */
DECL|function|of_finish_dynamic_node
r_static
r_int
id|of_finish_dynamic_node
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_struct
id|device_node
op_star
id|parent
op_assign
id|of_get_parent
c_func
(paren
id|node
)paren
suffix:semicolon
id|u32
op_star
id|regs
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|phandle
op_star
id|ibm_phandle
suffix:semicolon
id|node-&gt;name
op_assign
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|node-&gt;type
op_assign
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t support that function on PowerMac, at least&n;&t; * not yet&n;&t; */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* fix up new node&squot;s linux_phandle field */
r_if
c_cond
(paren
(paren
id|ibm_phandle
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;ibm,phandle&quot;
comma
l_int|NULL
)paren
)paren
)paren
id|node-&gt;linux_phandle
op_assign
op_star
id|ibm_phandle
suffix:semicolon
multiline_comment|/* do the work of interpret_pci_props */
r_if
c_cond
(paren
id|parent-&gt;type
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|parent-&gt;type
comma
l_string|&quot;pci&quot;
)paren
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|address_range
)paren
op_star
(paren
id|l
op_div
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|node-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|node-&gt;n_addrs
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* now do the work of finish_node_interrupts */
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;interrupts&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|err
op_assign
id|of_finish_dynamic_node_interrupts
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* now do the rough equivalent of update_dn_pci_info, this&n;&t; * probably is not correct for phb&squot;s, but should work for&n;&t; * IOAs and slots.&n;&t; */
id|node-&gt;phb
op_assign
id|parent-&gt;phb
suffix:semicolon
id|regs
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs
)paren
(brace
id|node-&gt;busno
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|node-&gt;devfn
op_assign
(paren
id|regs
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
id|out
suffix:colon
id|of_node_put
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a path and a property list, construct an OF device node, add&n; * it to the device tree and global list, and place it in&n; * /proc/device-tree.  This function may sleep.&n; */
DECL|function|of_add_node
r_int
id|of_add_node
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|property
op_star
id|proplist
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|np
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;full_name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;full_name
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
suffix:semicolon
id|np-&gt;properties
op_assign
id|proplist
suffix:semicolon
id|OF_MARK_DYNAMIC
c_func
(paren
id|np
)paren
suffix:semicolon
id|kref_init
c_func
(paren
op_amp
id|np-&gt;kref
)paren
suffix:semicolon
id|np-&gt;parent
op_assign
id|derive_parent
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;parent
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* could also be ENOMEM, though */
)brace
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|err
op_assign
id|of_finish_dynamic_node
c_func
(paren
id|np
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|np-&gt;sibling
op_assign
id|np-&gt;parent-&gt;child
suffix:semicolon
id|np-&gt;allnext
op_assign
id|allnodes
suffix:semicolon
id|np-&gt;parent-&gt;child
op_assign
id|np
suffix:semicolon
id|allnodes
op_assign
id|np
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|add_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare an OF node for removal from system&n; */
DECL|function|of_cleanup_node
r_static
r_void
id|of_cleanup_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;iommu_table
op_logical_and
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|NULL
)paren
)paren
id|iommu_free_table
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;Unplug&quot; a node from the device tree.  The caller must hold&n; * a reference to the node.  The memory associated with the node&n; * is not freed until its refcount goes to zero.&n; */
DECL|function|of_remove_node
r_int
id|of_remove_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|parent
comma
op_star
id|child
suffix:semicolon
id|parent
op_assign
id|of_get_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|child
op_assign
id|of_get_next_child
c_func
(paren
id|np
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|of_node_put
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|of_cleanup_node
c_func
(paren
id|np
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|remove_node_proc_entries
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allnodes
op_eq
id|np
)paren
id|allnodes
op_assign
id|np-&gt;allnext
suffix:semicolon
r_else
(brace
r_struct
id|device_node
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
id|allnodes
suffix:semicolon
id|prev-&gt;allnext
op_ne
id|np
suffix:semicolon
id|prev
op_assign
id|prev-&gt;allnext
)paren
suffix:semicolon
id|prev-&gt;allnext
op_assign
id|np-&gt;allnext
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parent-&gt;child
op_eq
id|np
)paren
id|parent-&gt;child
op_assign
id|np-&gt;sibling
suffix:semicolon
r_else
(brace
r_struct
id|device_node
op_star
id|prevsib
suffix:semicolon
r_for
c_loop
(paren
id|prevsib
op_assign
id|np-&gt;parent-&gt;child
suffix:semicolon
id|prevsib-&gt;sibling
op_ne
id|np
suffix:semicolon
id|prevsib
op_assign
id|prevsib-&gt;sibling
)paren
suffix:semicolon
id|prevsib-&gt;sibling
op_assign
id|np-&gt;sibling
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|devtree_lock
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|parent
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* Must decrement the refcount */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a property with a given name for a given node&n; * and return the value.&n; */
r_int
r_char
op_star
DECL|function|get_property
id|get_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pp-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lenp
op_ne
l_int|0
)paren
op_star
id|lenp
op_assign
id|pp-&gt;length
suffix:semicolon
r_return
id|pp-&gt;value
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a property to a node&n; */
r_void
DECL|function|prom_add_property
id|prom_add_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_struct
id|property
op_star
id|prop
)paren
(brace
r_struct
id|property
op_star
op_star
id|next
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prop-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|next
)paren
id|next
op_assign
op_amp
(paren
op_star
id|next
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
op_star
id|next
op_assign
id|prop
suffix:semicolon
)brace
macro_line|#if 0
r_void
id|print_properties
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|pp-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|strlen
c_func
(paren
id|pp-&gt;name
)paren
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pp-&gt;length
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|cp
)paren
r_if
c_cond
(paren
(paren
id|i
OG
l_int|1
op_logical_and
(paren
op_star
id|cp
template_param
l_int|0x7e
)paren
)paren
op_logical_or
(paren
id|i
op_eq
l_int|1
op_logical_and
op_star
id|cp
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|pp-&gt;length
OG
l_int|1
)paren
(brace
multiline_comment|/* looks like a string */
id|printk
c_func
(paren
l_string|&quot; %s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|pp-&gt;value
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dump it in hex */
id|n
op_assign
id|pp-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|64
)paren
id|n
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
op_mod
l_int|4
op_eq
l_int|0
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pp-&gt;value
suffix:semicolon
id|n
op_div_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %08x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
op_star
id|bp
op_assign
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|bp
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OG
l_int|64
)paren
id|printk
c_func
(paren
l_string|&quot;                 ... (length = %d)&bslash;n&quot;
comma
id|pp-&gt;length
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
eof
