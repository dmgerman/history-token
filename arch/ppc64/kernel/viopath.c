multiline_comment|/* -*- linux-c -*-&n; *  arch/ppc64/kernel/viopath.c&n; *&n; *  iSeries Virtual I/O Message Path code&n; *&n; *  Authors: Dave Boutcher &lt;boutcher@us.ibm.com&gt;&n; *           Ryan Arnold &lt;ryanarn@us.ibm.com&gt;&n; *           Colin Devilbiss &lt;devilbis@us.ibm.com&gt;&n; *&n; * (C) Copyright 2000-2003 IBM Corporation&n; *&n; * This code is used by the iSeries virtual disk, cd,&n; * tape, and console to communicate with OS/400 in another&n; * partition.&n; *&n; * This program is free software;  you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as&n; * published by the Free Software Foundation; either version 2 of the&n; * License, or (at your option) anyu later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpEvent.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpConfig.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallCfg.h&gt;
macro_line|#include &lt;asm/iSeries/mf.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_proc.h&gt;
macro_line|#include &lt;asm/iSeries/vio.h&gt;
multiline_comment|/* Status of the path to each other partition in the system.&n; * This is overkill, since we will only ever establish connections&n; * to our hosting partition and the primary partition on the system.&n; * But this allows for other support in the future.&n; */
DECL|struct|viopathStatus
r_static
r_struct
id|viopathStatus
(brace
DECL|member|isOpen
r_int
id|isOpen
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Did we open the path?            */
DECL|member|isActive
r_int
id|isActive
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Do we have a mon msg outstanding */
DECL|member|users
r_int
id|users
(braket
id|VIO_MAX_SUBTYPES
)braket
suffix:semicolon
DECL|member|mSourceInst
id|HvLpInstanceId
id|mSourceInst
suffix:semicolon
DECL|member|mTargetInst
id|HvLpInstanceId
id|mTargetInst
suffix:semicolon
DECL|member|numberAllocated
r_int
id|numberAllocated
suffix:semicolon
DECL|variable|viopathStatus
)brace
id|viopathStatus
(braket
id|HVMAXARCHITECTEDLPS
)braket
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|statuslock
)paren
suffix:semicolon
multiline_comment|/*&n; * For each kind of event we allocate a buffer that is&n; * guaranteed not to cross a page boundary&n; */
DECL|variable|__page_aligned
r_static
r_int
r_char
id|event_buffer
(braket
id|VIO_MAX_SUBTYPES
op_star
l_int|256
)braket
id|__page_aligned
suffix:semicolon
DECL|variable|event_buffer_available
r_static
id|atomic_t
id|event_buffer_available
(braket
id|VIO_MAX_SUBTYPES
)braket
suffix:semicolon
DECL|variable|event_buffer_initialised
r_static
r_int
id|event_buffer_initialised
suffix:semicolon
r_static
r_void
id|handleMonitorEvent
c_func
(paren
r_struct
id|HvLpEvent
op_star
id|event
)paren
suffix:semicolon
multiline_comment|/*&n; * We use this structure to handle asynchronous responses.  The caller&n; * blocks on the semaphore and the handler posts the semaphore.  However,&n; * if in_atomic() is true in the caller, then wait_atomic is used ...&n; */
DECL|struct|doneAllocParms_t
r_struct
id|doneAllocParms_t
(brace
DECL|member|sem
r_struct
id|semaphore
op_star
id|sem
suffix:semicolon
DECL|member|number
r_int
id|number
suffix:semicolon
DECL|member|wait_atomic
id|atomic_t
op_star
id|wait_atomic
suffix:semicolon
DECL|member|used_wait_atomic
r_int
id|used_wait_atomic
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Put a sequence number in each mon msg.  The value is not&n; * important.  Start at something other than 0 just for&n; * readability.  wrapping this is ok.&n; */
DECL|variable|viomonseq
r_static
id|u8
id|viomonseq
op_assign
l_int|22
suffix:semicolon
multiline_comment|/* Our hosting logical partition.  We get this at startup&n; * time, and different modules access this variable directly.&n; */
DECL|variable|viopath_hostLp
id|HvLpIndex
id|viopath_hostLp
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* HvLpIndexInvalid */
DECL|variable|viopath_hostLp
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_hostLp
)paren
suffix:semicolon
DECL|variable|viopath_ourLp
id|HvLpIndex
id|viopath_ourLp
op_assign
l_int|0xff
suffix:semicolon
DECL|variable|viopath_ourLp
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_ourLp
)paren
suffix:semicolon
multiline_comment|/* For each kind of incoming event we set a pointer to a&n; * routine to call.&n; */
DECL|variable|vio_handler
r_static
id|vio_event_handler_t
op_star
id|vio_handler
(braket
id|VIO_MAX_SUBTYPES
)braket
suffix:semicolon
DECL|macro|VIOPATH_KERN_WARN
mdefine_line|#define VIOPATH_KERN_WARN&t;KERN_WARNING &quot;viopath: &quot;
DECL|macro|VIOPATH_KERN_INFO
mdefine_line|#define VIOPATH_KERN_INFO&t;KERN_INFO &quot;viopath: &quot;
DECL|function|proc_viopath_show
r_static
r_int
id|proc_viopath_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
id|u16
id|vlanMap
suffix:semicolon
id|dma_addr_t
id|handle
suffix:semicolon
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|Semaphore
)paren
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|handle
op_assign
id|dma_map_single
c_func
(paren
id|iSeries_vio_dev
comma
id|buf
comma
id|PAGE_SIZE
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_config
op_or
id|vioconfigget
comma
id|HvLpEvent_AckInd_DoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
op_amp
id|Semaphore
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|handle
)paren
op_lshift
l_int|32
comma
id|PAGE_SIZE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_ne
id|HvLpEvent_Rc_Good
)paren
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;hv error on op %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|Semaphore
)paren
suffix:semicolon
id|vlanMap
op_assign
id|HvLpConfig_getVirtualLanIndexMap
c_func
(paren
)paren
suffix:semicolon
id|buf
(braket
id|PAGE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;AVAILABLE_VETH=%x&bslash;n&quot;
comma
id|vlanMap
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;SRLNBR=%c%c%c%c%c%c%c&bslash;n&quot;
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.mfgID
(braket
l_int|2
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.mfgID
(braket
l_int|3
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.systemSerial
(braket
l_int|1
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.systemSerial
(braket
l_int|2
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.systemSerial
(braket
l_int|3
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.systemSerial
(braket
l_int|4
)braket
)paren
comma
id|e2a
c_func
(paren
id|xItExtVpdPanel.systemSerial
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|dma_unmap_single
c_func
(paren
id|iSeries_vio_dev
comma
id|handle
comma
id|PAGE_SIZE
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|proc_viopath_open
r_static
r_int
id|proc_viopath_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|proc_viopath_show
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|proc_viopath_operations
r_static
r_struct
id|file_operations
id|proc_viopath_operations
op_assign
(brace
dot
id|open
op_assign
id|proc_viopath_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
DECL|function|vio_proc_init
r_static
r_int
id|__init
id|vio_proc_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|e
suffix:semicolon
id|e
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;iSeries/config&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
id|e-&gt;proc_fops
op_assign
op_amp
id|proc_viopath_operations
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vio_proc_init
id|__initcall
c_func
(paren
id|vio_proc_init
)paren
suffix:semicolon
multiline_comment|/* See if a given LP is active.  Allow for invalid lps to be passed in&n; * and just return invalid&n; */
DECL|function|viopath_isactive
r_int
id|viopath_isactive
c_func
(paren
id|HvLpIndex
id|lp
)paren
(brace
r_if
c_cond
(paren
id|lp
op_eq
id|HvLpIndexInvalid
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp
OL
id|HVMAXARCHITECTEDLPS
)paren
r_return
id|viopathStatus
(braket
id|lp
)braket
dot
id|isActive
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|viopath_isactive
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_isactive
)paren
suffix:semicolon
multiline_comment|/*&n; * We cache the source and target instance ids for each&n; * partition.  &n; */
DECL|function|viopath_sourceinst
id|HvLpInstanceId
id|viopath_sourceinst
c_func
(paren
id|HvLpIndex
id|lp
)paren
(brace
r_return
id|viopathStatus
(braket
id|lp
)braket
dot
id|mSourceInst
suffix:semicolon
)brace
DECL|variable|viopath_sourceinst
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_sourceinst
)paren
suffix:semicolon
DECL|function|viopath_targetinst
id|HvLpInstanceId
id|viopath_targetinst
c_func
(paren
id|HvLpIndex
id|lp
)paren
(brace
r_return
id|viopathStatus
(braket
id|lp
)braket
dot
id|mTargetInst
suffix:semicolon
)brace
DECL|variable|viopath_targetinst
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_targetinst
)paren
suffix:semicolon
multiline_comment|/*&n; * Send a monitor message.  This is a message with the acknowledge&n; * bit on that the other side will NOT explicitly acknowledge.  When&n; * the other side goes down, the hypervisor will acknowledge any&n; * outstanding messages....so we will know when the other side dies.&n; */
DECL|function|sendMonMsg
r_static
r_void
id|sendMonMsg
c_func
(paren
id|HvLpIndex
id|remoteLp
)paren
(brace
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
op_assign
id|HvCallEvent_getSourceLpInstanceId
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
op_assign
id|HvCallEvent_getTargetLpInstanceId
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Deliberately ignore the return code here.  if we call this&n;&t; * more than once, we don&squot;t care.&n;&t; */
id|vio_setHandler
c_func
(paren
id|viomajorsubtype_monitor
comma
id|handleMonitorEvent
)paren
suffix:semicolon
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_monitor
comma
id|HvLpEvent_AckInd_DoAck
comma
id|HvLpEvent_AckType_DeferredAck
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
comma
id|viomonseq
op_increment
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_eq
id|HvLpEvent_Rc_Good
)paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;could not connect to partition %d&bslash;n&quot;
comma
id|remoteLp
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|handleMonitorEvent
r_static
r_void
id|handleMonitorEvent
c_func
(paren
r_struct
id|HvLpEvent
op_star
id|event
)paren
(brace
id|HvLpIndex
id|remoteLp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * This handler is _also_ called as part of the loop&n;&t; * at the end of this routine, so it must be able to&n;&t; * ignore NULL events...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * First see if this is just a normal monitor message from the&n;&t; * other partition&n;&t; */
r_if
c_cond
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
(brace
id|remoteLp
op_assign
id|event-&gt;xSourceLp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
)paren
id|sendMonMsg
c_func
(paren
id|remoteLp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This path is for an acknowledgement; the other partition&n;&t; * died&n;&t; */
id|remoteLp
op_assign
id|event-&gt;xTargetLp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event-&gt;xSourceInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
)paren
op_logical_or
(paren
id|event-&gt;xTargetInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;ignoring ack....mismatched instances&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;partition %d ended&bslash;n&quot;
comma
id|remoteLp
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * For each active handler, pass them a NULL&n;&t; * message to indicate that the other partition&n;&t; * died&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIO_MAX_SUBTYPES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vio_handler
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(paren
op_star
id|vio_handler
(braket
id|i
)braket
)paren
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|function|vio_setHandler
r_int
id|vio_setHandler
c_func
(paren
r_int
id|subtype
comma
id|vio_event_handler_t
op_star
id|beh
)paren
(brace
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vio_handler
(braket
id|subtype
)braket
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|vio_handler
(braket
id|subtype
)braket
op_assign
id|beh
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vio_setHandler
id|EXPORT_SYMBOL
c_func
(paren
id|vio_setHandler
)paren
suffix:semicolon
DECL|function|vio_clearHandler
r_int
id|vio_clearHandler
c_func
(paren
r_int
id|subtype
)paren
(brace
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vio_handler
(braket
id|subtype
)braket
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|vio_handler
(braket
id|subtype
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vio_clearHandler
id|EXPORT_SYMBOL
c_func
(paren
id|vio_clearHandler
)paren
suffix:semicolon
DECL|function|handleConfig
r_static
r_void
id|handleConfig
c_func
(paren
r_struct
id|HvLpEvent
op_star
id|event
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;unexpected config request from partition %d&quot;
comma
id|event-&gt;xSourceLp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
op_logical_and
(paren
id|event-&gt;xFlags.xAckInd
op_eq
id|HvLpEvent_AckInd_DoAck
)paren
)paren
(brace
id|event-&gt;xRc
op_assign
id|HvLpEvent_Rc_InvalidSubtype
suffix:semicolon
id|HvCallEvent_ackLpEvent
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|up
c_func
(paren
(paren
r_struct
id|semaphore
op_star
)paren
id|event-&gt;xCorrelationToken
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialization of the hosting partition&n; */
DECL|function|vio_set_hostlp
r_void
id|vio_set_hostlp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * If this has already been set then we DON&squot;T want to either change&n;&t; * it or re-register the proc file system&n;&t; */
r_if
c_cond
(paren
id|viopath_hostLp
op_ne
id|HvLpIndexInvalid
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out our hosting partition.  This isn&squot;t allowed to change&n;&t; * while we&squot;re active&n;&t; */
id|viopath_ourLp
op_assign
id|HvLpConfig_getLpIndex
c_func
(paren
)paren
suffix:semicolon
id|viopath_hostLp
op_assign
id|HvCallCfg_getHostingLpIndex
c_func
(paren
id|viopath_ourLp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|viopath_hostLp
op_ne
id|HvLpIndexInvalid
)paren
id|vio_setHandler
c_func
(paren
id|viomajorsubtype_config
comma
id|handleConfig
)paren
suffix:semicolon
)brace
DECL|variable|vio_set_hostlp
id|EXPORT_SYMBOL
c_func
(paren
id|vio_set_hostlp
)paren
suffix:semicolon
DECL|function|vio_handleEvent
r_static
r_void
id|vio_handleEvent
c_func
(paren
r_struct
id|HvLpEvent
op_star
id|event
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|HvLpIndex
id|remoteLp
suffix:semicolon
r_int
id|subtype
op_assign
(paren
id|event-&gt;xSubtype
op_amp
id|VIOMAJOR_SUBTYPE_MASK
)paren
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
(brace
id|remoteLp
op_assign
id|event-&gt;xSourceLp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The isActive is checked because if the hosting partition&n;&t;&t; * went down and came back up it would not be active but it&n;&t;&t; * would have different source and target instances, in which&n;&t;&t; * case we&squot;d want to reset them.  This case really protects&n;&t;&t; * against an unauthorized active partition sending interrupts&n;&t;&t; * or acks to this linux partition.&n;&t;&t; */
r_if
c_cond
(paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_logical_and
(paren
id|event-&gt;xSourceInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;message from invalid partition. &quot;
l_string|&quot;int msg rcvd, source inst (%d) doesnt match (%d)&bslash;n&quot;
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
comma
id|event-&gt;xSourceInstanceId
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_logical_and
(paren
id|event-&gt;xTargetInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;message from invalid partition. &quot;
l_string|&quot;int msg rcvd, target inst (%d) doesnt match (%d)&bslash;n&quot;
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
comma
id|event-&gt;xTargetInstanceId
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|remoteLp
op_assign
id|event-&gt;xTargetLp
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xSourceInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;message from invalid partition. &quot;
l_string|&quot;ack msg rcvd, source inst (%d) doesnt match (%d)&bslash;n&quot;
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
comma
id|event-&gt;xSourceInstanceId
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|event-&gt;xTargetInstanceId
op_ne
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;message from invalid partition. &quot;
l_string|&quot;viopath: ack msg rcvd, target inst (%d) doesnt match (%d)&bslash;n&quot;
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
comma
id|event-&gt;xTargetInstanceId
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vio_handler
(braket
id|subtype
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;unexpected virtual io event subtype %d from partition %d&bslash;n&quot;
comma
id|event-&gt;xSubtype
comma
id|remoteLp
)paren
suffix:semicolon
multiline_comment|/* No handler.  Ack if necessary */
r_if
c_cond
(paren
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
op_logical_and
(paren
id|event-&gt;xFlags.xAckInd
op_eq
id|HvLpEvent_AckInd_DoAck
)paren
)paren
(brace
id|event-&gt;xRc
op_assign
id|HvLpEvent_Rc_InvalidSubtype
suffix:semicolon
id|HvCallEvent_ackLpEvent
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* This innocuous little line is where all the real work happens */
(paren
op_star
id|vio_handler
(braket
id|subtype
)braket
)paren
(paren
id|event
)paren
suffix:semicolon
)brace
DECL|function|viopath_donealloc
r_static
r_void
id|viopath_donealloc
c_func
(paren
r_void
op_star
id|parm
comma
r_int
id|number
)paren
(brace
r_struct
id|doneAllocParms_t
op_star
id|parmsp
op_assign
(paren
r_struct
id|doneAllocParms_t
op_star
)paren
id|parm
suffix:semicolon
id|parmsp-&gt;number
op_assign
id|number
suffix:semicolon
r_if
c_cond
(paren
id|parmsp-&gt;used_wait_atomic
)paren
id|atomic_set
c_func
(paren
id|parmsp-&gt;wait_atomic
comma
l_int|0
)paren
suffix:semicolon
r_else
id|up
c_func
(paren
id|parmsp-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|allocateEvents
r_static
r_int
id|allocateEvents
c_func
(paren
id|HvLpIndex
id|remoteLp
comma
r_int
id|numEvents
)paren
(brace
r_struct
id|doneAllocParms_t
id|parms
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|Semaphore
)paren
suffix:semicolon
id|atomic_t
id|wait_atomic
suffix:semicolon
r_if
c_cond
(paren
id|in_atomic
c_func
(paren
)paren
)paren
(brace
id|parms.used_wait_atomic
op_assign
l_int|1
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|wait_atomic
comma
l_int|1
)paren
suffix:semicolon
id|parms.wait_atomic
op_assign
op_amp
id|wait_atomic
suffix:semicolon
)brace
r_else
(brace
id|parms.used_wait_atomic
op_assign
l_int|0
suffix:semicolon
id|parms.sem
op_assign
op_amp
id|Semaphore
suffix:semicolon
)brace
id|mf_allocate_lp_events
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
comma
l_int|250
comma
multiline_comment|/* It would be nice to put a real number here! */
id|numEvents
comma
op_amp
id|viopath_donealloc
comma
op_amp
id|parms
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_atomic
c_func
(paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|wait_atomic
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|down
c_func
(paren
op_amp
id|Semaphore
)paren
suffix:semicolon
r_return
id|parms.number
suffix:semicolon
)brace
DECL|function|viopath_open
r_int
id|viopath_open
c_func
(paren
id|HvLpIndex
id|remoteLp
comma
r_int
id|subtype
comma
r_int
id|numReq
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tempNumAllocated
suffix:semicolon
r_if
c_cond
(paren
(paren
id|remoteLp
op_ge
id|HvMaxArchitectedLps
)paren
op_logical_or
(paren
id|remoteLp
op_eq
id|HvLpIndexInvalid
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event_buffer_initialised
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIO_MAX_SUBTYPES
suffix:semicolon
id|i
op_increment
)paren
id|atomic_set
c_func
(paren
op_amp
id|event_buffer_available
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|event_buffer_initialised
op_assign
l_int|1
suffix:semicolon
)brace
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|users
(braket
id|subtype
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isOpen
)paren
(brace
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isOpen
op_assign
l_int|1
suffix:semicolon
id|HvCallEvent_openLpEventPath
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t hold the spinlock during an operation that&n;&t;&t; * can sleep.&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
id|tempNumAllocated
op_assign
id|allocateEvents
c_func
(paren
id|remoteLp
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|numberAllocated
op_add_assign
id|tempNumAllocated
suffix:semicolon
r_if
c_cond
(paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|numberAllocated
op_eq
l_int|0
)paren
(brace
id|HvCallEvent_closeLpEventPath
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
op_assign
id|HvCallEvent_getSourceLpInstanceId
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
op_assign
id|HvCallEvent_getTargetLpInstanceId
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
id|HvLpEvent_registerHandler
c_func
(paren
id|HvLpEvent_Type_VirtualIo
comma
op_amp
id|vio_handleEvent
)paren
suffix:semicolon
id|sendMonMsg
c_func
(paren
id|remoteLp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|VIOPATH_KERN_INFO
l_string|&quot;opening connection to partition %d, &quot;
l_string|&quot;setting sinst %d, tinst %d&bslash;n&quot;
comma
id|remoteLp
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mSourceInst
comma
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|mTargetInst
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
id|tempNumAllocated
op_assign
id|allocateEvents
c_func
(paren
id|remoteLp
comma
id|numReq
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|numberAllocated
op_add_assign
id|tempNumAllocated
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|viopath_open
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_open
)paren
suffix:semicolon
DECL|function|viopath_close
r_int
id|viopath_close
c_func
(paren
id|HvLpIndex
id|remoteLp
comma
r_int
id|subtype
comma
r_int
id|numReq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|numOpen
suffix:semicolon
r_struct
id|doneAllocParms_t
id|doneAllocParms
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|Semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|remoteLp
op_ge
id|HvMaxArchitectedLps
)paren
op_logical_or
(paren
id|remoteLp
op_eq
id|HvLpIndexInvalid
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the viopath_close somehow gets called before a&n;&t; * viopath_open it could decrement to -1 which is a non&n;&t; * recoverable state so we&squot;ll prevent this from&n;&t; * happening.&n;&t; */
r_if
c_cond
(paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|users
(braket
id|subtype
)braket
OG
l_int|0
)paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|users
(braket
id|subtype
)braket
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
id|doneAllocParms.used_wait_atomic
op_assign
l_int|0
suffix:semicolon
id|doneAllocParms.sem
op_assign
op_amp
id|Semaphore
suffix:semicolon
id|mf_deallocate_lp_events
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|numReq
comma
op_amp
id|viopath_donealloc
comma
op_amp
id|doneAllocParms
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|Semaphore
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|numOpen
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIO_MAX_SUBTYPES
suffix:semicolon
id|i
op_increment
)paren
id|numOpen
op_add_assign
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|users
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isOpen
)paren
op_logical_and
(paren
id|numOpen
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_INFO
l_string|&quot;closing connection to partition %d&quot;
comma
id|remoteLp
)paren
suffix:semicolon
id|HvCallEvent_closeLpEventPath
c_func
(paren
id|remoteLp
comma
id|HvLpEvent_Type_VirtualIo
)paren
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isOpen
op_assign
l_int|0
suffix:semicolon
id|viopathStatus
(braket
id|remoteLp
)braket
dot
id|isActive
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIO_MAX_SUBTYPES
suffix:semicolon
id|i
op_increment
)paren
id|atomic_set
c_func
(paren
op_amp
id|event_buffer_available
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
id|event_buffer_initialised
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|statuslock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|viopath_close
id|EXPORT_SYMBOL
c_func
(paren
id|viopath_close
)paren
suffix:semicolon
DECL|function|vio_get_event_buffer
r_void
op_star
id|vio_get_event_buffer
c_func
(paren
r_int
id|subtype
)paren
(brace
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_if_positive
c_func
(paren
op_amp
id|event_buffer_available
(braket
id|subtype
)braket
)paren
op_eq
l_int|0
)paren
r_return
op_amp
id|event_buffer
(braket
id|subtype
op_star
l_int|256
)braket
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|vio_get_event_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|vio_get_event_buffer
)paren
suffix:semicolon
DECL|function|vio_free_event_buffer
r_void
id|vio_free_event_buffer
c_func
(paren
r_int
id|subtype
comma
r_void
op_star
id|buffer
)paren
(brace
id|subtype
op_assign
id|subtype
op_rshift
id|VIOMAJOR_SUBTYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subtype
OL
l_int|0
)paren
op_logical_or
(paren
id|subtype
op_ge
id|VIO_MAX_SUBTYPES
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;unexpected subtype %d freeing event buffer&bslash;n&quot;
comma
id|subtype
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|event_buffer_available
(braket
id|subtype
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;freeing unallocated event buffer, subtype %d&bslash;n&quot;
comma
id|subtype
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
op_ne
op_amp
id|event_buffer
(braket
id|subtype
op_star
l_int|256
)braket
)paren
(brace
id|printk
c_func
(paren
id|VIOPATH_KERN_WARN
l_string|&quot;freeing invalid event buffer, subtype %d&bslash;n&quot;
comma
id|subtype
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|event_buffer_available
(braket
id|subtype
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|vio_free_event_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|vio_free_event_buffer
)paren
suffix:semicolon
DECL|variable|vio_no_error
r_static
r_const
r_struct
id|vio_error_entry
id|vio_no_error
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_string|&quot;Non-VIO Error&quot;
)brace
suffix:semicolon
DECL|variable|vio_unknown_error
r_static
r_const
r_struct
id|vio_error_entry
id|vio_unknown_error
op_assign
(brace
l_int|0
comma
id|EIO
comma
l_string|&quot;Unknown Error&quot;
)brace
suffix:semicolon
DECL|variable|vio_default_errors
r_static
r_const
r_struct
id|vio_error_entry
id|vio_default_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x0001
comma
id|EIO
comma
l_string|&quot;No Connection&quot;
)brace
comma
(brace
l_int|0x0002
comma
id|EIO
comma
l_string|&quot;No Receiver&quot;
)brace
comma
(brace
l_int|0x0003
comma
id|EIO
comma
l_string|&quot;No Buffer Available&quot;
)brace
comma
(brace
l_int|0x0004
comma
id|EBADRQC
comma
l_string|&quot;Invalid Message Type&quot;
)brace
comma
(brace
l_int|0x0000
comma
l_int|0
comma
l_int|NULL
)brace
comma
)brace
suffix:semicolon
DECL|function|vio_lookup_rc
r_const
r_struct
id|vio_error_entry
op_star
id|vio_lookup_rc
c_func
(paren
r_const
r_struct
id|vio_error_entry
op_star
id|local_table
comma
id|u16
id|rc
)paren
(brace
r_const
r_struct
id|vio_error_entry
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
r_return
op_amp
id|vio_no_error
suffix:semicolon
r_if
c_cond
(paren
id|local_table
)paren
r_for
c_loop
(paren
id|cur
op_assign
id|local_table
suffix:semicolon
id|cur-&gt;rc
suffix:semicolon
op_increment
id|cur
)paren
r_if
c_cond
(paren
id|cur-&gt;rc
op_eq
id|rc
)paren
r_return
id|cur
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|vio_default_errors
suffix:semicolon
id|cur-&gt;rc
suffix:semicolon
op_increment
id|cur
)paren
r_if
c_cond
(paren
id|cur-&gt;rc
op_eq
id|rc
)paren
r_return
id|cur
suffix:semicolon
r_return
op_amp
id|vio_unknown_error
suffix:semicolon
)brace
DECL|variable|vio_lookup_rc
id|EXPORT_SYMBOL
c_func
(paren
id|vio_lookup_rc
)paren
suffix:semicolon
eof
