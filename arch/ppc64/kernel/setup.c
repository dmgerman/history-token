multiline_comment|/*&n; * &n; * Common boot and setup code.&n; *&n; * Copyright (C) 2001 PPC64 Team, IBM Corp&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serial_8250.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/elf.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/cputable.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/nvram.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/serial.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(fmt...) udbg_printf(fmt)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(fmt...)
macro_line|#endif
multiline_comment|/*&n; * Here are some early debugging facilities. You can enable one&n; * but your kernel will not boot on anything else if you do so&n; */
multiline_comment|/* This one is for use on LPAR machines that support an HVC console&n; * on vterm 0&n; */
r_extern
r_void
id|udbg_init_debug_lpar
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* This one is for use on Apple G5 machines&n; */
r_extern
r_void
id|udbg_init_pmac_realmode
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* That&squot;s RTAS panel debug */
r_extern
r_void
id|call_rtas_display_status_delay
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
multiline_comment|/* Here&squot;s maple real mode debug */
r_extern
r_void
id|udbg_init_maple_realmode
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|EARLY_DEBUG_INIT
mdefine_line|#define EARLY_DEBUG_INIT() do {} while(0)
macro_line|#if 0
mdefine_line|#define EARLY_DEBUG_INIT() udbg_init_debug_lpar()
mdefine_line|#define EARLY_DEBUG_INIT() udbg_init_maple_realmode()
mdefine_line|#define EARLY_DEBUG_INIT() udbg_init_pmac_realmode()
mdefine_line|#define EARLY_DEBUG_INIT()&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do { ppc_md.udbg_putc = call_rtas_display_status_delay; } while(0)
macro_line|#endif
multiline_comment|/* extern void *stab; */
r_extern
r_int
r_int
id|klimit
suffix:semicolon
r_extern
r_void
id|mm_init_ppc64
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|idle_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|stab_initialize
c_func
(paren
r_int
r_int
id|stab
)paren
suffix:semicolon
r_extern
r_void
id|htab_initialize
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|early_init_devtree
c_func
(paren
r_void
op_star
id|flat_dt
)paren
suffix:semicolon
r_extern
r_void
id|unflatten_device_tree
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|smp_release_cpus
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|decr_overclock
r_int
r_int
id|decr_overclock
op_assign
l_int|1
suffix:semicolon
DECL|variable|decr_overclock_proc0
r_int
r_int
id|decr_overclock_proc0
op_assign
l_int|1
suffix:semicolon
DECL|variable|decr_overclock_set
r_int
r_int
id|decr_overclock_set
op_assign
l_int|0
suffix:semicolon
DECL|variable|decr_overclock_proc0_set
r_int
r_int
id|decr_overclock_proc0_set
op_assign
l_int|0
suffix:semicolon
DECL|variable|have_of
r_int
id|have_of
op_assign
l_int|1
suffix:semicolon
DECL|variable|boot_cpuid
r_int
id|boot_cpuid
op_assign
l_int|0
suffix:semicolon
DECL|variable|boot_cpuid_phys
r_int
id|boot_cpuid_phys
op_assign
l_int|0
suffix:semicolon
DECL|variable|boot_dev
id|dev_t
id|boot_dev
suffix:semicolon
DECL|variable|ppc64_pft_size
id|u64
id|ppc64_pft_size
suffix:semicolon
DECL|variable|ppc64_debug_switch
id|u64
id|ppc64_debug_switch
suffix:semicolon
DECL|variable|ppc64_caches
r_struct
id|ppc64_caches
id|ppc64_caches
suffix:semicolon
multiline_comment|/*&n; * These are used in binfmt_elf.c to put aux entries on the stack&n; * for each elf executable being started.&n; */
DECL|variable|dcache_bsize
r_int
id|dcache_bsize
suffix:semicolon
DECL|variable|icache_bsize
r_int
id|icache_bsize
suffix:semicolon
DECL|variable|ucache_bsize
r_int
id|ucache_bsize
suffix:semicolon
multiline_comment|/* The main machine-dep calls structure&n; */
DECL|variable|ppc_md
r_struct
id|machdep_calls
id|ppc_md
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|SYSRQ_KEY
r_int
r_int
id|SYSRQ_KEY
suffix:semicolon
macro_line|#endif /* CONFIG_MAGIC_SYSRQ */
r_static
r_int
id|ppc64_panic_event
c_func
(paren
r_struct
id|notifier_block
op_star
comma
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
DECL|variable|ppc64_panic_block
r_static
r_struct
id|notifier_block
id|ppc64_panic_block
op_assign
(brace
dot
id|notifier_call
op_assign
id|ppc64_panic_event
comma
dot
id|priority
op_assign
id|INT_MIN
multiline_comment|/* may not return; must be done last */
)brace
suffix:semicolon
multiline_comment|/*&n; * Perhaps we can put the pmac screen_info[] here&n; * on pmac as well so we don&squot;t need the ifdef&squot;s.&n; * Until we get multiple-console support in here&n; * that is.  -- Cort&n; * Maybe tie it to serial consoles, since this is really what&n; * these processors use on existing boards.  -- Dan&n; */
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
op_assign
(brace
dot
id|orig_x
op_assign
l_int|0
comma
dot
id|orig_y
op_assign
l_int|25
comma
dot
id|orig_video_cols
op_assign
l_int|80
comma
dot
id|orig_video_lines
op_assign
l_int|25
comma
dot
id|orig_video_isVGA
op_assign
l_int|1
comma
dot
id|orig_video_points
op_assign
l_int|16
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize the PPCDBG state.  Called before relocation has been enabled.&n; */
DECL|function|ppcdbg_initialize
r_void
id|__init
id|ppcdbg_initialize
c_func
(paren
r_void
)paren
(brace
id|ppc64_debug_switch
op_assign
id|PPC_DEBUG_DEFAULT
suffix:semicolon
multiline_comment|/* | PPCDBG_BUSWALK | */
multiline_comment|/* PPCDBG_PHBINIT | PPCDBG_MM | PPCDBG_MMINIT | PPCDBG_TCEINIT | PPCDBG_TCE */
suffix:semicolon
)brace
multiline_comment|/*&n; * Early boot console based on udbg&n; */
DECL|variable|udbg_console
r_static
r_struct
id|console
id|udbg_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;udbg&quot;
comma
dot
id|write
op_assign
id|udbg_console_write
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|early_console_initialized
r_static
r_int
id|early_console_initialized
suffix:semicolon
DECL|function|disable_early_printk
r_void
id|__init
id|disable_early_printk
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|early_console_initialized
)paren
r_return
suffix:semicolon
id|unregister_console
c_func
(paren
op_amp
id|udbg_console
)paren
suffix:semicolon
id|early_console_initialized
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_PPC_MULTIPLATFORM) &amp;&amp; defined(CONFIG_SMP)
DECL|variable|smt_enabled_cmdline
r_static
r_int
id|smt_enabled_cmdline
suffix:semicolon
multiline_comment|/* Look for ibm,smt-enabled OF option */
DECL|function|check_smt_enabled
r_static
r_void
id|check_smt_enabled
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_char
op_star
id|smt_option
suffix:semicolon
multiline_comment|/* Allow the command line to overrule the OF option */
r_if
c_cond
(paren
id|smt_enabled_cmdline
)paren
r_return
suffix:semicolon
id|dn
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/options&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dn
)paren
(brace
id|smt_option
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,smt-enabled&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smt_option
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|smt_option
comma
l_string|&quot;on&quot;
)paren
)paren
id|smt_enabled_at_boot
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|smt_option
comma
l_string|&quot;off&quot;
)paren
)paren
id|smt_enabled_at_boot
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Look for smt-enabled= cmdline option */
DECL|function|early_smt_enabled
r_static
r_int
id|__init
id|early_smt_enabled
c_func
(paren
r_char
op_star
id|p
)paren
(brace
id|smt_enabled_cmdline
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;on&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;1&quot;
)paren
)paren
id|smt_enabled_at_boot
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;off&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;0&quot;
)paren
)paren
id|smt_enabled_at_boot
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|early_param
c_func
(paren
l_string|&quot;smt-enabled&quot;
comma
id|early_smt_enabled
)paren
suffix:semicolon
multiline_comment|/**&n; * setup_cpu_maps - initialize the following cpu maps:&n; *                  cpu_possible_map&n; *                  cpu_present_map&n; *                  cpu_sibling_map&n; *&n; * Having the possible map set up early allows us to restrict allocations&n; * of things like irqstacks to num_possible_cpus() rather than NR_CPUS.&n; *&n; * We do not initialize the online map here; cpus set their own bits in&n; * cpu_online_map as they come up.&n; *&n; * This function is valid only for Open Firmware systems.  finish_device_tree&n; * must be called before using this.&n; *&n; * While we&squot;re here, we may as well set the &quot;physical&quot; cpu ids in the paca.&n; */
DECL|function|setup_cpu_maps
r_static
r_void
id|__init
id|setup_cpu_maps
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|dn
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cpu
op_assign
l_int|0
suffix:semicolon
r_int
id|swap_cpuid
op_assign
l_int|0
suffix:semicolon
id|check_smt_enabled
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dn
op_assign
id|of_find_node_by_type
c_func
(paren
id|dn
comma
l_string|&quot;cpu&quot;
)paren
)paren
op_logical_and
id|cpu
OL
id|NR_CPUS
)paren
(brace
id|u32
op_star
id|intserv
suffix:semicolon
r_int
id|j
comma
id|len
op_assign
r_sizeof
(paren
id|u32
)paren
comma
id|nthreads
suffix:semicolon
id|intserv
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,ppc-interrupt-server#s&quot;
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intserv
)paren
id|intserv
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|nthreads
op_assign
id|len
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nthreads
op_logical_and
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Only spin up secondary threads if SMT is enabled.&n;&t;&t;&t; * We must leave space in the logical map for the&n;&t;&t;&t; * threads.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|j
op_eq
l_int|0
op_logical_or
id|smt_enabled_at_boot
)paren
(brace
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_present_map
)paren
suffix:semicolon
id|set_hard_smp_processor_id
c_func
(paren
id|cpu
comma
id|intserv
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intserv
(braket
id|j
)braket
op_eq
id|boot_cpuid_phys
)paren
id|swap_cpuid
op_assign
id|cpu
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_possible_map
)paren
suffix:semicolon
id|cpu
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Swap CPU id 0 with boot_cpuid_phys, so we can always assume that&n;&t; * boot cpu is logical 0.&n;&t; */
r_if
c_cond
(paren
id|boot_cpuid_phys
op_ne
id|get_hard_smp_processor_id
c_func
(paren
l_int|0
)paren
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|tmp
op_assign
id|get_hard_smp_processor_id
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_hard_smp_processor_id
c_func
(paren
l_int|0
comma
id|boot_cpuid_phys
)paren
suffix:semicolon
id|set_hard_smp_processor_id
c_func
(paren
id|swap_cpuid
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * On pSeries LPAR, we need to know how many cpus&n;&t; * could possibly be added to this partition.&n;&t; */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
op_logical_and
(paren
id|dn
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
)paren
(brace
r_int
id|num_addr_cell
comma
id|num_size_cell
comma
id|maxcpus
suffix:semicolon
r_int
r_int
op_star
id|ireg
suffix:semicolon
id|num_addr_cell
op_assign
id|prom_n_addr_cells
c_func
(paren
id|dn
)paren
suffix:semicolon
id|num_size_cell
op_assign
id|prom_n_size_cells
c_func
(paren
id|dn
)paren
suffix:semicolon
id|ireg
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,lrdr-capacity&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ireg
)paren
r_goto
id|out
suffix:semicolon
id|maxcpus
op_assign
id|ireg
(braket
id|num_addr_cell
op_plus
id|num_size_cell
)braket
suffix:semicolon
multiline_comment|/* Double maxcpus for processors which have SMT capability */
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_SMT
)paren
id|maxcpus
op_mul_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|maxcpus
OG
id|NR_CPUS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Partition configured for %d cpus, &quot;
l_string|&quot;operating system maximum is %d.&bslash;n&quot;
comma
id|maxcpus
comma
id|NR_CPUS
)paren
suffix:semicolon
id|maxcpus
op_assign
id|NR_CPUS
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Partition configured for %d cpus.&bslash;n&quot;
comma
id|maxcpus
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|maxcpus
suffix:semicolon
id|cpu
op_increment
)paren
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_possible_map
)paren
suffix:semicolon
id|out
suffix:colon
id|of_node_put
c_func
(paren
id|dn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do the sibling map; assume only two threads per processor.&n;&t; */
id|for_each_cpu
c_func
(paren
id|cpu
)paren
(brace
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_sibling_map
(braket
id|cpu
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_SMT
)paren
id|cpu_set
c_func
(paren
id|cpu
op_xor
l_int|0x1
comma
id|cpu_sibling_map
(braket
id|cpu
)braket
)paren
suffix:semicolon
)brace
id|systemcfg-&gt;processorCount
op_assign
id|num_present_cpus
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_PPC_MULTIPLATFORM) &amp;&amp; defined(CONFIG_SMP) */
macro_line|#ifdef CONFIG_PPC_MULTIPLATFORM
r_extern
r_struct
id|machdep_calls
id|pSeries_md
suffix:semicolon
r_extern
r_struct
id|machdep_calls
id|pmac_md
suffix:semicolon
r_extern
r_struct
id|machdep_calls
id|maple_md
suffix:semicolon
multiline_comment|/* Ultimately, stuff them in an elf section like initcalls... */
DECL|variable|machines
r_static
r_struct
id|machdep_calls
id|__initdata
op_star
id|machines
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_PPC_PSERIES
op_amp
id|pSeries_md
comma
macro_line|#endif /* CONFIG_PPC_PSERIES */
macro_line|#ifdef CONFIG_PPC_PMAC
op_amp
id|pmac_md
comma
macro_line|#endif /* CONFIG_PPC_PMAC */
macro_line|#ifdef CONFIG_PPC_MAPLE
op_amp
id|maple_md
comma
macro_line|#endif /* CONFIG_PPC_MAPLE */
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Early initialization entry point. This is called by head.S&n; * with MMU translation disabled. We rely on the &quot;feature&quot; of&n; * the CPU that ignores the top 2 bits of the address in real&n; * mode so we can access kernel globals normally provided we&n; * only toy with things in the RMO region. From here, we do&n; * some early parsing of the device-tree to setup out LMB&n; * data structures, and allocate &amp; initialize the hash table&n; * and segment tables so we can start running with translation&n; * enabled.&n; *&n; * It is this function which will call the probe() callback of&n; * the various platform types and copy the matching one to the&n; * global ppc_md structure. Your platform can eventually do&n; * some very early initializations from the probe() routine, but&n; * this is not recommended, be very careful as, for example, the&n; * device-tree is not accessible via normal means at this point.&n; */
DECL|function|early_setup
r_void
id|__init
id|early_setup
c_func
(paren
r_int
r_int
id|dt_ptr
)paren
(brace
r_struct
id|paca_struct
op_star
id|lpaca
op_assign
id|get_paca
c_func
(paren
)paren
suffix:semicolon
r_static
r_struct
id|machdep_calls
op_star
op_star
id|mach
suffix:semicolon
multiline_comment|/*&n;&t; * Enable early debugging if any specified (see top of&n;&t; * this file)&n;&t; */
id|EARLY_DEBUG_INIT
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; early_setup()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill the default DBG level (do we want to keep&n;&t; * that old mecanism around forever ?)&n;&t; */
id|ppcdbg_initialize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do early initializations using the flattened device&n;&t; * tree, like retreiving the physical memory map or&n;&t; * calculating/retreiving the hash table size&n;&t; */
id|early_init_devtree
c_func
(paren
id|__va
c_func
(paren
id|dt_ptr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate all ppc_md structures until we find the proper&n;&t; * one for the current machine type&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;Probing machine type for platform %x...&bslash;n&quot;
comma
id|systemcfg-&gt;platform
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mach
op_assign
id|machines
suffix:semicolon
op_star
id|mach
suffix:semicolon
id|mach
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|mach
)paren
op_member_access_from_pointer
id|probe
c_func
(paren
id|systemcfg-&gt;platform
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* What can we do if we didn&squot;t find ? */
r_if
c_cond
(paren
op_star
id|mach
op_eq
l_int|NULL
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;No suitable machine found !&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
id|ppc_md
op_assign
op_star
op_star
id|mach
suffix:semicolon
multiline_comment|/* our udbg callbacks got overriden by the above, let&squot;s put them&n;&t; * back in. Ultimately, I want those things to be split from the&n;&t; * main ppc_md&n;&t; */
id|EARLY_DEBUG_INIT
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Found, Initializing memory management...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize stab / SLB management&n;&t; */
id|stab_initialize
c_func
(paren
id|lpaca-&gt;stab_real
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the MMU Hash table and create the linear mapping&n;&t; * of memory&n;&t; */
id|htab_initialize
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- early_setup()&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize some remaining members of the ppc64_caches and systemcfg structures&n; * (at least until we get rid of them completely). This is mostly some&n; * cache informations about the CPU that will be used by cache flush&n; * routines and/or provided to userland&n; */
DECL|function|initialize_cache_info
r_static
r_void
id|__init
id|initialize_cache_info
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
r_int
id|num_cpus
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; initialize_cache_info()&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
l_int|NULL
suffix:semicolon
(paren
id|np
op_assign
id|of_find_node_by_type
c_func
(paren
id|np
comma
l_string|&quot;cpu&quot;
)paren
)paren
suffix:semicolon
)paren
(brace
id|num_cpus
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* We&squot;re assuming *all* of the CPUs have the same&n;&t;&t; * d-cache and i-cache sizes... -Peter&n;&t;&t; */
r_if
c_cond
(paren
id|num_cpus
op_eq
l_int|1
)paren
(brace
id|u32
op_star
id|sizep
comma
op_star
id|lsizep
suffix:semicolon
id|u32
id|size
comma
id|lsize
suffix:semicolon
r_const
r_char
op_star
id|dc
comma
op_star
id|ic
suffix:semicolon
multiline_comment|/* Then read cache informations */
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_eq
id|PLATFORM_POWERMAC
)paren
(brace
id|dc
op_assign
l_string|&quot;d-cache-block-size&quot;
suffix:semicolon
id|ic
op_assign
l_string|&quot;i-cache-block-size&quot;
suffix:semicolon
)brace
r_else
(brace
id|dc
op_assign
l_string|&quot;d-cache-line-size&quot;
suffix:semicolon
id|ic
op_assign
l_string|&quot;i-cache-line-size&quot;
suffix:semicolon
)brace
id|size
op_assign
l_int|0
suffix:semicolon
id|lsize
op_assign
id|cur_cpu_spec-&gt;dcache_bsize
suffix:semicolon
id|sizep
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;d-cache-size&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizep
op_ne
l_int|NULL
)paren
id|size
op_assign
op_star
id|sizep
suffix:semicolon
id|lsizep
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
id|dc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsizep
op_ne
l_int|NULL
)paren
id|lsize
op_assign
op_star
id|lsizep
suffix:semicolon
r_if
c_cond
(paren
id|sizep
op_eq
l_int|0
op_logical_or
id|lsizep
op_eq
l_int|0
)paren
id|DBG
c_func
(paren
l_string|&quot;Argh, can&squot;t find dcache properties ! &quot;
l_string|&quot;sizep: %p, lsizep: %p&bslash;n&quot;
comma
id|sizep
comma
id|lsizep
)paren
suffix:semicolon
id|systemcfg-&gt;dcache_size
op_assign
id|ppc64_caches.dsize
op_assign
id|size
suffix:semicolon
id|systemcfg-&gt;dcache_line_size
op_assign
id|ppc64_caches.dline_size
op_assign
id|lsize
suffix:semicolon
id|ppc64_caches.log_dline_size
op_assign
id|__ilog2
c_func
(paren
id|lsize
)paren
suffix:semicolon
id|ppc64_caches.dlines_per_page
op_assign
id|PAGE_SIZE
op_div
id|lsize
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
id|lsize
op_assign
id|cur_cpu_spec-&gt;icache_bsize
suffix:semicolon
id|sizep
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;i-cache-size&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizep
op_ne
l_int|NULL
)paren
id|size
op_assign
op_star
id|sizep
suffix:semicolon
id|lsizep
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
id|ic
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsizep
op_ne
l_int|NULL
)paren
id|lsize
op_assign
op_star
id|lsizep
suffix:semicolon
r_if
c_cond
(paren
id|sizep
op_eq
l_int|0
op_logical_or
id|lsizep
op_eq
l_int|0
)paren
id|DBG
c_func
(paren
l_string|&quot;Argh, can&squot;t find icache properties ! &quot;
l_string|&quot;sizep: %p, lsizep: %p&bslash;n&quot;
comma
id|sizep
comma
id|lsizep
)paren
suffix:semicolon
id|systemcfg-&gt;icache_size
op_assign
id|ppc64_caches.isize
op_assign
id|size
suffix:semicolon
id|systemcfg-&gt;icache_line_size
op_assign
id|ppc64_caches.iline_size
op_assign
id|lsize
suffix:semicolon
id|ppc64_caches.log_iline_size
op_assign
id|__ilog2
c_func
(paren
id|lsize
)paren
suffix:semicolon
id|ppc64_caches.ilines_per_page
op_assign
id|PAGE_SIZE
op_div
id|lsize
suffix:semicolon
)brace
)brace
multiline_comment|/* Add an eye catcher and the systemcfg layout version number */
id|strcpy
c_func
(paren
id|systemcfg-&gt;eye_catcher
comma
l_string|&quot;SYSTEMCFG:PPC64&quot;
)paren
suffix:semicolon
id|systemcfg-&gt;version.major
op_assign
id|SYSTEMCFG_MAJOR
suffix:semicolon
id|systemcfg-&gt;version.minor
op_assign
id|SYSTEMCFG_MINOR
suffix:semicolon
id|systemcfg-&gt;processor
op_assign
id|mfspr
c_func
(paren
id|SPRN_PVR
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- initialize_cache_info()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|check_for_initrd
r_static
r_void
id|__init
id|check_for_initrd
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
id|u64
op_star
id|prop
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; check_for_initrd()&bslash;n&quot;
)paren
suffix:semicolon
id|prop
op_assign
(paren
id|u64
op_star
)paren
id|get_property
c_func
(paren
id|of_chosen
comma
l_string|&quot;linux,initrd-start&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
op_ne
l_int|NULL
)paren
(brace
id|initrd_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
op_star
id|prop
)paren
suffix:semicolon
id|prop
op_assign
(paren
id|u64
op_star
)paren
id|get_property
c_func
(paren
id|of_chosen
comma
l_string|&quot;linux,initrd-end&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
op_ne
l_int|NULL
)paren
(brace
id|initrd_end
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
op_star
id|prop
)paren
suffix:semicolon
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we were passed an initrd, set the ROOT_DEV properly if the values&n;&t; * look sensible. If not, clear initrd reference.&n;&t; */
r_if
c_cond
(paren
id|initrd_start
op_ge
id|KERNELBASE
op_logical_and
id|initrd_end
op_ge
id|KERNELBASE
op_logical_and
id|initrd_end
OG
id|initrd_start
)paren
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_else
id|initrd_start
op_assign
id|initrd_end
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|initrd_start
)paren
id|printk
c_func
(paren
l_string|&quot;Found initrd at 0x%lx:0x%lx&bslash;n&quot;
comma
id|initrd_start
comma
id|initrd_end
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- check_for_initrd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
)brace
macro_line|#endif /* CONFIG_PPC_MULTIPLATFORM */
multiline_comment|/*&n; * Do some initial setup of the system.  The parameters are those which &n; * were passed in from the bootloader.&n; */
DECL|function|setup_system
r_void
id|__init
id|setup_system
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; -&gt; setup_system()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
multiline_comment|/* pSeries systems are identified in prom.c via OF. */
r_if
c_cond
(paren
id|itLpNaca.xLparInstalled
op_eq
l_int|1
)paren
id|systemcfg-&gt;platform
op_assign
id|PLATFORM_ISERIES_LPAR
suffix:semicolon
id|ppc_md
dot
id|init_early
c_func
(paren
)paren
suffix:semicolon
macro_line|#else /* CONFIG_PPC_ISERIES */
multiline_comment|/*&n;&t; * Unflatten the device-tree passed by prom_init or kexec&n;&t; */
id|unflatten_device_tree
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill the ppc64_caches &amp; systemcfg structures with informations&n;&t; * retreived from the device-tree. Need to be called before&n;&t; * finish_device_tree() since the later requires some of the&n;&t; * informations filled up here to properly parse the interrupt&n;&t; * tree.&n;&t; * It also sets up the cache line sizes which allows to call&n;&t; * routines like flush_icache_range (used by the hash init&n;&t; * later on).&n;&t; */
id|initialize_cache_info
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_PSERIES
multiline_comment|/*&n;&t; * Initialize RTAS if available&n;&t; */
id|rtas_initialize
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPC_PSERIES */
multiline_comment|/*&n;&t; * Check if we have an initrd provided via the device-tree&n;&t; */
id|check_for_initrd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do some platform specific early initializations, that includes&n;&t; * setting up the hash table pointers. It also sets up some interrupt-mapping&n;&t; * related options that will be used by finish_device_tree()&n;&t; */
id|ppc_md
dot
id|init_early
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;Finish&quot; the device-tree, that is do the actual parsing of&n;&t; * some of the properties like the interrupt map&n;&t; */
id|finish_device_tree
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize xmon&n;&t; */
macro_line|#ifdef CONFIG_XMON_DEFAULT
id|xmon_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Register early console&n;&t; */
id|early_console_initialized
op_assign
l_int|1
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|udbg_console
)paren
suffix:semicolon
macro_line|#endif /* !CONFIG_PPC_ISERIES */
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|strlcpy
c_func
(paren
id|saved_command_line
comma
id|cmd_line
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|parse_early_param
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SMP) &amp;&amp; !defined(CONFIG_PPC_ISERIES)
multiline_comment|/*&n;&t; * iSeries has already initialized the cpu maps at this point.&n;&t; */
id|setup_cpu_maps
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release secondary cpus out of their spinloops at 0x60 now that&n;&t; * we can map physical -&gt; logical CPU ids&n;&t; */
id|smp_release_cpus
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* defined(CONFIG_SMP) &amp;&amp; !defined(CONFIG_PPC_ISERIES) */
id|printk
c_func
(paren
l_string|&quot;Starting Linux PPC64 %s&bslash;n&quot;
comma
id|UTS_RELEASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-----------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppc64_pft_size                = 0x%lx&bslash;n&quot;
comma
id|ppc64_pft_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppc64_debug_switch            = 0x%lx&bslash;n&quot;
comma
id|ppc64_debug_switch
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppc64_interrupt_controller    = 0x%ld&bslash;n&quot;
comma
id|ppc64_interrupt_controller
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;systemcfg                     = 0x%p&bslash;n&quot;
comma
id|systemcfg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;systemcfg-&gt;platform           = 0x%x&bslash;n&quot;
comma
id|systemcfg-&gt;platform
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;systemcfg-&gt;processorCount     = 0x%lx&bslash;n&quot;
comma
id|systemcfg-&gt;processorCount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;systemcfg-&gt;physicalMemorySize = 0x%lx&bslash;n&quot;
comma
id|systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppc64_caches.dcache_line_size = 0x%x&bslash;n&quot;
comma
id|ppc64_caches.dline_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppc64_caches.icache_line_size = 0x%x&bslash;n&quot;
comma
id|ppc64_caches.iline_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;htab_address                  = 0x%p&bslash;n&quot;
comma
id|htab_address
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;htab_hash_mask                = 0x%lx&bslash;n&quot;
comma
id|htab_hash_mask
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-----------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|mm_init_ppc64
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- setup_system()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.nvram_sync
)paren
id|ppc_md
dot
id|nvram_sync
c_func
(paren
)paren
suffix:semicolon
id|ppc_md
dot
id|restart
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
DECL|variable|machine_restart
id|EXPORT_SYMBOL
c_func
(paren
id|machine_restart
)paren
suffix:semicolon
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.nvram_sync
)paren
id|ppc_md
dot
id|nvram_sync
c_func
(paren
)paren
suffix:semicolon
id|ppc_md
dot
id|power_off
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|machine_power_off
id|EXPORT_SYMBOL
c_func
(paren
id|machine_power_off
)paren
suffix:semicolon
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.nvram_sync
)paren
id|ppc_md
dot
id|nvram_sync
c_func
(paren
)paren
suffix:semicolon
id|ppc_md
dot
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|machine_halt
id|EXPORT_SYMBOL
c_func
(paren
id|machine_halt
)paren
suffix:semicolon
DECL|variable|ppc_proc_freq
r_int
r_int
id|ppc_proc_freq
suffix:semicolon
DECL|variable|ppc_tb_freq
r_int
r_int
id|ppc_tb_freq
suffix:semicolon
DECL|function|ppc64_panic_event
r_static
r_int
id|ppc64_panic_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
id|ppc_md
dot
id|panic
c_func
(paren
(paren
r_char
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* May not return */
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|pvr
)paren
suffix:semicolon
macro_line|#endif
DECL|function|show_cpuinfo
r_static
r_int
id|show_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|cpu_id
op_assign
(paren
r_int
r_int
)paren
id|v
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|pvr
suffix:semicolon
r_int
r_int
id|maj
suffix:semicolon
r_int
r_int
id|min
suffix:semicolon
r_if
c_cond
(paren
id|cpu_id
op_eq
id|NR_CPUS
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;timebase&bslash;t: %lu&bslash;n&quot;
comma
id|ppc_tb_freq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.get_cpuinfo
op_ne
l_int|NULL
)paren
id|ppc_md
dot
id|get_cpuinfo
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We only show online cpus: disable preempt (overzealous, I&n;&t; * knew) to prevent cpu going down. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu_id
)paren
)paren
(brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|pvr
op_assign
id|per_cpu
c_func
(paren
id|pvr
comma
id|cpu_id
)paren
suffix:semicolon
macro_line|#else
id|pvr
op_assign
id|mfspr
c_func
(paren
id|SPRN_PVR
)paren
suffix:semicolon
macro_line|#endif
id|maj
op_assign
(paren
id|pvr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|min
op_assign
id|pvr
op_amp
l_int|0xFF
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;processor&bslash;t: %lu&bslash;n&quot;
comma
id|cpu_id
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;cpu&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;pvr_mask
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s&quot;
comma
id|cur_cpu_spec-&gt;cpu_name
)paren
suffix:semicolon
r_else
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;unknown (%08x)&quot;
comma
id|pvr
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ALTIVEC
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_ALTIVEC
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;, altivec supported&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ALTIVEC */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Assume here that all clock rates are the same in a&n;&t; * smp system.  -- Cort&n;&t; */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;clock&bslash;t&bslash;t: %lu.%06luMHz&bslash;n&quot;
comma
id|ppc_proc_freq
op_div
l_int|1000000
comma
id|ppc_proc_freq
op_mod
l_int|1000000
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;revision&bslash;t: %hd.%hd&bslash;n&bslash;n&quot;
comma
id|maj
comma
id|min
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|c_start
r_static
r_void
op_star
id|c_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
op_star
id|pos
op_le
id|NR_CPUS
ques
c_cond
(paren
r_void
op_star
)paren
(paren
(paren
op_star
id|pos
)paren
op_plus
l_int|1
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|c_next
r_static
r_void
op_star
id|c_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|c_start
c_func
(paren
id|m
comma
id|pos
)paren
suffix:semicolon
)brace
DECL|function|c_stop
r_static
r_void
id|c_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
)brace
DECL|variable|cpuinfo_op
r_struct
id|seq_operations
id|cpuinfo_op
op_assign
(brace
dot
id|start
op_assign
id|c_start
comma
dot
id|next
op_assign
id|c_next
comma
dot
id|stop
op_assign
id|c_stop
comma
dot
id|show
op_assign
id|show_cpuinfo
comma
)brace
suffix:semicolon
macro_line|#if 0 /* XXX not currently used */
r_int
r_int
id|memory_limit
suffix:semicolon
r_static
r_int
id|__init
id|early_parsemem
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
id|memory_limit
op_assign
id|memparse
c_func
(paren
id|p
comma
op_amp
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|early_param
c_func
(paren
l_string|&quot;mem&quot;
comma
id|early_parsemem
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PPC_MULTIPLATFORM
DECL|function|set_preferred_console
r_static
r_int
id|__init
id|set_preferred_console
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|prom_stdout
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
id|u32
op_star
id|spd
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; set_preferred_console()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* The user has requested a console so this is already set up. */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|saved_command_line
comma
l_string|&quot;console=&quot;
)paren
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; console was specified !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|of_chosen
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; of_chosen is NULL !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* We are getting a weird phandle from OF ... */
multiline_comment|/* ... So use the full path instead */
id|name
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|of_chosen
comma
l_string|&quot;linux,stdout-path&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; no linux,stdout-path !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|prom_stdout
op_assign
id|of_find_node_by_path
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prom_stdout
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; can&squot;t find stdout package %s !&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;stdout is %s&bslash;n&quot;
comma
id|prom_stdout-&gt;full_name
)paren
suffix:semicolon
id|name
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|prom_stdout
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; stdout package has no name !&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|not_found
suffix:semicolon
)brace
id|spd
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|prom_stdout
comma
l_string|&quot;current-speed&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_CONSOLE
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;serial&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
op_star
id|reg
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|prom_stdout
comma
l_string|&quot;reg&quot;
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|8
)paren
(brace
r_switch
c_cond
(paren
id|reg
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|0x3f8
suffix:colon
id|offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2f8
suffix:colon
id|offset
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x898
suffix:colon
id|offset
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x890
suffix:colon
id|offset
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We dont recognise the serial port */
r_goto
id|not_found
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_SERIAL_8250_CONSOLE */
macro_line|#ifdef CONFIG_PPC_PSERIES
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;vty&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|u32
op_star
id|reg
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|prom_stdout
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_char
op_star
id|compat
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|prom_stdout
comma
l_string|&quot;compatible&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_logical_and
id|compat
op_logical_and
(paren
id|strcmp
c_func
(paren
id|compat
comma
l_string|&quot;hvterm-protocol&quot;
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Host Virtual Serial Interface */
r_int
id|offset
suffix:semicolon
r_switch
c_cond
(paren
id|reg
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x30000000
suffix:colon
id|offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30000001
suffix:colon
id|offset
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_found
suffix:semicolon
)brace
id|of_node_put
c_func
(paren
id|prom_stdout
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Found hvsi console at offset %d&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
r_return
id|add_preferred_console
c_func
(paren
l_string|&quot;hvsi&quot;
comma
id|offset
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* pSeries LPAR virtual console */
id|of_node_put
c_func
(paren
id|prom_stdout
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Found hvc console&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|add_preferred_console
c_func
(paren
l_string|&quot;hvc&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PPC_PSERIES */
macro_line|#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;ch-a&quot;
)paren
op_eq
l_int|0
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;ch-b&quot;
)paren
op_eq
l_int|0
)paren
id|offset
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_PMACZILOG_CONSOLE */
r_else
r_goto
id|not_found
suffix:semicolon
id|of_node_put
c_func
(paren
id|prom_stdout
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Found serial console at ttyS%d&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spd
)paren
(brace
r_static
r_char
id|__initdata
id|opt
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|opt
comma
l_string|&quot;%d&quot;
comma
op_star
id|spd
)paren
suffix:semicolon
r_return
id|add_preferred_console
c_func
(paren
l_string|&quot;ttyS&quot;
comma
id|offset
comma
id|opt
)paren
suffix:semicolon
)brace
r_else
r_return
id|add_preferred_console
c_func
(paren
l_string|&quot;ttyS&quot;
comma
id|offset
comma
l_int|NULL
)paren
suffix:semicolon
id|not_found
suffix:colon
id|DBG
c_func
(paren
l_string|&quot;No preferred console found !&bslash;n&quot;
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|prom_stdout
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|set_preferred_console
id|console_initcall
c_func
(paren
id|set_preferred_console
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPC_MULTIPLATFORM */
macro_line|#ifdef CONFIG_IRQSTACKS
DECL|function|irqstack_early_init
r_static
r_void
id|__init
id|irqstack_early_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * interrupt stacks must be under 256MB, we cannot afford to take&n;&t; * SLB misses on them.&n;&t; */
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
id|softirq_ctx
(braket
id|i
)braket
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
id|__va
c_func
(paren
id|lmb_alloc_base
c_func
(paren
id|THREAD_SIZE
comma
id|THREAD_SIZE
comma
l_int|0x10000000
)paren
)paren
suffix:semicolon
id|hardirq_ctx
(braket
id|i
)braket
op_assign
(paren
r_struct
id|thread_info
op_star
)paren
id|__va
c_func
(paren
id|lmb_alloc_base
c_func
(paren
id|THREAD_SIZE
comma
id|THREAD_SIZE
comma
l_int|0x10000000
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|irqstack_early_init
mdefine_line|#define irqstack_early_init()
macro_line|#endif
multiline_comment|/*&n; * Stack space used when we detect a bad kernel stack pointer, and&n; * early in SMP boots before relocation is enabled.&n; */
DECL|function|emergency_stack_init
r_static
r_void
id|__init
id|emergency_stack_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|limit
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Emergency stacks must be under 256MB, we cannot afford to take&n;&t; * SLB misses on them. The ABI also requires them to be 128-byte&n;&t; * aligned.&n;&t; *&n;&t; * Since we use these as temporary stacks during secondary CPU&n;&t; * bringup, we need to get at them in real mode. This means they&n;&t; * must also be within the RMO region.&n;&t; */
id|limit
op_assign
id|min
c_func
(paren
l_int|0x10000000UL
comma
id|lmb.rmo_size
)paren
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|i
)paren
id|paca
(braket
id|i
)braket
dot
id|emergency_sp
op_assign
id|__va
c_func
(paren
id|lmb_alloc_base
c_func
(paren
id|PAGE_SIZE
comma
l_int|128
comma
id|limit
)paren
)paren
op_plus
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n; * Called into from start_kernel, after lock_kernel has been called.&n; * Initializes bootmem, which is unsed to manage page allocation until&n; * mem_init is called.&n; */
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_extern
r_void
id|do_init_bootmem
c_func
(paren
r_void
)paren
suffix:semicolon
id|ppc64_boot_msg
c_func
(paren
l_int|0x12
comma
l_string|&quot;Setup Arch&quot;
)paren
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|cmd_line
suffix:semicolon
multiline_comment|/*&n;&t; * Set cache line size based on type of cpu as a default.&n;&t; * Systems with OF can look in the properties on the cpu node(s)&n;&t; * for a possibly more accurate value.&n;&t; */
id|dcache_bsize
op_assign
id|ppc64_caches.dline_size
suffix:semicolon
id|icache_bsize
op_assign
id|ppc64_caches.iline_size
suffix:semicolon
multiline_comment|/* reboot on panic */
id|panic_timeout
op_assign
l_int|180
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.panic
)paren
id|notifier_chain_register
c_func
(paren
op_amp
id|panic_notifier_list
comma
op_amp
id|ppc64_panic_block
)paren
suffix:semicolon
id|init_mm.start_code
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|init_mm.end_code
op_assign
(paren
r_int
r_int
)paren
id|_etext
suffix:semicolon
id|init_mm.end_data
op_assign
(paren
r_int
r_int
)paren
id|_edata
suffix:semicolon
id|init_mm.brk
op_assign
id|klimit
suffix:semicolon
id|irqstack_early_init
c_func
(paren
)paren
suffix:semicolon
id|emergency_stack_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set up the bootmem stuff with available memory */
id|do_init_bootmem
c_func
(paren
)paren
suffix:semicolon
id|ppc_md
dot
id|setup_arch
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Select the correct idle loop for the platform. */
id|idle_setup
c_func
(paren
)paren
suffix:semicolon
id|paging_init
c_func
(paren
)paren
suffix:semicolon
id|ppc64_boot_msg
c_func
(paren
l_int|0x15
comma
l_string|&quot;Setup Done&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ToDo: do something useful if ppc_md is not yet setup. */
DECL|macro|PPC64_LINUX_FUNCTION
mdefine_line|#define PPC64_LINUX_FUNCTION 0x0f000000
DECL|macro|PPC64_IPL_MESSAGE
mdefine_line|#define PPC64_IPL_MESSAGE 0xc0000000
DECL|macro|PPC64_TERM_MESSAGE
mdefine_line|#define PPC64_TERM_MESSAGE 0xb0000000
DECL|macro|PPC64_ATTN_MESSAGE
mdefine_line|#define PPC64_ATTN_MESSAGE 0xa0000000
DECL|macro|PPC64_DUMP_MESSAGE
mdefine_line|#define PPC64_DUMP_MESSAGE 0xd0000000
DECL|function|ppc64_do_msg
r_static
r_void
id|ppc64_do_msg
c_func
(paren
r_int
r_int
id|src
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.progress
)paren
(brace
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%08x        &bslash;n&quot;
comma
id|src
)paren
suffix:semicolon
id|ppc_md
dot
id|progress
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-16s&quot;
comma
id|msg
)paren
suffix:semicolon
id|ppc_md
dot
id|progress
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Print a boot progress message. */
DECL|function|ppc64_boot_msg
r_void
id|ppc64_boot_msg
c_func
(paren
r_int
r_int
id|src
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ppc64_do_msg
c_func
(paren
id|PPC64_LINUX_FUNCTION
op_or
id|PPC64_IPL_MESSAGE
op_or
id|src
comma
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[boot]%04x %s&bslash;n&quot;
comma
id|src
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Print a termination message (print only -- does not stop the kernel) */
DECL|function|ppc64_terminate_msg
r_void
id|ppc64_terminate_msg
c_func
(paren
r_int
r_int
id|src
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ppc64_do_msg
c_func
(paren
id|PPC64_LINUX_FUNCTION
op_or
id|PPC64_TERM_MESSAGE
op_or
id|src
comma
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[terminate]%04x %s&bslash;n&quot;
comma
id|src
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Print something that needs attention (device error, etc) */
DECL|function|ppc64_attention_msg
r_void
id|ppc64_attention_msg
c_func
(paren
r_int
r_int
id|src
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ppc64_do_msg
c_func
(paren
id|PPC64_LINUX_FUNCTION
op_or
id|PPC64_ATTN_MESSAGE
op_or
id|src
comma
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[attention]%04x %s&bslash;n&quot;
comma
id|src
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Print a dump progress message. */
DECL|function|ppc64_dump_msg
r_void
id|ppc64_dump_msg
c_func
(paren
r_int
r_int
id|src
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ppc64_do_msg
c_func
(paren
id|PPC64_LINUX_FUNCTION
op_or
id|PPC64_DUMP_MESSAGE
op_or
id|src
comma
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[dump]%04x %s&bslash;n&quot;
comma
id|src
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|set_spread_lpevents
r_int
id|set_spread_lpevents
c_func
(paren
r_char
op_star
id|str
)paren
(brace
multiline_comment|/* The parameter is the number of processors to share in processing lp events */
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OG
l_int|0
)paren
op_logical_and
(paren
id|val
op_le
id|NR_CPUS
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|val
suffix:semicolon
op_increment
id|i
)paren
id|paca
(braket
id|i
)braket
dot
id|lpqueue_ptr
op_assign
id|paca
(braket
l_int|0
)braket
dot
id|lpqueue_ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;lpevent processing spread over %ld processors&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;invalid spreaqd_lpevents %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This should only be called on processor 0 during calibrate decr */
DECL|function|setup_default_decr
r_void
id|setup_default_decr
c_func
(paren
r_void
)paren
(brace
r_struct
id|paca_struct
op_star
id|lpaca
op_assign
id|get_paca
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decr_overclock_set
op_logical_and
op_logical_neg
id|decr_overclock_proc0_set
)paren
id|decr_overclock_proc0
op_assign
id|decr_overclock
suffix:semicolon
id|lpaca-&gt;default_decr
op_assign
id|tb_ticks_per_jiffy
op_div
id|decr_overclock_proc0
suffix:semicolon
id|lpaca-&gt;next_jiffy_update_tb
op_assign
id|get_tb
c_func
(paren
)paren
op_plus
id|tb_ticks_per_jiffy
suffix:semicolon
)brace
DECL|function|set_decr_overclock_proc0
r_int
id|set_decr_overclock_proc0
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_ge
l_int|1
)paren
op_logical_and
(paren
id|val
op_le
l_int|48
)paren
)paren
(brace
id|decr_overclock_proc0_set
op_assign
l_int|1
suffix:semicolon
id|decr_overclock_proc0
op_assign
id|val
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;proc 0 decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;invalid proc 0 decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|set_decr_overclock
r_int
id|set_decr_overclock
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_ge
l_int|1
)paren
op_logical_and
(paren
id|val
op_le
l_int|48
)paren
)paren
(brace
id|decr_overclock_set
op_assign
l_int|1
suffix:semicolon
id|decr_overclock
op_assign
id|val
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;invalid decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;spread_lpevents=&quot;
comma
id|set_spread_lpevents
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;decr_overclock_proc0=&quot;
comma
id|set_decr_overclock_proc0
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;decr_overclock=&quot;
comma
id|set_decr_overclock
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_PPC_ISERIES
multiline_comment|/*&n; * This function can be used by platforms to &quot;find&quot; legacy serial ports.&n; * It works for &quot;serial&quot; nodes under an &quot;isa&quot; node, and will try to&n; * respect the &quot;ibm,aix-loc&quot; property if any. It works with up to 8&n; * ports.&n; */
DECL|macro|MAX_LEGACY_SERIAL_PORTS
mdefine_line|#define MAX_LEGACY_SERIAL_PORTS&t;8
DECL|variable|serial_ports
r_static
r_struct
id|plat_serial8250_port
id|serial_ports
(braket
id|MAX_LEGACY_SERIAL_PORTS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|old_serial_count
r_static
r_int
r_int
id|old_serial_count
suffix:semicolon
DECL|function|generic_find_legacy_serial_ports
r_void
id|__init
id|generic_find_legacy_serial_ports
c_func
(paren
id|u64
op_star
id|physport
comma
r_int
r_int
op_star
id|default_speed
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|u32
op_star
id|sizeprop
suffix:semicolon
r_struct
id|isa_reg_property
(brace
id|u32
id|space
suffix:semicolon
id|u32
id|address
suffix:semicolon
id|u32
id|size
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|pci_reg_property
(brace
r_struct
id|pci_address
id|addr
suffix:semicolon
id|u32
id|size_hi
suffix:semicolon
id|u32
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; -&gt; generic_find_legacy_serial_port()&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|physport
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|default_speed
)paren
op_star
id|default_speed
op_assign
l_int|0
suffix:semicolon
id|np
op_assign
id|of_find_node_by_path
c_func
(paren
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
suffix:semicolon
multiline_comment|/* First fill our array */
r_for
c_loop
(paren
id|np
op_assign
l_int|NULL
suffix:semicolon
(paren
id|np
op_assign
id|of_find_node_by_type
c_func
(paren
id|np
comma
l_string|&quot;serial&quot;
)paren
)paren
suffix:semicolon
)paren
(brace
r_struct
id|device_node
op_star
id|isa
comma
op_star
id|pci
suffix:semicolon
r_struct
id|isa_reg_property
op_star
id|reg
suffix:semicolon
r_int
r_int
id|phys_size
comma
id|addr_size
comma
id|io_base
suffix:semicolon
id|u32
op_star
id|rangesp
suffix:semicolon
id|u32
op_star
id|interrupts
comma
op_star
id|clk
comma
op_star
id|spd
suffix:semicolon
r_char
op_star
id|typep
suffix:semicolon
r_int
id|index
comma
id|rlen
comma
id|rentsize
suffix:semicolon
multiline_comment|/* Ok, first check if it&squot;s under an &quot;isa&quot; parent */
id|isa
op_assign
id|of_get_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isa
op_logical_or
id|strcmp
c_func
(paren
id|isa-&gt;name
comma
l_string|&quot;isa&quot;
)paren
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;%s: no isa parent found&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Now look for an &quot;ibm,aix-loc&quot; property that gives us ordering&n;&t;&t; * if any...&n;&t;&t; */
id|typep
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;ibm,aix-loc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Get the ISA port number */
id|reg
op_assign
(paren
r_struct
id|isa_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
l_int|NULL
)paren
r_goto
id|next_port
suffix:semicolon
multiline_comment|/* We assume the interrupt number isn&squot;t translated ... */
id|interrupts
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* get clock freq. if present */
id|clk
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;clock-frequency&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* get default speed if present */
id|spd
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;current-speed&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Default to locate at end of array */
id|index
op_assign
id|old_serial_count
suffix:semicolon
multiline_comment|/* end of the array by default */
multiline_comment|/* If we have a location index, then use it */
r_if
c_cond
(paren
id|typep
op_logical_and
op_star
id|typep
op_eq
l_char|&squot;S&squot;
)paren
(brace
id|index
op_assign
id|simple_strtol
c_func
(paren
id|typep
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* if index is out of range, use end of array instead */
r_if
c_cond
(paren
id|index
op_ge
id|MAX_LEGACY_SERIAL_PORTS
)paren
id|index
op_assign
id|old_serial_count
suffix:semicolon
multiline_comment|/* if our index is still out of range, that mean that&n;&t;&t;&t; * array is full, we could scan for a free slot but that&n;&t;&t;&t; * make little sense to bother, just skip the port&n;&t;&t;&t; */
r_if
c_cond
(paren
id|index
op_ge
id|MAX_LEGACY_SERIAL_PORTS
)paren
r_goto
id|next_port
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|old_serial_count
)paren
id|old_serial_count
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Check if there is a port who already claimed our slot */
r_if
c_cond
(paren
id|serial_ports
(braket
id|index
)braket
dot
id|iobase
op_ne
l_int|0
)paren
(brace
multiline_comment|/* if we still have some room, move it, else override */
r_if
c_cond
(paren
id|old_serial_count
OL
id|MAX_LEGACY_SERIAL_PORTS
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;Moved legacy port %d -&gt; %d&bslash;n&quot;
comma
id|index
comma
id|old_serial_count
)paren
suffix:semicolon
id|serial_ports
(braket
id|old_serial_count
op_increment
)braket
op_assign
id|serial_ports
(braket
id|index
)braket
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
l_string|&quot;Replacing legacy port %d&bslash;n&quot;
comma
id|index
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|index
op_ge
id|MAX_LEGACY_SERIAL_PORTS
)paren
r_goto
id|next_port
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|old_serial_count
)paren
id|old_serial_count
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Now fill the entry */
id|memset
c_func
(paren
op_amp
id|serial_ports
(braket
id|index
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|plat_serial8250_port
)paren
)paren
suffix:semicolon
id|serial_ports
(braket
id|index
)braket
dot
id|uartclk
op_assign
id|clk
ques
c_cond
op_star
id|clk
suffix:colon
id|BASE_BAUD
op_star
l_int|16
suffix:semicolon
id|serial_ports
(braket
id|index
)braket
dot
id|iobase
op_assign
id|reg-&gt;address
suffix:semicolon
id|serial_ports
(braket
id|index
)braket
dot
id|irq
op_assign
id|interrupts
ques
c_cond
id|interrupts
(braket
l_int|0
)braket
suffix:colon
l_int|0
suffix:semicolon
id|serial_ports
(braket
id|index
)braket
dot
id|flags
op_assign
id|ASYNC_BOOT_AUTOCONF
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Added legacy port, index: %d, port: %x, irq: %d, clk: %d&bslash;n&quot;
comma
id|index
comma
id|serial_ports
(braket
id|index
)braket
dot
id|iobase
comma
id|serial_ports
(braket
id|index
)braket
dot
id|irq
comma
id|serial_ports
(braket
id|index
)braket
dot
id|uartclk
)paren
suffix:semicolon
multiline_comment|/* Get phys address of IO reg for port 1 */
r_if
c_cond
(paren
id|index
op_ne
l_int|0
)paren
r_goto
id|next_port
suffix:semicolon
id|pci
op_assign
id|of_get_parent
c_func
(paren
id|isa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;%s: no pci parent found&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_goto
id|next_port
suffix:semicolon
)brace
id|rangesp
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|pci
comma
l_string|&quot;ranges&quot;
comma
op_amp
id|rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rangesp
op_eq
l_int|NULL
)paren
(brace
id|of_node_put
c_func
(paren
id|pci
)paren
suffix:semicolon
r_goto
id|next_port
suffix:semicolon
)brace
id|rlen
op_div_assign
l_int|4
suffix:semicolon
multiline_comment|/* we need the #size-cells of the PCI bridge node itself */
id|phys_size
op_assign
l_int|1
suffix:semicolon
id|sizeprop
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|pci
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizeprop
op_ne
l_int|NULL
)paren
id|phys_size
op_assign
op_star
id|sizeprop
suffix:semicolon
multiline_comment|/* we need the parent #addr-cells */
id|addr_size
op_assign
id|prom_n_addr_cells
c_func
(paren
id|pci
)paren
suffix:semicolon
id|rentsize
op_assign
l_int|3
op_plus
id|addr_size
op_plus
id|phys_size
suffix:semicolon
id|io_base
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|rlen
op_ge
id|rentsize
suffix:semicolon
id|rlen
op_sub_assign
id|rentsize
comma
id|rangesp
op_add_assign
id|rentsize
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|rangesp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|0x3
)paren
op_ne
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* not IO space */
id|io_base
op_assign
id|rangesp
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|addr_size
op_eq
l_int|2
)paren
id|io_base
op_assign
(paren
id|io_base
op_lshift
l_int|32
)paren
op_or
id|rangesp
(braket
l_int|4
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io_base
op_ne
l_int|0
)paren
(brace
op_star
id|physport
op_assign
id|io_base
op_plus
id|reg-&gt;address
suffix:semicolon
r_if
c_cond
(paren
id|default_speed
op_logical_and
id|spd
)paren
op_star
id|default_speed
op_assign
op_star
id|spd
suffix:semicolon
)brace
id|of_node_put
c_func
(paren
id|pci
)paren
suffix:semicolon
id|next_port
suffix:colon
id|of_node_put
c_func
(paren
id|isa
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot; &lt;- generic_find_legacy_serial_port()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|serial_device
r_static
r_struct
id|platform_device
id|serial_device
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;serial8250&quot;
comma
dot
id|id
op_assign
l_int|0
comma
dot
id|dev
op_assign
(brace
dot
id|platform_data
op_assign
id|serial_ports
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|serial_dev_init
r_static
r_int
id|__init
id|serial_dev_init
c_func
(paren
r_void
)paren
(brace
r_return
id|platform_device_register
c_func
(paren
op_amp
id|serial_device
)paren
suffix:semicolon
)brace
DECL|variable|serial_dev_init
id|arch_initcall
c_func
(paren
id|serial_dev_init
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPC_ISERIES */
DECL|function|check_legacy_ioport
r_int
id|check_legacy_ioport
c_func
(paren
r_int
r_int
id|base_port
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.check_legacy_ioport
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ppc_md
dot
id|check_legacy_ioport
c_func
(paren
id|base_port
)paren
suffix:semicolon
)brace
DECL|variable|check_legacy_ioport
id|EXPORT_SYMBOL
c_func
(paren
id|check_legacy_ioport
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_XMON
DECL|function|early_xmon
r_static
r_int
id|__init
id|early_xmon
c_func
(paren
r_char
op_star
id|p
)paren
(brace
multiline_comment|/* ensure xmon is enabled */
id|xmon_init
c_func
(paren
)paren
suffix:semicolon
id|debugger
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|early_param
c_func
(paren
l_string|&quot;xmon&quot;
comma
id|early_xmon
)paren
suffix:semicolon
macro_line|#endif
DECL|function|cpu_die
r_void
id|cpu_die
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.cpu_die
)paren
id|ppc_md
dot
id|cpu_die
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
eof
