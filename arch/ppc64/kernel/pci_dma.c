multiline_comment|/*&n; * pci_dma.c&n; * Copyright (C) 2001 Mike Corrigan &amp; Dave Engebretsen, IBM Corporation&n; *&n; * Dynamic DMA mapping support.&n; * &n; * Manages the TCE space assigned to this partition.&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/pci_dma.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_pci.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &quot;pci.h&quot;
singleline_comment|// #define DEBUG_TCE 1
multiline_comment|/* Initialize so this guy does not end up in the BSS section.&n; * Only used to pass OF initialization data set in prom.c into the main &n; * kernel code -- data ultimately copied into tceTables[].&n; */
r_extern
r_struct
id|_of_tce_table
id|of_tce_table
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|pci_controller
op_star
id|hose_head
suffix:semicolon
r_extern
r_struct
id|pci_controller
op_star
op_star
id|hose_tail
suffix:semicolon
DECL|variable|virtBusVethTceTable
r_struct
id|TceTable
id|virtBusVethTceTable
suffix:semicolon
multiline_comment|/* Tce table for virtual ethernet */
DECL|variable|virtBusVioTceTable
r_struct
id|TceTable
id|virtBusVioTceTable
suffix:semicolon
multiline_comment|/* Tce table for virtual I/O */
DECL|variable|iSeries_veth_dev_node
r_struct
id|device_node
id|iSeries_veth_dev_node
op_assign
(brace
id|tce_table
suffix:colon
op_amp
id|virtBusVethTceTable
)brace
suffix:semicolon
DECL|variable|iSeries_vio_dev_node
r_struct
id|device_node
id|iSeries_vio_dev_node
op_assign
(brace
id|tce_table
suffix:colon
op_amp
id|virtBusVioTceTable
)brace
suffix:semicolon
DECL|variable|iSeries_veth_dev_st
r_struct
id|pci_dev
id|iSeries_veth_dev_st
op_assign
(brace
id|sysdata
suffix:colon
op_amp
id|iSeries_veth_dev_node
)brace
suffix:semicolon
DECL|variable|iSeries_vio_dev_st
r_struct
id|pci_dev
id|iSeries_vio_dev_st
op_assign
(brace
id|sysdata
suffix:colon
op_amp
id|iSeries_vio_dev_node
)brace
suffix:semicolon
DECL|variable|iSeries_veth_dev
r_struct
id|pci_dev
op_star
id|iSeries_veth_dev
op_assign
op_amp
id|iSeries_veth_dev_st
suffix:semicolon
DECL|variable|iSeries_vio_dev
r_struct
id|pci_dev
op_star
id|iSeries_vio_dev
op_assign
op_amp
id|iSeries_vio_dev_st
suffix:semicolon
DECL|variable|tceTables
r_struct
id|TceTable
op_star
id|tceTables
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* Tce tables for 256 busses&n;&t;&t;&t;&t;&t; * Bus 255 is the virtual bus&n;&t;&t;&t;&t;&t; * zero indicates no bus defined&n;&t;&t;&t;&t;&t; */
multiline_comment|/* allocates a contiguous range of tces (power-of-2 size) */
r_static
r_inline
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* allocates a contiguous range of tces (power-of-2 size)&n; * assumes lock already held&n; */
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* frees a contiguous range of tces (power-of-2 size) */
r_static
r_inline
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* frees a contiguous rnage of tces (power-of-2 size)&n; * assumes lock already held&n; */
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* allocates a range of tces and sets them to the pages  */
r_static
r_inline
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|direction
)paren
suffix:semicolon
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
r_static
r_int
id|fill_scatterlist_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
id|dma_addr_t
id|dma_addr
comma
r_int
r_int
id|numTces
)paren
suffix:semicolon
r_static
r_int
r_int
id|num_tces_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
suffix:semicolon
r_static
id|dma_addr_t
id|create_tces_sg
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|numTces
comma
r_int
id|direction
)paren
suffix:semicolon
r_static
r_void
id|getTceTableParmsPSeries
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|tce_table_parms
)paren
suffix:semicolon
r_static
r_void
id|getTceTableParmsPSeriesLP
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
suffix:semicolon
r_void
id|create_pci_bus_tce_table
c_func
(paren
r_int
r_int
id|token
)paren
suffix:semicolon
DECL|function|iSeries_Get_Bus
id|u8
id|iSeries_Get_Bus
c_func
(paren
r_struct
id|pci_dev
op_star
id|dv
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_tce_table
r_static
r_inline
r_struct
id|TceTable
op_star
id|get_tce_table
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|ppc64_isabridge_dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_ISERIES_LPAR
)paren
op_logical_and
(paren
id|dev-&gt;bus
)paren
)paren
r_return
id|tceTables
(braket
id|dev-&gt;bus-&gt;number
)braket
suffix:semicolon
multiline_comment|/* On the iSeries, the virtual bus will take this path.  There is a */
multiline_comment|/* fake pci_dev and dev_node built and used.                        */
r_return
id|PCI_GET_DN
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|tce_table
suffix:semicolon
)brace
DECL|function|count_leading_zeros64
r_static
r_int
r_int
id|__inline__
id|count_leading_zeros64
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|lz
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;cntlzd %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lz
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|x
)paren
)paren
suffix:semicolon
r_return
id|lz
suffix:semicolon
)brace
DECL|function|tce_build_iSeries
r_static
r_void
id|tce_build_iSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
r_int
id|uaddr
comma
r_int
id|direction
)paren
(brace
id|u64
id|setTceRc
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;build_tce: uaddr = 0x%lx&bslash;n&quot;
comma
id|uaddr
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum = 0x%lx, tbl = 0x%lx, index=%lx&bslash;n&quot;
comma
id|tcenum
comma
id|tbl
comma
id|tbl-&gt;index
)paren
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce.tceBits.rpn
op_assign
(paren
id|virt_to_absolute
c_func
(paren
id|uaddr
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* If for virtual bus */
r_if
c_cond
(paren
id|tbl-&gt;tceType
op_eq
id|TCE_VB
)paren
(brace
id|tce.tceBits.valid
op_assign
l_int|1
suffix:semicolon
id|tce.tceBits.allIo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If for PCI bus */
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Read allowed 
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.pciWrite
op_assign
l_int|1
suffix:semicolon
)brace
id|setTceRc
op_assign
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setTceRc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: tce_build failed 0x%lx tcenum: 0x%lx&bslash;n&quot;
comma
id|setTceRc
comma
(paren
id|u64
)paren
id|tcenum
)paren
suffix:semicolon
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;setTce failed. rc=%ld&bslash;n&quot;, setTceRc);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;tindex   = 0x%lx&bslash;n&quot;, (u64)tbl-&gt;index);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;ttce num = 0x%lx&bslash;n&quot;, (u64)tcenum);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;ttce val = 0x%lx&bslash;n&quot;, tce.wholeTce );
)brace
)brace
DECL|function|tce_build_pSeries
r_static
r_void
id|tce_build_pSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
r_int
id|uaddr
comma
r_int
id|direction
)paren
(brace
r_union
id|Tce
id|tce
suffix:semicolon
r_union
id|Tce
op_star
id|tce_addr
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;build_tce: uaddr = 0x%lx&bslash;n&quot;
comma
id|uaddr
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum = 0x%lx, tbl = 0x%lx, index=%lx&bslash;n&quot;
comma
id|tcenum
comma
id|tbl
comma
id|tbl-&gt;index
)paren
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce.tceBits.rpn
op_assign
(paren
id|virt_to_absolute
c_func
(paren
id|uaddr
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Read allowed 
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.pciWrite
op_assign
l_int|1
suffix:semicolon
id|tce_addr
op_assign
(paren
(paren
r_union
id|Tce
op_star
)paren
id|tbl-&gt;base
)paren
op_plus
id|tcenum
suffix:semicolon
op_star
id|tce_addr
op_assign
(paren
r_union
id|Tce
)paren
id|tce.wholeTce
suffix:semicolon
multiline_comment|/* Make sure the update is visible to hardware. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Build a TceTable structure.  This contains a multi-level bit map which&n; * is used to manage allocation of the tce space.&n; */
DECL|function|build_tce_table
r_static
r_struct
id|TceTable
op_star
id|build_tce_table
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
)paren
(brace
r_int
r_int
id|bits
comma
id|bytes
comma
id|totalBytes
suffix:semicolon
r_int
r_int
id|numBits
(braket
id|NUM_TCE_LEVELS
)braket
comma
id|numBytes
(braket
id|NUM_TCE_LEVELS
)braket
suffix:semicolon
r_int
id|i
comma
id|k
comma
id|m
suffix:semicolon
r_int
r_char
op_star
id|pos
comma
op_star
id|p
comma
id|b
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: tbl = 0x%lx&bslash;n&quot;
comma
id|tbl
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
)paren
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute number of bits and bytes for each level of the&n;&t; * multi-level bit map&n;&t; */
id|totalBytes
op_assign
l_int|0
suffix:semicolon
id|bits
op_assign
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bytes
op_assign
(paren
(paren
id|bits
op_plus
l_int|63
)paren
op_div
l_int|64
)paren
op_star
l_int|8
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: level %d bits=%ld, bytes=%ld&bslash;n&quot;
comma
id|i
comma
id|bits
comma
id|bytes
)paren
suffix:semicolon
id|numBits
(braket
id|i
)braket
op_assign
id|bits
suffix:semicolon
id|numBytes
(braket
id|i
)braket
op_assign
id|bytes
suffix:semicolon
id|bits
op_div_assign
l_int|2
suffix:semicolon
id|totalBytes
op_add_assign
id|bytes
suffix:semicolon
)brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: totalBytes=%ld&bslash;n&quot;
comma
id|totalBytes
)paren
suffix:semicolon
id|pos
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|totalBytes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pos
comma
l_int|0
comma
id|totalBytes
)paren
suffix:semicolon
multiline_comment|/* For each level, fill in the pointer to the bit map,&n;&t; * and turn on the last bit in the bit map (if the&n;&t; * number of bits in the map is odd).  The highest&n;&t; * level will get all of its bits turned on.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|numBytes
(braket
id|i
)braket
)paren
(brace
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
id|pos
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|numBits
(braket
id|i
)braket
op_amp
l_int|1
)paren
(brace
id|p
op_assign
id|pos
op_plus
id|numBytes
(braket
id|i
)braket
op_minus
l_int|1
suffix:semicolon
id|m
op_assign
(paren
(paren
id|numBits
(braket
id|i
)braket
op_mod
l_int|8
)paren
op_minus
l_int|1
)paren
op_amp
l_int|7
suffix:semicolon
op_star
id|p
op_assign
l_int|0x80
op_rshift
id|m
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: level %d last bit %x&bslash;n&quot;
comma
id|i
comma
l_int|0x80
op_rshift
id|m
)paren
suffix:semicolon
)brace
)brace
r_else
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
l_int|0
suffix:semicolon
id|pos
op_add_assign
id|numBytes
(braket
id|i
)braket
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBits
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBytes
op_assign
id|numBytes
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* For the highest level, turn on all the bits */
id|i
op_assign
id|tbl-&gt;mlbm.maxLevel
suffix:semicolon
id|p
op_assign
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
suffix:semicolon
id|m
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: highest level (%d) has all bits set&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|numBytes
(braket
id|i
)braket
suffix:semicolon
op_increment
id|k
)paren
(brace
r_if
c_cond
(paren
id|m
op_ge
l_int|8
)paren
(brace
multiline_comment|/* handle full bytes */
op_star
id|p
op_increment
op_assign
l_int|0xff
suffix:semicolon
id|m
op_sub_assign
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m
OG
l_int|0
)paren
(brace
multiline_comment|/* handle the last partial byte */
id|b
op_assign
l_int|0x80
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|m
)paren
(brace
op_star
id|p
op_or_assign
id|b
suffix:semicolon
id|b
op_rshift_assign
l_int|1
suffix:semicolon
op_decrement
id|m
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|tbl
suffix:semicolon
)brace
DECL|function|alloc_tce_range
r_static
r_inline
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Lock the tce allocation bitmap */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do the actual work */
id|retval
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
multiline_comment|/* Unlock the tce allocation bitmap */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|alloc_tce_range_nolock
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|numBits
comma
id|numBytes
suffix:semicolon
r_int
r_int
id|i
comma
id|bit
comma
id|block
comma
id|mask
suffix:semicolon
r_int
id|tcenum
suffix:semicolon
id|u64
op_star
id|map
suffix:semicolon
multiline_comment|/* If the order (power of 2 size) requested is larger than our&n;&t; * biggest, indicate failure&n;&t; */
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: invalid order: %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|numBits
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
suffix:semicolon
id|numBytes
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBytes
suffix:semicolon
id|map
op_assign
(paren
id|u64
op_star
)paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
multiline_comment|/* Initialize return value to -1 (failure) */
id|tcenum
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Loop through the bytes of the bitmap */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numBytes
op_div
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_star
id|map
)paren
(brace
multiline_comment|/* A free block is found, compute the block&n;&t;&t;&t; * number (of this size)&n;&t;&t;&t; */
id|bit
op_assign
id|count_leading_zeros64
c_func
(paren
op_star
id|map
)paren
suffix:semicolon
id|block
op_assign
(paren
id|i
op_star
l_int|64
)paren
op_plus
id|bit
suffix:semicolon
multiline_comment|/* turn off the bit in the map to indicate&n;&t;&t;&t; * that the block is now in use&n;&t;&t;&t; */
id|mask
op_assign
l_int|0x1UL
op_lshift
(paren
l_int|63
op_minus
id|bit
)paren
suffix:semicolon
op_star
id|map
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* compute the index into our tce table for&n;&t;&t;&t; * the first tce in the block&n;&t;&t;&t; */
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: allocating block %ld, (byte=%ld, bit=%ld) order %d&bslash;n&quot;
comma
id|block
comma
id|i
comma
id|bit
comma
id|order
)paren
suffix:semicolon
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
r_return
id|tcenum
suffix:semicolon
)brace
op_increment
id|map
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TCE
r_if
c_cond
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: no available blocks of order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: trying next bigger size&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: maximum size reached...failing&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/* If no block of the requested size was found, try the next&n;&t; * size bigger.  If one of those is found, return the second&n;&t; * half of the block to freespace and keep the first half&n;&t; */
r_if
c_cond
(paren
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|order
OL
(paren
id|NUM_TCE_LEVELS
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|tcenum
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
id|order
)paren
comma
id|order
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Return the index of the first tce in the block&n;&t; * (or -1 if we failed)&n;&t; */
r_return
id|tcenum
suffix:semicolon
)brace
DECL|function|free_tce_range
r_static
r_inline
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Lock the tce allocation bitmap */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do the actual work */
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
multiline_comment|/* Unlock the tce allocation bitmap */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|free_tce_range_nolock
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
r_char
op_star
id|map
comma
op_star
id|bytep
suffix:semicolon
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: invalid order: %d, tcenum = %d&bslash;n&quot;
comma
id|order
comma
id|tcenum
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
r_if
c_cond
(paren
id|tcenum
op_ne
(paren
id|block
op_lshift
id|order
)paren
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: tcenum %lx misaligned for order %x&bslash;n&quot;
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block
op_ge
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: tcenum %lx is outside the range of this map (order %x, numBits %lx&bslash;n&quot;
comma
id|tcenum
comma
id|order
comma
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: freeing range not allocated.&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tTceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
)brace
macro_line|#endif
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|bytep
op_assign
id|map
op_plus
id|byte
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range_nolock: freeing block %ld (byte=%d, bit=%d) of order %d&bslash;n&quot;
comma
id|block
comma
id|byte
comma
id|bit
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bytep
op_amp
id|mask
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: already free: TceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
macro_line|#endif&t;
op_star
id|bytep
op_or_assign
id|mask
suffix:semicolon
multiline_comment|/* If there is a higher level in the bit map than this we may be&n;&t; * able to buddy up this block with its partner.&n;&t; *   If this is the highest level we can&squot;t buddy up&n;&t; *   If this level has an odd number of bits and&n;&t; *      we are freeing the last block we can&squot;t buddy up&n;&t; * Don&squot;t buddy up if it&squot;s in the first 1/4 of the level&n;&t; */
r_if
c_cond
(paren
(paren
id|block
OG
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_div
l_int|4
)paren
)paren
op_logical_and
(paren
(paren
id|block
OL
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_minus
l_int|1
)paren
op_logical_or
(paren
l_int|0
op_eq
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_amp
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* See if we can buddy up the block we just freed */
id|bit
op_and_assign
l_int|6
suffix:semicolon
multiline_comment|/* get to the first of the buddy bits */
id|mask
op_assign
l_int|0xc0
op_rshift
id|bit
suffix:semicolon
multiline_comment|/* build two bit mask */
id|b
op_assign
op_star
id|bytep
op_amp
id|mask
suffix:semicolon
multiline_comment|/* Get the two bits */
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|b
op_xor
id|mask
)paren
)paren
(brace
multiline_comment|/* If both bits are on */
multiline_comment|/* both of the buddy blocks are free we can combine them */
op_star
id|bytep
op_xor_assign
id|mask
suffix:semicolon
multiline_comment|/* turn off the two bits */
id|block
op_assign
(paren
id|byte
op_star
l_int|8
)paren
op_plus
id|bit
suffix:semicolon
multiline_comment|/* block of first of buddies */
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
multiline_comment|/* free the buddied block */
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: buddying blocks %ld &amp; %ld&bslash;n&quot;
comma
id|block
comma
id|block
op_plus
l_int|1
)paren
suffix:semicolon
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|test_tce_range
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
id|retval
comma
id|retLeft
comma
id|retRight
suffix:semicolon
r_int
r_char
op_star
id|map
suffix:semicolon
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
multiline_comment|/* Byte within bitmap */
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Bit within byte */
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|b
op_assign
(paren
op_star
(paren
id|map
op_plus
id|byte
)paren
op_amp
id|mask
)paren
suffix:semicolon
multiline_comment|/* 0 if block is allocated, else free */
r_if
c_cond
(paren
id|b
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 == block is free */
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 == block is allocated */
multiline_comment|/* Test bits at all levels below this to ensure that all agree */
r_if
c_cond
(paren
id|order
)paren
(brace
id|retLeft
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
id|retRight
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
(paren
id|order
op_minus
l_int|1
)paren
)paren
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retLeft
op_logical_or
id|retRight
)paren
(brace
id|retval
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* Test bits at all levels above this to ensure that all agree */
r_return
id|retval
suffix:semicolon
)brace
DECL|function|get_tces
r_static
r_inline
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|direction
)paren
(brace
r_int
id|tcenum
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|retTce
op_assign
id|NO_TCE
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|page
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* Allocate a range of tces */
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* We got the tces we wanted */
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
multiline_comment|/* Offset into real TCE table */
id|retTce
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Set the return dma address */
multiline_comment|/* Setup a tce for each page */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ppc_md
dot
id|tce_build
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|retTce
suffix:semicolon
)brace
DECL|function|tce_free_iSeries
r_static
r_void
id|tce_free_iSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|order
comma
r_int
id|numPages
)paren
(brace
id|u64
id|setTceRc
suffix:semicolon
r_int
id|tcenum
comma
id|freeTce
comma
id|maxTcenum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
id|maxTcenum
op_assign
(paren
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|tcenum
op_assign
id|dma_addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|freeTce
op_assign
id|tcenum
op_minus
id|tbl-&gt;startOffset
suffix:semicolon
r_if
c_cond
(paren
id|freeTce
OG
id|maxTcenum
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tces: tcenum &gt; maxTcenum&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum    = 0x%lx&bslash;n&quot;
comma
id|tcenum
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tmaxTcenum = 0x%lx&bslash;n&quot;
comma
id|maxTcenum
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tTCE Table = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tbus#      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;busNumber
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tsize      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;size
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tstartOff  = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tindex     = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|setTceRc
op_assign
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setTceRc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: tce_free failed 0x%lx tcenum: 0x%lx&bslash;n&quot;
comma
id|setTceRc
comma
(paren
id|u64
)paren
id|tcenum
)paren
suffix:semicolon
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;tce_free: setTce failed&bslash;n&quot;);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;trc      = 0x%lx&bslash;n&quot;, setTceRc);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;tindex   = 0x%lx&bslash;n&quot;, (u64)tbl-&gt;index);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;ttce num = 0x%lx&bslash;n&quot;, (u64)tcenum);
singleline_comment|//PPCDBG(PPCDBG_TCE, &quot;&bslash;ttce val = 0x%lx&bslash;n&quot;, tce.wholeTce );
)brace
op_increment
id|tcenum
suffix:semicolon
)brace
id|free_tce_range
c_func
(paren
id|tbl
comma
id|freeTce
comma
id|order
)paren
suffix:semicolon
)brace
DECL|function|tce_free_pSeries
r_static
r_void
id|tce_free_pSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|order
comma
r_int
id|numPages
)paren
(brace
r_int
id|tcenum
comma
id|freeTce
comma
id|maxTcenum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
r_union
id|Tce
op_star
id|tce_addr
suffix:semicolon
id|maxTcenum
op_assign
(paren
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|tcenum
op_assign
id|dma_addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
singleline_comment|// tcenum -= tbl-&gt;startOffset;
id|freeTce
op_assign
id|tcenum
op_minus
id|tbl-&gt;startOffset
suffix:semicolon
r_if
c_cond
(paren
id|freeTce
OG
id|maxTcenum
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tces: tcenum &gt; maxTcenum&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum    = 0x%lx&bslash;n&quot;
comma
id|tcenum
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tmaxTcenum = 0x%lx&bslash;n&quot;
comma
id|maxTcenum
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tTCE Table = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tbus#      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;busNumber
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tsize      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;size
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tstartOff  = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tindex     = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce_addr
op_assign
(paren
(paren
r_union
id|Tce
op_star
)paren
id|tbl-&gt;base
)paren
op_plus
id|tcenum
suffix:semicolon
op_star
id|tce_addr
op_assign
(paren
r_union
id|Tce
)paren
id|tce.wholeTce
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
)brace
multiline_comment|/* Make sure the update is visible to hardware. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|free_tce_range
c_func
(paren
id|tbl
comma
id|freeTce
comma
id|order
)paren
suffix:semicolon
)brace
DECL|function|create_virtual_bus_tce_table
r_void
id|__init
id|create_virtual_bus_tce_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|TceTable
op_star
id|t
suffix:semicolon
r_struct
id|TceTableManagerCB
id|virtBusTceTableParms
suffix:semicolon
id|u64
id|absParmsPtr
suffix:semicolon
id|virtBusTceTableParms.busNumber
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* Bus 255 is the virtual bus */
id|virtBusTceTableParms.virtualBusFlag
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Ask for virtual bus */
id|absParmsPtr
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u64
)paren
op_amp
id|virtBusTceTableParms
)paren
suffix:semicolon
id|HvCallXm_getTceTableParms
c_func
(paren
id|absParmsPtr
)paren
suffix:semicolon
id|virtBusVethTceTable.size
op_assign
id|virtBusTceTableParms.size
op_div
l_int|2
suffix:semicolon
id|virtBusVethTceTable.busNumber
op_assign
id|virtBusTceTableParms.busNumber
suffix:semicolon
id|virtBusVethTceTable.startOffset
op_assign
id|virtBusTceTableParms.startOffset
suffix:semicolon
id|virtBusVethTceTable.index
op_assign
id|virtBusTceTableParms.index
suffix:semicolon
id|virtBusVethTceTable.tceType
op_assign
id|TCE_VB
suffix:semicolon
id|virtBusVioTceTable.size
op_assign
id|virtBusTceTableParms.size
op_minus
id|virtBusVethTceTable.size
suffix:semicolon
id|virtBusVioTceTable.busNumber
op_assign
id|virtBusTceTableParms.busNumber
suffix:semicolon
id|virtBusVioTceTable.startOffset
op_assign
id|virtBusTceTableParms.startOffset
op_plus
id|virtBusVethTceTable.size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
suffix:semicolon
id|virtBusVioTceTable.index
op_assign
id|virtBusTceTableParms.index
suffix:semicolon
id|virtBusVioTceTable.tceType
op_assign
id|TCE_VB
suffix:semicolon
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|virtBusVethTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|tceTables
(braket
l_int|255
)braket
op_assign
id|t
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VETH TCE table built successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VETH TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|virtBusVioTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VIO TCE table built successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VIO TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|create_tce_tables_for_buses
r_void
id|create_tce_tables_for_buses
c_func
(paren
r_struct
id|list_head
op_star
id|bus_list
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
comma
op_star
id|first_dn
suffix:semicolon
r_int
id|num_slots
comma
id|num_slots_ilog2
suffix:semicolon
r_int
id|first_phb
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|phb
op_assign
id|hose_head
suffix:semicolon
id|phb
suffix:semicolon
id|phb
op_assign
id|phb-&gt;next
)paren
(brace
id|first_dn
op_assign
(paren
(paren
r_struct
id|device_node
op_star
)paren
id|phb-&gt;arch_data
)paren
op_member_access_from_pointer
id|child
suffix:semicolon
multiline_comment|/* Carve 2GB into the largest dma_window_size possible */
r_for
c_loop
(paren
id|dn
op_assign
id|first_dn
comma
id|num_slots
op_assign
l_int|0
suffix:semicolon
id|dn
op_ne
l_int|NULL
suffix:semicolon
id|dn
op_assign
id|dn-&gt;sibling
)paren
id|num_slots
op_increment
suffix:semicolon
id|num_slots_ilog2
op_assign
id|__ilog2
c_func
(paren
id|num_slots
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|num_slots_ilog2
)paren
op_ne
id|num_slots
)paren
id|num_slots_ilog2
op_increment
suffix:semicolon
id|phb-&gt;dma_window_size
op_assign
l_int|1
op_lshift
(paren
l_int|22
op_minus
id|num_slots_ilog2
)paren
suffix:semicolon
multiline_comment|/* Reserve 16MB of DMA space on the first PHB.&n;&t;&t; * We should probably be more careful and use firmware props.&n;&t;&t; * In reality this space is remapped, not lost.  But we don&squot;t&n;&t;&t; * want to get that smart to handle it -- too much work.&n;&t;&t; */
id|phb-&gt;dma_window_base_cur
op_assign
id|first_phb
ques
c_cond
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:colon
l_int|0
suffix:semicolon
id|first_phb
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dn
op_assign
id|first_dn
comma
id|num_slots
op_assign
l_int|0
suffix:semicolon
id|dn
op_ne
l_int|NULL
suffix:semicolon
id|dn
op_assign
id|dn-&gt;sibling
)paren
(brace
id|create_pci_bus_tce_table
c_func
(paren
(paren
r_int
r_int
)paren
id|dn
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|create_tce_tables_for_busesLP
r_void
id|create_tce_tables_for_busesLP
c_func
(paren
r_struct
id|list_head
op_star
id|bus_list
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device_node
op_star
id|busdn
suffix:semicolon
id|u32
op_star
id|dma_window
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|bus_list-&gt;next
suffix:semicolon
id|ln
op_ne
id|bus_list
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|bus
op_assign
id|pci_bus_b
c_func
(paren
id|ln
)paren
suffix:semicolon
id|busdn
op_assign
id|PCI_GET_DN
c_func
(paren
id|bus
)paren
suffix:semicolon
multiline_comment|/* NOTE: there should never be a window declared on a bus when&n;&t;&t; * child devices also have a window.  If this should ever be&n;&t;&t; * architected, we probably want children to have priority.&n;&t;&t; * In reality, the PHB containing ISA has the property, but otherwise&n;&t;&t; * it is the pci-bridges that have the property.&n;&t;&t; */
id|dma_window
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|busdn
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_window
)paren
(brace
multiline_comment|/* Busno hasn&squot;t been copied yet.&n;&t;&t;&t; * Do it now because getTceTableParmsPSeriesLP needs it.&n;&t;&t;&t; */
id|busdn-&gt;busno
op_assign
id|bus-&gt;number
suffix:semicolon
id|create_pci_bus_tce_table
c_func
(paren
(paren
r_int
r_int
)paren
id|busdn
)paren
suffix:semicolon
)brace
r_else
id|create_tce_tables_for_busesLP
c_func
(paren
op_amp
id|bus-&gt;children
)paren
suffix:semicolon
)brace
)brace
DECL|function|create_tce_tables
r_void
id|create_tce_tables
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
comma
op_star
id|mydn
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
)paren
id|create_tce_tables_for_busesLP
c_func
(paren
op_amp
id|pci_root_buses
)paren
suffix:semicolon
r_else
id|create_tce_tables_for_buses
c_func
(paren
op_amp
id|pci_root_buses
)paren
suffix:semicolon
multiline_comment|/* Now copy the tce_table ptr from the bus devices down to every&n;&t; * pci device_node.  This means get_tce_table() won&squot;t need to search&n;&t; * up the device tree to find it.&n;&t; */
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|mydn
op_assign
id|dn
op_assign
id|PCI_GET_DN
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dn
op_logical_and
id|dn-&gt;tce_table
op_eq
l_int|NULL
)paren
id|dn
op_assign
id|dn-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|dn
)paren
(brace
id|mydn-&gt;tce_table
op_assign
id|dn-&gt;tce_table
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * iSeries token = busNumber &n; * pSeries token = pci_controller*&n; */
DECL|function|create_pci_bus_tce_table
r_void
id|create_pci_bus_tce_table
c_func
(paren
r_int
r_int
id|token
)paren
(brace
r_struct
id|TceTable
op_star
id|builtTceTable
suffix:semicolon
r_struct
id|TceTable
op_star
id|newTceTable
suffix:semicolon
r_struct
id|TceTableManagerCB
id|pciBusTceTableParms
suffix:semicolon
id|u64
id|parmsPtr
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;Entering create_pci_bus_tce_table.&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttoken = 0x%lx&bslash;n&quot;
comma
id|token
)paren
suffix:semicolon
id|newTceTable
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|TceTable
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_ISERIES_LPAR
)paren
(brace
r_if
c_cond
(paren
id|token
OG
l_int|254
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: Bus TCE table failed, invalid bus number %lu&bslash;n&quot;
comma
id|token
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pciBusTceTableParms.busNumber
op_assign
id|token
suffix:semicolon
id|pciBusTceTableParms.virtualBusFlag
op_assign
l_int|0
suffix:semicolon
id|parmsPtr
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u64
)paren
op_amp
id|pciBusTceTableParms
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Call HV with the architected data structure to get TCE table&n;&t;&t; * info. Put the returned data into the Linux representation&n;&t;&t; * of the TCE table data.&n;&t;&t; */
id|HvCallXm_getTceTableParms
c_func
(paren
id|parmsPtr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: getTceTableParms: Bus: 0x%lx Size: 0x%lx, Start: 0x%lx, Index: 0x%lx&bslash;n&quot;
comma
id|pciBusTceTableParms.busNumber
comma
id|pciBusTceTableParms.size
comma
id|pciBusTceTableParms.startOffset
comma
id|pciBusTceTableParms.index
)paren
suffix:semicolon
multiline_comment|/* Determine if the table identified by the index and startOffset      */
multiline_comment|/* returned by the hypervisor for this bus has already been created.   */
multiline_comment|/* If so, set the tceTable entry to point to the linux shared tceTable.*/
r_int
id|BusIndex
suffix:semicolon
r_for
c_loop
(paren
id|BusIndex
op_assign
l_int|0
suffix:semicolon
id|BusIndex
OL
l_int|255
suffix:semicolon
op_increment
id|BusIndex
)paren
(brace
r_if
c_cond
(paren
id|tceTables
(braket
id|BusIndex
)braket
op_ne
l_int|NULL
)paren
(brace
r_struct
id|TceTable
op_star
id|CmprTceTable
op_assign
id|tceTables
(braket
id|BusIndex
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|CmprTceTable-&gt;index
op_eq
id|pciBusTceTableParms.index
)paren
op_logical_and
(paren
id|CmprTceTable-&gt;startOffset
op_eq
id|pciBusTceTableParms.startOffset
)paren
)paren
(brace
id|tceTables
(braket
id|token
)braket
op_assign
id|CmprTceTable
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Bus %lu Shares a TCE table with bus %d&bslash;n&quot;
comma
id|token
comma
id|BusIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* No shared table, build a new table for this bus. */
r_if
c_cond
(paren
id|tceTables
(braket
id|token
)braket
op_eq
l_int|NULL
)paren
(brace
id|newTceTable-&gt;size
op_assign
id|pciBusTceTableParms.size
suffix:semicolon
id|newTceTable-&gt;busNumber
op_assign
id|pciBusTceTableParms.busNumber
suffix:semicolon
id|newTceTable-&gt;startOffset
op_assign
id|pciBusTceTableParms.startOffset
suffix:semicolon
id|newTceTable-&gt;index
op_assign
id|pciBusTceTableParms.index
suffix:semicolon
id|builtTceTable
op_assign
id|build_tce_table
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
id|builtTceTable-&gt;tceType
op_assign
id|TCE_PCI
suffix:semicolon
id|tceTables
(braket
id|token
)braket
op_assign
id|builtTceTable
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We&squot;re using the shared table, not this new one. */
id|kfree
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PCI: Pci bus %lu TceTable: %p&bslash;n&quot;
comma
id|token
comma
id|tceTables
(braket
id|token
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
id|dn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|token
suffix:semicolon
id|phb
op_assign
id|dn-&gt;phb
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_PSERIES
)paren
id|getTceTableParmsPSeries
c_func
(paren
id|phb
comma
id|dn
comma
id|newTceTable
)paren
suffix:semicolon
r_else
id|getTceTableParmsPSeriesLP
c_func
(paren
id|phb
comma
id|dn
comma
id|newTceTable
)paren
suffix:semicolon
id|builtTceTable
op_assign
id|build_tce_table
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
id|dn-&gt;tce_table
op_assign
id|builtTceTable
suffix:semicolon
)brace
r_if
c_cond
(paren
id|builtTceTable
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;PCI Bus TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|getTceTableParmsPSeries
r_static
r_void
id|getTceTableParmsPSeries
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|node
op_assign
(paren
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|phb-&gt;arch_data
)paren
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;getTceTableParms: start&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table = 0x%lx&bslash;n&quot;
comma
id|of_tce_table
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb          = 0x%lx&bslash;n&quot;
comma
id|phb
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn           = 0x%lx&bslash;n&quot;
comma
id|dn
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn-&gt;name     = %s&bslash;n&quot;
comma
id|dn-&gt;name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn-&gt;full_name= %s&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable  = 0x%lx&bslash;n&quot;
comma
id|newTceTable
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdma_window_size = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;dma_window_size
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].node = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|node
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].base = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].size = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|size
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;arch_data-&gt;node = 0x%lx&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
op_eq
id|node
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|of_tce_table
(braket
id|i
)braket
dot
id|base
comma
l_int|0
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|newTceTable-&gt;busNumber
op_assign
id|phb-&gt;bus-&gt;number
suffix:semicolon
multiline_comment|/* Units of tce entries.                        */
id|newTceTable-&gt;startOffset
op_assign
id|phb-&gt;dma_window_base_cur
suffix:semicolon
multiline_comment|/* Adjust the current table offset to the next  */
multiline_comment|/* region.  Measured in TCE entries. Force an   */
multiline_comment|/* alignment to the size alloted per IOA. This  */
multiline_comment|/* makes it easier to remove the 1st 16MB.      */
id|phb-&gt;dma_window_base_cur
op_add_assign
(paren
id|phb-&gt;dma_window_size
op_rshift
l_int|3
)paren
suffix:semicolon
id|phb-&gt;dma_window_base_cur
op_and_assign
op_complement
(paren
(paren
id|phb-&gt;dma_window_size
op_rshift
l_int|3
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the tce table size - measured in units   */
multiline_comment|/* of pages of tce table.                       */
id|newTceTable-&gt;size
op_assign
(paren
(paren
id|phb-&gt;dma_window_base_cur
op_minus
id|newTceTable-&gt;startOffset
)paren
op_lshift
l_int|3
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Test if we are going over 2GB of DMA space.  */
r_if
c_cond
(paren
id|phb-&gt;dma_window_base_cur
OG
(paren
l_int|1
op_lshift
l_int|19
)paren
)paren
(brace
id|udbg_printf
c_func
(paren
l_string|&quot;Unexpected number of IOAs under this PHB&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Unexpected number of IOAs under this PHB&quot;
)paren
suffix:semicolon
)brace
id|newTceTable-&gt;base
op_assign
id|of_tce_table
(braket
id|i
)braket
dot
id|base
suffix:semicolon
id|newTceTable-&gt;index
op_assign
l_int|0
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;base        = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;base
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;startOffset = 0x%lx&quot;
l_string|&quot;(# tce entries)&bslash;n&quot;
comma
id|newTceTable-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;size        = 0x%lx&quot;
l_string|&quot;(# pages of tce table)&bslash;n&quot;
comma
id|newTceTable-&gt;size
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * getTceTableParmsPSeriesLP&n; *&n; * Function: On pSeries LPAR systems, return TCE table info, given a pci bus.&n; *&n; * ToDo: properly interpret the ibm,dma-window property.  The definition is:&n; *&t;logical-bus-number&t;(1 word)&n; *&t;phys-address&t;&t;(#address-cells words)&n; *&t;size&t;&t;&t;(#cell-size words)&n; *&n; * Currently we hard code these sizes (more or less).&n; */
DECL|function|getTceTableParmsPSeriesLP
r_static
r_void
id|getTceTableParmsPSeriesLP
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
id|u32
op_star
id|dma_window
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_window
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;getTceTableParmsPSeriesLP:  device %s has no ibm,dma-window property!&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
)brace
id|newTceTable-&gt;busNumber
op_assign
id|dn-&gt;busno
suffix:semicolon
id|newTceTable-&gt;size
op_assign
(paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|4
)braket
op_lshift
l_int|32
)paren
op_or
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|5
)braket
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_lshift
l_int|3
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|newTceTable-&gt;startOffset
op_assign
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|2
)braket
op_lshift
l_int|32
)paren
op_or
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|3
)braket
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|newTceTable-&gt;base
op_assign
l_int|0
suffix:semicolon
id|newTceTable-&gt;index
op_assign
id|dma_window
(braket
l_int|0
)braket
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;getTceTableParmsPSeriesLP for bus 0x%lx:&bslash;n&quot;
comma
id|dn-&gt;busno
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tDevice = %s&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;index       = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;index
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;startOffset = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;size        = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;size
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocates a contiguous real buffer and creates TCEs over it.&n; * Returns the virtual address of the buffer and sets dma_handle&n; * to the dma address (tce) of the first page.&n; */
DECL|function|pci_alloc_consistent
r_void
op_star
id|pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_void
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|dma_addr_t
id|tce
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev      = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tsize       = 0x%16.16lx&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tdma_handle = 0x%16.16lx&bslash;n&quot;
comma
id|dma_handle
)paren
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
multiline_comment|/* Alloc enough pages (and possibly more) */
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* Page allocation succeeded */
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|nPages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Set up tces to cover the allocated range */
id|tce
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|ret
comma
id|nPages
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tce
op_eq
id|NO_TCE
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: get_tces failed&bslash;n&quot;
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ret
comma
id|order
)paren
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|dma_handle
op_assign
id|tce
suffix:semicolon
)brace
)brace
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: __get_free_pages failed for order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: get_tce_table failed for 0x%016lx&bslash;n&quot;
comma
id|hwdev
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tpci_alloc_consistent: dma_handle = 0x%16.16lx&bslash;n&quot;
comma
op_star
id|dma_handle
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tpci_alloc_consistent: return     = 0x%16.16lx&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pci_free_consistent
r_void
id|pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_free_consistent:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, dma_handle = 0x%16.16lx, vaddr = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|dma_handle
comma
id|vaddr
)paren
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_if
c_cond
(paren
id|order
OG
l_int|10
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_free_consistent: order=%d, size=%d, nPages=%d, dma_handle=%016lx, vaddr=%016lx&bslash;n&quot;
comma
id|order
comma
id|size
comma
id|nPages
comma
(paren
r_int
r_int
)paren
id|dma_handle
comma
(paren
r_int
r_int
)paren
id|vaddr
)paren
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|ppc_md
dot
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|order
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Creates TCEs for a user provided buffer.  The user buffer must be &n; * contiguous real kernel storage (not vmalloc).  The address of the buffer&n; * passed here is the kernel (virtual) address of the buffer.  The buffer&n; * need not be page aligned, the dma_addr_t returned will point to the same&n; * byte within the page as vaddr.&n; */
DECL|function|pci_map_single
id|dma_addr_t
id|pci_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
id|dma_addr_t
id|dma_handle
op_assign
id|NO_TCE
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_map_single:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, direction = 0x%16.16lx, vaddr = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|direction
comma
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|vaddr
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|uaddr
op_plus
id|size
)paren
op_minus
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|dma_handle
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|vaddr
comma
id|nPages
comma
id|direction
)paren
suffix:semicolon
id|dma_handle
op_or_assign
(paren
id|uaddr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
)brace
r_return
id|dma_handle
suffix:semicolon
)brace
DECL|function|pci_unmap_single
r_void
id|pci_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_single:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, direction = 0x%16.16lx, dma_handle = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|direction
comma
id|dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|dma_handle
op_plus
id|size
)paren
op_minus
(paren
id|dma_handle
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|order
OG
l_int|10
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_single: order=%d, size=%d, nPages=%d, dma_handle=%016lx&bslash;n&quot;
comma
id|order
comma
id|size
comma
id|nPages
comma
(paren
r_int
r_int
)paren
id|dma_handle
)paren
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|ppc_md
dot
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Figure out how many TCEs are actually going to be required&n; * to map this scatterlist.  This code is not optimal.  It &n; * takes into account the case where entry n ends in the same&n; * page in which entry n+1 starts.  It does not handle the &n; * general case of entry n ending in the same page in which &n; * entry m starts.   &n; */
r_static
r_int
r_int
id|num_tces_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
r_int
id|nTces
comma
id|numPages
comma
id|startPage
comma
id|endPage
comma
id|prevEndPage
suffix:semicolon
r_int
id|i
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
id|nTces
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* Compute the starting page number and&n;&t;&t; * the ending page number for this entry&n;&t;&t; */
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Simple optimization: if the previous entry ended&n;&t;&t; * in the same page in which this entry starts&n;&t;&t; * then we can reduce the required pages by one.&n;&t;&t; * This matches assumptions in fill_scatterlist_sg and&n;&t;&t; * create_tces_sg&n;&t;&t; */
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
op_decrement
id|numPages
suffix:semicolon
id|nTces
op_add_assign
id|numPages
suffix:semicolon
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_return
id|nTces
suffix:semicolon
)brace
multiline_comment|/* Fill in the dma data in the scatterlist&n; * return the number of dma sg entries created&n; */
r_static
r_int
id|fill_scatterlist_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
id|dma_addr_t
id|dma_addr
comma
r_int
r_int
id|numTces
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
suffix:semicolon
id|u32
id|cur_start_dma
suffix:semicolon
r_int
r_int
id|cur_len_dma
comma
id|cur_end_virt
comma
id|uaddr
suffix:semicolon
r_int
id|num_dma_ents
suffix:semicolon
id|dma_sg
op_assign
id|sg
suffix:semicolon
id|num_dma_ents
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Process the first sg entry */
id|cur_start_dma
op_assign
id|dma_addr
op_plus
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
id|sg-&gt;length
suffix:semicolon
multiline_comment|/* cur_end_virt holds the address of the byte immediately after the&n;&t; * end of the current buffer.&n;&t; */
id|cur_end_virt
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|cur_len_dma
suffix:semicolon
multiline_comment|/* Later code assumes that unused sg-&gt;dma_address and sg-&gt;dma_length&n;&t; * fields will be zero.  Other archs seem to assume that the user&n;&t; * (device driver) guarantees that...I don&squot;t want to depend on that&n;&t; */
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Process the rest of the sg entries */
r_while
c_loop
(paren
op_decrement
id|nents
)paren
(brace
op_increment
id|sg
suffix:semicolon
multiline_comment|/* Clear possibly unused fields. Note: sg &gt;= dma_sg so&n;&t;&t; * this can&squot;t be clearing a field we&squot;ve already set&n;&t;&t; */
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check if it is possible to make this next entry&n;&t;&t; * contiguous (in dma space) with the previous entry.&n;&t;&t; */
multiline_comment|/* The entries can be contiguous in dma space if&n;&t;&t; * the previous entry ends immediately before the&n;&t;&t; * start of the current entry (in virtual space)&n;&t;&t; * or if the previous entry ends at a page boundary&n;&t;&t; * and the current entry starts at a page boundary.&n;&t;&t; */
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uaddr
op_ne
id|cur_end_virt
)paren
op_logical_and
(paren
(paren
(paren
id|uaddr
op_or
id|cur_end_virt
)paren
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
op_logical_or
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* This entry can not be contiguous in dma space.&n;&t;&t;&t; * save the previous dma entry and start a new one&n;&t;&t;&t; */
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
op_increment
id|dma_sg
suffix:semicolon
op_increment
id|num_dma_ents
suffix:semicolon
id|cur_start_dma
op_add_assign
id|cur_len_dma
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If the previous entry ends and this entry starts&n;&t;&t;&t; * in the same page then they share a tce.  In that&n;&t;&t;&t; * case don&squot;t bump cur_start_dma to the next page &n;&t;&t;&t; * in dma space.  This matches assumptions made in&n;&t;&t;&t; * num_tces_sg and create_tces_sg.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
id|cur_start_dma
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_else
id|cur_start_dma
op_assign
id|PAGE_ALIGN
c_func
(paren
id|cur_start_dma
op_plus
l_int|1
)paren
suffix:semicolon
id|cur_start_dma
op_add_assign
(paren
id|uaddr
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Accumulate the length of this entry for the next &n;&t;&t; * dma entry&n;&t;&t; */
id|cur_len_dma
op_add_assign
id|sg-&gt;length
suffix:semicolon
id|cur_end_virt
op_assign
id|uaddr
op_plus
id|sg-&gt;length
suffix:semicolon
)brace
multiline_comment|/* Fill in the last dma entry */
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
op_ne
id|numTces
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;fill_scatterlist_sg: numTces %ld, used tces %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_return
id|num_dma_ents
suffix:semicolon
)brace
multiline_comment|/* Call the hypervisor to create the TCE entries.&n; * return the number of TCEs created&n; */
r_static
id|dma_addr_t
id|create_tces_sg
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|numTces
comma
r_int
id|direction
)paren
(brace
r_int
id|order
comma
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|startPage
comma
id|endPage
comma
id|prevEndPage
comma
id|numPages
comma
id|uaddr
suffix:semicolon
r_int
id|tcenum
comma
id|starttcenum
suffix:semicolon
id|dma_addr_t
id|dmaAddr
suffix:semicolon
id|dmaAddr
op_assign
id|NO_TCE
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* allocate a block of tces */
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
id|starttcenum
op_assign
id|tcenum
suffix:semicolon
id|dmaAddr
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nents
suffix:semicolon
op_increment
id|j
)paren
(brace
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
multiline_comment|/* If the previous entry ended in the same page that&n;&t;&t;&t; * the current page starts then they share that&n;&t;&t;&t; * tce and we reduce the number of tces we need&n;&t;&t;&t; * by one.  This matches assumptions made in&n;&t;&t;&t; * num_tces_sg and fill_scatterlist_sg&n;&t;&t;&t; */
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
(brace
op_decrement
id|numPages
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ppc_md
dot
id|tce_build
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
op_ne
id|numTces
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;create_tces_sg: numTces %d, tces used %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
)paren
suffix:semicolon
)brace
r_return
id|dmaAddr
suffix:semicolon
)brace
r_int
id|pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|numTces
suffix:semicolon
r_int
id|num_dma
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_map_sg:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, sg = 0x%16.16lx, direction = 0x%16.16lx, nents = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|sg
comma
id|direction
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/* Fast path for a single entry scatterlist */
r_if
c_cond
(paren
id|nents
op_eq
l_int|1
)paren
(brace
id|sg-&gt;dma_address
op_assign
id|pci_map_single
c_func
(paren
id|hwdev
comma
id|sg-&gt;address
comma
id|sg-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
multiline_comment|/* Compute the number of tces required */
id|numTces
op_assign
id|num_tces_sg
c_func
(paren
id|sg
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/* Create the tces and get the dma address */
id|dma_handle
op_assign
id|create_tces_sg
c_func
(paren
id|tbl
comma
id|sg
comma
id|nents
comma
id|numTces
comma
id|direction
)paren
suffix:semicolon
multiline_comment|/* Fill in the dma scatterlist */
id|num_dma
op_assign
id|fill_scatterlist_sg
c_func
(paren
id|sg
comma
id|nents
comma
id|dma_handle
comma
id|numTces
)paren
suffix:semicolon
)brace
r_return
id|num_dma
suffix:semicolon
)brace
r_void
id|pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelms
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|numTces
comma
id|i
suffix:semicolon
id|dma_addr_t
id|dma_end_page
comma
id|dma_start_page
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_sg:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, sg = 0x%16.16lx, direction = 0x%16.16lx, nelms = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|sg
comma
id|direction
comma
id|nelms
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|dma_start_page
op_assign
id|sg-&gt;dma_address
op_amp
id|PAGE_MASK
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nelms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|k
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_length
)paren
(brace
id|dma_end_page
op_assign
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_address
op_plus
id|sg
(braket
id|k
)braket
dot
id|dma_length
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|numTces
op_assign
(paren
(paren
id|dma_end_page
op_minus
id|dma_start_page
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
OG
l_int|10
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_sg: order=%d, numTces=%d, nelms=%d, dma_start_page=%016lx, dma_end_page=%016lx&bslash;n&quot;
comma
id|order
comma
id|numTces
comma
id|nelms
comma
(paren
r_int
r_int
)paren
id|dma_start_page
comma
(paren
r_int
r_int
)paren
id|dma_end_page
)paren
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|ppc_md
dot
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_start_page
comma
id|order
comma
id|numTces
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|pci_map_sg
r_int
id|pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
id|page_address
c_func
(paren
id|sglist-&gt;page
)paren
op_plus
id|sglist-&gt;offset
)paren
suffix:semicolon
id|sglist-&gt;dma_address
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|vaddr
comma
id|sglist-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sglist-&gt;dma_length
op_assign
id|sglist-&gt;length
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
r_return
id|nelems
suffix:semicolon
)brace
DECL|function|pci_unmap_sg
r_void
id|pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_while
c_loop
(paren
id|nelems
op_decrement
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|sglist-&gt;dma_address
comma
id|sglist-&gt;dma_length
comma
id|direction
)paren
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * phb_tce_table_init&n; * &n; * Function: Display TCE config registers.  Could be easily changed&n; *           to initialize the hardware to use TCEs.&n; */
DECL|function|phb_tce_table_init
r_int
r_int
id|phb_tce_table_init
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
)paren
(brace
r_int
r_int
id|r
comma
id|cfg_rw
comma
id|i
suffix:semicolon
r_int
r_int
id|r64
suffix:semicolon
id|phandle
id|node
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;phb_tce_table_init: start.&bslash;n&quot;
)paren
suffix:semicolon
id|node
op_assign
(paren
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|phb-&gt;arch_data
)paren
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb            = 0x%lx&bslash;n&quot;
comma
id|phb
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;type      = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;type
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;phb_regs  = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;phb_regs
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;chip_regs = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;chip_regs
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb: node      = 0x%lx&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;arch_data = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;arch_data
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
)paren
(brace
r_if
c_cond
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
op_eq
id|node
)paren
(brace
r_if
c_cond
(paren
id|phb-&gt;type
op_eq
id|phb_type_python
)paren
(brace
id|r
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;phb_regs
)paren
op_plus
(paren
l_int|0xf10
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR(low)    = 0x%x&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;phb_regs
)paren
op_plus
(paren
l_int|0xf00
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR(high)   = 0x%x&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;phb_regs
)paren
op_plus
(paren
l_int|0xfd0
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tPHB cfg(rw) = 0x%x&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|phb-&gt;type
op_eq
id|phb_type_speedwagon
)paren
(brace
id|r64
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
l_int|0x800
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tNCFG    = 0x%lx&bslash;n&quot;
comma
id|r64
)paren
suffix:semicolon
id|r64
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
l_int|0x580
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR0    = 0x%lx&bslash;n&quot;
comma
id|r64
)paren
suffix:semicolon
id|r64
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
l_int|0x588
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR1    = 0x%lx&bslash;n&quot;
comma
id|r64
)paren
suffix:semicolon
id|r64
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
l_int|0x590
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR2    = 0x%lx&bslash;n&quot;
comma
id|r64
)paren
suffix:semicolon
id|r64
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
l_int|0x598
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tTAR3    = 0x%lx&bslash;n&quot;
comma
id|r64
)paren
suffix:semicolon
id|cfg_rw
op_assign
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|phb-&gt;chip_regs
)paren
op_plus
(paren
(paren
l_int|0x160
op_plus
(paren
(paren
(paren
id|phb-&gt;local_number
)paren
op_plus
l_int|8
)paren
op_lshift
l_int|12
)paren
)paren
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tcfg_rw = 0x%x&bslash;n&quot;
comma
id|cfg_rw
)paren
suffix:semicolon
)brace
)brace
id|i
op_increment
suffix:semicolon
)brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;phb_tce_table_init: done&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These are called very early. */
DECL|function|tce_init_pSeries
r_void
id|tce_init_pSeries
c_func
(paren
r_void
)paren
(brace
id|ppc_md.tce_build
op_assign
id|tce_build_pSeries
suffix:semicolon
id|ppc_md.tce_free
op_assign
id|tce_free_pSeries
suffix:semicolon
)brace
DECL|function|tce_init_iSeries
r_void
id|tce_init_iSeries
c_func
(paren
r_void
)paren
(brace
id|ppc_md.tce_build
op_assign
id|tce_build_iSeries
suffix:semicolon
id|ppc_md.tce_free
op_assign
id|tce_free_iSeries
suffix:semicolon
)brace
eof
