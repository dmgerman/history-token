multiline_comment|/*&n; * pci_dma.c&n; * Copyright (C) 2001 Mike Corrigan &amp; Dave Engebretsen, IBM Corporation&n; *&n; * Dynamic DMA mapping support.&n; * &n; * Manages the TCE space assigned to this partition.&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/pci_dma.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_pci.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &quot;pci.h&quot;
multiline_comment|/* #define DEBUG_TCE 1   */
multiline_comment|/* #define MONITOR_TCE 1 */
multiline_comment|/* Turn on to sanity check TCE generation. */
multiline_comment|/* Initialize so this guy does not end up in the BSS section.&n; * Only used to pass OF initialization data set in prom.c into the main &n; * kernel code -- data ultimately copied into tceTables[].&n; */
r_extern
r_struct
id|_of_tce_table
id|of_tce_table
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|pci_controller
op_star
id|hose_head
suffix:semicolon
r_extern
r_struct
id|pci_controller
op_star
op_star
id|hose_tail
suffix:semicolon
r_extern
r_struct
id|list_head
id|iSeries_Global_Device_List
suffix:semicolon
DECL|variable|virtBusVethTceTable
r_struct
id|TceTable
id|virtBusVethTceTable
suffix:semicolon
multiline_comment|/* Tce table for virtual ethernet */
DECL|variable|virtBusVioTceTable
r_struct
id|TceTable
id|virtBusVioTceTable
suffix:semicolon
multiline_comment|/* Tce table for virtual I/O */
DECL|variable|iSeries_veth_dev_node
r_struct
id|iSeries_Device_Node
id|iSeries_veth_dev_node
op_assign
(brace
dot
id|LogicalSlot
op_assign
l_int|0xFF
comma
dot
id|DevTceTable
op_assign
op_amp
id|virtBusVethTceTable
)brace
suffix:semicolon
DECL|variable|iSeries_vio_dev_node
r_struct
id|iSeries_Device_Node
id|iSeries_vio_dev_node
op_assign
(brace
dot
id|LogicalSlot
op_assign
l_int|0xFF
comma
dot
id|DevTceTable
op_assign
op_amp
id|virtBusVioTceTable
)brace
suffix:semicolon
DECL|variable|iSeries_veth_dev_st
r_struct
id|pci_dev
id|iSeries_veth_dev_st
op_assign
(brace
dot
id|sysdata
op_assign
op_amp
id|iSeries_veth_dev_node
)brace
suffix:semicolon
DECL|variable|iSeries_vio_dev_st
r_struct
id|pci_dev
id|iSeries_vio_dev_st
op_assign
(brace
dot
id|sysdata
op_assign
op_amp
id|iSeries_vio_dev_node
)brace
suffix:semicolon
DECL|variable|iSeries_veth_dev
r_struct
id|pci_dev
op_star
id|iSeries_veth_dev
op_assign
op_amp
id|iSeries_veth_dev_st
suffix:semicolon
DECL|variable|iSeries_vio_dev
r_struct
id|pci_dev
op_star
id|iSeries_vio_dev
op_assign
op_amp
id|iSeries_vio_dev_st
suffix:semicolon
multiline_comment|/* Device TceTable is stored in Device Node */
multiline_comment|/* struct TceTable * tceTables[256]; */
multiline_comment|/* Tce tables for 256 busses&n;&t;&t;&t;&t;&t; * Bus 255 is the virtual bus&n;&t;&t;&t;&t;&t; * zero indicates no bus defined&n;&t;&t;&t;&t;&t; */
multiline_comment|/* allocates a contiguous range of tces (power-of-2 size) */
r_static
r_inline
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* allocates a contiguous range of tces (power-of-2 size)&n; * assumes lock already held&n; */
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* frees a contiguous range of tces (power-of-2 size) */
r_static
r_inline
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* frees a contiguous rnage of tces (power-of-2 size)&n; * assumes lock already held&n; */
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
multiline_comment|/* allocates a range of tces and sets them to the pages  */
r_static
r_inline
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|direction
)paren
suffix:semicolon
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
r_static
r_void
id|getTceTableParmsiSeries
c_func
(paren
r_struct
id|iSeries_Device_Node
op_star
id|DevNode
comma
r_struct
id|TceTable
op_star
id|tce_table_parms
)paren
suffix:semicolon
r_static
r_void
id|getTceTableParmsPSeries
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|tce_table_parms
)paren
suffix:semicolon
r_static
r_void
id|getTceTableParmsPSeriesLP
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
suffix:semicolon
r_static
r_struct
id|TceTable
op_star
id|findHwTceTable
c_func
(paren
r_struct
id|TceTable
op_star
id|newTceTable
)paren
suffix:semicolon
r_void
id|create_pci_bus_tce_table
c_func
(paren
r_int
r_int
id|token
)paren
suffix:semicolon
DECL|function|iSeries_Get_Bus
id|u8
id|iSeries_Get_Bus
c_func
(paren
r_struct
id|pci_dev
op_star
id|dv
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_tce_table
r_static
r_inline
r_struct
id|TceTable
op_star
id|get_tce_table
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|ppc64_isabridge_dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_ISERIES_LPAR
)paren
(brace
r_return
id|ISERIES_DEVNODE
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|DevTceTable
suffix:semicolon
)brace
r_else
(brace
r_return
id|PCI_GET_DN
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|tce_table
suffix:semicolon
)brace
)brace
DECL|function|count_leading_zeros64
r_static
r_int
r_int
id|__inline__
id|count_leading_zeros64
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|lz
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;cntlzd %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lz
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|x
)paren
)paren
suffix:semicolon
r_return
id|lz
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPC_ISERIES
DECL|function|tce_build_iSeries
r_static
r_void
id|tce_build_iSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
r_int
id|uaddr
comma
r_int
id|direction
)paren
(brace
id|u64
id|setTceRc
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;build_tce: uaddr = 0x%lx&bslash;n&quot;
comma
id|uaddr
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum = 0x%lx, tbl = 0x%lx, index=%lx&bslash;n&quot;
comma
id|tcenum
comma
id|tbl
comma
id|tbl-&gt;index
)paren
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce.tceBits.rpn
op_assign
(paren
id|virt_to_absolute
c_func
(paren
id|uaddr
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* If for virtual bus */
r_if
c_cond
(paren
id|tbl-&gt;tceType
op_eq
id|TCE_VB
)paren
(brace
id|tce.tceBits.valid
op_assign
l_int|1
suffix:semicolon
id|tce.tceBits.allIo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If for PCI bus */
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Read allowed 
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.pciWrite
op_assign
l_int|1
suffix:semicolon
)brace
id|setTceRc
op_assign
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setTceRc
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: HvCallXm_setTce failed, Rc: 0x%lx&bslash;n&quot;
comma
id|setTceRc
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PPC_PSERIES
DECL|function|tce_build_pSeries
r_static
r_void
id|tce_build_pSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
r_int
id|uaddr
comma
r_int
id|direction
)paren
(brace
r_union
id|Tce
id|tce
suffix:semicolon
r_union
id|Tce
op_star
id|tce_addr
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;build_tce: uaddr = 0x%lx&bslash;n&quot;
comma
id|uaddr
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttcenum = 0x%lx, tbl = 0x%lx, index=%lx&bslash;n&quot;
comma
id|tcenum
comma
id|tbl
comma
id|tbl-&gt;index
)paren
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce.tceBits.rpn
op_assign
(paren
id|virt_to_absolute
c_func
(paren
id|uaddr
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Read allowed 
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.pciWrite
op_assign
l_int|1
suffix:semicolon
id|tce_addr
op_assign
(paren
(paren
r_union
id|Tce
op_star
)paren
id|tbl-&gt;base
)paren
op_plus
id|tcenum
suffix:semicolon
op_star
id|tce_addr
op_assign
(paren
r_union
id|Tce
)paren
id|tce.wholeTce
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * Build a TceTable structure.  This contains a multi-level bit map which&n; * is used to manage allocation of the tce space.&n; */
DECL|function|build_tce_table
r_static
r_struct
id|TceTable
op_star
id|build_tce_table
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
)paren
(brace
r_int
r_int
id|bits
comma
id|bytes
comma
id|totalBytes
suffix:semicolon
r_int
r_int
id|numBits
(braket
id|NUM_TCE_LEVELS
)braket
comma
id|numBytes
(braket
id|NUM_TCE_LEVELS
)braket
suffix:semicolon
r_int
id|i
comma
id|k
comma
id|m
suffix:semicolon
r_int
r_char
op_star
id|pos
comma
op_star
id|p
comma
id|b
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: tbl = 0x%lx&bslash;n&quot;
comma
id|tbl
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
)paren
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute number of bits and bytes for each level of the&n;&t; * multi-level bit map&n;&t; */
id|totalBytes
op_assign
l_int|0
suffix:semicolon
id|bits
op_assign
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bytes
op_assign
(paren
(paren
id|bits
op_plus
l_int|63
)paren
op_div
l_int|64
)paren
op_star
l_int|8
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: level %d bits=%ld, bytes=%ld&bslash;n&quot;
comma
id|i
comma
id|bits
comma
id|bytes
)paren
suffix:semicolon
id|numBits
(braket
id|i
)braket
op_assign
id|bits
suffix:semicolon
id|numBytes
(braket
id|i
)braket
op_assign
id|bytes
suffix:semicolon
id|bits
op_div_assign
l_int|2
suffix:semicolon
id|totalBytes
op_add_assign
id|bytes
suffix:semicolon
)brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: totalBytes=%ld&bslash;n&quot;
comma
id|totalBytes
)paren
suffix:semicolon
id|pos
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|totalBytes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: Allocation failed in build_tce_table!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* For each level, fill in the pointer to the bit map,&n;&t; * and turn on the last bit in the bit map (if the&n;&t; * number of bits in the map is odd).  The highest&n;&t; * level will get all of its bits turned on.&n;&t; */
id|memset
c_func
(paren
id|pos
comma
l_int|0
comma
id|totalBytes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|numBytes
(braket
id|i
)braket
)paren
(brace
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
id|pos
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|numBits
(braket
id|i
)braket
op_amp
l_int|1
)paren
(brace
id|p
op_assign
id|pos
op_plus
id|numBytes
(braket
id|i
)braket
op_minus
l_int|1
suffix:semicolon
id|m
op_assign
(paren
(paren
id|numBits
(braket
id|i
)braket
op_mod
l_int|8
)paren
op_minus
l_int|1
)paren
op_amp
l_int|7
suffix:semicolon
op_star
id|p
op_assign
l_int|0x80
op_rshift
id|m
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: level %d last bit %x&bslash;n&quot;
comma
id|i
comma
l_int|0x80
op_rshift
id|m
)paren
suffix:semicolon
)brace
)brace
r_else
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
l_int|0
suffix:semicolon
id|pos
op_add_assign
id|numBytes
(braket
id|i
)braket
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBits
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBytes
op_assign
id|numBytes
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* For the highest level, turn on all the bits */
id|i
op_assign
id|tbl-&gt;mlbm.maxLevel
suffix:semicolon
id|p
op_assign
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
suffix:semicolon
id|m
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;build_tce_table: highest level (%d) has all bits set&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|numBytes
(braket
id|i
)braket
suffix:semicolon
op_increment
id|k
)paren
(brace
r_if
c_cond
(paren
id|m
op_ge
l_int|8
)paren
(brace
multiline_comment|/* handle full bytes */
op_star
id|p
op_increment
op_assign
l_int|0xff
suffix:semicolon
id|m
op_sub_assign
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m
OG
l_int|0
)paren
(brace
multiline_comment|/* handle the last partial byte */
id|b
op_assign
l_int|0x80
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|m
)paren
(brace
op_star
id|p
op_or_assign
id|b
suffix:semicolon
id|b
op_rshift_assign
l_int|1
suffix:semicolon
op_decrement
id|m
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|tbl
suffix:semicolon
)brace
DECL|function|alloc_tce_range
r_static
r_inline
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Lock the tce allocation bitmap */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do the actual work */
id|retval
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
multiline_comment|/* Unlock the tce allocation bitmap */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|alloc_tce_range_nolock
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|numBits
comma
id|numBytes
suffix:semicolon
r_int
r_int
id|i
comma
id|bit
comma
id|block
comma
id|mask
suffix:semicolon
r_int
id|tcenum
suffix:semicolon
id|u64
op_star
id|map
suffix:semicolon
multiline_comment|/* If the order (power of 2 size) requested is larger than our&n;&t; * biggest, indicate failure&n;&t; */
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
multiline_comment|/* This can happen if block of TCE&squot;s are not found. This code      */
multiline_comment|/*  maybe in a recursive loop looking up the bit map for the range.*/
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: alloc_tce_range_nolock: invalid order: %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
)brace
id|numBits
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
suffix:semicolon
id|numBytes
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBytes
suffix:semicolon
id|map
op_assign
(paren
id|u64
op_star
)paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
multiline_comment|/* Initialize return value to -1 (failure) */
id|tcenum
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Loop through the bytes of the bitmap */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numBytes
op_div
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_star
id|map
)paren
(brace
multiline_comment|/* A free block is found, compute the block&n;&t;&t;&t; * number (of this size)&n;&t;&t;&t; */
id|bit
op_assign
id|count_leading_zeros64
c_func
(paren
op_star
id|map
)paren
suffix:semicolon
id|block
op_assign
(paren
id|i
op_star
l_int|64
)paren
op_plus
id|bit
suffix:semicolon
multiline_comment|/* Bit count to free entry */
multiline_comment|/* turn off the bit in the map to indicate&n;&t;&t;&t; * that the block is now in use&n;&t;&t;&t; */
id|mask
op_assign
l_int|0x1UL
op_lshift
(paren
l_int|63
op_minus
id|bit
)paren
suffix:semicolon
op_star
id|map
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* compute the index into our tce table for&n;&t;&t;&t; * the first tce in the block&n;&t;&t;&t; */
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: allocating block %ld, (byte=%ld, bit=%ld) order %d&bslash;n&quot;
comma
id|block
comma
id|i
comma
id|bit
comma
id|order
)paren
suffix:semicolon
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
r_return
id|tcenum
suffix:semicolon
)brace
op_increment
id|map
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TCE
r_if
c_cond
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: no available blocks of order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;alloc_tce_range_nolock: trying next bigger size&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: alloc_tce_range_nolock: maximum size reached...failing&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;
multiline_comment|/* If no block of the requested size was found, try the next&n;&t; * size bigger.  If one of those is found, return the second&n;&t; * half of the block to freespace and keep the first half&n;&t; */
r_if
c_cond
(paren
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|order
OL
(paren
id|NUM_TCE_LEVELS
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|tcenum
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
id|order
)paren
comma
id|order
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Return the index of the first tce in the block&n;&t; * (or -1 if we failed)&n;&t; */
r_return
id|tcenum
suffix:semicolon
)brace
DECL|function|free_tce_range
r_static
r_inline
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Lock the tce allocation bitmap */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do the actual work */
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
multiline_comment|/* Unlock the tce allocation bitmap */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|free_tce_range_nolock
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
r_char
op_star
id|map
comma
op_star
id|bytep
suffix:semicolon
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: free_tce_range: invalid order: 0x%x&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
macro_line|#ifdef MONITOR_TCE
r_if
c_cond
(paren
id|tcenum
op_ne
(paren
id|block
op_lshift
id|order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: Free_tce_range: tcenum %lx misaligned for order %x&bslash;n&quot;
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block
op_ge
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: Free_tce_range: tcenum %lx is outside the range of this map (order %x, numBits %lx&bslash;n&quot;
comma
id|tcenum
comma
id|order
comma
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: Freeing range not allocated: tTceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|bytep
op_assign
id|map
op_plus
id|byte
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range_nolock: freeing block %ld (byte=%d, bit=%d) of order %d&bslash;n&quot;
comma
id|block
comma
id|byte
comma
id|bit
comma
id|order
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef MONITOR_TCE
r_if
c_cond
(paren
op_star
id|bytep
op_amp
id|mask
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: Tce already free: TceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
op_star
id|bytep
op_or_assign
id|mask
suffix:semicolon
multiline_comment|/* If there is a higher level in the bit map than this we may be&n;&t; * able to buddy up this block with its partner.&n;&t; *   If this is the highest level we can&squot;t buddy up&n;&t; *   If this level has an odd number of bits and&n;&t; *      we are freeing the last block we can&squot;t buddy up&n;&t; * Don&squot;t buddy up if it&squot;s in the first 1/4 of the level&n;&t; */
r_if
c_cond
(paren
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
op_logical_and
(paren
id|block
OG
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_div
l_int|4
)paren
)paren
op_logical_and
(paren
(paren
id|block
OL
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_minus
l_int|1
)paren
op_logical_or
(paren
l_int|0
op_eq
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_amp
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* See if we can buddy up the block we just freed */
id|bit
op_and_assign
l_int|6
suffix:semicolon
multiline_comment|/* get to the first of the buddy bits */
id|mask
op_assign
l_int|0xc0
op_rshift
id|bit
suffix:semicolon
multiline_comment|/* build two bit mask */
id|b
op_assign
op_star
id|bytep
op_amp
id|mask
suffix:semicolon
multiline_comment|/* Get the two bits */
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|b
op_xor
id|mask
)paren
)paren
(brace
multiline_comment|/* If both bits are on */
multiline_comment|/* both of the buddy blocks are free we can combine them */
op_star
id|bytep
op_xor_assign
id|mask
suffix:semicolon
multiline_comment|/* turn off the two bits */
id|block
op_assign
(paren
id|byte
op_star
l_int|8
)paren
op_plus
id|bit
suffix:semicolon
multiline_comment|/* block of first of buddies */
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
multiline_comment|/* free the buddied block */
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;free_tce_range: buddying blocks %ld &amp; %ld&bslash;n&quot;
comma
id|block
comma
id|block
op_plus
l_int|1
)paren
suffix:semicolon
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|test_tce_range
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
id|retval
comma
id|retLeft
comma
id|retRight
suffix:semicolon
r_int
r_char
op_star
id|map
suffix:semicolon
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
multiline_comment|/* Byte within bitmap */
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Bit within byte */
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|b
op_assign
(paren
op_star
(paren
id|map
op_plus
id|byte
)paren
op_amp
id|mask
)paren
suffix:semicolon
multiline_comment|/* 0 if block is allocated, else free */
r_if
c_cond
(paren
id|b
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 == block is free */
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 == block is allocated */
multiline_comment|/* Test bits at all levels below this to ensure that all agree */
r_if
c_cond
(paren
id|order
)paren
(brace
id|retLeft
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
id|retRight
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
(paren
id|order
op_minus
l_int|1
)paren
)paren
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retLeft
op_logical_or
id|retRight
)paren
(brace
id|retval
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* Test bits at all levels above this to ensure that all agree */
r_return
id|retval
suffix:semicolon
)brace
DECL|function|get_tces
r_static
r_inline
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|direction
)paren
(brace
r_int
id|tcenum
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|retTce
op_assign
id|NO_TCE
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|page
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* Allocate a range of tces */
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* We got the tces we wanted */
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
multiline_comment|/* Offset into real TCE table */
id|retTce
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Set the return dma address */
multiline_comment|/* Setup a tce for each page */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ppc_md
dot
id|tce_build
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Make sure the update is visible to hardware. &n;&t;&t;   sync required to synchronize the update to &n;&t;&t;   the TCE table with the MMIO that will send&n;&t;&t;   the bus address to the IOA */
id|__asm__
id|__volatile__
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: Tce Allocation failure in get_tces. 0x%p&bslash;n&quot;
comma
id|tbl
)paren
suffix:semicolon
)brace
r_return
id|retTce
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPC_ISERIES
DECL|function|tce_free_one_iSeries
r_static
r_void
id|tce_free_one_iSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
)paren
(brace
id|u64
id|set_tce_rc
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|set_tce_rc
op_assign
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_tce_rc
)paren
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: HvCallXm_setTce failed, Rc: 0x%lx&bslash;n&quot;
comma
id|set_tce_rc
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PPC_PSERIES
DECL|function|tce_free_one_pSeries
r_static
r_void
id|tce_free_one_pSeries
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
)paren
(brace
r_union
id|Tce
id|tce
suffix:semicolon
r_union
id|Tce
op_star
id|tce_addr
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce_addr
op_assign
(paren
(paren
r_union
id|Tce
op_star
)paren
id|tbl-&gt;base
)paren
op_plus
id|tcenum
suffix:semicolon
op_star
id|tce_addr
op_assign
(paren
r_union
id|Tce
)paren
id|tce.wholeTce
suffix:semicolon
)brace
macro_line|#endif
DECL|function|tce_free
r_static
r_void
id|tce_free
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|order
comma
r_int
id|num_pages
)paren
(brace
r_int
id|tcenum
comma
id|total_tces
comma
id|free_tce
suffix:semicolon
r_int
id|i
suffix:semicolon
id|total_tces
op_assign
(paren
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|tcenum
op_assign
id|dma_addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|free_tce
op_assign
id|tcenum
op_minus
id|tbl-&gt;startOffset
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|free_tce
op_plus
id|num_pages
)paren
OG
id|total_tces
)paren
op_logical_or
(paren
id|tcenum
OL
id|tbl-&gt;startOffset
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tce_free: invalid tcenum&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;ttcenum    = 0x%lx&bslash;n&quot;
comma
id|tcenum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tTCE Table = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tbus#      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;busNumber
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsize      = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tstartOff  = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;startOffset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tindex     = 0x%lx&bslash;n&quot;
comma
(paren
id|u64
)paren
id|tbl-&gt;index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ppc_md
dot
id|tce_free_one
c_func
(paren
id|tbl
comma
id|tcenum
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
)brace
multiline_comment|/* No sync (to make TCE change visible) is required here.&n;&t;   The lwsync when acquiring the lock in free_tce_range&n;&t;   is sufficient to synchronize with the bitmap.&n;&t;*/
id|free_tce_range
c_func
(paren
id|tbl
comma
id|free_tce
comma
id|order
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPC_ISERIES
DECL|function|create_virtual_bus_tce_table
r_void
id|__init
id|create_virtual_bus_tce_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|TceTable
op_star
id|t
suffix:semicolon
r_struct
id|TceTableManagerCB
id|virtBusTceTableParms
suffix:semicolon
id|u64
id|absParmsPtr
suffix:semicolon
id|virtBusTceTableParms.busNumber
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* Bus 255 is the virtual bus */
id|virtBusTceTableParms.virtualBusFlag
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Ask for virtual bus */
id|absParmsPtr
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u64
)paren
op_amp
id|virtBusTceTableParms
)paren
suffix:semicolon
id|HvCallXm_getTceTableParms
c_func
(paren
id|absParmsPtr
)paren
suffix:semicolon
id|virtBusVethTceTable.size
op_assign
id|virtBusTceTableParms.size
op_div
l_int|2
suffix:semicolon
id|virtBusVethTceTable.busNumber
op_assign
id|virtBusTceTableParms.busNumber
suffix:semicolon
id|virtBusVethTceTable.startOffset
op_assign
id|virtBusTceTableParms.startOffset
suffix:semicolon
id|virtBusVethTceTable.index
op_assign
id|virtBusTceTableParms.index
suffix:semicolon
id|virtBusVethTceTable.tceType
op_assign
id|TCE_VB
suffix:semicolon
id|virtBusVioTceTable.size
op_assign
id|virtBusTceTableParms.size
op_minus
id|virtBusVethTceTable.size
suffix:semicolon
id|virtBusVioTceTable.busNumber
op_assign
id|virtBusTceTableParms.busNumber
suffix:semicolon
id|virtBusVioTceTable.startOffset
op_assign
id|virtBusTceTableParms.startOffset
op_plus
id|virtBusVethTceTable.size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
suffix:semicolon
id|virtBusVioTceTable.index
op_assign
id|virtBusTceTableParms.index
suffix:semicolon
id|virtBusVioTceTable.tceType
op_assign
id|TCE_VB
suffix:semicolon
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|virtBusVethTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
multiline_comment|/* tceTables[255] = t; */
singleline_comment|//VirtBusVethTceTable = t;
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VETH TCE table built successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VETH TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|virtBusVioTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
singleline_comment|//VirtBusVioTceTable = t;
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VIO TCE table built successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Virtual Bus VIO TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|create_tce_tables_for_buses
r_void
id|create_tce_tables_for_buses
c_func
(paren
r_struct
id|list_head
op_star
id|bus_list
)paren
(brace
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
comma
op_star
id|first_dn
suffix:semicolon
r_int
id|num_slots
comma
id|num_slots_ilog2
suffix:semicolon
r_int
id|first_phb
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|phb
op_assign
id|hose_head
suffix:semicolon
id|phb
suffix:semicolon
id|phb
op_assign
id|phb-&gt;next
)paren
(brace
id|first_dn
op_assign
(paren
(paren
r_struct
id|device_node
op_star
)paren
id|phb-&gt;arch_data
)paren
op_member_access_from_pointer
id|child
suffix:semicolon
multiline_comment|/* Carve 2GB into the largest dma_window_size possible */
r_for
c_loop
(paren
id|dn
op_assign
id|first_dn
comma
id|num_slots
op_assign
l_int|0
suffix:semicolon
id|dn
op_ne
l_int|NULL
suffix:semicolon
id|dn
op_assign
id|dn-&gt;sibling
)paren
id|num_slots
op_increment
suffix:semicolon
id|num_slots_ilog2
op_assign
id|__ilog2
c_func
(paren
id|num_slots
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|num_slots_ilog2
)paren
op_ne
id|num_slots
)paren
id|num_slots_ilog2
op_increment
suffix:semicolon
id|phb-&gt;dma_window_size
op_assign
l_int|1
op_lshift
(paren
l_int|22
op_minus
id|num_slots_ilog2
)paren
suffix:semicolon
multiline_comment|/* Reserve 16MB of DMA space on the first PHB.&n;&t;&t; * We should probably be more careful and use firmware props.&n;&t;&t; * In reality this space is remapped, not lost.  But we don&squot;t&n;&t;&t; * want to get that smart to handle it -- too much work.&n;&t;&t; */
id|phb-&gt;dma_window_base_cur
op_assign
id|first_phb
ques
c_cond
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:colon
l_int|0
suffix:semicolon
id|first_phb
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dn
op_assign
id|first_dn
comma
id|num_slots
op_assign
l_int|0
suffix:semicolon
id|dn
op_ne
l_int|NULL
suffix:semicolon
id|dn
op_assign
id|dn-&gt;sibling
)paren
(brace
id|create_pci_bus_tce_table
c_func
(paren
(paren
r_int
r_int
)paren
id|dn
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|create_tce_tables_for_busesLP
r_void
id|create_tce_tables_for_busesLP
c_func
(paren
r_struct
id|list_head
op_star
id|bus_list
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device_node
op_star
id|busdn
suffix:semicolon
id|u32
op_star
id|dma_window
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|bus_list-&gt;next
suffix:semicolon
id|ln
op_ne
id|bus_list
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|bus
op_assign
id|pci_bus_b
c_func
(paren
id|ln
)paren
suffix:semicolon
id|busdn
op_assign
id|PCI_GET_DN
c_func
(paren
id|bus
)paren
suffix:semicolon
multiline_comment|/* NOTE: there should never be a window declared on a bus when&n;&t;&t; * child devices also have a window.  If this should ever be&n;&t;&t; * architected, we probably want children to have priority.&n;&t;&t; * In reality, the PHB containing ISA has the property, but otherwise&n;&t;&t; * it is the pci-bridges that have the property.&n;&t;&t; */
id|dma_window
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|busdn
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_window
)paren
(brace
multiline_comment|/* Bussubno hasn&squot;t been copied yet.&n;&t;&t;&t; * Do it now because getTceTableParmsPSeriesLP needs it.&n;&t;&t;&t; */
id|busdn-&gt;bussubno
op_assign
id|bus-&gt;number
suffix:semicolon
id|create_pci_bus_tce_table
c_func
(paren
(paren
r_int
r_int
)paren
id|busdn
)paren
suffix:semicolon
)brace
r_else
id|create_tce_tables_for_busesLP
c_func
(paren
op_amp
id|bus-&gt;children
)paren
suffix:semicolon
)brace
)brace
DECL|function|create_tce_tables
r_void
id|create_tce_tables
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|device_node
op_star
id|dn
comma
op_star
id|mydn
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_PSERIES_LPAR
)paren
(brace
id|create_tce_tables_for_busesLP
c_func
(paren
op_amp
id|pci_root_buses
)paren
suffix:semicolon
)brace
r_else
(brace
id|create_tce_tables_for_buses
c_func
(paren
op_amp
id|pci_root_buses
)paren
suffix:semicolon
)brace
multiline_comment|/* Now copy the tce_table ptr from the bus devices down to every&n;&t; * pci device_node.  This means get_tce_table() won&squot;t need to search&n;&t; * up the device tree to find it.&n;&t; */
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|mydn
op_assign
id|dn
op_assign
id|PCI_GET_DN
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dn
op_logical_and
id|dn-&gt;tce_table
op_eq
l_int|NULL
)paren
id|dn
op_assign
id|dn-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|dn
)paren
(brace
id|mydn-&gt;tce_table
op_assign
id|dn-&gt;tce_table
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * iSeries token = iSeries_device_Node*&n; * pSeries token = pci_controller*&n; *&n; */
DECL|function|create_pci_bus_tce_table
r_void
id|create_pci_bus_tce_table
c_func
(paren
r_int
r_int
id|token
)paren
(brace
r_struct
id|TceTable
op_star
id|newTceTable
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;Entering create_pci_bus_tce_table.&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;ttoken = 0x%lx&bslash;n&quot;
comma
id|token
)paren
suffix:semicolon
id|newTceTable
op_assign
(paren
r_struct
id|TceTable
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|TceTable
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*****************************************************************/
multiline_comment|/* For the iSeries machines, the HvTce Table can be one of three */
multiline_comment|/* flavors,                                                      */
multiline_comment|/* - Single bus TCE table,                                       */
multiline_comment|/* - Tce Table Share between buses,                              */
multiline_comment|/* - Tce Table per logical slot.                                 */
multiline_comment|/*****************************************************************/
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_ISERIES_LPAR
)paren
(brace
r_struct
id|iSeries_Device_Node
op_star
id|DevNode
op_assign
(paren
r_struct
id|iSeries_Device_Node
op_star
)paren
id|token
suffix:semicolon
id|getTceTableParmsiSeries
c_func
(paren
id|DevNode
comma
id|newTceTable
)paren
suffix:semicolon
multiline_comment|/* Look for existing TCE table for this device.          */
id|DevNode-&gt;DevTceTable
op_assign
id|findHwTceTable
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DevNode-&gt;DevTceTable
op_eq
l_int|NULL
)paren
(brace
id|DevNode-&gt;DevTceTable
op_assign
id|build_tce_table
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We&squot;re using a shared table, free this new one.    */
id|kfree
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Pci Device 0x%p TceTable: %p&bslash;n&quot;
comma
id|DevNode
comma
id|DevNode-&gt;DevTceTable
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pSeries Leg */
r_else
(brace
r_struct
id|device_node
op_star
id|dn
suffix:semicolon
r_struct
id|pci_controller
op_star
id|phb
suffix:semicolon
id|dn
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|token
suffix:semicolon
id|phb
op_assign
id|dn-&gt;phb
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_eq
id|PLATFORM_PSERIES
)paren
id|getTceTableParmsPSeries
c_func
(paren
id|phb
comma
id|dn
comma
id|newTceTable
)paren
suffix:semicolon
r_else
id|getTceTableParmsPSeriesLP
c_func
(paren
id|phb
comma
id|dn
comma
id|newTceTable
)paren
suffix:semicolon
id|dn-&gt;tce_table
op_assign
id|build_tce_table
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/***********************************************************************/
multiline_comment|/* This function compares the known Tce tables to find a TceTable that */
multiline_comment|/* has already been built for hardware TCEs.                           */
multiline_comment|/* Search the complete(all devices) for a TCE table assigned.  If the  */
multiline_comment|/* startOffset, index, and size match, then the TCE for this device has*/
multiline_comment|/* already been built and it should be shared with this device         */
multiline_comment|/***********************************************************************/
DECL|function|findHwTceTable
r_static
r_struct
id|TceTable
op_star
id|findHwTceTable
c_func
(paren
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
macro_line|#ifdef CONFIG_PPC_ISERIES
r_struct
id|list_head
op_star
id|Device_Node_Ptr
op_assign
id|iSeries_Global_Device_List.next
suffix:semicolon
multiline_comment|/* Cache the compare values. */
id|u64
id|startOffset
op_assign
id|newTceTable-&gt;startOffset
suffix:semicolon
id|u64
id|index
op_assign
id|newTceTable-&gt;index
suffix:semicolon
id|u64
id|size
op_assign
id|newTceTable-&gt;size
suffix:semicolon
r_while
c_loop
(paren
id|Device_Node_Ptr
op_ne
op_amp
id|iSeries_Global_Device_List
)paren
(brace
r_struct
id|iSeries_Device_Node
op_star
id|CmprNode
op_assign
(paren
r_struct
id|iSeries_Device_Node
op_star
)paren
id|Device_Node_Ptr
suffix:semicolon
r_if
c_cond
(paren
id|CmprNode-&gt;DevTceTable
op_ne
l_int|NULL
op_logical_and
id|CmprNode-&gt;DevTceTable-&gt;tceType
op_eq
id|TCE_PCI
)paren
(brace
r_if
c_cond
(paren
id|CmprNode-&gt;DevTceTable-&gt;startOffset
op_eq
id|startOffset
op_logical_and
id|CmprNode-&gt;DevTceTable-&gt;index
op_eq
id|index
op_logical_and
id|CmprNode-&gt;DevTceTable-&gt;size
op_eq
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI TCE table matches 0x%p &bslash;n&quot;
comma
id|CmprNode-&gt;DevTceTable
)paren
suffix:semicolon
r_return
id|CmprNode-&gt;DevTceTable
suffix:semicolon
)brace
)brace
multiline_comment|/* Get next Device Node in List             */
id|Device_Node_Ptr
op_assign
id|Device_Node_Ptr-&gt;next
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/***********************************************************************/
multiline_comment|/* Call Hv with the architected data structure to get TCE table info.  */
multiline_comment|/* info. Put the returned data into the Linux representation of the    */
multiline_comment|/* TCE table data.                                                     */
multiline_comment|/* The Hardware Tce table comes in three flavors.                      */
multiline_comment|/* 1. TCE table shared between Buses.                                  */
multiline_comment|/* 2. TCE table per Bus.                                               */
multiline_comment|/* 3. TCE Table per IOA.                                               */
multiline_comment|/***********************************************************************/
DECL|function|getTceTableParmsiSeries
r_static
r_void
id|getTceTableParmsiSeries
c_func
(paren
r_struct
id|iSeries_Device_Node
op_star
id|DevNode
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
macro_line|#ifdef CONFIG_PPC_ISERIES
r_struct
id|TceTableManagerCB
op_star
id|pciBusTceTableParms
op_assign
(paren
r_struct
id|TceTableManagerCB
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|TceTableManagerCB
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciBusTceTableParms
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: TCE Table Allocation failed.&quot;
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|pciBusTceTableParms
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|TceTableManagerCB
)paren
)paren
suffix:semicolon
id|pciBusTceTableParms-&gt;busNumber
op_assign
id|ISERIES_BUS
c_func
(paren
id|DevNode
)paren
suffix:semicolon
id|pciBusTceTableParms-&gt;logicalSlot
op_assign
id|DevNode-&gt;LogicalSlot
suffix:semicolon
id|pciBusTceTableParms-&gt;virtualBusFlag
op_assign
l_int|0
suffix:semicolon
id|HvCallXm_getTceTableParms
c_func
(paren
id|REALADDR
c_func
(paren
id|pciBusTceTableParms
)paren
)paren
suffix:semicolon
multiline_comment|/* PciTceTableParms Bus:0x18 Slot:0x04 Start:0x000000 Offset:0x04c000 Size:0x0020 */
id|printk
c_func
(paren
l_string|&quot;PciTceTableParms Bus:0x%02lx Slot:0x%02x Start:0x%06lx Offset:0x%06lx Size:0x%04lx&bslash;n&quot;
comma
id|pciBusTceTableParms-&gt;busNumber
comma
id|pciBusTceTableParms-&gt;logicalSlot
comma
id|pciBusTceTableParms-&gt;start
comma
id|pciBusTceTableParms-&gt;startOffset
comma
id|pciBusTceTableParms-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pciBusTceTableParms-&gt;size
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: Possible Structure mismatch, 0x%p&bslash;n&quot;
comma
id|pciBusTceTableParms
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: pciBusTceTableParms-&gt;size is zero, halt here!&quot;
)paren
suffix:semicolon
)brace
id|newTceTable-&gt;size
op_assign
id|pciBusTceTableParms-&gt;size
suffix:semicolon
id|newTceTable-&gt;busNumber
op_assign
id|pciBusTceTableParms-&gt;busNumber
suffix:semicolon
id|newTceTable-&gt;startOffset
op_assign
id|pciBusTceTableParms-&gt;startOffset
suffix:semicolon
id|newTceTable-&gt;index
op_assign
id|pciBusTceTableParms-&gt;index
suffix:semicolon
id|newTceTable-&gt;tceType
op_assign
id|TCE_PCI
suffix:semicolon
id|kfree
c_func
(paren
id|pciBusTceTableParms
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|getTceTableParmsPSeries
r_static
r_void
id|getTceTableParmsPSeries
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|node
op_assign
(paren
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|phb-&gt;arch_data
)paren
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;getTceTableParms: start&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table = 0x%lx&bslash;n&quot;
comma
id|of_tce_table
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb          = 0x%lx&bslash;n&quot;
comma
id|phb
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn           = 0x%lx&bslash;n&quot;
comma
id|dn
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn-&gt;name     = %s&bslash;n&quot;
comma
id|dn-&gt;name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdn-&gt;full_name= %s&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable  = 0x%lx&bslash;n&quot;
comma
id|newTceTable
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tdma_window_size = 0x%lx&bslash;n&quot;
comma
id|phb-&gt;dma_window_size
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].node = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|node
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].base = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tof_tce_table[%d].size = 0x%lx&bslash;n&quot;
comma
id|i
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|size
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tphb-&gt;arch_data-&gt;node = 0x%lx&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|of_tce_table
(braket
id|i
)braket
dot
id|node
op_eq
id|node
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|of_tce_table
(braket
id|i
)braket
dot
id|base
comma
l_int|0
comma
id|of_tce_table
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|newTceTable-&gt;busNumber
op_assign
id|phb-&gt;bus-&gt;number
suffix:semicolon
multiline_comment|/* Units of tce entries.                        */
id|newTceTable-&gt;startOffset
op_assign
id|phb-&gt;dma_window_base_cur
suffix:semicolon
multiline_comment|/* Adjust the current table offset to the next  */
multiline_comment|/* region.  Measured in TCE entries. Force an   */
multiline_comment|/* alignment to the size alloted per IOA. This  */
multiline_comment|/* makes it easier to remove the 1st 16MB.      */
id|phb-&gt;dma_window_base_cur
op_add_assign
(paren
id|phb-&gt;dma_window_size
op_rshift
l_int|3
)paren
suffix:semicolon
id|phb-&gt;dma_window_base_cur
op_and_assign
op_complement
(paren
(paren
id|phb-&gt;dma_window_size
op_rshift
l_int|3
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the tce table size - measured in units   */
multiline_comment|/* of pages of tce table.                       */
id|newTceTable-&gt;size
op_assign
(paren
(paren
id|phb-&gt;dma_window_base_cur
op_minus
id|newTceTable-&gt;startOffset
)paren
op_lshift
l_int|3
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Test if we are going over 2GB of DMA space.  */
r_if
c_cond
(paren
id|phb-&gt;dma_window_base_cur
OG
(paren
l_int|1
op_lshift
l_int|19
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: Unexpected number of IOAs under this PHB.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|newTceTable-&gt;base
op_assign
id|of_tce_table
(braket
id|i
)braket
dot
id|base
suffix:semicolon
id|newTceTable-&gt;index
op_assign
l_int|0
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;base        = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;base
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;startOffset = 0x%lx&quot;
l_string|&quot;(# tce entries)&bslash;n&quot;
comma
id|newTceTable-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;size        = 0x%lx&quot;
l_string|&quot;(# pages of tce table)&bslash;n&quot;
comma
id|newTceTable-&gt;size
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * getTceTableParmsPSeriesLP&n; *&n; * Function: On pSeries LPAR systems, return TCE table info, given a pci bus.&n; *&n; * ToDo: properly interpret the ibm,dma-window property.  The definition is:&n; *&t;logical-bus-number&t;(1 word)&n; *&t;phys-address&t;&t;(#address-cells words)&n; *&t;size&t;&t;&t;(#cell-size words)&n; *&n; * Currently we hard code these sizes (more or less).&n; */
DECL|function|getTceTableParmsPSeriesLP
r_static
r_void
id|getTceTableParmsPSeriesLP
c_func
(paren
r_struct
id|pci_controller
op_star
id|phb
comma
r_struct
id|device_node
op_star
id|dn
comma
r_struct
id|TceTable
op_star
id|newTceTable
)paren
(brace
id|u32
op_star
id|dma_window
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|dn
comma
l_string|&quot;ibm,dma-window&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_window
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;PCI_DMA: getTceTableParmsPSeriesLP: device %s has no ibm,dma-window property!&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
)brace
id|newTceTable-&gt;busNumber
op_assign
id|dn-&gt;bussubno
suffix:semicolon
id|newTceTable-&gt;size
op_assign
(paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|4
)braket
op_lshift
l_int|32
)paren
op_or
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|5
)braket
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_lshift
l_int|3
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|newTceTable-&gt;startOffset
op_assign
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|2
)braket
op_lshift
l_int|32
)paren
op_or
(paren
r_int
r_int
)paren
id|dma_window
(braket
l_int|3
)braket
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|newTceTable-&gt;base
op_assign
l_int|0
suffix:semicolon
id|newTceTable-&gt;index
op_assign
id|dma_window
(braket
l_int|0
)braket
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;getTceTableParmsPSeriesLP for bus 0x%lx:&bslash;n&quot;
comma
id|dn-&gt;bussubno
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tDevice = %s&bslash;n&quot;
comma
id|dn-&gt;full_name
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;index       = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;index
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;startOffset = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;startOffset
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCEINIT
comma
l_string|&quot;&bslash;tnewTceTable-&gt;size        = 0x%lx&bslash;n&quot;
comma
id|newTceTable-&gt;size
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocates a contiguous real buffer and creates TCEs over it.&n; * Returns the virtual address of the buffer and sets dma_handle&n; * to the dma address (tce) of the first page.&n; */
DECL|function|pci_alloc_consistent
r_void
op_star
id|pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_void
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|dma_addr_t
id|tce
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev      = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tsize       = 0x%16.16lx&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tdma_handle = 0x%16.16lx&bslash;n&quot;
comma
id|dma_handle
)paren
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: pci_alloc_consistent size to large: 0x%lx &bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|NO_TCE
suffix:semicolon
)brace
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
multiline_comment|/* Alloc enough pages (and possibly more) */
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* Page allocation succeeded */
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|nPages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Set up tces to cover the allocated range */
id|tce
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|ret
comma
id|nPages
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tce
op_eq
id|NO_TCE
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: get_tces failed&bslash;n&quot;
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ret
comma
id|order
)paren
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|dma_handle
op_assign
id|tce
suffix:semicolon
)brace
)brace
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: __get_free_pages failed for order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_alloc_consistent: get_tce_table failed for 0x%016lx&bslash;n&quot;
comma
id|hwdev
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tpci_alloc_consistent: dma_handle = 0x%16.16lx&bslash;n&quot;
comma
op_star
id|dma_handle
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;tpci_alloc_consistent: return     = 0x%16.16lx&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pci_free_consistent
r_void
id|pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_free_consistent:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, dma_handle = 0x%16.16lx, vaddr = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|dma_handle
comma
id|vaddr
)paren
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: pci_free_consistent size to large: 0x%lx &bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|order
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Creates TCEs for a user provided buffer.  The user buffer must be &n; * contiguous real kernel storage (not vmalloc).  The address of the buffer&n; * passed here is the kernel (virtual) address of the buffer.  The buffer&n; * need not be page aligned, the dma_addr_t returned will point to the same&n; * byte within the page as vaddr.&n; */
DECL|function|pci_map_single
id|dma_addr_t
id|pci_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
id|dma_addr_t
id|dma_handle
op_assign
id|NO_TCE
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_map_single:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, direction = 0x%16.16lx, vaddr = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|direction
comma
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|vaddr
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|uaddr
op_plus
id|size
)paren
op_minus
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: pci_map_single size to large: 0x%lx &bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
id|NO_TCE
suffix:semicolon
)brace
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|dma_handle
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|vaddr
comma
id|nPages
comma
id|direction
)paren
suffix:semicolon
id|dma_handle
op_or_assign
(paren
id|uaddr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
)brace
r_return
id|dma_handle
suffix:semicolon
)brace
DECL|function|pci_unmap_single
r_void
id|pci_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_single:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, size = 0x%16.16lx, direction = 0x%16.16lx, dma_handle = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|size
comma
id|direction
comma
id|dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|dma_handle
op_plus
id|size
)paren
op_minus
(paren
id|dma_handle
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: pci_unmap_single 0x%lx size to large: 0x%lx &bslash;n&quot;
comma
id|dma_handle
comma
id|size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Figure out how many TCEs are actually going to be required&n; * to map this scatterlist.  This code is not optimal.  It &n; * takes into account the case where entry n ends in the same&n; * page in which entry n+1 starts.  It does not handle the &n; * general case of entry n ending in the same page in which &n; * entry m starts.   &n; */
r_static
r_int
r_int
id|num_tces_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
r_int
id|nTces
comma
id|numPages
comma
id|startPage
comma
id|endPage
comma
id|prevEndPage
suffix:semicolon
r_int
id|i
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
id|nTces
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* Compute the starting page number and&n;&t;&t; * the ending page number for this entry&n;&t;&t; */
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Simple optimization: if the previous entry ended&n;&t;&t; * in the same page in which this entry starts&n;&t;&t; * then we can reduce the required pages by one.&n;&t;&t; * This matches assumptions in fill_scatterlist_sg and&n;&t;&t; * create_tces_sg&n;&t;&t; */
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
op_decrement
id|numPages
suffix:semicolon
id|nTces
op_add_assign
id|numPages
suffix:semicolon
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_return
id|nTces
suffix:semicolon
)brace
multiline_comment|/* Fill in the dma data in the scatterlist&n; * return the number of dma sg entries created&n; */
r_static
r_int
id|fill_scatterlist_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
id|dma_addr_t
id|dma_addr
comma
r_int
r_int
id|numTces
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
suffix:semicolon
id|u32
id|cur_start_dma
suffix:semicolon
r_int
r_int
id|cur_len_dma
comma
id|cur_end_virt
comma
id|uaddr
suffix:semicolon
r_int
id|num_dma_ents
suffix:semicolon
id|dma_sg
op_assign
id|sg
suffix:semicolon
id|num_dma_ents
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Process the first sg entry */
id|cur_start_dma
op_assign
id|dma_addr
op_plus
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
id|sg-&gt;length
suffix:semicolon
multiline_comment|/* cur_end_virt holds the address of the byte immediately after the&n;&t; * end of the current buffer.&n;&t; */
id|cur_end_virt
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|cur_len_dma
suffix:semicolon
multiline_comment|/* Later code assumes that unused sg-&gt;dma_address and sg-&gt;dma_length&n;&t; * fields will be zero.  Other archs seem to assume that the user&n;&t; * (device driver) guarantees that...I don&squot;t want to depend on that&n;&t; */
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Process the rest of the sg entries */
r_while
c_loop
(paren
op_decrement
id|nents
)paren
(brace
op_increment
id|sg
suffix:semicolon
multiline_comment|/* Clear possibly unused fields. Note: sg &gt;= dma_sg so&n;&t;&t; * this can&squot;t be clearing a field we&squot;ve already set&n;&t;&t; */
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check if it is possible to make this next entry&n;&t;&t; * contiguous (in dma space) with the previous entry.&n;&t;&t; */
multiline_comment|/* The entries can be contiguous in dma space if&n;&t;&t; * the previous entry ends immediately before the&n;&t;&t; * start of the current entry (in virtual space)&n;&t;&t; * or if the previous entry ends at a page boundary&n;&t;&t; * and the current entry starts at a page boundary.&n;&t;&t; */
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uaddr
op_ne
id|cur_end_virt
)paren
op_logical_and
(paren
(paren
(paren
id|uaddr
op_or
id|cur_end_virt
)paren
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
op_logical_or
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* This entry can not be contiguous in dma space.&n;&t;&t;&t; * save the previous dma entry and start a new one&n;&t;&t;&t; */
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
op_increment
id|dma_sg
suffix:semicolon
op_increment
id|num_dma_ents
suffix:semicolon
id|cur_start_dma
op_add_assign
id|cur_len_dma
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If the previous entry ends and this entry starts&n;&t;&t;&t; * in the same page then they share a tce.  In that&n;&t;&t;&t; * case don&squot;t bump cur_start_dma to the next page &n;&t;&t;&t; * in dma space.  This matches assumptions made in&n;&t;&t;&t; * num_tces_sg and create_tces_sg.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
id|cur_start_dma
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_else
id|cur_start_dma
op_assign
id|PAGE_ALIGN
c_func
(paren
id|cur_start_dma
op_plus
l_int|1
)paren
suffix:semicolon
id|cur_start_dma
op_add_assign
(paren
id|uaddr
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Accumulate the length of this entry for the next &n;&t;&t; * dma entry&n;&t;&t; */
id|cur_len_dma
op_add_assign
id|sg-&gt;length
suffix:semicolon
id|cur_end_virt
op_assign
id|uaddr
op_plus
id|sg-&gt;length
suffix:semicolon
)brace
multiline_comment|/* Fill in the last dma entry */
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
op_ne
id|numTces
)paren
(brace
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;fill_scatterlist_sg: numTces %ld, used tces %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_return
id|num_dma_ents
suffix:semicolon
)brace
multiline_comment|/* Call the hypervisor to create the TCE entries.&n; * return the number of TCEs created&n; */
r_static
id|dma_addr_t
id|create_tces_sg
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|numTces
comma
r_int
id|direction
)paren
(brace
r_int
id|order
comma
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|startPage
comma
id|endPage
comma
id|prevEndPage
comma
id|numPages
comma
id|uaddr
suffix:semicolon
r_int
id|tcenum
comma
id|starttcenum
suffix:semicolon
id|dma_addr_t
id|dmaAddr
suffix:semicolon
id|dmaAddr
op_assign
id|NO_TCE
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: create_tces_sg size to large: 0x%x &bslash;n&quot;
comma
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
r_return
id|NO_TCE
suffix:semicolon
)brace
multiline_comment|/* allocate a block of tces */
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
id|starttcenum
op_assign
id|tcenum
suffix:semicolon
id|dmaAddr
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nents
suffix:semicolon
op_increment
id|j
)paren
(brace
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
multiline_comment|/* If the previous entry ended in the same page that&n;&t;&t;&t; * the current page starts then they share that&n;&t;&t;&t; * tce and we reduce the number of tces we need&n;&t;&t;&t; * by one.  This matches assumptions made in&n;&t;&t;&t; * num_tces_sg and fill_scatterlist_sg&n;&t;&t;&t; */
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
(brace
op_decrement
id|numPages
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ppc_md
dot
id|tce_build
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
multiline_comment|/* Make sure the update is visible to hardware. &n;&t;&t;   sync required to synchronize the update to &n;&t;&t;   the TCE table with the MMIO that will send&n;&t;&t;   the bus address to the IOA */
id|__asm__
id|__volatile__
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
op_ne
id|numTces
)paren
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;create_tces_sg: numTces %d, tces used %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
)paren
suffix:semicolon
)brace
r_return
id|dmaAddr
suffix:semicolon
)brace
r_int
id|pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|numTces
suffix:semicolon
r_int
id|num_dma
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_map_sg:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, sg = 0x%16.16lx, direction = 0x%16.16lx, nents = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|sg
comma
id|direction
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/* Fast path for a single entry scatterlist */
r_if
c_cond
(paren
id|nents
op_eq
l_int|1
)paren
(brace
id|sg-&gt;dma_address
op_assign
id|pci_map_single
c_func
(paren
id|hwdev
comma
id|sg-&gt;address
comma
id|sg-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
multiline_comment|/* Compute the number of tces required */
id|numTces
op_assign
id|num_tces_sg
c_func
(paren
id|sg
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/* Create the tces and get the dma address */
id|dma_handle
op_assign
id|create_tces_sg
c_func
(paren
id|tbl
comma
id|sg
comma
id|nents
comma
id|numTces
comma
id|direction
)paren
suffix:semicolon
multiline_comment|/* Fill in the dma scatterlist */
id|num_dma
op_assign
id|fill_scatterlist_sg
c_func
(paren
id|sg
comma
id|nents
comma
id|dma_handle
comma
id|numTces
)paren
suffix:semicolon
)brace
r_return
id|num_dma
suffix:semicolon
)brace
r_void
id|pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelms
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|numTces
comma
id|i
suffix:semicolon
id|dma_addr_t
id|dma_end_page
comma
id|dma_start_page
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;pci_unmap_sg:&bslash;n&quot;
)paren
suffix:semicolon
id|PPCDBG
c_func
(paren
id|PPCDBG_TCE
comma
l_string|&quot;&bslash;thwdev = 0x%16.16lx, sg = 0x%16.16lx, direction = 0x%16.16lx, nelms = 0x%16.16lx&bslash;n&quot;
comma
id|hwdev
comma
id|sg
comma
id|direction
comma
id|nelms
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
op_logical_or
id|nelms
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|dma_start_page
op_assign
id|sg-&gt;dma_address
op_amp
id|PAGE_MASK
suffix:semicolon
id|dma_end_page
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nelms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|k
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_length
)paren
(brace
id|dma_end_page
op_assign
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_address
op_plus
id|sg
(braket
id|k
)braket
dot
id|dma_length
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|numTces
op_assign
(paren
(paren
id|dma_end_page
op_minus
id|dma_start_page
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Client asked for way to much space.  This is checked later anyway */
multiline_comment|/* It is easier to debug here for the drivers than in the tce tables.*/
r_if
c_cond
(paren
id|order
op_ge
id|NUM_TCE_LEVELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: dma_start_page:0x%lx  dma_end_page:0x%lx&bslash;n&quot;
comma
id|dma_start_page
comma
id|dma_end_page
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI_DMA: pci_unmap_sg size to large: 0x%x &bslash;n&quot;
comma
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tbl
op_assign
id|get_tce_table
c_func
(paren
id|hwdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|tce_free
c_func
(paren
id|tbl
comma
id|dma_start_page
comma
id|order
comma
id|numTces
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|pci_map_sg
r_int
id|pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nelems
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|vaddr
op_assign
id|page_address
c_func
(paren
id|sglist-&gt;page
)paren
op_plus
id|sglist-&gt;offset
suffix:semicolon
id|sglist-&gt;dma_address
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|vaddr
comma
id|sglist-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sglist-&gt;dma_length
op_assign
id|sglist-&gt;length
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
r_return
id|nelems
suffix:semicolon
)brace
DECL|function|pci_unmap_sg
r_void
id|pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
(brace
r_while
c_loop
(paren
id|nelems
op_decrement
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|sglist-&gt;dma_address
comma
id|sglist-&gt;dma_length
comma
id|direction
)paren
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PPC_PSERIES
multiline_comment|/* These are called very early. */
DECL|function|tce_init_pSeries
r_void
id|tce_init_pSeries
c_func
(paren
r_void
)paren
(brace
id|ppc_md.tce_build
op_assign
id|tce_build_pSeries
suffix:semicolon
id|ppc_md.tce_free_one
op_assign
id|tce_free_one_pSeries
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PPC_ISERIES
DECL|function|tce_init_iSeries
r_void
id|tce_init_iSeries
c_func
(paren
r_void
)paren
(brace
id|ppc_md.tce_build
op_assign
id|tce_build_iSeries
suffix:semicolon
id|ppc_md.tce_free_one
op_assign
id|tce_free_one_iSeries
suffix:semicolon
)brace
macro_line|#endif
eof
