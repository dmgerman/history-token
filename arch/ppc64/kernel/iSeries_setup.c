multiline_comment|/*&n; *    Copyright (c) 2000 Mike Corrigan &lt;mikejc@us.ibm.com&gt;&n; *    Copyright (c) 1999-2000 Grant Erickson &lt;grant@lcse.umn.edu&gt;&n; *&n; *    Module name: iSeries_setup.c&n; *&n; *    Description:&n; *      Architecture- / platform-specific boot-time initialization code for&n; *      the IBM iSeries LPAR.  Adapted from original code by Grant Erickson and&n; *      code by Gary Thomas, Cort Dougan &lt;cort@fsmlabs.com&gt;, and Dan Malek&n; *      &lt;dan@net4x.com&gt;.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/cputable.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &quot;iSeries_setup.h&quot;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallHpt.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpConfig.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallEvent.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallSm.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/ItLpQueue.h&gt;
macro_line|#include &lt;asm/iSeries/IoHriMainStore.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_proc.h&gt;
macro_line|#include &lt;asm/iSeries/mf.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpEvent.h&gt;
r_extern
r_void
id|hvlog
c_func
(paren
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(fmt...) hvlog(fmt)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(fmt...)
macro_line|#endif
multiline_comment|/* Function Prototypes */
r_extern
r_void
id|ppcdbg_initialize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|iSeries_bolt_kernel
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|eaddr
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_setup_arch
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_pci_final_fixup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Global Variables */
DECL|variable|procFreqHz
r_static
r_int
r_int
id|procFreqHz
suffix:semicolon
DECL|variable|procFreqMhz
r_static
r_int
r_int
id|procFreqMhz
suffix:semicolon
DECL|variable|procFreqMhzHundreths
r_static
r_int
r_int
id|procFreqMhzHundreths
suffix:semicolon
DECL|variable|tbFreqHz
r_static
r_int
r_int
id|tbFreqHz
suffix:semicolon
DECL|variable|tbFreqMhz
r_static
r_int
r_int
id|tbFreqMhz
suffix:semicolon
DECL|variable|tbFreqMhzHundreths
r_static
r_int
r_int
id|tbFreqMhzHundreths
suffix:semicolon
DECL|variable|piranha_simulator
r_int
id|piranha_simulator
suffix:semicolon
r_extern
r_int
id|rd_size
suffix:semicolon
multiline_comment|/* Defined in drivers/block/rd.c */
r_extern
r_int
r_int
id|klimit
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_start
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_end
suffix:semicolon
r_extern
r_int
r_int
id|iSeries_recal_tb
suffix:semicolon
r_extern
r_int
r_int
id|iSeries_recal_titan
suffix:semicolon
DECL|variable|mf_initialized
r_static
r_int
id|mf_initialized
suffix:semicolon
DECL|struct|MemoryBlock
r_struct
id|MemoryBlock
(brace
DECL|member|absStart
r_int
r_int
id|absStart
suffix:semicolon
DECL|member|absEnd
r_int
r_int
id|absEnd
suffix:semicolon
DECL|member|logicalStart
r_int
r_int
id|logicalStart
suffix:semicolon
DECL|member|logicalEnd
r_int
r_int
id|logicalEnd
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Process the main store vpd to determine where the holes in memory are&n; * and return the number of physical blocks and fill in the array of&n; * block data.&n; */
DECL|function|iSeries_process_Condor_mainstore_vpd
r_int
r_int
id|iSeries_process_Condor_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
r_int
r_int
id|holeFirstChunk
comma
id|holeSizeChunks
suffix:semicolon
r_int
r_int
id|numMemoryBlocks
op_assign
l_int|1
suffix:semicolon
r_struct
id|IoHriMainStoreSegment4
op_star
id|msVpd
op_assign
(paren
r_struct
id|IoHriMainStoreSegment4
op_star
)paren
id|xMsVpd
suffix:semicolon
r_int
r_int
id|holeStart
op_assign
id|msVpd-&gt;nonInterleavedBlocksStartAdr
suffix:semicolon
r_int
r_int
id|holeEnd
op_assign
id|msVpd-&gt;nonInterleavedBlocksEndAdr
suffix:semicolon
r_int
r_int
id|holeSize
op_assign
id|holeEnd
op_minus
id|holeStart
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: Condor&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine if absolute memory has any&n;&t; * holes so that we can interpret the&n;&t; * access map we get back from the hypervisor&n;&t; * correctly.&n;&t; */
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalStart
op_assign
l_int|0
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalEnd
op_assign
l_int|0x100000000
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absStart
op_assign
l_int|0
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absEnd
op_assign
l_int|0x100000000
suffix:semicolon
r_if
c_cond
(paren
id|holeSize
)paren
(brace
id|numMemoryBlocks
op_assign
l_int|2
suffix:semicolon
id|holeStart
op_assign
id|holeStart
op_amp
l_int|0x000fffffffffffff
suffix:semicolon
id|holeStart
op_assign
id|addr_to_chunk
c_func
(paren
id|holeStart
)paren
suffix:semicolon
id|holeFirstChunk
op_assign
id|holeStart
suffix:semicolon
id|holeSize
op_assign
id|addr_to_chunk
c_func
(paren
id|holeSize
)paren
suffix:semicolon
id|holeSizeChunks
op_assign
id|holeSize
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Main store hole: start chunk = %0lx, size = %0lx chunks&bslash;n&quot;
comma
id|holeFirstChunk
comma
id|holeSizeChunks
)paren
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalEnd
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absEnd
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|logicalStart
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|logicalEnd
op_assign
l_int|0x100000000
op_minus
id|holeSizeChunks
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|absStart
op_assign
id|holeFirstChunk
op_plus
id|holeSizeChunks
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|absEnd
op_assign
l_int|0x100000000
suffix:semicolon
)brace
r_return
id|numMemoryBlocks
suffix:semicolon
)brace
DECL|macro|MaxSegmentAreas
mdefine_line|#define MaxSegmentAreas&t;&t;&t;32
DECL|macro|MaxSegmentAdrRangeBlocks
mdefine_line|#define MaxSegmentAdrRangeBlocks&t;128
DECL|macro|MaxAreaRangeBlocks
mdefine_line|#define MaxAreaRangeBlocks&t;&t;4
DECL|function|iSeries_process_Regatta_mainstore_vpd
r_int
r_int
id|iSeries_process_Regatta_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
r_struct
id|IoHriMainStoreSegment5
op_star
id|msVpdP
op_assign
(paren
r_struct
id|IoHriMainStoreSegment5
op_star
)paren
id|xMsVpd
suffix:semicolon
r_int
r_int
id|numSegmentBlocks
op_assign
l_int|0
suffix:semicolon
id|u32
id|existsBits
op_assign
id|msVpdP-&gt;msAreaExists
suffix:semicolon
r_int
r_int
id|area_num
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: Regatta&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|area_num
op_assign
l_int|0
suffix:semicolon
id|area_num
OL
id|MaxSegmentAreas
suffix:semicolon
op_increment
id|area_num
)paren
(brace
r_int
r_int
id|numAreaBlocks
suffix:semicolon
r_struct
id|IoHriMainStoreArea4
op_star
id|currentArea
suffix:semicolon
r_if
c_cond
(paren
id|existsBits
op_amp
l_int|0x80000000
)paren
(brace
r_int
r_int
id|block_num
suffix:semicolon
id|currentArea
op_assign
op_amp
id|msVpdP-&gt;msAreaArray
(braket
id|area_num
)braket
suffix:semicolon
id|numAreaBlocks
op_assign
id|currentArea-&gt;numAdrRangeBlocks
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ms_vpd: processing area %2ld  blocks=%ld&quot;
comma
id|area_num
comma
id|numAreaBlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block_num
op_assign
l_int|0
suffix:semicolon
id|block_num
OL
id|numAreaBlocks
suffix:semicolon
op_increment
id|block_num
)paren
(brace
multiline_comment|/* Process an address range block */
r_struct
id|MemoryBlock
id|tempBlock
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|tempBlock.absStart
op_assign
(paren
r_int
r_int
)paren
id|currentArea-&gt;xAdrRangeBlock
(braket
id|block_num
)braket
dot
id|blockStart
suffix:semicolon
id|tempBlock.absEnd
op_assign
(paren
r_int
r_int
)paren
id|currentArea-&gt;xAdrRangeBlock
(braket
id|block_num
)braket
dot
id|blockEnd
suffix:semicolon
id|tempBlock.logicalStart
op_assign
l_int|0
suffix:semicolon
id|tempBlock.logicalEnd
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n          block %ld absStart=%016lx absEnd=%016lx&quot;
comma
id|block_num
comma
id|tempBlock.absStart
comma
id|tempBlock.absEnd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numSegmentBlocks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_eq
id|tempBlock.absStart
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|numSegmentBlocks
)paren
(brace
r_if
c_cond
(paren
id|numSegmentBlocks
op_eq
id|max_entries
)paren
id|panic
c_func
(paren
l_string|&quot;iSeries_process_mainstore_vpd: too many memory blocks&quot;
)paren
suffix:semicolon
id|mb_array
(braket
id|numSegmentBlocks
)braket
op_assign
id|tempBlock
suffix:semicolon
op_increment
id|numSegmentBlocks
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; (duplicate)&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|existsBits
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now sort the blocks found into ascending sequence */
r_if
c_cond
(paren
id|numSegmentBlocks
OG
l_int|1
)paren
(brace
r_int
r_int
id|m
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|numSegmentBlocks
op_minus
l_int|1
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
id|numSegmentBlocks
op_minus
l_int|1
suffix:semicolon
id|m
OL
id|n
suffix:semicolon
op_decrement
id|n
)paren
(brace
r_if
c_cond
(paren
id|mb_array
(braket
id|n
)braket
dot
id|absStart
OL
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
dot
id|absStart
)paren
(brace
r_struct
id|MemoryBlock
id|tempBlock
suffix:semicolon
id|tempBlock
op_assign
id|mb_array
(braket
id|n
)braket
suffix:semicolon
id|mb_array
(braket
id|n
)braket
op_assign
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
suffix:semicolon
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
op_assign
id|tempBlock
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Assign &quot;logical&quot; addresses to each block.  These&n;&t; * addresses correspond to the hypervisor &quot;bitmap&quot; space.&n;&t; * Convert all addresses into units of 256K chunks.&n;&t; */
(brace
r_int
r_int
id|i
comma
id|nextBitmapAddress
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ms_vpd: %ld sorted memory blocks&bslash;n&quot;
comma
id|numSegmentBlocks
)paren
suffix:semicolon
id|nextBitmapAddress
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numSegmentBlocks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|length
op_assign
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_minus
id|mb_array
(braket
id|i
)braket
dot
id|absStart
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
op_assign
id|nextBitmapAddress
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
op_assign
id|nextBitmapAddress
op_plus
id|length
suffix:semicolon
id|nextBitmapAddress
op_add_assign
id|length
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;          Bitmap range: %016lx - %016lx&bslash;n&quot;
l_string|&quot;        Absolute range: %016lx - %016lx&bslash;n&quot;
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
comma
id|mb_array
(braket
id|i
)braket
dot
id|absStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_amp
l_int|0x000fffffffffffff
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_amp
l_int|0x000fffffffffffff
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
)paren
suffix:semicolon
)brace
)brace
r_return
id|numSegmentBlocks
suffix:semicolon
)brace
DECL|function|iSeries_process_mainstore_vpd
r_int
r_int
id|iSeries_process_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|mem_blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_feature
c_func
(paren
id|CPU_FTR_SLB
)paren
)paren
id|mem_blocks
op_assign
id|iSeries_process_Regatta_mainstore_vpd
c_func
(paren
id|mb_array
comma
id|max_entries
)paren
suffix:semicolon
r_else
id|mem_blocks
op_assign
id|iSeries_process_Condor_mainstore_vpd
c_func
(paren
id|mb_array
comma
id|max_entries
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: numMemoryBlocks = %ld &bslash;n&quot;
comma
id|mem_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mem_blocks
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: block %3ld logical chunks %016lx - %016lx&bslash;n&quot;
l_string|&quot;                             abs chunks %016lx - %016lx&bslash;n&quot;
comma
id|i
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
comma
id|mb_array
(braket
id|i
)braket
dot
id|absStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
)paren
suffix:semicolon
)brace
r_return
id|mem_blocks
suffix:semicolon
)brace
DECL|function|iSeries_parse_cmdline
r_static
r_void
id|__init
id|iSeries_parse_cmdline
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
multiline_comment|/* copy the command line parameter from the primary VSP  */
id|HvCallEvent_dmaToSp
c_func
(paren
id|cmd_line
comma
l_int|2
op_star
l_int|64
op_star
l_int|1024
comma
l_int|256
comma
id|HvLpDma_Direction_RemoteToLocal
)paren
suffix:semicolon
id|p
op_assign
id|cmd_line
suffix:semicolon
id|q
op_assign
id|cmd_line
op_plus
l_int|255
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|q
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
op_increment
id|p
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|iSeries_init_early
multiline_comment|/*static*/
r_void
id|__init
id|iSeries_init_early
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot; -&gt; iSeries_init_early()&bslash;n&quot;
)paren
suffix:semicolon
id|ppcdbg_initialize
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_INITRD)
multiline_comment|/*&n;&t; * If the init RAM disk has been configured and there is&n;&t; * a non-zero starting address for it, set it up&n;&t; */
r_if
c_cond
(paren
id|naca.xRamDisk
)paren
(brace
id|initrd_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|naca.xRamDisk
)paren
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|naca.xRamDiskSize
op_star
id|PAGE_SIZE
suffix:semicolon
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
singleline_comment|// ramdisk in kernel space
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|rd_size
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
)paren
OL
id|naca.xRamDiskSize
)paren
id|rd_size
op_assign
(paren
id|naca.xRamDiskSize
op_star
id|PAGE_SIZE
)paren
op_div
l_int|1024
suffix:semicolon
)brace
r_else
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
(brace
multiline_comment|/* ROOT_DEV = MKDEV(VIODASD_MAJOR, 1); */
)brace
id|iSeries_recal_tb
op_assign
id|get_tb
c_func
(paren
)paren
suffix:semicolon
id|iSeries_recal_titan
op_assign
id|HvCallXm_loadTod
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Cache sizes must be initialized before hpte_init_iSeries is called&n;&t; * as the later need them for flush_icache_range()&n;&t; */
id|setup_iSeries_cache_sizes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the hash table management pointers&n;&t; */
id|hpte_init_iSeries
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the DMA/TCE management&n;&t; */
id|iommu_init_early_iSeries
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the table which translate Linux physical addresses to&n;&t; * AS/400 absolute addresses&n;&t; */
id|build_iSeries_Memory_Map
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize machine-dependency vectors */
macro_line|#ifdef CONFIG_SMP
id|smp_init_iSeries
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|itLpNaca.xPirEnvironMode
op_eq
l_int|0
)paren
id|piranha_simulator
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Associate Lp Event Queue 0 with processor 0 */
id|HvCallEvent_setLpEventQueueInterruptProc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|mf_init
c_func
(paren
)paren
suffix:semicolon
id|mf_initialized
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we were passed an initrd, set the ROOT_DEV properly if the values&n;&t; * look sensible. If not, clear initrd reference.&n;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
op_ge
id|KERNELBASE
op_logical_and
id|initrd_end
op_ge
id|KERNELBASE
op_logical_and
id|initrd_end
OG
id|initrd_start
)paren
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_else
id|initrd_start
op_assign
id|initrd_end
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
id|iSeries_parse_cmdline
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot; &lt;- iSeries_init_early()&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The iSeries may have very large memories ( &gt; 128 GB ) and a partition&n; * may get memory in &quot;chunks&quot; that may be anywhere in the 2**52 real&n; * address space.  The chunks are 256K in size.  To map this to the &n; * memory model Linux expects, the AS/400 specific code builds a &n; * translation table to translate what Linux thinks are &quot;physical&quot;&n; * addresses to the actual real addresses.  This allows us to make &n; * it appear to Linux that we have contiguous memory starting at&n; * physical address zero while in fact this could be far from the truth.&n; * To avoid confusion, I&squot;ll let the words physical and/or real address &n; * apply to the Linux addresses while I&squot;ll use &quot;absolute address&quot; to &n; * refer to the actual hardware real address.&n; *&n; * build_iSeries_Memory_Map gets information from the Hypervisor and &n; * looks at the Main Store VPD to determine the absolute addresses&n; * of the memory that has been assigned to our partition and builds&n; * a table used to translate Linux&squot;s physical addresses to these&n; * absolute addresses.  Absolute addresses are needed when &n; * communicating with the hypervisor (e.g. to build HPT entries)&n; */
DECL|function|build_iSeries_Memory_Map
r_static
r_void
id|__init
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
(brace
id|u32
id|loadAreaFirstChunk
comma
id|loadAreaLastChunk
comma
id|loadAreaSize
suffix:semicolon
id|u32
id|nextPhysChunk
suffix:semicolon
id|u32
id|hptFirstChunk
comma
id|hptLastChunk
comma
id|hptSizeChunks
comma
id|hptSizePages
suffix:semicolon
id|u32
id|num_ptegs
suffix:semicolon
id|u32
id|totalChunks
comma
id|moreChunks
suffix:semicolon
id|u32
id|currChunk
comma
id|thisChunk
comma
id|absChunk
suffix:semicolon
id|u32
id|currDword
suffix:semicolon
id|u32
id|chunkBit
suffix:semicolon
id|u64
id|map
suffix:semicolon
r_struct
id|MemoryBlock
id|mb
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|numMemoryBlocks
comma
id|curBlock
suffix:semicolon
multiline_comment|/* Chunk size on iSeries is 256K bytes */
id|totalChunks
op_assign
(paren
id|u32
)paren
id|HvLpConfig_getMsChunks
c_func
(paren
)paren
suffix:semicolon
id|klimit
op_assign
id|msChunks_alloc
c_func
(paren
id|klimit
comma
id|totalChunks
comma
l_int|1UL
op_lshift
l_int|18
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get absolute address of our load area&n;&t; * and map it to physical address 0&n;&t; * This guarantees that the loadarea ends up at physical 0&n;&t; * otherwise, it might not be returned by PLIC as the first&n;&t; * chunks&n;&t; */
id|loadAreaFirstChunk
op_assign
(paren
id|u32
)paren
id|addr_to_chunk
c_func
(paren
id|itLpNaca.xLoadAreaAddr
)paren
suffix:semicolon
id|loadAreaSize
op_assign
id|itLpNaca.xLoadAreaChunks
suffix:semicolon
multiline_comment|/*&n;&t; * Only add the pages already mapped here.  &n;&t; * Otherwise we might add the hpt pages &n;&t; * The rest of the pages of the load area&n;&t; * aren&squot;t in the HPT yet and can still&n;&t; * be assigned an arbitrary physical address&n;&t; */
r_if
c_cond
(paren
(paren
id|loadAreaSize
op_star
l_int|64
)paren
OG
id|HvPagesToMap
)paren
id|loadAreaSize
op_assign
id|HvPagesToMap
op_div
l_int|64
suffix:semicolon
id|loadAreaLastChunk
op_assign
id|loadAreaFirstChunk
op_plus
id|loadAreaSize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * TODO Do we need to do something if the HPT is in the 64MB load area?&n;&t; * This would be required if the itLpNaca.xLoadAreaChunks includes &n;&t; * the HPT size&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Mapping load area - physical addr = 0000000000000000&bslash;n&quot;
l_string|&quot;                    absolute addr = %016lx&bslash;n&quot;
comma
id|chunk_to_addr
c_func
(paren
id|loadAreaFirstChunk
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Load area size %dK&bslash;n&quot;
comma
id|loadAreaSize
op_star
l_int|256
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nextPhysChunk
op_assign
l_int|0
suffix:semicolon
id|nextPhysChunk
OL
id|loadAreaSize
suffix:semicolon
op_increment
id|nextPhysChunk
)paren
id|msChunks.abs
(braket
id|nextPhysChunk
)braket
op_assign
id|loadAreaFirstChunk
op_plus
id|nextPhysChunk
suffix:semicolon
multiline_comment|/*&n;&t; * Get absolute address of our HPT and remember it so&n;&t; * we won&squot;t map it to any physical address&n;&t; */
id|hptFirstChunk
op_assign
(paren
id|u32
)paren
id|addr_to_chunk
c_func
(paren
id|HvCallHpt_getHptAddress
c_func
(paren
)paren
)paren
suffix:semicolon
id|hptSizePages
op_assign
(paren
id|u32
)paren
id|HvCallHpt_getHptPages
c_func
(paren
)paren
suffix:semicolon
id|hptSizeChunks
op_assign
id|hptSizePages
op_rshift
(paren
id|msChunks.chunk_shift
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
id|hptLastChunk
op_assign
id|hptFirstChunk
op_plus
id|hptSizeChunks
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HPT absolute addr = %016lx, size = %dK&bslash;n&quot;
comma
id|chunk_to_addr
c_func
(paren
id|hptFirstChunk
)paren
comma
id|hptSizeChunks
op_star
l_int|256
)paren
suffix:semicolon
multiline_comment|/* Fill in the hashed page table hash mask */
id|num_ptegs
op_assign
id|hptSizePages
op_star
(paren
id|PAGE_SIZE
op_div
(paren
r_sizeof
(paren
id|HPTE
)paren
op_star
id|HPTES_PER_GROUP
)paren
)paren
suffix:semicolon
id|htab_hash_mask
op_assign
id|num_ptegs
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * The actual hashed page table is in the hypervisor,&n;&t; * we have no direct access&n;&t; */
id|htab_address
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Determine if absolute memory has any&n;&t; * holes so that we can interpret the&n;&t; * access map we get back from the hypervisor&n;&t; * correctly.&n;&t; */
id|numMemoryBlocks
op_assign
id|iSeries_process_mainstore_vpd
c_func
(paren
id|mb
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Process the main store access map from the hypervisor&n;&t; * to build up our physical -&gt; absolute translation table&n;&t; */
id|curBlock
op_assign
l_int|0
suffix:semicolon
id|currChunk
op_assign
l_int|0
suffix:semicolon
id|currDword
op_assign
l_int|0
suffix:semicolon
id|moreChunks
op_assign
id|totalChunks
suffix:semicolon
r_while
c_loop
(paren
id|moreChunks
)paren
(brace
id|map
op_assign
id|HvCallSm_get64BitsOfAccessMap
c_func
(paren
id|itLpNaca.xLpIndex
comma
id|currDword
)paren
suffix:semicolon
id|thisChunk
op_assign
id|currChunk
suffix:semicolon
r_while
c_loop
(paren
id|map
)paren
(brace
id|chunkBit
op_assign
id|map
op_rshift
l_int|63
suffix:semicolon
id|map
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|chunkBit
)paren
(brace
op_decrement
id|moreChunks
suffix:semicolon
r_while
c_loop
(paren
id|thisChunk
op_ge
id|mb
(braket
id|curBlock
)braket
dot
id|logicalEnd
)paren
(brace
op_increment
id|curBlock
suffix:semicolon
r_if
c_cond
(paren
id|curBlock
op_ge
id|numMemoryBlocks
)paren
id|panic
c_func
(paren
l_string|&quot;out of memory blocks&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thisChunk
OL
id|mb
(braket
id|curBlock
)braket
dot
id|logicalStart
)paren
id|panic
c_func
(paren
l_string|&quot;memory block error&quot;
)paren
suffix:semicolon
id|absChunk
op_assign
id|mb
(braket
id|curBlock
)braket
dot
id|absStart
op_plus
(paren
id|thisChunk
op_minus
id|mb
(braket
id|curBlock
)braket
dot
id|logicalStart
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|absChunk
OL
id|hptFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|hptLastChunk
)paren
)paren
op_logical_and
(paren
(paren
id|absChunk
OL
id|loadAreaFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|loadAreaLastChunk
)paren
)paren
)paren
(brace
id|msChunks.abs
(braket
id|nextPhysChunk
)braket
op_assign
id|absChunk
suffix:semicolon
op_increment
id|nextPhysChunk
suffix:semicolon
)brace
)brace
op_increment
id|thisChunk
suffix:semicolon
)brace
op_increment
id|currDword
suffix:semicolon
id|currChunk
op_add_assign
l_int|64
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * main store size (in chunks) is &n;&t; *   totalChunks - hptSizeChunks&n;&t; * which should be equal to &n;&t; *   nextPhysChunk&n;&t; */
id|systemcfg-&gt;physicalMemorySize
op_assign
id|chunk_to_addr
c_func
(paren
id|nextPhysChunk
)paren
suffix:semicolon
multiline_comment|/* Bolt kernel mappings for all of memory */
id|iSeries_bolt_kernel
c_func
(paren
l_int|0
comma
id|systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
id|lmb_init
c_func
(paren
)paren
suffix:semicolon
id|lmb_add
c_func
(paren
l_int|0
comma
id|systemcfg-&gt;physicalMemorySize
)paren
suffix:semicolon
id|lmb_analyze
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ?? */
id|lmb_reserve
c_func
(paren
l_int|0
comma
id|__pa
c_func
(paren
id|klimit
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the variables that describe the cache line sizes&n; * for this machine.&n; */
DECL|function|setup_iSeries_cache_sizes
r_static
r_void
id|__init
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|n
suffix:semicolon
r_int
r_int
id|procIx
op_assign
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|lppaca.dyn_hv_phys_proc_index
suffix:semicolon
id|systemcfg-&gt;icache_size
op_assign
id|ppc64_caches.isize
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xInstCacheSize
op_star
l_int|1024
suffix:semicolon
id|systemcfg-&gt;icache_line_size
op_assign
id|ppc64_caches.iline_size
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xInstCacheOperandSize
suffix:semicolon
id|systemcfg-&gt;dcache_size
op_assign
id|ppc64_caches.dsize
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xDataL1CacheSizeKB
op_star
l_int|1024
suffix:semicolon
id|systemcfg-&gt;dcache_line_size
op_assign
id|ppc64_caches.dline_size
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xDataCacheOperandSize
suffix:semicolon
id|ppc64_caches.ilines_per_page
op_assign
id|PAGE_SIZE
op_div
id|ppc64_caches.iline_size
suffix:semicolon
id|ppc64_caches.dlines_per_page
op_assign
id|PAGE_SIZE
op_div
id|ppc64_caches.dline_size
suffix:semicolon
id|i
op_assign
id|ppc64_caches.iline_size
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|ppc64_caches.log_iline_size
op_assign
id|n
suffix:semicolon
id|i
op_assign
id|ppc64_caches.dline_size
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|ppc64_caches.log_dline_size
op_assign
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;D-cache line size = %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ppc64_caches.dline_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I-cache line size = %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ppc64_caches.iline_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a pte. Used during initialization only.&n; */
DECL|function|iSeries_make_pte
r_static
r_void
id|iSeries_make_pte
c_func
(paren
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|mode
)paren
(brace
id|HPTE
id|local_hpte
comma
id|rhpte
suffix:semicolon
r_int
r_int
id|hash
comma
id|vpn
suffix:semicolon
r_int
id|slot
suffix:semicolon
id|vpn
op_assign
id|va
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|hash
op_assign
id|hpt_hash
c_func
(paren
id|vpn
comma
l_int|0
)paren
suffix:semicolon
id|local_hpte.dw1.dword1
op_assign
id|pa
op_or
id|mode
suffix:semicolon
id|local_hpte.dw0.dword0
op_assign
l_int|0
suffix:semicolon
id|local_hpte.dw0.dw0.avpn
op_assign
id|va
op_rshift
l_int|23
suffix:semicolon
id|local_hpte.dw0.dw0.bolted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* bolted */
id|local_hpte.dw0.dw0.v
op_assign
l_int|1
suffix:semicolon
id|slot
op_assign
id|HvCallHpt_findValid
c_func
(paren
op_amp
id|rhpte
comma
id|vpn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
OL
l_int|0
)paren
(brace
multiline_comment|/* Must find space in primary group */
id|panic
c_func
(paren
l_string|&quot;hash_page: hpte already exists&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|HvCallHpt_addValidate
c_func
(paren
id|slot
comma
l_int|0
comma
(paren
id|HPTE
op_star
)paren
op_amp
id|local_hpte
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bolt the kernel addr space into the HPT&n; */
DECL|function|iSeries_bolt_kernel
r_static
r_void
id|__init
id|iSeries_bolt_kernel
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|eaddr
)paren
(brace
r_int
r_int
id|pa
suffix:semicolon
r_int
r_int
id|mode_rw
op_assign
id|_PAGE_ACCESSED
op_or
id|_PAGE_COHERENT
op_or
id|PP_RWXX
suffix:semicolon
id|HPTE
id|hpte
suffix:semicolon
r_for
c_loop
(paren
id|pa
op_assign
id|saddr
suffix:semicolon
id|pa
OL
id|eaddr
suffix:semicolon
id|pa
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_int
r_int
id|ea
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|pa
)paren
suffix:semicolon
r_int
r_int
id|vsid
op_assign
id|get_kernel_vsid
c_func
(paren
id|ea
)paren
suffix:semicolon
r_int
r_int
id|va
op_assign
(paren
id|vsid
op_lshift
l_int|28
)paren
op_or
(paren
id|pa
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
r_int
r_int
id|vpn
op_assign
id|va
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
r_int
id|slot
op_assign
id|HvCallHpt_findValid
c_func
(paren
op_amp
id|hpte
comma
id|vpn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hpte.dw0.dw0.v
)paren
(brace
multiline_comment|/* HPTE exists, so just bolt it */
id|HvCallHpt_setSwBits
c_func
(paren
id|slot
comma
l_int|0x10
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* And make sure the pp bits are correct */
id|HvCallHpt_setPp
c_func
(paren
id|slot
comma
id|PP_RWXX
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* No HPTE exists, so create a new bolted one */
id|iSeries_make_pte
c_func
(paren
id|va
comma
id|phys_to_abs
c_func
(paren
id|pa
)paren
comma
id|mode_rw
)paren
suffix:semicolon
)brace
)brace
r_extern
r_int
r_int
id|ppc_proc_freq
suffix:semicolon
r_extern
r_int
r_int
id|ppc_tb_freq
suffix:semicolon
multiline_comment|/*&n; * Document me.&n; */
DECL|function|iSeries_setup_arch
r_void
id|__init
id|iSeries_setup_arch
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|eventStack
suffix:semicolon
r_int
id|procIx
op_assign
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|lppaca.dyn_hv_phys_proc_index
suffix:semicolon
multiline_comment|/* Add an eye catcher and the systemcfg layout version number */
id|strcpy
c_func
(paren
id|systemcfg-&gt;eye_catcher
comma
l_string|&quot;SYSTEMCFG:PPC64&quot;
)paren
suffix:semicolon
id|systemcfg-&gt;version.major
op_assign
id|SYSTEMCFG_MAJOR
suffix:semicolon
id|systemcfg-&gt;version.minor
op_assign
id|SYSTEMCFG_MINOR
suffix:semicolon
multiline_comment|/* Setup the Lp Event Queue */
multiline_comment|/* Allocate a page for the Event Stack&n;&t; * The hypervisor wants the absolute real address, so&n;&t; * we subtract out the KERNELBASE and add in the&n;&t; * absolute real address of the kernel load area&n;&t; */
id|eventStack
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|LpEventStackSize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|eventStack
comma
l_int|0
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Invoke the hypervisor to initialize the event stack */
id|HvCallEvent_setLpEventStack
c_func
(paren
l_int|0
comma
id|eventStack
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Initialize fields in our Lp Event Queue */
id|xItLpQueue.xSlicEventStackPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xSlicCurEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xSlicLastValidEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
op_plus
(paren
id|LpEventStackSize
op_minus
id|LpEventMaxSize
)paren
suffix:semicolon
id|xItLpQueue.xIndex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute processor frequency */
id|procFreqHz
op_assign
(paren
(paren
l_int|1UL
op_lshift
l_int|34
)paren
op_star
l_int|1000000
)paren
op_div
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xProcFreq
suffix:semicolon
id|procFreqMhz
op_assign
id|procFreqHz
op_div
l_int|1000000
suffix:semicolon
id|procFreqMhzHundreths
op_assign
(paren
id|procFreqHz
op_div
l_int|10000
)paren
op_minus
(paren
id|procFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
id|ppc_proc_freq
op_assign
id|procFreqHz
suffix:semicolon
multiline_comment|/* Compute time base frequency */
id|tbFreqHz
op_assign
(paren
(paren
l_int|1UL
op_lshift
l_int|32
)paren
op_star
l_int|1000000
)paren
op_div
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xTimeBaseFreq
suffix:semicolon
id|tbFreqMhz
op_assign
id|tbFreqHz
op_div
l_int|1000000
suffix:semicolon
id|tbFreqMhzHundreths
op_assign
(paren
id|tbFreqHz
op_div
l_int|10000
)paren
op_minus
(paren
id|tbFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
id|ppc_tb_freq
op_assign
id|tbFreqHz
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max  logical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxLogicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max physical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxPhysicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor frequency = %lu.%02lu&bslash;n&quot;
comma
id|procFreqMhz
comma
id|procFreqMhzHundreths
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Time base frequency = %lu.%02lu&bslash;n&quot;
comma
id|tbFreqMhz
comma
id|tbFreqMhzHundreths
)paren
suffix:semicolon
id|systemcfg-&gt;processor
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xPVR
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor version = %x&bslash;n&quot;
comma
id|systemcfg-&gt;processor
)paren
suffix:semicolon
)brace
DECL|function|iSeries_get_cpuinfo
r_void
id|iSeries_get_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;machine&bslash;t&bslash;t: 64-bit iSeries Logical Partition&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; * and Implement me.&n; */
DECL|function|iSeries_get_irq
r_int
id|iSeries_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* -2 means ignore this interrupt */
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
DECL|function|iSeries_restart
r_void
id|iSeries_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
id|mf_reboot
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
DECL|function|iSeries_power_off
r_void
id|iSeries_power_off
c_func
(paren
r_void
)paren
(brace
id|mf_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
DECL|function|iSeries_halt
r_void
id|iSeries_halt
c_func
(paren
r_void
)paren
(brace
id|mf_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* JDH Hack */
DECL|variable|jdh_time
r_int
r_int
id|jdh_time
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|setup_default_decr
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * void __init iSeries_calibrate_decr()&n; *&n; * Description:&n; *   This routine retrieves the internal processor frequency from the VPD,&n; *   and sets up the kernel timer decrementer based on that value.&n; *&n; */
DECL|function|iSeries_calibrate_decr
r_void
id|__init
id|iSeries_calibrate_decr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cyclesPerUsec
suffix:semicolon
r_struct
id|div_result
id|divres
suffix:semicolon
multiline_comment|/* Compute decrementer (and TB) frequency in cycles/sec */
id|cyclesPerUsec
op_assign
id|ppc_tb_freq
op_div
l_int|1000000
suffix:semicolon
multiline_comment|/*&n;&t; * Set the amount to refresh the decrementer by.  This&n;&t; * is the number of decrementer ticks it takes for &n;&t; * 1/HZ seconds.&n;&t; */
id|tb_ticks_per_jiffy
op_assign
id|ppc_tb_freq
op_div
id|HZ
suffix:semicolon
macro_line|#if 0
multiline_comment|/* TEST CODE FOR ADJTIME */
id|tb_ticks_per_jiffy
op_add_assign
id|tb_ticks_per_jiffy
op_div
l_int|5000
suffix:semicolon
multiline_comment|/* END OF TEST CODE */
macro_line|#endif
multiline_comment|/*&n;&t; * tb_ticks_per_sec = freq; would give better accuracy&n;&t; * but tb_ticks_per_sec = tb_ticks_per_jiffy*HZ; assures&n;&t; * that jiffies (and xtime) will match the time returned&n;&t; * by do_gettimeofday.&n;&t; */
id|tb_ticks_per_sec
op_assign
id|tb_ticks_per_jiffy
op_star
id|HZ
suffix:semicolon
id|tb_ticks_per_usec
op_assign
id|cyclesPerUsec
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|ppc_tb_freq
comma
l_int|1000000
)paren
suffix:semicolon
id|div128_by_32
c_func
(paren
l_int|1024
op_star
l_int|1024
comma
l_int|0
comma
id|tb_ticks_per_sec
comma
op_amp
id|divres
)paren
suffix:semicolon
id|tb_to_xs
op_assign
id|divres.result_low
suffix:semicolon
id|setup_default_decr
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|iSeries_progress
r_void
id|__init
id|iSeries_progress
c_func
(paren
r_char
op_star
id|st
comma
r_int
r_int
id|code
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Progress: [%04x] - %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|code
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|piranha_simulator
op_logical_and
id|mf_initialized
)paren
(brace
r_if
c_cond
(paren
id|code
op_ne
l_int|0xffff
)paren
id|mf_display_progress
c_func
(paren
id|code
)paren
suffix:semicolon
r_else
id|mf_clear_src
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|iSeries_fixup_klimit
r_static
r_void
id|__init
id|iSeries_fixup_klimit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Change klimit to take into account any ram disk&n;&t; * that may be included&n;&t; */
r_if
c_cond
(paren
id|naca.xRamDisk
)paren
id|klimit
op_assign
id|KERNELBASE
op_plus
(paren
id|u64
)paren
id|naca.xRamDisk
op_plus
(paren
id|naca.xRamDiskSize
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * No ram disk was included - check and see if there&n;&t;&t; * was an embedded system map.  Change klimit to take&n;&t;&t; * into account any embedded system map&n;&t;&t; */
r_if
c_cond
(paren
id|embedded_sysmap_end
)paren
id|klimit
op_assign
id|KERNELBASE
op_plus
(paren
(paren
id|embedded_sysmap_end
op_plus
l_int|4095
)paren
op_amp
l_int|0xfffffffffffff000
)paren
suffix:semicolon
)brace
)brace
DECL|function|iSeries_src_init
r_int
id|__init
id|iSeries_src_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* clear the progress line */
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot; &quot;
comma
l_int|0xffff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|iSeries_src_init
id|late_initcall
c_func
(paren
id|iSeries_src_init
)paren
suffix:semicolon
DECL|function|iSeries_early_setup
r_void
id|__init
id|iSeries_early_setup
c_func
(paren
r_void
)paren
(brace
id|iSeries_fixup_klimit
c_func
(paren
)paren
suffix:semicolon
id|ppc_md.setup_arch
op_assign
id|iSeries_setup_arch
suffix:semicolon
id|ppc_md.get_cpuinfo
op_assign
id|iSeries_get_cpuinfo
suffix:semicolon
id|ppc_md.init_IRQ
op_assign
id|iSeries_init_IRQ
suffix:semicolon
id|ppc_md.get_irq
op_assign
id|iSeries_get_irq
suffix:semicolon
id|ppc_md.init_early
op_assign
id|iSeries_init_early
comma
id|ppc_md.pcibios_fixup
op_assign
id|iSeries_pci_final_fixup
suffix:semicolon
id|ppc_md.restart
op_assign
id|iSeries_restart
suffix:semicolon
id|ppc_md.power_off
op_assign
id|iSeries_power_off
suffix:semicolon
id|ppc_md.halt
op_assign
id|iSeries_halt
suffix:semicolon
id|ppc_md.get_boot_time
op_assign
id|iSeries_get_boot_time
suffix:semicolon
id|ppc_md.set_rtc_time
op_assign
id|iSeries_set_rtc_time
suffix:semicolon
id|ppc_md.get_rtc_time
op_assign
id|iSeries_get_rtc_time
suffix:semicolon
id|ppc_md.calibrate_decr
op_assign
id|iSeries_calibrate_decr
suffix:semicolon
id|ppc_md.progress
op_assign
id|iSeries_progress
suffix:semicolon
)brace
eof
