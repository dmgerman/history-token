multiline_comment|/*&n; * &n; *&n; *    Copyright (c) 2000 Mike Corrigan &lt;mikejc@us.ibm.com&gt;&n; *    Copyright (c) 1999-2000 Grant Erickson &lt;grant@lcse.umn.edu&gt;&n; *&n; *    Module name: iSeries_setup.c&n; *&n; *    Description:&n; *      Architecture- / platform-specific boot-time initialization code for&n; *      the IBM iSeries LPAR.  Adapted from original code by Grant Erickson and&n; *      code by Gary Thomas, Cort Dougan &lt;cort@fsmlabs.com&gt;, and Dan Malek&n; *      &lt;dan@net4x.com&gt;.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &quot;iSeries_setup.h&quot;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallHpt.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpConfig.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallEvent.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallSm.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/ItLpQueue.h&gt;
macro_line|#include &lt;asm/iSeries/IoHriMainStore.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_proc.h&gt;
macro_line|#include &lt;asm/proc_pmc.h&gt;
macro_line|#include &lt;asm/iSeries/mf.h&gt;
multiline_comment|/* Function Prototypes */
r_extern
r_void
m_abort
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
r_static
r_void
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|iSeries_bolt_kernel
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|eaddr
)paren
suffix:semicolon
macro_line|#endif
r_void
id|build_valid_hpte
c_func
(paren
r_int
r_int
id|vsid
comma
r_int
r_int
id|ea
comma
r_int
r_int
id|pa
comma
id|pte_t
op_star
id|ptep
comma
r_int
id|hpteflags
comma
r_int
id|bolted
)paren
suffix:semicolon
r_extern
r_void
id|ppcdbg_initialize
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_pcibios_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_pcibios_fixup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_pcibios_fixup_bus
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|iSeries_setup_dprofile
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Global Variables */
DECL|variable|procFreqHz
r_static
r_int
r_int
id|procFreqHz
op_assign
l_int|0
suffix:semicolon
DECL|variable|procFreqMhz
r_static
r_int
r_int
id|procFreqMhz
op_assign
l_int|0
suffix:semicolon
DECL|variable|procFreqMhzHundreths
r_static
r_int
r_int
id|procFreqMhzHundreths
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqHz
r_static
r_int
r_int
id|tbFreqHz
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqMhz
r_static
r_int
r_int
id|tbFreqMhz
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqMhzHundreths
r_static
r_int
r_int
id|tbFreqMhzHundreths
op_assign
l_int|0
suffix:semicolon
DECL|variable|dprof_shift
r_int
r_int
id|dprof_shift
op_assign
l_int|0
suffix:semicolon
DECL|variable|dprof_len
r_int
r_int
id|dprof_len
op_assign
l_int|0
suffix:semicolon
DECL|variable|dprof_buffer
r_int
r_int
op_star
id|dprof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|piranha_simulator
r_int
id|piranha_simulator
op_assign
l_int|0
suffix:semicolon
r_extern
r_char
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_int
id|rd_size
suffix:semicolon
multiline_comment|/* Defined in drivers/block/rd.c */
r_extern
r_int
r_int
id|klimit
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_start
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_end
suffix:semicolon
r_extern
r_int
r_int
id|iSeries_recal_tb
suffix:semicolon
r_extern
r_int
r_int
id|iSeries_recal_titan
suffix:semicolon
r_extern
r_char
id|_stext
suffix:semicolon
r_extern
r_char
id|_etext
suffix:semicolon
DECL|variable|mf_initialized
r_static
r_int
id|mf_initialized
op_assign
l_int|0
suffix:semicolon
DECL|struct|MemoryBlock
r_struct
id|MemoryBlock
(brace
DECL|member|absStart
r_int
r_int
id|absStart
suffix:semicolon
DECL|member|absEnd
r_int
r_int
id|absEnd
suffix:semicolon
DECL|member|logicalStart
r_int
r_int
id|logicalStart
suffix:semicolon
DECL|member|logicalEnd
r_int
r_int
id|logicalEnd
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Process the main store vpd to determine where the holes in memory are&n; * and return the number of physical blocks and fill in the array of&n; * block data.&n; */
DECL|function|iSeries_process_Condor_mainstore_vpd
r_int
r_int
id|iSeries_process_Condor_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
multiline_comment|/* Determine if absolute memory has any&n;&t; * holes so that we can interpret the&n;&t; * access map we get back from the hypervisor&n;&t; * correctly.&n;&t; */
r_int
r_int
id|holeFirstChunk
comma
id|holeSizeChunks
suffix:semicolon
r_int
r_int
id|numMemoryBlocks
op_assign
l_int|1
suffix:semicolon
r_struct
id|IoHriMainStoreSegment4
op_star
id|msVpd
op_assign
(paren
r_struct
id|IoHriMainStoreSegment4
op_star
)paren
id|xMsVpd
suffix:semicolon
r_int
r_int
id|holeStart
op_assign
id|msVpd-&gt;nonInterleavedBlocksStartAdr
suffix:semicolon
r_int
r_int
id|holeEnd
op_assign
id|msVpd-&gt;nonInterleavedBlocksEndAdr
suffix:semicolon
r_int
r_int
id|holeSize
op_assign
id|holeEnd
op_minus
id|holeStart
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: Condor&bslash;n&quot;
)paren
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalStart
op_assign
l_int|0
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalEnd
op_assign
l_int|0x100000000
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absStart
op_assign
l_int|0
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absEnd
op_assign
l_int|0x100000000
suffix:semicolon
r_if
c_cond
(paren
id|holeSize
)paren
(brace
id|numMemoryBlocks
op_assign
l_int|2
suffix:semicolon
id|holeStart
op_assign
id|holeStart
op_amp
l_int|0x000fffffffffffff
suffix:semicolon
id|holeStart
op_assign
id|addr_to_chunk
c_func
(paren
id|holeStart
)paren
suffix:semicolon
id|holeFirstChunk
op_assign
id|holeStart
suffix:semicolon
id|holeSize
op_assign
id|addr_to_chunk
c_func
(paren
id|holeSize
)paren
suffix:semicolon
id|holeSizeChunks
op_assign
id|holeSize
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Main store hole: start chunk = %0lx, size = %0lx chunks&bslash;n&quot;
comma
id|holeFirstChunk
comma
id|holeSizeChunks
)paren
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|logicalEnd
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|0
)braket
dot
id|absEnd
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|logicalStart
op_assign
id|holeFirstChunk
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|logicalEnd
op_assign
l_int|0x100000000
op_minus
id|holeSizeChunks
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|absStart
op_assign
id|holeFirstChunk
op_plus
id|holeSizeChunks
suffix:semicolon
id|mb_array
(braket
l_int|1
)braket
dot
id|absEnd
op_assign
l_int|0x100000000
suffix:semicolon
)brace
r_return
id|numMemoryBlocks
suffix:semicolon
)brace
DECL|macro|MaxSegmentAreas
mdefine_line|#define MaxSegmentAreas 32
DECL|macro|MaxSegmentAdrRangeBlocks
mdefine_line|#define MaxSegmentAdrRangeBlocks 128
DECL|macro|MaxAreaRangeBlocks
mdefine_line|#define MaxAreaRangeBlocks 4
DECL|function|iSeries_process_Regatta_mainstore_vpd
r_int
r_int
id|iSeries_process_Regatta_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
r_struct
id|IoHriMainStoreSegment5
op_star
id|msVpdP
op_assign
(paren
r_struct
id|IoHriMainStoreSegment5
op_star
)paren
id|xMsVpd
suffix:semicolon
r_int
r_int
id|numSegmentBlocks
op_assign
l_int|0
suffix:semicolon
id|u32
id|existsBits
op_assign
id|msVpdP-&gt;msAreaExists
suffix:semicolon
r_int
r_int
id|area_num
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: Regatta&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|area_num
op_assign
l_int|0
suffix:semicolon
id|area_num
OL
id|MaxSegmentAreas
suffix:semicolon
op_increment
id|area_num
)paren
(brace
r_int
r_int
id|numAreaBlocks
suffix:semicolon
r_struct
id|IoHriMainStoreArea4
op_star
id|currentArea
suffix:semicolon
r_if
c_cond
(paren
id|existsBits
op_amp
l_int|0x80000000
)paren
(brace
r_int
r_int
id|block_num
suffix:semicolon
id|currentArea
op_assign
op_amp
id|msVpdP-&gt;msAreaArray
(braket
id|area_num
)braket
suffix:semicolon
id|numAreaBlocks
op_assign
id|currentArea-&gt;numAdrRangeBlocks
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ms_vpd: processing area %2ld  blocks=%ld&quot;
comma
id|area_num
comma
id|numAreaBlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block_num
op_assign
l_int|0
suffix:semicolon
id|block_num
OL
id|numAreaBlocks
suffix:semicolon
op_increment
id|block_num
)paren
(brace
multiline_comment|/* Process an address range block */
r_struct
id|MemoryBlock
id|tempBlock
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|tempBlock.absStart
op_assign
(paren
r_int
r_int
)paren
id|currentArea-&gt;xAdrRangeBlock
(braket
id|block_num
)braket
dot
id|blockStart
suffix:semicolon
id|tempBlock.absEnd
op_assign
(paren
r_int
r_int
)paren
id|currentArea-&gt;xAdrRangeBlock
(braket
id|block_num
)braket
dot
id|blockEnd
suffix:semicolon
id|tempBlock.logicalStart
op_assign
l_int|0
suffix:semicolon
id|tempBlock.logicalEnd
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n          block %ld absStart=%016lx absEnd=%016lx&quot;
comma
id|block_num
comma
id|tempBlock.absStart
comma
id|tempBlock.absEnd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numSegmentBlocks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_eq
id|tempBlock.absStart
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|numSegmentBlocks
)paren
(brace
r_if
c_cond
(paren
id|numSegmentBlocks
op_eq
id|max_entries
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;iSeries_process_mainstore_vpd: too many memory blocks&quot;
)paren
suffix:semicolon
)brace
id|mb_array
(braket
id|numSegmentBlocks
)braket
op_assign
id|tempBlock
suffix:semicolon
op_increment
id|numSegmentBlocks
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; (duplicate)&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|existsBits
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now sort the blocks found into ascending sequence */
r_if
c_cond
(paren
id|numSegmentBlocks
OG
l_int|1
)paren
(brace
r_int
r_int
id|m
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|numSegmentBlocks
op_minus
l_int|1
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
id|numSegmentBlocks
op_minus
l_int|1
suffix:semicolon
id|m
OL
id|n
suffix:semicolon
op_decrement
id|n
)paren
(brace
r_if
c_cond
(paren
id|mb_array
(braket
id|n
)braket
dot
id|absStart
OL
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
dot
id|absStart
)paren
(brace
r_struct
id|MemoryBlock
id|tempBlock
suffix:semicolon
id|tempBlock
op_assign
id|mb_array
(braket
id|n
)braket
suffix:semicolon
id|mb_array
(braket
id|n
)braket
op_assign
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
suffix:semicolon
id|mb_array
(braket
id|n
op_minus
l_int|1
)braket
op_assign
id|tempBlock
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Assign &quot;logical&quot; addresses to each block.  These&n;&t; * addresses correspond to the hypervisor &quot;bitmap&quot; space.&n;&t; * Convert all addresses into units of 256K chunks.&n;&t; */
(brace
r_int
r_int
id|i
comma
id|nextBitmapAddress
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ms_vpd: %ld sorted memory blocks&bslash;n&quot;
comma
id|numSegmentBlocks
)paren
suffix:semicolon
id|nextBitmapAddress
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numSegmentBlocks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|length
op_assign
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_minus
id|mb_array
(braket
id|i
)braket
dot
id|absStart
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
op_assign
id|nextBitmapAddress
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
op_assign
id|nextBitmapAddress
op_plus
id|length
suffix:semicolon
id|nextBitmapAddress
op_add_assign
id|length
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;          Bitmap range: %016lx - %016lx&bslash;n&quot;
l_string|&quot;        Absolute range: %016lx - %016lx&bslash;n&quot;
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
comma
id|mb_array
(braket
id|i
)braket
dot
id|absStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absStart
op_amp
l_int|0x000fffffffffffff
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
op_amp
l_int|0x000fffffffffffff
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
)paren
suffix:semicolon
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
op_assign
id|addr_to_chunk
c_func
(paren
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
)paren
suffix:semicolon
)brace
)brace
r_return
id|numSegmentBlocks
suffix:semicolon
)brace
DECL|function|iSeries_process_mainstore_vpd
r_int
r_int
id|iSeries_process_mainstore_vpd
c_func
(paren
r_struct
id|MemoryBlock
op_star
id|mb_array
comma
r_int
r_int
id|max_entries
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|mem_blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
)paren
id|mem_blocks
op_assign
id|iSeries_process_Regatta_mainstore_vpd
c_func
(paren
id|mb_array
comma
id|max_entries
)paren
suffix:semicolon
r_else
id|mem_blocks
op_assign
id|iSeries_process_Condor_mainstore_vpd
c_func
(paren
id|mb_array
comma
id|max_entries
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: numMemoryBlocks = %ld &bslash;n&quot;
comma
id|mem_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mem_blocks
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Mainstore_VPD: block %3ld logical chunks %016lx - %016lx&bslash;n&quot;
l_string|&quot;                             abs chunks %016lx - %016lx&bslash;n&quot;
comma
id|i
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|logicalEnd
comma
id|mb_array
(braket
id|i
)braket
dot
id|absStart
comma
id|mb_array
(braket
id|i
)braket
dot
id|absEnd
)paren
suffix:semicolon
)brace
r_return
id|mem_blocks
suffix:semicolon
)brace
multiline_comment|/*&n; * void __init iSeries_init_early()&n; */
r_void
id|__init
DECL|function|iSeries_init_early
id|iSeries_init_early
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PPC_ISERIES
id|ppcdbg_initialize
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_INITRD)
multiline_comment|/*&n;&t; * If the init RAM disk has been configured and there is&n;&t; * a non-zero starting address for it, set it up&n;&t; */
r_if
c_cond
(paren
id|naca-&gt;xRamDisk
)paren
(brace
id|initrd_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|naca-&gt;xRamDisk
)paren
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|naca-&gt;xRamDiskSize
op_star
id|PAGE_SIZE
suffix:semicolon
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
singleline_comment|// ramdisk in kernel space
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|rd_size
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
)paren
OL
id|naca-&gt;xRamDiskSize
)paren
id|rd_size
op_assign
(paren
id|naca-&gt;xRamDiskSize
op_star
id|PAGE_SIZE
)paren
op_div
l_int|1024
suffix:semicolon
)brace
r_else
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
(brace
multiline_comment|/*&t;&t;ROOT_DEV = MKDEV( VIODASD_MAJOR, 1 ); */
)brace
id|iSeries_recal_tb
op_assign
id|get_tb
c_func
(paren
)paren
suffix:semicolon
id|iSeries_recal_titan
op_assign
id|HvCallXm_loadTod
c_func
(paren
)paren
suffix:semicolon
id|ppc_md.setup_arch
op_assign
id|iSeries_setup_arch
suffix:semicolon
id|ppc_md.setup_residual
op_assign
id|iSeries_setup_residual
suffix:semicolon
id|ppc_md.get_cpuinfo
op_assign
id|iSeries_get_cpuinfo
suffix:semicolon
id|ppc_md.irq_cannonicalize
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.init_IRQ
op_assign
id|iSeries_init_IRQ
suffix:semicolon
id|ppc_md.init_ras_IRQ
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.get_irq
op_assign
id|iSeries_get_irq
suffix:semicolon
id|ppc_md.init
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.pcibios_fixup
op_assign
id|iSeries_pcibios_fixup
suffix:semicolon
id|ppc_md.pcibios_fixup_bus
op_assign
id|iSeries_pcibios_fixup_bus
suffix:semicolon
id|ppc_md.restart
op_assign
id|iSeries_restart
suffix:semicolon
id|ppc_md.power_off
op_assign
id|iSeries_power_off
suffix:semicolon
id|ppc_md.halt
op_assign
id|iSeries_halt
suffix:semicolon
id|ppc_md.time_init
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.get_boot_time
op_assign
id|iSeries_get_boot_time
suffix:semicolon
id|ppc_md.set_rtc_time
op_assign
id|iSeries_set_rtc_time
suffix:semicolon
id|ppc_md.get_rtc_time
op_assign
id|iSeries_get_rtc_time
suffix:semicolon
id|ppc_md.calibrate_decr
op_assign
id|iSeries_calibrate_decr
suffix:semicolon
id|ppc_md.progress
op_assign
id|iSeries_progress
suffix:semicolon
id|ppc_md.kbd_setkeycode
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.kbd_getkeycode
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.kbd_translate
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.kbd_unexpected_up
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.kbd_leds
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.kbd_init_hw
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if defined(CONFIG_MAGIC_SYSRQ)
id|ppc_md.ppc_kbd_sysrq_xlate
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|hpte_init_iSeries
c_func
(paren
)paren
suffix:semicolon
id|tce_init_iSeries
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the table which translate Linux physical addresses to&n;&t; * AS/400 absolute addresses&n;&t; */
id|build_iSeries_Memory_Map
c_func
(paren
)paren
suffix:semicolon
id|setup_iSeries_cache_sizes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize machine-dependency vectors */
macro_line|#ifdef CONFIG_SMP
id|smp_init_iSeries
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|itLpNaca.xPirEnvironMode
op_eq
l_int|0
)paren
id|piranha_simulator
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * void __init iSeries_init()&n; */
r_void
id|__init
DECL|function|iSeries_init
id|iSeries_init
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
)paren
(brace
multiline_comment|/* Associate Lp Event Queue 0 with processor 0 */
id|HvCallEvent_setLpEventQueueInterruptProc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
(brace
multiline_comment|/* copy the command line parameter from the primary VSP  */
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|HvCallEvent_dmaToSp
c_func
(paren
id|cmd_line
comma
l_int|2
op_star
l_int|64
op_star
l_int|1024
comma
l_int|256
comma
id|HvLpDma_Direction_RemoteToLocal
)paren
suffix:semicolon
id|p
op_assign
id|q
op_assign
id|cmd_line
op_plus
l_int|255
suffix:semicolon
r_while
c_loop
(paren
id|p
OG
id|cmd_line
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
op_eq
l_int|0
)paren
op_logical_or
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
)paren
op_logical_or
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
op_decrement
id|p
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
OL
id|q
)paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|cmd_line
comma
l_string|&quot;dprofile=&quot;
)paren
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|cmd_line
suffix:semicolon
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|q
comma
l_string|&quot;dprofile=&quot;
)paren
)paren
op_ne
l_int|0
suffix:semicolon
)paren
(brace
r_int
r_int
id|size
comma
id|new_klimit
suffix:semicolon
id|q
op_assign
id|p
op_plus
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|p
OG
id|cmd_line
op_logical_and
id|p
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
id|dprof_shift
op_assign
id|simple_strtoul
c_func
(paren
id|q
comma
op_amp
id|q
comma
l_int|0
)paren
suffix:semicolon
id|dprof_len
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
op_minus
(paren
r_int
r_int
)paren
op_amp
id|_stext
suffix:semicolon
id|dprof_len
op_rshift_assign
id|dprof_shift
suffix:semicolon
id|size
op_assign
(paren
(paren
id|dprof_len
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|dprof_buffer
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
id|klimit
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|new_klimit
op_assign
(paren
(paren
r_int
r_int
)paren
id|dprof_buffer
)paren
op_plus
id|size
suffix:semicolon
id|lmb_reserve
c_func
(paren
id|__pa
c_func
(paren
id|klimit
)paren
comma
(paren
id|new_klimit
op_minus
id|klimit
)paren
)paren
suffix:semicolon
id|klimit
op_assign
id|new_klimit
suffix:semicolon
id|memset
c_func
(paren
id|dprof_buffer
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
)brace
id|iSeries_setup_dprofile
c_func
(paren
)paren
suffix:semicolon
id|iSeries_proc_early_init
c_func
(paren
)paren
suffix:semicolon
id|mf_init
c_func
(paren
)paren
suffix:semicolon
id|mf_initialized
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|iSeries_proc_callback
c_func
(paren
op_amp
id|pmc_proc_init
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPC_ISERIES
multiline_comment|/*&n; * The iSeries may have very large memories ( &gt; 128 GB ) and a partition&n; * may get memory in &quot;chunks&quot; that may be anywhere in the 2**52 real&n; * address space.  The chunks are 256K in size.  To map this to the &n; * memory model Linux expects, the AS/400 specific code builds a &n; * translation table to translate what Linux thinks are &quot;physical&quot;&n; * addresses to the actual real addresses.  This allows us to make &n; * it appear to Linux that we have contiguous memory starting at&n; * physical address zero while in fact this could be far from the truth.&n; * To avoid confusion, I&squot;ll let the words physical and/or real address &n; * apply to the Linux addresses while I&squot;ll use &quot;absolute address&quot; to &n; * refer to the actual hardware real address.&n; *&n; * build_iSeries_Memory_Map gets information from the Hypervisor and &n; * looks at the Main Store VPD to determine the absolute addresses&n; * of the memory that has been assigned to our partition and builds&n; * a table used to translate Linux&squot;s physical addresses to these&n; * absolute addresses.  Absolute addresses are needed when &n; * communicating with the hypervisor (e.g. to build HPT entries)&n; */
DECL|function|build_iSeries_Memory_Map
r_static
r_void
id|__init
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
(brace
id|u32
id|loadAreaFirstChunk
comma
id|loadAreaLastChunk
comma
id|loadAreaSize
suffix:semicolon
id|u32
id|nextPhysChunk
suffix:semicolon
id|u32
id|hptFirstChunk
comma
id|hptLastChunk
comma
id|hptSizeChunks
comma
id|hptSizePages
suffix:semicolon
id|u32
id|num_ptegs
suffix:semicolon
id|u32
id|totalChunks
comma
id|moreChunks
suffix:semicolon
id|u32
id|currChunk
comma
id|thisChunk
comma
id|absChunk
suffix:semicolon
id|u32
id|currDword
suffix:semicolon
id|u32
id|chunkBit
suffix:semicolon
id|u64
id|map
suffix:semicolon
r_struct
id|MemoryBlock
id|mb
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|numMemoryBlocks
comma
id|curBlock
suffix:semicolon
multiline_comment|/* Chunk size on iSeries is 256K bytes */
id|totalChunks
op_assign
(paren
id|u32
)paren
id|HvLpConfig_getMsChunks
c_func
(paren
)paren
suffix:semicolon
id|klimit
op_assign
id|msChunks_alloc
c_func
(paren
id|klimit
comma
id|totalChunks
comma
l_int|1UL
op_lshift
l_int|18
)paren
suffix:semicolon
multiline_comment|/* Get absolute address of our load area&n;&t; * and map it to physical address 0&n;&t; * This guarantees that the loadarea ends up at physical 0&n;&t; * otherwise, it might not be returned by PLIC as the first&n;&t; * chunks&n;&t; */
id|loadAreaFirstChunk
op_assign
(paren
id|u32
)paren
id|addr_to_chunk
c_func
(paren
id|itLpNaca.xLoadAreaAddr
)paren
suffix:semicolon
id|loadAreaSize
op_assign
id|itLpNaca.xLoadAreaChunks
suffix:semicolon
multiline_comment|/* Only add the pages already mapped here.  &n;&t; * Otherwise we might add the hpt pages &n;&t; * The rest of the pages of the load area&n;&t; * aren&squot;t in the HPT yet and can still&n;&t; * be assigned an arbitrary physical address&n;&t; */
r_if
c_cond
(paren
(paren
id|loadAreaSize
op_star
l_int|64
)paren
OG
id|HvPagesToMap
)paren
id|loadAreaSize
op_assign
id|HvPagesToMap
op_div
l_int|64
suffix:semicolon
id|loadAreaLastChunk
op_assign
id|loadAreaFirstChunk
op_plus
id|loadAreaSize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* TODO Do we need to do something if the HPT is in the 64MB load area?&n;&t; * This would be required if the itLpNaca.xLoadAreaChunks includes &n;&t; * the HPT size&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Mapping load area - physical addr = 0000000000000000&bslash;n&quot;
l_string|&quot;                    absolute addr = %016lx&bslash;n&quot;
comma
id|chunk_to_addr
c_func
(paren
id|loadAreaFirstChunk
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Load area size %dK&bslash;n&quot;
comma
id|loadAreaSize
op_star
l_int|256
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nextPhysChunk
op_assign
l_int|0
suffix:semicolon
id|nextPhysChunk
OL
id|loadAreaSize
suffix:semicolon
op_increment
id|nextPhysChunk
)paren
(brace
id|msChunks.abs
(braket
id|nextPhysChunk
)braket
op_assign
id|loadAreaFirstChunk
op_plus
id|nextPhysChunk
suffix:semicolon
)brace
multiline_comment|/* Get absolute address of our HPT and remember it so&n;&t; * we won&squot;t map it to any physical address&n;&t; */
id|hptFirstChunk
op_assign
(paren
id|u32
)paren
id|addr_to_chunk
c_func
(paren
id|HvCallHpt_getHptAddress
c_func
(paren
)paren
)paren
suffix:semicolon
id|hptSizePages
op_assign
(paren
id|u32
)paren
(paren
id|HvCallHpt_getHptPages
c_func
(paren
)paren
)paren
suffix:semicolon
id|hptSizeChunks
op_assign
id|hptSizePages
op_rshift
(paren
id|msChunks.chunk_shift
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
id|hptLastChunk
op_assign
id|hptFirstChunk
op_plus
id|hptSizeChunks
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HPT absolute addr = %016lx, size = %dK&bslash;n&quot;
comma
id|chunk_to_addr
c_func
(paren
id|hptFirstChunk
)paren
comma
id|hptSizeChunks
op_star
l_int|256
)paren
suffix:semicolon
multiline_comment|/* Fill in the htab_data structure */
multiline_comment|/* Fill in size of hashed page table */
id|num_ptegs
op_assign
id|hptSizePages
op_star
(paren
id|PAGE_SIZE
op_div
(paren
r_sizeof
(paren
id|HPTE
)paren
op_star
id|HPTES_PER_GROUP
)paren
)paren
suffix:semicolon
id|htab_data.htab_num_ptegs
op_assign
id|num_ptegs
suffix:semicolon
id|htab_data.htab_hash_mask
op_assign
id|num_ptegs
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* The actual hashed page table is in the hypervisor, we have no direct access */
id|htab_data.htab
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Determine if absolute memory has any&n;&t; * holes so that we can interpret the&n;&t; * access map we get back from the hypervisor&n;&t; * correctly.&n;&t; */
id|numMemoryBlocks
op_assign
id|iSeries_process_mainstore_vpd
c_func
(paren
id|mb
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/* Process the main store access map from the hypervisor&n;&t; * to build up our physical -&gt; absolute translation table&n;&t; */
id|curBlock
op_assign
l_int|0
suffix:semicolon
id|currChunk
op_assign
l_int|0
suffix:semicolon
id|currDword
op_assign
l_int|0
suffix:semicolon
id|moreChunks
op_assign
id|totalChunks
suffix:semicolon
r_while
c_loop
(paren
id|moreChunks
)paren
(brace
id|map
op_assign
id|HvCallSm_get64BitsOfAccessMap
c_func
(paren
id|itLpNaca.xLpIndex
comma
id|currDword
)paren
suffix:semicolon
id|thisChunk
op_assign
id|currChunk
suffix:semicolon
r_while
c_loop
(paren
id|map
)paren
(brace
id|chunkBit
op_assign
id|map
op_rshift
l_int|63
suffix:semicolon
id|map
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|chunkBit
)paren
(brace
op_decrement
id|moreChunks
suffix:semicolon
r_while
c_loop
(paren
id|thisChunk
op_ge
id|mb
(braket
id|curBlock
)braket
dot
id|logicalEnd
)paren
(brace
op_increment
id|curBlock
suffix:semicolon
r_if
c_cond
(paren
id|curBlock
op_ge
id|numMemoryBlocks
)paren
id|panic
c_func
(paren
l_string|&quot;out of memory blocks&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thisChunk
OL
id|mb
(braket
id|curBlock
)braket
dot
id|logicalStart
)paren
id|panic
c_func
(paren
l_string|&quot;memory block error&quot;
)paren
suffix:semicolon
id|absChunk
op_assign
id|mb
(braket
id|curBlock
)braket
dot
id|absStart
op_plus
(paren
id|thisChunk
op_minus
id|mb
(braket
id|curBlock
)braket
dot
id|logicalStart
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|absChunk
OL
id|hptFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|hptLastChunk
)paren
)paren
op_logical_and
(paren
(paren
id|absChunk
OL
id|loadAreaFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|loadAreaLastChunk
)paren
)paren
)paren
(brace
id|msChunks.abs
(braket
id|nextPhysChunk
)braket
op_assign
id|absChunk
suffix:semicolon
op_increment
id|nextPhysChunk
suffix:semicolon
)brace
)brace
op_increment
id|thisChunk
suffix:semicolon
)brace
op_increment
id|currDword
suffix:semicolon
id|currChunk
op_add_assign
l_int|64
suffix:semicolon
)brace
multiline_comment|/* main store size (in chunks) is &n;&t; *   totalChunks - hptSizeChunks&n;&t; * which should be equal to &n;&t; *   nextPhysChunk&n;&t; */
id|naca-&gt;physicalMemorySize
op_assign
id|chunk_to_addr
c_func
(paren
id|nextPhysChunk
)paren
suffix:semicolon
multiline_comment|/* Bolt kernel mappings for all of memory */
id|iSeries_bolt_kernel
c_func
(paren
l_int|0
comma
id|naca-&gt;physicalMemorySize
)paren
suffix:semicolon
id|lmb_init
c_func
(paren
)paren
suffix:semicolon
id|lmb_add
c_func
(paren
l_int|0
comma
id|naca-&gt;physicalMemorySize
)paren
suffix:semicolon
id|lmb_analyze
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ?? */
id|lmb_reserve
c_func
(paren
l_int|0
comma
id|__pa
c_func
(paren
id|klimit
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Hardcode to GP size.  I am not sure where to get this info. DRENG&n;&t; */
id|naca-&gt;slb_size
op_assign
l_int|64
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the variables that describe the cache line sizes&n; * for this machine.&n; */
DECL|function|setup_iSeries_cache_sizes
r_static
r_void
id|__init
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_int
id|procIx
op_assign
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|xLpPaca.xDynHvPhysicalProcIndex
suffix:semicolon
id|naca-&gt;iCacheL1LineSize
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xInstCacheOperandSize
suffix:semicolon
id|naca-&gt;dCacheL1LineSize
op_assign
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xDataCacheOperandSize
suffix:semicolon
id|naca-&gt;iCacheL1LinesPerPage
op_assign
id|PAGE_SIZE
op_div
id|naca-&gt;iCacheL1LineSize
suffix:semicolon
id|naca-&gt;dCacheL1LinesPerPage
op_assign
id|PAGE_SIZE
op_div
id|naca-&gt;dCacheL1LineSize
suffix:semicolon
id|i
op_assign
id|naca-&gt;iCacheL1LineSize
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|naca-&gt;iCacheL1LogLineSize
op_assign
id|n
suffix:semicolon
id|i
op_assign
id|naca-&gt;dCacheL1LineSize
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|naca-&gt;dCacheL1LogLineSize
op_assign
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;D-cache line size = %d  (log = %d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|naca-&gt;dCacheL1LineSize
comma
(paren
r_int
)paren
id|naca-&gt;dCacheL1LogLineSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I-cache line size = %d  (log = %d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|naca-&gt;iCacheL1LineSize
comma
(paren
r_int
)paren
id|naca-&gt;iCacheL1LogLineSize
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bolt the kernel addr space into the HPT&n; */
DECL|function|iSeries_bolt_kernel
r_static
r_void
id|__init
id|iSeries_bolt_kernel
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|eaddr
)paren
(brace
r_int
r_int
id|pa
suffix:semicolon
r_int
r_int
id|mode_rw
op_assign
id|_PAGE_ACCESSED
op_or
id|_PAGE_COHERENT
op_or
id|PP_RWXX
suffix:semicolon
id|HPTE
id|hpte
suffix:semicolon
r_for
c_loop
(paren
id|pa
op_assign
id|saddr
suffix:semicolon
id|pa
OL
id|eaddr
suffix:semicolon
id|pa
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_int
r_int
id|ea
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|pa
)paren
suffix:semicolon
r_int
r_int
id|vsid
op_assign
id|get_kernel_vsid
c_func
(paren
id|ea
)paren
suffix:semicolon
r_int
r_int
id|va
op_assign
(paren
id|vsid
op_lshift
l_int|28
)paren
op_or
(paren
id|pa
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
r_int
r_int
id|vpn
op_assign
id|va
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
r_int
id|slot
op_assign
id|HvCallHpt_findValid
c_func
(paren
op_amp
id|hpte
comma
id|vpn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hpte.dw0.dw0.v
)paren
(brace
multiline_comment|/* HPTE exists, so just bolt it */
id|HvCallHpt_setSwBits
c_func
(paren
id|slot
comma
l_int|0x10
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No HPTE exists, so create a new bolted one */
id|build_valid_hpte
c_func
(paren
id|vsid
comma
id|ea
comma
id|pa
comma
l_int|NULL
comma
id|mode_rw
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_PPC_ISERIES */
r_extern
r_int
r_int
id|ppc_proc_freq
suffix:semicolon
r_extern
r_int
r_int
id|ppc_tb_freq
suffix:semicolon
multiline_comment|/*&n; * Document me.&n; */
r_void
id|__init
DECL|function|iSeries_setup_arch
id|iSeries_setup_arch
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|eventStack
suffix:semicolon
r_int
id|procIx
op_assign
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|xLpPaca.xDynHvPhysicalProcIndex
suffix:semicolon
multiline_comment|/* Setup the Lp Event Queue */
multiline_comment|/* Allocate a page for the Event Stack&n;&t; * The hypervisor wants the absolute real address, so&n;&t; * we subtract out the KERNELBASE and add in the&n;&t; * absolute real address of the kernel load area&n;&t; */
id|eventStack
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|LpEventStackSize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|eventStack
comma
l_int|0
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Invoke the hypervisor to initialize the event stack */
id|HvCallEvent_setLpEventStack
c_func
(paren
l_int|0
comma
id|eventStack
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Initialize fields in our Lp Event Queue */
id|xItLpQueue.xSlicEventStackPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xSlicCurEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xSlicLastValidEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
op_plus
(paren
id|LpEventStackSize
op_minus
id|LpEventMaxSize
)paren
suffix:semicolon
id|xItLpQueue.xIndex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute processor frequency */
id|procFreqHz
op_assign
(paren
(paren
(paren
l_int|1UL
op_lshift
l_int|34
)paren
op_star
l_int|1000000
)paren
op_div
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xProcFreq
)paren
suffix:semicolon
id|procFreqMhz
op_assign
id|procFreqHz
op_div
l_int|1000000
suffix:semicolon
id|procFreqMhzHundreths
op_assign
(paren
id|procFreqHz
op_div
l_int|10000
)paren
op_minus
(paren
id|procFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
id|ppc_proc_freq
op_assign
id|procFreqHz
suffix:semicolon
multiline_comment|/* Compute time base frequency */
id|tbFreqHz
op_assign
(paren
(paren
(paren
l_int|1UL
op_lshift
l_int|32
)paren
op_star
l_int|1000000
)paren
op_div
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xTimeBaseFreq
)paren
suffix:semicolon
id|tbFreqMhz
op_assign
id|tbFreqHz
op_div
l_int|1000000
suffix:semicolon
id|tbFreqMhzHundreths
op_assign
(paren
id|tbFreqHz
op_div
l_int|10000
)paren
op_minus
(paren
id|tbFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
id|ppc_tb_freq
op_assign
id|tbFreqHz
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max  logical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxLogicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max physical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxPhysicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor frequency = %lu.%02lu&bslash;n&quot;
comma
id|procFreqMhz
comma
id|procFreqMhzHundreths
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Time base frequency = %lu.%02lu&bslash;n&quot;
comma
id|tbFreqMhz
comma
id|tbFreqMhzHundreths
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor version = %x&bslash;n&quot;
comma
id|xIoHriProcessorVpd
(braket
id|procIx
)braket
dot
id|xPVR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * int as400_setup_residual()&n; *&n; * Description:&n; *   This routine pretty-prints CPU information gathered from the VPD    &n; *   for use in /proc/cpuinfo                               &n; *&n; * Input(s):&n; *  *buffer - Buffer into which CPU data is to be printed.             &n; *&n; * Output(s):&n; *  *buffer - Buffer with CPU data.&n; *&n; * Returns:&n; *   The number of bytes copied into &squot;buffer&squot; if OK, otherwise zero or less&n; *   on error.&n; */
DECL|function|iSeries_setup_residual
r_void
id|iSeries_setup_residual
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;clock&bslash;t&bslash;t: %lu.%02luMhz&bslash;n&quot;
comma
id|procFreqMhz
comma
id|procFreqMhzHundreths
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;time base&bslash;t: %lu.%02luMHz&bslash;n&quot;
comma
id|tbFreqMhz
comma
id|tbFreqMhzHundreths
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;i-cache&bslash;t&bslash;t: %d&bslash;n&quot;
comma
id|naca-&gt;iCacheL1LineSize
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;d-cache&bslash;t&bslash;t: %d&bslash;n&quot;
comma
id|naca-&gt;dCacheL1LineSize
)paren
suffix:semicolon
)brace
DECL|function|iSeries_get_cpuinfo
r_void
id|iSeries_get_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;machine&bslash;t&bslash;t: 64-bit iSeries Logical Partition&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; * and Implement me.&n; */
r_int
DECL|function|iSeries_get_irq
id|iSeries_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* -2 means ignore this interrupt */
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_restart
id|iSeries_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
id|mf_reboot
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_power_off
id|iSeries_power_off
c_func
(paren
r_void
)paren
(brace
id|mf_powerOff
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_halt
id|iSeries_halt
c_func
(paren
r_void
)paren
(brace
id|mf_powerOff
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Nothing to do here.&n; */
r_void
id|__init
DECL|function|iSeries_time_init
id|iSeries_time_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing to do */
)brace
multiline_comment|/* JDH Hack */
DECL|variable|jdh_time
r_int
r_int
id|jdh_time
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|setup_default_decr
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * void __init iSeries_calibrate_decr()&n; *&n; * Description:&n; *   This routine retrieves the internal processor frequency from the VPD,&n; *   and sets up the kernel timer decrementer based on that value.&n; *&n; */
r_void
id|__init
DECL|function|iSeries_calibrate_decr
id|iSeries_calibrate_decr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cyclesPerUsec
suffix:semicolon
r_struct
id|div_result
id|divres
suffix:semicolon
multiline_comment|/* Compute decrementer (and TB) frequency &n;&t; * in cycles/sec &n;&t; */
id|cyclesPerUsec
op_assign
id|ppc_tb_freq
op_div
l_int|1000000
suffix:semicolon
multiline_comment|/* cycles / usec */
multiline_comment|/* Set the amount to refresh the decrementer by.  This&n;&t; * is the number of decrementer ticks it takes for &n;&t; * 1/HZ seconds.&n;&t; */
id|tb_ticks_per_jiffy
op_assign
id|ppc_tb_freq
op_div
id|HZ
suffix:semicolon
macro_line|#if 0
multiline_comment|/* TEST CODE FOR ADJTIME */
id|tb_ticks_per_jiffy
op_add_assign
id|tb_ticks_per_jiffy
op_div
l_int|5000
suffix:semicolon
multiline_comment|/* END OF TEST CODE */
macro_line|#endif
multiline_comment|/*&n;&t; * tb_ticks_per_sec = freq; would give better accuracy&n;&t; * but tb_ticks_per_sec = tb_ticks_per_jiffy*HZ; assures&n;&t; * that jiffies (and xtime) will match the time returned&n;&t; * by do_gettimeofday.&n;&t; */
id|tb_ticks_per_sec
op_assign
id|tb_ticks_per_jiffy
op_star
id|HZ
suffix:semicolon
id|tb_ticks_per_usec
op_assign
id|cyclesPerUsec
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|ppc_tb_freq
comma
l_int|1000000
)paren
suffix:semicolon
id|div128_by_32
c_func
(paren
l_int|1024
op_star
l_int|1024
comma
l_int|0
comma
id|tb_ticks_per_sec
comma
op_amp
id|divres
)paren
suffix:semicolon
id|tb_to_xs
op_assign
id|divres.result_low
suffix:semicolon
id|setup_default_decr
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|iSeries_progress
id|iSeries_progress
c_func
(paren
r_char
op_star
id|st
comma
r_int
r_int
id|code
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Progress: [%04x] - %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|code
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|piranha_simulator
op_logical_and
id|mf_initialized
)paren
(brace
r_if
c_cond
(paren
id|code
op_ne
l_int|0xffff
)paren
id|mf_displayProgress
c_func
(paren
id|code
)paren
suffix:semicolon
r_else
id|mf_clearSrc
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|iSeries_fixup_klimit
r_void
id|iSeries_fixup_klimit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Change klimit to take into account any ram disk that may be included */
r_if
c_cond
(paren
id|naca-&gt;xRamDisk
)paren
id|klimit
op_assign
id|KERNELBASE
op_plus
(paren
id|u64
)paren
id|naca-&gt;xRamDisk
op_plus
(paren
id|naca-&gt;xRamDiskSize
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* No ram disk was included - check and see if there was an embedded system map */
multiline_comment|/* Change klimit to take into account any embedded system map */
r_if
c_cond
(paren
id|embedded_sysmap_end
)paren
id|klimit
op_assign
id|KERNELBASE
op_plus
(paren
(paren
id|embedded_sysmap_end
op_plus
l_int|4095
)paren
op_amp
l_int|0xfffffffffffff000
)paren
suffix:semicolon
)brace
)brace
DECL|function|iSeries_setup_dprofile
r_static
r_void
id|iSeries_setup_dprofile
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|dprof_buffer
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PACAS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|paca
(braket
id|i
)braket
dot
id|prof_shift
op_assign
id|dprof_shift
suffix:semicolon
id|paca
(braket
id|i
)braket
dot
id|prof_len
op_assign
id|dprof_len
op_minus
l_int|1
suffix:semicolon
id|paca
(braket
id|i
)braket
dot
id|prof_buffer
op_assign
id|dprof_buffer
suffix:semicolon
id|paca
(braket
id|i
)braket
dot
id|prof_stext
op_assign
(paren
r_int
op_star
)paren
op_amp
id|_stext
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|paca
(braket
id|i
)braket
dot
id|prof_enabled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
eof
