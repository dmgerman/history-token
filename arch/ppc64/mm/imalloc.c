multiline_comment|/*&n; * c 2001 PPC 64 Team, IBM Corp&n; * &n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
r_static
id|DECLARE_MUTEX
c_func
(paren
id|imlist_sem
)paren
suffix:semicolon
DECL|variable|imlist
r_struct
id|vm_struct
op_star
id|imlist
op_assign
l_int|NULL
suffix:semicolon
DECL|function|get_free_im_addr
r_static
r_int
id|get_free_im_addr
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
op_star
id|im_addr
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|vm_struct
op_star
op_star
id|p
comma
op_star
id|tmp
suffix:semicolon
id|addr
op_assign
id|IMALLOC_START
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|imlist
suffix:semicolon
(paren
id|tmp
op_assign
op_star
id|p
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|tmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|size
op_plus
id|addr
OL
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
op_ge
id|IMALLOC_START
)paren
id|addr
op_assign
id|tmp-&gt;size
op_plus
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|IMALLOC_END
op_minus
id|size
)paren
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|im_addr
op_assign
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Return whether the region described by v_addr and size overlaps&n; * the region described by vm.  Overlapping regions meet the &n; * following conditions:&n; * 1) The regions share some part of the address space&n; * 2) The regions aren&squot;t identical&n; * 3) The first region is not a subset of the second&n; */
DECL|function|im_region_overlaps
r_static
r_inline
r_int
id|im_region_overlaps
c_func
(paren
r_int
r_int
id|v_addr
comma
r_int
r_int
id|size
comma
r_struct
id|vm_struct
op_star
id|vm
)paren
(brace
r_return
(paren
id|v_addr
op_plus
id|size
OG
(paren
r_int
r_int
)paren
id|vm-&gt;addr
op_plus
id|vm-&gt;size
op_logical_and
id|v_addr
OL
(paren
r_int
r_int
)paren
id|vm-&gt;addr
op_plus
id|vm-&gt;size
)paren
op_logical_or
(paren
id|v_addr
template_param
(paren
r_int
r_int
)paren
id|vm-&gt;addr
)paren
suffix:semicolon
)brace
multiline_comment|/* Return whether the region described by v_addr and size is a subset&n; * of the region described by vm&n; */
DECL|function|im_region_is_subset
r_static
r_inline
r_int
id|im_region_is_subset
c_func
(paren
r_int
r_int
id|v_addr
comma
r_int
r_int
id|size
comma
r_struct
id|vm_struct
op_star
id|vm
)paren
(brace
r_return
(paren
r_int
)paren
(paren
id|v_addr
op_ge
(paren
r_int
r_int
)paren
id|vm-&gt;addr
op_logical_and
id|v_addr
OL
(paren
r_int
r_int
)paren
id|vm-&gt;addr
op_plus
id|vm-&gt;size
op_logical_and
id|size
OL
id|vm-&gt;size
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine imalloc status of region described by v_addr and size.&n; * Can return one of the following:&n; * IM_REGION_UNUSED   -  Entire region is unallocated in imalloc space.&n; * IM_REGION_SUBSET -    Region is a subset of a region that is already&n; * &t;&t;&t; allocated in imalloc space.&n; * &t;&t;         vm will be assigned to a ptr to the parent region.&n; * IM_REGION_EXISTS -    Exact region already allocated in imalloc space.&n; *                       vm will be assigned to a ptr to the existing imlist&n; *                       member.&n; * IM_REGION_OVERLAPS -  A portion of the region is already allocated in &n; *                       imalloc space.&n; */
DECL|function|im_region_status
r_static
r_int
id|im_region_status
c_func
(paren
r_int
r_int
id|v_addr
comma
r_int
r_int
id|size
comma
r_struct
id|vm_struct
op_star
op_star
id|vm
)paren
(brace
r_struct
id|vm_struct
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|imlist
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
id|v_addr
OL
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
op_plus
id|tmp-&gt;size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|im_region_overlaps
c_func
(paren
id|v_addr
comma
id|size
comma
id|tmp
)paren
)paren
r_return
id|IM_REGION_OVERLAP
suffix:semicolon
op_star
id|vm
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|im_region_is_subset
c_func
(paren
id|v_addr
comma
id|size
comma
id|tmp
)paren
)paren
r_return
id|IM_REGION_SUBSET
suffix:semicolon
r_else
r_if
c_cond
(paren
id|v_addr
op_eq
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
op_logical_and
id|size
op_eq
id|tmp-&gt;size
)paren
r_return
id|IM_REGION_EXISTS
suffix:semicolon
)brace
op_star
id|vm
op_assign
l_int|NULL
suffix:semicolon
r_return
id|IM_REGION_UNUSED
suffix:semicolon
)brace
DECL|function|split_im_region
r_static
r_struct
id|vm_struct
op_star
id|split_im_region
c_func
(paren
r_int
r_int
id|v_addr
comma
r_int
r_int
id|size
comma
r_struct
id|vm_struct
op_star
id|parent
)paren
(brace
r_struct
id|vm_struct
op_star
id|vm1
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_struct
op_star
id|vm2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_struct
op_star
id|new_vm
op_assign
l_int|NULL
suffix:semicolon
id|vm1
op_assign
(paren
r_struct
id|vm_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|vm1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm1
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s() out of memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v_addr
op_eq
(paren
r_int
r_int
)paren
id|parent-&gt;addr
)paren
(brace
multiline_comment|/* Use existing parent vm_struct to represent child, allocate&n;&t;&t; * new one for the remainder of parent range&n;&t;&t; */
id|vm1-&gt;size
op_assign
id|parent-&gt;size
op_minus
id|size
suffix:semicolon
id|vm1-&gt;addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|v_addr
op_plus
id|size
)paren
suffix:semicolon
id|vm1-&gt;next
op_assign
id|parent-&gt;next
suffix:semicolon
id|parent-&gt;size
op_assign
id|size
suffix:semicolon
id|parent-&gt;next
op_assign
id|vm1
suffix:semicolon
id|new_vm
op_assign
id|parent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v_addr
op_plus
id|size
op_eq
(paren
r_int
r_int
)paren
id|parent-&gt;addr
op_plus
id|parent-&gt;size
)paren
(brace
multiline_comment|/* Allocate new vm_struct to represent child, use existing&n;&t;&t; * parent one for remainder of parent range&n;&t;&t; */
id|vm1-&gt;size
op_assign
id|size
suffix:semicolon
id|vm1-&gt;addr
op_assign
(paren
r_void
op_star
)paren
id|v_addr
suffix:semicolon
id|vm1-&gt;next
op_assign
id|parent-&gt;next
suffix:semicolon
id|new_vm
op_assign
id|vm1
suffix:semicolon
id|parent-&gt;size
op_sub_assign
id|size
suffix:semicolon
id|parent-&gt;next
op_assign
id|vm1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Allocate two new vm_structs for the new child and &n;&t;&t; * uppermost remainder, and use existing parent one for the&n;&t;&t; * lower remainder of parent range&n;&t;&t; */
id|vm2
op_assign
(paren
r_struct
id|vm_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|vm2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm2
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s() out of memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vm1
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|vm1-&gt;size
op_assign
id|size
suffix:semicolon
id|vm1-&gt;addr
op_assign
(paren
r_void
op_star
)paren
id|v_addr
suffix:semicolon
id|vm1-&gt;next
op_assign
id|vm2
suffix:semicolon
id|new_vm
op_assign
id|vm1
suffix:semicolon
id|vm2-&gt;size
op_assign
(paren
(paren
r_int
r_int
)paren
id|parent-&gt;addr
op_plus
id|parent-&gt;size
)paren
op_minus
(paren
id|v_addr
op_plus
id|size
)paren
suffix:semicolon
id|vm2-&gt;addr
op_assign
(paren
r_void
op_star
)paren
id|v_addr
op_plus
id|size
suffix:semicolon
id|vm2-&gt;next
op_assign
id|parent-&gt;next
suffix:semicolon
id|parent-&gt;size
op_assign
id|v_addr
op_minus
(paren
r_int
r_int
)paren
id|parent-&gt;addr
suffix:semicolon
id|parent-&gt;next
op_assign
id|vm1
suffix:semicolon
)brace
r_return
id|new_vm
suffix:semicolon
)brace
DECL|function|__add_new_im_area
r_static
r_struct
id|vm_struct
op_star
id|__add_new_im_area
c_func
(paren
r_int
r_int
id|req_addr
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|vm_struct
op_star
op_star
id|p
comma
op_star
id|tmp
comma
op_star
id|area
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|imlist
suffix:semicolon
(paren
id|tmp
op_assign
op_star
id|p
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|tmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|req_addr
op_plus
id|size
op_le
(paren
r_int
r_int
)paren
id|tmp-&gt;addr
)paren
r_break
suffix:semicolon
)brace
id|area
op_assign
(paren
r_struct
id|vm_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|area
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|area
)paren
r_return
l_int|NULL
suffix:semicolon
id|area-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|area-&gt;addr
op_assign
(paren
r_void
op_star
)paren
id|req_addr
suffix:semicolon
id|area-&gt;size
op_assign
id|size
suffix:semicolon
id|area-&gt;next
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_assign
id|area
suffix:semicolon
r_return
id|area
suffix:semicolon
)brace
DECL|function|__im_get_area
r_static
r_struct
id|vm_struct
op_star
id|__im_get_area
c_func
(paren
r_int
r_int
id|req_addr
comma
r_int
r_int
id|size
comma
r_int
id|criteria
)paren
(brace
r_struct
id|vm_struct
op_star
id|tmp
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|im_region_status
c_func
(paren
id|req_addr
comma
id|size
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|criteria
op_amp
id|status
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|IM_REGION_UNUSED
suffix:colon
id|tmp
op_assign
id|__add_new_im_area
c_func
(paren
id|req_addr
comma
id|size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IM_REGION_SUBSET
suffix:colon
id|tmp
op_assign
id|split_im_region
c_func
(paren
id|req_addr
comma
id|size
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IM_REGION_EXISTS
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s() unexpected imalloc region status&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|im_get_free_area
r_struct
id|vm_struct
op_star
id|im_get_free_area
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|down
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_free_im_addr
c_func
(paren
id|size
comma
op_amp
id|addr
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s() cannot obtain addr for size 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
)paren
suffix:semicolon
id|area
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|next_im_done
suffix:semicolon
)brace
id|area
op_assign
id|__im_get_area
c_func
(paren
id|addr
comma
id|size
comma
id|IM_REGION_UNUSED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s() cannot obtain area for addr 0x%lx size 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
id|next_im_done
suffix:colon
id|up
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
r_return
id|area
suffix:semicolon
)brace
DECL|function|im_get_area
r_struct
id|vm_struct
op_star
id|im_get_area
c_func
(paren
r_int
r_int
id|v_addr
comma
r_int
r_int
id|size
comma
r_int
id|criteria
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
id|down
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
id|area
op_assign
id|__im_get_area
c_func
(paren
id|v_addr
comma
id|size
comma
id|criteria
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
r_return
id|area
suffix:semicolon
)brace
DECL|function|im_free
r_int
r_int
id|im_free
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_struct
id|vm_struct
op_star
op_star
id|p
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|ret_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
id|ret_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
(paren
r_int
r_int
)paren
id|addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to %s bad address (%p)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|addr
)paren
suffix:semicolon
r_return
id|ret_size
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|imlist
suffix:semicolon
(paren
id|tmp
op_assign
op_star
id|p
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|tmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;addr
op_eq
id|addr
)paren
(brace
id|ret_size
op_assign
id|tmp-&gt;size
suffix:semicolon
op_star
id|p
op_assign
id|tmp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
r_return
id|ret_size
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|imlist_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to %s nonexistent area (%p)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|addr
)paren
suffix:semicolon
r_return
id|ret_size
suffix:semicolon
)brace
eof
