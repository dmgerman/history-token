multiline_comment|/*&n; * Copyright (C) 1996 Paul Mackerras.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
multiline_comment|/* Transition to udbg isn&squot;t quite done yet...but very close. */
DECL|macro|USE_UDBG
mdefine_line|#define USE_UDBG
macro_line|#ifdef USE_UDBG
macro_line|#include &lt;asm/udbg.h&gt;
macro_line|#endif
macro_line|#ifndef USE_UDBG
DECL|variable|sccc
DECL|variable|sccd
r_static
r_volatile
r_int
r_char
op_star
id|sccc
comma
op_star
id|sccd
suffix:semicolon
macro_line|#endif
DECL|variable|TXRDY
DECL|variable|RXRDY
r_int
r_int
id|TXRDY
comma
id|RXRDY
suffix:semicolon
r_extern
r_void
id|xmon_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_int
id|xmon_expect
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
macro_line|#ifndef USE_UDBG
DECL|variable|console
r_static
r_int
id|console
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|via_modem
r_static
r_int
id|via_modem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* static int xmon_use_sccb = 0;  --Unused */
DECL|macro|TB_SPEED
mdefine_line|#define TB_SPEED&t;25000000
r_extern
r_void
op_star
id|comport1
suffix:semicolon
DECL|function|readtb
r_static
r_inline
r_int
r_int
id|readtb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mftb %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef USE_UDBG
DECL|function|buf_access
r_void
id|buf_access
c_func
(paren
r_void
)paren
(brace
id|sccd
(braket
l_int|3
)braket
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
multiline_comment|/* reset DLAB */
)brace
macro_line|#endif
DECL|function|sysrq_handle_xmon
r_static
r_void
id|sysrq_handle_xmon
c_func
(paren
r_int
id|key
comma
r_struct
id|pt_regs
op_star
id|pt_regs
comma
r_struct
id|kbd_struct
op_star
id|kbd
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|xmon
c_func
(paren
id|pt_regs
)paren
suffix:semicolon
)brace
DECL|variable|sysrq_xmon_op
r_static
r_struct
id|sysrq_key_op
id|sysrq_xmon_op
op_assign
(brace
id|handler
suffix:colon
id|sysrq_handle_xmon
comma
id|help_msg
suffix:colon
l_string|&quot;xmon&quot;
comma
id|action_msg
suffix:colon
l_string|&quot;Entering xmon&bslash;n&quot;
comma
)brace
suffix:semicolon
r_void
DECL|function|xmon_map_scc
id|xmon_map_scc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* This maybe isn&squot;t the best place to register sysrq &squot;x&squot; */
id|__sysrq_put_key_op
c_func
(paren
l_char|&squot;x&squot;
comma
op_amp
id|sysrq_xmon_op
)paren
suffix:semicolon
macro_line|#ifndef USE_UDBG
multiline_comment|/* should already be mapped by the kernel boot */
id|sccd
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|comport1
)paren
)paren
suffix:semicolon
id|sccc
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|comport1
)paren
op_plus
l_int|5
)paren
suffix:semicolon
id|TXRDY
op_assign
l_int|0x20
suffix:semicolon
id|RXRDY
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|scc_initialized
r_static
r_int
id|scc_initialized
op_assign
l_int|0
suffix:semicolon
r_void
id|xmon_init_scc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pmu_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
DECL|function|xmon_write
id|xmon_write
c_func
(paren
r_void
op_star
id|handle
comma
r_void
op_star
id|ptr
comma
r_int
id|nb
)paren
(brace
macro_line|#ifdef USE_UDBG
r_return
id|udbg_write
c_func
(paren
id|ptr
comma
id|nb
)paren
suffix:semicolon
macro_line|#else
r_char
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_int
id|i
comma
id|c
comma
id|ct
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc_initialized
)paren
id|xmon_init_scc
c_func
(paren
)paren
suffix:semicolon
id|ct
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|sccc
op_amp
id|TXRDY
)paren
op_eq
l_int|0
)paren
(brace
)brace
id|c
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|ct
)paren
(brace
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
op_decrement
id|i
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|console
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|c
)paren
suffix:semicolon
id|ct
op_assign
l_int|0
suffix:semicolon
)brace
id|buf_access
c_func
(paren
)paren
suffix:semicolon
op_star
id|sccd
op_assign
id|c
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|xmon_wants_key
r_int
id|xmon_wants_key
suffix:semicolon
r_int
DECL|function|xmon_read
id|xmon_read
c_func
(paren
r_void
op_star
id|handle
comma
r_void
op_star
id|ptr
comma
r_int
id|nb
)paren
(brace
macro_line|#ifdef USE_UDBG
r_return
id|udbg_read
c_func
(paren
id|ptr
comma
id|nb
)paren
suffix:semicolon
macro_line|#else
r_char
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc_initialized
)paren
id|xmon_init_scc
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
(brace
r_do
(brace
r_while
c_loop
(paren
(paren
op_star
id|sccc
op_amp
id|RXRDY
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|buf_access
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
op_star
id|sccd
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_eq
l_int|0x11
op_logical_or
id|c
op_eq
l_int|0x13
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|xmon_read_poll
id|xmon_read_poll
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef USE_UDBG
r_return
id|udbg_getc_poll
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
op_star
id|sccc
op_amp
id|RXRDY
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|buf_access
c_func
(paren
)paren
suffix:semicolon
r_return
op_star
id|sccd
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|xmon_init_scc
id|xmon_init_scc
c_func
(paren
)paren
(brace
macro_line|#ifndef USE_UDBG
id|sccd
(braket
l_int|3
)braket
op_assign
l_int|0x83
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* LCR = 8N1 + DLAB */
id|sccd
(braket
l_int|0
)braket
op_assign
l_int|12
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* DLL = 9600 baud */
id|sccd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
id|sccd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FCR = 0 */
id|sccd
(braket
l_int|3
)braket
op_assign
l_int|3
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* LCR = 8N1 */
id|sccd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* IER = 0 */
macro_line|#endif
id|scc_initialized
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|via_modem
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|xmon_write
c_func
(paren
l_int|0
comma
l_string|&quot;ATE1V1&bslash;r&quot;
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmon_expect
c_func
(paren
l_string|&quot;OK&quot;
comma
l_int|5
)paren
)paren
(brace
id|xmon_write
c_func
(paren
l_int|0
comma
l_string|&quot;ATA&bslash;r&quot;
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmon_expect
c_func
(paren
l_string|&quot;CONNECT&quot;
comma
l_int|40
)paren
)paren
r_break
suffix:semicolon
)brace
id|xmon_write
c_func
(paren
l_int|0
comma
l_string|&quot;+++&quot;
comma
l_int|3
)paren
suffix:semicolon
id|xmon_expect
c_func
(paren
l_string|&quot;OK&quot;
comma
l_int|3
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|xmon_stdin
r_void
op_star
id|xmon_stdin
suffix:semicolon
DECL|variable|xmon_stdout
r_void
op_star
id|xmon_stdout
suffix:semicolon
DECL|variable|xmon_stderr
r_void
op_star
id|xmon_stderr
suffix:semicolon
r_void
DECL|function|xmon_init
id|xmon_init
c_func
(paren
r_void
)paren
(brace
)brace
r_int
DECL|function|xmon_putc
id|xmon_putc
c_func
(paren
r_int
id|c
comma
r_void
op_star
id|f
)paren
(brace
r_char
id|ch
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|xmon_putc
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
id|f
)paren
suffix:semicolon
r_return
id|xmon_write
c_func
(paren
id|f
comma
op_amp
id|ch
comma
l_int|1
)paren
op_eq
l_int|1
ques
c_cond
id|c
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_putchar
id|xmon_putchar
c_func
(paren
r_int
id|c
)paren
(brace
r_return
id|xmon_putc
c_func
(paren
id|c
comma
id|xmon_stdout
)paren
suffix:semicolon
)brace
r_int
DECL|function|xmon_fputs
id|xmon_fputs
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|f
)paren
(brace
r_int
id|n
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_return
id|xmon_write
c_func
(paren
id|f
comma
id|str
comma
id|n
)paren
op_eq
id|n
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_readchar
id|xmon_readchar
c_func
(paren
r_void
)paren
(brace
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|xmon_read
c_func
(paren
id|xmon_stdin
comma
op_amp
id|ch
comma
l_int|1
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
id|ch
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
id|xmon_printf
c_func
(paren
l_string|&quot;read(stdin) returned -1&bslash;r&bslash;n&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
DECL|variable|lineleft
r_static
r_int
id|lineleft
suffix:semicolon
DECL|function|xmon_expect
r_int
id|xmon_expect
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
r_int
id|t0
suffix:semicolon
id|timeout
op_mul_assign
id|TB_SPEED
suffix:semicolon
id|t0
op_assign
id|readtb
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|lineptr
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_read_poll
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|readtb
c_func
(paren
)paren
op_minus
id|t0
OG
id|timeout
)paren
r_return
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;r&squot;
op_logical_and
id|lineptr
OL
op_amp
id|line
(braket
r_sizeof
(paren
id|line
)paren
op_minus
l_int|1
)braket
)paren
op_star
id|lineptr
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|lineptr
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|strstr
c_func
(paren
id|line
comma
id|str
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_getchar
id|xmon_getchar
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|lineleft
op_eq
l_int|0
)paren
(brace
id|lineptr
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_readchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
op_logical_or
id|c
op_eq
l_int|4
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_star
id|lineptr
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0177
suffix:colon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|lineptr
OG
id|line
)paren
(brace
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
op_decrement
id|lineptr
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;U&squot;
op_amp
l_int|0x1F
suffix:colon
r_while
c_loop
(paren
id|lineptr
OG
id|line
)paren
(brace
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
op_decrement
id|lineptr
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|lineptr
op_ge
op_amp
id|line
(braket
r_sizeof
(paren
id|line
)paren
op_minus
l_int|1
)braket
)paren
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;a&squot;
)paren
suffix:semicolon
r_else
(brace
id|xmon_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
op_star
id|lineptr
op_increment
op_assign
id|c
suffix:semicolon
)brace
)brace
)brace
id|lineleft
op_assign
id|lineptr
op_minus
id|line
suffix:semicolon
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lineleft
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_decrement
id|lineleft
suffix:semicolon
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_char
op_star
DECL|function|xmon_fgets
id|xmon_fgets
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|nb
comma
r_void
op_star
id|f
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|c
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|str
suffix:semicolon
id|p
OL
id|str
op_plus
id|nb
op_minus
l_int|1
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_getchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|str
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_return
id|str
suffix:semicolon
)brace
eof
