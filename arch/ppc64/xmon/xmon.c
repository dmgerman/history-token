multiline_comment|/*&n; * Routines providing a simple monitor for use on the PowerMac.&n; *&n; * Copyright (C) 1996 Paul Mackerras.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/cpumask.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/cputable.h&gt;
macro_line|#include &lt;asm/rtas.h&gt;
macro_line|#include &quot;nonstdio.h&quot;
macro_line|#include &quot;privinst.h&quot;
DECL|macro|scanhex
mdefine_line|#define scanhex&t;xmon_scanhex
DECL|macro|skipbl
mdefine_line|#define skipbl&t;xmon_skipbl
macro_line|#ifdef CONFIG_SMP
DECL|variable|cpus_in_xmon
r_volatile
id|cpumask_t
id|cpus_in_xmon
op_assign
id|CPU_MASK_NONE
suffix:semicolon
DECL|variable|xmon_taken
r_static
r_int
r_int
id|xmon_taken
op_assign
l_int|1
suffix:semicolon
DECL|variable|xmon_owner
r_static
r_int
id|xmon_owner
suffix:semicolon
DECL|variable|xmon_gate
r_static
r_int
id|xmon_gate
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
DECL|variable|in_xmon
r_static
r_int
r_int
id|in_xmon
op_assign
l_int|0
suffix:semicolon
DECL|variable|adrs
r_static
r_int
r_int
id|adrs
suffix:semicolon
DECL|variable|size
r_static
r_int
id|size
op_assign
l_int|1
suffix:semicolon
DECL|variable|ndump
r_static
r_int
r_int
id|ndump
op_assign
l_int|64
suffix:semicolon
DECL|variable|nidump
r_static
r_int
r_int
id|nidump
op_assign
l_int|16
suffix:semicolon
DECL|variable|ncsum
r_static
r_int
r_int
id|ncsum
op_assign
l_int|4096
suffix:semicolon
DECL|variable|termch
r_static
r_int
id|termch
suffix:semicolon
DECL|variable|tmpstr
r_static
r_char
id|tmpstr
(braket
l_int|128
)braket
suffix:semicolon
DECL|macro|JMP_BUF_LEN
mdefine_line|#define JMP_BUF_LEN&t;(184/sizeof(long))
DECL|variable|bus_error_jmp
r_static
r_int
id|bus_error_jmp
(braket
id|JMP_BUF_LEN
)braket
suffix:semicolon
DECL|variable|catch_memory_errors
r_static
r_int
id|catch_memory_errors
suffix:semicolon
DECL|variable|xmon_fault_jmp
r_static
r_int
op_star
id|xmon_fault_jmp
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|setjmp
mdefine_line|#define setjmp xmon_setjmp
DECL|macro|longjmp
mdefine_line|#define longjmp xmon_longjmp
multiline_comment|/* Breakpoint stuff */
DECL|struct|bpt
r_struct
id|bpt
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|instr
r_int
r_int
id|instr
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|ref_count
id|atomic_t
id|ref_count
suffix:semicolon
DECL|member|enabled
r_int
id|enabled
suffix:semicolon
DECL|member|pad
r_int
r_int
id|pad
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Bits in bpt.enabled */
DECL|macro|BP_IABR_TE
mdefine_line|#define BP_IABR_TE&t;1&t;&t;/* IABR translation enabled */
DECL|macro|BP_IABR
mdefine_line|#define BP_IABR&t;&t;2
DECL|macro|BP_TRAP
mdefine_line|#define BP_TRAP&t;&t;8
DECL|macro|BP_DABR
mdefine_line|#define BP_DABR&t;&t;0x10
DECL|macro|NBPTS
mdefine_line|#define NBPTS&t;256
DECL|variable|bpts
r_static
r_struct
id|bpt
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
DECL|variable|dabr
r_static
r_struct
id|bpt
id|dabr
suffix:semicolon
DECL|variable|iabr
r_static
r_struct
id|bpt
op_star
id|iabr
suffix:semicolon
DECL|variable|bpinstr
r_static
r_int
id|bpinstr
op_assign
l_int|0x7fe00008
suffix:semicolon
multiline_comment|/* trap */
DECL|macro|BP_NUM
mdefine_line|#define BP_NUM(bp)&t;((bp) - bpts + 1)
multiline_comment|/* Bits in SRR1 that are copied from MSR */
DECL|macro|MSR_MASK
mdefine_line|#define MSR_MASK&t;0xffffffff87c0ffff
multiline_comment|/* Prototypes */
r_static
r_int
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|mread
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mwrite
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|byterev
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|memex
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bsesc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|prdump
c_func
(paren
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppc_inst_dump
c_func
(paren
r_int
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|print_address
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|memops
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|memlocate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memzcan
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memdiffs
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|skipbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|scanhex
c_func
(paren
r_int
r_int
op_star
id|valp
)paren
suffix:semicolon
r_static
r_void
id|scannl
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|hexdigit
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|getstring
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|flush_input
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|inchar
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|take_input
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|read_spr
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|write_spr
c_func
(paren
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|super_regs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|remove_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|insert_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|remove_cpu_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|insert_cpu_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|bpt
op_star
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
r_static
r_struct
id|bpt
op_star
id|in_breakpoint_table
c_func
(paren
r_int
r_int
id|pc
comma
r_int
r_int
op_star
id|offp
)paren
suffix:semicolon
r_static
r_int
id|do_step
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|bpt_cmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|cacheflush
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|cpu_cmd
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|csum
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bootcmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|dump_segments
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|symbol_lookup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|emulate_step
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|instr
)paren
suffix:semicolon
r_static
r_void
id|xmon_print_symbol
c_func
(paren
r_int
r_int
id|address
comma
r_const
r_char
op_star
id|mid
comma
r_const
r_char
op_star
id|after
)paren
suffix:semicolon
r_static
r_const
r_char
op_star
id|getvecname
c_func
(paren
r_int
r_int
id|vec
)paren
suffix:semicolon
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|print_insn_powerpc
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_void
id|xmon_vfprintf
c_func
(paren
r_void
op_star
id|f
comma
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|ap
)paren
suffix:semicolon
r_extern
r_int
id|xmon_putc
c_func
(paren
r_int
id|c
comma
r_void
op_star
id|f
)paren
suffix:semicolon
r_extern
r_int
id|putchar
c_func
(paren
r_int
id|ch
)paren
suffix:semicolon
r_extern
r_int
id|xmon_read_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
m_setjmp
(paren
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
m_longjmp
(paren
r_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|_ASR
suffix:semicolon
r_extern
r_char
id|SystemCall_common
(braket
)braket
suffix:semicolon
id|pte_t
op_star
id|find_linux_pte
c_func
(paren
id|pgd_t
op_star
id|pgdir
comma
r_int
r_int
id|va
)paren
suffix:semicolon
multiline_comment|/* from htab.c */
DECL|macro|GETWORD
mdefine_line|#define GETWORD(v)&t;(((v)[0] &lt;&lt; 24) + ((v)[1] &lt;&lt; 16) + ((v)[2] &lt;&lt; 8) + (v)[3])
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
DECL|macro|isalnum
mdefine_line|#define isalnum(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;z&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;Z&squot;))
DECL|macro|isspace
mdefine_line|#define isspace(c)&t;(c == &squot; &squot; || c == &squot;&bslash;t&squot; || c == 10 || c == 13 || c == 0)
DECL|variable|help_string
r_static
r_char
op_star
id|help_string
op_assign
l_string|&quot;&bslash;&n;Commands:&bslash;n&bslash;&n;  b&t;show breakpoints&bslash;n&bslash;&n;  bd&t;set data breakpoint&bslash;n&bslash;&n;  bi&t;set instruction breakpoint&bslash;n&bslash;&n;  bc&t;clear breakpoint&bslash;n&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;&bslash;&n;  c&t;print cpus stopped in xmon&bslash;n&bslash;&n;  c#&t;try to switch to cpu number h (in hex)&bslash;n&quot;
macro_line|#endif
l_string|&quot;&bslash;&n;  C&t;checksum&bslash;n&bslash;&n;  d&t;dump bytes&bslash;n&bslash;&n;  di&t;dump instructions&bslash;n&bslash;&n;  df&t;dump float values&bslash;n&bslash;&n;  dd&t;dump double values&bslash;n&bslash;&n;  e&t;print exception information&bslash;n&bslash;&n;  f&t;flush cache&bslash;n&bslash;&n;  la&t;lookup symbol+offset of specified address&bslash;n&bslash;&n;  ls&t;lookup address of specified symbol&bslash;n&bslash;&n;  m&t;examine/change memory&bslash;n&bslash;&n;  mm&t;move a block of memory&bslash;n&bslash;&n;  ms&t;set a block of memory&bslash;n&bslash;&n;  md&t;compare two blocks of memory&bslash;n&bslash;&n;  ml&t;locate a block of memory&bslash;n&bslash;&n;  mz&t;zero a block of memory&bslash;n&bslash;&n;  mi&t;show information about memory allocation&bslash;n&bslash;&n;  p &t;show the task list&bslash;n&bslash;&n;  r&t;print registers&bslash;n&bslash;&n;  s&t;single step&bslash;n&bslash;&n;  S&t;print special registers&bslash;n&bslash;&n;  t&t;print backtrace&bslash;n&bslash;&n;  T&t;Enable/Disable PPCDBG flags&bslash;n&bslash;&n;  x&t;exit monitor and recover&bslash;n&bslash;&n;  X&t;exit monitor and dont recover&bslash;n&bslash;&n;  u&t;dump segment table or SLB&bslash;n&bslash;&n;  ?&t;help&bslash;n&quot;
l_string|&quot;&bslash;&n;  zr&t;reboot&bslash;n&bslash;&n;  zh&t;halt&bslash;n&quot;
suffix:semicolon
DECL|variable|xmon_regs
r_static
r_struct
id|pt_regs
op_star
id|xmon_regs
suffix:semicolon
DECL|function|sync
r_extern
r_inline
r_void
id|sync
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;sync; isync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* (Ref: 64-bit PowerPC ELF ABI Spplement; Ian Lance Taylor, Zembu Labs).&n; A PPC stack frame looks like this:&n;&n; High Address&n;    Back Chain&n;    FP reg save area&n;    GP reg save area&n;    Local var space&n;    Parameter save area&t;&t;(SP+48)&n;    TOC save area&t;&t;(SP+40)&n;    link editor doubleword&t;(SP+32)&n;    compiler doubleword&t;&t;(SP+24)&n;    LR save&t;&t;&t;(SP+16)&n;    CR save&t;&t;&t;(SP+8)&n;    Back Chain&t;&t;&t;(SP+0)&n;&n; Note that the LR (ret addr) may not be saved in the current frame if&n; no functions have been called from the current function.&n; */
multiline_comment|/*&n; * We don&squot;t allow single-stepping an mtmsrd that would clear&n; * MSR_RI, since that would make the exception unrecoverable.&n; * Since we need to single-step to proceed from a breakpoint,&n; * we don&squot;t allow putting a breakpoint on an mtmsrd instruction.&n; * Similarly we don&squot;t allow breakpoints on rfid instructions.&n; * These macros tell us if an instruction is a mtmsrd or rfid.&n; */
DECL|macro|IS_MTMSRD
mdefine_line|#define IS_MTMSRD(instr)&t;(((instr) &amp; 0xfc0007fe) == 0x7c000164)
DECL|macro|IS_RFID
mdefine_line|#define IS_RFID(instr)&t;&t;(((instr) &amp; 0xfc0007fe) == 0x4c000024)
multiline_comment|/*&n; * Disable surveillance (the service processor watchdog function)&n; * while we are in xmon.&n; * XXX we should re-enable it when we leave. :)&n; */
DECL|macro|SURVEILLANCE_TOKEN
mdefine_line|#define SURVEILLANCE_TOKEN&t;9000
DECL|function|disable_surveillance
r_static
r_inline
r_void
id|disable_surveillance
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PPC_PSERIES
multiline_comment|/* Since this can&squot;t be a module, args should end up below 4GB. */
r_static
r_struct
id|rtas_args
id|args
suffix:semicolon
multiline_comment|/*&n;&t; * At this point we have got all the cpus we can into&n;&t; * xmon, so there is hopefully no other cpu calling RTAS&n;&t; * at the moment, even though we don&squot;t take rtas.lock.&n;&t; * If we did try to take rtas.lock there would be a&n;&t; * real possibility of deadlock.&n;&t; */
id|args.token
op_assign
id|rtas_token
c_func
(paren
l_string|&quot;set-indicator&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args.token
op_eq
id|RTAS_UNKNOWN_SERVICE
)paren
r_return
suffix:semicolon
id|args.nargs
op_assign
l_int|3
suffix:semicolon
id|args.nret
op_assign
l_int|1
suffix:semicolon
id|args.rets
op_assign
op_amp
id|args.args
(braket
l_int|3
)braket
suffix:semicolon
id|args.args
(braket
l_int|0
)braket
op_assign
id|SURVEILLANCE_TOKEN
suffix:semicolon
id|args.args
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|args.args
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|enter_rtas
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|args
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPC_PSERIES */
)brace
macro_line|#ifdef CONFIG_SMP
DECL|variable|xmon_speaker
r_static
r_int
id|xmon_speaker
suffix:semicolon
DECL|function|get_output_lock
r_static
r_void
id|get_output_lock
c_func
(paren
r_void
)paren
(brace
r_int
id|me
op_assign
id|smp_processor_id
c_func
(paren
)paren
op_plus
l_int|0x100
suffix:semicolon
r_int
id|last_speaker
op_assign
l_int|0
comma
id|prev
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|xmon_speaker
op_eq
id|me
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|xmon_speaker
op_eq
l_int|0
)paren
(brace
id|last_speaker
op_assign
id|cmpxchg
c_func
(paren
op_amp
id|xmon_speaker
comma
l_int|0
comma
id|me
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_speaker
op_eq
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|timeout
op_assign
l_int|10000000
suffix:semicolon
r_while
c_loop
(paren
id|xmon_speaker
op_eq
id|last_speaker
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
OG
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* hostile takeover */
id|prev
op_assign
id|cmpxchg
c_func
(paren
op_amp
id|xmon_speaker
comma
id|last_speaker
comma
id|me
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|last_speaker
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|release_output_lock
r_static
r_void
id|release_output_lock
c_func
(paren
r_void
)paren
(brace
id|xmon_speaker
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|xmon_core
r_int
id|xmon_core
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|fromipi
)paren
(brace
r_int
id|cmd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|msr
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
id|recurse_jmp
(braket
id|JMP_BUF_LEN
)braket
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|cpu
suffix:semicolon
r_int
id|secondary
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#endif
id|msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|msr
op_amp
op_complement
id|MSR_EE
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|bp
op_assign
id|in_breakpoint_table
c_func
(paren
id|regs-&gt;nip
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|regs-&gt;nip
op_assign
id|bp-&gt;address
op_plus
id|offset
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bp-&gt;ref_count
)paren
suffix:semicolon
)brace
id|remove_cpu_bpts
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
)paren
(brace
id|get_output_lock
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;cpu 0x%x: Exception %lx %s in xmon, &quot;
l_string|&quot;returning to main loop&bslash;n&quot;
comma
id|cpu
comma
id|regs-&gt;trap
comma
id|getvecname
c_func
(paren
id|TRAP
c_func
(paren
id|regs
)paren
)paren
)paren
suffix:semicolon
m_longjmp
(paren
id|xmon_fault_jmp
(braket
id|cpu
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
m_setjmp
(paren
id|recurse_jmp
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_xmon
op_logical_or
op_logical_neg
id|xmon_gate
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;xmon: WARNING: bad recursive fault &quot;
l_string|&quot;on cpu 0x%x&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_goto
id|waiting
suffix:semicolon
)brace
id|secondary
op_assign
op_logical_neg
(paren
id|xmon_taken
op_logical_and
id|cpu
op_eq
id|xmon_owner
)paren
suffix:semicolon
r_goto
id|cmdloop
suffix:semicolon
)brace
id|xmon_fault_jmp
(braket
id|cpu
)braket
op_assign
id|recurse_jmp
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_eq
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_logical_or
(paren
id|regs-&gt;msr
op_amp
id|MSR_RI
)paren
op_eq
l_int|0
)paren
id|fromipi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fromipi
)paren
(brace
id|get_output_lock
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;cpu 0x%x stopped at breakpoint 0x%x (&quot;
comma
id|cpu
comma
id|BP_NUM
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|regs-&gt;nip
comma
l_string|&quot; &quot;
comma
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_RI
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;WARNING: exception is not recoverable, &quot;
l_string|&quot;can&squot;t continue&bslash;n&quot;
)paren
suffix:semicolon
id|release_output_lock
c_func
(paren
)paren
suffix:semicolon
)brace
id|waiting
suffix:colon
id|secondary
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|secondary
op_logical_and
op_logical_neg
id|xmon_gate
)paren
(brace
r_if
c_cond
(paren
id|in_xmon
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fromipi
)paren
r_goto
id|leave
suffix:semicolon
id|secondary
op_assign
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|in_xmon
)paren
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|secondary
op_logical_and
op_logical_neg
id|xmon_gate
)paren
(brace
multiline_comment|/* we are the first cpu to come in */
multiline_comment|/* interrupt other cpu(s) */
r_int
id|ncpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|xmon_owner
op_assign
id|cpu
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncpus
OG
l_int|1
)paren
(brace
id|smp_send_debugger_break
c_func
(paren
id|MSG_ALL_BUT_SELF
)paren
suffix:semicolon
multiline_comment|/* wait for other cpus to come in */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|100000000
suffix:semicolon
id|timeout
op_ne
l_int|0
suffix:semicolon
op_decrement
id|timeout
)paren
r_if
c_cond
(paren
id|cpus_weight
c_func
(paren
id|cpus_in_xmon
)paren
op_ge
id|ncpus
)paren
r_break
suffix:semicolon
)brace
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|disable_surveillance
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* for breakpoint or single step, print the current instr. */
r_if
c_cond
(paren
id|bp
op_logical_or
id|TRAP
c_func
(paren
id|regs
)paren
op_eq
l_int|0xd00
)paren
id|ppc_inst_dump
c_func
(paren
id|regs-&gt;nip
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;enter ? for help&bslash;n&quot;
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|xmon_gate
op_assign
l_int|1
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|cmdloop
suffix:colon
r_while
c_loop
(paren
id|in_xmon
)paren
(brace
r_if
c_cond
(paren
id|secondary
)paren
(brace
r_if
c_cond
(paren
id|cpu
op_eq
id|xmon_owner
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|xmon_taken
)paren
)paren
(brace
id|secondary
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* missed it */
r_while
c_loop
(paren
id|cpu
op_eq
id|xmon_owner
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|cmds
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_int|0
)paren
(brace
multiline_comment|/* exiting xmon */
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
id|xmon_gate
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|in_xmon
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* have switched to some other cpu */
id|secondary
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|leave
suffix:colon
id|cpu_clear
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
suffix:semicolon
id|xmon_fault_jmp
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
multiline_comment|/* UP is simple... */
r_if
c_cond
(paren
id|in_xmon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Exception %lx %s in xmon, returning to main loop&bslash;n&quot;
comma
id|regs-&gt;trap
comma
id|getvecname
c_func
(paren
id|TRAP
c_func
(paren
id|regs
)paren
)paren
)paren
suffix:semicolon
m_longjmp
(paren
id|xmon_fault_jmp
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
m_setjmp
(paren
id|recurse_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|xmon_fault_jmp
(braket
l_int|0
)braket
op_assign
id|recurse_jmp
suffix:semicolon
id|in_xmon
op_assign
l_int|1
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Stopped at breakpoint %x (&quot;
comma
id|BP_NUM
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|regs-&gt;nip
comma
l_string|&quot; &quot;
comma
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_RI
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;WARNING: exception is not recoverable, &quot;
l_string|&quot;can&squot;t continue&bslash;n&quot;
)paren
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|disable_surveillance
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* for breakpoint or single step, print the current instr. */
r_if
c_cond
(paren
id|bp
op_logical_or
id|TRAP
c_func
(paren
id|regs
)paren
op_eq
l_int|0xd00
)paren
id|ppc_inst_dump
c_func
(paren
id|regs-&gt;nip
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;enter ? for help&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|cmds
c_func
(paren
id|regs
)paren
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
id|in_xmon
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_eq
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
(brace
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_int
id|stepped
op_assign
id|emulate_step
c_func
(paren
id|regs
comma
id|bp-&gt;instr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stepped
op_eq
l_int|0
)paren
(brace
id|regs-&gt;nip
op_assign
(paren
r_int
r_int
)paren
op_amp
id|bp-&gt;instr
(braket
l_int|0
)braket
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bp-&gt;ref_count
)paren
suffix:semicolon
)brace
)brace
)brace
id|insert_cpu_bpts
c_func
(paren
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|msr
)paren
suffix:semicolon
multiline_comment|/* restore interrupt enable */
r_return
id|cmd
op_ne
l_char|&squot;X&squot;
suffix:semicolon
)brace
DECL|function|xmon
r_int
id|xmon
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Ok, grab regs as they are now.&n;&t;&t; This won&squot;t do a particularily good job because the&n;&t;&t; prologue has already been executed.&n;&t;&t; ToDo: We could reach back into the callers save&n;&t;&t; area to do a better job of representing the&n;&t;&t; caller&squot;s state.&n;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;std&t;0,0(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;1,8(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;2,16(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;3,24(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;4,32(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;5,40(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;6,48(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;7,56(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;8,64(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;9,72(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;10,80(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;11,88(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;12,96(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;13,104(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;14,112(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;15,120(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;16,128(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;17,136(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;18,144(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;19,152(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;20,160(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;21,168(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;22,176(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;23,184(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;24,192(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;25,200(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;26,208(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;27,216(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;28,224(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;29,232(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;30,240(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;31,248(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
op_amp
id|regs
)paren
)paren
suffix:semicolon
id|regs.nip
op_assign
id|regs.link
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs.gpr
(braket
l_int|1
)braket
)paren
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|regs.msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|regs.ctr
op_assign
id|get_ctr
c_func
(paren
)paren
suffix:semicolon
id|regs.xer
op_assign
id|get_xer
c_func
(paren
)paren
suffix:semicolon
id|regs.ccr
op_assign
id|get_cr
c_func
(paren
)paren
suffix:semicolon
id|regs.trap
op_assign
l_int|0
suffix:semicolon
id|excp
op_assign
op_amp
id|regs
suffix:semicolon
)brace
r_return
id|xmon_core
c_func
(paren
id|excp
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|xmon_bpt
r_int
id|xmon_bpt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_ne
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Are we at the trap at bp-&gt;instr[1] for some bp? */
id|bp
op_assign
id|in_breakpoint_table
c_func
(paren
id|regs-&gt;nip
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
op_logical_and
id|offset
op_eq
l_int|4
)paren
(brace
id|regs-&gt;nip
op_assign
id|bp-&gt;address
op_plus
l_int|4
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bp-&gt;ref_count
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Are we at a breakpoint? */
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
l_int|0
suffix:semicolon
id|xmon_core
c_func
(paren
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xmon_sstep
r_int
id|xmon_sstep
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|xmon_core
c_func
(paren
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xmon_dabr_match
r_int
id|xmon_dabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_ne
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|xmon_core
c_func
(paren
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xmon_iabr_match
r_int
id|xmon_iabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_ne
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iabr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|xmon_core
c_func
(paren
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xmon_ipi
r_int
id|xmon_ipi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|in_xmon
op_logical_and
op_logical_neg
id|cpu_isset
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpus_in_xmon
)paren
)paren
id|xmon_core
c_func
(paren
id|regs
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xmon_fault_handler
r_int
id|xmon_fault_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|in_xmon
op_logical_and
id|catch_memory_errors
)paren
id|handle_fault
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* doesn&squot;t return */
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_IR
op_or
id|MSR_PR
op_or
id|MSR_SF
)paren
)paren
op_eq
(paren
id|MSR_IR
op_or
id|MSR_SF
)paren
)paren
(brace
id|bp
op_assign
id|in_breakpoint_table
c_func
(paren
id|regs-&gt;nip
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|regs-&gt;nip
op_assign
id|bp-&gt;address
op_plus
id|offset
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bp-&gt;ref_count
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|at_breakpoint
r_static
r_struct
id|bpt
op_star
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
op_logical_and
id|pc
op_eq
id|bp-&gt;address
)paren
r_return
id|bp
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|in_breakpoint_table
r_static
r_struct
id|bpt
op_star
id|in_breakpoint_table
c_func
(paren
r_int
r_int
id|nip
comma
r_int
r_int
op_star
id|offp
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
id|off
op_assign
id|nip
op_minus
(paren
r_int
r_int
)paren
id|bpts
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
r_sizeof
(paren
id|bpts
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|off
op_mod_assign
r_sizeof
(paren
r_struct
id|bpt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
m_offsetof
(paren
r_struct
id|bpt
comma
id|instr
(braket
l_int|0
)braket
)paren
op_logical_and
id|off
op_ne
m_offsetof
(paren
r_struct
id|bpt
comma
id|instr
(braket
l_int|1
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|offp
op_assign
id|off
op_minus
m_offsetof
(paren
r_struct
id|bpt
comma
id|instr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
(paren
r_struct
id|bpt
op_star
)paren
(paren
id|nip
op_minus
id|off
)paren
suffix:semicolon
)brace
DECL|function|new_breakpoint
r_static
r_struct
id|bpt
op_star
id|new_breakpoint
c_func
(paren
r_int
r_int
id|a
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|a
op_and_assign
op_complement
l_int|3UL
suffix:semicolon
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
r_return
id|bp
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|bp-&gt;ref_count
)paren
op_eq
l_int|0
)paren
(brace
id|bp-&gt;address
op_assign
id|a
suffix:semicolon
id|bp-&gt;instr
(braket
l_int|1
)braket
op_assign
id|bpinstr
suffix:semicolon
id|store_inst
c_func
(paren
op_amp
id|bp-&gt;instr
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;Sorry, no free breakpoints.  Please clear one first.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|insert_bpts
r_static
r_void
id|insert_bpts
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp-&gt;enabled
op_amp
(paren
id|BP_TRAP
op_or
id|BP_IABR
)paren
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
(braket
l_int|0
)braket
comma
l_int|4
)paren
op_ne
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t read instruction at %lx, &quot;
l_string|&quot;disabling breakpoint there&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_MTMSRD
c_func
(paren
id|bp-&gt;instr
(braket
l_int|0
)braket
)paren
op_logical_or
id|IS_RFID
c_func
(paren
id|bp-&gt;instr
(braket
l_int|0
)braket
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Breakpoint at %lx is on an mtmsrd or rfid &quot;
l_string|&quot;instruction, disabling it&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|store_inst
c_func
(paren
op_amp
id|bp-&gt;instr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;enabled
op_amp
id|BP_IABR
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bpinstr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t write instruction at %lx, &quot;
l_string|&quot;disabling breakpoint there&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_and_assign
op_complement
id|BP_TRAP
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|function|insert_cpu_bpts
r_static
r_void
id|insert_cpu_bpts
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|set_dabr
c_func
(paren
id|dabr.address
op_or
(paren
id|dabr.enabled
op_amp
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr
op_logical_and
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
)paren
id|set_iabr
c_func
(paren
id|iabr-&gt;address
op_or
(paren
id|iabr-&gt;enabled
op_amp
(paren
id|BP_IABR
op_or
id|BP_IABR_TE
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|remove_bpts
r_static
r_void
id|remove_bpts
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
id|instr
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp-&gt;enabled
op_amp
(paren
id|BP_TRAP
op_or
id|BP_IABR
)paren
)paren
op_ne
id|BP_TRAP
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|instr
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
id|instr
op_eq
id|bpinstr
op_logical_and
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t remove breakpoint at %lx&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
r_else
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|function|remove_cpu_bpts
r_static
r_void
id|remove_cpu_bpts
c_func
(paren
r_void
)paren
(brace
id|set_dabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
)paren
id|set_iabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|branch_taken
r_static
r_int
id|branch_taken
c_func
(paren
r_int
r_int
id|instr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|bo
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
r_int
id|bi
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bo
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* decrement counter */
op_decrement
id|regs-&gt;ctr
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|bo
op_rshift
l_int|1
)paren
op_amp
l_int|1
)paren
op_xor
(paren
id|regs-&gt;ctr
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bo
op_amp
l_int|0x10
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check bit from CR */
id|bi
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|regs-&gt;ccr
op_rshift
(paren
l_int|31
op_minus
id|bi
)paren
)paren
op_amp
l_int|1
)paren
op_ne
(paren
(paren
id|bo
op_rshift
l_int|3
)paren
op_amp
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Emulate instructions that cause a transfer of control.&n; * Returns 1 if the step was emulated, 0 if not,&n; * or -1 if the instruction is one that should not be stepped,&n; * such as an rfid, or a mtmsrd that would clear MSR_RI.&n; */
DECL|function|emulate_step
r_static
r_int
id|emulate_step
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|instr
)paren
(brace
r_int
r_int
id|opcode
comma
id|rd
suffix:semicolon
r_int
r_int
r_int
id|imm
suffix:semicolon
id|opcode
op_assign
id|instr
op_rshift
l_int|26
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|16
suffix:colon
multiline_comment|/* bc */
id|imm
op_assign
(paren
r_int
r_int
)paren
(paren
id|instr
op_amp
l_int|0xfffc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|imm
op_add_assign
id|regs-&gt;nip
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* XXX check 32-bit mode */
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
id|regs-&gt;link
op_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|branch_taken
c_func
(paren
id|instr
comma
id|regs
)paren
)paren
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|17
suffix:colon
multiline_comment|/* sc */
id|regs-&gt;gpr
(braket
l_int|9
)braket
op_assign
id|regs-&gt;gpr
(braket
l_int|13
)braket
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|11
)braket
op_assign
id|regs-&gt;nip
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|12
)braket
op_assign
id|regs-&gt;msr
op_amp
id|MSR_MASK
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|13
)braket
op_assign
(paren
r_int
r_int
)paren
id|get_paca
c_func
(paren
)paren
suffix:semicolon
id|regs-&gt;nip
op_assign
(paren
r_int
r_int
)paren
op_amp
id|SystemCall_common
suffix:semicolon
id|regs-&gt;msr
op_assign
id|MSR_KERNEL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|18
suffix:colon
multiline_comment|/* b */
id|imm
op_assign
id|instr
op_amp
l_int|0x03fffffc
suffix:semicolon
r_if
c_cond
(paren
id|imm
op_amp
l_int|0x02000000
)paren
id|imm
op_sub_assign
l_int|0x04000000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|imm
op_add_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
id|regs-&gt;link
op_assign
id|regs-&gt;nip
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|19
suffix:colon
r_switch
c_cond
(paren
id|instr
op_amp
l_int|0x7fe
)paren
(brace
r_case
l_int|0x20
suffix:colon
multiline_comment|/* bclr */
r_case
l_int|0x420
suffix:colon
multiline_comment|/* bcctr */
id|imm
op_assign
(paren
id|instr
op_amp
l_int|0x400
)paren
ques
c_cond
id|regs-&gt;ctr
suffix:colon
id|regs-&gt;link
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* XXX check 32-bit mode */
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
id|regs-&gt;link
op_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|branch_taken
c_func
(paren
id|instr
comma
id|regs
)paren
)paren
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|0x24
suffix:colon
multiline_comment|/* rfid, scary */
id|printf
c_func
(paren
l_string|&quot;Can&squot;t single-step an rfid instruction&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_case
l_int|31
suffix:colon
id|rd
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|instr
op_amp
l_int|0x7fe
)paren
(brace
r_case
l_int|0xa6
suffix:colon
multiline_comment|/* mfmsr */
id|regs-&gt;gpr
(braket
id|rd
)braket
op_assign
id|regs-&gt;msr
op_amp
id|MSR_MASK
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|0x164
suffix:colon
multiline_comment|/* mtmsrd */
multiline_comment|/* only MSR_EE and MSR_RI get changed if bit 15 set */
multiline_comment|/* mtmsrd doesn&squot;t change MSR_HV and MSR_ME */
id|imm
op_assign
(paren
id|instr
op_amp
l_int|0x10000
)paren
ques
c_cond
l_int|0x8002
suffix:colon
l_int|0xefffffffffffefffUL
suffix:semicolon
id|imm
op_assign
(paren
id|regs-&gt;msr
op_amp
id|MSR_MASK
op_amp
op_complement
id|imm
)paren
op_or
(paren
id|regs-&gt;gpr
(braket
id|rd
)braket
op_amp
id|imm
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|imm
op_amp
id|MSR_RI
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Can&squot;t step an instruction that would &quot;
l_string|&quot;clear MSR.RI&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|regs-&gt;msr
op_assign
id|imm
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Command interpreting routine */
DECL|variable|last_cmd
r_static
r_char
op_star
id|last_cmd
suffix:semicolon
r_static
r_int
DECL|function|cmds
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
id|cmd
op_assign
l_int|0
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
id|xmon_regs
op_assign
id|excp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|printf
c_func
(paren
l_string|&quot;%x:&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printf
c_func
(paren
l_string|&quot;mon&gt; &quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|flush_input
c_func
(paren
)paren
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|last_cmd
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|take_input
c_func
(paren
id|last_cmd
)paren
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
id|memops
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|memlocate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|memzcan
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|show_mem
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|memex
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|dump
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|symbol_lookup
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|prregs
c_func
(paren
id|excp
)paren
suffix:semicolon
multiline_comment|/* print regs */
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|super_regs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|backtrace
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|cacheflush
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_if
c_cond
(paren
id|do_step
c_func
(paren
id|excp
)paren
)paren
r_return
id|cmd
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
l_char|&squot;X&squot;
suffix:colon
r_case
id|EOF
suffix:colon
r_return
id|cmd
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
id|show_state
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|bpt_cmds
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|csum
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
id|cpu_cmd
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|bootcmds
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|debug_trace
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|dump_segments
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Unrecognized command: &quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
l_char|&squot; &squot;
OL
id|cmd
op_logical_and
id|cmd
op_le
l_char|&squot;~&squot;
)paren
id|putchar
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&bslash;x%x&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (type ? for help)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Step a single instruction.&n; * Some instructions we emulate, others we execute with MSR_SE set.&n; */
DECL|function|do_step
r_static
r_int
id|do_step
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|instr
suffix:semicolon
r_int
id|stepped
suffix:semicolon
multiline_comment|/* check we are in 64-bit kernel mode, translation enabled */
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
(paren
id|MSR_SF
op_or
id|MSR_PR
op_or
id|MSR_IR
)paren
)paren
op_eq
(paren
id|MSR_SF
op_or
id|MSR_IR
)paren
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|regs-&gt;nip
comma
op_amp
id|instr
comma
l_int|4
)paren
op_eq
l_int|4
)paren
(brace
id|stepped
op_assign
id|emulate_step
c_func
(paren
id|regs
comma
id|instr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stepped
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stepped
OG
l_int|0
)paren
(brace
id|regs-&gt;trap
op_assign
l_int|0xd00
op_or
(paren
id|regs-&gt;trap
op_amp
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;stepped to &quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|regs-&gt;nip
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ppc_inst_dump
c_func
(paren
id|regs-&gt;nip
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|bootcmds
r_static
r_void
id|bootcmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|ppc_md
dot
id|restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;h&squot;
)paren
id|ppc_md
dot
id|halt
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;p&squot;
)paren
id|ppc_md
dot
id|power_off
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cpu_cmd
r_static
r_int
id|cpu_cmd
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
r_int
id|cpu
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|cpu
)paren
)paren
(brace
multiline_comment|/* print cpus waiting or in xmon */
id|printf
c_func
(paren
l_string|&quot;cpus stopped:&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; %x&quot;
comma
id|cpu
)paren
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;-%x&quot;
comma
id|cpu
op_minus
l_int|1
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;-%x&quot;
comma
id|NR_CPUS
op_minus
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* try to switch to cpu specified */
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;cpu 0x%x isn&squot;t in xmon&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xmon_taken
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|xmon_owner
op_assign
id|cpu
suffix:semicolon
id|timeout
op_assign
l_int|10000000
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|xmon_taken
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|xmon_taken
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* take control back */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|xmon_owner
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;cpu %u didn&squot;t take control&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
)brace
DECL|variable|fcstab
r_static
r_int
r_int
id|fcstab
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|macro|FCS
mdefine_line|#define FCS(fcs, c)&t;(((fcs) &gt;&gt; 8) ^ fcstab[((fcs) ^ (c)) &amp; 0xff])
r_static
r_void
DECL|function|csum
id|csum
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|fcs
suffix:semicolon
r_int
r_char
id|v
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|ncsum
)paren
)paren
r_return
suffix:semicolon
id|fcs
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ncsum
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|adrs
op_plus
id|i
comma
op_amp
id|v
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;csum stopped at %x&bslash;n&quot;
comma
id|adrs
op_plus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fcs
op_assign
id|FCS
c_func
(paren
id|fcs
comma
id|v
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%x&bslash;n&quot;
comma
id|fcs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if this is a suitable place to put a breakpoint.&n; */
DECL|function|check_bp_loc
r_static
r_int
id|check_bp_loc
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|instr
suffix:semicolon
id|addr
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|KERNELBASE
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Breakpoints may only be placed at kernel addresses&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mread
c_func
(paren
id|addr
comma
op_amp
id|instr
comma
r_sizeof
(paren
id|instr
)paren
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Can&squot;t read instruction at address %lx&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_MTMSRD
c_func
(paren
id|instr
)paren
op_logical_or
id|IS_RFID
c_func
(paren
id|instr
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Breakpoints may not be placed on mtmsrd or rfid &quot;
l_string|&quot;instructions&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|breakpoint_help_string
r_static
r_char
op_star
id|breakpoint_help_string
op_assign
l_string|&quot;Breakpoint command usage:&bslash;n&quot;
l_string|&quot;b                show breakpoints&bslash;n&quot;
l_string|&quot;b &lt;addr&gt; [cnt]   set breakpoint at given instr addr&bslash;n&quot;
l_string|&quot;bc               clear all breakpoints&bslash;n&quot;
l_string|&quot;bc &lt;n/addr&gt;      clear breakpoint number n or at addr&bslash;n&quot;
l_string|&quot;bi &lt;addr&gt; [cnt]  set hardware instr breakpoint (broken?)&bslash;n&quot;
l_string|&quot;bd &lt;addr&gt; [cnt]  set hardware data breakpoint (broken?)&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_static
r_void
DECL|function|bpt_cmds
id|bpt_cmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|a
suffix:semicolon
r_int
id|mode
comma
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_const
r_char
id|badaddr
(braket
)braket
op_assign
l_string|&quot;Only kernel addresses are permitted &quot;
l_string|&quot;for breakpoints&bslash;n&quot;
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* bd - hardware data breakpoint */
id|mode
op_assign
l_int|7
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|mode
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;w&squot;
)paren
id|mode
op_assign
l_int|6
suffix:semicolon
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
id|dabr.address
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|dabr.address
)paren
)paren
(brace
r_if
c_cond
(paren
id|dabr.address
OL
id|KERNELBASE
)paren
(brace
id|printf
c_func
(paren
id|badaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dabr.address
op_and_assign
op_complement
l_int|7
suffix:semicolon
id|dabr.enabled
op_assign
id|mode
op_or
id|BP_DABR
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* bi - hardware instr breakpoint */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Hardware instruction breakpoint &quot;
l_string|&quot;not supported on this cpu&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iabr
)paren
(brace
id|iabr-&gt;enabled
op_and_assign
op_complement
(paren
id|BP_IABR
op_or
id|BP_IABR_TE
)paren
suffix:semicolon
id|iabr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_bp_loc
c_func
(paren
id|a
)paren
)paren
r_break
suffix:semicolon
id|bp
op_assign
id|new_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|bp-&gt;enabled
op_or_assign
id|BP_IABR
op_or
id|BP_IABR_TE
suffix:semicolon
id|iabr
op_assign
id|bp
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* clear all breakpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
)paren
id|bpts
(braket
id|i
)braket
dot
id|enabled
op_assign
l_int|0
suffix:semicolon
id|iabr
op_assign
l_int|NULL
suffix:semicolon
id|dabr.enabled
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All breakpoints cleared&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a
op_le
id|NBPTS
op_logical_and
id|a
op_ge
l_int|1
)paren
(brace
multiline_comment|/* assume a breakpoint number */
id|bp
op_assign
op_amp
id|bpts
(braket
id|a
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bp nums are 1 based */
)brace
r_else
(brace
multiline_comment|/* assume a breakpoint address */
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;No breakpoint at %x&bslash;n&quot;
comma
id|a
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;Cleared breakpoint %x (&quot;
comma
id|BP_NUM
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|bp-&gt;address
comma
l_string|&quot; &quot;
comma
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|breakpoint_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* print all breakpoints */
id|printf
c_func
(paren
l_string|&quot;   type            address&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   data   %.16lx  [&quot;
comma
id|dabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
op_amp
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
op_amp
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%2x %s   &quot;
comma
id|BP_NUM
c_func
(paren
id|bp
)paren
comma
(paren
id|bp-&gt;enabled
op_amp
id|BP_IABR
)paren
ques
c_cond
l_string|&quot;inst&quot;
suffix:colon
l_string|&quot;trap&quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|bp-&gt;address
comma
l_string|&quot;  &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|check_bp_loc
c_func
(paren
id|a
)paren
)paren
r_break
suffix:semicolon
id|bp
op_assign
id|new_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
id|bp-&gt;enabled
op_or_assign
id|BP_TRAP
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Very cheap human name for vector lookup. */
r_static
DECL|function|getvecname
r_const
r_char
op_star
id|getvecname
c_func
(paren
r_int
r_int
id|vec
)paren
(brace
r_char
op_star
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|vec
)paren
(brace
r_case
l_int|0x100
suffix:colon
id|ret
op_assign
l_string|&quot;(System Reset)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x200
suffix:colon
id|ret
op_assign
l_string|&quot;(Machine Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x300
suffix:colon
id|ret
op_assign
l_string|&quot;(Data Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x380
suffix:colon
id|ret
op_assign
l_string|&quot;(Data SLB Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x400
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x480
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction SLB Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x500
suffix:colon
id|ret
op_assign
l_string|&quot;(Hardware Interrupt)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x600
suffix:colon
id|ret
op_assign
l_string|&quot;(Alignment)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x700
suffix:colon
id|ret
op_assign
l_string|&quot;(Program Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x800
suffix:colon
id|ret
op_assign
l_string|&quot;(FPU Unavailable)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x900
suffix:colon
id|ret
op_assign
l_string|&quot;(Decrementer)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc00
suffix:colon
id|ret
op_assign
l_string|&quot;(System Call)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd00
suffix:colon
id|ret
op_assign
l_string|&quot;(Single Step)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf00
suffix:colon
id|ret
op_assign
l_string|&quot;(Performance Monitor)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf20
suffix:colon
id|ret
op_assign
l_string|&quot;(Altivec Unavailable)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1300
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction Breakpoint)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_function_bounds
r_static
r_void
id|get_function_bounds
c_func
(paren
r_int
r_int
id|pc
comma
r_int
r_int
op_star
id|startp
comma
r_int
r_int
op_star
id|endp
)paren
(brace
r_int
r_int
id|size
comma
id|offset
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_char
op_star
id|modname
suffix:semicolon
op_star
id|startp
op_assign
op_star
id|endp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pc
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|kallsyms_lookup
c_func
(paren
id|pc
comma
op_amp
id|size
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|tmpstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
(brace
op_star
id|startp
op_assign
id|pc
op_minus
id|offset
suffix:semicolon
op_star
id|endp
op_assign
id|pc
op_minus
id|offset
op_plus
id|size
suffix:semicolon
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|xmon_depth_to_print
r_static
r_int
id|xmon_depth_to_print
op_assign
l_int|64
suffix:semicolon
DECL|function|xmon_show_stack
r_static
r_void
id|xmon_show_stack
c_func
(paren
r_int
r_int
id|sp
comma
r_int
r_int
id|lr
comma
r_int
r_int
id|pc
)paren
(brace
r_int
r_int
id|ip
suffix:semicolon
r_int
r_int
id|newsp
suffix:semicolon
r_int
r_int
id|marker
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|sp
OL
id|PAGE_OFFSET
)paren
(brace
r_if
c_cond
(paren
id|sp
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;SP (%lx) is in userspace&bslash;n&quot;
comma
id|sp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mread
c_func
(paren
id|sp
op_plus
l_int|16
comma
op_amp
id|ip
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_logical_or
op_logical_neg
id|mread
c_func
(paren
id|sp
comma
op_amp
id|newsp
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t read stack frame at %lx&bslash;n&quot;
comma
id|sp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For the first stack frame, try to work out if&n;&t;&t; * LR and/or the saved LR value in the bottommost&n;&t;&t; * stack frame are valid.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pc
op_or
id|lr
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|fnstart
comma
id|fnend
suffix:semicolon
r_int
r_int
id|nextip
suffix:semicolon
r_int
id|printip
op_assign
l_int|1
suffix:semicolon
id|get_function_bounds
c_func
(paren
id|pc
comma
op_amp
id|fnstart
comma
op_amp
id|fnend
)paren
suffix:semicolon
id|nextip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|newsp
OG
id|sp
)paren
id|mread
c_func
(paren
id|newsp
op_plus
l_int|16
comma
op_amp
id|nextip
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lr
op_eq
id|ip
)paren
(brace
r_if
c_cond
(paren
id|lr
OL
id|PAGE_OFFSET
op_logical_or
(paren
id|fnstart
op_le
id|lr
op_logical_and
id|lr
OL
id|fnend
)paren
)paren
id|printip
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lr
op_eq
id|nextip
)paren
(brace
id|printip
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lr
op_ge
id|PAGE_OFFSET
op_logical_and
op_logical_neg
(paren
id|fnstart
op_le
id|lr
op_logical_and
id|lr
OL
id|fnend
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;[link register   ] &quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|lr
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printip
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;[%.16lx] &quot;
comma
id|sp
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|ip
comma
l_string|&quot; &quot;
comma
l_string|&quot; (unreliable)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pc
op_assign
id|lr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;[%.16lx] &quot;
comma
id|sp
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|ip
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for &quot;regshere&quot; marker to see if this is&n;&t;&t;   an exception frame. */
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
op_plus
l_int|0x60
comma
op_amp
id|marker
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_logical_and
id|marker
op_eq
l_int|0x7265677368657265ul
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
op_plus
l_int|0x70
comma
op_amp
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
op_ne
r_sizeof
(paren
id|regs
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t read registers at %lx&bslash;n&quot;
comma
id|sp
op_plus
l_int|0x70
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;--- Exception: %lx %s at &quot;
comma
id|regs.trap
comma
id|getvecname
c_func
(paren
id|TRAP
c_func
(paren
op_amp
id|regs
)paren
)paren
)paren
suffix:semicolon
id|pc
op_assign
id|regs.nip
suffix:semicolon
id|lr
op_assign
id|regs.link
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|pc
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsp
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|sp
op_assign
id|newsp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
id|xmon_depth_to_print
)paren
suffix:semicolon
)brace
DECL|function|backtrace
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
r_int
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|sp
)paren
)paren
id|xmon_show_stack
c_func
(paren
id|sp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_else
id|xmon_show_stack
c_func
(paren
id|excp-&gt;gpr
(braket
l_int|1
)braket
comma
id|excp-&gt;link
comma
id|excp-&gt;nip
)paren
suffix:semicolon
id|scannl
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|excprint
r_void
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
id|trap
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printf
c_func
(paren
l_string|&quot;cpu 0x%x: &quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|trap
op_assign
id|TRAP
c_func
(paren
id|fp
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Vector: %lx %s at [%lx]&bslash;n&quot;
comma
id|fp-&gt;trap
comma
id|getvecname
c_func
(paren
id|trap
)paren
comma
id|fp
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    pc: &quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|fp-&gt;nip
comma
l_string|&quot;: &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    lr: &quot;
comma
id|fp-&gt;link
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|fp-&gt;link
comma
l_string|&quot;: &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    sp: %lx&bslash;n&quot;
comma
id|fp-&gt;gpr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   msr: %lx&bslash;n&quot;
comma
id|fp-&gt;msr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trap
op_eq
l_int|0x300
op_logical_or
id|trap
op_eq
l_int|0x380
op_logical_or
id|trap
op_eq
l_int|0x600
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   dar: %lx&bslash;n&quot;
comma
id|fp-&gt;dar
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trap
op_ne
l_int|0x380
)paren
id|printf
c_func
(paren
l_string|&quot; dsisr: %lx&bslash;n&quot;
comma
id|fp-&gt;dsisr
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  current = 0x%lx&bslash;n&quot;
comma
id|current
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  paca    = 0x%lx&bslash;n&quot;
comma
id|get_paca
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;    pid   = %ld, comm = %s&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
)brace
DECL|function|prregs
r_void
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|base
)paren
)paren
(brace
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|regs
op_assign
op_star
(paren
r_struct
id|pt_regs
op_star
)paren
id|base
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_else
(brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;*** Error reading registers from %.16lx&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
id|fp
op_assign
op_amp
id|regs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FULL_REGS
c_func
(paren
id|fp
)paren
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|16
suffix:semicolon
op_increment
id|n
)paren
id|printf
c_func
(paren
l_string|&quot;R%.2ld = %.16lx   R%.2ld = %.16lx&bslash;n&quot;
comma
id|n
comma
id|fp-&gt;gpr
(braket
id|n
)braket
comma
id|n
op_plus
l_int|16
comma
id|fp-&gt;gpr
(braket
id|n
op_plus
l_int|16
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|7
suffix:semicolon
op_increment
id|n
)paren
id|printf
c_func
(paren
l_string|&quot;R%.2ld = %.16lx   R%.2ld = %.16lx&bslash;n&quot;
comma
id|n
comma
id|fp-&gt;gpr
(braket
id|n
)braket
comma
id|n
op_plus
l_int|7
comma
id|fp-&gt;gpr
(braket
id|n
op_plus
l_int|7
)braket
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;pc  = &quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|fp-&gt;nip
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;lr  = &quot;
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
id|fp-&gt;link
comma
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;msr = %.16lx   cr  = %.8lx&bslash;n&quot;
comma
id|fp-&gt;msr
comma
id|fp-&gt;ccr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ctr = %.16lx   xer = %.16lx   trap = %8lx&bslash;n&quot;
comma
id|fp-&gt;ctr
comma
id|fp-&gt;xer
comma
id|fp-&gt;trap
)paren
suffix:semicolon
)brace
DECL|function|cacheflush
r_void
id|cacheflush
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|nflush
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
id|termch
op_assign
id|cmd
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|nflush
op_assign
l_int|1
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|nflush
)paren
suffix:semicolon
id|nflush
op_assign
(paren
id|nflush
op_plus
id|L1_CACHE_BYTES
op_minus
l_int|1
)paren
op_div
id|L1_CACHE_BYTES
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
id|L1_CACHE_BYTES
)paren
id|cflush
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
id|L1_CACHE_BYTES
)paren
id|cinval
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|read_spr
id|read_spr
c_func
(paren
r_int
id|n
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_int
id|ret
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6002a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|opd
suffix:semicolon
id|ret
op_assign
id|code
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|write_spr
id|write_spr
c_func
(paren
r_int
id|n
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6003a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|opd
suffix:semicolon
id|code
c_func
(paren
id|val
)paren
suffix:semicolon
)brace
DECL|variable|regno
r_static
r_int
r_int
id|regno
suffix:semicolon
r_extern
r_char
id|exc_prolog
suffix:semicolon
r_extern
r_char
id|dec_exc
suffix:semicolon
r_void
DECL|function|super_regs
id|super_regs
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
r_struct
id|paca_struct
op_star
id|ptrPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpPaca
op_star
id|ptrLpPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpRegSave
op_star
id|ptrLpRegSave
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_int
r_int
id|sp
comma
id|toc
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sp
)paren
suffix:colon
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|toc
)paren
suffix:colon
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;msr  = %.16lx  sprg0= %.16lx&bslash;n&quot;
comma
id|get_msr
c_func
(paren
)paren
comma
id|get_sprg0
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pvr  = %.16lx  sprg1= %.16lx&bslash;n&quot;
comma
id|get_pvr
c_func
(paren
)paren
comma
id|get_sprg1
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;dec  = %.16lx  sprg2= %.16lx&bslash;n&quot;
comma
id|get_dec
c_func
(paren
)paren
comma
id|get_sprg2
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sp   = %.16lx  sprg3= %.16lx&bslash;n&quot;
comma
id|sp
comma
id|get_sprg3
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;toc  = %.16lx  dar  = %.16lx&bslash;n&quot;
comma
id|toc
comma
id|get_dar
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;srr0 = %.16lx  srr1 = %.16lx&bslash;n&quot;
comma
id|get_srr0
c_func
(paren
)paren
comma
id|get_srr1
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
singleline_comment|// Dump out relevant Paca data areas.
id|printf
c_func
(paren
l_string|&quot;Paca: &bslash;n&quot;
)paren
suffix:semicolon
id|ptrPaca
op_assign
id|get_paca
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Control Area (LpPaca): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpPaca
op_assign
id|ptrPaca-&gt;lppaca_ptr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Srr0=%.16lx  Saved Srr1=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedSrr0
comma
id|ptrLpPaca-&gt;xSavedSrr1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr3=%.16lx  Saved Gpr4=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr3
comma
id|ptrLpPaca-&gt;xSavedGpr4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr5=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr5
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Register Save Area (LpRegSave): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpRegSave
op_assign
id|ptrPaca-&gt;reg_save_ptr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg0=%.16lx  Saved Sprg1=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG0
comma
id|ptrLpRegSave-&gt;xSPRG0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg2=%.16lx  Saved Sprg3=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG2
comma
id|ptrLpRegSave-&gt;xSPRG3
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Msr  =%.16lx  Saved Nia  =%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xMSR
comma
id|ptrLpRegSave-&gt;xNIA
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|regno
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;w&squot;
suffix:colon
id|val
op_assign
id|read_spr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|write_spr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_char|&squot;r&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;spr %lx = %lx&bslash;n&quot;
comma
id|regno
comma
id|read_spr
c_func
(paren
id|regno
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|val
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scannl
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Stuff for reading and writing memory safely&n; */
r_int
DECL|function|mread
id|mread
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|q
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_int
DECL|function|mwrite
id|mwrite
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error writing address %x&bslash;n&quot;
comma
id|adrs
op_plus
id|n
)paren
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|fault_type
r_static
r_int
id|fault_type
suffix:semicolon
DECL|variable|fault_chars
r_static
r_char
op_star
id|fault_chars
(braket
)braket
op_assign
(brace
l_string|&quot;--&quot;
comma
l_string|&quot;**&quot;
comma
l_string|&quot;##&quot;
)brace
suffix:semicolon
r_static
r_int
DECL|function|handle_fault
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_switch
c_cond
(paren
id|TRAP
c_func
(paren
id|regs
)paren
)paren
(brace
r_case
l_int|0x200
suffix:colon
id|fault_type
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x300
suffix:colon
r_case
l_int|0x380
suffix:colon
id|fault_type
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fault_type
op_assign
l_int|2
suffix:semicolon
)brace
m_longjmp
(paren
id|bus_error_jmp
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SWAP
mdefine_line|#define SWAP(a, b, t)&t;((t) = (a), (a) = (b), (b) = (t))
r_void
DECL|function|byterev
id|byterev
c_func
(paren
r_int
r_char
op_star
id|val
comma
r_int
id|size
)paren
(brace
r_int
id|t
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|1
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|3
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|2
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* is there really any use for this? */
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|7
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|6
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|2
)braket
comma
id|val
(braket
l_int|5
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|3
)braket
comma
id|val
(braket
l_int|4
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|brev
r_static
r_int
id|brev
suffix:semicolon
DECL|variable|mnoread
r_static
r_int
id|mnoread
suffix:semicolon
DECL|variable|memex_help_string
r_static
r_char
op_star
id|memex_help_string
op_assign
l_string|&quot;Memory examine command usage:&bslash;n&quot;
l_string|&quot;m [addr] [flags] examine/change memory&bslash;n&quot;
l_string|&quot;  addr is optional.  will start where left off.&bslash;n&quot;
l_string|&quot;  flags may include chars from this set:&bslash;n&quot;
l_string|&quot;    b   modify by bytes (default)&bslash;n&quot;
l_string|&quot;    w   modify by words (2 byte)&bslash;n&quot;
l_string|&quot;    l   modify by longs (4 byte)&bslash;n&quot;
l_string|&quot;    d   modify by doubleword (8 byte)&bslash;n&quot;
l_string|&quot;    r   toggle reverse byte order mode&bslash;n&quot;
l_string|&quot;    n   do not read memory (for i/o spaces)&bslash;n&quot;
l_string|&quot;    .   ok to read (default)&bslash;n&quot;
l_string|&quot;NOTE: flags are saved as defaults&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|memex_subcmd_help_string
r_static
r_char
op_star
id|memex_subcmd_help_string
op_assign
l_string|&quot;Memory examine subcommands:&bslash;n&quot;
l_string|&quot;  hexval   write this val to current location&bslash;n&quot;
l_string|&quot;  &squot;string&squot; write chars from string to this location&bslash;n&quot;
l_string|&quot;  &squot;        increment address&bslash;n&quot;
l_string|&quot;  ^        decrement address&bslash;n&quot;
l_string|&quot;  /        increment addr by 0x10.  //=0x100, ///=0x1000, etc&bslash;n&quot;
l_string|&quot;  &bslash;&bslash;        decrement addr by 0x10.  &bslash;&bslash;&bslash;&bslash;=0x100, &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;=0x1000, etc&bslash;n&quot;
l_string|&quot;  `        clear no-read flag&bslash;n&quot;
l_string|&quot;  ;        stay at this addr&bslash;n&quot;
l_string|&quot;  v        change to byte mode&bslash;n&quot;
l_string|&quot;  w        change to word (2 byte) mode&bslash;n&quot;
l_string|&quot;  l        change to long (4 byte) mode&bslash;n&quot;
l_string|&quot;  u        change to doubleword (8 byte) mode&bslash;n&quot;
l_string|&quot;  m addr   change current addr&bslash;n&quot;
l_string|&quot;  n        toggle no-read flag&bslash;n&quot;
l_string|&quot;  r        toggle byte reverse flag&bslash;n&quot;
l_string|&quot;  &lt; count  back up count bytes&bslash;n&quot;
l_string|&quot;  &gt; count  skip forward count bytes&bslash;n&quot;
l_string|&quot;  x        exit this mode&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_void
DECL|function|memex
id|memex
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
comma
id|inc
comma
id|i
comma
id|nslash
suffix:semicolon
r_int
r_int
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|16
)braket
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|memex_help_string
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|last_cmd
op_assign
l_string|&quot;m&bslash;n&quot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
(brace
id|size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
l_int|8
)paren
(brace
id|size
op_assign
l_int|8
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
id|n
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16x%c&quot;
comma
id|adrs
comma
id|brev
ques
c_cond
l_char|&squot;r&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
(brace
r_if
c_cond
(paren
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|val
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
id|nslash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|n
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
id|inc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|n
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|n
op_assign
id|bsesc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|adrs
op_add_assign
id|size
suffix:semicolon
)brace
id|adrs
op_sub_assign
id|size
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
id|adrs
op_add_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;;&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
r_case
l_char|&squot;v&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
id|adrs
op_sub_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OG
l_int|0
)paren
id|adrs
op_sub_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_add_assign
l_int|4
suffix:semicolon
id|adrs
op_add_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OL
l_int|0
)paren
id|adrs
op_add_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_sub_assign
l_int|4
suffix:semicolon
id|adrs
op_sub_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_add_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|memex_subcmd_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|adrs
op_add_assign
id|inc
suffix:semicolon
)brace
)brace
r_int
DECL|function|bsesc
id|bsesc
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
r_void
DECL|function|dump
id|dump
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|scanhex
c_func
(paren
op_amp
id|nidump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nidump
op_eq
l_int|0
)paren
(brace
id|nidump
op_assign
l_int|16
suffix:semicolon
)brace
id|adrs
op_add_assign
id|ppc_inst_dump
c_func
(paren
id|adrs
comma
id|nidump
comma
l_int|1
)paren
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;di&bslash;n&quot;
suffix:semicolon
)brace
r_else
(brace
id|scanhex
c_func
(paren
op_amp
id|ndump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndump
op_eq
l_int|0
)paren
(brace
id|ndump
op_assign
l_int|64
suffix:semicolon
)brace
id|prdump
c_func
(paren
id|adrs
comma
id|ndump
)paren
suffix:semicolon
id|adrs
op_add_assign
id|ndump
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;d&bslash;n&quot;
suffix:semicolon
)brace
)brace
r_void
DECL|function|prdump
id|prdump
c_func
(paren
r_int
r_int
id|adrs
comma
r_int
id|ndump
)paren
(brace
r_int
id|n
comma
id|m
comma
id|c
comma
id|r
comma
id|nr
suffix:semicolon
r_int
r_char
id|temp
(braket
l_int|16
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|ndump
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16lx&quot;
comma
id|adrs
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|r
op_assign
id|n
OL
l_int|16
ques
c_cond
id|n
suffix:colon
l_int|16
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|temp
comma
id|r
)paren
suffix:semicolon
id|adrs
op_add_assign
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|7
)paren
op_eq
l_int|0
op_logical_and
id|m
OG
l_int|0
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|temp
(braket
id|m
)braket
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
op_le
l_int|8
)paren
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
id|printf
c_func
(paren
l_string|&quot;  &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  |&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|c
op_assign
id|temp
(braket
id|m
)braket
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;~&squot;
ques
c_cond
id|c
suffix:colon
l_char|&squot;.&squot;
)paren
suffix:semicolon
)brace
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|n
op_sub_assign
id|r
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
id|r
)paren
r_break
suffix:semicolon
)brace
)brace
r_int
DECL|function|ppc_inst_dump
id|ppc_inst_dump
c_func
(paren
r_int
r_int
id|adr
comma
r_int
id|count
comma
r_int
id|praddr
)paren
(brace
r_int
id|nr
comma
id|dotted
suffix:semicolon
r_int
r_int
id|first_adr
suffix:semicolon
r_int
r_int
id|inst
comma
id|last_inst
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|dotted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|first_adr
op_assign
id|adr
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
op_decrement
id|count
comma
id|adr
op_add_assign
l_int|4
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|adr
comma
id|val
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|praddr
)paren
(brace
r_const
r_char
op_star
id|x
op_assign
id|fault_chars
(braket
id|fault_type
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx  %s%s%s%s&bslash;n&quot;
comma
id|adr
comma
id|x
comma
id|x
comma
id|x
comma
id|x
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|inst
op_assign
id|GETWORD
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adr
OG
id|first_adr
op_logical_and
id|inst
op_eq
id|last_inst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dotted
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; ...&bslash;n&quot;
)paren
suffix:semicolon
id|dotted
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|dotted
op_assign
l_int|0
suffix:semicolon
id|last_inst
op_assign
id|inst
suffix:semicolon
r_if
c_cond
(paren
id|praddr
)paren
id|printf
c_func
(paren
l_string|&quot;%.16lx  %.8x&quot;
comma
id|adr
comma
id|inst
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&quot;
)paren
suffix:semicolon
id|print_insn_powerpc
c_func
(paren
id|inst
comma
id|adr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* always returns 4 */
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|adr
op_minus
id|first_adr
suffix:semicolon
)brace
r_void
DECL|function|print_address
id|print_address
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|xmon_print_symbol
c_func
(paren
id|addr
comma
l_string|&quot;&bslash;t# &quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Memory operations - move, set, print differences&n; */
DECL|variable|mdest
r_static
r_int
r_int
id|mdest
suffix:semicolon
multiline_comment|/* destination address */
DECL|variable|msrc
r_static
r_int
r_int
id|msrc
suffix:semicolon
multiline_comment|/* source address */
DECL|variable|mval
r_static
r_int
r_int
id|mval
suffix:semicolon
multiline_comment|/* byte value to set memory to */
DECL|variable|mcount
r_static
r_int
r_int
id|mcount
suffix:semicolon
multiline_comment|/* # bytes to affect */
DECL|variable|mdiffs
r_static
r_int
r_int
id|mdiffs
suffix:semicolon
multiline_comment|/* max # differences to print */
r_void
DECL|function|memops
id|memops
c_func
(paren
r_int
id|cmd
)paren
(brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
ques
c_cond
op_amp
id|mval
suffix:colon
op_amp
id|msrc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mcount
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|memmove
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
(paren
r_void
op_star
)paren
id|msrc
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
id|mval
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdiffs
)paren
suffix:semicolon
id|memdiffs
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mdest
comma
(paren
r_int
r_char
op_star
)paren
id|msrc
comma
id|mcount
comma
id|mdiffs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_void
DECL|function|memdiffs
id|memdiffs
c_func
(paren
r_int
r_char
op_star
id|p1
comma
r_int
r_char
op_star
id|p2
comma
r_int
id|nb
comma
r_int
id|maxpr
)paren
(brace
r_int
id|n
comma
id|prt
suffix:semicolon
id|prt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|nb
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
op_decrement
id|n
)paren
r_if
c_cond
(paren
op_star
id|p1
op_increment
op_ne
op_star
id|p2
op_increment
)paren
r_if
c_cond
(paren
op_increment
id|prt
op_le
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x %.2x # %.16x %.2x&bslash;n&quot;
comma
id|p1
op_minus
l_int|1
comma
id|p1
(braket
op_minus
l_int|1
)braket
comma
id|p2
op_minus
l_int|1
comma
id|p2
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prt
OG
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Total of %d differences&bslash;n&quot;
comma
id|prt
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mend
r_static
r_int
id|mend
suffix:semicolon
DECL|variable|mask
r_static
r_int
id|mask
suffix:semicolon
r_void
DECL|function|memlocate
id|memlocate
c_func
(paren
r_void
)paren
(brace
r_int
id|a
comma
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;ml&quot;
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mval
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mask
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mend
suffix:semicolon
id|a
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|a
comma
id|val
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
(paren
(paren
id|GETWORD
c_func
(paren
id|val
)paren
op_xor
id|mval
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x:  %.16x&bslash;n&quot;
comma
id|a
comma
id|GETWORD
c_func
(paren
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|n
op_ge
l_int|10
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|mskip
r_static
r_int
r_int
id|mskip
op_assign
l_int|0x1000
suffix:semicolon
DECL|variable|mlim
r_static
r_int
r_int
id|mlim
op_assign
l_int|0xffffffff
suffix:semicolon
r_void
DECL|function|memzcan
id|memzcan
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|v
suffix:semicolon
r_int
id|a
suffix:semicolon
r_int
id|ok
comma
id|ook
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mskip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mlim
)paren
suffix:semicolon
id|ook
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mlim
suffix:semicolon
id|a
op_add_assign
id|mskip
)paren
(brace
id|ok
op_assign
id|mread
c_func
(paren
id|a
comma
op_amp
id|v
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
op_logical_and
op_logical_neg
id|ook
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x .. &quot;
comma
id|a
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ok
op_logical_and
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
id|ook
op_assign
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|mskip
OL
id|a
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
)brace
multiline_comment|/* Input scanning routines */
r_int
DECL|function|skipbl
id|skipbl
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_int|0
)paren
(brace
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|N_PTREGS
mdefine_line|#define N_PTREGS&t;44
DECL|variable|regnames
r_static
r_char
op_star
id|regnames
(braket
id|N_PTREGS
)braket
op_assign
(brace
l_string|&quot;r0&quot;
comma
l_string|&quot;r1&quot;
comma
l_string|&quot;r2&quot;
comma
l_string|&quot;r3&quot;
comma
l_string|&quot;r4&quot;
comma
l_string|&quot;r5&quot;
comma
l_string|&quot;r6&quot;
comma
l_string|&quot;r7&quot;
comma
l_string|&quot;r8&quot;
comma
l_string|&quot;r9&quot;
comma
l_string|&quot;r10&quot;
comma
l_string|&quot;r11&quot;
comma
l_string|&quot;r12&quot;
comma
l_string|&quot;r13&quot;
comma
l_string|&quot;r14&quot;
comma
l_string|&quot;r15&quot;
comma
l_string|&quot;r16&quot;
comma
l_string|&quot;r17&quot;
comma
l_string|&quot;r18&quot;
comma
l_string|&quot;r19&quot;
comma
l_string|&quot;r20&quot;
comma
l_string|&quot;r21&quot;
comma
l_string|&quot;r22&quot;
comma
l_string|&quot;r23&quot;
comma
l_string|&quot;r24&quot;
comma
l_string|&quot;r25&quot;
comma
l_string|&quot;r26&quot;
comma
l_string|&quot;r27&quot;
comma
l_string|&quot;r28&quot;
comma
l_string|&quot;r29&quot;
comma
l_string|&quot;r30&quot;
comma
l_string|&quot;r31&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;msr&quot;
comma
l_string|&quot;or3&quot;
comma
l_string|&quot;ctr&quot;
comma
l_string|&quot;lr&quot;
comma
l_string|&quot;xer&quot;
comma
l_string|&quot;ccr&quot;
comma
l_string|&quot;softe&quot;
comma
l_string|&quot;trap&quot;
comma
l_string|&quot;dar&quot;
comma
l_string|&quot;dsisr&quot;
comma
l_string|&quot;res&quot;
)brace
suffix:semicolon
r_int
DECL|function|scanhex
id|scanhex
c_func
(paren
r_int
r_int
op_star
id|vp
)paren
(brace
r_int
id|c
comma
id|d
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;%&squot;
)paren
(brace
multiline_comment|/* parse register name */
r_char
id|regname
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regname
)paren
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isalnum
c_func
(paren
id|c
)paren
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_break
suffix:semicolon
)brace
id|regname
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|regname
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_PTREGS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regnames
(braket
id|i
)braket
comma
id|regname
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|xmon_regs
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;regs not available&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|vp
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|xmon_regs
)paren
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;invalid register name &squot;%%%s&squot;&bslash;n&quot;
comma
id|regname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* skip leading &quot;0x&quot; if any */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;x&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
id|EOF
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|vp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;$&squot;
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|63
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmpstr
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|tmpstr
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|vp
op_assign
id|kallsyms_lookup_name
c_func
(paren
id|tmpstr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|vp
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;unknown symbol &squot;%s&squot;&bslash;n&quot;
comma
id|tmpstr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
id|EOF
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|v
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|v
op_assign
(paren
id|v
op_lshift
l_int|4
)paren
op_plus
id|d
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
op_ne
id|EOF
)paren
suffix:semicolon
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|vp
op_assign
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|scannl
id|scannl
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|hexdigit
id|hexdigit
c_func
(paren
r_int
id|c
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
r_return
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_return
id|EOF
suffix:semicolon
)brace
r_void
DECL|function|getstring
id|getstring
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|size
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|size
OG
l_int|1
)paren
(brace
op_star
id|s
op_increment
op_assign
id|c
suffix:semicolon
op_decrement
id|size
suffix:semicolon
)brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot; &squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|s
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
r_void
DECL|function|flush_input
id|flush_input
c_func
(paren
r_void
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|inchar
id|inchar
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|lineptr
op_eq
l_int|NULL
op_logical_or
op_star
id|lineptr
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_eq
l_int|NULL
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|EOF
suffix:semicolon
)brace
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_void
DECL|function|take_input
id|take_input
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|lineptr
op_assign
id|str
suffix:semicolon
)brace
r_static
r_void
DECL|function|symbol_lookup
id|symbol_lookup
c_func
(paren
r_void
)paren
(brace
r_int
id|type
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_static
r_char
id|tmp
(braket
l_int|64
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_char|&squot;a&squot;
suffix:colon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|addr
)paren
)paren
id|xmon_print_symbol
c_func
(paren
id|addr
comma
l_string|&quot;: &quot;
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|getstring
c_func
(paren
id|tmp
comma
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|addr
op_assign
id|kallsyms_lookup_name
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|printf
c_func
(paren
l_string|&quot;%s: %lx&bslash;n&quot;
comma
id|tmp
comma
id|addr
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;Symbol &squot;%s&squot; not found.&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Print an address in numeric and symbolic form (if possible) */
DECL|function|xmon_print_symbol
r_static
r_void
id|xmon_print_symbol
c_func
(paren
r_int
r_int
id|address
comma
r_const
r_char
op_star
id|mid
comma
r_const
r_char
op_star
id|after
)paren
(brace
r_char
op_star
id|modname
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|offset
comma
id|size
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx&quot;
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|catch_memory_errors
op_assign
l_int|1
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|kallsyms_lookup
c_func
(paren
id|address
comma
op_amp
id|size
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|tmpstr
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
id|catch_memory_errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s%s+%#lx/%#lx&quot;
comma
id|mid
comma
id|name
comma
id|offset
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|modname
)paren
id|printf
c_func
(paren
l_string|&quot; [%s]&quot;
comma
id|modname
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|after
)paren
suffix:semicolon
)brace
DECL|function|debug_trace
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|val
comma
id|cmd
comma
id|on
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* show current state */
r_int
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;naca-&gt;debug_switch = 0x%lx&bslash;n&quot;
comma
id|naca-&gt;debug_switch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PPCDBG_NUM_FLAGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|on
op_assign
id|PPCDBG_BITVAL
c_func
(paren
id|i
)paren
op_amp
id|naca-&gt;debug_switch
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%02x %s %12s   &quot;
comma
id|i
comma
id|on
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
comma
id|trace_names
(braket
id|i
)braket
ques
c_cond
id|trace_names
(braket
id|i
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|on
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default if no sign given */
r_while
c_loop
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|on
op_assign
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot; &squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* Turn on or off based on + or - */
id|naca-&gt;debug_switch
op_assign
id|on
ques
c_cond
id|PPCDBG_ALL
suffix:colon
id|PPCDBG_NONE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Setting all values to %s...&bslash;n&quot;
comma
id|on
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
suffix:semicolon
r_else
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* not +/- ... let scanhex see it */
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|64
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Value %x out of range:&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on
)paren
(brace
id|naca-&gt;debug_switch
op_or_assign
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;enable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|naca-&gt;debug_switch
op_and_assign
op_complement
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;disable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|dump_slb
r_static
r_void
id|dump_slb
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SLB contents of cpu %x&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SLB_NUM_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;slbmfee  %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%02d %016lx &quot;
comma
id|i
comma
id|tmp
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;slbmfev  %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%016lx&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
)brace
DECL|function|dump_stab
r_static
r_void
id|dump_stab
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|tmp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|stab_addr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Segment table contents of cpu %x&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGE_SIZE
op_div
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
id|tmp
op_increment
suffix:semicolon
id|b
op_assign
op_star
id|tmp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|a
op_logical_or
id|b
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%03d %016lx &quot;
comma
id|i
comma
id|a
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%016lx&bslash;n&quot;
comma
id|b
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|xmon_init
r_void
id|xmon_init
c_func
(paren
r_void
)paren
(brace
id|__debugger
op_assign
id|xmon
suffix:semicolon
id|__debugger_ipi
op_assign
id|xmon_ipi
suffix:semicolon
id|__debugger_bpt
op_assign
id|xmon_bpt
suffix:semicolon
id|__debugger_sstep
op_assign
id|xmon_sstep
suffix:semicolon
id|__debugger_iabr_match
op_assign
id|xmon_iabr_match
suffix:semicolon
id|__debugger_dabr_match
op_assign
id|xmon_dabr_match
suffix:semicolon
id|__debugger_fault_handler
op_assign
id|xmon_fault_handler
suffix:semicolon
)brace
DECL|function|dump_segments
r_void
id|dump_segments
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_SLB
)paren
id|dump_slb
c_func
(paren
)paren
suffix:semicolon
r_else
id|dump_stab
c_func
(paren
)paren
suffix:semicolon
)brace
eof
