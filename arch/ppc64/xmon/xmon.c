multiline_comment|/*&n; * Routines providing a simple monitor for use on the PowerMac.&n; *&n; * Copyright (C) 1996 Paul Mackerras.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &quot;nonstdio.h&quot;
macro_line|#include &quot;privinst.h&quot;
DECL|macro|scanhex
mdefine_line|#define scanhex&t;xmon_scanhex
DECL|macro|skipbl
mdefine_line|#define skipbl&t;xmon_skipbl
macro_line|#ifdef CONFIG_SMP
DECL|variable|cpus_in_xmon
r_int
r_int
id|cpus_in_xmon
op_assign
l_int|0
suffix:semicolon
DECL|variable|got_xmon
r_static
r_int
r_int
id|got_xmon
op_assign
l_int|0
suffix:semicolon
DECL|variable|take_xmon
r_static
r_volatile
r_int
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
DECL|variable|adrs
r_static
r_int
r_int
id|adrs
suffix:semicolon
DECL|variable|size
r_static
r_int
id|size
op_assign
l_int|1
suffix:semicolon
DECL|variable|ndump
r_static
r_int
r_int
id|ndump
op_assign
l_int|64
suffix:semicolon
DECL|variable|nidump
r_static
r_int
r_int
id|nidump
op_assign
l_int|16
suffix:semicolon
DECL|variable|ncsum
r_static
r_int
r_int
id|ncsum
op_assign
l_int|4096
suffix:semicolon
DECL|variable|termch
r_static
r_int
id|termch
suffix:semicolon
DECL|variable|bus_error_jmp
r_static
id|u_int
id|bus_error_jmp
(braket
l_int|100
)braket
suffix:semicolon
DECL|macro|setjmp
mdefine_line|#define setjmp xmon_setjmp
DECL|macro|longjmp
mdefine_line|#define longjmp xmon_longjmp
DECL|macro|memlist_entry
mdefine_line|#define memlist_entry list_entry
DECL|macro|memlist_next
mdefine_line|#define memlist_next(x) ((x)-&gt;next)
DECL|macro|memlist_prev
mdefine_line|#define memlist_prev(x) ((x)-&gt;prev)
multiline_comment|/* Max number of stack frames we are willing to produce on a backtrace. */
DECL|macro|MAXFRAMECOUNT
mdefine_line|#define MAXFRAMECOUNT 50
multiline_comment|/* Breakpoint stuff */
DECL|struct|bpt
r_struct
id|bpt
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|instr
r_int
id|instr
suffix:semicolon
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
DECL|member|funcname
r_char
id|funcname
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* function name for humans */
)brace
suffix:semicolon
DECL|macro|NBPTS
mdefine_line|#define NBPTS&t;16
DECL|variable|bpts
r_static
r_struct
id|bpt
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
DECL|variable|dabr
r_static
r_struct
id|bpt
id|dabr
suffix:semicolon
DECL|variable|iabr
r_static
r_struct
id|bpt
id|iabr
suffix:semicolon
DECL|variable|bpinstr
r_static
r_int
id|bpinstr
op_assign
l_int|0x7fe00008
suffix:semicolon
multiline_comment|/* trap */
multiline_comment|/* Prototypes */
r_extern
r_void
(paren
op_star
id|debugger_fault_handler
)paren
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|mread
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mwrite
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|byterev
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|memex
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bsesc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|prdump
c_func
(paren
r_int
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef __MWERKS__
r_static
r_void
id|prndump
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nvreadb
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ppc_inst_dump
c_func
(paren
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|print_address
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|getsp
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump_hash_table
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|memops
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|memlocate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memzcan
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memdiffs
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|skipbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|scanhex
c_func
(paren
r_int
r_int
op_star
id|valp
)paren
suffix:semicolon
r_static
r_void
id|scannl
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|hexdigit
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|getstring
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|flush_input
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|inchar
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|take_input
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* static void openforth(void); */
r_static
r_int
r_int
id|read_spr
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|write_spr
c_func
(paren
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|super_regs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_sysmap
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|remove_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|insert_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|bpt
op_star
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
r_static
r_void
id|bpt_cmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|cacheflush
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|cpu_cmd
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
r_static
r_void
id|csum
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mem_translate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mem_check
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mem_find_real
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mem_find_vsid
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|print_insn_big_powerpc
c_func
(paren
id|FILE
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_void
id|xmon_vfprintf
c_func
(paren
r_void
op_star
id|f
comma
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|ap
)paren
suffix:semicolon
r_extern
r_int
id|xmon_putc
c_func
(paren
r_int
id|c
comma
r_void
op_star
id|f
)paren
suffix:semicolon
r_extern
r_int
id|putchar
c_func
(paren
r_int
id|ch
)paren
suffix:semicolon
r_extern
r_int
id|xmon_read_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
m_setjmp
(paren
id|u_int
op_star
)paren
suffix:semicolon
r_extern
r_void
m_longjmp
(paren
id|u_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|_ASR
suffix:semicolon
id|pte_t
op_star
id|find_linux_pte
c_func
(paren
id|pgd_t
op_star
id|pgdir
comma
r_int
r_int
id|va
)paren
suffix:semicolon
multiline_comment|/* from htab.c */
DECL|macro|GETWORD
mdefine_line|#define GETWORD(v)&t;(((v)[0] &lt;&lt; 24) + ((v)[1] &lt;&lt; 16) + ((v)[2] &lt;&lt; 8) + (v)[3])
DECL|variable|help_string
r_static
r_char
op_star
id|help_string
op_assign
l_string|&quot;&bslash;&n;Commands:&bslash;n&bslash;&n;  b&t;show breakpoints&bslash;n&bslash;&n;  bd&t;set data breakpoint&bslash;n&bslash;&n;  bi&t;set instruction breakpoint&bslash;n&bslash;&n;  bc&t;clear breakpoint&bslash;n&bslash;&n;  d&t;dump bytes&bslash;n&bslash;&n;  di&t;dump instructions&bslash;n&bslash;&n;  df&t;dump float values&bslash;n&bslash;&n;  dd&t;dump double values&bslash;n&bslash;&n;  e&t;print exception information&bslash;n&bslash;&n;  f&t;flush cache&bslash;n&bslash;&n;  h&t;dump hash table&bslash;n&bslash;&n;  m&t;examine/change memory&bslash;n&bslash;&n;  mm&t;move a block of memory&bslash;n&bslash;&n;  ms&t;set a block of memory&bslash;n&bslash;&n;  md&t;compare two blocks of memory&bslash;n&bslash;&n;  ml&t;locate a block of memory&bslash;n&bslash;&n;  mz&t;zero a block of memory&bslash;n&bslash;&n;  mx&t;translation information for an effective address&bslash;n&bslash;&n;  mi&t;show information about memory allocation&bslash;n&bslash;&n;  M&t;print System.map&bslash;n&bslash;&n;  p &t;show the task list&bslash;n&bslash;&n;  r&t;print registers&bslash;n&bslash;&n;  s&t;single step&bslash;n&bslash;&n;  S&t;print special registers&bslash;n&bslash;&n;  t&t;print backtrace&bslash;n&bslash;&n;  T&t;Enable/Disable PPCDBG flags&bslash;n&bslash;&n;  x&t;exit monitor&bslash;n&bslash;&n;  z&t;reboot&bslash;n&bslash;&n;  Z&t;halt&bslash;n&bslash;&n;&quot;
suffix:semicolon
DECL|variable|xmon_trace
r_static
r_int
id|xmon_trace
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|SSTEP
mdefine_line|#define SSTEP&t;1&t;&t;/* stepping because of &squot;s&squot; command */
DECL|macro|BRSTEP
mdefine_line|#define BRSTEP&t;2&t;&t;/* stepping over breakpoint */
multiline_comment|/*&n; * Stuff for reading and writing memory safely&n; */
DECL|function|sync
r_extern
r_inline
r_void
id|sync
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;sync; isync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* (Ref: 64-bit PowerPC ELF ABI Spplement; Ian Lance Taylor, Zembu Labs).&n; A PPC stack frame looks like this:&n;&n; High Address&n;    Back Chain&n;    FP reg save area&n;    GP reg save area&n;    Local var space&n;    Parameter save area&t;&t;(SP+48)&n;    TOC save area&t;&t;(SP+40)&n;    link editor doubleword&t;(SP+32)&n;    compiler doubleword&t;&t;(SP+24)&n;    LR save&t;&t;&t;(SP+16)&n;    CR save&t;&t;&t;(SP+8)&n;    Back Chain&t;&t;&t;(SP+0)&n;&n; Note that the LR (ret addr) may not be saved in the current frame if&n; no functions have been called from the current function.&n; */
multiline_comment|/*&n; A traceback table typically follows each function.&n; The find_tb_table() func will fill in this struct.  Note that the struct&n; is not an exact match with the encoded table defined by the ABI.  It is&n; defined here more for programming convenience.&n; */
DECL|struct|tbtable
r_struct
id|tbtable
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* flags: */
DECL|macro|TBTAB_FLAGSGLOBALLINK
mdefine_line|#define TBTAB_FLAGSGLOBALLINK&t;(1L&lt;&lt;47)
DECL|macro|TBTAB_FLAGSISEPROL
mdefine_line|#define TBTAB_FLAGSISEPROL&t;(1L&lt;&lt;46)
DECL|macro|TBTAB_FLAGSHASTBOFF
mdefine_line|#define TBTAB_FLAGSHASTBOFF&t;(1L&lt;&lt;45)
DECL|macro|TBTAB_FLAGSINTPROC
mdefine_line|#define TBTAB_FLAGSINTPROC&t;(1L&lt;&lt;44)
DECL|macro|TBTAB_FLAGSHASCTL
mdefine_line|#define TBTAB_FLAGSHASCTL&t;(1L&lt;&lt;43)
DECL|macro|TBTAB_FLAGSTOCLESS
mdefine_line|#define TBTAB_FLAGSTOCLESS&t;(1L&lt;&lt;42)
DECL|macro|TBTAB_FLAGSFPPRESENT
mdefine_line|#define TBTAB_FLAGSFPPRESENT&t;(1L&lt;&lt;41)
DECL|macro|TBTAB_FLAGSNAMEPRESENT
mdefine_line|#define TBTAB_FLAGSNAMEPRESENT&t;(1L&lt;&lt;38)
DECL|macro|TBTAB_FLAGSUSESALLOCA
mdefine_line|#define TBTAB_FLAGSUSESALLOCA&t;(1L&lt;&lt;37)
DECL|macro|TBTAB_FLAGSSAVESCR
mdefine_line|#define TBTAB_FLAGSSAVESCR&t;(1L&lt;&lt;33)
DECL|macro|TBTAB_FLAGSSAVESLR
mdefine_line|#define TBTAB_FLAGSSAVESLR&t;(1L&lt;&lt;32)
DECL|macro|TBTAB_FLAGSSTORESBC
mdefine_line|#define TBTAB_FLAGSSTORESBC&t;(1L&lt;&lt;31)
DECL|macro|TBTAB_FLAGSFIXUP
mdefine_line|#define TBTAB_FLAGSFIXUP&t;(1L&lt;&lt;30)
DECL|macro|TBTAB_FLAGSPARMSONSTK
mdefine_line|#define TBTAB_FLAGSPARMSONSTK&t;(1L&lt;&lt;0)
DECL|member|fp_saved
r_int
r_char
id|fp_saved
suffix:semicolon
multiline_comment|/* num fp regs saved f(32-n)..f31 */
DECL|member|gpr_saved
r_int
r_char
id|gpr_saved
suffix:semicolon
multiline_comment|/* num gpr&squot;s saved */
DECL|member|fixedparms
r_int
r_char
id|fixedparms
suffix:semicolon
multiline_comment|/* num fixed point parms */
DECL|member|floatparms
r_int
r_char
id|floatparms
suffix:semicolon
multiline_comment|/* num float parms */
DECL|member|parminfo
r_int
r_char
id|parminfo
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* types of args.  null terminated */
DECL|macro|TBTAB_PARMFIXED
mdefine_line|#define TBTAB_PARMFIXED 1
DECL|macro|TBTAB_PARMSFLOAT
mdefine_line|#define TBTAB_PARMSFLOAT 2
DECL|macro|TBTAB_PARMDFLOAT
mdefine_line|#define TBTAB_PARMDFLOAT 3
DECL|member|tb_offset
r_int
r_int
id|tb_offset
suffix:semicolon
multiline_comment|/* offset from start of func */
DECL|member|funcstart
r_int
r_int
id|funcstart
suffix:semicolon
multiline_comment|/* addr of start of function */
DECL|member|name
r_char
id|name
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* name of function (null terminated)*/
)brace
suffix:semicolon
r_static
r_int
id|find_tb_table
c_func
(paren
r_int
r_int
id|codeaddr
comma
r_struct
id|tbtable
op_star
id|tab
)paren
suffix:semicolon
DECL|macro|SURVEILLANCE_TOKEN
mdefine_line|#define SURVEILLANCE_TOKEN&t;9000
DECL|function|disable_surveillance
r_static
r_inline
r_void
id|disable_surveillance
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_PPC_ISERIES
id|rtas_call
c_func
(paren
id|rtas_token
c_func
(paren
l_string|&quot;set-indicator&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
l_int|NULL
comma
id|SURVEILLANCE_TOKEN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|xmon
id|xmon
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|msr
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Ok, grab regs as they are now.&n;&t;&t; This won&squot;t do a particularily good job because the&n;&t;&t; prologue has already been executed.&n;&t;&t; ToDo: We could reach back into the callers save&n;&t;&t; area to do a better job of representing the&n;&t;&t; caller&squot;s state.&n;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;std&t;0,0(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;1,8(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;2,16(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;3,24(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;4,32(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;5,40(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;6,48(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;7,56(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;8,64(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;9,72(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;10,80(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;11,88(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;12,96(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;13,104(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;14,112(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;15,120(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;16,128(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;17,136(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;18,144(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;19,152(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;20,160(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;21,168(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;22,176(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;23,184(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;24,192(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;25,200(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;26,208(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;27,216(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;28,224(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;29,232(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;30,240(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;31,248(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
op_amp
id|regs
)paren
)paren
suffix:semicolon
multiline_comment|/* Fetch the link reg for this stack frame.&n;&t;&t; NOTE: the prev printf fills in the lr. */
id|regs.nip
op_assign
id|regs.link
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs.gpr
(braket
l_int|1
)braket
)paren
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|regs.msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|regs.ctr
op_assign
id|get_ctr
c_func
(paren
)paren
suffix:semicolon
id|regs.xer
op_assign
id|get_xer
c_func
(paren
)paren
suffix:semicolon
id|regs.ccr
op_assign
id|get_cr
c_func
(paren
)paren
suffix:semicolon
id|regs.trap
op_assign
l_int|0
suffix:semicolon
id|excp
op_assign
op_amp
id|regs
suffix:semicolon
)brace
id|msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|msr
op_amp
op_complement
id|MSR_EE
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
op_amp
id|cpus_in_xmon
)paren
)paren
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
)paren
(brace
r_if
c_cond
(paren
id|take_xmon
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * XXX: breakpoints are removed while any cpu is in xmon&n;&t; */
macro_line|#endif /* CONFIG_SMP */
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|disable_surveillance
c_func
(paren
)paren
suffix:semicolon
id|cmd
op_assign
id|cmds
c_func
(paren
id|excp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|SSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|at_breakpoint
c_func
(paren
id|excp-&gt;nip
)paren
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
op_amp
id|cpus_in_xmon
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|set_msrd
c_func
(paren
id|msr
)paren
suffix:semicolon
multiline_comment|/* restore interrupt enable */
)brace
multiline_comment|/* Code can call this to get a backtrace and continue. */
r_void
DECL|function|xmon_backtrace
id|xmon_backtrace
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
multiline_comment|/* Ok, grab regs as they are now.&n;&t; This won&squot;t do a particularily good job because the&n;&t; prologue has already been executed.&n;&t; ToDo: We could reach back into the callers save&n;&t; area to do a better job of representing the&n;&t; caller&squot;s state.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;std&t;0,0(%0)&bslash;n&bslash;&n;&t;    std&t;1,8(%0)&bslash;n&bslash;&n;&t;    std&t;2,16(%0)&bslash;n&bslash;&n;&t;    std&t;3,24(%0)&bslash;n&bslash;&n;&t;    std&t;4,32(%0)&bslash;n&bslash;&n;&t;    std&t;5,40(%0)&bslash;n&bslash;&n;&t;    std&t;6,48(%0)&bslash;n&bslash;&n;&t;    std&t;7,56(%0)&bslash;n&bslash;&n;&t;    std&t;8,64(%0)&bslash;n&bslash;&n;&t;    std&t;9,72(%0)&bslash;n&bslash;&n;&t;    std&t;10,80(%0)&bslash;n&bslash;&n;&t;    std&t;11,88(%0)&bslash;n&bslash;&n;&t;    std&t;12,96(%0)&bslash;n&bslash;&n;&t;    std&t;13,104(%0)&bslash;n&bslash;&n;&t;    std&t;14,112(%0)&bslash;n&bslash;&n;&t;    std&t;15,120(%0)&bslash;n&bslash;&n;&t;    std&t;16,128(%0)&bslash;n&bslash;&n;&t;    std&t;17,136(%0)&bslash;n&bslash;&n;&t;    std&t;18,144(%0)&bslash;n&bslash;&n;&t;    std&t;19,152(%0)&bslash;n&bslash;&n;&t;    std&t;20,160(%0)&bslash;n&bslash;&n;&t;    std&t;21,168(%0)&bslash;n&bslash;&n;&t;    std&t;22,176(%0)&bslash;n&bslash;&n;&t;    std&t;23,184(%0)&bslash;n&bslash;&n;&t;    std&t;24,192(%0)&bslash;n&bslash;&n;&t;    std&t;25,200(%0)&bslash;n&bslash;&n;&t;    std&t;26,208(%0)&bslash;n&bslash;&n;&t;    std&t;27,216(%0)&bslash;n&bslash;&n;&t;    std&t;28,224(%0)&bslash;n&bslash;&n;&t;    std&t;29,232(%0)&bslash;n&bslash;&n;&t;    std&t;30,240(%0)&bslash;n&bslash;&n;&t;    std&t;31,248(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
op_amp
id|regs
)paren
)paren
suffix:semicolon
multiline_comment|/* Fetch the link reg for this stack frame.&n;&t; NOTE: the prev printf fills in the lr. */
id|regs.nip
op_assign
id|regs.link
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs.gpr
(braket
l_int|1
)braket
)paren
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|regs.msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|regs.ctr
op_assign
id|get_ctr
c_func
(paren
)paren
suffix:semicolon
id|regs.xer
op_assign
id|get_xer
c_func
(paren
)paren
suffix:semicolon
id|regs.ccr
op_assign
id|get_cr
c_func
(paren
)paren
suffix:semicolon
id|regs.trap
op_assign
l_int|0
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|xmon_vfprintf
c_func
(paren
id|stdout
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|xmon_putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stdout
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|take_input
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|backtrace
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* Call this to poll for ^C during busy operations.&n; * Returns true if the user has hit ^C.&n; */
r_int
DECL|function|xmon_interrupted
id|xmon_interrupted
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
id|xmon_read_poll
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|3
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n^C interrupted.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xmon_irq
id|xmon_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|d
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Keyboard interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|xmon_bpt
id|xmon_bpt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;count
)paren
(brace
op_decrement
id|bp-&gt;count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Stopped at breakpoint %x (%lx %s)&bslash;n&quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
comma
id|bp-&gt;funcname
)paren
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_sstep
id|xmon_sstep
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_eq
id|BRSTEP
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_dabr_match
id|xmon_dabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|dabr.count
)paren
(brace
op_decrement
id|dabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|dabr.instr
op_assign
id|regs-&gt;nip
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_iabr_match
id|xmon_iabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|iabr.count
)paren
(brace
op_decrement
id|iabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|bpt
op_star
DECL|function|at_breakpoint
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|pc
op_eq
id|dabr.instr
)paren
r_return
op_amp
id|dabr
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|pc
op_eq
id|iabr.address
)paren
r_return
op_amp
id|iabr
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
op_logical_and
id|pc
op_eq
id|bp-&gt;address
)paren
r_return
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|insert_bpts
id|insert_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_ne
id|PLATFORM_PSERIES
)paren
r_return
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
op_logical_or
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bpinstr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t insert breakpoint at %x, disabling&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
op_logical_and
op_logical_neg
id|__is_processor
c_func
(paren
id|PV_POWER4p
)paren
)paren
(brace
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|set_dabr
c_func
(paren
id|dabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|set_iabr
c_func
(paren
id|iabr.address
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|remove_bpts
id|remove_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
id|instr
suffix:semicolon
r_if
c_cond
(paren
id|naca-&gt;platform
op_ne
id|PLATFORM_PSERIES
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
op_logical_and
op_logical_neg
id|__is_processor
c_func
(paren
id|PV_POWER4p
)paren
)paren
(brace
id|set_dabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_iabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|instr
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
id|instr
op_eq
id|bpinstr
op_logical_and
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t remove breakpoint at %x&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
r_else
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|variable|last_cmd
r_static
r_char
op_star
id|last_cmd
suffix:semicolon
multiline_comment|/* Command interpreting routine */
r_static
r_int
DECL|function|cmds
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
id|cmd
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|printf
c_func
(paren
l_string|&quot;%d:&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printf
c_func
(paren
l_string|&quot;mon&gt; &quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|flush_input
c_func
(paren
)paren
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|last_cmd
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|take_input
c_func
(paren
id|last_cmd
)paren
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;z&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Rebooting machine now...&quot;
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;Z&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Halting machine now...&quot;
)paren
suffix:semicolon
id|machine_halt
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
id|memops
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|memlocate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|memzcan
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
id|mem_translate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
id|mem_check
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|mem_find_real
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|mem_find_vsid
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|show_mem
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|memex
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|dump
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_ne
l_int|NULL
)paren
id|prregs
c_func
(paren
id|excp
)paren
suffix:semicolon
multiline_comment|/* print regs */
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot;No exception information&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|print_sysmap
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|super_regs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|backtrace
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|cacheflush
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|dump_hash_table
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
r_return
id|cmd
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
id|show_state
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|bpt_cmds
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|csum
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_case
l_char|&squot;c&squot;
suffix:colon
id|cpu_cmd
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
r_case
l_char|&squot;T&squot;
suffix:colon
id|debug_trace
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Unrecognized command: &quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
l_char|&squot; &squot;
OL
id|cmd
op_logical_and
id|cmd
op_le
l_char|&squot;~&squot;
)paren
(brace
id|putchar
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&bslash;x%x&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (type ? for help)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|cpu_cmd
r_static
r_void
id|cpu_cmd
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;stopping all cpus&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* interrupt other cpu(s) */
id|cpu
op_assign
id|MSG_ALL_BUT_SELF
suffix:semicolon
id|smp_send_xmon_break
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|cpu
)paren
)paren
(brace
multiline_comment|/* print cpus waiting or in xmon */
id|printf
c_func
(paren
l_string|&quot;cpus stopped:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|cpu
comma
op_amp
id|cpus_in_xmon
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; %x&quot;
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;*&quot;
comma
id|cpu
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* try to switch to cpu specified */
id|take_xmon
op_assign
id|cpu
suffix:semicolon
id|timeout
op_assign
l_int|10000000
suffix:semicolon
r_while
c_loop
(paren
id|take_xmon
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
op_eq
l_int|0
)paren
(brace
multiline_comment|/* yes there&squot;s a race here */
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;cpu %u didn&squot;t take control&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* now have to wait to be given control back */
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
)paren
(brace
r_if
c_cond
(paren
id|take_xmon
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|variable|fcstab
r_static
r_int
r_int
id|fcstab
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|macro|FCS
mdefine_line|#define FCS(fcs, c)&t;(((fcs) &gt;&gt; 8) ^ fcstab[((fcs) ^ (c)) &amp; 0xff])
r_static
r_void
DECL|function|csum
id|csum
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|fcs
suffix:semicolon
r_int
r_char
id|v
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|ncsum
)paren
)paren
r_return
suffix:semicolon
id|fcs
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ncsum
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|adrs
op_plus
id|i
comma
op_amp
id|v
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;csum stopped at %x&bslash;n&quot;
comma
id|adrs
op_plus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fcs
op_assign
id|FCS
c_func
(paren
id|fcs
comma
id|v
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%x&bslash;n&quot;
comma
id|fcs
)paren
suffix:semicolon
)brace
DECL|variable|breakpoint_help_string
r_static
r_char
op_star
id|breakpoint_help_string
op_assign
l_string|&quot;Breakpoint command usage:&bslash;n&quot;
l_string|&quot;b                show breakpoints&bslash;n&quot;
l_string|&quot;b &lt;addr&gt; [cnt]   set breakpoint at given instr addr&bslash;n&quot;
l_string|&quot;bc               clear all breakpoints&bslash;n&quot;
l_string|&quot;bc &lt;n/addr&gt;      clear breakpoint number n or at addr&bslash;n&quot;
l_string|&quot;bi &lt;addr&gt; [cnt]  set hardware instr breakpoint (broken?)&bslash;n&quot;
l_string|&quot;bd &lt;addr&gt; [cnt]  set hardware data breakpoint (broken?)&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_static
r_void
DECL|function|bpt_cmds
id|bpt_cmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|a
suffix:semicolon
r_int
id|mode
comma
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_struct
id|tbtable
id|tab
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* bd - hardware data breakpoint */
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_POWER4p
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Not implemented on POWER4&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mode
op_assign
l_int|7
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|mode
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;w&squot;
)paren
id|mode
op_assign
l_int|6
suffix:semicolon
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
id|dabr.address
op_assign
l_int|0
suffix:semicolon
id|dabr.count
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|dabr.address
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|dabr.address
op_assign
(paren
id|dabr.address
op_amp
op_complement
l_int|7
)paren
op_or
id|mode
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* bi - hardware instr breakpoint */
r_if
c_cond
(paren
id|__is_processor
c_func
(paren
id|PV_POWER4
)paren
op_logical_or
id|__is_processor
c_func
(paren
id|PV_POWER4p
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Not implemented on POWER4&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|iabr.address
op_assign
l_int|0
suffix:semicolon
id|iabr.count
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|iabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|iabr.address
op_or_assign
l_int|3
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|iabr.count
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* clear all breakpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
)paren
id|bpts
(braket
id|i
)braket
dot
id|enabled
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All breakpoints cleared&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|a
op_le
id|NBPTS
op_logical_and
id|a
op_ge
l_int|1
)paren
(brace
multiline_comment|/* assume a breakpoint number */
op_decrement
id|a
suffix:semicolon
multiline_comment|/* bp nums are 1 based */
id|bp
op_assign
op_amp
id|bpts
(braket
id|a
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assume a breakpoint address */
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;No breakpoint at %x&bslash;n&quot;
comma
id|a
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Cleared breakpoint %x (%lx %s)&bslash;n&quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
comma
id|bp-&gt;funcname
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|breakpoint_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|breakpoint_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* print all breakpoints */
r_int
id|bpnum
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   type            address    count&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   data   %.16lx %8x [&quot;
comma
id|dabr.address
op_amp
op_complement
l_int|7
comma
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|printf
c_func
(paren
l_string|&quot;   inst   %.16lx %8x&bslash;n&quot;
comma
id|iabr.address
op_amp
op_complement
l_int|3
comma
id|iabr.count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
comma
id|bpnum
op_assign
l_int|1
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
comma
op_increment
id|bpnum
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
)paren
id|printf
c_func
(paren
l_string|&quot;%2x trap   %.16lx %8x  %s&bslash;n&quot;
comma
id|bpnum
comma
id|bp-&gt;address
comma
id|bp-&gt;count
comma
id|bp-&gt;funcname
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ge
op_amp
id|bpts
(braket
id|NBPTS
)braket
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Sorry, no free breakpoints.  Please clear one first.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bp-&gt;enabled
op_assign
l_int|1
suffix:semicolon
id|bp-&gt;address
op_assign
id|a
suffix:semicolon
id|bp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|bp-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Find the function name just once. */
id|bp-&gt;funcname
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|find_tb_table
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|tab
)paren
op_logical_and
id|tab.name
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* Got a nice name for it. */
r_int
id|delta
op_assign
id|bp-&gt;address
op_minus
id|tab.funcstart
suffix:semicolon
id|sprintf
c_func
(paren
id|bp-&gt;funcname
comma
l_string|&quot;%s+0x%x&quot;
comma
id|tab.name
comma
id|delta
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Set breakpoint %2x trap   %.16lx %8x  %s&bslash;n&quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
comma
id|bp-&gt;count
comma
id|bp-&gt;funcname
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Very cheap human name for vector lookup. */
r_static
DECL|function|getvecname
r_const
r_char
op_star
id|getvecname
c_func
(paren
r_int
r_int
id|vec
)paren
(brace
r_char
op_star
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|vec
)paren
(brace
r_case
l_int|0x100
suffix:colon
id|ret
op_assign
l_string|&quot;(System Reset)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x200
suffix:colon
id|ret
op_assign
l_string|&quot;(Machine Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x300
suffix:colon
id|ret
op_assign
l_string|&quot;(Data Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x400
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x500
suffix:colon
id|ret
op_assign
l_string|&quot;(Hardware Interrupt)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x600
suffix:colon
id|ret
op_assign
l_string|&quot;(Alignment)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x700
suffix:colon
id|ret
op_assign
l_string|&quot;(Program Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x800
suffix:colon
id|ret
op_assign
l_string|&quot;(FPU Unavailable)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x900
suffix:colon
id|ret
op_assign
l_string|&quot;(Decrementer)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc00
suffix:colon
id|ret
op_assign
l_string|&quot;(System Call)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd00
suffix:colon
id|ret
op_assign
l_string|&quot;(Single Step)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf00
suffix:colon
id|ret
op_assign
l_string|&quot;(Performance Monitor)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|backtrace
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
r_int
id|sp
suffix:semicolon
r_int
r_int
id|lr
suffix:semicolon
r_int
r_int
id|stack
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_struct
id|tbtable
id|tab
suffix:semicolon
r_int
id|framecount
suffix:semicolon
r_char
op_star
id|funcname
suffix:semicolon
multiline_comment|/* declare these as raw ptrs so we don&squot;t get func descriptors */
r_extern
r_void
op_star
id|ret_from_except
comma
op_star
id|ret_from_syscall_1
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_ne
l_int|NULL
)paren
(brace
id|lr
op_assign
id|excp-&gt;link
suffix:semicolon
id|sp
op_assign
id|excp-&gt;gpr
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use care not to call any function before this point&n;&t;&t; so the saved lr has a chance of being good. */
id|asm
r_volatile
(paren
l_string|&quot;mflr %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lr
)paren
suffix:colon
)paren
suffix:semicolon
id|sp
op_assign
id|getsp
c_func
(paren
)paren
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|framecount
op_assign
l_int|0
suffix:semicolon
id|sp
op_ne
l_int|0
op_logical_and
id|framecount
OL
id|MAXFRAMECOUNT
suffix:semicolon
id|sp
op_assign
id|stack
(braket
l_int|0
)braket
comma
id|framecount
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
comma
id|stack
comma
r_sizeof
(paren
id|stack
)paren
)paren
op_ne
r_sizeof
(paren
id|stack
)paren
)paren
r_break
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|lr
op_ne
l_int|0
)paren
(brace
id|stack
(braket
l_int|2
)braket
op_assign
id|lr
suffix:semicolon
multiline_comment|/* fake out the first saved lr.  It may not be saved yet. */
id|lr
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|printf
c_func
(paren
l_string|&quot;%.16lx  %.16lx&quot;
comma
id|sp
comma
id|stack
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* TAI -- for now only the ones cast to unsigned long will match.&n;&t;&t; * Need to test the rest...&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|stack
(braket
l_int|2
)braket
op_eq
(paren
r_int
r_int
)paren
id|ret_from_except
op_logical_and
(paren
id|funcname
op_assign
l_string|&quot;ret_from_except&quot;
)paren
)paren
op_logical_or
(paren
id|stack
(braket
l_int|2
)braket
op_eq
(paren
r_int
r_int
)paren
id|ret_from_syscall_1
op_logical_and
(paren
id|funcname
op_assign
l_string|&quot;ret_from_syscall_1&quot;
)paren
)paren
macro_line|#if 0
op_logical_or
id|stack
(braket
l_int|2
)braket
op_eq
(paren
r_int
)paren
op_amp
id|ret_from_syscall_2
op_logical_or
id|stack
(braket
l_int|2
)braket
op_eq
(paren
r_int
)paren
op_amp
id|do_signal_ret
macro_line|#endif
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;  %s&bslash;n&quot;
comma
id|funcname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
op_plus
l_int|112
comma
op_amp
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
op_ne
r_sizeof
(paren
id|regs
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;exception: %lx %s regs %lx&bslash;n&quot;
comma
id|regs.trap
comma
id|getvecname
c_func
(paren
id|regs.trap
)paren
comma
id|sp
op_plus
l_int|112
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;                  %.16lx&quot;
comma
id|regs.nip
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs.nip
op_amp
l_int|0xffffffff00000000UL
)paren
op_logical_and
id|find_tb_table
c_func
(paren
id|regs.nip
comma
op_amp
id|tab
)paren
)paren
(brace
r_int
id|delta
op_assign
id|regs.nip
op_minus
id|tab.funcstart
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;  &lt;unknown code&gt;&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;  %s+0x%x&quot;
comma
id|tab.name
comma
id|delta
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs.gpr
(braket
l_int|1
)braket
OL
id|sp
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&lt;Stack drops into 32-bit userspace %.16lx&gt;&bslash;n&quot;
comma
id|regs.gpr
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sp
op_assign
id|regs.gpr
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
comma
id|stack
comma
r_sizeof
(paren
id|stack
)paren
)paren
op_ne
r_sizeof
(paren
id|stack
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|stack
(braket
l_int|2
)braket
op_logical_and
id|find_tb_table
c_func
(paren
id|stack
(braket
l_int|2
)braket
comma
op_amp
id|tab
)paren
)paren
(brace
r_int
id|delta
op_assign
id|stack
(braket
l_int|2
)braket
op_minus
id|tab.funcstart
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;  &lt;unknown code&gt;&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;  %s+0x%x&quot;
comma
id|tab.name
comma
id|delta
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stack
(braket
l_int|0
)braket
op_logical_and
id|stack
(braket
l_int|0
)braket
op_le
id|sp
)paren
(brace
r_if
c_cond
(paren
(paren
id|stack
(braket
l_int|0
)braket
op_amp
l_int|0xffffffff00000000UL
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&lt;Stack drops into 32-bit userspace %.16lx&gt;&bslash;n&quot;
comma
id|stack
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&lt;Corrupt stack.  Next backchain is %.16lx&gt;&bslash;n&quot;
comma
id|stack
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|framecount
op_ge
id|MAXFRAMECOUNT
)paren
id|printf
c_func
(paren
l_string|&quot;&lt;Punt. Too many stack frames&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_int
DECL|function|getsp
id|getsp
c_func
(paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|x
)paren
suffix:colon
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|variable|exception_print_lock
id|spinlock_t
id|exception_print_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_void
DECL|function|excprint
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_struct
id|task_struct
op_star
id|c
suffix:semicolon
r_struct
id|tbtable
id|tab
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|exception_print_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printf
c_func
(paren
l_string|&quot;cpu %d: &quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printf
c_func
(paren
l_string|&quot;Vector: %lx %s at  [%lx]&bslash;n&quot;
comma
id|fp-&gt;trap
comma
id|getvecname
c_func
(paren
id|fp-&gt;trap
)paren
comma
id|fp
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    pc: %lx&quot;
comma
id|fp-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_tb_table
c_func
(paren
id|fp-&gt;nip
comma
op_amp
id|tab
)paren
op_logical_and
id|tab.name
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* Got a nice name for it */
r_int
id|delta
op_assign
id|fp-&gt;nip
op_minus
id|tab.funcstart
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (%s+0x%x)&quot;
comma
id|tab.name
comma
id|delta
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    lr: %lx&quot;
comma
id|fp-&gt;link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_tb_table
c_func
(paren
id|fp-&gt;link
comma
op_amp
id|tab
)paren
op_logical_and
id|tab.name
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* Got a nice name for it */
r_int
id|delta
op_assign
id|fp-&gt;link
op_minus
id|tab.funcstart
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (%s+0x%x)&quot;
comma
id|tab.name
comma
id|delta
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    sp: %lx&bslash;n&quot;
comma
id|fp-&gt;gpr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   msr: %lx&bslash;n&quot;
comma
id|fp-&gt;msr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;trap
op_eq
l_int|0x300
op_logical_or
id|fp-&gt;trap
op_eq
l_int|0x600
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   dar: %lx&bslash;n&quot;
comma
id|fp-&gt;dar
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; dsisr: %lx&bslash;n&quot;
comma
id|fp-&gt;dsisr
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX: need to copy current or we die.  Why? */
id|c
op_assign
id|current
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  current = 0x%lx&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  paca    = 0x%lx&bslash;n&quot;
comma
id|get_paca
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;  current = %lx, pid = %ld, comm = %s&bslash;n&quot;
comma
id|c
comma
id|c-&gt;pid
comma
id|c-&gt;comm
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|exception_print_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|prregs
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|base
)paren
)paren
id|fp
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|16
suffix:semicolon
op_increment
id|n
)paren
id|printf
c_func
(paren
l_string|&quot;R%.2ld = %.16lx   R%.2ld = %.16lx&bslash;n&quot;
comma
id|n
comma
id|fp-&gt;gpr
(braket
id|n
)braket
comma
id|n
op_plus
l_int|16
comma
id|fp-&gt;gpr
(braket
id|n
op_plus
l_int|16
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pc  = %.16lx   msr = %.16lx&bslash;nlr  = %.16lx   cr  = %.16lx&bslash;n&quot;
comma
id|fp-&gt;nip
comma
id|fp-&gt;msr
comma
id|fp-&gt;link
comma
id|fp-&gt;ccr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ctr = %.16lx   xer = %.16lx   trap = %8lx&bslash;n&quot;
comma
id|fp-&gt;ctr
comma
id|fp-&gt;xer
comma
id|fp-&gt;trap
)paren
suffix:semicolon
)brace
r_void
DECL|function|cacheflush
id|cacheflush
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|nflush
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
id|termch
op_assign
id|cmd
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|nflush
op_assign
l_int|1
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|nflush
)paren
suffix:semicolon
id|nflush
op_assign
(paren
id|nflush
op_plus
l_int|31
)paren
op_div
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
l_int|0x20
)paren
id|cflush
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
l_int|0x20
)paren
id|cinval
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
)brace
r_int
r_int
DECL|function|read_spr
id|read_spr
c_func
(paren
r_int
id|n
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6002a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|opd
suffix:semicolon
r_return
id|code
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|write_spr
id|write_spr
c_func
(paren
r_int
id|n
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6003a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|opd
suffix:semicolon
id|code
c_func
(paren
id|val
)paren
suffix:semicolon
)brace
DECL|variable|regno
r_static
r_int
r_int
id|regno
suffix:semicolon
r_extern
r_char
id|exc_prolog
suffix:semicolon
r_extern
r_char
id|dec_exc
suffix:semicolon
r_void
DECL|function|print_sysmap
id|print_sysmap
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
op_star
id|sysmap
suffix:semicolon
r_if
c_cond
(paren
id|sysmap
)paren
id|printf
c_func
(paren
l_string|&quot;System.map: &bslash;n%s&quot;
comma
id|sysmap
)paren
suffix:semicolon
)brace
r_void
DECL|function|super_regs
id|super_regs
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|cmd
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_struct
id|paca_struct
op_star
id|ptrPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpPaca
op_star
id|ptrLpPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpRegSave
op_star
id|ptrLpRegSave
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_int
r_int
id|sp
comma
id|toc
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sp
)paren
suffix:colon
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|toc
)paren
suffix:colon
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;msr  = %.16lx  sprg0= %.16lx&bslash;n&quot;
comma
id|get_msr
c_func
(paren
)paren
comma
id|get_sprg0
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pvr  = %.16lx  sprg1= %.16lx&bslash;n&quot;
comma
id|get_pvr
c_func
(paren
)paren
comma
id|get_sprg1
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;dec  = %.16lx  sprg2= %.16lx&bslash;n&quot;
comma
id|get_dec
c_func
(paren
)paren
comma
id|get_sprg2
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sp   = %.16lx  sprg3= %.16lx&bslash;n&quot;
comma
id|sp
comma
id|get_sprg3
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;toc  = %.16lx  dar  = %.16lx&bslash;n&quot;
comma
id|toc
comma
id|get_dar
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;srr0 = %.16lx  srr1 = %.16lx&bslash;n&quot;
comma
id|get_srr0
c_func
(paren
)paren
comma
id|get_srr1
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;asr  = %.16lx&bslash;n&quot;
comma
id|mfasr
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;sr%.2ld = %.16lx  sr%.2ld = %.16lx&bslash;n&quot;
comma
id|i
comma
id|get_sr
c_func
(paren
id|i
)paren
comma
id|i
op_plus
l_int|8
comma
id|get_sr
c_func
(paren
id|i
op_plus
l_int|8
)paren
)paren
suffix:semicolon
singleline_comment|// Dump out relevant Paca data areas.
id|printf
c_func
(paren
l_string|&quot;Paca: &bslash;n&quot;
)paren
suffix:semicolon
id|ptrPaca
op_assign
id|get_paca
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Control Area (LpPaca): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpPaca
op_assign
id|ptrPaca-&gt;xLpPacaPtr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Srr0=%.16lx  Saved Srr1=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedSrr0
comma
id|ptrLpPaca-&gt;xSavedSrr1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr3=%.16lx  Saved Gpr4=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr3
comma
id|ptrLpPaca-&gt;xSavedGpr4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr5=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr5
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Register Save Area (LpRegSave): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpRegSave
op_assign
id|ptrPaca-&gt;xLpRegSavePtr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg0=%.16lx  Saved Sprg1=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG0
comma
id|ptrLpRegSave-&gt;xSPRG0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg2=%.16lx  Saved Sprg3=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG2
comma
id|ptrLpRegSave-&gt;xSPRG3
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Msr  =%.16lx  Saved Nia  =%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xMSR
comma
id|ptrLpRegSave-&gt;xNIA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|regno
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;w&squot;
suffix:colon
id|val
op_assign
id|read_spr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|write_spr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_char|&squot;r&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;spr %lx = %lx&bslash;n&quot;
comma
id|regno
comma
id|read_spr
c_func
(paren
id|regno
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|val
op_assign
id|get_sr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_sr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|val
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scannl
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|openforth
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
id|cmd
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|args
(braket
l_int|5
)braket
suffix:semicolon
r_extern
r_int
(paren
op_star
id|prom_entry
)paren
(paren
r_int
op_star
)paren
suffix:semicolon
id|p
op_assign
id|cmd
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|args
(braket
l_int|0
)braket
op_assign
(paren
r_int
)paren
l_string|&quot;interpret&quot;
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
(paren
r_int
)paren
id|cmd
suffix:semicolon
(paren
op_star
id|prom_entry
)paren
(paren
id|args
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|4
)braket
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;error %x&bslash;n&quot;
comma
id|args
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef CONFIG_PPC64BRIDGE
r_static
r_void
DECL|function|dump_hash_table_seg
id|dump_hash_table_seg
c_func
(paren
r_int
id|seg
comma
r_int
id|start
comma
r_int
id|end
)paren
(brace
r_extern
r_void
op_star
id|Hash
suffix:semicolon
r_extern
r_int
r_int
id|Hash_size
suffix:semicolon
r_int
op_star
id|htab
op_assign
id|Hash
suffix:semicolon
r_int
id|hsize
op_assign
id|Hash_size
suffix:semicolon
r_int
id|v
comma
id|hmask
comma
id|va
comma
id|last_va
suffix:semicolon
r_int
id|found
comma
id|last_found
comma
id|i
suffix:semicolon
r_int
op_star
id|hg
comma
id|w1
comma
id|last_w2
comma
id|last_va0
suffix:semicolon
id|last_found
op_assign
l_int|0
suffix:semicolon
id|hmask
op_assign
id|hsize
op_div
l_int|64
op_minus
l_int|1
suffix:semicolon
id|va
op_assign
id|start
suffix:semicolon
id|start
op_assign
(paren
id|start
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|end
op_assign
(paren
id|end
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
id|start
suffix:semicolon
id|v
OL
id|end
suffix:semicolon
op_increment
id|v
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|16
)paren
suffix:semicolon
id|w1
op_assign
l_int|0x80000000
op_or
(paren
id|seg
op_lshift
l_int|7
)paren
op_or
(paren
id|v
op_rshift
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_star
id|hg
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|w1
op_xor_assign
l_int|0x40
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
op_complement
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_star
id|hg
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_found
op_logical_and
id|found
op_logical_and
(paren
id|hg
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x180
)paren
op_eq
id|last_w2
op_plus
l_int|4096
)paren
)paren
(brace
r_if
c_cond
(paren
id|last_found
)paren
(brace
r_if
c_cond
(paren
id|last_va
op_ne
id|last_va0
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&quot;
comma
id|last_va
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%x to %x&quot;
comma
id|va
comma
id|hg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|last_va0
op_assign
id|va
suffix:semicolon
)brace
id|last_found
op_assign
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|last_w2
op_assign
id|hg
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x180
suffix:semicolon
id|last_va
op_assign
id|va
suffix:semicolon
)brace
id|va
op_add_assign
l_int|4096
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_found
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&bslash;n&quot;
comma
id|last_va
)paren
suffix:semicolon
)brace
macro_line|#else /* CONFIG_PPC64BRIDGE */
r_static
r_void
DECL|function|dump_hash_table_seg
id|dump_hash_table_seg
c_func
(paren
r_int
id|seg
comma
r_int
id|start
comma
r_int
id|end
)paren
(brace
r_extern
r_void
op_star
id|Hash
suffix:semicolon
r_extern
r_int
r_int
id|Hash_size
suffix:semicolon
r_int
op_star
id|htab
op_assign
id|Hash
suffix:semicolon
r_int
id|hsize
op_assign
id|Hash_size
suffix:semicolon
r_int
id|v
comma
id|hmask
comma
id|va
comma
id|last_va
suffix:semicolon
r_int
id|found
comma
id|last_found
comma
id|i
suffix:semicolon
r_int
op_star
id|hg
comma
id|w1
comma
id|last_w2
comma
id|last_va0
suffix:semicolon
id|last_found
op_assign
l_int|0
suffix:semicolon
id|hmask
op_assign
id|hsize
op_div
l_int|128
op_minus
l_int|1
suffix:semicolon
id|va
op_assign
id|start
suffix:semicolon
id|start
op_assign
(paren
id|start
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|end
op_assign
(paren
id|end
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
id|start
suffix:semicolon
id|v
OL
id|end
suffix:semicolon
op_increment
id|v
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|32
)paren
suffix:semicolon
id|w1
op_assign
l_int|1
op_or
(paren
id|seg
op_lshift
l_int|12
)paren
op_or
(paren
(paren
id|v
op_amp
l_int|0xf800
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|hg
(braket
l_int|1
)braket
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|w1
op_xor_assign
l_int|2
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
op_complement
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|32
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|hg
(braket
l_int|1
)braket
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_found
op_logical_and
id|found
op_logical_and
(paren
id|hg
(braket
l_int|3
)braket
op_amp
op_complement
l_int|0x180
)paren
op_eq
id|last_w2
op_plus
l_int|4096
)paren
)paren
(brace
r_if
c_cond
(paren
id|last_found
)paren
(brace
r_if
c_cond
(paren
id|last_va
op_ne
id|last_va0
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&quot;
comma
id|last_va
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%x to %x&quot;
comma
id|va
comma
id|hg
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|last_va0
op_assign
id|va
suffix:semicolon
)brace
id|last_found
op_assign
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|last_w2
op_assign
id|hg
(braket
l_int|3
)braket
op_amp
op_complement
l_int|0x180
suffix:semicolon
id|last_va
op_assign
id|va
suffix:semicolon
)brace
id|va
op_add_assign
l_int|4096
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_found
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&bslash;n&quot;
comma
id|last_va
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PPC64BRIDGE */
DECL|variable|hash_ctx
r_static
r_int
r_int
id|hash_ctx
suffix:semicolon
DECL|variable|hash_start
r_static
r_int
r_int
id|hash_start
suffix:semicolon
DECL|variable|hash_end
r_static
r_int
r_int
id|hash_end
suffix:semicolon
r_static
r_void
DECL|function|dump_hash_table
id|dump_hash_table
c_func
(paren
)paren
(brace
r_int
id|seg
suffix:semicolon
r_int
id|seg_start
comma
id|seg_end
suffix:semicolon
id|hash_ctx
op_assign
l_int|0
suffix:semicolon
id|hash_start
op_assign
l_int|0
suffix:semicolon
id|hash_end
op_assign
l_int|0xfffff000
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_ctx
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_start
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_end
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Mappings for context %x&bslash;n&quot;
comma
id|hash_ctx
)paren
suffix:semicolon
id|seg_start
op_assign
id|hash_start
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
id|hash_start
op_rshift
l_int|28
suffix:semicolon
id|seg
op_le
id|hash_end
op_rshift
l_int|28
suffix:semicolon
op_increment
id|seg
)paren
(brace
id|seg_end
op_assign
(paren
id|seg
op_lshift
l_int|28
)paren
op_or
l_int|0x0ffff000
suffix:semicolon
r_if
c_cond
(paren
id|seg_end
OG
id|hash_end
)paren
id|seg_end
op_assign
id|hash_end
suffix:semicolon
id|dump_hash_table_seg
c_func
(paren
(paren
id|hash_ctx
op_lshift
l_int|4
)paren
op_plus
id|seg
comma
id|seg_start
comma
id|seg_end
)paren
suffix:semicolon
id|seg_start
op_assign
id|seg_end
op_plus
l_int|0x1000
suffix:semicolon
)brace
)brace
r_int
DECL|function|mread
id|mread
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|q
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
id|debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_int
DECL|function|mwrite
id|mwrite
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error writing address %x&bslash;n&quot;
comma
id|adrs
op_plus
id|n
)paren
suffix:semicolon
)brace
id|debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|fault_type
r_static
r_int
id|fault_type
suffix:semicolon
DECL|variable|fault_chars
r_static
r_char
op_star
id|fault_chars
(braket
)braket
op_assign
(brace
l_string|&quot;--&quot;
comma
l_string|&quot;**&quot;
comma
l_string|&quot;##&quot;
)brace
suffix:semicolon
r_static
r_void
DECL|function|handle_fault
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|fault_type
op_assign
id|regs-&gt;trap
op_eq
l_int|0x200
ques
c_cond
l_int|0
suffix:colon
id|regs-&gt;trap
op_eq
l_int|0x300
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
m_longjmp
(paren
id|bus_error_jmp
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|SWAP
mdefine_line|#define SWAP(a, b, t)&t;((t) = (a), (a) = (b), (b) = (t))
r_void
DECL|function|byterev
id|byterev
c_func
(paren
r_int
r_char
op_star
id|val
comma
r_int
id|size
)paren
(brace
r_int
id|t
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|1
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|3
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|2
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* is there really any use for this? */
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|7
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|6
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|2
)braket
comma
id|val
(braket
l_int|5
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|3
)braket
comma
id|val
(braket
l_int|4
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|brev
r_static
r_int
id|brev
suffix:semicolon
DECL|variable|mnoread
r_static
r_int
id|mnoread
suffix:semicolon
DECL|variable|memex_help_string
r_static
r_char
op_star
id|memex_help_string
op_assign
l_string|&quot;Memory examine command usage:&bslash;n&quot;
l_string|&quot;m [addr] [flags] examine/change memory&bslash;n&quot;
l_string|&quot;  addr is optional.  will start where left off.&bslash;n&quot;
l_string|&quot;  flags may include chars from this set:&bslash;n&quot;
l_string|&quot;    b   modify by bytes (default)&bslash;n&quot;
l_string|&quot;    w   modify by words (2 byte)&bslash;n&quot;
l_string|&quot;    l   modify by longs (4 byte)&bslash;n&quot;
l_string|&quot;    d   modify by doubleword (8 byte)&bslash;n&quot;
l_string|&quot;    r   toggle reverse byte order mode&bslash;n&quot;
l_string|&quot;    n   do not read memory (for i/o spaces)&bslash;n&quot;
l_string|&quot;    .   ok to read (default)&bslash;n&quot;
l_string|&quot;NOTE: flags are saved as defaults&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|memex_subcmd_help_string
r_static
r_char
op_star
id|memex_subcmd_help_string
op_assign
l_string|&quot;Memory examine subcommands:&bslash;n&quot;
l_string|&quot;  hexval   write this val to current location&bslash;n&quot;
l_string|&quot;  &squot;string&squot; write chars from string to this location&bslash;n&quot;
l_string|&quot;  &squot;        increment address&bslash;n&quot;
l_string|&quot;  ^        decrement address&bslash;n&quot;
l_string|&quot;  /        increment addr by 0x10.  //=0x100, ///=0x1000, etc&bslash;n&quot;
l_string|&quot;  &bslash;&bslash;        decrement addr by 0x10.  &bslash;&bslash;&bslash;&bslash;=0x100, &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;=0x1000, etc&bslash;n&quot;
l_string|&quot;  `        clear no-read flag&bslash;n&quot;
l_string|&quot;  ;        stay at this addr&bslash;n&quot;
l_string|&quot;  v        change to byte mode&bslash;n&quot;
l_string|&quot;  w        change to word (2 byte) mode&bslash;n&quot;
l_string|&quot;  l        change to long (4 byte) mode&bslash;n&quot;
l_string|&quot;  u        change to doubleword (8 byte) mode&bslash;n&quot;
l_string|&quot;  m addr   change current addr&bslash;n&quot;
l_string|&quot;  n        toggle no-read flag&bslash;n&quot;
l_string|&quot;  r        toggle byte reverse flag&bslash;n&quot;
l_string|&quot;  &lt; count  back up count bytes&bslash;n&quot;
l_string|&quot;  &gt; count  skip forward count bytes&bslash;n&quot;
l_string|&quot;  x        exit this mode&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_void
DECL|function|memex
id|memex
c_func
(paren
)paren
(brace
r_int
id|cmd
comma
id|inc
comma
id|i
comma
id|nslash
suffix:semicolon
r_int
r_int
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|16
)braket
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|memex_help_string
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|last_cmd
op_assign
l_string|&quot;m&bslash;n&quot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
(brace
id|size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
l_int|8
)paren
(brace
id|size
op_assign
l_int|8
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
id|n
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16x%c&quot;
comma
id|adrs
comma
id|brev
ques
c_cond
l_char|&squot;r&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
(brace
r_if
c_cond
(paren
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|val
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
id|nslash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|n
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
id|inc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|n
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|n
op_assign
id|bsesc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|adrs
op_add_assign
id|size
suffix:semicolon
)brace
id|adrs
op_sub_assign
id|size
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
id|adrs
op_add_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;;&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
r_case
l_char|&squot;v&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
id|adrs
op_sub_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OG
l_int|0
)paren
id|adrs
op_sub_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_add_assign
l_int|4
suffix:semicolon
id|adrs
op_add_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OL
l_int|0
)paren
id|adrs
op_add_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_sub_assign
l_int|4
suffix:semicolon
id|adrs
op_sub_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_add_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|memex_subcmd_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|adrs
op_add_assign
id|inc
suffix:semicolon
)brace
)brace
r_int
DECL|function|bsesc
id|bsesc
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
r_void
DECL|function|dump
id|dump
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|scanhex
c_func
(paren
op_amp
id|nidump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nidump
op_eq
l_int|0
)paren
(brace
id|nidump
op_assign
l_int|16
suffix:semicolon
)brace
id|adrs
op_add_assign
id|ppc_inst_dump
c_func
(paren
id|adrs
comma
id|nidump
)paren
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;di&bslash;n&quot;
suffix:semicolon
)brace
r_else
(brace
id|scanhex
c_func
(paren
op_amp
id|ndump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndump
op_eq
l_int|0
)paren
(brace
id|ndump
op_assign
l_int|64
suffix:semicolon
)brace
id|prdump
c_func
(paren
id|adrs
comma
id|ndump
)paren
suffix:semicolon
id|adrs
op_add_assign
id|ndump
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;d&bslash;n&quot;
suffix:semicolon
)brace
)brace
r_void
DECL|function|prdump
id|prdump
c_func
(paren
r_int
r_int
id|adrs
comma
r_int
id|ndump
)paren
(brace
r_int
id|n
comma
id|m
comma
id|c
comma
id|r
comma
id|nr
suffix:semicolon
r_int
r_char
id|temp
(braket
l_int|16
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|ndump
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16lx&quot;
comma
id|adrs
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|r
op_assign
id|n
OL
l_int|16
ques
c_cond
id|n
suffix:colon
l_int|16
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|temp
comma
id|r
)paren
suffix:semicolon
id|adrs
op_add_assign
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|7
)paren
op_eq
l_int|0
op_logical_and
id|m
OG
l_int|0
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|temp
(braket
id|m
)braket
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  |&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|c
op_assign
id|temp
(braket
id|m
)braket
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;~&squot;
ques
c_cond
id|c
suffix:colon
l_char|&squot;.&squot;
)paren
suffix:semicolon
)brace
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|n
op_sub_assign
id|r
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
id|r
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|ppc_inst_dump
id|ppc_inst_dump
c_func
(paren
r_int
r_int
id|adr
comma
r_int
id|count
)paren
(brace
r_int
id|nr
comma
id|dotted
suffix:semicolon
r_int
r_int
id|first_adr
suffix:semicolon
r_int
r_int
id|inst
comma
id|last_inst
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|dotted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|first_adr
op_assign
id|adr
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
op_decrement
id|count
comma
id|adr
op_add_assign
l_int|4
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|adr
comma
id|val
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
(brace
r_const
r_char
op_star
id|x
op_assign
id|fault_chars
(braket
id|fault_type
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx  %s%s%s%s&bslash;n&quot;
comma
id|adr
comma
id|x
comma
id|x
comma
id|x
comma
id|x
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inst
op_assign
id|GETWORD
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adr
OG
id|first_adr
op_logical_and
id|inst
op_eq
id|last_inst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dotted
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; ...&bslash;n&quot;
)paren
suffix:semicolon
id|dotted
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|dotted
op_assign
l_int|0
suffix:semicolon
id|last_inst
op_assign
id|inst
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx  &quot;
comma
id|adr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;t&quot;
comma
id|inst
)paren
suffix:semicolon
id|print_insn_big_powerpc
c_func
(paren
id|stdout
comma
id|inst
comma
id|adr
)paren
suffix:semicolon
multiline_comment|/* always returns 4 */
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|adr
op_minus
id|first_adr
suffix:semicolon
)brace
r_void
DECL|function|print_address
id|print_address
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;0x%lx&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Memory operations - move, set, print differences&n; */
DECL|variable|mdest
r_static
r_int
r_int
id|mdest
suffix:semicolon
multiline_comment|/* destination address */
DECL|variable|msrc
r_static
r_int
r_int
id|msrc
suffix:semicolon
multiline_comment|/* source address */
DECL|variable|mval
r_static
r_int
r_int
id|mval
suffix:semicolon
multiline_comment|/* byte value to set memory to */
DECL|variable|mcount
r_static
r_int
r_int
id|mcount
suffix:semicolon
multiline_comment|/* # bytes to affect */
DECL|variable|mdiffs
r_static
r_int
r_int
id|mdiffs
suffix:semicolon
multiline_comment|/* max # differences to print */
r_void
DECL|function|memops
id|memops
c_func
(paren
r_int
id|cmd
)paren
(brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
ques
c_cond
op_amp
id|mval
suffix:colon
op_amp
id|msrc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mcount
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|memmove
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
(paren
r_void
op_star
)paren
id|msrc
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
id|mval
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdiffs
)paren
suffix:semicolon
id|memdiffs
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mdest
comma
(paren
r_int
r_char
op_star
)paren
id|msrc
comma
id|mcount
comma
id|mdiffs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_void
DECL|function|memdiffs
id|memdiffs
c_func
(paren
r_int
r_char
op_star
id|p1
comma
r_int
r_char
op_star
id|p2
comma
r_int
id|nb
comma
r_int
id|maxpr
)paren
(brace
r_int
id|n
comma
id|prt
suffix:semicolon
id|prt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|nb
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
op_decrement
id|n
)paren
r_if
c_cond
(paren
op_star
id|p1
op_increment
op_ne
op_star
id|p2
op_increment
)paren
r_if
c_cond
(paren
op_increment
id|prt
op_le
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x %.2x # %.16x %.2x&bslash;n&quot;
comma
id|p1
op_minus
l_int|1
comma
id|p1
(braket
op_minus
l_int|1
)braket
comma
id|p2
op_minus
l_int|1
comma
id|p2
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prt
OG
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Total of %d differences&bslash;n&quot;
comma
id|prt
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mend
r_static
r_int
id|mend
suffix:semicolon
DECL|variable|mask
r_static
r_int
id|mask
suffix:semicolon
r_void
DECL|function|memlocate
id|memlocate
c_func
(paren
)paren
(brace
r_int
id|a
comma
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;ml&quot;
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mval
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mask
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mend
suffix:semicolon
id|a
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|a
comma
id|val
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
(paren
(paren
id|GETWORD
c_func
(paren
id|val
)paren
op_xor
id|mval
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x:  %.16x&bslash;n&quot;
comma
id|a
comma
id|GETWORD
c_func
(paren
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|n
op_ge
l_int|10
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|mskip
r_static
r_int
r_int
id|mskip
op_assign
l_int|0x1000
suffix:semicolon
DECL|variable|mlim
r_static
r_int
r_int
id|mlim
op_assign
l_int|0xffffffff
suffix:semicolon
r_void
DECL|function|memzcan
id|memzcan
c_func
(paren
)paren
(brace
r_int
r_char
id|v
suffix:semicolon
r_int
id|a
suffix:semicolon
r_int
id|ok
comma
id|ook
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mskip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mlim
)paren
suffix:semicolon
id|ook
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mlim
suffix:semicolon
id|a
op_add_assign
id|mskip
)paren
(brace
id|ok
op_assign
id|mread
c_func
(paren
id|a
comma
op_amp
id|v
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
op_logical_and
op_logical_neg
id|ook
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x .. &quot;
comma
id|a
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ok
op_logical_and
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
id|ook
op_assign
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|mskip
OL
id|a
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
)brace
multiline_comment|/* Input scanning routines */
r_int
DECL|function|skipbl
id|skipbl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_int|0
)paren
(brace
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
r_int
DECL|function|scanhex
id|scanhex
c_func
(paren
id|vp
)paren
r_int
r_int
op_star
id|vp
suffix:semicolon
(brace
r_int
id|c
comma
id|d
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
id|EOF
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|v
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|v
op_assign
(paren
id|v
op_lshift
l_int|4
)paren
op_plus
id|d
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
op_ne
id|EOF
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|vp
op_assign
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|scannl
id|scannl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|hexdigit
id|hexdigit
c_func
(paren
r_int
id|c
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
r_return
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_return
id|EOF
suffix:semicolon
)brace
r_void
DECL|function|getstring
id|getstring
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|size
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|size
OG
l_int|1
)paren
(brace
op_star
id|s
op_increment
op_assign
id|c
suffix:semicolon
op_decrement
id|size
suffix:semicolon
)brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot; &squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|s
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
r_void
DECL|function|flush_input
id|flush_input
c_func
(paren
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|inchar
id|inchar
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|lineptr
op_eq
l_int|NULL
op_logical_or
op_star
id|lineptr
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_eq
l_int|NULL
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|EOF
suffix:semicolon
)brace
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_void
DECL|function|take_input
id|take_input
c_func
(paren
id|str
)paren
r_char
op_star
id|str
suffix:semicolon
(brace
id|lineptr
op_assign
id|str
suffix:semicolon
)brace
multiline_comment|/* Starting at codeaddr scan forward for a tbtable and fill in the&n; given table.  Return non-zero if successful at doing something.&n; */
r_static
r_int
DECL|function|find_tb_table
id|find_tb_table
c_func
(paren
r_int
r_int
id|codeaddr
comma
r_struct
id|tbtable
op_star
id|tab
)paren
(brace
r_int
r_int
id|codeaddr_max
suffix:semicolon
r_int
r_int
id|tbtab_start
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_int
id|instr
suffix:semicolon
r_int
id|num_parms
suffix:semicolon
r_if
c_cond
(paren
id|tab
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|tab
comma
l_int|0
comma
r_sizeof
(paren
id|tab
)paren
)paren
suffix:semicolon
multiline_comment|/* Scan instructions starting at codeaddr for 128k max */
r_for
c_loop
(paren
id|codeaddr_max
op_assign
id|codeaddr
op_plus
l_int|128
op_star
l_int|1024
op_star
l_int|4
suffix:semicolon
id|codeaddr
OL
id|codeaddr_max
suffix:semicolon
id|codeaddr
op_add_assign
l_int|4
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
op_amp
id|instr
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|4
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Bad read.  Give up promptly. */
r_if
c_cond
(paren
id|instr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* table should follow. */
r_int
id|version
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|tbtab_start
op_assign
id|codeaddr
suffix:semicolon
multiline_comment|/* save it to compute func start addr */
id|codeaddr
op_add_assign
l_int|4
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
op_amp
id|flags
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|8
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Bad read or no tb table. */
id|tab-&gt;flags
op_assign
id|flags
suffix:semicolon
id|version
op_assign
(paren
id|flags
op_rshift
l_int|56
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|version
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* No tb table here. */
multiline_comment|/* Now, like the version, some of the flags are values&n;&t;&t;&t; that are more conveniently extracted... */
id|tab-&gt;fp_saved
op_assign
(paren
id|flags
op_rshift
l_int|24
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|tab-&gt;gpr_saved
op_assign
(paren
id|flags
op_rshift
l_int|16
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|tab-&gt;fixedparms
op_assign
(paren
id|flags
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tab-&gt;floatparms
op_assign
(paren
id|flags
op_rshift
l_int|1
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|codeaddr
op_add_assign
l_int|8
suffix:semicolon
id|num_parms
op_assign
id|tab-&gt;fixedparms
op_plus
id|tab-&gt;floatparms
suffix:semicolon
r_if
c_cond
(paren
id|num_parms
)paren
(brace
r_int
r_int
id|parminfo
suffix:semicolon
r_int
id|parm
suffix:semicolon
r_if
c_cond
(paren
id|num_parms
OG
l_int|32
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* incomplete */
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
op_amp
id|parminfo
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* incomplete */
multiline_comment|/* decode parminfo...32 bits.&n;&t;&t;&t;&t; A zero means fixed.  A one means float and the&n;&t;&t;&t;&t; following bit determines single (0) or double (1).&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|parm
op_assign
l_int|0
suffix:semicolon
id|parm
OL
id|num_parms
suffix:semicolon
id|parm
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parminfo
op_amp
l_int|0x80000000
)paren
(brace
id|parminfo
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|parminfo
op_amp
l_int|0x80000000
)paren
id|tab-&gt;parminfo
(braket
id|parm
)braket
op_assign
id|TBTAB_PARMDFLOAT
suffix:semicolon
r_else
id|tab-&gt;parminfo
(braket
id|parm
)braket
op_assign
id|TBTAB_PARMSFLOAT
suffix:semicolon
)brace
r_else
(brace
id|tab-&gt;parminfo
(braket
id|parm
)braket
op_assign
id|TBTAB_PARMFIXED
suffix:semicolon
)brace
id|parminfo
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|codeaddr
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|TBTAB_FLAGSHASTBOFF
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
op_amp
id|tab-&gt;tb_offset
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* incomplete */
r_if
c_cond
(paren
id|tab-&gt;tb_offset
OG
l_int|0
)paren
(brace
id|tab-&gt;funcstart
op_assign
id|tbtab_start
op_minus
id|tab-&gt;tb_offset
suffix:semicolon
)brace
id|codeaddr
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* hand_mask appears to be always be omitted. */
r_if
c_cond
(paren
id|flags
op_amp
id|TBTAB_FLAGSHASCTL
)paren
(brace
multiline_comment|/* Assume this will never happen for C or asm */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* incomplete */
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|TBTAB_FLAGSNAMEPRESENT
)paren
(brace
r_int
id|namlen
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
op_amp
id|namlen
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* incomplete */
r_if
c_cond
(paren
id|namlen
op_ge
r_sizeof
(paren
id|tab-&gt;name
)paren
)paren
id|namlen
op_assign
r_sizeof
(paren
id|tab-&gt;name
)paren
op_minus
l_int|1
suffix:semicolon
id|codeaddr
op_add_assign
l_int|2
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|codeaddr
comma
id|tab-&gt;name
comma
id|namlen
)paren
suffix:semicolon
id|tab-&gt;name
(braket
id|namlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|codeaddr
op_add_assign
id|namlen
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* hit max...sorry. */
)brace
r_void
DECL|function|mem_translate
id|mem_translate
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
r_int
id|ea
comma
id|va
comma
id|vsid
comma
id|vpn
comma
id|page
comma
id|hpteg_slot_primary
comma
id|hpteg_slot_secondary
comma
id|primary_hash
comma
id|i
comma
op_star
id|steg
comma
id|esid
comma
id|stabl
suffix:semicolon
id|HPTE
op_star
id|hpte
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|pte_t
op_star
id|ptep
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|pgdir
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|ea
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ea
op_ge
id|KRANGE_START
)paren
op_logical_and
(paren
id|ea
op_le
(paren
id|KRANGE_START
op_plus
(paren
l_int|1UL
op_lshift
l_int|60
)paren
)paren
)paren
)paren
(brace
id|ptep
op_assign
l_int|0
suffix:semicolon
id|vsid
op_assign
id|get_kernel_vsid
c_func
(paren
id|ea
)paren
suffix:semicolon
id|va
op_assign
(paren
id|vsid
op_lshift
l_int|28
)paren
op_or
(paren
id|ea
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// if in vmalloc range, use the vmalloc page directory
r_if
c_cond
(paren
(paren
id|ea
op_ge
id|VMALLOC_START
)paren
op_logical_and
(paren
id|ea
op_le
id|VMALLOC_END
)paren
)paren
(brace
id|mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|vsid
op_assign
id|get_kernel_vsid
c_func
(paren
id|ea
)paren
suffix:semicolon
)brace
singleline_comment|// if in ioremap range, use the ioremap page directory
r_else
r_if
c_cond
(paren
(paren
id|ea
op_ge
id|IMALLOC_START
)paren
op_logical_and
(paren
id|ea
op_le
id|IMALLOC_END
)paren
)paren
(brace
id|mm
op_assign
op_amp
id|ioremap_mm
suffix:semicolon
id|vsid
op_assign
id|get_kernel_vsid
c_func
(paren
id|ea
)paren
suffix:semicolon
)brace
singleline_comment|// if in user range, use the current task&squot;s page directory
r_else
r_if
c_cond
(paren
(paren
id|ea
op_ge
id|USER_START
)paren
op_logical_and
(paren
id|ea
op_le
id|USER_END
)paren
)paren
(brace
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|vsid
op_assign
id|get_vsid
c_func
(paren
id|mm-&gt;context
comma
id|ea
)paren
suffix:semicolon
)brace
id|pgdir
op_assign
id|mm-&gt;pgd
suffix:semicolon
id|va
op_assign
(paren
id|vsid
op_lshift
l_int|28
)paren
op_or
(paren
id|ea
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|ptep
op_assign
id|find_linux_pte
c_func
(paren
id|pgdir
comma
id|ea
)paren
suffix:semicolon
)brace
id|vpn
op_assign
(paren
(paren
id|vsid
op_lshift
l_int|28
)paren
op_or
(paren
(paren
(paren
id|ea
)paren
op_amp
l_int|0xFFFF000
)paren
)paren
)paren
op_rshift
l_int|12
suffix:semicolon
id|page
op_assign
id|vpn
op_amp
l_int|0xffff
suffix:semicolon
id|esid
op_assign
(paren
id|ea
op_rshift
l_int|28
)paren
op_amp
l_int|0xFFFFFFFFF
suffix:semicolon
singleline_comment|// Search the primary group for an available slot
id|primary_hash
op_assign
(paren
id|vsid
op_amp
l_int|0x7fffffffff
)paren
op_xor
id|page
suffix:semicolon
id|hpteg_slot_primary
op_assign
(paren
id|primary_hash
op_amp
id|htab_data.htab_hash_mask
)paren
op_star
id|HPTES_PER_GROUP
suffix:semicolon
id|hpteg_slot_secondary
op_assign
(paren
op_complement
id|primary_hash
op_amp
id|htab_data.htab_hash_mask
)paren
op_star
id|HPTES_PER_GROUP
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ea             : %.16lx&bslash;n&quot;
comma
id|ea
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;esid           : %.16lx&bslash;n&quot;
comma
id|esid
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;vsid           : %.16lx&bslash;n&quot;
comma
id|vsid
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nSoftware Page Table&bslash;n-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ptep           : %.16lx&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|ptep
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptep
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;*ptep          : %.16lx&bslash;n&quot;
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|ptep
)paren
)paren
suffix:semicolon
)brace
id|hpte
op_assign
id|htab_data.htab
op_plus
id|hpteg_slot_primary
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nHardware Page Table&bslash;n-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab base      : %.16lx&bslash;n&quot;
comma
id|htab_data.htab
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;slot primary   : %.16lx&bslash;n&quot;
comma
id|hpteg_slot_primary
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;slot secondary : %.16lx&bslash;n&quot;
comma
id|hpteg_slot_secondary
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nPrimary Group&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|hpte-&gt;dw0.dw0.v
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d: (hpte)%.16lx %.16lx&bslash;n&quot;
comma
id|i
comma
id|hpte-&gt;dw0.dword0
comma
id|hpte-&gt;dw1.dword1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;          vsid: %.13lx   api: %.2lx  hash: %.1lx&bslash;n&quot;
comma
(paren
id|hpte-&gt;dw0.dw0.avpn
)paren
op_rshift
l_int|5
comma
(paren
id|hpte-&gt;dw0.dw0.avpn
)paren
op_amp
l_int|0x1f
comma
(paren
id|hpte-&gt;dw0.dw0.h
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;          rpn: %.13lx &bslash;n&quot;
comma
(paren
id|hpte-&gt;dw1.dw1.rpn
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           pp: %.1lx &bslash;n&quot;
comma
(paren
(paren
id|hpte-&gt;dw1.dw1.pp0
)paren
op_lshift
l_int|2
)paren
op_or
(paren
id|hpte-&gt;dw1.dw1.pp
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;        wimgn: %.2lx  reference: %.1lx  change: %.1lx&bslash;n&quot;
comma
(paren
(paren
id|hpte-&gt;dw1.dw1.w
)paren
op_lshift
l_int|4
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.i
)paren
op_lshift
l_int|3
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.m
)paren
op_lshift
l_int|2
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.g
)paren
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.n
)paren
op_lshift
l_int|0
)paren
comma
id|hpte-&gt;dw1.dw1.r
comma
id|hpte-&gt;dw1.dw1.c
)paren
suffix:semicolon
)brace
id|hpte
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nSecondary Group&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Search the secondary group
id|hpte
op_assign
id|htab_data.htab
op_plus
id|hpteg_slot_secondary
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|hpte-&gt;dw0.dw0.v
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d: (hpte)%.16lx %.16lx&bslash;n&quot;
comma
id|i
comma
id|hpte-&gt;dw0.dword0
comma
id|hpte-&gt;dw1.dword1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;          vsid: %.13lx   api: %.2lx  hash: %.1lx&bslash;n&quot;
comma
(paren
id|hpte-&gt;dw0.dw0.avpn
)paren
op_rshift
l_int|5
comma
(paren
id|hpte-&gt;dw0.dw0.avpn
)paren
op_amp
l_int|0x1f
comma
(paren
id|hpte-&gt;dw0.dw0.h
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;          rpn: %.13lx &bslash;n&quot;
comma
(paren
id|hpte-&gt;dw1.dw1.rpn
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           pp: %.1lx &bslash;n&quot;
comma
(paren
(paren
id|hpte-&gt;dw1.dw1.pp0
)paren
op_lshift
l_int|2
)paren
op_or
(paren
id|hpte-&gt;dw1.dw1.pp
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;        wimgn: %.2lx  reference: %.1lx  change: %.1lx&bslash;n&quot;
comma
(paren
(paren
id|hpte-&gt;dw1.dw1.w
)paren
op_lshift
l_int|4
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.i
)paren
op_lshift
l_int|3
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.m
)paren
op_lshift
l_int|2
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.g
)paren
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|hpte-&gt;dw1.dw1.n
)paren
op_lshift
l_int|0
)paren
comma
id|hpte-&gt;dw1.dw1.r
comma
id|hpte-&gt;dw1.dw1.c
)paren
suffix:semicolon
)brace
id|hpte
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nHardware Segment Table&bslash;n-----------------------&bslash;n&quot;
)paren
suffix:semicolon
id|stabl
op_assign
(paren
r_int
r_int
)paren
(paren
id|KERNELBASE
op_plus
(paren
id|_ASR
op_amp
l_int|0xFFFFFFFFFFFFFFFE
)paren
)paren
suffix:semicolon
id|steg
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
id|stabl
)paren
op_or
(paren
(paren
id|esid
op_amp
l_int|0x1f
)paren
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;stab base      : %.16lx&bslash;n&quot;
comma
id|stabl
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;slot           : %.16lx&bslash;n&quot;
comma
id|steg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d: (ste) %.16lx %.16lx&bslash;n&quot;
comma
id|i
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|steg
op_plus
id|i
op_star
l_int|2
)paren
)paren
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|steg
op_plus
id|i
op_star
l_int|2
op_plus
l_int|1
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_check
r_void
id|mem_check
c_func
(paren
)paren
(brace
r_int
r_int
id|htab_size_bytes
suffix:semicolon
r_int
r_int
id|htab_end
suffix:semicolon
r_int
r_int
id|last_rpn
suffix:semicolon
id|HPTE
op_star
id|hpte1
comma
op_star
id|hpte2
suffix:semicolon
id|htab_size_bytes
op_assign
id|htab_data.htab_num_ptegs
op_star
l_int|128
suffix:semicolon
singleline_comment|// 128B / PTEG
id|htab_end
op_assign
(paren
r_int
r_int
)paren
id|htab_data.htab
op_plus
id|htab_size_bytes
suffix:semicolon
singleline_comment|// last_rpn = (naca-&gt;physicalMemorySize-1) &gt;&gt; PAGE_SHIFT;
id|last_rpn
op_assign
l_int|0xfffff
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nHardware Page Table Check&bslash;n-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab base      : %.16lx&bslash;n&quot;
comma
id|htab_data.htab
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab size      : %.16lx&bslash;n&quot;
comma
id|htab_size_bytes
)paren
suffix:semicolon
macro_line|#if 1
r_for
c_loop
(paren
id|hpte1
op_assign
id|htab_data.htab
suffix:semicolon
id|hpte1
OL
(paren
id|HPTE
op_star
)paren
id|htab_end
suffix:semicolon
id|hpte1
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw0.dw0.v
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw1.dw1.rpn
op_le
id|last_rpn
)paren
(brace
r_for
c_loop
(paren
id|hpte2
op_assign
id|hpte1
op_plus
l_int|1
suffix:semicolon
id|hpte2
OL
(paren
id|HPTE
op_star
)paren
id|htab_end
suffix:semicolon
id|hpte2
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hpte2-&gt;dw0.dw0.v
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw1.dw1.rpn
op_eq
id|hpte2-&gt;dw1.dw1.rpn
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; Duplicate rpn: %.13lx &bslash;n&quot;
comma
(paren
id|hpte1-&gt;dw1.dw1.rpn
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   hpte1: %16.16lx  *hpte1: %16.16lx %16.16lx&bslash;n&quot;
comma
id|hpte1
comma
id|hpte1-&gt;dw0.dword0
comma
id|hpte1-&gt;dw1.dword1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   hpte2: %16.16lx  *hpte2: %16.16lx %16.16lx&bslash;n&quot;
comma
id|hpte2
comma
id|hpte2-&gt;dw0.dword0
comma
id|hpte2-&gt;dw1.dword1
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot; Bogus rpn: %.13lx &bslash;n&quot;
comma
(paren
id|hpte1-&gt;dw1.dw1.rpn
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   hpte: %16.16lx  *hpte: %16.16lx %16.16lx&bslash;n&quot;
comma
id|hpte1
comma
id|hpte1-&gt;dw0.dword0
comma
id|hpte1-&gt;dw1.dword1
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|printf
c_func
(paren
l_string|&quot;&bslash;nDone -------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mem_find_real
r_void
id|mem_find_real
c_func
(paren
)paren
(brace
r_int
r_int
id|htab_size_bytes
suffix:semicolon
r_int
r_int
id|htab_end
suffix:semicolon
r_int
r_int
id|last_rpn
suffix:semicolon
id|HPTE
op_star
id|hpte1
suffix:semicolon
r_int
r_int
id|pa
comma
id|rpn
suffix:semicolon
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|pa
)paren
suffix:semicolon
id|rpn
op_assign
id|pa
op_rshift
l_int|12
suffix:semicolon
id|htab_size_bytes
op_assign
id|htab_data.htab_num_ptegs
op_star
l_int|128
suffix:semicolon
singleline_comment|// 128B / PTEG
id|htab_end
op_assign
(paren
r_int
r_int
)paren
id|htab_data.htab
op_plus
id|htab_size_bytes
suffix:semicolon
singleline_comment|// last_rpn = (naca-&gt;physicalMemorySize-1) &gt;&gt; PAGE_SHIFT;
id|last_rpn
op_assign
l_int|0xfffff
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nMem Find RPN&bslash;n-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab base      : %.16lx&bslash;n&quot;
comma
id|htab_data.htab
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab size      : %.16lx&bslash;n&quot;
comma
id|htab_size_bytes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hpte1
op_assign
id|htab_data.htab
suffix:semicolon
id|hpte1
OL
(paren
id|HPTE
op_star
)paren
id|htab_end
suffix:semicolon
id|hpte1
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw0.dw0.v
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw1.dw1.rpn
op_eq
id|rpn
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; Found rpn: %.13lx &bslash;n&quot;
comma
(paren
id|hpte1-&gt;dw1.dw1.rpn
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;      hpte: %16.16lx  *hpte1: %16.16lx %16.16lx&bslash;n&quot;
comma
id|hpte1
comma
id|hpte1-&gt;dw0.dword0
comma
id|hpte1-&gt;dw1.dword1
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nDone -------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mem_find_vsid
r_void
id|mem_find_vsid
c_func
(paren
)paren
(brace
r_int
r_int
id|htab_size_bytes
suffix:semicolon
r_int
r_int
id|htab_end
suffix:semicolon
id|HPTE
op_star
id|hpte1
suffix:semicolon
r_int
r_int
id|vsid
suffix:semicolon
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|vsid
)paren
suffix:semicolon
id|htab_size_bytes
op_assign
id|htab_data.htab_num_ptegs
op_star
l_int|128
suffix:semicolon
singleline_comment|// 128B / PTEG
id|htab_end
op_assign
(paren
r_int
r_int
)paren
id|htab_data.htab
op_plus
id|htab_size_bytes
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nMem Find VSID&bslash;n-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab base      : %.16lx&bslash;n&quot;
comma
id|htab_data.htab
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;htab size      : %.16lx&bslash;n&quot;
comma
id|htab_size_bytes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hpte1
op_assign
id|htab_data.htab
suffix:semicolon
id|hpte1
OL
(paren
id|HPTE
op_star
)paren
id|htab_end
suffix:semicolon
id|hpte1
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hpte1-&gt;dw0.dw0.v
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|hpte1-&gt;dw0.dw0.avpn
)paren
op_rshift
l_int|5
)paren
op_eq
id|vsid
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; Found vsid: %.16lx &bslash;n&quot;
comma
(paren
(paren
id|hpte1-&gt;dw0.dw0.avpn
)paren
op_rshift
l_int|5
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       hpte: %16.16lx  *hpte1: %16.16lx %16.16lx&bslash;n&quot;
comma
id|hpte1
comma
id|hpte1-&gt;dw0.dword0
comma
id|hpte1-&gt;dw1.dword1
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nDone -------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|debug_trace
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|val
comma
id|cmd
comma
id|on
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* show current state */
r_int
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;naca-&gt;debug_switch = 0x%lx&bslash;n&quot;
comma
id|naca-&gt;debug_switch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PPCDBG_NUM_FLAGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|on
op_assign
id|PPCDBG_BITVAL
c_func
(paren
id|i
)paren
op_amp
id|naca-&gt;debug_switch
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%02x %s %12s   &quot;
comma
id|i
comma
id|on
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
comma
id|trace_names
(braket
id|i
)braket
ques
c_cond
id|trace_names
(braket
id|i
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|on
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default if no sign given */
r_while
c_loop
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|on
op_assign
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot; &squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* Turn on or off based on + or - */
id|naca-&gt;debug_switch
op_assign
id|on
ques
c_cond
id|PPCDBG_ALL
suffix:colon
id|PPCDBG_NONE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Setting all values to %s...&bslash;n&quot;
comma
id|on
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
suffix:semicolon
r_else
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* not +/- ... let scanhex see it */
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|64
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Value %x out of range:&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on
)paren
(brace
id|naca-&gt;debug_switch
op_or_assign
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;enable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|naca-&gt;debug_switch
op_and_assign
op_complement
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;disable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
eof
