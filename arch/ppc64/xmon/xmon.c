multiline_comment|/*&n; * Routines providing a simple monitor for use on the PowerMac.&n; *&n; * Copyright (C) 1996 Paul Mackerras.&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/cpumask.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/naca.h&gt;
macro_line|#include &lt;asm/paca.h&gt;
macro_line|#include &lt;asm/ppcdebug.h&gt;
macro_line|#include &lt;asm/cputable.h&gt;
macro_line|#include &quot;nonstdio.h&quot;
macro_line|#include &quot;privinst.h&quot;
DECL|macro|scanhex
mdefine_line|#define scanhex&t;xmon_scanhex
DECL|macro|skipbl
mdefine_line|#define skipbl&t;xmon_skipbl
macro_line|#ifdef CONFIG_SMP
DECL|variable|cpus_in_xmon
r_volatile
id|cpumask_t
id|cpus_in_xmon
op_assign
id|CPU_MASK_NONE
suffix:semicolon
DECL|variable|got_xmon
r_static
r_int
r_int
id|got_xmon
op_assign
l_int|0
suffix:semicolon
DECL|variable|take_xmon
r_static
r_volatile
r_int
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|leaving_xmon
r_static
r_volatile
r_int
id|leaving_xmon
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
DECL|variable|adrs
r_static
r_int
r_int
id|adrs
suffix:semicolon
DECL|variable|size
r_static
r_int
id|size
op_assign
l_int|1
suffix:semicolon
DECL|variable|ndump
r_static
r_int
r_int
id|ndump
op_assign
l_int|64
suffix:semicolon
DECL|variable|nidump
r_static
r_int
r_int
id|nidump
op_assign
l_int|16
suffix:semicolon
DECL|variable|ncsum
r_static
r_int
r_int
id|ncsum
op_assign
l_int|4096
suffix:semicolon
DECL|variable|termch
r_static
r_int
id|termch
suffix:semicolon
DECL|variable|tmpstr
r_static
r_char
id|tmpstr
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|bus_error_jmp
r_static
id|u_int
id|bus_error_jmp
(braket
l_int|100
)braket
suffix:semicolon
DECL|macro|setjmp
mdefine_line|#define setjmp xmon_setjmp
DECL|macro|longjmp
mdefine_line|#define longjmp xmon_longjmp
multiline_comment|/* Breakpoint stuff */
DECL|struct|bpt
r_struct
id|bpt
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|instr
r_int
id|instr
suffix:semicolon
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NBPTS
mdefine_line|#define NBPTS&t;16
DECL|variable|bpts
r_static
r_struct
id|bpt
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
DECL|variable|dabr
r_static
r_struct
id|bpt
id|dabr
suffix:semicolon
DECL|variable|iabr
r_static
r_struct
id|bpt
id|iabr
suffix:semicolon
DECL|variable|bpinstr
r_static
r_int
id|bpinstr
op_assign
l_int|0x7fe00008
suffix:semicolon
multiline_comment|/* trap */
multiline_comment|/* Prototypes */
r_static
r_int
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|mread
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mwrite
c_func
(paren
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|byterev
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|memex
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bsesc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|prdump
c_func
(paren
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppc_inst_dump
c_func
(paren
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|print_address
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|memops
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|memlocate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memzcan
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memdiffs
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|skipbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|scanhex
c_func
(paren
r_int
r_int
op_star
id|valp
)paren
suffix:semicolon
r_static
r_void
id|scannl
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|hexdigit
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|getstring
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|flush_input
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|inchar
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|take_input
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* static void openforth(void); */
r_static
r_int
r_int
id|read_spr
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|write_spr
c_func
(paren
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|super_regs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|remove_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|insert_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|bpt
op_star
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
r_static
r_void
id|bpt_cmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|cacheflush
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|cpu_cmd
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
r_static
r_void
id|csum
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bootcmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|dump_segments
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|symbol_lookup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|print_insn_big_powerpc
c_func
(paren
id|FILE
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_void
id|xmon_vfprintf
c_func
(paren
r_void
op_star
id|f
comma
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|ap
)paren
suffix:semicolon
r_extern
r_int
id|xmon_putc
c_func
(paren
r_int
id|c
comma
r_void
op_star
id|f
)paren
suffix:semicolon
r_extern
r_int
id|putchar
c_func
(paren
r_int
id|ch
)paren
suffix:semicolon
r_extern
r_int
id|xmon_read_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
m_setjmp
(paren
id|u_int
op_star
)paren
suffix:semicolon
r_extern
r_void
m_longjmp
(paren
id|u_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|_ASR
suffix:semicolon
id|pte_t
op_star
id|find_linux_pte
c_func
(paren
id|pgd_t
op_star
id|pgdir
comma
r_int
r_int
id|va
)paren
suffix:semicolon
multiline_comment|/* from htab.c */
DECL|macro|GETWORD
mdefine_line|#define GETWORD(v)&t;(((v)[0] &lt;&lt; 24) + ((v)[1] &lt;&lt; 16) + ((v)[2] &lt;&lt; 8) + (v)[3])
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
DECL|macro|isalnum
mdefine_line|#define isalnum(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;z&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;Z&squot;))
DECL|macro|isspace
mdefine_line|#define isspace(c)&t;(c == &squot; &squot; || c == &squot;&bslash;t&squot; || c == 10 || c == 13 || c == 0)
DECL|variable|help_string
r_static
r_char
op_star
id|help_string
op_assign
l_string|&quot;&bslash;&n;Commands:&bslash;n&bslash;&n;  b&t;show breakpoints&bslash;n&bslash;&n;  bd&t;set data breakpoint&bslash;n&bslash;&n;  bi&t;set instruction breakpoint&bslash;n&bslash;&n;  bc&t;clear breakpoint&bslash;n&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;&bslash;&n;  c&t;print cpus stopped in xmon&bslash;n&bslash;&n;  ci&t;send xmon interrupt to all other cpus&bslash;n&bslash;&n;  c#&t;try to switch to cpu number h (in hex)&bslash;n&quot;
macro_line|#endif
l_string|&quot;&bslash;&n;  C&t;checksum&bslash;n&bslash;&n;  d&t;dump bytes&bslash;n&bslash;&n;  di&t;dump instructions&bslash;n&bslash;&n;  df&t;dump float values&bslash;n&bslash;&n;  dd&t;dump double values&bslash;n&bslash;&n;  e&t;print exception information&bslash;n&bslash;&n;  f&t;flush cache&bslash;n&bslash;&n;  la&t;lookup symbol+offset of specified address&bslash;n&bslash;&n;  ls&t;lookup address of specified symbol&bslash;n&bslash;&n;  m&t;examine/change memory&bslash;n&bslash;&n;  mm&t;move a block of memory&bslash;n&bslash;&n;  ms&t;set a block of memory&bslash;n&bslash;&n;  md&t;compare two blocks of memory&bslash;n&bslash;&n;  ml&t;locate a block of memory&bslash;n&bslash;&n;  mz&t;zero a block of memory&bslash;n&bslash;&n;  mi&t;show information about memory allocation&bslash;n&bslash;&n;  p &t;show the task list&bslash;n&bslash;&n;  r&t;print registers&bslash;n&bslash;&n;  s&t;single step&bslash;n&bslash;&n;  S&t;print special registers&bslash;n&bslash;&n;  t&t;print backtrace&bslash;n&bslash;&n;  T&t;Enable/Disable PPCDBG flags&bslash;n&bslash;&n;  x&t;exit monitor&bslash;n&bslash;&n;  u&t;dump segment table or SLB&bslash;n&bslash;&n;  ?&t;help&bslash;n&quot;
l_string|&quot;&bslash;&n;  zr&t;reboot&bslash;n&bslash;&n;  zh&t;halt&bslash;n&quot;
suffix:semicolon
DECL|variable|xmon_trace
r_static
r_int
id|xmon_trace
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|macro|SSTEP
mdefine_line|#define SSTEP&t;1&t;&t;/* stepping because of &squot;s&squot; command */
DECL|macro|BRSTEP
mdefine_line|#define BRSTEP&t;2&t;&t;/* stepping over breakpoint */
DECL|variable|xmon_regs
r_static
r_struct
id|pt_regs
op_star
id|xmon_regs
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_void
id|__xmon_print_symbol
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
r_int
r_int
id|address
)paren
suffix:semicolon
DECL|macro|xmon_print_symbol
mdefine_line|#define xmon_print_symbol(fmt, addr)&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__check_printsym_format(fmt, &quot;&quot;);&t;&bslash;&n;&t;__xmon_print_symbol(fmt, addr);&t;&t;&bslash;&n;} while(0)
multiline_comment|/*&n; * Stuff for reading and writing memory safely&n; */
DECL|function|sync
r_extern
r_inline
r_void
id|sync
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;sync; isync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* (Ref: 64-bit PowerPC ELF ABI Spplement; Ian Lance Taylor, Zembu Labs).&n; A PPC stack frame looks like this:&n;&n; High Address&n;    Back Chain&n;    FP reg save area&n;    GP reg save area&n;    Local var space&n;    Parameter save area&t;&t;(SP+48)&n;    TOC save area&t;&t;(SP+40)&n;    link editor doubleword&t;(SP+32)&n;    compiler doubleword&t;&t;(SP+24)&n;    LR save&t;&t;&t;(SP+16)&n;    CR save&t;&t;&t;(SP+8)&n;    Back Chain&t;&t;&t;(SP+0)&n;&n; Note that the LR (ret addr) may not be saved in the current frame if&n; no functions have been called from the current function.&n; */
DECL|macro|SURVEILLANCE_TOKEN
mdefine_line|#define SURVEILLANCE_TOKEN&t;9000
DECL|function|disable_surveillance
r_static
r_inline
r_void
id|disable_surveillance
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_PPC_ISERIES
id|rtas_call
c_func
(paren
id|rtas_token
c_func
(paren
l_string|&quot;set-indicator&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
l_int|NULL
comma
id|SURVEILLANCE_TOKEN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|xmon
id|xmon
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_int
id|cmd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|msr
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Ok, grab regs as they are now.&n;&t;&t; This won&squot;t do a particularily good job because the&n;&t;&t; prologue has already been executed.&n;&t;&t; ToDo: We could reach back into the callers save&n;&t;&t; area to do a better job of representing the&n;&t;&t; caller&squot;s state.&n;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;std&t;0,0(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;1,8(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;2,16(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;3,24(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;4,32(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;5,40(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;6,48(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;7,56(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;8,64(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;9,72(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;10,80(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;11,88(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;12,96(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;13,104(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;14,112(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;15,120(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;16,128(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;17,136(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;18,144(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;19,152(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;20,160(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;21,168(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;22,176(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;23,184(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;24,192(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;25,200(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;26,208(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;27,216(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;28,224(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;29,232(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;30,240(%0)&bslash;n&bslash;&n;&t;&t;&t;std&t;31,248(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
op_amp
id|regs
)paren
)paren
suffix:semicolon
id|regs.nip
op_assign
id|regs.link
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs.gpr
(braket
l_int|1
)braket
)paren
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|regs.msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|regs.ctr
op_assign
id|get_ctr
c_func
(paren
)paren
suffix:semicolon
id|regs.xer
op_assign
id|get_xer
c_func
(paren
)paren
suffix:semicolon
id|regs.ccr
op_assign
id|get_cr
c_func
(paren
)paren
suffix:semicolon
id|regs.trap
op_assign
l_int|0
suffix:semicolon
id|excp
op_assign
op_amp
id|regs
suffix:semicolon
)brace
id|msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|msr
op_amp
op_complement
id|MSR_EE
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|xmon_regs
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|excp
suffix:semicolon
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|leaving_xmon
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* possible race condition here if a CPU is held up and gets&n;&t; * here while we are exiting */
r_if
c_cond
(paren
id|cpu_test_and_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpus_in_xmon
)paren
)paren
(brace
multiline_comment|/* xmon probably caused an exception itself */
id|printf
c_func
(paren
l_string|&quot;We are already in xmon&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
)paren
(brace
r_if
c_cond
(paren
id|take_xmon
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX: breakpoints are removed while any cpu is in xmon&n;&t; */
macro_line|#endif /* CONFIG_SMP */
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|disable_surveillance
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;press ? for help &quot;
)paren
suffix:semicolon
id|cmd
op_assign
id|cmds
c_func
(paren
id|excp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|SSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
macro_line|#ifdef CONFIG_SMP&t;&t;
id|take_xmon
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;
)brace
r_else
r_if
c_cond
(paren
id|at_breakpoint
c_func
(paren
id|excp-&gt;nip
)paren
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
id|xmon_regs
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|leaving_xmon
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;s&squot;
)paren
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
suffix:semicolon
id|cpu_clear
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpus_in_xmon
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|set_msrd
c_func
(paren
id|msr
)paren
suffix:semicolon
multiline_comment|/* restore interrupt enable */
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_bpt
id|xmon_bpt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;count
)paren
(brace
op_decrement
id|bp-&gt;count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Stopped at breakpoint %x (%lx &quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s)&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_sstep
id|xmon_sstep
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_eq
id|BRSTEP
)paren
(brace
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_dabr_match
id|xmon_dabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|dabr.count
)paren
(brace
op_decrement
id|dabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|dabr.instr
op_assign
id|regs-&gt;nip
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_iabr_match
id|xmon_iabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|iabr.count
)paren
(brace
op_decrement
id|iabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
id|MSR_SE
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|bpt
op_star
DECL|function|at_breakpoint
id|at_breakpoint
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|pc
op_eq
id|dabr.instr
)paren
r_return
op_amp
id|dabr
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|pc
op_eq
id|iabr.address
)paren
r_return
op_amp
id|iabr
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
op_logical_and
id|pc
op_eq
id|bp-&gt;address
)paren
r_return
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|insert_bpts
id|insert_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
op_logical_or
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bpinstr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t insert breakpoint at %x, disabling&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_DABR
)paren
op_logical_and
id|dabr.enabled
)paren
id|set_dabr
c_func
(paren
id|dabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
op_logical_and
id|iabr.enabled
)paren
id|set_iabr
c_func
(paren
id|iabr.address
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|remove_bpts
id|remove_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
id|instr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_DABR
)paren
)paren
id|set_dabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
)paren
id|set_iabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|instr
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
id|instr
op_eq
id|bpinstr
op_logical_and
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t remove breakpoint at %x&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
r_else
id|store_inst
c_func
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|variable|last_cmd
r_static
r_char
op_star
id|last_cmd
suffix:semicolon
multiline_comment|/* Command interpreting routine */
r_static
r_int
DECL|function|cmds
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
id|cmd
op_assign
l_int|0
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Need to check if we should take any commands on&n;&t;&t;   this CPU. */
r_if
c_cond
(paren
id|leaving_xmon
)paren
r_return
id|cmd
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d:&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printf
c_func
(paren
l_string|&quot;mon&gt; &quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|flush_input
c_func
(paren
)paren
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|last_cmd
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|take_input
c_func
(paren
id|last_cmd
)paren
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
id|memops
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|memlocate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|memzcan
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|show_mem
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|memex
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|dump
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|symbol_lookup
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_ne
l_int|NULL
)paren
id|prregs
c_func
(paren
id|excp
)paren
suffix:semicolon
multiline_comment|/* print regs */
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot;No exception information&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|super_regs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|backtrace
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|cacheflush
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
r_return
id|cmd
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
id|show_state
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|bpt_cmds
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|csum
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_case
l_char|&squot;c&squot;
suffix:colon
id|cpu_cmd
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
r_case
l_char|&squot;z&squot;
suffix:colon
id|bootcmds
c_func
(paren
)paren
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|debug_trace
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|dump_segments
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Unrecognized command: &quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
l_char|&squot; &squot;
OL
id|cmd
op_logical_and
id|cmd
op_le
l_char|&squot;~&squot;
)paren
(brace
id|putchar
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&bslash;x%x&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (type ? for help)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|bootcmds
r_static
r_void
id|bootcmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|ppc_md
dot
id|restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;h&squot;
)paren
id|ppc_md
dot
id|halt
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;p&squot;
)paren
id|ppc_md
dot
id|power_off
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|cpu_cmd
r_static
r_void
id|cpu_cmd
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;stopping all cpus&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* interrupt other cpu(s) */
id|cpu
op_assign
id|MSG_ALL_BUT_SELF
suffix:semicolon
id|smp_send_debugger_break
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|cpu
)paren
)paren
(brace
multiline_comment|/* print cpus waiting or in xmon */
id|printf
c_func
(paren
l_string|&quot;cpus stopped:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpus_in_xmon
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; %x&quot;
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;*&quot;
comma
id|cpu
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* try to switch to cpu specified */
id|take_xmon
op_assign
id|cpu
suffix:semicolon
id|timeout
op_assign
l_int|10000000
suffix:semicolon
r_while
c_loop
(paren
id|take_xmon
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
op_eq
l_int|0
)paren
(brace
multiline_comment|/* yes there&squot;s a race here */
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;cpu %u didn&squot;t take control&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* now have to wait to be given control back */
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|got_xmon
)paren
)paren
(brace
r_if
c_cond
(paren
id|take_xmon
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|take_xmon
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|variable|fcstab
r_static
r_int
r_int
id|fcstab
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|macro|FCS
mdefine_line|#define FCS(fcs, c)&t;(((fcs) &gt;&gt; 8) ^ fcstab[((fcs) ^ (c)) &amp; 0xff])
r_static
r_void
DECL|function|csum
id|csum
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|fcs
suffix:semicolon
r_int
r_char
id|v
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|ncsum
)paren
)paren
r_return
suffix:semicolon
id|fcs
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ncsum
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|adrs
op_plus
id|i
comma
op_amp
id|v
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;csum stopped at %x&bslash;n&quot;
comma
id|adrs
op_plus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fcs
op_assign
id|FCS
c_func
(paren
id|fcs
comma
id|v
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%x&bslash;n&quot;
comma
id|fcs
)paren
suffix:semicolon
)brace
DECL|variable|breakpoint_help_string
r_static
r_char
op_star
id|breakpoint_help_string
op_assign
l_string|&quot;Breakpoint command usage:&bslash;n&quot;
l_string|&quot;b                show breakpoints&bslash;n&quot;
l_string|&quot;b &lt;addr&gt; [cnt]   set breakpoint at given instr addr&bslash;n&quot;
l_string|&quot;bc               clear all breakpoints&bslash;n&quot;
l_string|&quot;bc &lt;n/addr&gt;      clear breakpoint number n or at addr&bslash;n&quot;
l_string|&quot;bi &lt;addr&gt; [cnt]  set hardware instr breakpoint (broken?)&bslash;n&quot;
l_string|&quot;bd &lt;addr&gt; [cnt]  set hardware data breakpoint (broken?)&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_static
r_void
DECL|function|bpt_cmds
id|bpt_cmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|a
suffix:semicolon
r_int
id|mode
comma
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* bd - hardware data breakpoint */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_DABR
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Not implemented on this cpu&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mode
op_assign
l_int|7
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|mode
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;w&squot;
)paren
id|mode
op_assign
l_int|6
suffix:semicolon
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
id|dabr.address
op_assign
l_int|0
suffix:semicolon
id|dabr.count
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|dabr.address
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|dabr.address
op_assign
(paren
id|dabr.address
op_amp
op_complement
l_int|7
)paren
op_or
id|mode
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* bi - hardware instr breakpoint */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_IABR
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Not implemented on POWER4&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|iabr.address
op_assign
l_int|0
suffix:semicolon
id|iabr.count
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|iabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|iabr.address
op_or_assign
l_int|3
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|iabr.count
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* clear all breakpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
)paren
id|bpts
(braket
id|i
)braket
dot
id|enabled
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All breakpoints cleared&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|a
op_le
id|NBPTS
op_logical_and
id|a
op_ge
l_int|1
)paren
(brace
multiline_comment|/* assume a breakpoint number */
op_decrement
id|a
suffix:semicolon
multiline_comment|/* bp nums are 1 based */
id|bp
op_assign
op_amp
id|bpts
(braket
id|a
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assume a breakpoint address */
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;No breakpoint at %x&bslash;n&quot;
comma
id|a
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Cleared breakpoint %x (%lx &quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s)&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|breakpoint_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|breakpoint_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* print all breakpoints */
r_int
id|bpnum
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   type            address    count&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   data   %.16lx %8x [&quot;
comma
id|dabr.address
op_amp
op_complement
l_int|7
comma
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|printf
c_func
(paren
l_string|&quot;   inst   %.16lx %8x&bslash;n&quot;
comma
id|iabr.address
op_amp
op_complement
l_int|3
comma
id|iabr.count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
comma
id|bpnum
op_assign
l_int|1
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
comma
op_increment
id|bpnum
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%2x trap   %.16lx %8x  &quot;
comma
id|bpnum
comma
id|bp-&gt;address
comma
id|bp-&gt;count
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|systemcfg-&gt;platform
op_ne
id|PLATFORM_POWERMAC
op_logical_and
op_logical_neg
(paren
id|systemcfg-&gt;platform
op_amp
id|PLATFORM_PSERIES
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Not supported for this platform&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ge
op_amp
id|bpts
(braket
id|NBPTS
)braket
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Sorry, no free breakpoints.  Please clear one first.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bp-&gt;enabled
op_assign
l_int|1
suffix:semicolon
id|bp-&gt;address
op_assign
id|a
suffix:semicolon
id|bp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|bp-&gt;count
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Set breakpoint %2x trap   %.16lx %8x  &quot;
comma
(paren
id|bp
op_minus
id|bpts
)paren
op_plus
l_int|1
comma
id|bp-&gt;address
comma
id|bp-&gt;count
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Very cheap human name for vector lookup. */
r_static
DECL|function|getvecname
r_const
r_char
op_star
id|getvecname
c_func
(paren
r_int
r_int
id|vec
)paren
(brace
r_char
op_star
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|vec
)paren
(brace
r_case
l_int|0x100
suffix:colon
id|ret
op_assign
l_string|&quot;(System Reset)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x200
suffix:colon
id|ret
op_assign
l_string|&quot;(Machine Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x300
suffix:colon
id|ret
op_assign
l_string|&quot;(Data Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x380
suffix:colon
id|ret
op_assign
l_string|&quot;(Data SLB Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x400
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x480
suffix:colon
id|ret
op_assign
l_string|&quot;(Instruction SLB Access)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x500
suffix:colon
id|ret
op_assign
l_string|&quot;(Hardware Interrupt)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x600
suffix:colon
id|ret
op_assign
l_string|&quot;(Alignment)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x700
suffix:colon
id|ret
op_assign
l_string|&quot;(Program Check)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x800
suffix:colon
id|ret
op_assign
l_string|&quot;(FPU Unavailable)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x900
suffix:colon
id|ret
op_assign
l_string|&quot;(Decrementer)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc00
suffix:colon
id|ret
op_assign
l_string|&quot;(System Call)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd00
suffix:colon
id|ret
op_assign
l_string|&quot;(Single Step)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf00
suffix:colon
id|ret
op_assign
l_string|&quot;(Performance Monitor)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Most of our exceptions are in the form:&n; *    bl handler&n; *    b .ret_from_exception&n; * and this currently fails to catch them.&n; */
DECL|function|exception_frame
r_static
r_inline
r_int
id|exception_frame
c_func
(paren
r_int
r_int
id|ip
)paren
(brace
r_extern
r_void
op_star
id|ret_from_syscall_1
comma
op_star
id|ret_from_syscall_2
comma
op_star
id|ret_from_except
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip
op_eq
(paren
r_int
r_int
)paren
id|ret_from_syscall_1
)paren
op_logical_or
(paren
id|ip
op_eq
(paren
r_int
r_int
)paren
id|ret_from_syscall_2
)paren
op_logical_or
(paren
id|ip
op_eq
(paren
r_int
r_int
)paren
id|ret_from_except
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|xmon_depth_to_print
r_static
r_int
id|xmon_depth_to_print
op_assign
l_int|64
suffix:semicolon
DECL|function|xmon_show_stack
r_static
r_void
id|xmon_show_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_int
r_int
id|ip
suffix:semicolon
r_int
r_int
id|newsp
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|sp
OL
id|PAGE_OFFSET
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;SP in userspace&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mread
c_func
(paren
(paren
id|sp
op_plus
l_int|16
)paren
comma
op_amp
id|ip
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;[%016lx] [%016lx] &quot;
comma
id|sp
comma
id|ip
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exception_frame
c_func
(paren
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
op_plus
l_int|112
comma
op_amp
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
op_ne
r_sizeof
(paren
id|regs
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  exception: %lx %s regs %lx&bslash;n&quot;
comma
id|regs.trap
comma
id|getvecname
c_func
(paren
id|regs.trap
)paren
comma
id|sp
op_plus
l_int|112
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mread
c_func
(paren
id|sp
comma
op_amp
id|newsp
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|newsp
OL
id|sp
)paren
r_break
suffix:semicolon
id|sp
op_assign
id|newsp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
id|xmon_depth_to_print
)paren
suffix:semicolon
)brace
DECL|function|backtrace
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
r_int
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
id|sp
op_assign
id|__get_SP
c_func
(paren
)paren
suffix:semicolon
r_else
id|sp
op_assign
id|excp-&gt;gpr
(braket
l_int|1
)braket
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
id|scannl
c_func
(paren
)paren
suffix:semicolon
id|xmon_show_stack
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
DECL|variable|exception_print_lock
id|spinlock_t
id|exception_print_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_void
DECL|function|excprint
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|exception_print_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printf
c_func
(paren
l_string|&quot;cpu %d: &quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printf
c_func
(paren
l_string|&quot;Vector: %lx %s at [%lx]&bslash;n&quot;
comma
id|fp-&gt;trap
comma
id|getvecname
c_func
(paren
id|fp-&gt;trap
)paren
comma
id|fp
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    pc: %lx&quot;
comma
id|fp-&gt;nip
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
id|fp-&gt;nip
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    lr: %lx&quot;
comma
id|fp-&gt;link
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
id|fp-&gt;link
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    sp: %lx&bslash;n&quot;
comma
id|fp-&gt;gpr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   msr: %lx&bslash;n&quot;
comma
id|fp-&gt;msr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;trap
op_eq
l_int|0x300
op_logical_or
id|fp-&gt;trap
op_eq
l_int|0x380
op_logical_or
id|fp-&gt;trap
op_eq
l_int|0x600
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   dar: %lx&bslash;n&quot;
comma
id|fp-&gt;dar
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; dsisr: %lx&bslash;n&quot;
comma
id|fp-&gt;dsisr
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  current = 0x%lx&bslash;n&quot;
comma
id|current
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  paca    = 0x%lx&bslash;n&quot;
comma
id|get_paca
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;    pid   = %ld, comm = %s&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|exception_print_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|prregs
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|base
)paren
)paren
id|fp
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|16
suffix:semicolon
op_increment
id|n
)paren
id|printf
c_func
(paren
l_string|&quot;R%.2ld = %.16lx   R%.2ld = %.16lx&bslash;n&quot;
comma
id|n
comma
id|fp-&gt;gpr
(braket
id|n
)braket
comma
id|n
op_plus
l_int|16
comma
id|fp-&gt;gpr
(braket
id|n
op_plus
l_int|16
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pc  = %.16lx   msr = %.16lx&bslash;nlr  = %.16lx   cr  = %.16lx&bslash;n&quot;
comma
id|fp-&gt;nip
comma
id|fp-&gt;msr
comma
id|fp-&gt;link
comma
id|fp-&gt;ccr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ctr = %.16lx   xer = %.16lx   trap = %8lx&bslash;n&quot;
comma
id|fp-&gt;ctr
comma
id|fp-&gt;xer
comma
id|fp-&gt;trap
)paren
suffix:semicolon
)brace
r_void
DECL|function|cacheflush
id|cacheflush
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|nflush
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
id|termch
op_assign
id|cmd
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|nflush
op_assign
l_int|1
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|nflush
)paren
suffix:semicolon
id|nflush
op_assign
(paren
id|nflush
op_plus
id|L1_CACHE_BYTES
op_minus
l_int|1
)paren
op_div
id|L1_CACHE_BYTES
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
id|L1_CACHE_BYTES
)paren
id|cflush
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
id|L1_CACHE_BYTES
)paren
id|cinval
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|read_spr
id|read_spr
c_func
(paren
r_int
id|n
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_int
id|ret
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6002a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|opd
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|code
c_func
(paren
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error reading spr %x&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|write_spr
id|write_spr
c_func
(paren
r_int
id|n
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
(paren
op_star
id|code
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|opd
(braket
l_int|3
)braket
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6003a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|opd
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|instrs
suffix:semicolon
id|opd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|opd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
r_int
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|opd
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|code
c_func
(paren
id|val
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error writing spr %x&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|regno
r_static
r_int
r_int
id|regno
suffix:semicolon
r_extern
r_char
id|exc_prolog
suffix:semicolon
r_extern
r_char
id|dec_exc
suffix:semicolon
r_void
DECL|function|super_regs
id|super_regs
c_func
(paren
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
r_struct
id|paca_struct
op_star
id|ptrPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpPaca
op_star
id|ptrLpPaca
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ItLpRegSave
op_star
id|ptrLpRegSave
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_int
r_int
id|sp
comma
id|toc
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sp
)paren
suffix:colon
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|toc
)paren
suffix:colon
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;msr  = %.16lx  sprg0= %.16lx&bslash;n&quot;
comma
id|get_msr
c_func
(paren
)paren
comma
id|get_sprg0
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pvr  = %.16lx  sprg1= %.16lx&bslash;n&quot;
comma
id|get_pvr
c_func
(paren
)paren
comma
id|get_sprg1
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;dec  = %.16lx  sprg2= %.16lx&bslash;n&quot;
comma
id|get_dec
c_func
(paren
)paren
comma
id|get_sprg2
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sp   = %.16lx  sprg3= %.16lx&bslash;n&quot;
comma
id|sp
comma
id|get_sprg3
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;toc  = %.16lx  dar  = %.16lx&bslash;n&quot;
comma
id|toc
comma
id|get_dar
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;srr0 = %.16lx  srr1 = %.16lx&bslash;n&quot;
comma
id|get_srr0
c_func
(paren
)paren
comma
id|get_srr1
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC_ISERIES
singleline_comment|// Dump out relevant Paca data areas.
id|printf
c_func
(paren
l_string|&quot;Paca: &bslash;n&quot;
)paren
suffix:semicolon
id|ptrPaca
op_assign
id|get_paca
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Control Area (LpPaca): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpPaca
op_assign
id|ptrPaca-&gt;xLpPacaPtr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Srr0=%.16lx  Saved Srr1=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedSrr0
comma
id|ptrLpPaca-&gt;xSavedSrr1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr3=%.16lx  Saved Gpr4=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr3
comma
id|ptrLpPaca-&gt;xSavedGpr4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Gpr5=%.16lx &bslash;n&quot;
comma
id|ptrLpPaca-&gt;xSavedGpr5
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  Local Processor Register Save Area (LpRegSave): &bslash;n&quot;
)paren
suffix:semicolon
id|ptrLpRegSave
op_assign
id|ptrPaca-&gt;xLpRegSavePtr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg0=%.16lx  Saved Sprg1=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG0
comma
id|ptrLpRegSave-&gt;xSPRG0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Sprg2=%.16lx  Saved Sprg3=%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xSPRG2
comma
id|ptrLpRegSave-&gt;xSPRG3
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Saved Msr  =%.16lx  Saved Nia  =%.16lx &bslash;n&quot;
comma
id|ptrLpRegSave-&gt;xMSR
comma
id|ptrLpRegSave-&gt;xNIA
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|regno
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;w&squot;
suffix:colon
id|val
op_assign
id|read_spr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|write_spr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_char|&squot;r&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;spr %lx = %lx&bslash;n&quot;
comma
id|regno
comma
id|read_spr
c_func
(paren
id|regno
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|val
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_msrd
c_func
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scannl
c_func
(paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|mread
id|mread
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|q
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_int
DECL|function|mwrite
id|mwrite
c_func
(paren
r_int
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error writing address %x&bslash;n&quot;
comma
id|adrs
op_plus
id|n
)paren
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|fault_type
r_static
r_int
id|fault_type
suffix:semicolon
DECL|variable|fault_chars
r_static
r_char
op_star
id|fault_chars
(braket
)braket
op_assign
(brace
l_string|&quot;--&quot;
comma
l_string|&quot;**&quot;
comma
l_string|&quot;##&quot;
)brace
suffix:semicolon
r_static
r_int
DECL|function|handle_fault
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_switch
c_cond
(paren
id|regs-&gt;trap
)paren
(brace
r_case
l_int|0x200
suffix:colon
id|fault_type
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x300
suffix:colon
r_case
l_int|0x380
suffix:colon
id|fault_type
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fault_type
op_assign
l_int|2
suffix:semicolon
)brace
m_longjmp
(paren
id|bus_error_jmp
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SWAP
mdefine_line|#define SWAP(a, b, t)&t;((t) = (a), (a) = (b), (b) = (t))
r_void
DECL|function|byterev
id|byterev
c_func
(paren
r_int
r_char
op_star
id|val
comma
r_int
id|size
)paren
(brace
r_int
id|t
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|1
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|3
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|2
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* is there really any use for this? */
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|7
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|6
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|2
)braket
comma
id|val
(braket
l_int|5
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|3
)braket
comma
id|val
(braket
l_int|4
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|brev
r_static
r_int
id|brev
suffix:semicolon
DECL|variable|mnoread
r_static
r_int
id|mnoread
suffix:semicolon
DECL|variable|memex_help_string
r_static
r_char
op_star
id|memex_help_string
op_assign
l_string|&quot;Memory examine command usage:&bslash;n&quot;
l_string|&quot;m [addr] [flags] examine/change memory&bslash;n&quot;
l_string|&quot;  addr is optional.  will start where left off.&bslash;n&quot;
l_string|&quot;  flags may include chars from this set:&bslash;n&quot;
l_string|&quot;    b   modify by bytes (default)&bslash;n&quot;
l_string|&quot;    w   modify by words (2 byte)&bslash;n&quot;
l_string|&quot;    l   modify by longs (4 byte)&bslash;n&quot;
l_string|&quot;    d   modify by doubleword (8 byte)&bslash;n&quot;
l_string|&quot;    r   toggle reverse byte order mode&bslash;n&quot;
l_string|&quot;    n   do not read memory (for i/o spaces)&bslash;n&quot;
l_string|&quot;    .   ok to read (default)&bslash;n&quot;
l_string|&quot;NOTE: flags are saved as defaults&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|memex_subcmd_help_string
r_static
r_char
op_star
id|memex_subcmd_help_string
op_assign
l_string|&quot;Memory examine subcommands:&bslash;n&quot;
l_string|&quot;  hexval   write this val to current location&bslash;n&quot;
l_string|&quot;  &squot;string&squot; write chars from string to this location&bslash;n&quot;
l_string|&quot;  &squot;        increment address&bslash;n&quot;
l_string|&quot;  ^        decrement address&bslash;n&quot;
l_string|&quot;  /        increment addr by 0x10.  //=0x100, ///=0x1000, etc&bslash;n&quot;
l_string|&quot;  &bslash;&bslash;        decrement addr by 0x10.  &bslash;&bslash;&bslash;&bslash;=0x100, &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;=0x1000, etc&bslash;n&quot;
l_string|&quot;  `        clear no-read flag&bslash;n&quot;
l_string|&quot;  ;        stay at this addr&bslash;n&quot;
l_string|&quot;  v        change to byte mode&bslash;n&quot;
l_string|&quot;  w        change to word (2 byte) mode&bslash;n&quot;
l_string|&quot;  l        change to long (4 byte) mode&bslash;n&quot;
l_string|&quot;  u        change to doubleword (8 byte) mode&bslash;n&quot;
l_string|&quot;  m addr   change current addr&bslash;n&quot;
l_string|&quot;  n        toggle no-read flag&bslash;n&quot;
l_string|&quot;  r        toggle byte reverse flag&bslash;n&quot;
l_string|&quot;  &lt; count  back up count bytes&bslash;n&quot;
l_string|&quot;  &gt; count  skip forward count bytes&bslash;n&quot;
l_string|&quot;  x        exit this mode&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
r_void
DECL|function|memex
id|memex
c_func
(paren
)paren
(brace
r_int
id|cmd
comma
id|inc
comma
id|i
comma
id|nslash
suffix:semicolon
r_int
r_int
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|16
)braket
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|printf
c_func
(paren
id|memex_help_string
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|last_cmd
op_assign
l_string|&quot;m&bslash;n&quot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
(brace
id|size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
l_int|8
)paren
(brace
id|size
op_assign
l_int|8
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
id|n
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16x%c&quot;
comma
id|adrs
comma
id|brev
ques
c_cond
l_char|&squot;r&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
(brace
r_if
c_cond
(paren
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|val
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
id|nslash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|n
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
id|inc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|n
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|n
op_assign
id|bsesc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|adrs
op_add_assign
id|size
suffix:semicolon
)brace
id|adrs
op_sub_assign
id|size
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
id|adrs
op_add_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;;&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
r_case
l_char|&squot;v&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
id|adrs
op_sub_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OG
l_int|0
)paren
id|adrs
op_sub_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_add_assign
l_int|4
suffix:semicolon
id|adrs
op_add_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OL
l_int|0
)paren
id|adrs
op_add_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_sub_assign
l_int|4
suffix:semicolon
id|adrs
op_sub_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_add_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|memex_subcmd_help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|adrs
op_add_assign
id|inc
suffix:semicolon
)brace
)brace
r_int
DECL|function|bsesc
id|bsesc
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
r_void
DECL|function|dump
id|dump
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|scanhex
c_func
(paren
op_amp
id|nidump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nidump
op_eq
l_int|0
)paren
(brace
id|nidump
op_assign
l_int|16
suffix:semicolon
)brace
id|adrs
op_add_assign
id|ppc_inst_dump
c_func
(paren
id|adrs
comma
id|nidump
)paren
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;di&bslash;n&quot;
suffix:semicolon
)brace
r_else
(brace
id|scanhex
c_func
(paren
op_amp
id|ndump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndump
op_eq
l_int|0
)paren
(brace
id|ndump
op_assign
l_int|64
suffix:semicolon
)brace
id|prdump
c_func
(paren
id|adrs
comma
id|ndump
)paren
suffix:semicolon
id|adrs
op_add_assign
id|ndump
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;d&bslash;n&quot;
suffix:semicolon
)brace
)brace
r_void
DECL|function|prdump
id|prdump
c_func
(paren
r_int
r_int
id|adrs
comma
r_int
id|ndump
)paren
(brace
r_int
id|n
comma
id|m
comma
id|c
comma
id|r
comma
id|nr
suffix:semicolon
r_int
r_char
id|temp
(braket
l_int|16
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|ndump
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16lx&quot;
comma
id|adrs
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|r
op_assign
id|n
OL
l_int|16
ques
c_cond
id|n
suffix:colon
l_int|16
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|temp
comma
id|r
)paren
suffix:semicolon
id|adrs
op_add_assign
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
(paren
id|m
op_amp
l_int|7
)paren
op_eq
l_int|0
op_logical_and
id|m
OG
l_int|0
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|temp
(braket
id|m
)braket
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  |&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|c
op_assign
id|temp
(braket
id|m
)braket
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;~&squot;
ques
c_cond
id|c
suffix:colon
l_char|&squot;.&squot;
)paren
suffix:semicolon
)brace
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|n
op_sub_assign
id|r
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
id|r
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|ppc_inst_dump
id|ppc_inst_dump
c_func
(paren
r_int
r_int
id|adr
comma
r_int
id|count
)paren
(brace
r_int
id|nr
comma
id|dotted
suffix:semicolon
r_int
r_int
id|first_adr
suffix:semicolon
r_int
r_int
id|inst
comma
id|last_inst
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|dotted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|first_adr
op_assign
id|adr
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
op_decrement
id|count
comma
id|adr
op_add_assign
l_int|4
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|adr
comma
id|val
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
(brace
r_const
r_char
op_star
id|x
op_assign
id|fault_chars
(braket
id|fault_type
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx  %s%s%s%s&bslash;n&quot;
comma
id|adr
comma
id|x
comma
id|x
comma
id|x
comma
id|x
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inst
op_assign
id|GETWORD
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adr
OG
id|first_adr
op_logical_and
id|inst
op_eq
id|last_inst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dotted
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; ...&bslash;n&quot;
)paren
suffix:semicolon
id|dotted
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|dotted
op_assign
l_int|0
suffix:semicolon
id|last_inst
op_assign
id|inst
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.16lx  &quot;
comma
id|adr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;t&quot;
comma
id|inst
)paren
suffix:semicolon
id|print_insn_big_powerpc
c_func
(paren
id|stdout
comma
id|inst
comma
id|adr
)paren
suffix:semicolon
multiline_comment|/* always returns 4 */
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|adr
op_minus
id|first_adr
suffix:semicolon
)brace
r_void
DECL|function|print_address
id|print_address
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_char
op_star
id|modname
suffix:semicolon
r_int
id|size
comma
id|offset
suffix:semicolon
id|name
op_assign
id|kallsyms_lookup
c_func
(paren
id|addr
comma
op_amp
id|size
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|tmpstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|modname
)paren
id|printf
c_func
(paren
l_string|&quot;0x%lx&bslash;t# %s:%s+0x%lx&quot;
comma
id|addr
comma
id|modname
comma
id|name
comma
id|offset
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;0x%lx&bslash;t# %s+0x%lx&quot;
comma
id|addr
comma
id|name
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;0x%lx&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Memory operations - move, set, print differences&n; */
DECL|variable|mdest
r_static
r_int
r_int
id|mdest
suffix:semicolon
multiline_comment|/* destination address */
DECL|variable|msrc
r_static
r_int
r_int
id|msrc
suffix:semicolon
multiline_comment|/* source address */
DECL|variable|mval
r_static
r_int
r_int
id|mval
suffix:semicolon
multiline_comment|/* byte value to set memory to */
DECL|variable|mcount
r_static
r_int
r_int
id|mcount
suffix:semicolon
multiline_comment|/* # bytes to affect */
DECL|variable|mdiffs
r_static
r_int
r_int
id|mdiffs
suffix:semicolon
multiline_comment|/* max # differences to print */
r_void
DECL|function|memops
id|memops
c_func
(paren
r_int
id|cmd
)paren
(brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
ques
c_cond
op_amp
id|mval
suffix:colon
op_amp
id|msrc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mcount
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|memmove
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
(paren
r_void
op_star
)paren
id|msrc
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
id|mval
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdiffs
)paren
suffix:semicolon
id|memdiffs
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mdest
comma
(paren
r_int
r_char
op_star
)paren
id|msrc
comma
id|mcount
comma
id|mdiffs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_void
DECL|function|memdiffs
id|memdiffs
c_func
(paren
r_int
r_char
op_star
id|p1
comma
r_int
r_char
op_star
id|p2
comma
r_int
id|nb
comma
r_int
id|maxpr
)paren
(brace
r_int
id|n
comma
id|prt
suffix:semicolon
id|prt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|nb
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
op_decrement
id|n
)paren
r_if
c_cond
(paren
op_star
id|p1
op_increment
op_ne
op_star
id|p2
op_increment
)paren
r_if
c_cond
(paren
op_increment
id|prt
op_le
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x %.2x # %.16x %.2x&bslash;n&quot;
comma
id|p1
op_minus
l_int|1
comma
id|p1
(braket
op_minus
l_int|1
)braket
comma
id|p2
op_minus
l_int|1
comma
id|p2
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prt
OG
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Total of %d differences&bslash;n&quot;
comma
id|prt
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mend
r_static
r_int
id|mend
suffix:semicolon
DECL|variable|mask
r_static
r_int
id|mask
suffix:semicolon
r_void
DECL|function|memlocate
id|memlocate
c_func
(paren
)paren
(brace
r_int
id|a
comma
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;ml&quot;
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mval
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|mask
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mend
suffix:semicolon
id|a
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|a
comma
id|val
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
(paren
(paren
id|GETWORD
c_func
(paren
id|val
)paren
op_xor
id|mval
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.16x:  %.16x&bslash;n&quot;
comma
id|a
comma
id|GETWORD
c_func
(paren
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|n
op_ge
l_int|10
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|mskip
r_static
r_int
r_int
id|mskip
op_assign
l_int|0x1000
suffix:semicolon
DECL|variable|mlim
r_static
r_int
r_int
id|mlim
op_assign
l_int|0xffffffff
suffix:semicolon
r_void
DECL|function|memzcan
id|memzcan
c_func
(paren
)paren
(brace
r_int
r_char
id|v
suffix:semicolon
r_int
id|a
suffix:semicolon
r_int
id|ok
comma
id|ook
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mskip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mlim
)paren
suffix:semicolon
id|ook
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mlim
suffix:semicolon
id|a
op_add_assign
id|mskip
)paren
(brace
id|ok
op_assign
id|mread
c_func
(paren
id|a
comma
op_amp
id|v
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
op_logical_and
op_logical_neg
id|ook
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x .. &quot;
comma
id|a
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ok
op_logical_and
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
id|ook
op_assign
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|mskip
OL
id|a
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
)brace
multiline_comment|/* Input scanning routines */
r_int
DECL|function|skipbl
id|skipbl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_int|0
)paren
(brace
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|N_PTREGS
mdefine_line|#define N_PTREGS&t;44
DECL|variable|regnames
r_static
r_char
op_star
id|regnames
(braket
id|N_PTREGS
)braket
op_assign
(brace
l_string|&quot;r0&quot;
comma
l_string|&quot;r1&quot;
comma
l_string|&quot;r2&quot;
comma
l_string|&quot;r3&quot;
comma
l_string|&quot;r4&quot;
comma
l_string|&quot;r5&quot;
comma
l_string|&quot;r6&quot;
comma
l_string|&quot;r7&quot;
comma
l_string|&quot;r8&quot;
comma
l_string|&quot;r9&quot;
comma
l_string|&quot;r10&quot;
comma
l_string|&quot;r11&quot;
comma
l_string|&quot;r12&quot;
comma
l_string|&quot;r13&quot;
comma
l_string|&quot;r14&quot;
comma
l_string|&quot;r15&quot;
comma
l_string|&quot;r16&quot;
comma
l_string|&quot;r17&quot;
comma
l_string|&quot;r18&quot;
comma
l_string|&quot;r19&quot;
comma
l_string|&quot;r20&quot;
comma
l_string|&quot;r21&quot;
comma
l_string|&quot;r22&quot;
comma
l_string|&quot;r23&quot;
comma
l_string|&quot;r24&quot;
comma
l_string|&quot;r25&quot;
comma
l_string|&quot;r26&quot;
comma
l_string|&quot;r27&quot;
comma
l_string|&quot;r28&quot;
comma
l_string|&quot;r29&quot;
comma
l_string|&quot;r30&quot;
comma
l_string|&quot;r31&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;msr&quot;
comma
l_string|&quot;or3&quot;
comma
l_string|&quot;ctr&quot;
comma
l_string|&quot;lr&quot;
comma
l_string|&quot;xer&quot;
comma
l_string|&quot;ccr&quot;
comma
l_string|&quot;mq&quot;
comma
l_string|&quot;trap&quot;
comma
l_string|&quot;dar&quot;
comma
l_string|&quot;dsisr&quot;
comma
l_string|&quot;res&quot;
)brace
suffix:semicolon
r_int
DECL|function|scanhex
id|scanhex
c_func
(paren
id|vp
)paren
r_int
r_int
op_star
id|vp
suffix:semicolon
(brace
r_int
id|c
comma
id|d
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;%&squot;
)paren
(brace
multiline_comment|/* parse register name */
r_char
id|regname
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regname
)paren
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isalnum
c_func
(paren
id|c
)paren
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_break
suffix:semicolon
)brace
id|regname
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|regname
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_PTREGS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regnames
(braket
id|i
)braket
comma
id|regname
)paren
op_eq
l_int|0
)paren
(brace
r_int
r_int
op_star
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|xmon_regs
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;regs not available&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|vp
op_assign
id|rp
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;invalid register name &squot;%%%s&squot;&bslash;n&quot;
comma
id|regname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* skip leading &quot;0x&quot; if any */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;x&squot;
)paren
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;$&squot;
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|63
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmpstr
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|tmpstr
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|vp
op_assign
id|kallsyms_lookup_name
c_func
(paren
id|tmpstr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|vp
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;unknown symbol &squot;%s&squot;&bslash;n&quot;
comma
id|tmpstr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
id|EOF
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|v
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|v
op_assign
(paren
id|v
op_lshift
l_int|4
)paren
op_plus
id|d
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
op_ne
id|EOF
)paren
suffix:semicolon
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|vp
op_assign
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|scannl
id|scannl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|hexdigit
id|hexdigit
c_func
(paren
r_int
id|c
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
r_return
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_return
id|EOF
suffix:semicolon
)brace
r_void
DECL|function|getstring
id|getstring
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|size
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|size
OG
l_int|1
)paren
(brace
op_star
id|s
op_increment
op_assign
id|c
suffix:semicolon
op_decrement
id|size
suffix:semicolon
)brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot; &squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|s
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
r_void
DECL|function|flush_input
id|flush_input
c_func
(paren
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|inchar
id|inchar
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|lineptr
op_eq
l_int|NULL
op_logical_or
op_star
id|lineptr
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_eq
l_int|NULL
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|EOF
suffix:semicolon
)brace
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_void
DECL|function|take_input
id|take_input
c_func
(paren
id|str
)paren
r_char
op_star
id|str
suffix:semicolon
(brace
id|lineptr
op_assign
id|str
suffix:semicolon
)brace
r_static
r_void
DECL|function|symbol_lookup
id|symbol_lookup
c_func
(paren
r_void
)paren
(brace
r_int
id|type
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_static
r_char
id|tmp
(braket
l_int|64
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_char|&squot;a&squot;
suffix:colon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|addr
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%lx: &quot;
comma
id|addr
)paren
suffix:semicolon
id|xmon_print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
id|termch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|getstring
c_func
(paren
id|tmp
comma
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|addr
op_assign
id|kallsyms_lookup_name
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|printf
c_func
(paren
l_string|&quot;%s: %lx&bslash;n&quot;
comma
id|tmp
comma
id|addr
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;Symbol &squot;%s&squot; not found.&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* xmon version of __print_symbol */
DECL|function|__xmon_print_symbol
r_void
id|__xmon_print_symbol
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
r_int
r_int
id|address
)paren
(brace
r_char
op_star
id|modname
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|offset
comma
id|size
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|__debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|kallsyms_lookup
c_func
(paren
id|address
comma
op_amp
id|size
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|tmpstr
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
l_string|&quot;symbol lookup failed&quot;
suffix:semicolon
)brace
id|__debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_char
id|addrstr
(braket
r_sizeof
(paren
l_string|&quot;0x%lx&quot;
)paren
op_plus
(paren
id|BITS_PER_LONG
op_star
l_int|3
op_div
l_int|10
)paren
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|addrstr
comma
l_string|&quot;0x%lx&quot;
comma
id|address
)paren
suffix:semicolon
id|printf
c_func
(paren
id|fmt
comma
id|addrstr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|modname
)paren
(brace
multiline_comment|/* This is pretty small. */
r_char
id|buffer
(braket
r_sizeof
(paren
l_string|&quot;%s+%#lx/%#lx [%s]&quot;
)paren
op_plus
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|2
op_star
(paren
id|BITS_PER_LONG
op_star
l_int|3
op_div
l_int|10
)paren
op_plus
id|strlen
c_func
(paren
id|modname
)paren
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s+%#lx/%#lx [%s]&quot;
comma
id|name
comma
id|offset
comma
id|size
comma
id|modname
)paren
suffix:semicolon
id|printf
c_func
(paren
id|fmt
comma
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|buffer
(braket
r_sizeof
(paren
l_string|&quot;%s+%#lx/%#lx&quot;
)paren
op_plus
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|2
op_star
(paren
id|BITS_PER_LONG
op_star
l_int|3
op_div
l_int|10
)paren
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s+%#lx/%#lx&quot;
comma
id|name
comma
id|offset
comma
id|size
)paren
suffix:semicolon
id|printf
c_func
(paren
id|fmt
comma
id|buffer
)paren
suffix:semicolon
)brace
)brace
DECL|function|debug_trace
r_static
r_void
id|debug_trace
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|val
comma
id|cmd
comma
id|on
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* show current state */
r_int
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;naca-&gt;debug_switch = 0x%lx&bslash;n&quot;
comma
id|naca-&gt;debug_switch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PPCDBG_NUM_FLAGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|on
op_assign
id|PPCDBG_BITVAL
c_func
(paren
id|i
)paren
op_amp
id|naca-&gt;debug_switch
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%02x %s %12s   &quot;
comma
id|i
comma
id|on
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
comma
id|trace_names
(braket
id|i
)braket
ques
c_cond
id|trace_names
(braket
id|i
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmd
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|on
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default if no sign given */
r_while
c_loop
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|on
op_assign
(paren
id|cmd
op_eq
l_char|&squot;+&squot;
)paren
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot; &squot;
op_logical_or
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* Turn on or off based on + or - */
id|naca-&gt;debug_switch
op_assign
id|on
ques
c_cond
id|PPCDBG_ALL
suffix:colon
id|PPCDBG_NONE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Setting all values to %s...&bslash;n&quot;
comma
id|on
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
suffix:semicolon
r_else
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
)brace
id|termch
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* not +/- ... let scanhex see it */
id|scanhex
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|64
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Value %x out of range:&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on
)paren
(brace
id|naca-&gt;debug_switch
op_or_assign
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;enable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|naca-&gt;debug_switch
op_and_assign
op_complement
id|PPCDBG_BITVAL
c_func
(paren
id|val
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;disable debug %x %s&bslash;n&quot;
comma
id|val
comma
id|trace_names
(braket
id|val
)braket
ques
c_cond
id|trace_names
(braket
id|val
)braket
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|dump_slb
r_static
r_void
id|dump_slb
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SLB contents of cpu %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naca-&gt;slb_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;slbmfee  %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%02d %016lx &quot;
comma
id|i
comma
id|tmp
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;slbmfev  %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%016lx&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
)brace
DECL|function|dump_stab
r_static
r_void
id|dump_stab
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|tmp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_paca
c_func
(paren
)paren
op_member_access_from_pointer
id|xStab_data.virt
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Segment table contents of cpu %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGE_SIZE
op_div
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
id|tmp
op_increment
suffix:semicolon
id|b
op_assign
op_star
id|tmp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|a
op_logical_or
id|b
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%03d %016lx &quot;
comma
id|i
comma
id|a
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%016lx&bslash;n&quot;
comma
id|b
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|xmon_init
r_void
id|xmon_init
c_func
(paren
r_void
)paren
(brace
id|__debugger
op_assign
id|xmon
suffix:semicolon
id|__debugger_bpt
op_assign
id|xmon_bpt
suffix:semicolon
id|__debugger_sstep
op_assign
id|xmon_sstep
suffix:semicolon
id|__debugger_iabr_match
op_assign
id|xmon_iabr_match
suffix:semicolon
id|__debugger_dabr_match
op_assign
id|xmon_dabr_match
suffix:semicolon
)brace
DECL|function|dump_segments
r_void
id|dump_segments
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cur_cpu_spec-&gt;cpu_features
op_amp
id|CPU_FTR_SLB
)paren
id|dump_slb
c_func
(paren
)paren
suffix:semicolon
r_else
id|dump_stab
c_func
(paren
)paren
suffix:semicolon
)brace
eof
