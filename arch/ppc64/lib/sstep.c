multiline_comment|/*&n; * Single-step support.&n; *&n; * Copyright (C) 2004 Paul Mackerras &lt;paulus@au.ibm.com&gt;, IBM&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/sstep.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
r_extern
r_char
id|system_call_common
(braket
)braket
suffix:semicolon
multiline_comment|/* Bits in SRR1 that are copied from MSR */
DECL|macro|MSR_MASK
mdefine_line|#define MSR_MASK&t;0xffffffff87c0ffff
multiline_comment|/*&n; * Determine whether a conditional branch instruction would branch.&n; */
DECL|function|branch_taken
r_static
r_int
id|branch_taken
c_func
(paren
r_int
r_int
id|instr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|bo
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
r_int
id|bi
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bo
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* decrement counter */
op_decrement
id|regs-&gt;ctr
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|bo
op_rshift
l_int|1
)paren
op_amp
l_int|1
)paren
op_xor
(paren
id|regs-&gt;ctr
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bo
op_amp
l_int|0x10
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check bit from CR */
id|bi
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|regs-&gt;ccr
op_rshift
(paren
l_int|31
op_minus
id|bi
)paren
)paren
op_amp
l_int|1
)paren
op_ne
(paren
(paren
id|bo
op_rshift
l_int|3
)paren
op_amp
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Emulate instructions that cause a transfer of control.&n; * Returns 1 if the step was emulated, 0 if not,&n; * or -1 if the instruction is one that should not be stepped,&n; * such as an rfid, or a mtmsrd that would clear MSR_RI.&n; */
DECL|function|emulate_step
r_int
id|emulate_step
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|instr
)paren
(brace
r_int
r_int
id|opcode
comma
id|rd
suffix:semicolon
r_int
r_int
r_int
id|imm
suffix:semicolon
id|opcode
op_assign
id|instr
op_rshift
l_int|26
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|16
suffix:colon
multiline_comment|/* bc */
id|imm
op_assign
(paren
r_int
r_int
)paren
(paren
id|instr
op_amp
l_int|0xfffc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|imm
op_add_assign
id|regs-&gt;nip
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
id|regs-&gt;nip
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
id|regs-&gt;link
op_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|branch_taken
c_func
(paren
id|instr
comma
id|regs
)paren
)paren
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|17
suffix:colon
multiline_comment|/* sc */
multiline_comment|/*&n;&t;&t; * N.B. this uses knowledge about how the syscall&n;&t;&t; * entry code works.  If that is changed, this will&n;&t;&t; * need to be changed also.&n;&t;&t; */
id|regs-&gt;gpr
(braket
l_int|9
)braket
op_assign
id|regs-&gt;gpr
(braket
l_int|13
)braket
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|11
)braket
op_assign
id|regs-&gt;nip
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|12
)braket
op_assign
id|regs-&gt;msr
op_amp
id|MSR_MASK
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|13
)braket
op_assign
(paren
r_int
r_int
)paren
id|get_paca
c_func
(paren
)paren
suffix:semicolon
id|regs-&gt;nip
op_assign
(paren
r_int
r_int
)paren
op_amp
id|system_call_common
suffix:semicolon
id|regs-&gt;msr
op_assign
id|MSR_KERNEL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|18
suffix:colon
multiline_comment|/* b */
id|imm
op_assign
id|instr
op_amp
l_int|0x03fffffc
suffix:semicolon
r_if
c_cond
(paren
id|imm
op_amp
l_int|0x02000000
)paren
id|imm
op_sub_assign
l_int|0x04000000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|imm
op_add_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
(brace
id|regs-&gt;link
op_assign
id|regs-&gt;nip
op_plus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
id|regs-&gt;link
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
id|imm
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|19
suffix:colon
r_switch
c_cond
(paren
id|instr
op_amp
l_int|0x7fe
)paren
(brace
r_case
l_int|0x20
suffix:colon
multiline_comment|/* bclr */
r_case
l_int|0x420
suffix:colon
multiline_comment|/* bcctr */
id|imm
op_assign
(paren
id|instr
op_amp
l_int|0x400
)paren
ques
c_cond
id|regs-&gt;ctr
suffix:colon
id|regs-&gt;link
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
(brace
id|regs-&gt;nip
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
id|imm
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instr
op_amp
l_int|1
)paren
id|regs-&gt;link
op_assign
id|regs-&gt;nip
suffix:semicolon
r_if
c_cond
(paren
id|branch_taken
c_func
(paren
id|instr
comma
id|regs
)paren
)paren
id|regs-&gt;nip
op_assign
id|imm
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|0x24
suffix:colon
multiline_comment|/* rfid, scary */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_case
l_int|31
suffix:colon
id|rd
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|instr
op_amp
l_int|0x7fe
)paren
(brace
r_case
l_int|0xa6
suffix:colon
multiline_comment|/* mfmsr */
id|regs-&gt;gpr
(braket
id|rd
)braket
op_assign
id|regs-&gt;msr
op_amp
id|MSR_MASK
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;msr
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
id|regs-&gt;nip
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_int|0x164
suffix:colon
multiline_comment|/* mtmsrd */
multiline_comment|/* only MSR_EE and MSR_RI get changed if bit 15 set */
multiline_comment|/* mtmsrd doesn&squot;t change MSR_HV and MSR_ME */
id|imm
op_assign
(paren
id|instr
op_amp
l_int|0x10000
)paren
ques
c_cond
l_int|0x8002
suffix:colon
l_int|0xefffffffffffefffUL
suffix:semicolon
id|imm
op_assign
(paren
id|regs-&gt;msr
op_amp
id|MSR_MASK
op_amp
op_complement
id|imm
)paren
op_or
(paren
id|regs-&gt;gpr
(braket
id|rd
)braket
op_amp
id|imm
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|imm
op_amp
id|MSR_RI
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t step mtmsrd that would clear MSR_RI */
r_return
op_minus
l_int|1
suffix:semicolon
id|regs-&gt;msr
op_assign
id|imm
suffix:semicolon
id|regs-&gt;nip
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|imm
op_amp
id|MSR_SF
)paren
op_eq
l_int|0
)paren
id|regs-&gt;nip
op_and_assign
l_int|0xffffffffUL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
