multiline_comment|/*&n; * Spin and read/write lock operations.&n; *&n; * Copyright (C) 2001-2004 Paul Mackerras &lt;paulus@au.ibm.com&gt;, IBM&n; * Copyright (C) 2001 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM&n; * Copyright (C) 2002 Dave Engebretsen &lt;engebret@us.ibm.com&gt;, IBM&n; *   Rework to support virtual processors&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/stringify.h&gt;
macro_line|#include &lt;asm/hvcall.h&gt;
macro_line|#include &lt;asm/iSeries/HvCall.h&gt;
macro_line|#ifndef CONFIG_SPINLINE
multiline_comment|/*&n; * On a system with shared processors (that is, where a physical&n; * processor is multiplexed between several virtual processors),&n; * there is no point spinning on a lock if the holder of the lock&n; * isn&squot;t currently scheduled on a physical processor.  Instead&n; * we detect this situation and ask the hypervisor to give the&n; * rest of our timeslice to the lock holder.&n; *&n; * So that we can tell which virtual processor is holding a lock,&n; * we put 0x80000000 | smp_processor_id() in the lock when it is&n; * held.  Conveniently, we have a word in the paca that holds this&n; * value.&n; */
multiline_comment|/* waiting for a spinlock... */
macro_line|#if defined(CONFIG_PPC_SPLPAR) || defined(CONFIG_PPC_ISERIES)
multiline_comment|/* We only yield to the hypervisor if we are in shared processor mode */
DECL|macro|SHARED_PROCESSOR
mdefine_line|#define SHARED_PROCESSOR (get_paca()-&gt;lppaca.xSharedProc)
DECL|function|__spin_yield
r_void
id|__spin_yield
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
r_int
id|lock_value
comma
id|holder_cpu
comma
id|yield_count
suffix:semicolon
r_struct
id|paca_struct
op_star
id|holder_paca
suffix:semicolon
id|lock_value
op_assign
id|lock-&gt;lock
suffix:semicolon
r_if
c_cond
(paren
id|lock_value
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|holder_cpu
op_assign
id|lock_value
op_amp
l_int|0xffff
suffix:semicolon
id|BUG_ON
c_func
(paren
id|holder_cpu
op_ge
id|NR_CPUS
)paren
suffix:semicolon
id|holder_paca
op_assign
op_amp
id|paca
(braket
id|holder_cpu
)braket
suffix:semicolon
id|yield_count
op_assign
id|holder_paca-&gt;lppaca.xYieldCount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|yield_count
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* virtual cpu is currently running */
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock-&gt;lock
op_ne
id|lock_value
)paren
r_return
suffix:semicolon
multiline_comment|/* something has changed */
macro_line|#ifdef CONFIG_PPC_ISERIES
id|HvCall2
c_func
(paren
id|HvCallBaseYieldProcessor
comma
id|HvCall_YieldToProc
comma
(paren
(paren
id|u64
)paren
id|holder_cpu
op_lshift
l_int|32
)paren
op_or
id|yield_count
)paren
suffix:semicolon
macro_line|#else
id|plpar_hcall_norets
c_func
(paren
id|H_CONFER
comma
id|holder_cpu
comma
id|yield_count
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* SPLPAR || ISERIES */
DECL|macro|__spin_yield
mdefine_line|#define __spin_yield(x)&t;barrier()
DECL|macro|SHARED_PROCESSOR
mdefine_line|#define SHARED_PROCESSOR&t;0
macro_line|#endif
multiline_comment|/*&n; * This returns the old value in the lock, so we succeeded&n; * in getting the lock if the return value is 0.&n; */
DECL|function|__spin_trylock
r_static
id|__inline__
r_int
r_int
id|__spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
r_int
id|tmp
comma
id|tmp2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&t;lwz&t;&t;%1,%3(13)&t;&t;# __spin_trylock&bslash;n&bslash;&n;1:&t;lwarx&t;&t;%0,0,%2&bslash;n&bslash;&n;&t;cmpwi&t;&t;0,%0,0&bslash;n&bslash;&n;&t;bne-&t;&t;2f&bslash;n&bslash;&n;&t;stwcx.&t;&t;%1,0,%2&bslash;n&bslash;&n;&t;bne-&t;&t;1b&bslash;n&bslash;&n;&t;isync&bslash;n&bslash;&n;2:&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|lock-&gt;lock
)paren
comma
l_string|&quot;i&quot;
(paren
m_offsetof
(paren
r_struct
id|paca_struct
comma
id|lock_token
)paren
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|_raw_spin_trylock
r_int
id|_raw_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_return
id|__spin_trylock
c_func
(paren
id|lock
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|variable|_raw_spin_trylock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_spin_trylock
)paren
suffix:semicolon
DECL|function|_raw_spin_lock
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|__spin_trylock
c_func
(paren
id|lock
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_do
(brace
id|HMT_low
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHARED_PROCESSOR
)paren
id|__spin_yield
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|lock-&gt;lock
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|HMT_medium
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|_raw_spin_lock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_spin_lock
)paren
suffix:semicolon
DECL|function|_raw_spin_lock_flags
r_void
id|_raw_spin_lock_flags
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|flags_dis
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|__spin_trylock
c_func
(paren
id|lock
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|local_save_flags
c_func
(paren
id|flags_dis
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_do
(brace
id|HMT_low
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHARED_PROCESSOR
)paren
id|__spin_yield
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|lock-&gt;lock
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|HMT_medium
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags_dis
)paren
suffix:semicolon
)brace
)brace
DECL|variable|_raw_spin_lock_flags
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_spin_lock_flags
)paren
suffix:semicolon
DECL|function|spin_unlock_wait
r_void
id|spin_unlock_wait
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_while
c_loop
(paren
id|lock-&gt;lock
)paren
(brace
id|HMT_low
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHARED_PROCESSOR
)paren
id|__spin_yield
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
id|HMT_medium
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|spin_unlock_wait
id|EXPORT_SYMBOL
c_func
(paren
id|spin_unlock_wait
)paren
suffix:semicolon
multiline_comment|/*&n; * Waiting for a read lock or a write lock on a rwlock...&n; * This turns out to be the same for read and write locks, since&n; * we only know the holder if it is write-locked.&n; */
macro_line|#if defined(CONFIG_PPC_SPLPAR) || defined(CONFIG_PPC_ISERIES)
DECL|function|__rw_yield
r_void
id|__rw_yield
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
id|lock_value
suffix:semicolon
r_int
r_int
id|holder_cpu
comma
id|yield_count
suffix:semicolon
r_struct
id|paca_struct
op_star
id|holder_paca
suffix:semicolon
id|lock_value
op_assign
id|rw-&gt;lock
suffix:semicolon
r_if
c_cond
(paren
id|lock_value
op_ge
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* no write lock at present */
id|holder_cpu
op_assign
id|lock_value
op_amp
l_int|0xffff
suffix:semicolon
id|BUG_ON
c_func
(paren
id|holder_cpu
op_ge
id|NR_CPUS
)paren
suffix:semicolon
id|holder_paca
op_assign
op_amp
id|paca
(braket
id|holder_cpu
)braket
suffix:semicolon
id|yield_count
op_assign
id|holder_paca-&gt;lppaca.xYieldCount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|yield_count
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* virtual cpu is currently running */
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw-&gt;lock
op_ne
id|lock_value
)paren
r_return
suffix:semicolon
multiline_comment|/* something has changed */
macro_line|#ifdef CONFIG_PPC_ISERIES
id|HvCall2
c_func
(paren
id|HvCallBaseYieldProcessor
comma
id|HvCall_YieldToProc
comma
(paren
(paren
id|u64
)paren
id|holder_cpu
op_lshift
l_int|32
)paren
op_or
id|yield_count
)paren
suffix:semicolon
macro_line|#else
id|plpar_hcall_norets
c_func
(paren
id|H_CONFER
comma
id|holder_cpu
comma
id|yield_count
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* SPLPAR || ISERIES */
DECL|macro|__rw_yield
mdefine_line|#define __rw_yield(x)&t;barrier()
macro_line|#endif
multiline_comment|/*&n; * This returns the old value in the lock + 1,&n; * so we got a read lock if the return value is &gt; 0.&n; */
DECL|function|__read_trylock
r_static
id|__inline__
r_int
id|__read_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;lwarx&t;&t;%0,0,%1&t;&t;# read_trylock&bslash;n&bslash;&n;&t;extsw&t;&t;%0,%0&bslash;n&bslash;&n;&t;addic.&t;&t;%0,%0,1&bslash;n&bslash;&n;&t;ble-&t;&t;2f&bslash;n&bslash;&n;&t;stwcx.&t;&t;%0,0,%1&bslash;n&bslash;&n;&t;bne-&t;&t;1b&bslash;n&bslash;&n;&t;isync&bslash;n&bslash;&n;2:&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;xer&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|_raw_read_trylock
r_int
id|_raw_read_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_return
id|__read_trylock
c_func
(paren
id|rw
)paren
OG
l_int|0
suffix:semicolon
)brace
DECL|variable|_raw_read_trylock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_read_trylock
)paren
suffix:semicolon
DECL|function|_raw_read_lock
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|__read_trylock
c_func
(paren
id|rw
)paren
OG
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_do
(brace
id|HMT_low
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHARED_PROCESSOR
)paren
id|__rw_yield
c_func
(paren
id|rw
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|rw-&gt;lock
OL
l_int|0
)paren
)paren
suffix:semicolon
id|HMT_medium
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|_raw_read_lock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_read_lock
)paren
suffix:semicolon
DECL|function|_raw_read_unlock
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;eieio&t;&t;&t;&t;# read_unlock&bslash;n&bslash;&n;1:&t;lwarx&t;&t;%0,0,%1&bslash;n&bslash;&n;&t;addic&t;&t;%0,%0,-1&bslash;n&bslash;&n;&t;stwcx.&t;&t;%0,0,%1&bslash;n&bslash;&n;&t;bne-&t;&t;1b&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|variable|_raw_read_unlock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_read_unlock
)paren
suffix:semicolon
multiline_comment|/*&n; * This returns the old value in the lock,&n; * so we got the write lock if the return value is 0.&n; */
DECL|function|__write_trylock
r_static
id|__inline__
r_int
id|__write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
id|tmp
comma
id|tmp2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&t;lwz&t;&t;%1,%3(13)&t;# write_trylock&bslash;n&bslash;&n;1:&t;lwarx&t;&t;%0,0,%2&bslash;n&bslash;&n;&t;cmpwi&t;&t;0,%0,0&bslash;n&bslash;&n;&t;bne-&t;&t;2f&bslash;n&bslash;&n;&t;stwcx.&t;&t;%1,0,%2&bslash;n&bslash;&n;&t;bne-&t;&t;1b&bslash;n&bslash;&n;&t;isync&bslash;n&bslash;&n;2:&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
comma
l_string|&quot;i&quot;
(paren
m_offsetof
(paren
r_struct
id|paca_struct
comma
id|lock_token
)paren
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|_raw_write_trylock
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_return
id|__write_trylock
c_func
(paren
id|rw
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|variable|_raw_write_trylock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_write_trylock
)paren
suffix:semicolon
DECL|function|_raw_write_lock
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|__write_trylock
c_func
(paren
id|rw
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_do
(brace
id|HMT_low
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHARED_PROCESSOR
)paren
id|__rw_yield
c_func
(paren
id|rw
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|rw-&gt;lock
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|HMT_medium
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|_raw_write_lock
id|EXPORT_SYMBOL
c_func
(paren
id|_raw_write_lock
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SPINLINE */
eof
