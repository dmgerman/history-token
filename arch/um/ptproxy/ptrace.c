multiline_comment|/**********************************************************************&n;ptrace.c&n;&n;Copyright (C) 1999 Lars Brinkhoff.  See the file COPYING for licensing&n;terms and conditions.&n;&n;Jeff Dike (jdike@karaya.com) : Modified for integration into uml&n;**********************************************************************/
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;signal.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/time.h&gt;
macro_line|#include &lt;sys/ptrace.h&gt;
macro_line|#include &lt;sys/wait.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &quot;ptproxy.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;kern_util.h&quot;
macro_line|#include &quot;ptrace_user.h&quot;
DECL|function|proxy_ptrace
r_int
id|proxy_ptrace
c_func
(paren
r_struct
id|debugger
op_star
id|debugger
comma
r_int
id|arg1
comma
id|pid_t
id|arg2
comma
r_int
id|arg3
comma
r_int
id|arg4
comma
id|pid_t
id|child
comma
r_int
op_star
id|ret
)paren
(brace
id|sigset_t
id|relay
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debugger-&gt;debugee-&gt;died
)paren
(brace
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|arg1
)paren
(brace
r_case
id|PTRACE_ATTACH
suffix:colon
r_if
c_cond
(paren
id|debugger-&gt;debugee-&gt;traced
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|debugger-&gt;debugee-&gt;pid
op_assign
id|arg2
suffix:semicolon
id|debugger-&gt;debugee-&gt;traced
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|is_valid_pid
c_func
(paren
id|arg2
)paren
op_logical_and
(paren
id|arg2
op_ne
id|child
)paren
)paren
(brace
id|debugger-&gt;debugee-&gt;in_context
op_assign
l_int|0
suffix:semicolon
id|kill
c_func
(paren
id|arg2
comma
id|SIGSTOP
)paren
suffix:semicolon
id|debugger-&gt;debugee-&gt;event
op_assign
l_int|1
suffix:semicolon
id|debugger-&gt;debugee-&gt;wait_status
op_assign
id|W_STOPCODE
c_func
(paren
id|SIGSTOP
)paren
suffix:semicolon
)brace
r_else
(brace
id|debugger-&gt;debugee-&gt;in_context
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|debugger-&gt;debugee-&gt;stopped
)paren
(brace
id|child_proxy
c_func
(paren
id|child
comma
id|W_STOPCODE
c_func
(paren
id|SIGSTOP
)paren
)paren
suffix:semicolon
)brace
r_else
id|kill
c_func
(paren
id|child
comma
id|SIGSTOP
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|PTRACE_DETACH
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|debugger-&gt;debugee-&gt;traced
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|debugger-&gt;debugee-&gt;traced
op_assign
l_int|0
suffix:semicolon
id|debugger-&gt;debugee-&gt;pid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|debugger-&gt;debugee-&gt;in_context
)paren
(brace
id|kill
c_func
(paren
id|child
comma
id|SIGCONT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|PTRACE_CONT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|debugger-&gt;debugee-&gt;in_context
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
op_star
id|ret
op_assign
id|PTRACE_CONT
suffix:semicolon
r_return
id|ptrace
c_func
(paren
id|PTRACE_CONT
comma
id|child
comma
id|arg3
comma
id|arg4
)paren
suffix:semicolon
macro_line|#ifdef UM_HAVE_GETFPREGS
r_case
id|PTRACE_GETFPREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FP_FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
comma
id|result
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_GETFPREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|ptrace
c_func
(paren
id|PTRACE_POKEDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
id|regs
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef UM_HAVE_GETFPXREGS
r_case
id|PTRACE_GETFPXREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FPX_FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
comma
id|result
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_GETFPXREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|ptrace
c_func
(paren
id|PTRACE_POKEDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
id|regs
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef UM_HAVE_GETREGS
r_case
id|PTRACE_GETREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
comma
id|result
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_GETREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|ptrace
(paren
id|PTRACE_POKEDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
id|regs
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|PTRACE_KILL
suffix:colon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_KILL
comma
id|child
comma
id|arg3
comma
id|arg4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
r_case
id|PTRACE_PEEKDATA
suffix:colon
r_case
id|PTRACE_PEEKTEXT
suffix:colon
r_case
id|PTRACE_PEEKUSER
suffix:colon
multiline_comment|/* The value being read out could be -1, so we have to &n;&t;&t; * check errno to see if there&squot;s an error, and zero it&n;&t;&t; * beforehand so we&squot;re not faked out by an old error&n;&t;&t; */
id|errno
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|arg1
comma
id|child
comma
id|arg3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|errno
op_ne
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_POKEDATA
comma
id|debugger-&gt;pid
comma
id|arg4
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
r_case
id|PTRACE_POKEDATA
suffix:colon
r_case
id|PTRACE_POKETEXT
suffix:colon
r_case
id|PTRACE_POKEUSER
suffix:colon
id|result
op_assign
id|ptrace
c_func
(paren
id|arg1
comma
id|child
comma
id|arg3
comma
id|arg4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg1
op_eq
id|PTRACE_POKEUSER
)paren
(brace
id|ptrace_pokeuser
c_func
(paren
id|arg3
comma
id|arg4
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
macro_line|#ifdef UM_HAVE_SETFPREGS
r_case
id|PTRACE_SETFPREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FP_FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|regs
(braket
id|i
)braket
op_assign
id|ptrace
(paren
id|PTRACE_PEEKDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_SETFPREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef UM_HAVE_SETFPXREGS
r_case
id|PTRACE_SETFPXREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FPX_FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|regs
(braket
id|i
)braket
op_assign
id|ptrace
(paren
id|PTRACE_PEEKDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_SETFPXREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef UM_HAVE_SETREGS
r_case
id|PTRACE_SETREGS
suffix:colon
(brace
r_int
id|regs
(braket
id|FRAME_SIZE
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|regs
)paren
op_div
r_sizeof
(paren
id|regs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|regs
(braket
id|i
)braket
op_assign
id|ptrace
c_func
(paren
id|PTRACE_PEEKDATA
comma
id|debugger-&gt;pid
comma
id|arg4
op_plus
l_int|4
op_star
id|i
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_SETREGS
comma
id|child
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
r_case
id|PTRACE_SINGLESTEP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|debugger-&gt;debugee-&gt;in_context
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|sigemptyset
c_func
(paren
op_amp
id|relay
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|relay
comma
id|SIGSEGV
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|relay
comma
id|SIGILL
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|relay
comma
id|SIGBUS
)paren
suffix:semicolon
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_SINGLESTEP
comma
id|child
comma
id|arg3
comma
id|arg4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
id|status
op_assign
id|wait_for_stop
c_func
(paren
id|child
comma
id|SIGTRAP
comma
id|PTRACE_SINGLESTEP
comma
op_amp
id|relay
)paren
suffix:semicolon
id|child_proxy
c_func
(paren
id|child
comma
id|status
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
r_case
id|PTRACE_SYSCALL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|debugger-&gt;debugee-&gt;in_context
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|result
op_assign
id|ptrace
c_func
(paren
id|PTRACE_SYSCALL
comma
id|child
comma
id|arg3
comma
id|arg4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
op_star
id|ret
op_assign
id|PTRACE_SYSCALL
suffix:semicolon
r_return
id|result
suffix:semicolon
r_case
id|PTRACE_TRACEME
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
