multiline_comment|/* &n; * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#include &quot;linux/init.h&quot;
macro_line|#include &quot;linux/ctype.h&quot;
macro_line|#include &quot;linux/proc_fs.h&quot;
macro_line|#include &quot;asm/uaccess.h&quot;
multiline_comment|/* If read and write race, the read will still atomically read a valid&n; * value.&n; */
DECL|variable|uml_exitcode
r_int
id|uml_exitcode
op_assign
l_int|0
suffix:semicolon
DECL|function|read_proc_exitcode
r_static
r_int
id|read_proc_exitcode
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|uml_exitcode
)paren
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
(brace
id|len
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|write_proc_exitcode
r_static
r_int
id|write_proc_exitcode
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|end
comma
id|buf
(braket
r_sizeof
(paren
l_string|&quot;nnnnn&bslash;0&quot;
)paren
)braket
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|buffer
comma
id|count
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|tmp
op_assign
id|simple_strtol
c_func
(paren
id|buf
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|end
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|end
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|uml_exitcode
op_assign
id|tmp
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|make_proc_exitcode
r_static
r_int
id|make_proc_exitcode
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;exitcode&quot;
comma
l_int|0600
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;make_proc_exitcode : Failed to register &quot;
l_string|&quot;/proc/exitcode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ent-&gt;read_proc
op_assign
id|read_proc_exitcode
suffix:semicolon
id|ent-&gt;write_proc
op_assign
id|write_proc_exitcode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|make_proc_exitcode
id|__initcall
c_func
(paren
id|make_proc_exitcode
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
