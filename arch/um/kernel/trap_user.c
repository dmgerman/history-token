multiline_comment|/* &n; * Copyright (C) 2000, 2001, 2002 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;signal.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;sched.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;setjmp.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/ptrace.h&gt;
macro_line|#include &lt;sys/time.h&gt;
macro_line|#include &lt;sys/wait.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/ioctl.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;kern_util.h&quot;
macro_line|#include &quot;signal_user.h&quot;
macro_line|#include &quot;mem_user.h&quot;
macro_line|#include &quot;user.h&quot;
macro_line|#include &quot;process.h&quot;
macro_line|#include &quot;sigcontext.h&quot;
macro_line|#include &quot;sysdep/sigcontext.h&quot;
macro_line|#include &quot;init.h&quot;
macro_line|#include &quot;chan_user.h&quot;
macro_line|#include &quot;irq_user.h&quot;
macro_line|#include &quot;frame_user.h&quot;
macro_line|#include &quot;syscall_user.h&quot;
macro_line|#include &quot;ptrace_user.h&quot;
macro_line|#include &quot;task.h&quot;
macro_line|#include &quot;os.h&quot;
DECL|function|signal_segv
r_static
r_void
id|signal_segv
c_func
(paren
r_int
id|sig
)paren
(brace
id|write
c_func
(paren
l_int|2
comma
l_string|&quot;Seg fault in signals&bslash;n&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;Seg fault in signals&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|detach
r_int
id|detach
c_func
(paren
r_int
id|pid
comma
r_int
id|sig
)paren
(brace
r_return
id|ptrace
c_func
(paren
id|PTRACE_DETACH
comma
id|pid
comma
l_int|0
comma
id|sig
)paren
suffix:semicolon
)brace
DECL|function|attach
r_int
id|attach
c_func
(paren
r_int
id|pid
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|ptrace
c_func
(paren
id|PTRACE_ATTACH
comma
id|pid
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_else
r_return
id|err
suffix:semicolon
)brace
DECL|function|cont
r_int
id|cont
c_func
(paren
r_int
id|pid
)paren
(brace
r_return
id|ptrace
c_func
(paren
id|PTRACE_CONT
comma
id|pid
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|kill_child_dead
r_void
id|kill_child_dead
c_func
(paren
r_int
id|pid
)paren
(brace
id|kill
c_func
(paren
id|pid
comma
id|SIGKILL
)paren
suffix:semicolon
id|kill
c_func
(paren
id|pid
comma
id|SIGCONT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|waitpid
c_func
(paren
id|pid
comma
l_int|NULL
comma
l_int|0
)paren
OG
l_int|0
)paren
(brace
id|kill
c_func
(paren
id|pid
comma
id|SIGCONT
)paren
suffix:semicolon
)brace
)brace
DECL|variable|debug
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|debug_stop
r_int
id|debug_stop
op_assign
l_int|1
suffix:semicolon
DECL|variable|debug_parent
r_int
id|debug_parent
op_assign
l_int|0
suffix:semicolon
DECL|variable|honeypot
r_int
id|honeypot
op_assign
l_int|0
suffix:semicolon
DECL|function|signal_tramp
r_static
r_int
id|signal_tramp
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_int
(paren
op_star
id|proc
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|honeypot
op_logical_and
id|munmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|host_task_size
op_minus
l_int|0x10000000
)paren
comma
l_int|0x10000000
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Unmapping stack failed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptrace
c_func
(paren
id|PTRACE_TRACEME
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;ptrace PTRACE_TRACEME failed&quot;
)paren
suffix:semicolon
)brace
id|os_stop_process
c_func
(paren
id|os_getpid
c_func
(paren
)paren
)paren
suffix:semicolon
id|change_sig
c_func
(paren
id|SIGWINCH
comma
l_int|0
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGUSR1
comma
id|SIG_IGN
)paren
suffix:semicolon
id|change_sig
c_func
(paren
id|SIGCHLD
comma
l_int|0
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGSEGV
comma
(paren
id|__sighandler_t
)paren
id|sig_handler
)paren
suffix:semicolon
id|set_timers
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_cmdline
c_func
(paren
l_string|&quot;(idle thread)&quot;
)paren
suffix:semicolon
id|set_init_pid
c_func
(paren
id|os_getpid
c_func
(paren
)paren
)paren
suffix:semicolon
id|proc
op_assign
id|arg
suffix:semicolon
r_return
(paren
op_star
id|proc
)paren
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|last_ditch_exit
r_static
r_void
id|last_ditch_exit
c_func
(paren
r_int
id|sig
)paren
(brace
id|signal
c_func
(paren
id|SIGINT
comma
id|SIG_DFL
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGTERM
comma
id|SIG_DFL
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGHUP
comma
id|SIG_DFL
)paren
suffix:semicolon
id|uml_cleanup
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sleeping_process_signal
r_static
r_void
id|sleeping_process_signal
c_func
(paren
r_int
id|pid
comma
r_int
id|sig
)paren
(brace
r_switch
c_cond
(paren
id|sig
)paren
(brace
multiline_comment|/* These two result from UML being ^Z-ed and bg-ed.  PTRACE_CONT is&n;&t; * right because the process must be in the kernel already.&n;&t; */
r_case
id|SIGCONT
suffix:colon
r_case
id|SIGTSTP
suffix:colon
r_if
c_cond
(paren
id|ptrace
c_func
(paren
id|PTRACE_CONT
comma
id|pid
comma
l_int|0
comma
id|sig
)paren
OL
l_int|0
)paren
(brace
id|tracer_panic
c_func
(paren
l_string|&quot;sleeping_process_signal : Failed to &quot;
l_string|&quot;continue pid %d, errno = %d&bslash;n&quot;
comma
id|pid
comma
id|sig
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* This happens when the debugger (e.g. strace) is doing system call &n;&t; * tracing on the kernel.  During a context switch, the current task&n;&t; * will be set to the incoming process and the outgoing process will&n;&t; * hop into write and then read.  Since it&squot;s not the current process&n;&t; * any more, the trace of those will land here.  So, we need to just &n;&t; * PTRACE_SYSCALL it.&n;&t; */
r_case
id|SIGTRAP
suffix:colon
r_if
c_cond
(paren
id|ptrace
c_func
(paren
id|PTRACE_SYSCALL
comma
id|pid
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|tracer_panic
c_func
(paren
l_string|&quot;sleeping_process_signal : Failed to &quot;
l_string|&quot;PTRACE_SYSCALL pid %d, errno = %d&bslash;n&quot;
comma
id|pid
comma
id|sig
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIGSTOP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|tracer_panic
c_func
(paren
l_string|&quot;sleeping process %d got unexpected &quot;
l_string|&quot;signal : %d&bslash;n&quot;
comma
id|pid
comma
id|sig
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
macro_line|#error need to make these arrays
macro_line|#endif
DECL|variable|debugger_pid
r_int
id|debugger_pid
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|debugger_parent
r_int
id|debugger_parent
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|debugger_fd
r_int
id|debugger_fd
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|gdb_pid
r_int
id|gdb_pid
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|is_write
r_int
id|is_write
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|sp
r_int
r_int
id|sp
suffix:semicolon
DECL|member|is_user
r_int
id|is_user
suffix:semicolon
DECL|variable|segfault_record
)brace
id|segfault_record
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|segfault_index
r_int
id|segfault_index
op_assign
l_int|0
suffix:semicolon
r_struct
(brace
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|signal
r_int
id|signal
suffix:semicolon
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
DECL|member|time
r_struct
id|timeval
id|time
suffix:semicolon
DECL|variable|signal_record
)brace
id|signal_record
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|signal_index
r_int
id|signal_index
op_assign
l_int|0
suffix:semicolon
DECL|variable|nsignals
r_int
id|nsignals
op_assign
l_int|0
suffix:semicolon
DECL|variable|debug_trace
r_int
id|debug_trace
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|io_nsignals
comma
id|io_count
comma
id|intr_count
suffix:semicolon
r_extern
r_void
id|signal_usr1
c_func
(paren
r_int
id|sig
)paren
suffix:semicolon
DECL|variable|tracing_pid
r_int
id|tracing_pid
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|function|signals
r_int
id|signals
c_func
(paren
r_int
(paren
op_star
id|init_proc
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|sp
)paren
(brace
r_void
op_star
id|task
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|eip
op_assign
l_int|0
suffix:semicolon
r_int
id|status
comma
id|pid
op_assign
l_int|0
comma
id|sig
op_assign
l_int|0
comma
id|cont_type
comma
id|tracing
op_assign
l_int|0
comma
id|op
op_assign
l_int|0
suffix:semicolon
r_int
id|last_index
comma
id|proc_id
op_assign
l_int|0
comma
id|n
comma
id|err
comma
id|old_tracing
op_assign
l_int|0
comma
id|strace
op_assign
l_int|0
suffix:semicolon
id|capture_signal_stack
c_func
(paren
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGPIPE
comma
id|SIG_IGN
)paren
suffix:semicolon
id|setup_tracer_winch
c_func
(paren
)paren
suffix:semicolon
id|tracing_pid
op_assign
id|os_getpid
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;tracing thread pid = %d&bslash;n&quot;
comma
id|tracing_pid
)paren
suffix:semicolon
id|pid
op_assign
id|clone
c_func
(paren
id|signal_tramp
comma
id|sp
comma
id|CLONE_FILES
op_or
id|SIGCHLD
comma
id|init_proc
)paren
suffix:semicolon
id|n
op_assign
id|waitpid
c_func
(paren
id|pid
comma
op_amp
id|status
comma
id|WUNTRACED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;waitpid on idle thread failed, errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ptrace
c_func
(paren
id|PTRACE_CONT
comma
id|pid
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Failed to continue idle thread, errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|signal
c_func
(paren
id|SIGSEGV
comma
id|signal_segv
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGUSR1
comma
id|signal_usr1
)paren
suffix:semicolon
id|set_handler
c_func
(paren
id|SIGINT
comma
id|last_ditch_exit
comma
id|SA_ONESHOT
op_or
id|SA_NODEFER
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|set_handler
c_func
(paren
id|SIGTERM
comma
id|last_ditch_exit
comma
id|SA_ONESHOT
op_or
id|SA_NODEFER
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|set_handler
c_func
(paren
id|SIGHUP
comma
id|last_ditch_exit
comma
id|SA_ONESHOT
op_or
id|SA_NODEFER
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_trace
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Tracing thread pausing to be attached&bslash;n&quot;
)paren
suffix:semicolon
id|stop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
r_if
c_cond
(paren
id|gdb_pid
op_ne
op_minus
l_int|1
)paren
(brace
id|debugger_pid
op_assign
id|attach_debugger
c_func
(paren
id|pid
comma
id|gdb_pid
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|debugger_pid
op_assign
id|init_ptrace_proxy
c_func
(paren
id|pid
comma
l_int|1
comma
id|debug_stop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_parent
)paren
(brace
id|debugger_parent
op_assign
id|os_process_parent
c_func
(paren
id|debugger_pid
)paren
suffix:semicolon
id|init_parent_proxy
c_func
(paren
id|debugger_parent
)paren
suffix:semicolon
id|err
op_assign
id|attach
c_func
(paren
id|debugger_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to attach debugger parent %d, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|debugger_parent
comma
id|err
)paren
suffix:semicolon
id|debugger_parent
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ptrace
c_func
(paren
id|PTRACE_SYSCALL
comma
id|debugger_parent
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to continue debugger &quot;
l_string|&quot;parent, errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
id|debugger_parent
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
id|set_cmdline
c_func
(paren
l_string|&quot;(tracing thread)&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|pid
op_assign
id|waitpid
c_func
(paren
op_minus
l_int|1
comma
op_amp
id|status
comma
id|WUNTRACED
)paren
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|ECHILD
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait failed - errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pid
op_eq
id|debugger_pid
)paren
(brace
r_int
id|cont
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|WIFEXITED
c_func
(paren
id|status
)paren
op_logical_or
id|WIFSIGNALED
c_func
(paren
id|status
)paren
)paren
(brace
id|debugger_pid
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX Figure out how to deal with gdb and SMP */
r_else
id|cont
op_assign
id|debugger_signal
c_func
(paren
id|status
comma
id|cpu_tasks
(braket
l_int|0
)braket
dot
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cont
op_eq
id|PTRACE_SYSCALL
)paren
(brace
id|strace
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pid
op_eq
id|debugger_parent
)paren
(brace
id|debugger_parent_signal
c_func
(paren
id|status
comma
id|pid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nsignals
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|WIFEXITED
c_func
(paren
id|status
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#ifdef notdef
(brace
id|printk
c_func
(paren
l_string|&quot;Child %d exited with status %d&bslash;n&quot;
comma
id|pid
comma
id|WEXITSTATUS
c_func
(paren
id|status
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_else
r_if
c_cond
(paren
id|WIFSIGNALED
c_func
(paren
id|status
)paren
)paren
(brace
id|sig
op_assign
id|WTERMSIG
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sig
op_ne
l_int|9
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Child %d exited with signal %d&bslash;n&quot;
comma
id|pid
comma
id|sig
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|WIFSTOPPED
c_func
(paren
id|status
)paren
)paren
(brace
id|sig
op_assign
id|WSTOPSIG
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_index
op_eq
l_int|1024
)paren
(brace
id|signal_index
op_assign
l_int|0
suffix:semicolon
id|last_index
op_assign
l_int|1023
suffix:semicolon
)brace
r_else
id|last_index
op_assign
id|signal_index
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|sig
op_eq
id|SIGPROF
)paren
op_logical_or
(paren
id|sig
op_eq
id|SIGVTALRM
)paren
op_logical_or
(paren
id|sig
op_eq
id|SIGALRM
)paren
)paren
op_logical_and
(paren
id|signal_record
(braket
id|last_index
)braket
dot
id|signal
op_eq
id|sig
)paren
op_logical_and
(paren
id|signal_record
(braket
id|last_index
)braket
dot
id|pid
op_eq
id|pid
)paren
)paren
(brace
id|signal_index
op_assign
id|last_index
suffix:semicolon
)brace
id|signal_record
(braket
id|signal_index
)braket
dot
id|pid
op_assign
id|pid
suffix:semicolon
id|gettimeofday
c_func
(paren
op_amp
id|signal_record
(braket
id|signal_index
)braket
dot
id|time
comma
l_int|NULL
)paren
suffix:semicolon
id|eip
op_assign
id|ptrace
c_func
(paren
id|PTRACE_PEEKUSER
comma
id|pid
comma
id|PT_IP_OFFSET
comma
l_int|0
)paren
suffix:semicolon
id|signal_record
(braket
id|signal_index
)braket
dot
id|addr
op_assign
id|eip
suffix:semicolon
id|signal_record
(braket
id|signal_index
op_increment
)braket
dot
id|signal
op_assign
id|sig
suffix:semicolon
id|proc_id
op_assign
id|pid_to_processor_id
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_id
op_eq
op_minus
l_int|1
)paren
(brace
id|sleeping_process_signal
c_func
(paren
id|pid
comma
id|sig
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|task
op_assign
id|cpu_tasks
(braket
id|proc_id
)braket
dot
id|task
suffix:semicolon
id|tracing
op_assign
id|is_tracing
c_func
(paren
id|task
)paren
suffix:semicolon
id|old_tracing
op_assign
id|tracing
suffix:semicolon
r_switch
c_cond
(paren
id|sig
)paren
(brace
r_case
id|SIGUSR1
suffix:colon
id|sig
op_assign
l_int|0
suffix:semicolon
id|op
op_assign
id|do_proc_op
c_func
(paren
id|task
comma
id|proc_id
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|OP_TRACE_ON
suffix:colon
id|arch_leave_kernel
c_func
(paren
id|task
comma
id|pid
)paren
suffix:semicolon
id|tracing
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_REBOOT
suffix:colon
r_case
id|OP_HALT
suffix:colon
id|unmap_physmem
c_func
(paren
)paren
suffix:semicolon
id|kmalloc_ok
op_assign
l_int|0
suffix:semicolon
id|ptrace
c_func
(paren
id|PTRACE_KILL
comma
id|pid
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|op
op_eq
id|OP_REBOOT
suffix:semicolon
r_case
id|OP_NONE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detaching pid %d&bslash;n&quot;
comma
id|pid
)paren
suffix:semicolon
id|detach
c_func
(paren
id|pid
comma
id|SIGSTOP
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* OP_EXEC switches host processes on us,&n;&t;&t;&t;&t; * we want to continue the new one.&n;&t;&t;&t;&t; */
id|pid
op_assign
id|cpu_tasks
(braket
id|proc_id
)braket
dot
id|pid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGTRAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tracing
op_logical_and
(paren
id|debugger_pid
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|child_signal
c_func
(paren
id|pid
comma
id|status
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tracing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|do_syscall
c_func
(paren
id|task
comma
id|pid
)paren
)paren
(brace
id|sig
op_assign
id|SIGUSR2
suffix:semicolon
)brace
r_else
id|clear_singlestep
c_func
(paren
id|task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGPROF
suffix:colon
r_if
c_cond
(paren
id|tracing
)paren
(brace
id|sig
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIGCHLD
suffix:colon
r_case
id|SIGHUP
suffix:colon
id|sig
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGSEGV
suffix:colon
r_case
id|SIGIO
suffix:colon
r_case
id|SIGALRM
suffix:colon
r_case
id|SIGVTALRM
suffix:colon
r_case
id|SIGFPE
suffix:colon
r_case
id|SIGBUS
suffix:colon
r_case
id|SIGILL
suffix:colon
r_case
id|SIGWINCH
suffix:colon
r_default
suffix:colon
id|tracing
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_tracing
c_func
(paren
id|task
comma
id|tracing
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tracing
op_logical_and
id|old_tracing
)paren
(brace
id|arch_enter_kernel
c_func
(paren
id|task
comma
id|pid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tracing
op_logical_and
(paren
id|debugger_pid
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|sig
op_ne
l_int|0
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGALRM
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGVTALRM
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGSEGV
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGTRAP
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGUSR2
)paren
op_logical_and
(paren
id|sig
op_ne
id|SIGIO
)paren
)paren
(brace
id|child_signal
c_func
(paren
id|pid
comma
id|status
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tracing
)paren
(brace
r_if
c_cond
(paren
id|singlestepping
c_func
(paren
id|task
)paren
)paren
(brace
id|cont_type
op_assign
id|PTRACE_SINGLESTEP
suffix:semicolon
)brace
r_else
id|cont_type
op_assign
id|PTRACE_SYSCALL
suffix:semicolon
)brace
r_else
id|cont_type
op_assign
id|PTRACE_CONT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cont_type
op_eq
id|PTRACE_CONT
)paren
op_logical_and
(paren
id|debugger_pid
op_ne
op_minus
l_int|1
)paren
op_logical_and
id|strace
)paren
(brace
id|cont_type
op_assign
id|PTRACE_SYSCALL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptrace
c_func
(paren
id|cont_type
comma
id|pid
comma
l_int|0
comma
id|sig
)paren
op_ne
l_int|0
)paren
(brace
id|tracer_panic
c_func
(paren
l_string|&quot;ptrace failed to continue &quot;
l_string|&quot;process - errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uml_debugtrace_setup
r_static
r_int
id|__init
id|uml_debugtrace_setup
c_func
(paren
r_char
op_star
id|line
comma
r_int
op_star
id|add
)paren
(brace
id|debug_trace
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;debugtrace&quot;
comma
id|uml_debugtrace_setup
comma
l_string|&quot;debugtrace&bslash;n&quot;
l_string|&quot;    Causes the tracing thread to pause until it is attached by a&bslash;n&quot;
l_string|&quot;    debugger and continued.  This is mostly for debugging crashes&bslash;n&quot;
l_string|&quot;    early during boot, and should be pretty much obsoleted by&bslash;n&quot;
l_string|&quot;    the debug switch.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
DECL|function|uml_honeypot_setup
r_static
r_int
id|__init
id|uml_honeypot_setup
c_func
(paren
r_char
op_star
id|line
comma
r_int
op_star
id|add
)paren
(brace
id|jail_setup
c_func
(paren
l_string|&quot;&quot;
comma
id|add
)paren
suffix:semicolon
id|honeypot
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;honeypot&quot;
comma
id|uml_honeypot_setup
comma
l_string|&quot;honeypot&bslash;n&quot;
l_string|&quot;    This makes UML put process stacks in the same location as they are&bslash;n&quot;
l_string|&quot;    on the host, allowing expoits such as stack smashes to work against&bslash;n&quot;
l_string|&quot;    UML.  This implies &squot;jail&squot;.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|nsegfaults
r_int
id|nsegfaults
op_assign
l_int|0
suffix:semicolon
DECL|function|segv_handler
r_void
id|segv_handler
c_func
(paren
r_int
id|sig
comma
r_struct
id|uml_pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|sigcontext_struct
op_star
id|context
op_assign
id|regs-&gt;sc
suffix:semicolon
r_int
id|index
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;is_user
op_logical_and
op_logical_neg
id|SEGV_IS_FIXABLE
c_func
(paren
id|context
)paren
)paren
(brace
id|bad_segv
c_func
(paren
id|SC_FAULT_ADDR
c_func
(paren
id|context
)paren
comma
id|SC_IP
c_func
(paren
id|context
)paren
comma
id|SC_FAULT_WRITE
c_func
(paren
id|context
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock_trap
c_func
(paren
)paren
suffix:semicolon
id|index
op_assign
id|segfault_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|segfault_index
op_eq
l_int|1024
)paren
(brace
id|segfault_index
op_assign
l_int|0
suffix:semicolon
)brace
id|unlock_trap
c_func
(paren
)paren
suffix:semicolon
id|nsegfaults
op_increment
suffix:semicolon
id|segfault_record
(braket
id|index
)braket
dot
id|address
op_assign
id|SC_FAULT_ADDR
c_func
(paren
id|context
)paren
suffix:semicolon
id|segfault_record
(braket
id|index
)braket
dot
id|pid
op_assign
id|os_getpid
c_func
(paren
)paren
suffix:semicolon
id|segfault_record
(braket
id|index
)braket
dot
id|is_write
op_assign
id|SC_FAULT_WRITE
c_func
(paren
id|context
)paren
suffix:semicolon
id|segfault_record
(braket
id|index
)braket
dot
id|sp
op_assign
id|SC_SP
c_func
(paren
id|context
)paren
suffix:semicolon
id|segfault_record
(braket
id|index
)braket
dot
id|is_user
op_assign
id|regs-&gt;is_user
suffix:semicolon
id|segv
c_func
(paren
id|SC_FAULT_ADDR
c_func
(paren
id|context
)paren
comma
id|SC_IP
c_func
(paren
id|context
)paren
comma
id|SC_FAULT_WRITE
c_func
(paren
id|context
)paren
comma
id|regs-&gt;is_user
comma
id|context
)paren
suffix:semicolon
)brace
r_extern
r_int
id|kern_timer_on
suffix:semicolon
DECL|struct|signal_info
r_struct
id|signal_info
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_struct
id|uml_pt_regs
op_star
)paren
suffix:semicolon
DECL|member|is_irq
r_int
id|is_irq
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|sig_info
r_static
r_struct
id|signal_info
id|sig_info
(braket
)braket
op_assign
(brace
(braket
id|SIGTRAP
)braket
(brace
id|handler
suffix:colon
id|relay_signal
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
(braket
id|SIGFPE
)braket
(brace
id|handler
suffix:colon
id|relay_signal
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
(braket
id|SIGILL
)braket
(brace
id|handler
suffix:colon
id|relay_signal
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
(braket
id|SIGBUS
)braket
(brace
id|handler
suffix:colon
id|bus_handler
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
(braket
id|SIGSEGV
)braket
(brace
id|handler
suffix:colon
id|segv_handler
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
(braket
id|SIGIO
)braket
(brace
id|handler
suffix:colon
id|sigio_handler
comma
id|is_irq
suffix:colon
l_int|1
)brace
comma
(braket
id|SIGVTALRM
)braket
(brace
id|handler
suffix:colon
id|timer_handler
comma
id|is_irq
suffix:colon
l_int|1
)brace
comma
(braket
id|SIGALRM
)braket
(brace
id|handler
suffix:colon
id|timer_handler
comma
id|is_irq
suffix:colon
l_int|1
)brace
comma
(braket
id|SIGUSR2
)braket
(brace
id|handler
suffix:colon
id|syscall_handler
comma
id|is_irq
suffix:colon
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|function|sig_handler_common
r_void
id|sig_handler_common
c_func
(paren
r_int
id|sig
comma
r_struct
id|sigcontext
op_star
id|sc
)paren
(brace
r_struct
id|uml_pt_regs
id|save_regs
comma
op_star
id|r
suffix:semicolon
r_struct
id|signal_info
op_star
id|info
suffix:semicolon
r_int
id|save_errno
op_assign
id|errno
comma
id|save_timer
op_assign
id|kern_timer_on
comma
id|is_user
suffix:semicolon
id|unprotect_kernel_mem
c_func
(paren
)paren
suffix:semicolon
id|r
op_assign
(paren
r_struct
id|uml_pt_regs
op_star
)paren
id|TASK_REGS
c_func
(paren
id|get_current
c_func
(paren
)paren
)paren
suffix:semicolon
id|save_regs
op_assign
op_star
id|r
suffix:semicolon
id|is_user
op_assign
id|user_context
c_func
(paren
id|SC_SP
c_func
(paren
id|sc
)paren
)paren
suffix:semicolon
id|r-&gt;is_user
op_assign
id|is_user
suffix:semicolon
id|r-&gt;sc
op_assign
id|sc
suffix:semicolon
r_if
c_cond
(paren
id|sig
op_ne
id|SIGUSR2
)paren
(brace
id|r-&gt;syscall
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|change_sig
c_func
(paren
id|SIGUSR1
comma
l_int|1
)paren
suffix:semicolon
id|info
op_assign
op_amp
id|sig_info
(braket
id|sig
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;is_irq
)paren
(brace
id|unblock_signals
c_func
(paren
)paren
suffix:semicolon
)brace
(paren
op_star
id|info-&gt;handler
)paren
(paren
id|sig
comma
id|r
)paren
suffix:semicolon
id|kern_timer_on
op_assign
id|save_timer
suffix:semicolon
r_if
c_cond
(paren
id|is_user
)paren
(brace
id|interrupt_end
c_func
(paren
)paren
suffix:semicolon
id|block_signals
c_func
(paren
)paren
suffix:semicolon
id|change_sig
c_func
(paren
id|SIGUSR1
comma
l_int|0
)paren
suffix:semicolon
id|set_user_mode
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
op_star
id|r
op_assign
id|save_regs
suffix:semicolon
id|errno
op_assign
id|save_errno
suffix:semicolon
r_if
c_cond
(paren
id|is_user
)paren
(brace
id|protect_kernel_mem
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|sig_handler
r_void
id|sig_handler
c_func
(paren
r_int
id|sig
comma
r_struct
id|sigcontext
id|sc
)paren
(brace
id|sig_handler_common
c_func
(paren
id|sig
comma
op_amp
id|sc
)paren
suffix:semicolon
)brace
r_extern
r_int
id|timer_irq_inited
comma
id|missed_ticks
suffix:semicolon
r_extern
r_int
id|jail_timer_off
suffix:semicolon
DECL|function|alarm_handler
r_void
id|alarm_handler
c_func
(paren
r_int
id|sig
comma
r_struct
id|sigcontext
id|sc
)paren
(brace
r_int
id|user
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer_irq_inited
)paren
(brace
r_return
suffix:semicolon
)brace
id|missed_ticks
op_increment
suffix:semicolon
id|user
op_assign
id|user_context
c_func
(paren
id|SC_SP
c_func
(paren
op_amp
id|sc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
op_logical_and
op_logical_neg
id|kern_timer_on
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|user
op_logical_and
id|jail_timer_off
)paren
(brace
r_return
suffix:semicolon
)brace
id|sig_handler_common
c_func
(paren
id|sig
comma
op_amp
id|sc
)paren
suffix:semicolon
)brace
DECL|function|do_longjmp
r_void
id|do_longjmp
c_func
(paren
r_void
op_star
id|p
)paren
(brace
id|jmp_buf
op_star
id|jbuf
op_assign
(paren
id|jmp_buf
op_star
)paren
id|p
suffix:semicolon
m_longjmp
(paren
op_star
id|jbuf
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|uml_debug_setup
r_static
r_int
id|__init
id|uml_debug_setup
c_func
(paren
r_char
op_star
id|line
comma
r_int
op_star
id|add
)paren
(brace
r_char
op_star
id|next
suffix:semicolon
id|debug
op_assign
l_int|1
suffix:semicolon
op_star
id|add
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_ne
l_char|&squot;=&squot;
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|line
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|line
op_ne
l_int|NULL
)paren
(brace
id|next
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
op_star
id|next
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;go&quot;
)paren
)paren
(brace
id|debug_stop
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;parent&quot;
)paren
)paren
(brace
id|debug_parent
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Unknown debug option : &squot;%s&squot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
id|line
op_assign
id|next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;debug&quot;
comma
id|uml_debug_setup
comma
l_string|&quot;debug&bslash;n&quot;
l_string|&quot;    Starts up the kernel under the control of gdb. See the &bslash;n&quot;
l_string|&quot;    kernel debugging tutorial and the debugging session pages&bslash;n&quot;
l_string|&quot;    at http://user-mode-linux.sourceforge.net/ for more information.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
