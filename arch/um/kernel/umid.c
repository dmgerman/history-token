multiline_comment|/* &n; * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;signal.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;sys/param.h&gt;
macro_line|#include &quot;user.h&quot;
macro_line|#include &quot;umid.h&quot;
macro_line|#include &quot;init.h&quot;
macro_line|#include &quot;os.h&quot;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;choose-mode.h&quot;
DECL|macro|UMID_LEN
mdefine_line|#define UMID_LEN 64
DECL|macro|UML_DIR
mdefine_line|#define UML_DIR &quot;~/.uml/&quot;
multiline_comment|/* Changed by set_umid and make_umid, which are run early in boot */
DECL|variable|umid
r_static
r_char
id|umid
(braket
id|UMID_LEN
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Changed by set_uml_dir and make_uml_dir, which are run early in boot */
DECL|variable|uml_dir
r_static
r_char
op_star
id|uml_dir
op_assign
id|UML_DIR
suffix:semicolon
multiline_comment|/* Changed by set_umid */
DECL|variable|umid_is_random
r_static
r_int
id|umid_is_random
op_assign
l_int|1
suffix:semicolon
DECL|variable|umid_inited
r_static
r_int
id|umid_inited
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|make_umid
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|set_umid
r_static
r_int
id|__init
id|set_umid
c_func
(paren
r_char
op_star
id|name
comma
r_int
op_star
id|add
)paren
(brace
r_if
c_cond
(paren
id|umid_inited
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unique machine name can&squot;t be set twice&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|name
)paren
OG
id|UMID_LEN
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unique machine name is being truncated to %s &quot;
l_string|&quot;characters&bslash;n&quot;
comma
id|UMID_LEN
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|umid
comma
id|name
comma
id|UMID_LEN
op_minus
l_int|1
)paren
suffix:semicolon
id|umid
(braket
id|UMID_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|umid_is_random
op_assign
l_int|0
suffix:semicolon
id|umid_inited
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;umid=&quot;
comma
id|set_umid
comma
l_string|&quot;umid=&lt;name&gt;&bslash;n&quot;
l_string|&quot;    This is used to assign a unique identity to this UML machine and&bslash;n&quot;
l_string|&quot;    is used for naming the pid file and management console socket.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
DECL|function|umid_file_name
r_int
id|__init
id|umid_file_name
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umid_inited
op_logical_and
id|make_umid
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|n
op_assign
id|strlen
c_func
(paren
id|uml_dir
)paren
op_plus
id|strlen
c_func
(paren
id|umid
)paren
op_plus
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umid_file_name : buffer too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%s/%s&quot;
comma
id|uml_dir
comma
id|umid
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_extern
r_int
id|tracing_pid
suffix:semicolon
DECL|function|create_pid_file
r_static
r_int
id|__init
id|create_pid_file
c_func
(paren
r_void
)paren
(brace
r_char
id|file
(braket
id|strlen
c_func
(paren
id|uml_dir
)paren
op_plus
id|UMID_LEN
op_plus
r_sizeof
(paren
l_string|&quot;/pid&bslash;0&quot;
)paren
)braket
suffix:semicolon
r_char
id|pid
(braket
r_sizeof
(paren
l_string|&quot;nnnnn&bslash;0&quot;
)paren
)braket
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|umid_file_name
c_func
(paren
l_string|&quot;pid&quot;
comma
id|file
comma
r_sizeof
(paren
id|file
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|fd
op_assign
id|os_open_file
c_func
(paren
id|file
comma
id|of_create
c_func
(paren
id|of_excl
c_func
(paren
id|of_rdwr
c_func
(paren
id|OPENFLAGS
c_func
(paren
)paren
)paren
)paren
)paren
comma
l_int|0644
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Open of machine pid file &bslash;&quot;%s&bslash;&quot; failed - &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|file
comma
op_minus
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pid
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|os_getpid
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|fd
comma
id|pid
comma
id|strlen
c_func
(paren
id|pid
)paren
)paren
op_ne
id|strlen
c_func
(paren
id|pid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Write of pid file failed - errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|actually_do_remove
r_static
r_int
id|actually_do_remove
c_func
(paren
r_char
op_star
id|dir
)paren
(brace
id|DIR
op_star
id|directory
suffix:semicolon
r_struct
id|dirent
op_star
id|ent
suffix:semicolon
r_int
id|len
suffix:semicolon
r_char
id|file
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|directory
op_assign
id|opendir
c_func
(paren
id|dir
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;actually_do_remove : couldn&squot;t open directory &squot;%s&squot;, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|dir
comma
id|errno
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ent
op_assign
id|readdir
c_func
(paren
id|directory
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ent-&gt;d_name
comma
l_string|&quot;.&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|ent-&gt;d_name
comma
l_string|&quot;..&quot;
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|dir
)paren
op_plus
r_sizeof
(paren
l_string|&quot;/&quot;
)paren
op_plus
id|strlen
c_func
(paren
id|ent-&gt;d_name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|file
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Not deleting &squot;%s&squot; from &squot;%s&squot; - name too long&bslash;n&quot;
comma
id|ent-&gt;d_name
comma
id|dir
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|file
comma
l_string|&quot;%s/%s&quot;
comma
id|dir
comma
id|ent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlink
c_func
(paren
id|file
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;actually_do_remove : couldn&squot;t remove &squot;%s&squot; &quot;
l_string|&quot;from &squot;%s&squot;, errno = %d&bslash;n&quot;
comma
id|ent-&gt;d_name
comma
id|dir
comma
id|errno
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rmdir
c_func
(paren
id|dir
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;actually_do_remove : couldn&squot;t rmdir &squot;%s&squot;, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|dir
comma
id|errno
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remove_umid_dir
r_void
id|remove_umid_dir
c_func
(paren
r_void
)paren
(brace
r_char
id|dir
(braket
id|strlen
c_func
(paren
id|uml_dir
)paren
op_plus
id|UMID_LEN
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umid_inited
)paren
(brace
r_return
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|dir
comma
l_string|&quot;%s%s&quot;
comma
id|uml_dir
comma
id|umid
)paren
suffix:semicolon
id|actually_do_remove
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
DECL|function|get_umid
r_char
op_star
id|get_umid
c_func
(paren
r_int
id|only_if_set
)paren
(brace
r_if
c_cond
(paren
id|only_if_set
op_logical_and
id|umid_is_random
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|umid
suffix:semicolon
)brace
DECL|function|not_dead_yet
r_int
id|not_dead_yet
c_func
(paren
r_char
op_star
id|dir
)paren
(brace
r_char
id|file
(braket
id|strlen
c_func
(paren
id|uml_dir
)paren
op_plus
id|UMID_LEN
op_plus
r_sizeof
(paren
l_string|&quot;/pid&bslash;0&quot;
)paren
)braket
suffix:semicolon
r_char
id|pid
(braket
r_sizeof
(paren
l_string|&quot;nnnnn&bslash;0&quot;
)paren
)braket
comma
op_star
id|end
suffix:semicolon
r_int
id|dead
comma
id|fd
comma
id|p
suffix:semicolon
id|sprintf
c_func
(paren
id|file
comma
l_string|&quot;%s/pid&quot;
comma
id|dir
)paren
suffix:semicolon
id|dead
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|os_open_file
c_func
(paren
id|file
comma
id|of_read
c_func
(paren
id|OPENFLAGS
c_func
(paren
)paren
)paren
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fd
op_ne
op_minus
id|ENOENT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not_dead_yet : couldn&squot;t open pid file &squot;%s&squot;, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|file
comma
op_minus
id|fd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|pid
comma
r_sizeof
(paren
id|pid
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not_dead_yet : couldn&squot;t read pid file &squot;%s&squot;, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|file
comma
id|errno
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|p
op_assign
id|strtoul
c_func
(paren
id|pid
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|pid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not_dead_yet : couldn&squot;t parse pid file &squot;%s&squot;, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|file
comma
id|errno
)paren
suffix:semicolon
id|dead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|kill
c_func
(paren
id|p
comma
l_int|0
)paren
OL
l_int|0
)paren
op_logical_and
(paren
id|errno
op_eq
id|ESRCH
)paren
)paren
op_logical_or
(paren
id|p
op_eq
id|CHOOSE_MODE
c_func
(paren
id|tracing_pid
comma
id|os_getpid
c_func
(paren
)paren
)paren
)paren
)paren
(brace
id|dead
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dead
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|actually_do_remove
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_uml_dir
r_static
r_int
id|__init
id|set_uml_dir
c_func
(paren
r_char
op_star
id|name
comma
r_int
op_star
id|add
)paren
(brace
r_if
c_cond
(paren
(paren
id|strlen
c_func
(paren
id|name
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|name
(braket
id|strlen
c_func
(paren
id|name
)paren
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
)paren
(brace
id|uml_dir
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uml_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to malloc uml_dir - error = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
id|uml_dir
op_assign
id|name
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|uml_dir
comma
l_string|&quot;%s/&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
id|uml_dir
op_assign
id|name
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|make_uml_dir
r_static
r_int
id|__init
id|make_uml_dir
c_func
(paren
r_void
)paren
(brace
r_char
id|dir
(braket
id|MAXPATHLEN
op_plus
l_int|1
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|uml_dir
op_eq
l_char|&squot;~&squot;
)paren
(brace
r_char
op_star
id|home
op_assign
id|getenv
c_func
(paren
l_string|&quot;HOME&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|home
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;make_uml_dir : no value in environment for &quot;
l_string|&quot;$HOME&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|dir
comma
id|home
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|uml_dir
op_increment
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|dir
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|dir
comma
id|uml_dir
comma
r_sizeof
(paren
id|dir
)paren
op_minus
id|len
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
OG
l_int|0
)paren
op_logical_and
(paren
id|len
OL
r_sizeof
(paren
id|dir
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|dir
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
)paren
(brace
id|dir
(braket
id|len
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|dir
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|uml_dir
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|dir
)paren
op_plus
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;make_uml_dir : malloc failed, errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|uml_dir
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mkdir
c_func
(paren
id|uml_dir
comma
l_int|0777
)paren
OL
l_int|0
)paren
op_logical_and
(paren
id|errno
op_ne
id|EEXIST
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to mkdir %s - errno = %i&bslash;n&quot;
comma
id|uml_dir
comma
id|errno
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|make_umid
r_static
r_int
id|__init
id|make_umid
c_func
(paren
r_void
)paren
(brace
r_int
id|fd
comma
id|err
suffix:semicolon
r_char
id|tmp
(braket
id|strlen
c_func
(paren
id|uml_dir
)paren
op_plus
id|UMID_LEN
op_plus
l_int|1
)braket
suffix:semicolon
id|strncpy
c_func
(paren
id|tmp
comma
id|uml_dir
comma
r_sizeof
(paren
id|tmp
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|tmp
(braket
r_sizeof
(paren
id|tmp
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|umid
op_eq
l_int|0
)paren
(brace
id|strcat
c_func
(paren
id|tmp
comma
l_string|&quot;XXXXXX&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|mkstemp
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;set_umid - mkstemp failed, errno = %d&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/* There&squot;s a nice tiny little race between this unlink and&n;&t;&t; * the mkdir below.  It&squot;d be nice if there were a mkstemp&n;&t;&t; * for directories.&n;&t;&t; */
id|unlink
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|umid
comma
op_amp
id|tmp
(braket
id|strlen
c_func
(paren
id|uml_dir
)paren
)braket
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%s%s&quot;
comma
id|uml_dir
comma
id|umid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|mkdir
c_func
(paren
id|tmp
comma
l_int|0777
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EEXIST
)paren
(brace
r_if
c_cond
(paren
id|not_dead_yet
c_func
(paren
id|tmp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umid &squot;%s&squot; is in use&bslash;n&quot;
comma
id|umid
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|err
op_assign
id|mkdir
c_func
(paren
id|tmp
comma
l_int|0777
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to create %s - errno = %d&bslash;n&quot;
comma
id|umid
comma
id|errno
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;uml_dir=&quot;
comma
id|set_uml_dir
comma
l_string|&quot;uml_dir=&lt;directory&gt;&bslash;n&quot;
l_string|&quot;    The location to place the pid and umid files.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|make_uml_dir
id|__uml_postsetup
c_func
(paren
id|make_uml_dir
)paren
suffix:semicolon
DECL|variable|make_umid
id|__uml_postsetup
c_func
(paren
id|make_umid
)paren
suffix:semicolon
DECL|variable|create_pid_file
id|__uml_postsetup
c_func
(paren
id|create_pid_file
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
