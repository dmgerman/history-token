multiline_comment|/* &n; * Copyright (C) 2000 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;signal.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/poll.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/time.h&gt;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;kern_util.h&quot;
macro_line|#include &quot;user.h&quot;
macro_line|#include &quot;process.h&quot;
macro_line|#include &quot;signal_user.h&quot;
macro_line|#include &quot;sigio.h&quot;
macro_line|#include &quot;irq_user.h&quot;
macro_line|#include &quot;os.h&quot;
DECL|struct|irq_fd
r_struct
id|irq_fd
(brace
DECL|member|next
r_struct
id|irq_fd
op_star
id|next
suffix:semicolon
DECL|member|id
r_void
op_star
id|id
suffix:semicolon
DECL|member|fd
r_int
id|fd
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|events
r_int
id|events
suffix:semicolon
DECL|member|current_events
r_int
id|current_events
suffix:semicolon
DECL|member|freed
r_int
id|freed
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|active_fds
r_static
r_struct
id|irq_fd
op_star
id|active_fds
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|last_irq_ptr
r_static
r_struct
id|irq_fd
op_star
op_star
id|last_irq_ptr
op_assign
op_amp
id|active_fds
suffix:semicolon
DECL|variable|pollfds
r_static
r_struct
id|pollfd
op_star
id|pollfds
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pollfds_num
r_static
r_int
id|pollfds_num
op_assign
l_int|0
suffix:semicolon
DECL|variable|pollfds_size
r_static
r_int
id|pollfds_size
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|io_count
comma
id|intr_count
suffix:semicolon
DECL|function|sigio_handler
r_void
id|sigio_handler
c_func
(paren
r_int
id|sig
comma
r_struct
id|uml_pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq_fd
comma
op_star
id|next
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
id|smp_sigio_handler
c_func
(paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|poll
c_func
(paren
id|pollfds
comma
id|pollfds_num
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EINTR
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;sigio_handler : poll returned %d, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|n
comma
id|errno
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|irq_fd
op_assign
id|active_fds
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pollfds_num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pollfds
(braket
id|i
)braket
dot
id|revents
op_ne
l_int|0
)paren
(brace
id|irq_fd-&gt;current_events
op_assign
id|pollfds
(braket
id|i
)braket
dot
id|revents
suffix:semicolon
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|irq_fd
op_assign
id|irq_fd-&gt;next
suffix:semicolon
)brace
r_for
c_loop
(paren
id|irq_fd
op_assign
id|active_fds
suffix:semicolon
id|irq_fd
op_ne
l_int|NULL
suffix:semicolon
id|irq_fd
op_assign
id|next
)paren
(brace
id|next
op_assign
id|irq_fd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|irq_fd-&gt;current_events
op_ne
l_int|0
)paren
(brace
id|irq_fd-&gt;current_events
op_assign
l_int|0
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq_fd-&gt;irq
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* This is here because the next irq may be&n;&t;&t;&t;&t; * freed in the handler.  If a console goes&n;&t;&t;&t;&t; * away, both the read and write irqs will be&n;&t;&t;&t;&t; * freed.  After do_IRQ, -&gt;next will point to&n;&t;&t;&t;&t; * a good IRQ.&n;&t;&t;&t;&t; * Irqs can&squot;t be freed inside their handlers,&n;&t;&t;&t;&t; * so the next best thing is to have them&n;&t;&t;&t;&t; * marked as needing freeing, so that they&n;&t;&t;&t;&t; * can be freed here.&n;&t;&t;&t;&t; */
id|next
op_assign
id|irq_fd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|irq_fd-&gt;freed
)paren
(brace
id|free_irq
c_func
(paren
id|irq_fd-&gt;irq
comma
id|irq_fd-&gt;id
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
DECL|function|activate_ipi
r_int
id|activate_ipi
c_func
(paren
r_int
id|fd
comma
r_int
id|pid
)paren
(brace
r_return
id|os_set_fd_async
c_func
(paren
id|fd
comma
id|pid
)paren
suffix:semicolon
)brace
DECL|function|maybe_sigio_broken
r_static
r_void
id|maybe_sigio_broken
c_func
(paren
r_int
id|fd
comma
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|isatty
c_func
(paren
id|fd
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|type
op_eq
id|IRQ_WRITE
)paren
op_logical_and
op_logical_neg
id|pty_output_sigio
)paren
(brace
id|write_sigio_workaround
c_func
(paren
)paren
suffix:semicolon
id|add_sigio_fd
c_func
(paren
id|fd
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|type
op_eq
id|IRQ_READ
)paren
op_logical_and
op_logical_neg
id|pty_close_sigio
)paren
(brace
id|write_sigio_workaround
c_func
(paren
)paren
suffix:semicolon
id|add_sigio_fd
c_func
(paren
id|fd
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|activate_fd
r_int
id|activate_fd
c_func
(paren
r_int
id|irq
comma
r_int
id|fd
comma
r_int
id|type
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|pollfd
op_star
id|tmp_pfd
suffix:semicolon
r_struct
id|irq_fd
op_star
id|new_fd
comma
op_star
id|irq_fd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pid
comma
id|events
comma
id|err
comma
id|n
comma
id|size
suffix:semicolon
id|pid
op_assign
id|os_getpid
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|os_set_fd_async
c_func
(paren
id|fd
comma
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|new_fd
op_assign
id|um_kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_fd
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|new_fd
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|IRQ_READ
)paren
(brace
id|events
op_assign
id|POLLIN
op_or
id|POLLPRI
suffix:semicolon
)brace
r_else
id|events
op_assign
id|POLLOUT
suffix:semicolon
op_star
id|new_fd
op_assign
(paren
(paren
r_struct
id|irq_fd
)paren
(brace
id|next
suffix:colon
l_int|NULL
comma
id|id
suffix:colon
id|dev_id
comma
id|fd
suffix:colon
id|fd
comma
id|type
suffix:colon
id|type
comma
id|irq
suffix:colon
id|irq
comma
id|pid
suffix:colon
id|pid
comma
id|events
suffix:colon
id|events
comma
id|current_events
suffix:colon
l_int|0
comma
id|freed
suffix:colon
l_int|0
)brace
)paren
suffix:semicolon
multiline_comment|/* Critical section - locked by a spinlock because this stuff can&n;&t; * be changed from interrupt handlers.  The stuff above is done &n;&t; * outside the lock because it allocates memory.&n;&t; */
multiline_comment|/* Actually, it only looks like it can be called from interrupt&n;&t; * context.  The culprit is reactivate_fd, which calls &n;&t; * maybe_sigio_broken, which calls write_sigio_workaround,&n;&t; * which calls activate_fd.  However, write_sigio_workaround should&n;&t; * only be called once, at boot time.  That would make it clear that&n;&t; * this is called only from process context, and can be locked with&n;&t; * a semaphore.&n;&t; */
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|irq_fd
op_assign
id|active_fds
suffix:semicolon
id|irq_fd
op_ne
l_int|NULL
suffix:semicolon
id|irq_fd
op_assign
id|irq_fd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_fd-&gt;fd
op_eq
id|fd
)paren
op_logical_and
(paren
id|irq_fd-&gt;type
op_eq
id|type
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Registering fd %d twice&bslash;n&quot;
comma
id|fd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Irqs : %d, %d&bslash;n&quot;
comma
id|irq_fd-&gt;irq
comma
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ids : 0x%x, 0x%x&bslash;n&quot;
comma
id|irq_fd-&gt;id
comma
id|dev_id
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|n
op_assign
id|pollfds_num
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
id|pollfds_size
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Here we have to drop the lock in order to call &n;&t;&t;&t; * kmalloc, which might sleep.  If something else&n;&t;&t;&t; * came in and changed the pollfds array, we free&n;&t;&t;&t; * the buffer and try again.&n;&t;&t;&t; */
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|size
op_assign
(paren
id|pollfds_num
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|pollfds
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|tmp_pfd
op_assign
id|um_kmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_pfd
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_eq
id|pollfds_size
)paren
(brace
r_break
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|tmp_pfd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pollfds
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|tmp_pfd
comma
id|pollfds
comma
r_sizeof
(paren
id|pollfds
(braket
l_int|0
)braket
)paren
op_star
id|pollfds_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pollfds
)paren
suffix:semicolon
)brace
id|pollfds
op_assign
id|tmp_pfd
suffix:semicolon
id|pollfds_size
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|IRQ_WRITE
)paren
(brace
id|fd
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|pollfds
(braket
id|pollfds_num
)braket
op_assign
(paren
(paren
r_struct
id|pollfd
)paren
(brace
id|fd
suffix:colon
id|fd
comma
id|events
suffix:colon
id|events
comma
id|revents
suffix:colon
l_int|0
)brace
)paren
suffix:semicolon
id|pollfds_num
op_increment
suffix:semicolon
op_star
id|last_irq_ptr
op_assign
id|new_fd
suffix:semicolon
id|last_irq_ptr
op_assign
op_amp
id|new_fd-&gt;next
suffix:semicolon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This calls activate_fd, so it has to be outside the critical&n;&t; * section.&n;&t; */
id|maybe_sigio_broken
c_func
(paren
id|fd
comma
id|type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_unlock
suffix:colon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_fd
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|free_irq_by_cb
r_static
r_void
id|free_irq_by_cb
c_func
(paren
r_int
(paren
op_star
id|test
)paren
(paren
r_struct
id|irq_fd
op_star
comma
r_void
op_star
)paren
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|irq_fd
op_star
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
id|prev
op_assign
op_amp
id|active_fds
suffix:semicolon
r_while
c_loop
(paren
op_star
id|prev
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|test
)paren
(paren
op_star
id|prev
comma
id|arg
)paren
)paren
(brace
r_struct
id|irq_fd
op_star
id|old_fd
op_assign
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_ne
(paren
op_star
id|prev
)paren
op_member_access_from_pointer
id|fd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_irq_by_cb - mismatch between &quot;
l_string|&quot;active_fds and pollfds, fd %d vs %d&bslash;n&quot;
comma
(paren
op_star
id|prev
)paren
op_member_access_from_pointer
id|fd
comma
id|pollfds
(braket
id|i
)braket
dot
id|fd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|pollfds
(braket
id|i
)braket
comma
op_amp
id|pollfds
(braket
id|i
op_plus
l_int|1
)braket
comma
(paren
id|pollfds_num
op_minus
id|i
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|pollfds
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|pollfds_num
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|last_irq_ptr
op_eq
op_amp
id|old_fd-&gt;next
)paren
(brace
id|last_irq_ptr
op_assign
id|prev
suffix:semicolon
)brace
op_star
id|prev
op_assign
(paren
op_star
id|prev
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|old_fd-&gt;type
op_eq
id|IRQ_WRITE
)paren
(brace
id|ignore_sigio_fd
c_func
(paren
id|old_fd-&gt;fd
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|old_fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|prev
op_assign
op_amp
(paren
op_star
id|prev
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|struct|irq_and_dev
r_struct
id|irq_and_dev
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|dev
r_void
op_star
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|function|same_irq_and_dev
r_static
r_int
id|same_irq_and_dev
c_func
(paren
r_struct
id|irq_fd
op_star
id|irq
comma
r_void
op_star
id|d
)paren
(brace
r_struct
id|irq_and_dev
op_star
id|data
op_assign
id|d
suffix:semicolon
r_return
(paren
id|irq-&gt;irq
op_eq
id|data-&gt;irq
)paren
op_logical_and
(paren
id|irq-&gt;id
op_eq
id|data-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|free_irq_by_irq_and_dev
r_void
id|free_irq_by_irq_and_dev
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
)paren
(brace
r_struct
id|irq_and_dev
id|data
op_assign
(paren
(paren
r_struct
id|irq_and_dev
)paren
(brace
id|irq
suffix:colon
id|irq
comma
id|dev
suffix:colon
id|dev
)brace
)paren
suffix:semicolon
id|free_irq_by_cb
c_func
(paren
id|same_irq_and_dev
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|same_fd
r_static
r_int
id|same_fd
c_func
(paren
r_struct
id|irq_fd
op_star
id|irq
comma
r_void
op_star
id|fd
)paren
(brace
r_return
id|irq-&gt;fd
op_eq
op_star
(paren
(paren
r_int
op_star
)paren
id|fd
)paren
suffix:semicolon
)brace
DECL|function|free_irq_by_fd
r_void
id|free_irq_by_fd
c_func
(paren
r_int
id|fd
)paren
(brace
id|free_irq_by_cb
c_func
(paren
id|same_fd
comma
op_amp
id|fd
)paren
suffix:semicolon
)brace
DECL|function|find_irq_by_fd
r_static
r_struct
id|irq_fd
op_star
id|find_irq_by_fd
c_func
(paren
r_int
id|fd
comma
r_int
id|irqnum
comma
r_int
op_star
id|index_out
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|active_fds
suffix:semicolon
id|irq
op_ne
l_int|NULL
suffix:semicolon
id|irq
op_assign
id|irq-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq-&gt;fd
op_eq
id|fd
)paren
op_logical_and
(paren
id|irq-&gt;irq
op_eq
id|irqnum
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;find_irq_by_fd doesn&squot;t have descriptor %d&bslash;n&quot;
comma
id|fd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_ne
id|fd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;find_irq_by_fd - mismatch between active_fds and &quot;
l_string|&quot;pollfds, fd %d vs %d, need %d&bslash;n&quot;
comma
id|irq-&gt;fd
comma
id|pollfds
(braket
id|i
)braket
dot
id|fd
comma
id|fd
)paren
suffix:semicolon
id|irq
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|index_out
op_assign
id|i
suffix:semicolon
id|out
suffix:colon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|free_irq_later
r_void
id|free_irq_later
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq_fd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|irq_fd
op_assign
id|active_fds
suffix:semicolon
id|irq_fd
op_ne
l_int|NULL
suffix:semicolon
id|irq_fd
op_assign
id|irq_fd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_fd-&gt;irq
op_eq
id|irq
)paren
op_logical_and
(paren
id|irq_fd-&gt;id
op_eq
id|dev_id
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|irq_fd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_irq_later found no irq, irq = %d, &quot;
l_string|&quot;dev_id = 0x%p&bslash;n&quot;
comma
id|irq
comma
id|dev_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|irq_fd-&gt;freed
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|reactivate_fd
r_void
id|reactivate_fd
c_func
(paren
r_int
id|fd
comma
r_int
id|irqnum
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
id|irq
op_assign
id|find_irq_by_fd
c_func
(paren
id|fd
comma
id|irqnum
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
l_int|NULL
)paren
(brace
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_assign
id|irq-&gt;fd
suffix:semicolon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This calls activate_fd, so it has to be outside the critical&n;&t; * section.&n;&t; */
id|maybe_sigio_broken
c_func
(paren
id|fd
comma
id|irq-&gt;type
)paren
suffix:semicolon
)brace
DECL|function|deactivate_fd
r_void
id|deactivate_fd
c_func
(paren
r_int
id|fd
comma
r_int
id|irqnum
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
id|irq
op_assign
id|find_irq_by_fd
c_func
(paren
id|fd
comma
id|irqnum
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|pollfds
(braket
id|i
)braket
dot
id|fd
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|forward_ipi
r_void
id|forward_ipi
c_func
(paren
r_int
id|fd
comma
r_int
id|pid
)paren
(brace
r_if
c_cond
(paren
id|fcntl
c_func
(paren
id|fd
comma
id|F_SETOWN
comma
id|pid
)paren
OL
l_int|0
)paren
(brace
r_int
id|save_errno
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|fcntl
c_func
(paren
id|fd
comma
id|F_GETOWN
comma
l_int|0
)paren
op_ne
id|pid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;forward_ipi: F_SETOWN failed, fd = %d, &quot;
l_string|&quot;me = %d, target = %d, errno = %d&bslash;n&quot;
comma
id|fd
comma
id|os_getpid
c_func
(paren
)paren
comma
id|pid
comma
id|save_errno
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|forward_interrupts
r_void
id|forward_interrupts
c_func
(paren
r_int
id|pid
)paren
(brace
r_struct
id|irq_fd
op_star
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|irq_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|active_fds
suffix:semicolon
id|irq
op_ne
l_int|NULL
suffix:semicolon
id|irq
op_assign
id|irq-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|fcntl
c_func
(paren
id|irq-&gt;fd
comma
id|F_SETOWN
comma
id|pid
)paren
OL
l_int|0
)paren
(brace
r_int
id|save_errno
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|fcntl
c_func
(paren
id|irq-&gt;fd
comma
id|F_GETOWN
comma
l_int|0
)paren
op_ne
id|pid
)paren
(brace
multiline_comment|/* XXX Just remove the irq rather than&n;&t;&t;&t;&t; * print out an infinite stream of these&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Failed to forward %d to pid %d, &quot;
l_string|&quot;errno = %d&bslash;n&quot;
comma
id|irq-&gt;fd
comma
id|pid
comma
id|save_errno
)paren
suffix:semicolon
)brace
)brace
id|irq-&gt;pid
op_assign
id|pid
suffix:semicolon
)brace
id|irq_unlock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|init_irq_signals
r_void
id|init_irq_signals
c_func
(paren
r_int
id|on_sigstack
)paren
(brace
id|__sighandler_t
id|h
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|on_sigstack
ques
c_cond
id|SA_ONSTACK
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_irq_inited
)paren
(brace
id|h
op_assign
(paren
id|__sighandler_t
)paren
id|alarm_handler
suffix:semicolon
)brace
r_else
id|h
op_assign
id|boot_timer_handler
suffix:semicolon
id|set_handler
c_func
(paren
id|SIGVTALRM
comma
id|h
comma
id|flags
op_or
id|SA_RESTART
comma
id|SIGUSR1
comma
id|SIGIO
comma
id|SIGWINCH
comma
id|SIGALRM
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|set_handler
c_func
(paren
id|SIGIO
comma
(paren
id|__sighandler_t
)paren
id|sig_handler
comma
id|flags
op_or
id|SA_RESTART
comma
id|SIGUSR1
comma
id|SIGIO
comma
id|SIGWINCH
comma
id|SIGALRM
comma
id|SIGVTALRM
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGWINCH
comma
id|SIG_IGN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
