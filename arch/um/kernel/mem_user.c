multiline_comment|/*&n; * arch/um/kernel/mem_user.c&n; *&n; * BRIEF MODULE DESCRIPTION&n; * user side memory routines for supporting IO memory inside user mode linux&n; *&n; * Copyright (C) 2001 RidgeRun, Inc.&n; * Author: RidgeRun, Inc.&n; *         Greg Lonnon glonnon@ridgerun.com or info@ridgerun.com&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &quot;kern_util.h&quot;
macro_line|#include &quot;user.h&quot;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;mem_user.h&quot;
macro_line|#include &quot;init.h&quot;
macro_line|#include &quot;os.h&quot;
macro_line|#include &quot;tempfile.h&quot;
macro_line|#include &quot;kern_constants.h&quot;
r_extern
r_struct
id|mem_region
id|physmem_region
suffix:semicolon
DECL|macro|TEMPNAME_TEMPLATE
mdefine_line|#define TEMPNAME_TEMPLATE &quot;vm_file-XXXXXX&quot;
DECL|function|create_tmp_file
r_static
r_int
id|create_tmp_file
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
id|fd
comma
id|err
suffix:semicolon
r_char
id|zero
suffix:semicolon
id|fd
op_assign
id|make_tempfile
c_func
(paren
id|TEMPNAME_TEMPLATE
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|fd
comma
l_string|&quot;make_tempfile&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|err
op_assign
id|os_mode_fd
c_func
(paren
id|fd
comma
l_int|0777
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|err
comma
l_string|&quot;os_mode_fd&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|err
op_assign
id|os_seek_file
c_func
(paren
id|fd
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|err
comma
l_string|&quot;os_seek_file&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|zero
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|os_write_file
c_func
(paren
id|fd
comma
op_amp
id|zero
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
(brace
id|os_print_error
c_func
(paren
id|err
comma
l_string|&quot;os_write_file&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|fd
suffix:semicolon
)brace
DECL|function|check_tmpexec
r_void
id|check_tmpexec
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
r_int
id|err
comma
id|fd
op_assign
id|create_tmp_file
c_func
(paren
id|UM_KERN_PAGE_SIZE
)paren
suffix:semicolon
id|addr
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|UM_KERN_PAGE_SIZE
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Checking PROT_EXEC mmap in /tmp...&quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|MAP_FAILED
)paren
(brace
id|err
op_assign
id|errno
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot;failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|EPERM
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;/tmp must be not mounted noexec&bslash;n&quot;
)paren
suffix:semicolon
)brace
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|addr
comma
id|UM_KERN_PAGE_SIZE
)paren
suffix:semicolon
id|os_close_file
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
DECL|variable|have_devanon
r_static
r_int
id|have_devanon
op_assign
l_int|0
suffix:semicolon
DECL|function|check_devanon
r_void
id|check_devanon
c_func
(paren
r_void
)paren
(brace
r_int
id|fd
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Checking for /dev/anon on the host...&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/anon&quot;
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Not available (open failed with errno %d)&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
id|have_devanon
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|create_anon_file
r_static
r_int
id|create_anon_file
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/anon&quot;
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|fd
comma
l_string|&quot;opening /dev/anon&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|addr
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|len
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|MAP_FAILED
)paren
(brace
id|os_print_error
c_func
(paren
(paren
r_int
)paren
id|addr
comma
l_string|&quot;mapping physmem file&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
r_return
id|fd
suffix:semicolon
)brace
DECL|function|create_mem_file
r_int
id|create_mem_file
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
id|err
comma
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|have_devanon
)paren
(brace
id|fd
op_assign
id|create_anon_file
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_else
id|fd
op_assign
id|create_tmp_file
c_func
(paren
id|len
)paren
suffix:semicolon
id|err
op_assign
id|os_set_exec_close
c_func
(paren
id|fd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|err
comma
l_string|&quot;exec_close&quot;
)paren
suffix:semicolon
)brace
r_return
id|fd
suffix:semicolon
)brace
DECL|variable|iomem_regions
r_struct
id|iomem_region
op_star
id|iomem_regions
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|iomem_size
r_int
id|iomem_size
op_assign
l_int|0
suffix:semicolon
DECL|function|parse_iomem
r_static
r_int
id|__init
id|parse_iomem
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|add
)paren
(brace
r_struct
id|iomem_region
op_star
r_new
suffix:semicolon
r_struct
id|uml_stat
id|buf
suffix:semicolon
r_char
op_star
id|file
comma
op_star
id|driver
suffix:semicolon
r_int
id|fd
comma
id|err
comma
id|size
suffix:semicolon
id|driver
op_assign
id|str
suffix:semicolon
id|file
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;parse_iomem : failed to parse iomem&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|file
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|file
op_increment
suffix:semicolon
id|fd
op_assign
id|os_open_file
c_func
(paren
id|file
comma
id|of_rdwr
c_func
(paren
id|OPENFLAGS
c_func
(paren
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|fd
comma
l_string|&quot;parse_iomem - Couldn&squot;t open io file&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|os_stat_fd
c_func
(paren
id|fd
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|os_print_error
c_func
(paren
id|err
comma
l_string|&quot;parse_iomem - cannot stat_fd file&quot;
)paren
suffix:semicolon
r_goto
id|out_close
suffix:semicolon
)brace
r_new
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
r_new
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Couldn&squot;t allocate iomem_region struct&quot;
)paren
suffix:semicolon
r_goto
id|out_close
suffix:semicolon
)brace
id|size
op_assign
(paren
id|buf.ust_size
op_plus
id|UM_KERN_PAGE_SIZE
)paren
op_amp
op_complement
(paren
id|UM_KERN_PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
op_star
r_new
op_assign
(paren
(paren
r_struct
id|iomem_region
)paren
(brace
dot
id|next
op_assign
id|iomem_regions
comma
dot
id|driver
op_assign
id|driver
comma
dot
id|fd
op_assign
id|fd
comma
dot
id|size
op_assign
id|size
comma
dot
id|phys
op_assign
l_int|0
comma
dot
id|virt
op_assign
l_int|0
)brace
)paren
suffix:semicolon
id|iomem_regions
op_assign
r_new
suffix:semicolon
id|iomem_size
op_add_assign
r_new
op_member_access_from_pointer
id|size
op_plus
id|UM_KERN_PAGE_SIZE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_close
suffix:colon
id|os_close_file
c_func
(paren
id|fd
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
id|__uml_setup
c_func
(paren
l_string|&quot;iomem=&quot;
comma
id|parse_iomem
comma
l_string|&quot;iomem=&lt;name&gt;,&lt;file&gt;&bslash;n&quot;
l_string|&quot;    Configure &lt;file&gt; as an IO memory region named &lt;name&gt;.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
DECL|function|protect_memory
r_int
id|protect_memory
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
id|r
comma
r_int
id|w
comma
r_int
id|x
comma
r_int
id|must_succeed
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|os_protect_memory
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
comma
id|len
comma
id|r
comma
id|w
comma
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|must_succeed
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;protect failed, err = %d&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
)brace
r_else
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Debugging facility for dumping stuff out to the host, avoiding the timing&n; * problems that come with printf and breakpoints.&n; * Enable in case of emergency.&n; */
r_int
id|logging
op_assign
l_int|1
suffix:semicolon
r_int
id|logging_fd
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|logging_line
op_assign
l_int|0
suffix:semicolon
r_char
id|logging_buf
(braket
l_int|512
)braket
suffix:semicolon
r_void
id|log
c_func
(paren
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
r_struct
id|openflags
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|logging
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logging_fd
OL
l_int|0
)paren
(brace
id|flags
op_assign
id|of_create
c_func
(paren
id|of_trunc
c_func
(paren
id|of_rdwr
c_func
(paren
id|OPENFLAGS
c_func
(paren
)paren
)paren
)paren
)paren
suffix:semicolon
id|logging_fd
op_assign
id|os_open_file
c_func
(paren
l_string|&quot;log&quot;
comma
id|flags
comma
l_int|0644
)paren
suffix:semicolon
)brace
id|gettimeofday
c_func
(paren
op_amp
id|tv
comma
l_int|NULL
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|logging_buf
comma
l_string|&quot;%d&bslash;t %u.%u  &quot;
comma
id|logging_line
op_increment
comma
id|tv.tv_sec
comma
id|tv.tv_usec
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
op_amp
id|logging_buf
(braket
id|strlen
c_func
(paren
id|logging_buf
)paren
)braket
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|write
c_func
(paren
id|logging_fd
comma
id|logging_buf
comma
id|strlen
c_func
(paren
id|logging_buf
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
