multiline_comment|/* &n; * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#ifndef __FRAME_USER_I386_H
DECL|macro|__FRAME_USER_I386_H
mdefine_line|#define __FRAME_USER_I386_H
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &quot;sysdep/frame.h&quot;
multiline_comment|/* This stuff is to calculate the size of the fp state struct at runtime&n; * because it has changed between 2.2 and 2.4 and it would be good for a&n; * UML compiled on one to work on the other.&n; * So, setup_arch_frame_raw fills in the arch struct with the raw data, which&n; * just contains the address of the end of the sigcontext.  This is invoked&n; * from the signal handler.&n; * setup_arch_frame uses that data to figure out what &n; * arch_frame_data.fpstate_size should be.  It really has no idea, since it&squot;s&n; * not allowed to do sizeof(struct fpstate) but it&squot;s safe to consider that it&squot;s&n; * everything from the end of the sigcontext up to the top of the stack.  So,&n; * it masks off the page number to get the offset within the page and subtracts&n; * that from the page size, and that&squot;s how big the fpstate struct will be&n; * considered to be.&n; */
DECL|function|setup_arch_frame_raw
r_static
r_inline
r_void
id|setup_arch_frame_raw
c_func
(paren
r_struct
id|arch_frame_data_raw
op_star
id|data
comma
r_void
op_star
id|end
comma
r_int
r_int
id|srp
)paren
(brace
r_int
r_int
id|sr
op_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|srp
)paren
suffix:semicolon
id|data-&gt;fp_start
op_assign
(paren
r_int
r_int
)paren
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
r_int
r_int
)paren
id|end
op_amp
id|PAGE_MASK
)paren
)paren
(brace
id|data-&gt;sr
op_assign
id|sr
suffix:semicolon
)brace
r_else
id|data-&gt;sr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|setup_arch_frame
r_static
r_inline
r_void
id|setup_arch_frame
c_func
(paren
r_struct
id|arch_frame_data_raw
op_star
id|in
comma
r_struct
id|arch_frame_data
op_star
id|out
)paren
(brace
r_int
r_int
id|fpstate_start
op_assign
id|in-&gt;fp_start
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;sr
op_eq
l_int|0
)paren
(brace
id|fpstate_start
op_and_assign
op_complement
id|PAGE_MASK
suffix:semicolon
id|out-&gt;fpstate_size
op_assign
id|PAGE_SIZE
op_minus
id|fpstate_start
suffix:semicolon
)brace
r_else
(brace
id|out-&gt;fpstate_size
op_assign
id|in-&gt;sr
op_minus
id|fpstate_start
suffix:semicolon
)brace
)brace
multiline_comment|/* This figures out where on the stack the SA_RESTORER function address&n; * is stored.  For i386, it&squot;s the signal handler return address, so it&squot;s&n; * located next to the frame pointer.&n; * This is inlined, so __builtin_frame_address(0) is correct.  Otherwise,&n; * it would have to be __builtin_frame_address(1).&n; */
DECL|macro|frame_restorer
mdefine_line|#define frame_restorer() &bslash;&n;({ &bslash;&n;&t;unsigned long *fp; &bslash;&n;&bslash;&n;&t;fp = __builtin_frame_address(0); &bslash;&n;&t;((unsigned long) (fp + 1)); &bslash;&n;})
multiline_comment|/* Similarly, this returns the value of sp when the handler was first&n; * entered.  This is used to calculate the proper sp when delivering&n; * signals.&n; */
DECL|macro|frame_sp
mdefine_line|#define frame_sp() &bslash;&n;({ &bslash;&n;&t;unsigned long *fp; &bslash;&n;&bslash;&n;&t;fp = __builtin_frame_address(0); &bslash;&n;&t;((unsigned long) (fp + 1)); &bslash;&n;})
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
