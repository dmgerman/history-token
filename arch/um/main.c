multiline_comment|/* &n; * Copyright (C) 2000, 2001 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stdio.h&gt; 
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;signal.h&gt;
macro_line|#include &lt;sys/resource.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/user.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &quot;user_util.h&quot;
macro_line|#include &quot;kern_util.h&quot;
macro_line|#include &quot;mem_user.h&quot;
macro_line|#include &quot;user.h&quot;
macro_line|#include &quot;init.h&quot;
multiline_comment|/* Set in set_stklim, which is called from main and __wrap_malloc.  &n; * __wrap_malloc only calls it if main hasn&squot;t started.&n; */
DECL|variable|stacksizelim
r_int
r_int
id|stacksizelim
suffix:semicolon
multiline_comment|/* Set in main */
DECL|variable|linux_prog
r_char
op_star
id|linux_prog
suffix:semicolon
DECL|macro|PGD_BOUND
mdefine_line|#define PGD_BOUND (4 * 1024 * 1024)
DECL|macro|STACKSIZE
mdefine_line|#define STACKSIZE (8 * 1024 * 1024)
DECL|macro|THREAD_NAME_LEN
mdefine_line|#define THREAD_NAME_LEN (256)
multiline_comment|/* Never changed */
DECL|variable|padding
r_static
r_char
id|padding
(braket
id|THREAD_NAME_LEN
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|THREAD_NAME_LEN
op_minus
l_int|2
)braket
op_assign
l_char|&squot; &squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
DECL|function|set_stklim
r_static
r_void
id|set_stklim
c_func
(paren
r_void
)paren
(brace
r_struct
id|rlimit
id|lim
suffix:semicolon
r_if
c_cond
(paren
id|getrlimit
c_func
(paren
id|RLIMIT_STACK
comma
op_amp
id|lim
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;getrlimit&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lim.rlim_cur
op_eq
id|RLIM_INFINITY
)paren
op_logical_or
(paren
id|lim.rlim_cur
OG
id|STACKSIZE
)paren
)paren
(brace
id|lim.rlim_cur
op_assign
id|STACKSIZE
suffix:semicolon
r_if
c_cond
(paren
id|setrlimit
c_func
(paren
id|RLIMIT_STACK
comma
op_amp
id|lim
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;setrlimit&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|stacksizelim
op_assign
(paren
id|lim.rlim_cur
op_plus
id|PGD_BOUND
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|PGD_BOUND
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_uml_initcalls
r_static
id|__init
r_void
id|do_uml_initcalls
c_func
(paren
r_void
)paren
(brace
id|initcall_t
op_star
id|call
suffix:semicolon
id|call
op_assign
op_amp
id|__uml_initcall_start
suffix:semicolon
r_while
c_loop
(paren
id|call
OL
op_amp
id|__uml_initcall_end
)paren
(brace
suffix:semicolon
(paren
op_star
id|call
)paren
(paren
)paren
suffix:semicolon
id|call
op_increment
suffix:semicolon
)brace
)brace
r_extern
r_int
id|uml_exitcode
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|envp
)paren
(brace
id|sigset_t
id|mask
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
r_char
op_star
op_star
id|new_argv
suffix:semicolon
multiline_comment|/* Enable all signals - in some environments, we can enter with&n;&t; * some signals blocked&n;&t; */
id|sigemptyset
c_func
(paren
op_amp
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sigprocmask
c_func
(paren
id|SIG_SETMASK
comma
op_amp
id|mask
comma
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;sigprocmask&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate memory for thread command lines */
r_if
c_cond
(paren
id|argc
OL
l_int|2
op_logical_or
id|strlen
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
OL
id|THREAD_NAME_LEN
op_minus
l_int|1
)paren
(brace
id|new_argv
op_assign
id|malloc
c_func
(paren
(paren
id|argc
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_argv
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Allocating extended argv&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|new_argv
(braket
l_int|0
)braket
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|new_argv
(braket
l_int|1
)braket
op_assign
id|padding
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_le
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_argv
(braket
id|i
)braket
op_assign
id|argv
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
)brace
id|new_argv
(braket
id|argc
op_plus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef PROFILING
id|disable_profile_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|execvp
c_func
(paren
id|new_argv
(braket
l_int|0
)braket
comma
id|new_argv
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot;execing with extended args&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|linux_prog
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|set_stklim
c_func
(paren
)paren
suffix:semicolon
id|set_task_sizes
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_argv
op_assign
id|malloc
c_func
(paren
(paren
id|argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Mallocing argv&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_argv
(braket
id|i
)braket
op_assign
id|strdup
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Mallocing an arg&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|new_argv
(braket
id|argc
)braket
op_assign
l_int|NULL
suffix:semicolon
id|do_uml_initcalls
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|linux_main
c_func
(paren
id|argc
comma
id|argv
)paren
suffix:semicolon
multiline_comment|/* Reboot */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|execvp
c_func
(paren
id|new_argv
(braket
l_int|0
)braket
comma
id|new_argv
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot;Failed to exec kernel&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|uml_exitcode
suffix:semicolon
)brace
multiline_comment|/* Changed in  __wrap___monstartup and __wrap_malloc very early */
DECL|variable|allocating_monbuf
r_static
r_int
id|allocating_monbuf
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef PROFILING
r_extern
r_void
id|__real___monstartup
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|__wrap___monstartup
r_void
id|__wrap___monstartup
(paren
r_int
r_int
id|lowpc
comma
r_int
r_int
id|highpc
)paren
(brace
id|allocating_monbuf
op_assign
l_int|1
suffix:semicolon
id|__real___monstartup
c_func
(paren
id|lowpc
comma
id|highpc
)paren
suffix:semicolon
id|allocating_monbuf
op_assign
l_int|0
suffix:semicolon
id|get_profile_timer
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_void
op_star
id|__real_malloc
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|host_task_size
suffix:semicolon
multiline_comment|/* Set in __wrap_malloc early */
DECL|variable|gmon_buf
r_static
r_void
op_star
id|gmon_buf
op_assign
l_int|NULL
suffix:semicolon
DECL|function|__wrap_malloc
r_void
op_star
id|__wrap_malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|allocating_monbuf
)paren
(brace
r_int
r_int
id|start
comma
id|end
suffix:semicolon
r_int
id|fd
suffix:semicolon
multiline_comment|/* Turn this off now in case create_mem_file tries allocating&n;&t;&t; * memory&n;&t;&t; */
id|allocating_monbuf
op_assign
l_int|0
suffix:semicolon
id|fd
op_assign
id|create_mem_file
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* Calculate this here because linux_main hasn&squot;t run yet&n;&t;&t; * and host_task_size figures in STACK_TOP, which figures&n;&t;&t; * in kmem_end.&n;&t;&t; */
id|set_task_sizes
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Same with stacksizelim */
id|set_stklim
c_func
(paren
)paren
suffix:semicolon
id|end
op_assign
id|get_kmem_end
c_func
(paren
)paren
suffix:semicolon
id|start
op_assign
(paren
id|end
op_minus
id|size
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|gmon_buf
op_assign
id|mmap
c_func
(paren
(paren
r_void
op_star
)paren
id|start
comma
id|size
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_SHARED
op_or
id|MAP_FIXED
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gmon_buf
op_ne
(paren
r_void
op_star
)paren
id|start
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Creating gprof buffer&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|set_kmem_end
c_func
(paren
id|start
)paren
suffix:semicolon
r_return
id|gmon_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kmalloc_ok
)paren
(brace
r_return
id|um_kmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_else
r_return
id|__real_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
DECL|function|__wrap_calloc
r_void
op_star
id|__wrap_calloc
c_func
(paren
r_int
id|n
comma
r_int
id|size
)paren
(brace
r_void
op_star
id|ptr
op_assign
id|__wrap_malloc
c_func
(paren
id|n
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|n
op_star
id|size
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
r_extern
r_void
id|__real_free
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|function|__wrap_free
r_void
id|__wrap_free
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
multiline_comment|/* Could maybe unmap the gmon buffer, but we&squot;re just about to&n;&t; * exit anyway&n;&t; */
r_if
c_cond
(paren
id|ptr
op_eq
id|gmon_buf
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kmalloc_ok
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
r_else
id|__real_free
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
