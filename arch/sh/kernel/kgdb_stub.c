multiline_comment|/*&n; * May be copied or modified under the terms of the GNU General Public&n; * License.  See linux/COPYING for more information.&n; *&n; * Containes extracts from code by Glenn Engel, Jim Kingdon,&n; * David Grothe &lt;dave@gcom.com&gt;, Tigran Aivazian &lt;tigran@sco.com&gt;,&n; * Amit S. Kale &lt;akale@veritas.com&gt;,  William Gatliff &lt;bgat@open-widgets.com&gt;,&n; * Ben Lee, Steve Chamberlain and Benoit Miller &lt;fulg@iname.com&gt;.&n; * &n; * This version by Henry Bell &lt;henry.bell@st.com&gt;&n; * Minor modifications by Jeremy Siegel &lt;jsiegel@mvista.com&gt;&n; * &n; * Contains low-level support for remote debug using GDB. &n; *&n; * To enable debugger support, two things need to happen. A call to&n; * set_debug_traps() is necessary in order to allow any breakpoints&n; * or error conditions to be properly intercepted and reported to gdb.&n; * A breakpoint also needs to be generated to begin communication.  This&n; * is most easily accomplished by a call to breakpoint() which does&n; * a trapa if the initialisation phase has been successfully completed.&n; *&n; * In this case, set_debug_traps() is not used to &quot;take over&quot; exceptions;&n; * other kernel code is modified instead to enter the kgdb functions here&n; * when appropriate (see entry.S for breakpoint traps and NMI interrupts,&n; * see traps.c for kernel error exceptions).&n; *&n; * The following gdb commands are supported:&n; *&n; *    Command       Function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *    XAA..AA,LLLL: Same, but data is binary (not hex)     OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *    CNN;          Resume at current address with signal  SNN&n; *    CNN;AA..AA    Resume at address AA..AA with signal   SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *    SNN;          Step one instruction with signal       SNN&n; *    SNNAA..AA     Step one instruction from AA..AA w/NN  SNN&n; *&n; *    k             kill (Detach GDB)&n; *&n; *    d             Toggle debug flag&n; *    D             Detach GDB &n; *&n; *    Hct           Set thread t for operations,           OK or ENN&n; *                  c = &squot;c&squot; (step, cont), c = &squot;g&squot; (other&n; *                  operations)&n; *&n; *    qC            Query current thread ID                QCpid&n; *    qfThreadInfo  Get list of current threads (first)    m&lt;id&gt;&n; *    qsThreadInfo   &quot;    &quot;  &quot;     &quot;      &quot;   (subsequent)&n; *    qOffsets      Get section offsets                  Text=x;Data=y;Bss=z&n; * &n; *    TXX           Find if thread XX is alive             OK or ENN&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *    O             Output to GDB console&n; *&n; * Remote communication protocol.&n; *&n; *    A debug packet whose contents are &lt;data&gt; is encapsulated for&n; *    transmission in the form:&n; *&n; *       $ &lt;data&gt; # CSUM1 CSUM2&n; *&n; *       &lt;data&gt; must be ASCII alphanumeric and cannot include characters&n; *       &squot;$&squot; or &squot;#&squot;.  If &lt;data&gt; starts with two characters followed by&n; *       &squot;:&squot;, then the existing stubs interpret this as a sequence number.&n; *&n; *       CSUM1 and CSUM2 are ascii hex representation of an 8-bit &n; *       checksum of &lt;data&gt;, the most significant nibble is sent first.&n; *       the hex digits 0-9,a-f are used.&n; *&n; *    Receiver responds with:&n; *&n; *       +       - if CSUM is correct and ready for next packet&n; *       -       - if CSUM is incorrect&n; *&n; * Responses can be run-length encoded to save space.  A &squot;*&squot; means that&n; * the next character is an ASCII encoding giving a repeat count which&n; * stands for that many repititions of the character preceding the &squot;*&squot;.&n; * The encoding is n+29, yielding a printable character where n &gt;=3 &n; * (which is where RLE starts to win).  Don&squot;t use an n &gt; 126. &n; *&n; * So &quot;0* &quot; means the same as &quot;0000&quot;.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/kgdb.h&gt;
macro_line|#ifdef CONFIG_SH_KGDB_CONSOLE
macro_line|#include &lt;linux/console.h&gt;
macro_line|#endif
multiline_comment|/* Function pointers for linkage */
DECL|variable|kgdb_debug_hook
id|kgdb_debug_hook_t
op_star
id|kgdb_debug_hook
suffix:semicolon
DECL|variable|kgdb_bus_err_hook
id|kgdb_bus_error_hook_t
op_star
id|kgdb_bus_err_hook
suffix:semicolon
DECL|variable|kgdb_getchar
r_int
(paren
op_star
id|kgdb_getchar
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|kgdb_putchar
r_void
(paren
op_star
id|kgdb_putchar
)paren
(paren
r_int
)paren
suffix:semicolon
DECL|function|put_debug_char
r_static
r_void
id|put_debug_char
c_func
(paren
r_int
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kgdb_putchar
)paren
r_return
suffix:semicolon
(paren
op_star
id|kgdb_putchar
)paren
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|get_debug_char
r_static
r_int
id|get_debug_char
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kgdb_getchar
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
(paren
op_star
id|kgdb_getchar
)paren
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Num chars in in/out bound buffers, register packets need NUMREGBYTES * 2 */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 1024
DECL|macro|NUMREGBYTES
mdefine_line|#define NUMREGBYTES (MAXREG*4)
DECL|macro|OUTBUFMAX
mdefine_line|#define OUTBUFMAX (NUMREGBYTES*2+512)
DECL|enum|regs
r_enum
id|regs
(brace
DECL|enumerator|R0
DECL|enumerator|R1
DECL|enumerator|R2
DECL|enumerator|R3
DECL|enumerator|R4
DECL|enumerator|R5
DECL|enumerator|R6
DECL|enumerator|R7
id|R0
op_assign
l_int|0
comma
id|R1
comma
id|R2
comma
id|R3
comma
id|R4
comma
id|R5
comma
id|R6
comma
id|R7
comma
DECL|enumerator|R8
DECL|enumerator|R9
DECL|enumerator|R10
DECL|enumerator|R11
DECL|enumerator|R12
DECL|enumerator|R13
DECL|enumerator|R14
DECL|enumerator|R15
id|R8
comma
id|R9
comma
id|R10
comma
id|R11
comma
id|R12
comma
id|R13
comma
id|R14
comma
id|R15
comma
DECL|enumerator|PC
DECL|enumerator|PR
DECL|enumerator|GBR
DECL|enumerator|VBR
DECL|enumerator|MACH
DECL|enumerator|MACL
DECL|enumerator|SR
id|PC
comma
id|PR
comma
id|GBR
comma
id|VBR
comma
id|MACH
comma
id|MACL
comma
id|SR
comma
multiline_comment|/*  */
DECL|enumerator|MAXREG
id|MAXREG
)brace
suffix:semicolon
DECL|variable|registers
r_static
r_int
r_int
id|registers
(braket
id|MAXREG
)braket
suffix:semicolon
DECL|variable|trap_registers
r_struct
id|kgdb_regs
id|trap_registers
suffix:semicolon
DECL|variable|kgdb_in_gdb_mode
r_char
id|kgdb_in_gdb_mode
suffix:semicolon
DECL|variable|in_nmi
r_char
id|in_nmi
suffix:semicolon
multiline_comment|/* Set during NMI to prevent reentry */
DECL|variable|kgdb_nofault
r_int
id|kgdb_nofault
suffix:semicolon
multiline_comment|/* Boolean to ignore bus errs (i.e. in GDB) */
DECL|variable|kgdb_enabled
r_int
id|kgdb_enabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Default to enabled, cmdline can disable */
DECL|variable|kgdb_halt
r_int
id|kgdb_halt
suffix:semicolon
multiline_comment|/* Exposed for user access */
DECL|variable|kgdb_current
r_struct
id|task_struct
op_star
id|kgdb_current
suffix:semicolon
DECL|variable|kgdb_g_imask
r_int
r_int
id|kgdb_g_imask
suffix:semicolon
DECL|variable|kgdb_trapa_val
r_int
id|kgdb_trapa_val
suffix:semicolon
DECL|variable|kgdb_excode
r_int
id|kgdb_excode
suffix:semicolon
multiline_comment|/* Default values for SCI (can override via kernel args in setup.c) */
macro_line|#ifndef CONFIG_KGDB_DEFPORT
DECL|macro|CONFIG_KGDB_DEFPORT
mdefine_line|#define CONFIG_KGDB_DEFPORT 1
macro_line|#endif
macro_line|#ifndef CONFIG_KGDB_DEFBAUD
DECL|macro|CONFIG_KGDB_DEFBAUD
mdefine_line|#define CONFIG_KGDB_DEFBAUD 115200
macro_line|#endif
macro_line|#if defined(CONFIG_KGDB_DEFPARITY_E)
DECL|macro|CONFIG_KGDB_DEFPARITY
mdefine_line|#define CONFIG_KGDB_DEFPARITY &squot;E&squot;
macro_line|#elif defined(CONFIG_KGDB_DEFPARITY_O)
DECL|macro|CONFIG_KGDB_DEFPARITY
mdefine_line|#define CONFIG_KGDB_DEFPARITY &squot;O&squot;
macro_line|#else /* CONFIG_KGDB_DEFPARITY_N */
DECL|macro|CONFIG_KGDB_DEFPARITY
mdefine_line|#define CONFIG_KGDB_DEFPARITY &squot;N&squot;
macro_line|#endif
macro_line|#ifdef CONFIG_KGDB_DEFBITS_7
DECL|macro|CONFIG_KGDB_DEFBITS
mdefine_line|#define CONFIG_KGDB_DEFBITS &squot;7&squot;
macro_line|#else /* CONFIG_KGDB_DEFBITS_8 */
DECL|macro|CONFIG_KGDB_DEFBITS
mdefine_line|#define CONFIG_KGDB_DEFBITS &squot;8&squot;
macro_line|#endif
multiline_comment|/* SCI/UART settings, used in kgdb_console_setup() */
DECL|variable|kgdb_portnum
r_int
id|kgdb_portnum
op_assign
id|CONFIG_KGDB_DEFPORT
suffix:semicolon
DECL|variable|kgdb_baud
r_int
id|kgdb_baud
op_assign
id|CONFIG_KGDB_DEFBAUD
suffix:semicolon
DECL|variable|kgdb_parity
r_char
id|kgdb_parity
op_assign
id|CONFIG_KGDB_DEFPARITY
suffix:semicolon
DECL|variable|kgdb_bits
r_char
id|kgdb_bits
op_assign
id|CONFIG_KGDB_DEFBITS
suffix:semicolon
multiline_comment|/* Jump buffer for setjmp/longjmp */
DECL|variable|rem_com_env
r_static
id|jmp_buf
id|rem_com_env
suffix:semicolon
multiline_comment|/* TRA differs sh3/4 */
macro_line|#if defined(CONFIG_CPU_SH3)
DECL|macro|TRA
mdefine_line|#define TRA 0xffffffd0
macro_line|#elif defined(CONFIG_CPU_SH4)
DECL|macro|TRA
mdefine_line|#define TRA 0xff000020
macro_line|#endif
multiline_comment|/* Macros for single step instruction identification */
DECL|macro|OPCODE_BT
mdefine_line|#define OPCODE_BT(op)         (((op) &amp; 0xff00) == 0x8900)
DECL|macro|OPCODE_BF
mdefine_line|#define OPCODE_BF(op)         (((op) &amp; 0xff00) == 0x8b00)
DECL|macro|OPCODE_BTF_DISP
mdefine_line|#define OPCODE_BTF_DISP(op)   (((op) &amp; 0x80) ? (((op) | 0xffffff80) &lt;&lt; 1) : &bslash;&n;&t;&t;&t;      (((op) &amp; 0x7f ) &lt;&lt; 1))
DECL|macro|OPCODE_BFS
mdefine_line|#define OPCODE_BFS(op)        (((op) &amp; 0xff00) == 0x8f00)
DECL|macro|OPCODE_BTS
mdefine_line|#define OPCODE_BTS(op)        (((op) &amp; 0xff00) == 0x8d00)
DECL|macro|OPCODE_BRA
mdefine_line|#define OPCODE_BRA(op)        (((op) &amp; 0xf000) == 0xa000)
DECL|macro|OPCODE_BRA_DISP
mdefine_line|#define OPCODE_BRA_DISP(op)   (((op) &amp; 0x800) ? (((op) | 0xfffff800) &lt;&lt; 1) : &bslash;&n;&t;&t;&t;      (((op) &amp; 0x7ff) &lt;&lt; 1))
DECL|macro|OPCODE_BRAF
mdefine_line|#define OPCODE_BRAF(op)       (((op) &amp; 0xf0ff) == 0x0023)
DECL|macro|OPCODE_BRAF_REG
mdefine_line|#define OPCODE_BRAF_REG(op)   (((op) &amp; 0x0f00) &gt;&gt; 8)
DECL|macro|OPCODE_BSR
mdefine_line|#define OPCODE_BSR(op)        (((op) &amp; 0xf000) == 0xb000)
DECL|macro|OPCODE_BSR_DISP
mdefine_line|#define OPCODE_BSR_DISP(op)   (((op) &amp; 0x800) ? (((op) | 0xfffff800) &lt;&lt; 1) : &bslash;&n;&t;&t;&t;      (((op) &amp; 0x7ff) &lt;&lt; 1))
DECL|macro|OPCODE_BSRF
mdefine_line|#define OPCODE_BSRF(op)       (((op) &amp; 0xf0ff) == 0x0003)
DECL|macro|OPCODE_BSRF_REG
mdefine_line|#define OPCODE_BSRF_REG(op)   (((op) &gt;&gt; 8) &amp; 0xf)
DECL|macro|OPCODE_JMP
mdefine_line|#define OPCODE_JMP(op)        (((op) &amp; 0xf0ff) == 0x402b)
DECL|macro|OPCODE_JMP_REG
mdefine_line|#define OPCODE_JMP_REG(op)    (((op) &gt;&gt; 8) &amp; 0xf)
DECL|macro|OPCODE_JSR
mdefine_line|#define OPCODE_JSR(op)        (((op) &amp; 0xf0ff) == 0x400b)
DECL|macro|OPCODE_JSR_REG
mdefine_line|#define OPCODE_JSR_REG(op)    (((op) &gt;&gt; 8) &amp; 0xf)
DECL|macro|OPCODE_RTS
mdefine_line|#define OPCODE_RTS(op)        ((op) == 0xb)
DECL|macro|OPCODE_RTE
mdefine_line|#define OPCODE_RTE(op)        ((op) == 0x2b)
DECL|macro|SR_T_BIT_MASK
mdefine_line|#define SR_T_BIT_MASK           0x1
DECL|macro|STEP_OPCODE
mdefine_line|#define STEP_OPCODE             0xc320
DECL|macro|BIOS_CALL_TRAP
mdefine_line|#define BIOS_CALL_TRAP          0x3f
multiline_comment|/* Exception codes as per SH-4 core manual */
DECL|macro|ADDRESS_ERROR_LOAD_VEC
mdefine_line|#define ADDRESS_ERROR_LOAD_VEC   7
DECL|macro|ADDRESS_ERROR_STORE_VEC
mdefine_line|#define ADDRESS_ERROR_STORE_VEC  8
DECL|macro|TRAP_VEC
mdefine_line|#define TRAP_VEC                 11
DECL|macro|INVALID_INSN_VEC
mdefine_line|#define INVALID_INSN_VEC         12
DECL|macro|INVALID_SLOT_VEC
mdefine_line|#define INVALID_SLOT_VEC         13
DECL|macro|NMI_VEC
mdefine_line|#define NMI_VEC                  14
DECL|macro|USER_BREAK_VEC
mdefine_line|#define USER_BREAK_VEC           15
DECL|macro|SERIAL_BREAK_VEC
mdefine_line|#define SERIAL_BREAK_VEC         58
multiline_comment|/* Misc static */
DECL|variable|stepped_address
r_static
r_int
id|stepped_address
suffix:semicolon
DECL|variable|stepped_opcode
r_static
r_int
id|stepped_opcode
suffix:semicolon
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
DECL|variable|in_buffer
r_static
r_char
id|in_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|out_buffer
r_static
r_char
id|out_buffer
(braket
id|OUTBUFMAX
)braket
suffix:semicolon
r_static
r_void
id|kgdb_to_gdb
c_func
(paren
r_const
r_char
op_star
id|s
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB_THREAD
DECL|variable|trapped_thread
r_static
r_struct
id|task_struct
op_star
id|trapped_thread
suffix:semicolon
DECL|variable|current_thread
r_static
r_struct
id|task_struct
op_star
id|current_thread
suffix:semicolon
DECL|typedef|threadref
r_typedef
r_int
r_char
id|threadref
(braket
l_int|8
)braket
suffix:semicolon
DECL|macro|BUF_THREAD_ID_SIZE
mdefine_line|#define BUF_THREAD_ID_SIZE 16
macro_line|#endif
multiline_comment|/* Return addr as a real volatile address */
DECL|function|ctrl_inl
r_static
r_inline
r_int
r_int
id|ctrl_inl
c_func
(paren
r_const
r_int
r_int
id|addr
)paren
(brace
r_return
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
)brace
multiline_comment|/* Correctly set *addr using volatile */
DECL|function|ctrl_outl
r_static
r_inline
r_void
id|ctrl_outl
c_func
(paren
r_const
r_int
r_int
id|b
comma
r_int
r_int
id|addr
)paren
(brace
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|addr
op_assign
id|b
suffix:semicolon
)brace
multiline_comment|/* Get high hex bits */
DECL|function|highhex
r_static
r_char
id|highhex
c_func
(paren
r_const
r_int
id|x
)paren
(brace
r_return
id|hexchars
(braket
(paren
id|x
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
multiline_comment|/* Get low hex bits */
DECL|function|lowhex
r_static
r_char
id|lowhex
c_func
(paren
r_const
r_int
id|x
)paren
(brace
r_return
id|hexchars
(braket
id|x
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
multiline_comment|/* Convert ch to hex */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_const
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;f&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;9&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;F&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert the memory pointed to by mem into hex, placing result in buf.&n;   Returns a pointer to the last char put in buf (null) */
DECL|function|mem_to_hex
r_static
r_char
op_star
id|mem_to_hex
c_func
(paren
r_const
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_const
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_int
r_int
id|s_val
suffix:semicolon
r_int
r_int
id|l_val
suffix:semicolon
multiline_comment|/* Check for 16 or 32 */
r_if
c_cond
(paren
id|count
op_eq
l_int|2
op_logical_and
(paren
(paren
r_int
)paren
id|mem
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|s_val
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|mem
suffix:semicolon
id|mem
op_assign
(paren
r_char
op_star
)paren
op_amp
id|s_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
op_eq
l_int|4
op_logical_and
(paren
(paren
r_int
)paren
id|mem
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|l_val
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|mem
suffix:semicolon
id|mem
op_assign
(paren
r_char
op_star
)paren
op_amp
id|l_val
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|mem
op_increment
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|highhex
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|lowhex
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert the hex array pointed to by buf into binary, to be placed in mem.&n;   Return a pointer to the character after the last byte written */
DECL|function|hex_to_mem
r_static
r_char
op_star
id|hex_to_mem
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_const
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_assign
id|ch
op_plus
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
op_star
id|mem
op_increment
op_assign
id|ch
suffix:semicolon
)brace
r_return
(paren
id|mem
)paren
suffix:semicolon
)brace
multiline_comment|/* While finding valid hex chars, convert to an integer, then return it */
DECL|function|hex_to_int
r_static
r_int
id|hex_to_int
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|int_value
)paren
(brace
r_int
id|num_chars
op_assign
l_int|0
suffix:semicolon
r_int
id|hex_value
suffix:semicolon
op_star
id|int_value
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hex_value
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hex_value
op_ge
l_int|0
)paren
(brace
op_star
id|int_value
op_assign
(paren
op_star
id|int_value
op_lshift
l_int|4
)paren
op_or
id|hex_value
suffix:semicolon
id|num_chars
op_increment
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
id|num_chars
suffix:semicolon
)brace
multiline_comment|/*  Copy the binary array pointed to by buf into mem.  Fix $, #,&n;    and 0x7d escaped with 0x7d.  Return a pointer to the character &n;    after the last byte written. */
DECL|function|ebin_to_mem
r_static
r_char
op_star
id|ebin_to_mem
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
comma
id|buf
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|buf
op_eq
l_int|0x7d
)paren
op_star
id|mem
op_increment
op_assign
op_star
(paren
op_increment
id|buf
)paren
op_xor
l_int|0x20
suffix:semicolon
r_else
op_star
id|mem
op_increment
op_assign
op_star
id|buf
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/* Pack a hex byte */
DECL|function|pack_hex_byte
r_static
r_char
op_star
id|pack_hex_byte
c_func
(paren
r_char
op_star
id|pkt
comma
r_int
id|byte
)paren
(brace
op_star
id|pkt
op_increment
op_assign
id|hexchars
(braket
(paren
id|byte
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|pkt
op_increment
op_assign
id|hexchars
(braket
(paren
id|byte
op_amp
l_int|0xf
)paren
)braket
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KGDB_THREAD
multiline_comment|/* Pack a thread ID */
DECL|function|pack_threadid
r_static
r_char
op_star
id|pack_threadid
c_func
(paren
r_char
op_star
id|pkt
comma
id|threadref
op_star
id|id
)paren
(brace
r_char
op_star
id|limit
suffix:semicolon
r_int
r_char
op_star
id|altid
suffix:semicolon
id|altid
op_assign
(paren
r_int
r_char
op_star
)paren
id|id
suffix:semicolon
id|limit
op_assign
id|pkt
op_plus
id|BUF_THREAD_ID_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|pkt
OL
id|limit
)paren
id|pkt
op_assign
id|pack_hex_byte
c_func
(paren
id|pkt
comma
op_star
id|altid
op_increment
)paren
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/* Convert an integer into our threadref */
DECL|function|int_to_threadref
r_static
r_void
id|int_to_threadref
c_func
(paren
id|threadref
op_star
id|id
comma
r_const
r_int
id|value
)paren
(brace
r_int
r_char
op_star
id|scan
op_assign
(paren
r_int
r_char
op_star
)paren
id|id
suffix:semicolon
r_int
id|i
op_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
op_star
id|scan
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|scan
op_increment
op_assign
(paren
id|value
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|scan
op_increment
op_assign
(paren
id|value
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|scan
op_increment
op_assign
(paren
id|value
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|scan
op_increment
op_assign
(paren
id|value
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/* Return a task structure ptr for a particular pid */
DECL|function|get_thread
r_static
r_struct
id|task_struct
op_star
id|get_thread
c_func
(paren
r_int
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|thread
suffix:semicolon
multiline_comment|/* Use PID_MAX w/gdb for pid 0 */
r_if
c_cond
(paren
id|pid
op_eq
id|PID_MAX
)paren
id|pid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* First check via PID */
id|thread
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread
)paren
r_return
id|thread
suffix:semicolon
multiline_comment|/* Start at the start */
id|thread
op_assign
id|init_tasks
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Walk along the linked list of tasks */
r_do
(brace
r_if
c_cond
(paren
id|thread-&gt;pid
op_eq
id|pid
)paren
r_return
id|thread
suffix:semicolon
id|thread
op_assign
id|thread-&gt;next_task
suffix:semicolon
)brace
r_while
c_loop
(paren
id|thread
op_ne
id|init_tasks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KGDB_THREAD */
multiline_comment|/* Scan for the start char &squot;$&squot;, read the packet and check the checksum */
DECL|function|get_packet
r_static
r_void
id|get_packet
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_char
id|ch
suffix:semicolon
r_do
(brace
multiline_comment|/* Ignore everything until the start character */
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|get_debug_char
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now, read until a # or end of buffer is found */
r_while
c_loop
(paren
id|count
OL
(paren
id|buflen
op_minus
l_int|1
)paren
)paren
(brace
id|ch
op_assign
id|get_debug_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Continue to read checksum following # */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|get_debug_char
c_func
(paren
)paren
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_add_assign
id|hex
c_func
(paren
id|get_debug_char
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Checksum */
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
id|put_debug_char
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* Failed checksum */
r_else
(brace
multiline_comment|/* Ack successful transfer */
id|put_debug_char
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* If a sequence char is present, reply &n;&t;&t;&t;&t;   the sequence ID */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|put_debug_char
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|put_debug_char
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Remove sequence chars from buffer */
id|count
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
multiline_comment|/* Keep trying while we fail */
)brace
multiline_comment|/* Send the packet in the buffer with run-length encoding */
DECL|function|put_packet
r_static
r_void
id|put_packet
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
id|checksum
suffix:semicolon
r_char
op_star
id|src
suffix:semicolon
r_int
id|runlen
suffix:semicolon
r_int
id|encode
suffix:semicolon
r_do
(brace
id|src
op_assign
id|buffer
suffix:semicolon
id|put_debug_char
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Continue while we still have chars left */
r_while
c_loop
(paren
op_star
id|src
)paren
(brace
multiline_comment|/* Check for runs up to 99 chars long */
r_for
c_loop
(paren
id|runlen
op_assign
l_int|1
suffix:semicolon
id|runlen
OL
l_int|99
suffix:semicolon
id|runlen
op_increment
)paren
(brace
r_if
c_cond
(paren
id|src
(braket
l_int|0
)braket
op_ne
id|src
(braket
id|runlen
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runlen
OG
l_int|3
)paren
(brace
multiline_comment|/* Got a useful amount, send encoding */
id|encode
op_assign
id|runlen
op_plus
l_char|&squot; &squot;
op_minus
l_int|4
suffix:semicolon
id|put_debug_char
c_func
(paren
op_star
id|src
)paren
suffix:semicolon
id|checksum
op_add_assign
op_star
id|src
suffix:semicolon
id|put_debug_char
c_func
(paren
l_char|&squot;*&squot;
)paren
suffix:semicolon
id|checksum
op_add_assign
l_char|&squot;*&squot;
suffix:semicolon
id|put_debug_char
c_func
(paren
id|encode
)paren
suffix:semicolon
id|checksum
op_add_assign
id|encode
suffix:semicolon
id|src
op_add_assign
id|runlen
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise just send the current char */
id|put_debug_char
c_func
(paren
op_star
id|src
)paren
suffix:semicolon
id|checksum
op_add_assign
op_star
id|src
suffix:semicolon
id|src
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* &squot;#&squot; Separator, put high and low components of checksum */
id|put_debug_char
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|put_debug_char
c_func
(paren
id|highhex
c_func
(paren
id|checksum
)paren
)paren
suffix:semicolon
id|put_debug_char
c_func
(paren
id|lowhex
c_func
(paren
id|checksum
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|get_debug_char
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* While no ack */
)brace
multiline_comment|/* A bus error has occurred - perform a longjmp to return execution and&n;   allow handling of the error */
DECL|function|kgdb_handle_bus_error
r_static
r_void
id|kgdb_handle_bus_error
c_func
(paren
r_void
)paren
(brace
m_longjmp
(paren
id|rem_com_env
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Translate SH-3/4 exception numbers to unix-like signal values */
DECL|function|compute_signal
r_static
r_int
id|compute_signal
c_func
(paren
r_const
r_int
id|excep_code
)paren
(brace
r_int
id|sigval
suffix:semicolon
r_switch
c_cond
(paren
id|excep_code
)paren
(brace
r_case
id|INVALID_INSN_VEC
suffix:colon
r_case
id|INVALID_SLOT_VEC
suffix:colon
id|sigval
op_assign
id|SIGILL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADDRESS_ERROR_LOAD_VEC
suffix:colon
r_case
id|ADDRESS_ERROR_STORE_VEC
suffix:colon
id|sigval
op_assign
id|SIGSEGV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SERIAL_BREAK_VEC
suffix:colon
r_case
id|NMI_VEC
suffix:colon
id|sigval
op_assign
id|SIGINT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USER_BREAK_VEC
suffix:colon
r_case
id|TRAP_VEC
suffix:colon
id|sigval
op_assign
id|SIGTRAP
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sigval
op_assign
id|SIGBUS
suffix:semicolon
multiline_comment|/* &quot;software generated&quot; */
r_break
suffix:semicolon
)brace
r_return
(paren
id|sigval
)paren
suffix:semicolon
)brace
multiline_comment|/* Make a local copy of the registers passed into the handler (bletch) */
DECL|function|kgdb_regs_to_gdb_regs
r_static
r_void
id|kgdb_regs_to_gdb_regs
c_func
(paren
r_const
r_struct
id|kgdb_regs
op_star
id|regs
comma
r_int
op_star
id|gdb_regs
)paren
(brace
id|gdb_regs
(braket
id|R0
)braket
op_assign
id|regs-&gt;regs
(braket
id|R0
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R1
)braket
op_assign
id|regs-&gt;regs
(braket
id|R1
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R2
)braket
op_assign
id|regs-&gt;regs
(braket
id|R2
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R3
)braket
op_assign
id|regs-&gt;regs
(braket
id|R3
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R4
)braket
op_assign
id|regs-&gt;regs
(braket
id|R4
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R5
)braket
op_assign
id|regs-&gt;regs
(braket
id|R5
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R6
)braket
op_assign
id|regs-&gt;regs
(braket
id|R6
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R7
)braket
op_assign
id|regs-&gt;regs
(braket
id|R7
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R8
)braket
op_assign
id|regs-&gt;regs
(braket
id|R8
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R9
)braket
op_assign
id|regs-&gt;regs
(braket
id|R9
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R10
)braket
op_assign
id|regs-&gt;regs
(braket
id|R10
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R11
)braket
op_assign
id|regs-&gt;regs
(braket
id|R11
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R12
)braket
op_assign
id|regs-&gt;regs
(braket
id|R12
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R13
)braket
op_assign
id|regs-&gt;regs
(braket
id|R13
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R14
)braket
op_assign
id|regs-&gt;regs
(braket
id|R14
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R15
)braket
op_assign
id|regs-&gt;regs
(braket
id|R15
)braket
suffix:semicolon
id|gdb_regs
(braket
id|PC
)braket
op_assign
id|regs-&gt;pc
suffix:semicolon
id|gdb_regs
(braket
id|PR
)braket
op_assign
id|regs-&gt;pr
suffix:semicolon
id|gdb_regs
(braket
id|GBR
)braket
op_assign
id|regs-&gt;gbr
suffix:semicolon
id|gdb_regs
(braket
id|MACH
)braket
op_assign
id|regs-&gt;mach
suffix:semicolon
id|gdb_regs
(braket
id|MACL
)braket
op_assign
id|regs-&gt;macl
suffix:semicolon
id|gdb_regs
(braket
id|SR
)braket
op_assign
id|regs-&gt;sr
suffix:semicolon
id|gdb_regs
(braket
id|VBR
)braket
op_assign
id|regs-&gt;vbr
suffix:semicolon
)brace
multiline_comment|/* Copy local gdb registers back to kgdb regs, for later copy to kernel */
DECL|function|gdb_regs_to_kgdb_regs
r_static
r_void
id|gdb_regs_to_kgdb_regs
c_func
(paren
r_const
r_int
op_star
id|gdb_regs
comma
r_struct
id|kgdb_regs
op_star
id|regs
)paren
(brace
id|regs-&gt;regs
(braket
id|R0
)braket
op_assign
id|gdb_regs
(braket
id|R0
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R1
)braket
op_assign
id|gdb_regs
(braket
id|R1
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R2
)braket
op_assign
id|gdb_regs
(braket
id|R2
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R3
)braket
op_assign
id|gdb_regs
(braket
id|R3
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R4
)braket
op_assign
id|gdb_regs
(braket
id|R4
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R5
)braket
op_assign
id|gdb_regs
(braket
id|R5
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R6
)braket
op_assign
id|gdb_regs
(braket
id|R6
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R7
)braket
op_assign
id|gdb_regs
(braket
id|R7
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R8
)braket
op_assign
id|gdb_regs
(braket
id|R8
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R9
)braket
op_assign
id|gdb_regs
(braket
id|R9
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R10
)braket
op_assign
id|gdb_regs
(braket
id|R10
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R11
)braket
op_assign
id|gdb_regs
(braket
id|R11
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R12
)braket
op_assign
id|gdb_regs
(braket
id|R12
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R13
)braket
op_assign
id|gdb_regs
(braket
id|R13
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R14
)braket
op_assign
id|gdb_regs
(braket
id|R14
)braket
suffix:semicolon
id|regs-&gt;regs
(braket
id|R15
)braket
op_assign
id|gdb_regs
(braket
id|R15
)braket
suffix:semicolon
id|regs-&gt;pc
op_assign
id|gdb_regs
(braket
id|PC
)braket
suffix:semicolon
id|regs-&gt;pr
op_assign
id|gdb_regs
(braket
id|PR
)braket
suffix:semicolon
id|regs-&gt;gbr
op_assign
id|gdb_regs
(braket
id|GBR
)braket
suffix:semicolon
id|regs-&gt;mach
op_assign
id|gdb_regs
(braket
id|MACH
)braket
suffix:semicolon
id|regs-&gt;macl
op_assign
id|gdb_regs
(braket
id|MACL
)braket
suffix:semicolon
id|regs-&gt;sr
op_assign
id|gdb_regs
(braket
id|SR
)braket
suffix:semicolon
id|regs-&gt;vbr
op_assign
id|gdb_regs
(braket
id|VBR
)braket
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KGDB_THREAD
multiline_comment|/* Make a local copy of registers from the specified thread */
id|asmlinkage
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|thread_regs_to_gdb_regs
r_static
r_void
id|thread_regs_to_gdb_regs
c_func
(paren
r_const
r_struct
id|task_struct
op_star
id|thread
comma
r_int
op_star
id|gdb_regs
)paren
(brace
r_int
id|regno
suffix:semicolon
r_int
op_star
id|tregs
suffix:semicolon
multiline_comment|/* Initialize to zero */
r_for
c_loop
(paren
id|regno
op_assign
l_int|0
suffix:semicolon
id|regno
OL
id|MAXREG
suffix:semicolon
id|regno
op_increment
)paren
id|gdb_regs
(braket
id|regno
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Just making sure... */
r_if
c_cond
(paren
id|thread
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* A new fork has pt_regs on the stack from a fork() call */
r_if
c_cond
(paren
id|thread-&gt;thread.pc
op_eq
(paren
r_int
r_int
)paren
id|ret_from_fork
)paren
(brace
r_int
id|vbr_val
suffix:semicolon
r_struct
id|pt_regs
op_star
id|kregs
suffix:semicolon
id|kregs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|thread-&gt;thread.sp
suffix:semicolon
id|gdb_regs
(braket
id|R0
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R0
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R1
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R1
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R2
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R2
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R3
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R3
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R4
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R4
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R5
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R5
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R6
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R6
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R7
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R7
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R8
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R8
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R9
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R9
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R10
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R10
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R11
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R11
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R12
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R12
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R13
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R13
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R14
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R14
)braket
suffix:semicolon
id|gdb_regs
(braket
id|R15
)braket
op_assign
id|kregs-&gt;regs
(braket
id|R15
)braket
suffix:semicolon
id|gdb_regs
(braket
id|PC
)braket
op_assign
id|kregs-&gt;pc
suffix:semicolon
id|gdb_regs
(braket
id|PR
)braket
op_assign
id|kregs-&gt;pr
suffix:semicolon
id|gdb_regs
(braket
id|GBR
)braket
op_assign
id|kregs-&gt;gbr
suffix:semicolon
id|gdb_regs
(braket
id|MACH
)braket
op_assign
id|kregs-&gt;mach
suffix:semicolon
id|gdb_regs
(braket
id|MACL
)braket
op_assign
id|kregs-&gt;macl
suffix:semicolon
id|gdb_regs
(braket
id|SR
)braket
op_assign
id|kregs-&gt;sr
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;stc vbr, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|vbr_val
)paren
)paren
suffix:semicolon
id|gdb_regs
(braket
id|VBR
)braket
op_assign
id|vbr_val
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise, we have only some registers from switch_to() */
id|tregs
op_assign
(paren
r_int
op_star
)paren
id|thread-&gt;thread.sp
suffix:semicolon
id|gdb_regs
(braket
id|R15
)braket
op_assign
(paren
r_int
)paren
id|tregs
suffix:semicolon
id|gdb_regs
(braket
id|R14
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R13
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R12
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R11
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R10
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R9
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|R8
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|PR
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|GBR
)braket
op_assign
op_star
id|tregs
op_increment
suffix:semicolon
id|gdb_regs
(braket
id|PC
)braket
op_assign
id|thread-&gt;thread.pc
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KGDB_THREAD */
multiline_comment|/* Calculate the new address for after a step */
DECL|function|get_step_address
r_static
r_int
op_star
id|get_step_address
c_func
(paren
r_void
)paren
(brace
r_int
id|op
op_assign
op_star
(paren
r_int
op_star
)paren
id|trap_registers.pc
suffix:semicolon
r_int
id|addr
suffix:semicolon
multiline_comment|/* BT */
r_if
c_cond
(paren
id|OPCODE_BT
c_func
(paren
id|op
)paren
)paren
(brace
r_if
c_cond
(paren
id|trap_registers.sr
op_amp
id|SR_T_BIT_MASK
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BTF_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
r_else
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|2
suffix:semicolon
)brace
multiline_comment|/* BTS */
r_else
r_if
c_cond
(paren
id|OPCODE_BTS
c_func
(paren
id|op
)paren
)paren
(brace
r_if
c_cond
(paren
id|trap_registers.sr
op_amp
id|SR_T_BIT_MASK
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BTF_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
r_else
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
suffix:semicolon
multiline_comment|/* Not in delay slot */
)brace
multiline_comment|/* BF */
r_else
r_if
c_cond
(paren
id|OPCODE_BF
c_func
(paren
id|op
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|trap_registers.sr
op_amp
id|SR_T_BIT_MASK
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BTF_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
r_else
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|2
suffix:semicolon
)brace
multiline_comment|/* BFS */
r_else
r_if
c_cond
(paren
id|OPCODE_BFS
c_func
(paren
id|op
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|trap_registers.sr
op_amp
id|SR_T_BIT_MASK
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BTF_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
r_else
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
suffix:semicolon
multiline_comment|/* Not in delay slot */
)brace
multiline_comment|/* BRA */
r_else
r_if
c_cond
(paren
id|OPCODE_BRA
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BRA_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/* BRAF */
r_else
r_if
c_cond
(paren
id|OPCODE_BRAF
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|trap_registers.regs
(braket
id|OPCODE_BRAF_REG
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
multiline_comment|/* BSR */
r_else
r_if
c_cond
(paren
id|OPCODE_BSR
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|OPCODE_BSR_DISP
c_func
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/* BSRF */
r_else
r_if
c_cond
(paren
id|OPCODE_BSRF
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|4
op_plus
id|trap_registers.regs
(braket
id|OPCODE_BSRF_REG
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
multiline_comment|/* JMP */
r_else
r_if
c_cond
(paren
id|OPCODE_JMP
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.regs
(braket
id|OPCODE_JMP_REG
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
multiline_comment|/* JSR */
r_else
r_if
c_cond
(paren
id|OPCODE_JSR
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.regs
(braket
id|OPCODE_JSR_REG
c_func
(paren
id|op
)paren
)braket
suffix:semicolon
multiline_comment|/* RTS */
r_else
r_if
c_cond
(paren
id|OPCODE_RTS
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.pr
suffix:semicolon
multiline_comment|/* RTE */
r_else
r_if
c_cond
(paren
id|OPCODE_RTE
c_func
(paren
id|op
)paren
)paren
id|addr
op_assign
id|trap_registers.regs
(braket
l_int|15
)braket
suffix:semicolon
multiline_comment|/* Other */
r_else
id|addr
op_assign
id|trap_registers.pc
op_plus
l_int|2
suffix:semicolon
id|kgdb_flush_icache_range
c_func
(paren
id|addr
comma
id|addr
op_plus
l_int|2
)paren
suffix:semicolon
r_return
(paren
r_int
op_star
)paren
id|addr
suffix:semicolon
)brace
multiline_comment|/* Set up a single-step.  Replace the instruction immediately after the &n;   current instruction (i.e. next in the expected flow of control) with a&n;   trap instruction, so that returning will cause only a single instruction&n;   to be executed. Note that this model is slightly broken for instructions&n;   with delay slots (e.g. B[TF]S, BSR, BRA etc), where both the branch&n;   and the instruction in the delay slot will be executed. */
DECL|function|do_single_step
r_static
r_void
id|do_single_step
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Determine where the target instruction will send us to */
id|addr
op_assign
id|get_step_address
c_func
(paren
)paren
suffix:semicolon
id|stepped_address
op_assign
(paren
r_int
)paren
id|addr
suffix:semicolon
multiline_comment|/* Replace it */
id|stepped_opcode
op_assign
op_star
(paren
r_int
op_star
)paren
id|addr
suffix:semicolon
op_star
id|addr
op_assign
id|STEP_OPCODE
suffix:semicolon
multiline_comment|/* Flush and return */
id|kgdb_flush_icache_range
c_func
(paren
(paren
r_int
)paren
id|addr
comma
(paren
r_int
)paren
id|addr
op_plus
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Undo a single step */
DECL|function|undo_single_step
r_static
r_void
id|undo_single_step
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* If we have stepped, put back the old instruction */
multiline_comment|/* Use stepped_address in case we stopped elsewhere */
r_if
c_cond
(paren
id|stepped_opcode
op_ne
l_int|0
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|stepped_address
op_assign
id|stepped_opcode
suffix:semicolon
id|kgdb_flush_icache_range
c_func
(paren
id|stepped_address
comma
id|stepped_address
op_plus
l_int|2
)paren
suffix:semicolon
)brace
id|stepped_opcode
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a signal message */
DECL|function|send_signal_msg
r_static
r_void
id|send_signal_msg
c_func
(paren
r_const
r_int
id|signum
)paren
(brace
macro_line|#ifndef CONFIG_KGDB_THREAD
id|out_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|out_buffer
(braket
l_int|1
)braket
op_assign
id|highhex
c_func
(paren
id|signum
)paren
suffix:semicolon
id|out_buffer
(braket
l_int|2
)braket
op_assign
id|lowhex
c_func
(paren
id|signum
)paren
suffix:semicolon
id|out_buffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
macro_line|#else /* CONFIG_KGDB_THREAD */
r_int
id|threadid
suffix:semicolon
id|threadref
id|thref
suffix:semicolon
r_char
op_star
id|out
op_assign
id|out_buffer
suffix:semicolon
r_const
r_char
op_star
id|tstring
op_assign
l_string|&quot;thread&quot;
suffix:semicolon
op_star
id|out
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|highhex
c_func
(paren
id|signum
)paren
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|lowhex
c_func
(paren
id|signum
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tstring
)paren
(brace
op_star
id|out
op_increment
op_assign
op_star
id|tstring
op_increment
suffix:semicolon
)brace
op_star
id|out
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|threadid
op_assign
id|trapped_thread-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
id|threadid
op_eq
l_int|0
)paren
id|threadid
op_assign
id|PID_MAX
suffix:semicolon
id|int_to_threadref
c_func
(paren
op_amp
id|thref
comma
id|threadid
)paren
suffix:semicolon
id|pack_threadid
c_func
(paren
id|out
comma
op_amp
id|thref
)paren
suffix:semicolon
id|out
op_add_assign
id|BUF_THREAD_ID_SIZE
suffix:semicolon
op_star
id|out
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
op_star
id|out
op_assign
l_int|0
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_KGDB_THREAD */
)brace
multiline_comment|/* Reply that all was well */
DECL|function|send_ok_msg
r_static
r_void
id|send_ok_msg
c_func
(paren
r_void
)paren
(brace
id|strcpy
c_func
(paren
id|out_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Reply that an error occurred */
DECL|function|send_err_msg
r_static
r_void
id|send_err_msg
c_func
(paren
r_void
)paren
(brace
id|strcpy
c_func
(paren
id|out_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Empty message indicates unrecognised command */
DECL|function|send_empty_msg
r_static
r_void
id|send_empty_msg
c_func
(paren
r_void
)paren
(brace
id|put_packet
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Read memory due to &squot;m&squot; message */
DECL|function|read_mem_msg
r_static
r_void
id|read_mem_msg
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
multiline_comment|/* Jmp, disable bus error handler */
r_if
c_cond
(paren
m_setjmp
(paren
id|rem_com_env
)paren
op_eq
l_int|0
)paren
(brace
id|kgdb_nofault
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Walk through, have m&lt;addr&gt;,&lt;length&gt; */
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
(paren
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
)paren
)paren
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
id|ptr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|length
op_star
l_int|2
OG
id|OUTBUFMAX
)paren
id|length
op_assign
id|OUTBUFMAX
op_div
l_int|2
suffix:semicolon
id|mem_to_hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|out_buffer
comma
id|length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
)paren
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
r_else
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
r_else
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore bus error handler */
id|kgdb_nofault
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write memory due to &squot;M&squot; or &squot;X&squot; message */
DECL|function|write_mem_msg
r_static
r_void
id|write_mem_msg
c_func
(paren
r_int
id|binary
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|rem_com_env
)paren
op_eq
l_int|0
)paren
(brace
id|kgdb_nofault
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Walk through, have M&lt;addr&gt;,&lt;length&gt;:&lt;data&gt; */
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
(paren
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
)paren
)paren
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
(paren
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|binary
)paren
id|ebin_to_mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
)paren
suffix:semicolon
r_else
id|hex_to_mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
)paren
suffix:semicolon
id|kgdb_flush_icache_range
c_func
(paren
id|addr
comma
id|addr
op_plus
id|length
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
)paren
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore bus error handler */
id|kgdb_nofault
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Continue message  */
DECL|function|continue_msg
r_static
r_void
id|continue_msg
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Try to read optional parameter, PC unchanged if none */
r_char
op_star
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|trap_registers.pc
op_assign
id|addr
suffix:semicolon
)brace
multiline_comment|/* Continue message with signal */
DECL|function|continue_with_sig_msg
r_static
r_void
id|continue_with_sig_msg
c_func
(paren
r_void
)paren
(brace
r_int
id|signal
suffix:semicolon
r_char
op_star
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|addr
suffix:semicolon
multiline_comment|/* Report limitation */
id|kgdb_to_gdb
c_func
(paren
l_string|&quot;Cannot force signal in kgdb, continuing anyway.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Signal */
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|signal
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;;&squot;
)paren
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Optional address */
r_if
c_cond
(paren
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|trap_registers.pc
op_assign
id|addr
suffix:semicolon
)brace
multiline_comment|/* Step message */
DECL|function|step_msg
r_static
r_void
id|step_msg
c_func
(paren
r_void
)paren
(brace
id|continue_msg
c_func
(paren
)paren
suffix:semicolon
id|do_single_step
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Step message with signal */
DECL|function|step_with_sig_msg
r_static
r_void
id|step_with_sig_msg
c_func
(paren
r_void
)paren
(brace
id|continue_with_sig_msg
c_func
(paren
)paren
suffix:semicolon
id|do_single_step
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send register contents */
DECL|function|send_regs_msg
r_static
r_void
id|send_regs_msg
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_KGDB_THREAD
r_if
c_cond
(paren
op_logical_neg
id|current_thread
)paren
id|kgdb_regs_to_gdb_regs
c_func
(paren
op_amp
id|trap_registers
comma
id|registers
)paren
suffix:semicolon
r_else
id|thread_regs_to_gdb_regs
c_func
(paren
id|current_thread
comma
id|registers
)paren
suffix:semicolon
macro_line|#else
id|kgdb_regs_to_gdb_regs
c_func
(paren
op_amp
id|trap_registers
comma
id|registers
)paren
suffix:semicolon
macro_line|#endif
id|mem_to_hex
c_func
(paren
(paren
r_char
op_star
)paren
id|registers
comma
id|out_buffer
comma
id|NUMREGBYTES
)paren
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Set register contents - currently can&squot;t set other thread&squot;s registers */
DECL|function|set_regs_msg
r_static
r_void
id|set_regs_msg
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_KGDB_THREAD
r_if
c_cond
(paren
op_logical_neg
id|current_thread
)paren
(brace
macro_line|#endif
id|kgdb_regs_to_gdb_regs
c_func
(paren
op_amp
id|trap_registers
comma
id|registers
)paren
suffix:semicolon
id|hex_to_mem
c_func
(paren
op_amp
id|in_buffer
(braket
l_int|1
)braket
comma
(paren
r_char
op_star
)paren
id|registers
comma
id|NUMREGBYTES
)paren
suffix:semicolon
id|gdb_regs_to_kgdb_regs
c_func
(paren
id|registers
comma
op_amp
id|trap_registers
)paren
suffix:semicolon
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB_THREAD
)brace
r_else
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_KGDB_THREAD
multiline_comment|/* Set the status for a thread */
DECL|function|set_thread_msg
r_void
id|set_thread_msg
c_func
(paren
r_void
)paren
(brace
r_int
id|threadid
suffix:semicolon
r_struct
id|task_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_switch
c_cond
(paren
id|in_buffer
(braket
l_int|1
)braket
)paren
(brace
multiline_comment|/* To select which thread for gG etc messages, i.e. supported */
r_case
l_char|&squot;g&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|2
)braket
suffix:semicolon
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|threadid
)paren
suffix:semicolon
id|thread
op_assign
id|get_thread
c_func
(paren
id|threadid
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t found it */
r_if
c_cond
(paren
op_logical_neg
id|thread
)paren
(brace
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Set current_thread (or not) */
r_if
c_cond
(paren
id|thread
op_eq
id|trapped_thread
)paren
id|current_thread
op_assign
l_int|NULL
suffix:semicolon
r_else
id|current_thread
op_assign
id|thread
suffix:semicolon
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* To select which thread for cCsS messages, i.e. unsupported */
r_case
l_char|&squot;c&squot;
suffix:colon
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|send_empty_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Is a thread alive? */
DECL|function|thread_status_msg
r_static
r_void
id|thread_status_msg
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|threadid
suffix:semicolon
r_struct
id|task_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|threadid
)paren
suffix:semicolon
id|thread
op_assign
id|get_thread
c_func
(paren
id|threadid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread
)paren
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
r_else
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send the current thread ID */
DECL|function|thread_id_msg
r_static
r_void
id|thread_id_msg
c_func
(paren
r_void
)paren
(brace
r_int
id|threadid
suffix:semicolon
id|threadref
id|thref
suffix:semicolon
id|out_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;Q&squot;
suffix:semicolon
id|out_buffer
(braket
l_int|1
)braket
op_assign
l_char|&squot;C&squot;
suffix:semicolon
r_if
c_cond
(paren
id|current_thread
)paren
id|threadid
op_assign
id|current_thread-&gt;pid
suffix:semicolon
r_else
r_if
c_cond
(paren
id|trapped_thread
)paren
id|threadid
op_assign
id|trapped_thread-&gt;pid
suffix:semicolon
r_else
multiline_comment|/* Impossible, but just in case! */
(brace
id|send_err_msg
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Translate pid 0 to PID_MAX for gdb */
r_if
c_cond
(paren
id|threadid
op_eq
l_int|0
)paren
id|threadid
op_assign
id|PID_MAX
suffix:semicolon
id|int_to_threadref
c_func
(paren
op_amp
id|thref
comma
id|threadid
)paren
suffix:semicolon
id|pack_threadid
c_func
(paren
id|out_buffer
op_plus
l_int|2
comma
op_amp
id|thref
)paren
suffix:semicolon
id|out_buffer
(braket
l_int|2
op_plus
id|BUF_THREAD_ID_SIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Send thread info */
DECL|function|thread_info_msg
r_static
r_void
id|thread_info_msg
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_int
id|threadid
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
id|threadref
id|thref
suffix:semicolon
multiline_comment|/* Start with &squot;m&squot; */
id|out_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;m&squot;
suffix:semicolon
id|pos
op_assign
op_amp
id|out_buffer
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* For all possible thread IDs - this will overrun if &gt; 44 threads! */
multiline_comment|/* Start at 1 and include PID_MAX (since GDB won&squot;t use pid 0...) */
r_for
c_loop
(paren
id|threadid
op_assign
l_int|1
suffix:semicolon
id|threadid
op_le
id|PID_MAX
suffix:semicolon
id|threadid
op_increment
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|thread
op_assign
id|get_thread
c_func
(paren
id|threadid
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/* If it&squot;s a valid thread */
r_if
c_cond
(paren
id|thread
)paren
(brace
id|int_to_threadref
c_func
(paren
op_amp
id|thref
comma
id|threadid
)paren
suffix:semicolon
id|pack_threadid
c_func
(paren
id|pos
comma
op_amp
id|thref
)paren
suffix:semicolon
id|pos
op_add_assign
id|BUF_THREAD_ID_SIZE
suffix:semicolon
op_star
id|pos
op_increment
op_assign
l_char|&squot;,&squot;
suffix:semicolon
)brace
)brace
op_star
op_decrement
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Lose final comma */
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Return printable info for gdb&squot;s &squot;info threads&squot; command */
DECL|function|thread_extra_info_msg
r_static
r_void
id|thread_extra_info_msg
c_func
(paren
r_void
)paren
(brace
r_int
id|threadid
suffix:semicolon
r_struct
id|task_struct
op_star
id|thread
op_assign
l_int|NULL
suffix:semicolon
r_char
id|buffer
(braket
l_int|20
)braket
comma
op_star
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Extract thread ID */
id|ptr
op_assign
op_amp
id|in_buffer
(braket
l_int|17
)braket
suffix:semicolon
id|hex_to_int
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|threadid
)paren
suffix:semicolon
id|thread
op_assign
id|get_thread
c_func
(paren
id|threadid
)paren
suffix:semicolon
multiline_comment|/* If we don&squot;t recognise it, say so */
r_if
c_cond
(paren
id|thread
op_eq
l_int|NULL
)paren
id|strcpy
c_func
(paren
id|buffer
comma
l_string|&quot;(unknown)&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|buffer
comma
id|thread-&gt;comm
)paren
suffix:semicolon
multiline_comment|/* Construct packet */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ptr
op_assign
id|out_buffer
suffix:semicolon
id|buffer
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|ptr
op_assign
id|pack_hex_byte
c_func
(paren
id|ptr
comma
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread-&gt;thread.pc
op_eq
(paren
r_int
r_int
)paren
id|ret_from_fork
)paren
(brace
id|strcpy
c_func
(paren
id|buffer
comma
l_string|&quot;&lt;new fork&gt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|ptr
op_assign
id|pack_hex_byte
c_func
(paren
id|ptr
comma
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
op_star
id|ptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|put_packet
c_func
(paren
id|out_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle all qFooBarBaz messages - have to use an if statement as&n;   opposed to a switch because q messages can have &gt; 1 char id. */
DECL|function|query_msg
r_static
r_void
id|query_msg
c_func
(paren
r_void
)paren
(brace
r_const
r_char
op_star
id|q_start
op_assign
op_amp
id|in_buffer
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* qC = return current thread ID */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|q_start
comma
l_string|&quot;C&quot;
comma
l_int|1
)paren
op_eq
l_int|0
)paren
id|thread_id_msg
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* qfThreadInfo = query all threads (first) */
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|q_start
comma
l_string|&quot;fThreadInfo&quot;
comma
l_int|11
)paren
op_eq
l_int|0
)paren
id|thread_info_msg
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* qsThreadInfo = query all threads (subsequent). We know we have sent&n;&t;   them all after the qfThreadInfo message, so there are no to send */
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|q_start
comma
l_string|&quot;sThreadInfo&quot;
comma
l_int|11
)paren
op_eq
l_int|0
)paren
id|put_packet
c_func
(paren
l_string|&quot;l&quot;
)paren
suffix:semicolon
multiline_comment|/* el = last */
multiline_comment|/* qThreadExtraInfo = supply printable information per thread */
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|q_start
comma
l_string|&quot;ThreadExtraInfo&quot;
comma
l_int|15
)paren
op_eq
l_int|0
)paren
id|thread_extra_info_msg
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Unsupported - empty message as per spec */
r_else
id|send_empty_msg
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KGDB_THREAD */
multiline_comment|/*&n; * Bring up the ports..&n; */
DECL|function|kgdb_serial_setup
r_static
r_int
id|kgdb_serial_setup
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|kgdb_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
suffix:semicolon
r_struct
id|console
id|dummy
suffix:semicolon
id|kgdb_console_setup
c_func
(paren
op_amp
id|dummy
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The command loop, read and act on requests */
DECL|function|kgdb_command_loop
r_static
r_void
id|kgdb_command_loop
c_func
(paren
r_const
r_int
id|excep_code
comma
r_const
r_int
id|trapa_value
)paren
(brace
r_int
id|sigval
suffix:semicolon
r_if
c_cond
(paren
id|excep_code
op_eq
id|NMI_VEC
)paren
(brace
macro_line|#ifndef CONFIG_KGDB_NMI
id|KGDB_PRINTK
c_func
(paren
l_string|&quot;Ignoring unexpected NMI?&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else /* CONFIG_KGDB_NMI */
r_if
c_cond
(paren
op_logical_neg
id|kgdb_enabled
)paren
(brace
id|kgdb_enabled
op_assign
l_int|1
suffix:semicolon
id|kgdb_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KGDB_NMI */
)brace
multiline_comment|/* Ignore if we&squot;re disabled */
r_if
c_cond
(paren
op_logical_neg
id|kgdb_enabled
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB_THREAD
multiline_comment|/* Until GDB specifies a thread */
id|current_thread
op_assign
l_int|NULL
suffix:semicolon
id|trapped_thread
op_assign
id|current
suffix:semicolon
macro_line|#endif
multiline_comment|/* Enter GDB mode (e.g. after detach) */
r_if
c_cond
(paren
op_logical_neg
id|kgdb_in_gdb_mode
)paren
(brace
multiline_comment|/* Do serial setup, notify user, issue preemptive ack */
id|kgdb_serial_setup
c_func
(paren
)paren
suffix:semicolon
id|KGDB_PRINTK
c_func
(paren
l_string|&quot;Waiting for GDB (on %s%d at %d baud)&bslash;n&quot;
comma
(paren
id|kgdb_porttype
ques
c_cond
id|kgdb_porttype-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|kgdb_portnum
comma
id|kgdb_baud
)paren
suffix:semicolon
id|kgdb_in_gdb_mode
op_assign
l_int|1
suffix:semicolon
id|put_debug_char
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Reply to host that an exception has occurred */
id|sigval
op_assign
id|compute_signal
c_func
(paren
id|excep_code
)paren
suffix:semicolon
id|send_signal_msg
c_func
(paren
id|sigval
)paren
suffix:semicolon
multiline_comment|/* TRAP_VEC exception indicates a software trap inserted in place of&n;&t;   code by GDB so back up PC by one instruction, as this instruction&n;&t;   will later be replaced by its original one.  Do NOT do this for&n;&t;   trap 0xff, since that indicates a compiled-in breakpoint which&n;&t;   will not be replaced (and we would retake the trap forever) */
r_if
c_cond
(paren
(paren
id|excep_code
op_eq
id|TRAP_VEC
)paren
op_logical_and
(paren
id|trapa_value
op_ne
(paren
l_int|0xff
op_lshift
l_int|2
)paren
)paren
)paren
(brace
id|trap_registers.pc
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Undo any stepping we may have done */
id|undo_single_step
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|out_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|get_packet
c_func
(paren
id|in_buffer
comma
id|BUFMAX
)paren
suffix:semicolon
multiline_comment|/* Examine first char of buffer to see what we need to do */
r_switch
c_cond
(paren
id|in_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;?&squot;
suffix:colon
multiline_comment|/* Send which signal we&squot;ve received */
id|send_signal_msg
c_func
(paren
id|sigval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;g&squot;
suffix:colon
multiline_comment|/* Return the values of the CPU registers */
id|send_regs_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
multiline_comment|/* Set the value of the CPU registers */
id|set_regs_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
multiline_comment|/* Read LLLL bytes address AA..AA */
id|read_mem_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
multiline_comment|/* Write LLLL bytes address AA..AA, ret OK */
id|write_mem_msg
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 = data in hex */
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
multiline_comment|/* Write LLLL bytes esc bin address AA..AA */
r_if
c_cond
(paren
id|kgdb_bits
op_eq
l_char|&squot;8&squot;
)paren
id|write_mem_msg
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 = data in binary */
r_else
id|send_empty_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
multiline_comment|/* Continue, signum included, we ignore it */
id|continue_with_sig_msg
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* Continue at address AA..AA (optional) */
id|continue_msg
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
multiline_comment|/* Step, signum included, we ignore it */
id|step_with_sig_msg
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* Step one instruction from AA..AA */
id|step_msg
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB_THREAD
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* Task related */
id|set_thread_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* Query thread status */
id|thread_status_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
multiline_comment|/* Handle query - currently thread-related */
id|query_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_char|&squot;k&squot;
suffix:colon
multiline_comment|/* &squot;Kill the program&squot; with a kernel ? */
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* Detach from program, send reply OK */
id|kgdb_in_gdb_mode
op_assign
l_int|0
suffix:semicolon
id|send_ok_msg
c_func
(paren
)paren
suffix:semicolon
id|get_debug_char
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|send_empty_msg
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* There has been an exception, most likely a breakpoint. */
DECL|function|kgdb_handle_exception
r_void
id|kgdb_handle_exception
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|excep_code
comma
id|vbr_val
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|trapa_value
op_assign
id|ctrl_inl
c_func
(paren
id|TRA
)paren
suffix:semicolon
multiline_comment|/* Copy kernel regs (from stack) */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|16
suffix:semicolon
id|count
op_increment
)paren
id|trap_registers.regs
(braket
id|count
)braket
op_assign
id|regs-&gt;regs
(braket
id|count
)braket
suffix:semicolon
id|trap_registers.pc
op_assign
id|regs-&gt;pc
suffix:semicolon
id|trap_registers.pr
op_assign
id|regs-&gt;pr
suffix:semicolon
id|trap_registers.sr
op_assign
id|regs-&gt;sr
suffix:semicolon
id|trap_registers.gbr
op_assign
id|regs-&gt;gbr
suffix:semicolon
id|trap_registers.mach
op_assign
id|regs-&gt;mach
suffix:semicolon
id|trap_registers.macl
op_assign
id|regs-&gt;macl
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;stc vbr, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|vbr_val
)paren
)paren
suffix:semicolon
id|trap_registers.vbr
op_assign
id|vbr_val
suffix:semicolon
multiline_comment|/* Get excode for command loop call, user access */
id|asm
c_func
(paren
l_string|&quot;stc r2_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|excep_code
)paren
)paren
suffix:semicolon
id|kgdb_excode
op_assign
id|excep_code
suffix:semicolon
multiline_comment|/* Other interesting environment items for reference */
id|asm
c_func
(paren
l_string|&quot;stc r6_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|kgdb_g_imask
)paren
)paren
suffix:semicolon
id|kgdb_current
op_assign
id|current
suffix:semicolon
id|kgdb_trapa_val
op_assign
id|trapa_value
suffix:semicolon
multiline_comment|/* Act on the exception */
id|kgdb_command_loop
c_func
(paren
id|excep_code
op_rshift
l_int|5
comma
id|trapa_value
)paren
suffix:semicolon
id|kgdb_current
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Copy back the (maybe modified) registers */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|16
suffix:semicolon
id|count
op_increment
)paren
id|regs-&gt;regs
(braket
id|count
)braket
op_assign
id|trap_registers.regs
(braket
id|count
)braket
suffix:semicolon
id|regs-&gt;pc
op_assign
id|trap_registers.pc
suffix:semicolon
id|regs-&gt;pr
op_assign
id|trap_registers.pr
suffix:semicolon
id|regs-&gt;sr
op_assign
id|trap_registers.sr
suffix:semicolon
id|regs-&gt;gbr
op_assign
id|trap_registers.gbr
suffix:semicolon
id|regs-&gt;mach
op_assign
id|trap_registers.mach
suffix:semicolon
id|regs-&gt;macl
op_assign
id|trap_registers.macl
suffix:semicolon
id|vbr_val
op_assign
id|trap_registers.vbr
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;ldc %0, vbr&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|vbr_val
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Trigger a breakpoint by function */
DECL|function|breakpoint
r_void
id|breakpoint
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kgdb_enabled
)paren
(brace
id|kgdb_enabled
op_assign
l_int|1
suffix:semicolon
id|kgdb_init
c_func
(paren
)paren
suffix:semicolon
)brace
id|BREAKPOINT
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialise the KGDB data structures and serial configuration */
DECL|function|kgdb_init
r_int
id|kgdb_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kgdb_enabled
)paren
r_return
l_int|1
suffix:semicolon
id|in_nmi
op_assign
l_int|0
suffix:semicolon
id|kgdb_nofault
op_assign
l_int|0
suffix:semicolon
id|stepped_opcode
op_assign
l_int|0
suffix:semicolon
id|kgdb_in_gdb_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|kgdb_serial_setup
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
id|KGDB_PRINTK
c_func
(paren
l_string|&quot;serial setup error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Init ptr to exception handler */
id|kgdb_debug_hook
op_assign
id|kgdb_handle_exception
suffix:semicolon
id|kgdb_bus_err_hook
op_assign
id|kgdb_handle_bus_error
suffix:semicolon
multiline_comment|/* Enter kgdb now if requested, or just report init done */
r_if
c_cond
(paren
id|kgdb_halt
)paren
(brace
id|kgdb_in_gdb_mode
op_assign
l_int|1
suffix:semicolon
id|put_debug_char
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
id|breakpoint
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|KGDB_PRINTK
c_func
(paren
l_string|&quot;stub is initialized.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make function available for &quot;user messages&quot;; console will use it too. */
DECL|variable|gdbmsgbuf
r_char
id|gdbmsgbuf
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|macro|MAXOUT
mdefine_line|#define MAXOUT ((BUFMAX-2)/2)
DECL|function|kgdb_msg_write
r_static
r_void
id|kgdb_msg_write
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wcount
suffix:semicolon
r_char
op_star
id|bufptr
suffix:semicolon
multiline_comment|/* &squot;O&squot;utput */
id|gdbmsgbuf
(braket
l_int|0
)braket
op_assign
l_char|&squot;O&squot;
suffix:semicolon
multiline_comment|/* Fill and send buffers... */
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|bufptr
op_assign
id|gdbmsgbuf
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Calculate how many this time */
id|wcount
op_assign
(paren
id|count
OG
id|MAXOUT
)paren
ques
c_cond
id|MAXOUT
suffix:colon
id|count
suffix:semicolon
multiline_comment|/* Pack in hex chars */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wcount
suffix:semicolon
id|i
op_increment
)paren
id|bufptr
op_assign
id|pack_hex_byte
c_func
(paren
id|bufptr
comma
id|s
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|bufptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Move up */
id|s
op_add_assign
id|wcount
suffix:semicolon
id|count
op_sub_assign
id|wcount
suffix:semicolon
multiline_comment|/* Write packet */
id|put_packet
c_func
(paren
id|gdbmsgbuf
)paren
suffix:semicolon
)brace
)brace
DECL|function|kgdb_to_gdb
r_static
r_void
id|kgdb_to_gdb
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
id|kgdb_msg_write
c_func
(paren
id|s
comma
id|strlen
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SH_KGDB_CONSOLE
DECL|function|kgdb_console_write
r_void
id|kgdb_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
multiline_comment|/* Bail if we&squot;re not talking to GDB */
r_if
c_cond
(paren
op_logical_neg
id|kgdb_in_gdb_mode
)paren
r_return
suffix:semicolon
id|kgdb_msg_write
c_func
(paren
id|s
comma
id|count
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
