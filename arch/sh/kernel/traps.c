multiline_comment|/* $Id: traps.c,v 1.14 2001/07/24 08:07:10 gniibe Exp $&n; *&n; *  linux/arch/sh/traps.c&n; *&n; *  SuperH version: Copyright (C) 1999 Niibe Yutaka&n; *                  Copyright (C) 2000 Philipp Rumpf&n; *                  Copyright (C) 2000 David Howells&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;entry.S&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name, tsk) &bslash;&n;asmlinkage void do_##name(unsigned long r4, unsigned long r5, &bslash;&n;&t;&t;&t;  unsigned long r6, unsigned long r7, &bslash;&n;&t;&t;&t;  struct pt_regs regs) &bslash;&n;{ &bslash;&n;&t;unsigned long error_code; &bslash;&n; &bslash;&n;&t;asm volatile(&quot;stc&t;r2_bank, %0&quot;: &quot;=r&quot; (error_code)); &bslash;&n;&t;sti(); &bslash;&n;&t;tsk-&gt;thread.error_code = error_code; &bslash;&n;&t;tsk-&gt;thread.trap_no = trapnr; &bslash;&n;&t;force_sig(signr, tsk); &bslash;&n;&t;die_if_no_fixup(str,&amp;regs,error_code); &bslash;&n;}
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments.  VMALLOC_OFFSET comes from mm/vmalloc.c; MODULE_RANGE is&n; * a guess of how much space is likely to be vmalloced.&n; */
DECL|macro|VMALLOC_OFFSET
mdefine_line|#define VMALLOC_OFFSET (8*1024*1024)
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
DECL|variable|die_lock
id|spinlock_t
id|die_lock
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|variable|handle_unaligned_notify_count
r_static
r_int
id|handle_unaligned_notify_count
op_assign
l_int|10
suffix:semicolon
multiline_comment|/*&n; * try and fix up kernelspace address errors&n; * - userspace errors just cause EFAULT to be returned, resulting in SEGV&n; * - kernel/userspace interfaces cause a jump to an appropriate handler&n; * - other kernel errors are bad&n; * - return 0 if fixed-up, -EFAULT if non-fatal (to the kernel) fault&n; */
DECL|function|die_if_no_fixup
r_static
r_int
id|die_if_no_fixup
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_int
r_int
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;pc
op_assign
id|fixup
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n; * handle an instruction that does an unaligned memory access by emulating the&n; * desired behaviour&n; * - note that PC _may not_ point to the faulting instruction&n; *   (if that instruction is in a branch delay slot)&n; * - return 0 if emulation okay, -EFAULT on existential error&n; */
DECL|function|handle_unaligned_ins
r_static
r_int
id|handle_unaligned_ins
c_func
(paren
id|u16
id|instruction
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
comma
id|index
comma
id|count
suffix:semicolon
r_int
r_int
op_star
id|rm
comma
op_star
id|rn
suffix:semicolon
r_int
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
id|index
op_assign
(paren
id|instruction
op_rshift
l_int|8
)paren
op_amp
l_int|15
suffix:semicolon
multiline_comment|/* 0x0F00 */
id|rn
op_assign
op_amp
id|regs-&gt;regs
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
(paren
id|instruction
op_rshift
l_int|4
)paren
op_amp
l_int|15
suffix:semicolon
multiline_comment|/* 0x00F0 */
id|rm
op_assign
op_amp
id|regs-&gt;regs
(braket
id|index
)braket
suffix:semicolon
id|count
op_assign
l_int|1
op_lshift
(paren
id|instruction
op_amp
l_int|3
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|instruction
op_rshift
l_int|12
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* mov.[bwl] to/from memory via r0+rn */
r_if
c_cond
(paren
id|instruction
op_amp
l_int|8
)paren
(brace
multiline_comment|/* from memory */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rm
suffix:semicolon
id|src
op_add_assign
id|regs-&gt;regs
(braket
l_int|0
)braket
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
id|rn
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN__
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|2
)paren
op_logical_and
id|dst
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|2
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|3
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#else
id|dst
op_add_assign
l_int|4
op_minus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|__copy_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|2
)paren
op_logical_and
id|dst
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|1
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* to memory */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
id|rm
suffix:semicolon
macro_line|#if !defined(__LITTLE_ENDIAN__)
id|src
op_add_assign
l_int|4
op_minus
id|count
suffix:semicolon
macro_line|#endif
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rn
suffix:semicolon
id|dst
op_add_assign
id|regs-&gt;regs
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* mov.l Rm,@(disp,Rn) */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
id|rm
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rn
suffix:semicolon
id|dst
op_add_assign
(paren
id|instruction
op_amp
l_int|0x000F
)paren
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst
comma
id|src
comma
l_int|4
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* mov.[bwl] to memory, possibly with pre-decrement */
r_if
c_cond
(paren
id|instruction
op_amp
l_int|4
)paren
op_star
id|rn
op_sub_assign
id|count
suffix:semicolon
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
id|rm
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rn
suffix:semicolon
macro_line|#if !defined(__LITTLE_ENDIAN__)
id|src
op_add_assign
l_int|4
op_minus
id|count
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* mov.l @(disp,Rm),Rn */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rm
suffix:semicolon
id|src
op_add_assign
(paren
id|instruction
op_amp
l_int|0x000F
)paren
op_lshift
l_int|2
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
id|rn
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
l_int|4
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* mov.[bwl] from memory, possibly with post-increment */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rm
suffix:semicolon
r_if
c_cond
(paren
id|instruction
op_amp
l_int|4
)paren
op_star
id|rm
op_add_assign
id|count
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
id|rn
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN__
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|2
)paren
op_logical_and
id|dst
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|2
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|3
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#else
id|dst
op_add_assign
l_int|4
op_minus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|2
)paren
op_logical_and
id|dst
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|1
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#endif
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_switch
c_cond
(paren
(paren
id|instruction
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
)paren
(brace
r_case
l_int|0x81
suffix:colon
multiline_comment|/* mov.w R0,@(disp,Rn) */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|regs-&gt;regs
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#if !defined(__LITTLE_ENDIAN__)
id|src
op_add_assign
l_int|2
suffix:semicolon
macro_line|#endif
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rm
suffix:semicolon
multiline_comment|/* called Rn in the spec */
id|dst
op_add_assign
(paren
id|instruction
op_amp
l_int|0x000F
)paren
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst
comma
id|src
comma
l_int|2
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x85
suffix:colon
multiline_comment|/* mov.w @(disp,Rm),R0 */
id|src
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|rm
suffix:semicolon
id|src
op_add_assign
(paren
id|instruction
op_amp
l_int|0x000F
)paren
op_lshift
l_int|1
suffix:semicolon
id|dst
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|regs-&gt;regs
(braket
l_int|0
)braket
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
l_int|0
suffix:semicolon
macro_line|#if !defined(__LITTLE_ENDIAN__)
id|dst
op_add_assign
l_int|2
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
l_int|2
)paren
)paren
r_goto
id|fetch_fault
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN__
r_if
c_cond
(paren
id|dst
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|2
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|3
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|dst
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
(brace
id|dst
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dst
(braket
l_int|1
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#endif
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
id|fetch_fault
suffix:colon
multiline_comment|/* Argh. Address not only misaligned but also non-existent.&n;&t; * Raise an EFAULT and see if it&squot;s trapped&n;&t; */
r_return
id|die_if_no_fixup
c_func
(paren
l_string|&quot;Fault in unaligned fixup&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * emulate the instruction in the delay slot&n; * - fetches the instruction from PC+2&n; */
DECL|function|handle_unaligned_delayslot
r_static
r_inline
r_int
id|handle_unaligned_delayslot
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u16
id|instruction
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|instruction
comma
(paren
id|u16
op_star
)paren
(paren
id|regs-&gt;pc
op_plus
l_int|2
)paren
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* the instruction-fetch faulted */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* kernel */
id|die
c_func
(paren
l_string|&quot;delay-slot-insn faulting in handle_unaligned_delayslot&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|handle_unaligned_ins
c_func
(paren
id|instruction
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * handle an instruction that does an unaligned memory access&n; * - have to be careful of branch delay-slot instructions that fault&n; *  SH3:&n; *   - if the branch would be taken PC points to the branch&n; *   - if the branch would not be taken, PC points to delay-slot&n; *  SH4:&n; *   - PC always points to delayed branch&n; * - return 0 if handled, -EFAULT if failed (may not return if in kernel)&n; */
multiline_comment|/* Macros to determine offset from current PC for branch instructions */
multiline_comment|/* Explicit type coercion is used to force sign extension where needed */
DECL|macro|SH_PC_8BIT_OFFSET
mdefine_line|#define SH_PC_8BIT_OFFSET(instr) ((((signed char)(instr))*2) + 4)
DECL|macro|SH_PC_12BIT_OFFSET
mdefine_line|#define SH_PC_12BIT_OFFSET(instr) ((((signed short)(instr&lt;&lt;4))&gt;&gt;3) + 4)
DECL|function|handle_unaligned_access
r_static
r_int
id|handle_unaligned_access
c_func
(paren
id|u16
id|instruction
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u_int
id|rm
suffix:semicolon
r_int
id|ret
comma
id|index
suffix:semicolon
id|index
op_assign
(paren
id|instruction
op_rshift
l_int|8
)paren
op_amp
l_int|15
suffix:semicolon
multiline_comment|/* 0x0F00 */
id|rm
op_assign
id|regs-&gt;regs
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* shout about the first ten userspace fixups */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
op_logical_and
id|handle_unaligned_notify_count
OG
l_int|0
)paren
(brace
id|handle_unaligned_notify_count
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Fixing up unaligned userspace access in &bslash;&quot;%s&bslash;&quot; pid=%d pc=0x%p ins=0x%04hx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
id|u16
op_star
)paren
id|regs-&gt;pc
comma
id|instruction
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|instruction
op_amp
l_int|0xF000
)paren
(brace
r_case
l_int|0x0000
suffix:colon
r_if
c_cond
(paren
id|instruction
op_eq
l_int|0x000B
)paren
(brace
multiline_comment|/* rts */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_assign
id|regs-&gt;pr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|instruction
op_amp
l_int|0x00FF
)paren
op_eq
l_int|0x0023
)paren
(brace
multiline_comment|/* braf @Rm */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_add_assign
id|rm
op_plus
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|instruction
op_amp
l_int|0x00FF
)paren
op_eq
l_int|0x0003
)paren
(brace
multiline_comment|/* bsrf @Rm */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|regs-&gt;pr
op_assign
id|regs-&gt;pc
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;pc
op_add_assign
id|rm
op_plus
l_int|4
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* mov.[bwl] to/from memory via r0+rn */
r_goto
id|simple
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x1000
suffix:colon
multiline_comment|/* mov.l Rm,@(disp,Rn) */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x2000
suffix:colon
multiline_comment|/* mov.[bwl] to memory, possibly with pre-decrement */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x4000
suffix:colon
r_if
c_cond
(paren
(paren
id|instruction
op_amp
l_int|0x00FF
)paren
op_eq
l_int|0x002B
)paren
(brace
multiline_comment|/* jmp @Rm */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_assign
id|rm
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|instruction
op_amp
l_int|0x00FF
)paren
op_eq
l_int|0x000B
)paren
(brace
multiline_comment|/* jsr @Rm */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|regs-&gt;pr
op_assign
id|regs-&gt;pc
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;pc
op_assign
id|rm
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* mov.[bwl] to/from memory via r0+rn */
r_goto
id|simple
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x5000
suffix:colon
multiline_comment|/* mov.l @(disp,Rm),Rn */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x6000
suffix:colon
multiline_comment|/* mov.[bwl] from memory, possibly with post-increment */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x8000
suffix:colon
multiline_comment|/* bf lab, bf/s lab, bt lab, bt/s lab */
r_switch
c_cond
(paren
id|instruction
op_amp
l_int|0x0F00
)paren
(brace
r_case
l_int|0x0100
suffix:colon
multiline_comment|/* mov.w R0,@(disp,Rm) */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x0500
suffix:colon
multiline_comment|/* mov.w @(disp,Rm),R0 */
r_goto
id|simple
suffix:semicolon
r_case
l_int|0x0B00
suffix:colon
multiline_comment|/* bf   lab - no delayslot*/
r_break
suffix:semicolon
r_case
l_int|0x0F00
suffix:colon
multiline_comment|/* bf/s lab */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
macro_line|#if defined(__SH4__)
r_if
c_cond
(paren
(paren
id|regs-&gt;sr
op_amp
l_int|0x00000001
)paren
op_ne
l_int|0
)paren
id|regs-&gt;pc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* next after slot */
r_else
macro_line|#endif
id|regs-&gt;pc
op_add_assign
id|SH_PC_8BIT_OFFSET
c_func
(paren
id|instruction
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0900
suffix:colon
multiline_comment|/* bt   lab - no delayslot */
r_break
suffix:semicolon
r_case
l_int|0x0D00
suffix:colon
multiline_comment|/* bt/s lab */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
macro_line|#if defined(__SH4__)
r_if
c_cond
(paren
(paren
id|regs-&gt;sr
op_amp
l_int|0x00000001
)paren
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* next after slot */
r_else
macro_line|#endif
id|regs-&gt;pc
op_add_assign
id|SH_PC_8BIT_OFFSET
c_func
(paren
id|instruction
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0xA000
suffix:colon
multiline_comment|/* bra label */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_add_assign
id|SH_PC_12BIT_OFFSET
c_func
(paren
id|instruction
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xB000
suffix:colon
multiline_comment|/* bsr label */
id|ret
op_assign
id|handle_unaligned_delayslot
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|regs-&gt;pr
op_assign
id|regs-&gt;pc
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;pc
op_add_assign
id|SH_PC_12BIT_OFFSET
c_func
(paren
id|instruction
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/* handle non-delay-slot instruction */
id|simple
suffix:colon
id|ret
op_assign
id|handle_unaligned_ins
c_func
(paren
id|instruction
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|regs-&gt;pc
op_add_assign
l_int|2
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle various address error exceptions&n; */
DECL|function|do_address_error
id|asmlinkage
r_void
id|do_address_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writeaccess
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|error_code
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
id|u16
id|instruction
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;stc       r2_bank,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error_code
)paren
)paren
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
(paren
id|writeaccess
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* bad PC is not something we can fix */
r_if
c_cond
(paren
id|regs-&gt;pc
op_amp
l_int|1
)paren
r_goto
id|uspace_segv
suffix:semicolon
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|instruction
comma
(paren
id|u16
op_star
)paren
(paren
id|regs-&gt;pc
)paren
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* Argh. Fault on the instruction itself.&n;&t;&t;&t;   This should never happen non-SMP&n;&t;&t;&t;*/
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_goto
id|uspace_segv
suffix:semicolon
)brace
id|tmp
op_assign
id|handle_unaligned_access
c_func
(paren
id|instruction
comma
id|regs
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* sorted */
id|uspace_segv
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Killing process &bslash;&quot;%s&bslash;&quot; due to unaligned access&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|regs-&gt;pc
op_amp
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;unaligned program counter&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|instruction
comma
(paren
id|u16
op_star
)paren
(paren
id|regs-&gt;pc
)paren
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* Argh. Fault on the instruction itself.&n;&t;&t;&t;   This should never happen non-SMP&n;&t;&t;&t;*/
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;insn faulting in do_address_error&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
id|handle_unaligned_access
c_func
(paren
id|instruction
comma
id|regs
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
)brace
)brace
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGILL
comma
l_string|&quot;reserved instruction&quot;
comma
id|reserved_inst
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|13
comma
id|SIGILL
comma
l_string|&quot;illegal slot instruction&quot;
comma
id|illegal_slot_inst
comma
id|current
)paren
DECL|function|do_exception_error
id|asmlinkage
r_void
id|do_exception_error
c_func
(paren
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
id|ex
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;stc&t;r2_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ex
)paren
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;exception&quot;
comma
op_amp
id|regs
comma
id|ex
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SH_STANDARD_BIOS)
DECL|variable|gdb_vbr_vector
r_void
op_star
id|gdb_vbr_vector
suffix:semicolon
macro_line|#endif
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
op_star
id|vbr_base
suffix:semicolon
r_extern
r_void
op_star
id|exception_handling_table
(braket
l_int|14
)braket
suffix:semicolon
id|exception_handling_table
(braket
l_int|12
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_reserved_inst
suffix:semicolon
id|exception_handling_table
(braket
l_int|13
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_illegal_slot_inst
suffix:semicolon
macro_line|#if defined(CONFIG_SH_STANDARD_BIOS)
multiline_comment|/*&n;&t; * Read the old value of the VBR register to initialise&n;&t; * the vector through which debug and BIOS traps are&n;&t; * delegated by the Linux trap handler.&n;&t; */
(brace
r_register
r_int
r_int
id|vbr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;stc vbr, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|vbr
)paren
)paren
suffix:semicolon
id|gdb_vbr_vector
op_assign
(paren
r_void
op_star
)paren
(paren
id|vbr
op_plus
l_int|0x100
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Setting GDB trap vector to 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|gdb_vbr_vector
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* NOTE: The VBR value should be at P1&n;&t;   (or P2, virtural &quot;fixed&quot; address space).&n;&t;   It&squot;s definitely should not in physical address.  */
id|asm
r_volatile
(paren
l_string|&quot;ldc&t;%0, vbr&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|vbr_base
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|start
suffix:semicolon
r_int
r_int
op_star
id|end
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mov&t;r15, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|start
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;stc&t;r7_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|end
)paren
)paren
suffix:semicolon
id|end
op_add_assign
l_int|8192
op_div
l_int|4
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx:%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|start
comma
(paren
r_int
r_int
)paren
id|end
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|start
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_increment
)paren
(brace
r_extern
r_int
id|_text
comma
id|_etext
suffix:semicolon
r_int
r_int
id|v
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_text
)paren
op_logical_and
(paren
id|v
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lx&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_trace_task
r_void
id|show_trace_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Backtrace not yet implemented for SH.&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
