multiline_comment|/* arch/sh/kernel/setup_dc.c&n; *&n; * Hardware support for the Sega Dreamcast.&n; *&n; * Copyright (c) 2001 M. R. Brown &lt;mrbrown@linuxdc.org&gt;&n; *&n; * This file is part of the LinuxDC project (www.linuxdc.org)&n; *&n; * Released under the terms of the GNU GPL v2.0.&n; * &n; * This file originally bore the message (with enclosed-$):&n; *&t;Id: setup_dc.c,v 1.5 2001/05/24 05:09:16 mrbrown Exp&n; *&t;SEGA Dreamcast support&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dc_sysasic.h&gt;
r_int
id|__init
id|gapspci_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...) printk(KERN_DEBUG &quot;%s: &quot; fmt, __FUNCTION__ , ## args)
multiline_comment|/* Dreamcast System ASIC Hardware Events -&n; &n;   The Dreamcast&squot;s System ASIC (located on the PowerVR2 chip) is responsible&n;   for receiving hardware events from system peripherals and triggering an&n;   SH7750 IRQ.  Hardware events can trigger IRQs 13, 11, or 9 depending on&n;   which bits are set in the Event Mask Registers (EMRs).  When a hardware&n;   event is triggered, it&squot;s corresponding bit in the Event Status Registers&n;   (ESRs) is set, and that bit should be rewritten to the ESR to acknowledge&n;   that event.&n;&n;   There are three 32-bit ESRs located at 0xa05f8900 - 0xa05f6908.  Event&n;   types can be found in include/asm-sh/dc_sysasic.h.  There are three groups&n;   of EMRs that parallel the ESRs.  Each EMR group corresponds to an IRQ, so&n;   0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928 triggers&n;   IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.&n;&n;   In the kernel, these events are mapped to virtual IRQs so that drivers can&n;   respond to them as they would a normal interrupt.  In order to keep this&n;   mapping simple, the events are mapped as:&n;&n;   6900/6910 - Events  0-31, IRQ 13&n;   6904/6924 - Events 32-63, IRQ 11&n;   6908/6938 - Events 64-95, IRQ  9&n;&n;*/
DECL|macro|ESR_BASE
mdefine_line|#define ESR_BASE 0x005f6900    /* Base event status register */
DECL|macro|EMR_BASE
mdefine_line|#define EMR_BASE 0x005f6910    /* Base event mask register */
multiline_comment|/* Helps us determine the EMR group that this event belongs to: 0 = 0x6910,&n;   1 = 0x6920, 2 = 0x6930; also determine the event offset */
DECL|macro|LEVEL
mdefine_line|#define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
multiline_comment|/* Return the hardware event&squot;s bit positon within the EMR/ESR */
DECL|macro|EVENT_BIT
mdefine_line|#define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) &amp; 31)
multiline_comment|/* For each of these *_irq routines, the IRQ passed in is the virtual IRQ&n;   (logically mapped to the corresponding bit for the hardware event). */
multiline_comment|/* Disable the hardware event by masking its bit in its EMR */
DECL|function|disable_systemasic_irq
r_static
r_inline
r_void
id|disable_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|__u32
id|mask
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mask
op_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|mask
comma
id|emr
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable the hardware event by setting its bit in its EMR */
DECL|function|enable_systemasic_irq
r_static
r_inline
r_void
id|enable_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|__u32
id|mask
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mask
op_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
id|mask
op_or_assign
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|mask
comma
id|emr
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Acknowledge a hardware event by writing its bit back to its ESR */
DECL|function|ack_systemasic_irq
r_static
r_void
id|ack_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|__u32
id|esr
op_assign
id|ESR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|disable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|esr
)paren
suffix:semicolon
)brace
multiline_comment|/* After a IRQ has been ack&squot;d and responded to, it needs to be renabled */
DECL|function|end_systemasic_irq
r_static
r_void
id|end_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
id|enable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|startup_systemasic_irq
r_static
r_int
r_int
id|startup_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|enable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shutdown_systemasic_irq
r_static
r_void
id|shutdown_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|disable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|systemasic_int
r_static
r_struct
id|hw_interrupt_type
id|systemasic_int
op_assign
(brace
r_typename
suffix:colon
l_string|&quot;System ASIC&quot;
comma
id|startup
suffix:colon
id|startup_systemasic_irq
comma
id|shutdown
suffix:colon
id|shutdown_systemasic_irq
comma
id|enable
suffix:colon
id|enable_systemasic_irq
comma
id|disable
suffix:colon
id|disable_systemasic_irq
comma
id|ack
suffix:colon
id|ack_systemasic_irq
comma
id|end
suffix:colon
id|end_systemasic_irq
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Map the hardware event indicated by the processor IRQ to a virtual IRQ.&n; */
DECL|function|systemasic_irq_demux
r_int
id|systemasic_irq_demux
c_func
(paren
r_int
id|irq
)paren
(brace
id|__u32
id|emr
comma
id|esr
comma
id|status
comma
id|level
suffix:semicolon
id|__u32
id|j
comma
id|bit
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|13
suffix:colon
id|level
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|level
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|level
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|irq
suffix:semicolon
)brace
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|level
op_lshift
l_int|4
)paren
op_plus
(paren
id|level
op_lshift
l_int|2
)paren
suffix:semicolon
id|esr
op_assign
id|ESR_BASE
op_plus
(paren
id|level
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Mask the ESR to filter any spurious, unwanted interrtupts */
id|status
op_assign
id|inl
c_func
(paren
id|esr
)paren
suffix:semicolon
id|status
op_and_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
multiline_comment|/* Now scan and find the first set bit as the event to map */
r_for
c_loop
(paren
id|bit
op_assign
l_int|1
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|bit
op_lshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|bit
)paren
(brace
id|irq
op_assign
id|HW_EVENT_IRQ_BASE
op_plus
id|j
op_plus
(paren
id|level
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
)brace
multiline_comment|/* Not reached */
r_return
id|irq
suffix:semicolon
)brace
DECL|function|setup_dreamcast
r_int
id|__init
id|setup_dreamcast
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Mask all hardware events */
multiline_comment|/* XXX */
multiline_comment|/* Acknowledge any previous events */
multiline_comment|/* XXX */
multiline_comment|/* Assign all virtual IRQs to the System ASIC int. handler */
r_for
c_loop
(paren
id|i
op_assign
id|HW_EVENT_IRQ_BASE
suffix:semicolon
id|i
OL
id|HW_EVENT_IRQ_MAX
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|systemasic_int
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|gapspci_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SEGA Dreamcast support.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;BCR1: 0x%08x&bslash;n&quot;
comma
id|ctrl_inl
c_func
(paren
l_int|0xff800000
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;BCR2: 0x%08x&bslash;n&quot;
comma
id|ctrl_inw
c_func
(paren
l_int|0xff800004
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WCR1: 0x%08x&bslash;n&quot;
comma
id|ctrl_inl
c_func
(paren
l_int|0xff800008
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WCR2: 0x%08x&bslash;n&quot;
comma
id|ctrl_inl
c_func
(paren
l_int|0xff80000c
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WCR3: 0x%08x&bslash;n&quot;
comma
id|ctrl_inl
c_func
(paren
l_int|0xff800010
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MCR: 0x%08x&bslash;n&quot;
comma
id|ctrl_inl
c_func
(paren
l_int|0xff800014
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PCR: 0x%08x&bslash;n&quot;
comma
id|ctrl_inw
c_func
(paren
l_int|0xff800018
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;BCR1: 0xa3020008&n; *&t;BCR2: 0x0001&n; *&t;WCR1: 0x01110111&n; *&t;WCR2: 0x618066d8&n; *&t;WCR3: 0x07777777&n; *&t;MCR: 0xc00a0e24&n; *&t;PCR: 0x0000&n; */
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
