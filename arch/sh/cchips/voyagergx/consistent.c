multiline_comment|/*&n; * arch/sh/cchips/voyagergx/consistent.c&n; *&n; * Copyright (C) 2004  Paul Mundt&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bus-sh.h&gt;
DECL|struct|voya_alloc_entry
r_struct
id|voya_alloc_entry
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|ofs
r_int
r_int
id|ofs
suffix:semicolon
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|voya_list_lock
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|voya_alloc_list
)paren
suffix:semicolon
DECL|macro|OHCI_SRAM_START
mdefine_line|#define OHCI_SRAM_START&t;0xb0000000
DECL|macro|OHCI_HCCA_SIZE
mdefine_line|#define OHCI_HCCA_SIZE&t;0x100
DECL|macro|OHCI_SRAM_SIZE
mdefine_line|#define OHCI_SRAM_SIZE&t;0x10000
DECL|function|voyagergx_consistent_alloc
r_void
op_star
id|voyagergx_consistent_alloc
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|handle
comma
r_int
id|flag
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
id|voya_alloc_list
suffix:semicolon
r_struct
id|voya_alloc_entry
op_star
id|entry
suffix:semicolon
r_struct
id|sh_dev
op_star
id|shdev
op_assign
id|to_sh_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * The SM501 contains an integrated 8051 with its own SRAM.&n;&t; * Devices within the cchip can all hook into the 8051 SRAM.&n;&t; * We presently use this for the OHCI.&n;&t; *&n;&t; * Everything else goes through consistent_alloc().&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
id|dev-&gt;bus
op_ne
op_amp
id|sh_bus_types
(braket
id|SH_BUS_VIRT
)braket
op_logical_or
(paren
id|dev-&gt;bus
op_eq
op_amp
id|sh_bus_types
(braket
id|SH_BUS_VIRT
)braket
op_logical_and
id|shdev-&gt;dev_id
op_ne
id|SH_DEV_ID_USB_OHCI
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|start
op_assign
id|OHCI_SRAM_START
op_plus
id|OHCI_HCCA_SIZE
suffix:semicolon
id|entry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|voya_alloc_entry
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|entry-&gt;len
op_assign
(paren
id|size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
multiline_comment|/*&n;&t; * The basis for this allocator is dwmw2&squot;s malloc.. the&n;&t; * Matrox allocator :-)&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|voya_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|list
comma
op_amp
id|voya_alloc_list
)paren
(brace
r_struct
id|voya_alloc_entry
op_star
id|p
suffix:semicolon
id|p
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|voya_alloc_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;ofs
op_minus
id|start
op_ge
id|size
)paren
r_goto
id|out
suffix:semicolon
id|start
op_assign
id|p-&gt;ofs
op_plus
id|p-&gt;len
suffix:semicolon
)brace
id|end
op_assign
id|start
op_plus
(paren
id|OHCI_SRAM_SIZE
op_minus
id|OHCI_HCCA_SIZE
)paren
suffix:semicolon
id|list
op_assign
op_amp
id|voya_alloc_list
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
op_ge
id|size
)paren
(brace
id|out
suffix:colon
id|entry-&gt;ofs
op_assign
id|start
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|entry-&gt;list
comma
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|voya_list_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|handle
op_assign
id|start
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|start
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|voya_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|voyagergx_consistent_free
r_int
id|voyagergx_consistent_free
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|handle
)paren
(brace
r_struct
id|voya_alloc_entry
op_star
id|entry
suffix:semicolon
r_struct
id|sh_dev
op_star
id|shdev
op_assign
id|to_sh_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
id|dev-&gt;bus
op_ne
op_amp
id|sh_bus_types
(braket
id|SH_BUS_VIRT
)braket
op_logical_or
(paren
id|dev-&gt;bus
op_eq
op_amp
id|sh_bus_types
(braket
id|SH_BUS_VIRT
)braket
op_logical_and
id|shdev-&gt;dev_id
op_ne
id|SH_DEV_ID_USB_OHCI
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|voya_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|entry
comma
op_amp
id|voya_alloc_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;ofs
op_ne
id|handle
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|voya_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|voyagergx_consistent_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|voyagergx_consistent_alloc
)paren
suffix:semicolon
DECL|variable|voyagergx_consistent_free
id|EXPORT_SYMBOL
c_func
(paren
id|voyagergx_consistent_free
)paren
suffix:semicolon
eof
