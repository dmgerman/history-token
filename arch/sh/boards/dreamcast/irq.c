multiline_comment|/*&n; * arch/sh/boards/dreamcast/irq.c&n; *&n; * Holly IRQ support for the Sega Dreamcast.&n; *&n; * Copyright (c) 2001, 2002 M. R. Brown &lt;mrbrown@0xd6.org&gt;&n; *&n; * This file is part of the LinuxDC project (www.linuxdc.org)&n; * Released under the terms of the GNU GPL v2.0&n; */
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dreamcast/sysasic.h&gt;
multiline_comment|/* Dreamcast System ASIC Hardware Events -&n;&n;   The Dreamcast&squot;s System ASIC (a.k.a. Holly) is responsible for receiving&n;   hardware events from system peripherals and triggering an SH7750 IRQ.&n;   Hardware events can trigger IRQs 13, 11, or 9 depending on which bits are&n;   set in the Event Mask Registers (EMRs).  When a hardware event is&n;   triggered, it&squot;s corresponding bit in the Event Status Registers (ESRs)&n;   is set, and that bit should be rewritten to the ESR to acknowledge that&n;   event.&n;&n;   There are three 32-bit ESRs located at 0xa05f8900 - 0xa05f6908.  Event&n;   types can be found in include/asm-sh/dc_sysasic.h.  There are three groups&n;   of EMRs that parallel the ESRs.  Each EMR group corresponds to an IRQ, so&n;   0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928 triggers&n;   IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.&n;&n;   In the kernel, these events are mapped to virtual IRQs so that drivers can&n;   respond to them as they would a normal interrupt.  In order to keep this&n;   mapping simple, the events are mapped as:&n;&n;   6900/6910 - Events  0-31, IRQ 13&n;   6904/6924 - Events 32-63, IRQ 11&n;   6908/6938 - Events 64-95, IRQ  9&n;&n;*/
DECL|macro|ESR_BASE
mdefine_line|#define ESR_BASE 0x005f6900    /* Base event status register */
DECL|macro|EMR_BASE
mdefine_line|#define EMR_BASE 0x005f6910    /* Base event mask register */
multiline_comment|/* Helps us determine the EMR group that this event belongs to: 0 = 0x6910,&n;   1 = 0x6920, 2 = 0x6930; also determine the event offset */
DECL|macro|LEVEL
mdefine_line|#define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
multiline_comment|/* Return the hardware event&squot;s bit positon within the EMR/ESR */
DECL|macro|EVENT_BIT
mdefine_line|#define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) &amp; 31)
multiline_comment|/* For each of these *_irq routines, the IRQ passed in is the virtual IRQ&n;   (logically mapped to the corresponding bit for the hardware event). */
multiline_comment|/* Disable the hardware event by masking its bit in its EMR */
DECL|function|disable_systemasic_irq
r_static
r_inline
r_void
id|disable_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|__u32
id|mask
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mask
op_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|mask
comma
id|emr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable the hardware event by setting its bit in its EMR */
DECL|function|enable_systemasic_irq
r_static
r_inline
r_void
id|enable_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|__u32
id|mask
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mask
op_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
id|mask
op_or_assign
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|mask
comma
id|emr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Acknowledge a hardware event by writing its bit back to its ESR */
DECL|function|ack_systemasic_irq
r_static
r_void
id|ack_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|__u32
id|esr
op_assign
id|ESR_BASE
op_plus
(paren
id|LEVEL
c_func
(paren
id|irq
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|disable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
id|EVENT_BIT
c_func
(paren
id|irq
)paren
)paren
comma
id|esr
)paren
suffix:semicolon
)brace
multiline_comment|/* After a IRQ has been ack&squot;d and responded to, it needs to be renabled */
DECL|function|end_systemasic_irq
r_static
r_void
id|end_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
id|enable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|startup_systemasic_irq
r_static
r_int
r_int
id|startup_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|enable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shutdown_systemasic_irq
r_static
r_void
id|shutdown_systemasic_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|disable_systemasic_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|systemasic_int
r_struct
id|hw_interrupt_type
id|systemasic_int
op_assign
(brace
r_typename
suffix:colon
l_string|&quot;System ASIC&quot;
comma
id|startup
suffix:colon
id|startup_systemasic_irq
comma
id|shutdown
suffix:colon
id|shutdown_systemasic_irq
comma
id|enable
suffix:colon
id|enable_systemasic_irq
comma
id|disable
suffix:colon
id|disable_systemasic_irq
comma
id|ack
suffix:colon
id|ack_systemasic_irq
comma
id|end
suffix:colon
id|end_systemasic_irq
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Map the hardware event indicated by the processor IRQ to a virtual IRQ.&n; */
DECL|function|systemasic_irq_demux
r_int
id|systemasic_irq_demux
c_func
(paren
r_int
id|irq
)paren
(brace
id|__u32
id|emr
comma
id|esr
comma
id|status
comma
id|level
suffix:semicolon
id|__u32
id|j
comma
id|bit
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|13
suffix:colon
id|level
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|level
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|level
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|irq
suffix:semicolon
)brace
id|emr
op_assign
id|EMR_BASE
op_plus
(paren
id|level
op_lshift
l_int|4
)paren
op_plus
(paren
id|level
op_lshift
l_int|2
)paren
suffix:semicolon
id|esr
op_assign
id|ESR_BASE
op_plus
(paren
id|level
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Mask the ESR to filter any spurious, unwanted interrtupts */
id|status
op_assign
id|inl
c_func
(paren
id|esr
)paren
suffix:semicolon
id|status
op_and_assign
id|inl
c_func
(paren
id|emr
)paren
suffix:semicolon
multiline_comment|/* Now scan and find the first set bit as the event to map */
r_for
c_loop
(paren
id|bit
op_assign
l_int|1
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|bit
op_lshift_assign
l_int|1
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|bit
)paren
(brace
id|irq
op_assign
id|HW_EVENT_IRQ_BASE
op_plus
id|j
op_plus
(paren
id|level
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
)brace
multiline_comment|/* Not reached */
r_return
id|irq
suffix:semicolon
)brace
eof
