multiline_comment|/* &n; * Copyright (C) 2000 David J. Mckay (david.mckay@st.com)&n; *&n; * May be copied or modified under the terms of the GNU General Public&n; * License.  See linux/COPYING for more information.                            &n; *&n; * Looks after interrupts on the overdrive board.&n; *&n; * Bases on the IPR irq system&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/overdrive/overdrive.h&gt;
DECL|struct|od_data
r_struct
id|od_data
(brace
DECL|member|overdrive_irq
r_int
id|overdrive_irq
suffix:semicolon
DECL|member|irq_mask
r_int
id|irq_mask
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NUM_EXTERNAL_IRQS
mdefine_line|#define NUM_EXTERNAL_IRQS 16
DECL|macro|EXTERNAL_IRQ_NOT_IN_USE
mdefine_line|#define EXTERNAL_IRQ_NOT_IN_USE (-1)
DECL|macro|EXTERNAL_IRQ_NOT_ASSIGNED
mdefine_line|#define EXTERNAL_IRQ_NOT_ASSIGNED (-1)
multiline_comment|/*&n; * This table is used to determine what to program into the FPGA&squot;s CT register&n; * for the specified Linux IRQ.&n; *&n; * The irq_mask gives the interrupt number from the PCI board (PCI_Int(6:0))&n; * but is one greater than that because the because the FPGA treats 0&n; * as disabled, a value of 1 asserts PCI_Int0, and so on.&n; *&n; * The overdrive_irq specifies which of the eight interrupt sources generates&n; * that interrupt, and but is multiplied by four to give the bit offset into&n; * the CT register.&n; *&n; * The seven interrupts levels (SH4 IRL&squot;s) we have available here is hardwired&n; * by the EPLD. The assignments here of which PCI interrupt generates each&n; * level is arbitary.&n; */
DECL|variable|od_data_table
r_static
r_struct
id|od_data
id|od_data_table
(braket
id|NUM_EXTERNAL_IRQS
)braket
op_assign
(brace
multiline_comment|/*    overdrive_irq       , irq_mask */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 0 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|7
)brace
comma
multiline_comment|/* 1 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|6
)brace
comma
multiline_comment|/* 2 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 3 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|5
)brace
comma
multiline_comment|/* 4 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 5 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 6 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|4
)brace
comma
multiline_comment|/* 7 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 8 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 9 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|3
)brace
comma
multiline_comment|/* 10 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|2
)brace
comma
multiline_comment|/* 11 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 12 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
l_int|1
)brace
comma
multiline_comment|/* 13 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
comma
multiline_comment|/* 14 */
(brace
id|EXTERNAL_IRQ_NOT_ASSIGNED
comma
id|EXTERNAL_IRQ_NOT_IN_USE
)brace
multiline_comment|/* 15 */
)brace
suffix:semicolon
DECL|function|set_od_data
r_static
r_void
id|set_od_data
c_func
(paren
r_int
id|overdrive_irq
comma
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
id|NUM_EXTERNAL_IRQS
op_logical_or
id|irq
OL
l_int|0
)paren
r_return
suffix:semicolon
id|od_data_table
(braket
id|irq
)braket
dot
id|overdrive_irq
op_assign
id|overdrive_irq
op_lshift
l_int|2
suffix:semicolon
)brace
r_static
r_void
id|enable_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_void
id|disable_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
multiline_comment|/* shutdown is same as &quot;disable&quot; */
DECL|macro|shutdown_od_irq
mdefine_line|#define shutdown_od_irq disable_od_irq
r_static
r_void
id|mask_and_ack_od
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|end_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
DECL|function|startup_od_irq
r_static
r_int
r_int
id|startup_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|enable_od_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* never anything pending */
)brace
DECL|variable|od_irq_type
r_static
r_struct
id|hw_interrupt_type
id|od_irq_type
op_assign
(brace
l_string|&quot;Overdrive-IRQ&quot;
comma
id|startup_od_irq
comma
id|shutdown_od_irq
comma
id|enable_od_irq
comma
id|disable_od_irq
comma
id|mask_and_ack_od
comma
id|end_od_irq
)brace
suffix:semicolon
DECL|function|disable_od_irq
r_static
r_void
id|disable_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|val
comma
id|flags
suffix:semicolon
r_int
id|overdrive_irq
suffix:semicolon
r_int
id|mask
suffix:semicolon
multiline_comment|/* Not a valid interrupt */
r_if
c_cond
(paren
id|irq
OL
l_int|0
op_logical_or
id|irq
op_ge
id|NUM_EXTERNAL_IRQS
)paren
r_return
suffix:semicolon
multiline_comment|/* Is is necessary to use a cli here? Would a spinlock not be &n;         * mroe efficient?&n;         */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|overdrive_irq
op_assign
id|od_data_table
(braket
id|irq
)braket
dot
id|overdrive_irq
suffix:semicolon
r_if
c_cond
(paren
id|overdrive_irq
op_ne
id|EXTERNAL_IRQ_NOT_ASSIGNED
)paren
(brace
id|mask
op_assign
op_complement
(paren
l_int|0x7
op_lshift
id|overdrive_irq
)paren
suffix:semicolon
id|val
op_assign
id|ctrl_inl
c_func
(paren
id|OVERDRIVE_INT_CT
)paren
suffix:semicolon
id|val
op_and_assign
id|mask
suffix:semicolon
id|ctrl_outl
c_func
(paren
id|val
comma
id|OVERDRIVE_INT_CT
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|enable_od_irq
r_static
r_void
id|enable_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|val
comma
id|flags
suffix:semicolon
r_int
id|overdrive_irq
suffix:semicolon
r_int
id|mask
suffix:semicolon
multiline_comment|/* Not a valid interrupt */
r_if
c_cond
(paren
id|irq
OL
l_int|0
op_logical_or
id|irq
op_ge
id|NUM_EXTERNAL_IRQS
)paren
r_return
suffix:semicolon
multiline_comment|/* Set priority in OD back to original value */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This one is not in use currently */
id|overdrive_irq
op_assign
id|od_data_table
(braket
id|irq
)braket
dot
id|overdrive_irq
suffix:semicolon
r_if
c_cond
(paren
id|overdrive_irq
op_ne
id|EXTERNAL_IRQ_NOT_ASSIGNED
)paren
(brace
id|val
op_assign
id|ctrl_inl
c_func
(paren
id|OVERDRIVE_INT_CT
)paren
suffix:semicolon
id|mask
op_assign
op_complement
(paren
l_int|0x7
op_lshift
id|overdrive_irq
)paren
suffix:semicolon
id|val
op_and_assign
id|mask
suffix:semicolon
id|mask
op_assign
id|od_data_table
(braket
id|irq
)braket
dot
id|irq_mask
op_lshift
id|overdrive_irq
suffix:semicolon
id|val
op_or_assign
id|mask
suffix:semicolon
id|ctrl_outl
c_func
(paren
id|val
comma
id|OVERDRIVE_INT_CT
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* this functions sets the desired irq handler to be an overdrive type */
DECL|function|make_od_irq
r_static
r_void
id|__init
id|make_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|disable_irq_nosync
c_func
(paren
id|irq
)paren
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
op_amp
id|od_irq_type
suffix:semicolon
id|disable_od_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|mask_and_ack_od
r_static
r_void
id|mask_and_ack_od
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|disable_od_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|end_od_irq
r_static
r_void
id|end_od_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|enable_od_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|function|init_overdrive_irq
r_void
id|__init
id|init_overdrive_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Disable all interrupts */
id|ctrl_outl
c_func
(paren
l_int|0
comma
id|OVERDRIVE_INT_CT
)paren
suffix:semicolon
multiline_comment|/* Update interrupt pin mode to use encoded interrupts */
id|i
op_assign
id|ctrl_inw
c_func
(paren
id|INTC_ICR
)paren
suffix:semicolon
id|i
op_and_assign
op_complement
id|INTC_ICR_IRLM
suffix:semicolon
id|ctrl_outw
c_func
(paren
id|i
comma
id|INTC_ICR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_EXTERNAL_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|od_data_table
(braket
id|i
)braket
dot
id|irq_mask
op_ne
id|EXTERNAL_IRQ_NOT_IN_USE
)paren
(brace
id|make_od_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_ne
l_int|15
)paren
(brace
singleline_comment|// Cannot use imask on level 15
id|make_imask_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the interrupts */
id|set_od_data
c_func
(paren
id|OVERDRIVE_PCI_INTA
comma
id|OVERDRIVE_PCI_IRQ1
)paren
suffix:semicolon
id|set_od_data
c_func
(paren
id|OVERDRIVE_PCI_INTB
comma
id|OVERDRIVE_PCI_IRQ2
)paren
suffix:semicolon
id|set_od_data
c_func
(paren
id|OVERDRIVE_AUDIO_INT
comma
id|OVERDRIVE_ESS_IRQ
)paren
suffix:semicolon
)brace
eof
