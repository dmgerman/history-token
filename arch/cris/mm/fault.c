multiline_comment|/*&n; *  linux/arch/cris/mm/fault.c&n; *&n; *  Copyright (C) 2000, 2001  Axis Communications AB&n; *&n; *  Authors:  Bjorn Wesen &n; * &n; *  $Log: fault.c,v $&n; *  Revision 1.11  2004/05/14 07:58:05  starvik&n; *  Merge of changes from 2.4&n; *&n; *  Revision 1.10  2003/10/27 14:51:24  starvik&n; *  Removed debugcode&n; *&n; *  Revision 1.9  2003/10/27 14:50:42  starvik&n; *  Changed do_page_fault signature&n; *&n; *  Revision 1.8  2003/07/04 13:02:48  tobiasa&n; *  Moved code snippet from arch/cris/mm/fault.c that searches for fixup code&n; *  to seperate function in arch-specific files.&n; *&n; *  Revision 1.7  2003/01/22 06:48:38  starvik&n; *  Fixed warnings issued by GCC 3.2.1&n; *&n; *  Revision 1.6  2003/01/09 14:42:52  starvik&n; *  Merge of Linux 2.5.55&n; *&n; *  Revision 1.5  2002/12/11 14:44:48  starvik&n; *  Extracted v10 (ETRAX 100LX) specific stuff to arch/cris/arch-v10/mm&n; *&n; *  Revision 1.4  2002/11/13 15:10:28  starvik&n; *  pte_offset has been renamed to pte_offset_kernel&n; *&n; *  Revision 1.3  2002/11/05 06:45:13  starvik&n; *  Merge of Linux 2.5.45&n; *&n; *  Revision 1.2  2001/12/18 13:35:22  bjornw&n; *  Applied the 2.4.13-&gt;2.4.16 CRIS patch to 2.5.1 (is a copy of 2.4.15).&n; *&n; *  Revision 1.20  2001/11/22 13:34:06  bjornw&n; *  * Bug workaround (LX TR89): force a rerun of the whole of an interrupted&n; *    unaligned write, because the second half of the write will be corrupted&n; *    otherwise. Affected unaligned writes spanning not-yet mapped pages.&n; *  * Optimization: use the wr_rd bit in R_MMU_CAUSE to know whether a miss&n; *    was due to a read or a write (before we didn&squot;t know this until the next&n; *    restart of the interrupted instruction, thus wasting one fault-irq)&n; *&n; *  Revision 1.19  2001/11/12 19:02:10  pkj&n; *  Fixed compiler warnings.&n; *&n; *  Revision 1.18  2001/07/18 22:14:32  bjornw&n; *  Enable interrupts in the bulk of do_page_fault&n; *&n; *  Revision 1.17  2001/07/18 13:07:23  bjornw&n; *  * Detect non-existant PTE&squot;s in vmalloc pmd synchronization&n; *  * Remove comment about fast-paths for VMALLOC_START etc, because all that&n; *    was totally bogus anyway it turned out :)&n; *  * Fix detection of vmalloc-area synchronization&n; *  * Add some comments&n; *&n; *  Revision 1.16  2001/06/13 00:06:08  bjornw&n; *  current_pgd should be volatile&n; *&n; *  Revision 1.15  2001/06/13 00:02:23  bjornw&n; *  Use a separate variable to store the current pgd to avoid races in schedule&n; *&n; *  Revision 1.14  2001/05/16 17:41:07  hp&n; *  Last comment tweak further tweaked.&n; *&n; *  Revision 1.13  2001/05/15 00:58:44  hp&n; *  Expand a bit on the comment why we compare address &gt;= TASK_SIZE rather&n; *  than &gt;= VMALLOC_START.&n; *&n; *  Revision 1.12  2001/04/04 10:51:14  bjornw&n; *  mmap_sem is grabbed for reading&n; *&n; *  Revision 1.11  2001/03/23 07:36:07  starvik&n; *  Corrected according to review remarks&n; *&n; *  Revision 1.10  2001/03/21 16:10:11  bjornw&n; *  CRIS_FRAME_FIXUP not needed anymore, use FRAME_NORMAL&n; *&n; *  Revision 1.9  2001/03/05 13:22:20  bjornw&n; *  Spell-fix and fix in vmalloc_fault handling&n; *&n; *  Revision 1.8  2000/11/22 14:45:31  bjornw&n; *  * 2.4.0-test10 removed the set_pgdir instantaneous kernel global mapping&n; *    into all processes. Instead we fill in the missing PTE entries on demand.&n; *&n; *  Revision 1.7  2000/11/21 16:39:09  bjornw&n; *  fixup switches frametype&n; *&n; *  Revision 1.6  2000/11/17 16:54:08  bjornw&n; *  More detailed siginfo reporting&n; *&n; *&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
r_extern
r_int
id|find_fixup_code
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* debug of low-level TLB reload */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|D
mdefine_line|#define D(x) x
macro_line|#else
DECL|macro|D
mdefine_line|#define D(x)
macro_line|#endif
multiline_comment|/* debug of higher-level faults */
DECL|macro|DPG
mdefine_line|#define DPG(x)
multiline_comment|/* current active page directory */
DECL|variable|current_pgd
r_volatile
id|pgd_t
op_star
id|current_pgd
suffix:semicolon
multiline_comment|/*&n; * This routine handles page faults.  It determines the address,&n; * and the problem, and then passes it off to one of the appropriate&n; * routines.&n; *&n; * Notice that the address we&squot;re given is aligned to the page the fault&n; * occurred in, since we only get the PFN in R_MMU_CAUSE not the complete&n; * address.&n; *&n; * error_code:&n; *&t;bit 0 == 0 means no page found, 1 means protection fault&n; *&t;bit 1 == 0 means read, 1 means write&n; *&n; * If this routine detects a bad access, it returns 1, otherwise it&n; * returns 0.&n; */
id|asmlinkage
r_void
DECL|function|do_page_fault
id|do_page_fault
c_func
(paren
r_int
r_int
id|address
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|protection
comma
r_int
id|writeaccess
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Page fault for %X at %X, prot %d write %d&bslash;n&quot;
comma
id|address
comma
id|regs-&gt;erp
comma
id|protection
comma
id|writeaccess
)paren
)paren
suffix:semicolon
id|tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * We fault-in kernel-space virtual memory on-demand. The&n;&t; * &squot;reference&squot; page table is init_mm.pgd.&n;&t; *&n;&t; * NOTE! We MUST NOT take any locks for this case. We may&n;&t; * be in an interrupt or a critical region, and should&n;&t; * only copy the information from the master page table,&n;&t; * nothing more.&n;&t; *&n;&t; * NOTE2: This is done so that, when updating the vmalloc&n;&t; * mappings we don&squot;t have to walk all processes pgdirs and&n;&t; * add the high mappings all at once. Instead we do it as they&n;&t; * are used. However vmalloc&squot;ed page entries have the PAGE_GLOBAL&n;&t; * bit set so sometimes the TLB can use a lingering entry.&n;&t; *&n;&t; * This verifies that the fault happens in kernel space&n;&t; * and that the fault was not a protection error (error_code &amp; 1).&n;&t; */
r_if
c_cond
(paren
id|address
op_ge
id|VMALLOC_START
op_logical_and
op_logical_neg
id|protection
op_logical_and
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_goto
id|vmalloc_fault
suffix:semicolon
multiline_comment|/* we can and should enable interrupts at this point */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|mm
op_assign
id|tsk-&gt;mm
suffix:semicolon
id|info.si_code
op_assign
id|SEGV_MAPERR
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re in an interrupt or have no user&n;&t; * context, we must not take the fault..&n;&t; */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|mm
)paren
r_goto
id|no_context
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|bad_area
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_le
id|address
)paren
r_goto
id|good_area
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSDOWN
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * accessing the stack below usp is always a bug.&n;&t;&t; * we get page-aligned addresses so we can only check&n;&t;&t; * if we&squot;re within a page from usp, but that might be&n;&t;&t; * enough to catch brutal errors at least.&n;&t;&t; */
r_if
c_cond
(paren
id|address
op_plus
id|PAGE_SIZE
OL
id|rdusp
c_func
(paren
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expand_stack
c_func
(paren
id|vma
comma
id|address
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we have a good vm_area for this memory access, so&n;&t; * we can handle it..&n;&t; */
id|good_area
suffix:colon
id|info.si_code
op_assign
id|SEGV_ACCERR
suffix:semicolon
multiline_comment|/* first do some preliminary protection checks */
r_if
c_cond
(paren
id|writeaccess
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_EXEC
)paren
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If for any reason at all we couldn&squot;t handle the fault,&n;&t; * make sure we exit gracefully rather than endlessly redo&n;&t; * the fault.&n;&t; */
r_switch
c_cond
(paren
id|handle_mm_fault
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|writeaccess
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|tsk-&gt;min_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|tsk-&gt;maj_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|do_sigbus
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_of_memory
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Something tried to access memory that isn&squot;t in our memory map..&n;&t; * Fix it, but check if it&squot;s kernel or user first..&n;&t; */
id|bad_area
suffix:colon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|bad_area_nosemaphore
suffix:colon
id|DPG
c_func
(paren
id|show_registers
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
multiline_comment|/* User mode accesses just cause a SIGSEGV */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|info.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* info.si_code has been set above */
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|info
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|no_context
suffix:colon
multiline_comment|/* Are we prepared to handle this kernel fault?&n;&t; *&n;&t; * (The kernel has valid exception-points in the source &n;&t; *  when it acesses user-memory. When it fails in one&n;&t; *  of those points, we find it in a table and do a jump&n;&t; *  to some fixup code that loads an appropriate error&n;&t; *  code)&n;&t; */
r_if
c_cond
(paren
id|find_fixup_code
c_func
(paren
id|regs
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Oops. The kernel tried to access some bad page. We&squot;ll have to&n;&t; * terminate things with extreme prejudice.&n;&t; */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
(paren
id|address
)paren
OL
id|PAGE_SIZE
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Unable to handle kernel NULL pointer dereference&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Unable to handle kernel access&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at virtual address %08lx&bslash;n&quot;
comma
id|address
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Oops&quot;
comma
id|regs
comma
(paren
id|writeaccess
op_lshift
l_int|1
)paren
op_or
id|protection
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We ran out of memory, or some other thing happened to us that made&n;&t; * us unable to handle the page fault gracefully.&n;&t; */
id|out_of_memory
suffix:colon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VM: killing process %s&bslash;n&quot;
comma
id|tsk-&gt;comm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|do_exit
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
r_goto
id|no_context
suffix:semicolon
id|do_sigbus
suffix:colon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send a sigbus, regardless of whether we were in kernel&n;&t; * or user mode.&n;&t; */
id|info.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|BUS_ADRERR
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|info
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* Kernel mode? Handle exceptions or die */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_goto
id|no_context
suffix:semicolon
r_return
suffix:semicolon
id|vmalloc_fault
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * Synchronize this task&squot;s top level page-table&n;&t;&t; * with the &squot;reference&squot; page table.&n;&t;&t; *&n;&t;&t; * Use current_pgd instead of tsk-&gt;active_mm-&gt;pgd&n;&t;&t; * since the latter might be unavailable if this&n;&t;&t; * code is executed in a misfortunately run irq&n;&t;&t; * (like inside schedule() between switch_mm and&n;&t;&t; *  switch_to...).&n;&t;&t; */
r_int
id|offset
op_assign
id|pgd_index
c_func
(paren
id|address
)paren
suffix:semicolon
id|pgd_t
op_star
id|pgd
comma
op_star
id|pgd_k
suffix:semicolon
id|pmd_t
op_star
id|pmd
comma
op_star
id|pmd_k
suffix:semicolon
id|pte_t
op_star
id|pte_k
suffix:semicolon
id|pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|current_pgd
op_plus
id|offset
suffix:semicolon
id|pgd_k
op_assign
id|init_mm.pgd
op_plus
id|offset
suffix:semicolon
multiline_comment|/* Since we&squot;re two-level, we don&squot;t need to do both&n;&t;&t; * set_pgd and set_pmd (they do the same thing). If&n;&t;&t; * we go three-level at some point, do the right thing&n;&t;&t; * with pgd_present and set_pgd here. &n;&t;&t; * &n;&t;&t; * Also, since the vmalloc area is global, we don&squot;t&n;&t;&t; * need to copy individual PTE&squot;s, it is enough to&n;&t;&t; * copy the pgd pointer into the pte page of the&n;&t;&t; * root task. If that is there, we&squot;ll find our pte if&n;&t;&t; * it exists.&n;&t;&t; */
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
id|pmd_k
op_assign
id|pmd_offset
c_func
(paren
id|pgd_k
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd_k
)paren
)paren
r_goto
id|bad_area_nosemaphore
suffix:semicolon
id|set_pmd
c_func
(paren
id|pmd
comma
op_star
id|pmd_k
)paren
suffix:semicolon
multiline_comment|/* Make sure the actual PTE exists as well to&n;&t;&t; * catch kernel vmalloc-area accesses to non-mapped&n;&t;&t; * addresses. If we don&squot;t do this, this will just&n;&t;&t; * silently loop forever.&n;&t;&t; */
id|pte_k
op_assign
id|pte_offset_kernel
c_func
(paren
id|pmd_k
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
op_star
id|pte_k
)paren
)paren
r_goto
id|no_context
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
eof
