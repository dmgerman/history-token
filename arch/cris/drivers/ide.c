multiline_comment|/* $Id: ide.c,v 1.1.1.1 2001/12/17 13:59:27 bjornw Exp $&n; *&n; * Etrax specific IDE functions, like init and PIO-mode setting etc.&n; * Almost the entire ide.c is used for the rest of the Etrax ATA driver.&n; * Copyright (c) 2000, 2001 Axis Communications AB&n; *&n; * Authors:    Bjorn Wesen        (initial version)&n; *             Mikael Starvik     (pio setup stuff)&n; *&n; * $Log: ide.c,v $&n; * Revision 1.1.1.1  2001/12/17 13:59:27  bjornw&n; * Import of Linux 2.5.1&n; *&n; * Revision 1.19  2001/05/09 12:53:16  johana&n; * Added #include &lt;asm/dma.h&gt;&n; *&n; * Revision 1.18  2001/05/09 12:37:00  johana&n; * Use DMA_NBR macros from dma.h.&n; *&n; * Revision 1.17  2001/04/23 13:36:30  matsfg&n; * Changed CONFIG_IDE_DELAY to CONFIG_ETRAX_IDE_DELAY&n; *&n; * Revision 1.16  2001/04/05 08:30:07  matsfg&n; * Corrected cse1 and csp0 reset.&n; *&n; * Revision 1.15  2001/04/04 14:34:06  bjornw&n; * Re-instated code that mysteriously disappeared during review updates.&n; *&n; * Revision 1.14  2001/04/04 13:45:12  matsfg&n; * Calls REG_SHADOW_SET for cse1 reset so only the resetbit is affected&n; *&n; * Revision 1.13  2001/04/04 13:26:40  matsfg&n; * memmapping is done in init.c&n; *&n; * Revision 1.12  2001/04/04 11:37:56  markusl&n; * Updated according to review remarks&n; *&n; * Revision 1.11  2001/03/29 12:49:14  matsfg&n; * Changed check for ata_tot_size from &gt;= to &gt;.&n; * Sets sw_len to 0 if size is exactly 65536.&n; *&n; * Revision 1.10  2001/03/16 09:39:30  matsfg&n; * Support for reset on port CSP0&n; *&n; * Revision 1.9  2001/03/01 13:11:18  bjornw&n; * 100 -&gt; HZ&n; *&n; * Revision 1.8  2001/03/01 09:32:56  matsfg&n; * Moved IDE delay to a CONFIG-parameter instead&n; *&n; * Revision 1.7  2001/02/23 13:46:38  bjornw&n; * Spellling check&n; *&n; * Revision 1.6  2001/02/22 15:44:30  bjornw&n; * * Use ioremap when mapping the CSE1 memory-mapped reset-line for LX v2&n; * * sw_len for a 65536 descriptor is 0, not 65536&n; * * Express concern for G27 reset code&n; *&n; * Revision 1.5  2001/02/16 07:35:38  matsfg&n; * Now handles DMA request blocks between 64k and 128k by split into two descriptors.&n; *&n; * Revision 1.4  2001/01/10 21:14:32  bjornw&n; * Initialize hwif-&gt;ideproc, for the new way of handling ide_xxx_data&n; *&n; * Revision 1.3  2000/12/01 17:48:18  bjornw&n; * - atapi_output_bytes now uses DMA&n; * - dma_active check removed - the kernel does proper serializing and it had&n; *   a race-condition anyway&n; * - ide_build_dmatable had a nameclash&n; * - re-added the RESET_DMA thingys because sometimes the interface can get&n; *   stuck apparently&n; * - added ide_release_dma&n; *&n; * Revision 1.2  2000/11/29 17:31:29  bjornw&n; * 2.4 port&n; *&n; * - The &quot;register addresses&quot; stored in the hwif are now 32-bit fields that&n; *   don&squot;t need to be shifted into correct positions in R_ATA_CTRL_DATA&n; * - PIO-mode detection temporarily disabled since ide-modes.c is not compiled&n; * - All DMA uses virt_to_phys conversions for DMA buffers and descriptor ptrs&n; * - Probably correct ide_dma_begin semantics in dmaproc now for ATAPI devices&n; * - Removed RESET_DMA when starting a new transfer - why was this necessary ?&n; * - Indentation fix&n; *&n; *&n; */
multiline_comment|/* Regarding DMA: &n; *&n; * There are two forms of DMA - &quot;DMA handshaking&quot; between the interface and the drive,&n; * and DMA between the memory and the interface. We can ALWAYS use the latter, since it&squot;s&n; * something built-in in the Etrax. However only some drives support the DMA-mode handshaking&n; * on the ATA-bus. The normal PC driver and Triton interface disables memory-if DMA when the&n; * device can&squot;t do DMA handshaking for some stupid reason. We don&squot;t need to do that.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/svinto.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
multiline_comment|/* number of Etrax DMA descriptors */
DECL|macro|MAX_DMA_DESCRS
mdefine_line|#define MAX_DMA_DESCRS 64
macro_line|#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
multiline_comment|/* address where the memory-mapped IDE reset bit lives, if used */
DECL|variable|reset_addr
r_static
r_volatile
r_int
r_int
op_star
id|reset_addr
suffix:semicolon
macro_line|#endif
DECL|macro|LOWDB
mdefine_line|#define LOWDB(x)
DECL|macro|D
mdefine_line|#define D(x) 
DECL|function|OUT_BYTE
r_void
id|OUT_BYTE
c_func
(paren
r_int
r_char
id|data
comma
id|ide_ioreg_t
id|reg
)paren
(brace
id|LOWDB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ob: data 0x%x, reg 0x%x&bslash;n&quot;
comma
id|data
comma
id|reg
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for busy flag */
op_star
id|R_ATA_CTRL_DATA
op_assign
id|reg
op_or
id|data
suffix:semicolon
multiline_comment|/* write data to the drive&squot;s register */
r_while
c_loop
(paren
op_logical_neg
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|tr_rdy
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for transmitter ready */
)brace
DECL|function|IN_BYTE
r_int
r_char
id|IN_BYTE
c_func
(paren
id|ide_ioreg_t
id|reg
)paren
(brace
r_int
id|status
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for busy flag */
op_star
id|R_ATA_CTRL_DATA
op_assign
id|reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
suffix:semicolon
multiline_comment|/* read data */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
)paren
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|dav
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for available */
id|LOWDB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;inb: 0x%x from reg 0x%x&bslash;n&quot;
comma
id|status
op_amp
l_int|0xff
comma
id|reg
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
r_char
)paren
id|status
suffix:semicolon
multiline_comment|/* data was in the lower 16 bits in the status reg */
)brace
multiline_comment|/* PIO timing (in R_ATA_CONFIG)&n; *&n; *                        _____________________________&n; * ADDRESS :     ________/&n; *&n; *                            _______________&n; * DIOR    :     ____________/               &bslash;__________&n; *&n; *                               _______________&n; * DATA    :     XXXXXXXXXXXXXXXX_______________XXXXXXXX&n; *&n; *&n; * DIOR is unbuffered while address and data is buffered.&n; * This creates two problems:&n; * 1. The DIOR pulse is to early (because it is unbuffered)&n; * 2. The rise time of DIOR is long&n; *&n; * There are at least three different plausible solutions&n; * 1. Use a pad capable of larger currents in Etrax&n; * 2. Use an external buffer&n; * 3. Make the strobe pulse longer&n; *&n; * Some of the strobe timings below are modified to compensate&n; * for this. This implies a slight performance decrease.&n; *&n; * THIS SHOULD NEVER BE CHANGED!&n; *&n; * TODO: Is this true for the latest LX boards still ?&n; */
DECL|macro|ATA_DMA2_STROBE
mdefine_line|#define ATA_DMA2_STROBE  4 
DECL|macro|ATA_DMA2_HOLD
mdefine_line|#define ATA_DMA2_HOLD    0
DECL|macro|ATA_DMA1_STROBE
mdefine_line|#define ATA_DMA1_STROBE  4 
DECL|macro|ATA_DMA1_HOLD
mdefine_line|#define ATA_DMA1_HOLD    1
DECL|macro|ATA_DMA0_STROBE
mdefine_line|#define ATA_DMA0_STROBE 12 
DECL|macro|ATA_DMA0_HOLD
mdefine_line|#define ATA_DMA0_HOLD    9
DECL|macro|ATA_PIO4_SETUP
mdefine_line|#define ATA_PIO4_SETUP   1
DECL|macro|ATA_PIO4_STROBE
mdefine_line|#define ATA_PIO4_STROBE  5
DECL|macro|ATA_PIO4_HOLD
mdefine_line|#define ATA_PIO4_HOLD    0
DECL|macro|ATA_PIO3_SETUP
mdefine_line|#define ATA_PIO3_SETUP   1
DECL|macro|ATA_PIO3_STROBE
mdefine_line|#define ATA_PIO3_STROBE  5
DECL|macro|ATA_PIO3_HOLD
mdefine_line|#define ATA_PIO3_HOLD    1
DECL|macro|ATA_PIO2_SETUP
mdefine_line|#define ATA_PIO2_SETUP   1
DECL|macro|ATA_PIO2_STROBE
mdefine_line|#define ATA_PIO2_STROBE  6
DECL|macro|ATA_PIO2_HOLD
mdefine_line|#define ATA_PIO2_HOLD    2
DECL|macro|ATA_PIO1_SETUP
mdefine_line|#define ATA_PIO1_SETUP   2
DECL|macro|ATA_PIO1_STROBE
mdefine_line|#define ATA_PIO1_STROBE 11
DECL|macro|ATA_PIO1_HOLD
mdefine_line|#define ATA_PIO1_HOLD    4
DECL|macro|ATA_PIO0_SETUP
mdefine_line|#define ATA_PIO0_SETUP   4
DECL|macro|ATA_PIO0_STROBE
mdefine_line|#define ATA_PIO0_STROBE 19
DECL|macro|ATA_PIO0_HOLD
mdefine_line|#define ATA_PIO0_HOLD    4
r_static
r_int
id|e100_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_void
id|e100_ideproc
(paren
id|ide_ide_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|length
)paren
suffix:semicolon
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mword2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|tune_e100_ide
r_static
r_void
id|tune_e100_ide
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|pio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pio
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* pio = ide_get_best_pio_mode(drive, pio, 4, NULL); */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set pio mode! */
r_switch
c_cond
(paren
id|pio
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO0_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO0_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO0_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO1_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO1_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO1_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO2_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO2_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO3_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO3_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO3_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO4_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO4_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO4_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|init_e100_ide
id|init_e100_ide
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|dummy
suffix:semicolon
r_int
id|h
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: ETRAX 100LX built-in ATA DMA controller&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* first initialize the channel interface data */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
id|h
op_increment
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_etrax100
suffix:semicolon
id|hwif-&gt;tuneproc
op_assign
op_amp
id|tune_e100_ide
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|e100_dmaproc
suffix:semicolon
id|hwif-&gt;ata_read
op_assign
id|e100_ide_input_data
suffix:semicolon
id|hwif-&gt;ata_write
op_assign
id|e100_ide_output_data
suffix:semicolon
id|hwif-&gt;atapi_read
op_assign
id|e100_atapi_read
suffix:semicolon
id|hwif-&gt;atapi_write
op_assign
id|e100_atapi_write
suffix:semicolon
)brace
multiline_comment|/* actually reset and configure the etrax100 ide/ata interface */
multiline_comment|/* This is mystifying; why is not G27 SET anywhere ? It&squot;s just reset here twice. */
multiline_comment|/* de-assert bus-reset */
macro_line|#ifdef CONFIG_ETRAX_IDE_PB7_RESET  
id|port_pb_dir_shadow
op_assign
id|port_pb_dir_shadow
op_or
id|IO_STATE
c_func
(paren
id|R_PORT_PB_DIR
comma
id|dir7
comma
id|output
)paren
suffix:semicolon
op_star
id|R_PORT_PB_DIR
op_assign
id|port_pb_dir_shadow
suffix:semicolon
id|REG_SHADOW_SET
c_func
(paren
id|R_PORT_PB_DATA
comma
id|port_pb_data_shadow
comma
l_int|7
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_G27_RESET
op_star
id|R_PORT_G_DATA
op_assign
l_int|0
suffix:semicolon
macro_line|#endif 
op_star
id|R_ATA_CTRL_DATA
op_assign
l_int|0
suffix:semicolon
op_star
id|R_ATA_TRANSFER_CNT
op_assign
l_int|0
suffix:semicolon
op_star
id|R_ATA_CONFIG
op_assign
l_int|0
suffix:semicolon
id|genconfig_shadow
op_assign
(paren
id|genconfig_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma2
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma3
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|ata
)paren
)paren
op_or
(paren
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma3
comma
id|ata
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma2
comma
id|ata
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|ata
comma
id|select
)paren
)paren
suffix:semicolon
op_star
id|R_GEN_CONFIG
op_assign
id|genconfig_shadow
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
id|init_ioremap
c_func
(paren
)paren
suffix:semicolon
id|REG_SHADOW_SET
c_func
(paren
id|port_cse1_addr
comma
id|port_cse1_shadow
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
id|init_ioremap
c_func
(paren
)paren
suffix:semicolon
id|REG_SHADOW_SET
c_func
(paren
id|port_csp0_addr
comma
id|port_csp0_shadow
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait some */
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_cse1_addr
comma
id|port_cse1_shadow
comma
l_int|16
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_csp0_addr
comma
id|port_csp0_shadow
comma
l_int|8
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_G27_RESET
op_star
id|R_PORT_G_DATA
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* de-assert bus-reset */
macro_line|#endif 
multiline_comment|/* make a dummy read to set the ata controller in a proper state */
id|dummy
op_assign
op_star
id|R_ATA_STATUS_DATA
suffix:semicolon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO4_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO4_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO4_HOLD
)paren
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|addr
comma
l_int|1
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for busy flag*/
op_star
id|R_IRQ_MASK0_SET
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq0
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq1
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq2
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq3
comma
id|set
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: waiting %d seconds for drives to regain consciousness&bslash;n&quot;
comma
id|CONFIG_ETRAX_IDE_DELAY
)paren
suffix:semicolon
id|h
op_assign
id|jiffies
op_plus
(paren
id|CONFIG_ETRAX_IDE_DELAY
op_star
id|HZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|h
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* reset the dma channels we will use */
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
)brace
DECL|variable|mydescr
r_static
id|etrax_dma_descr
id|mydescr
suffix:semicolon
multiline_comment|/*&n; * The following routines are mainly used by the ATAPI drivers.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
r_static
r_void
DECL|function|e100_atapi_read
id|e100_atapi_read
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
id|ide_ioreg_t
id|data_reg
op_assign
id|IDE_DATA_REG
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;atapi_read, dreg 0x%x, buffer 0x%x, count %d&bslash;n&quot;
comma
id|data_reg
comma
id|buffer
comma
id|bytecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytecount
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning, odd bytecount in cdrom_in_bytes = %d.&bslash;n&quot;
comma
id|bytecount
)paren
suffix:semicolon
id|bytecount
op_increment
suffix:semicolon
multiline_comment|/* to round off */
)brace
multiline_comment|/* make sure the DMA channel is available */
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* setup DMA descriptor */
id|mydescr.sw_len
op_assign
id|bytecount
suffix:semicolon
id|mydescr.ctrl
op_assign
id|d_eol
suffix:semicolon
id|mydescr.buf
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* start the dma channel */
op_star
id|R_DMA_CH3_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|mydescr
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma read using PIO handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|bytecount
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
id|LED_DISK_READ
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|LED_DISK_READ
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* old polled transfer code&n;&t; * this should be moved into a new function that can do polled&n;&t; * transfers if DMA is not available&n;&t; */
multiline_comment|/* initiate a multi word read */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|wcount
op_lshift
l_int|1
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
r_register
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* svinto has a latency until the busy bit actually is set */
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* unit should be busy during multi transfer */
r_while
c_loop
(paren
(paren
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
)paren
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|status
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|dav
)paren
)paren
)paren
(brace
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
suffix:semicolon
)brace
op_star
id|ptr
op_increment
op_assign
(paren
r_int
r_int
)paren
(paren
id|status
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|e100_atapi_write
id|e100_atapi_write
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
id|ide_ioreg_t
id|data_reg
op_assign
id|IDE_DATA_REG
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;atapi_write, dreg 0x%x, buffer 0x%x, count %d&bslash;n&quot;
comma
id|data_reg
comma
id|buffer
comma
id|bytecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytecount
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;odd bytecount %d in atapi_out_bytes!&bslash;n&quot;
comma
id|bytecount
)paren
suffix:semicolon
id|bytecount
op_increment
suffix:semicolon
)brace
multiline_comment|/* make sure the DMA channel is available */
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* setup DMA descriptor */
id|mydescr.sw_len
op_assign
id|bytecount
suffix:semicolon
id|mydescr.ctrl
op_assign
id|d_eol
suffix:semicolon
id|mydescr.buf
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* start the dma channel */
op_star
id|R_DMA_CH2_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|mydescr
)paren
suffix:semicolon
op_star
id|R_DMA_CH2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma write using PIO handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|bytecount
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* old polled write code - see comment in input_bytes */
multiline_comment|/* wait for busy flag */
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* initiate a multi word write */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|bytecount
op_rshift
l_int|1
suffix:semicolon
id|ctrl
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
r_register
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Etrax will set busy = 1 until the multi pio transfer has finished&n;         * and tr_rdy = 1 after each succesful word transfer. &n;         * When the last byte has been transferred Etrax will first set tr_tdy = 1 &n;         * and then busy = 0 (not in the same cycle). If we read busy before it&n;         * has been set to 0 we will think that we should transfer more bytes &n;         * and then tr_rdy would be 0 forever. This is solved by checking busy&n;         * in the inner loop.&n;         */
r_do
(brace
op_star
id|R_ATA_CTRL_DATA
op_assign
id|ctrl
op_or
op_star
id|ptr
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|tr_rdy
)paren
)paren
op_logical_and
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif  
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the IDE interface&n; */
r_static
r_void
DECL|function|e100_ide_input_data
id|e100_ide_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|e100_atapi_read
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the IDE interface&n; */
r_static
r_void
DECL|function|e100_ide_output_data
id|e100_ide_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|e100_atapi_write
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* we only have one DMA channel on the chip for ATA, so we can keep these statically */
DECL|variable|ata_descrs
r_static
id|etrax_dma_descr
id|ata_descrs
(braket
id|MAX_DMA_DESCRS
)braket
suffix:semicolon
DECL|variable|ata_tot_size
r_static
r_int
r_int
id|ata_tot_size
suffix:semicolon
multiline_comment|/*&n; * e100_ide_build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; */
DECL|function|e100_ide_build_dmatable
r_static
r_int
id|e100_ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|ata_tot_size
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging and tape requests have (rq-&gt;bh == NULL) */
id|addr
op_assign
id|virt_to_phys
(paren
id|rq-&gt;buffer
)paren
suffix:semicolon
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|virt_to_phys
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_phys
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/* did we run out of descriptors? */
r_if
c_cond
(paren
id|count
op_ge
id|MAX_DMA_DESCRS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: too few DMA descriptors&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* however, this case is more difficult - R_ATA_TRANSFER_CNT cannot be more&n;&t;&t;   than 65536 words per transfer, so in that case we need to either &n;&t;&t;   1) use a DMA interrupt to re-trigger R_ATA_TRANSFER_CNT and continue with&n;&t;&t;      the descriptors, or&n;&t;&t;   2) simply do the request here, and get dma_intr to only ide_end_request on &n;&t;&t;      those blocks that were actually set-up for transfer.&n;&t;&t;*/
r_if
c_cond
(paren
id|ata_tot_size
op_plus
id|size
OG
l_int|131072
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;too large total ATA DMA request, %d + %d!&bslash;n&quot;
comma
id|ata_tot_size
comma
id|size
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If size &gt; 65536 it has to be splitted into new descriptors. Since we don&squot;t handle &n;                   size &gt; 131072 only one split is necessary */
r_if
c_cond
(paren
id|size
OG
l_int|65536
)paren
(brace
multiline_comment|/* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 means 65536, this is a 16-bit field */
id|ata_descrs
(braket
id|count
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|buf
op_assign
id|addr
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|ata_descrs
(braket
id|count
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|ata_tot_size
op_add_assign
l_int|65536
suffix:semicolon
multiline_comment|/* size and addr should refere to not handled data */
id|size
op_sub_assign
l_int|65536
suffix:semicolon
id|addr
op_add_assign
l_int|65536
suffix:semicolon
)brace
multiline_comment|/* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
r_if
c_cond
(paren
id|size
op_eq
l_int|65536
)paren
(brace
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 means 65536, this is a 16-bit field */
)brace
r_else
(brace
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
id|size
suffix:semicolon
)brace
id|ata_descrs
(braket
id|count
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|buf
op_assign
id|addr
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|ata_descrs
(braket
id|count
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|ata_tot_size
op_add_assign
id|size
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* set the end-of-list flag on the last descriptor */
id|ata_descrs
(braket
id|count
op_minus
l_int|1
)braket
dot
id|ctrl
op_or_assign
id|d_eol
suffix:semicolon
multiline_comment|/* return and say all is ok */
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* let the PIO routines handle this weirdness */
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Enable DMA on any drive that supports mword2 DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* DMA not enabled */
)brace
multiline_comment|/*&n; * etrax_dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|etrax_dma_intr
r_static
id|ide_startstop_t
id|etrax_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
comma
id|dma_stat
suffix:semicolon
id|byte
id|stat
suffix:semicolon
id|LED_DISK_READ
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|dma_stat
op_assign
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
suffix:semicolon
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad DMA status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * e100_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; */
DECL|function|e100_dmaproc
r_static
r_int
id|e100_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_static
r_int
r_int
id|reading
suffix:semicolon
multiline_comment|/* static to support ide_dma_begin semantics */
r_int
id|atapi
op_assign
l_int|0
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;e100_dmaproc func %d&bslash;n&quot;
comma
id|func
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_verbose
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_off
suffix:colon
r_case
id|ide_dma_off_quietly
suffix:colon
multiline_comment|/* ok.. we don&squot;t really need to do anything I think. */
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
id|reading
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
id|reading
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_dma_begin
suffix:colon
multiline_comment|/* begin DMA, used by ATAPI devices which want to issue the &n;&t;&t;&t; * appropriate IDE command themselves.&n;&t;&t;&t; *&n;&t;&t;&t; * they have already called ide_dma_read/write to set the&n;&t;&t;&t; * static reading flag, now they call ide_dma_begin to do&n;&t;&t;&t; * the real stuff. we tell our code below not to issue&n;&t;&t;&t; * any IDE commands itself and jump into it. &n;&t;&t;&t; */
id|atapi
op_increment
suffix:semicolon
r_goto
id|dma_begin
suffix:semicolon
r_case
id|ide_dma_end
suffix:colon
multiline_comment|/* returns 1 on error, 0 otherwise */
multiline_comment|/* TODO: check if something went wrong with the DMA */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;e100_dmaproc: unsupported func %d&bslash;n&quot;
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ATAPI-devices (not disks) first call ide_dma_read/write to set the direction&n;&t; * then they call ide_dma_begin after they have issued the appropriate drive command&n;&t; * themselves to actually start the chipset DMA. so we just return here if we&squot;re&n;&t; * not a diskdrive.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
l_int|0
suffix:semicolon
id|dma_begin
suffix:colon
r_if
c_cond
(paren
id|reading
)paren
(brace
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* sometimes the DMA channel get stuck so we need to do this */
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* set up the Etrax DMA descriptors */
r_if
c_cond
(paren
id|e100_ide_build_dmatable
(paren
id|drive
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|atapi
)paren
(brace
multiline_comment|/* set the irq handler which will finish the request when DMA is done */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|etrax_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|WIN_READDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* begin DMA */
op_star
id|R_DMA_CH3_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|ata_descrs
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma read using DMA handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|ata_tot_size
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|data
comma
id|IDE_DATA_REG
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_READ
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;dma read of %d bytes.&bslash;n&quot;
comma
id|ata_tot_size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* writing */
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* sometimes the DMA channel get stuck so we need to do this */
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* set up the Etrax DMA descriptors */
r_if
c_cond
(paren
id|e100_ide_build_dmatable
(paren
id|drive
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|atapi
)paren
(brace
multiline_comment|/* set the irq handler which will finish the request when DMA is done */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|etrax_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* begin DMA */
op_star
id|R_DMA_CH2_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|ata_descrs
)paren
suffix:semicolon
op_star
id|R_DMA_CH2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma write using DMA handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|ata_tot_size
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|data
comma
id|IDE_DATA_REG
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;dma write of %d bytes.&bslash;n&quot;
comma
id|ata_tot_size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* DMA started successfully */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ide.c calls this, but we don&squot;t need to do anything particular */
multiline_comment|/* Dear maintainer of this architecture please note that it would be a little&n; * more clever :-) to put this up into some header as static inline, so the&n; * spurious code below would just vanish.&n; *&n; * --- Marcin Dalecki&n; */
DECL|function|ide_release_dma
r_void
id|ide_release_dma
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
)paren
(brace
multiline_comment|/* empty */
)brace
eof
