multiline_comment|/* $Id: e100lpslavenet.c,v 1.1.1.1 2001/12/17 13:59:27 bjornw Exp $&n; *&n; * e100lpslavenet.c: A network driver for the ETRAX 100LX slave controller.&n; *&n; * Copyright (c) 1998-2001 Axis Communications AB.&n; *&n; * The outline of this driver comes from skeleton.c.&n; *&n; * $Log: e100lpslavenet.c,v $&n; * Revision 1.1.1.1  2001/12/17 13:59:27  bjornw&n; * Import of Linux 2.5.1&n; *&n; * Revision 1.4  2001/06/21 16:55:26  olof&n; * Minimized par port setup time to gain bandwidth&n; *&n; * Revision 1.3  2001/06/21 15:49:02  olof&n; * Removed setting of default MAC address&n; *&n; * Revision 1.2  2001/06/11 15:39:52  olof&n; * Clean up and sync with ethernet.c rev 1.16. Increased reset time of slave.&n; *&n; * Revision 1.1  2001/06/06 08:56:26  olof&n; * Added support for slave Etrax defined by CONFIG_ETRAX_ETHERNET_LPSLAVE&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/svinto.h&gt;     /* DMA and register descriptions */
macro_line|#include &lt;asm/io.h&gt;         /* LED_* I/O functions */
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;e100lpslave.h&quot;
multiline_comment|/* #define ETHDEBUG */
DECL|macro|D
mdefine_line|#define D(x)
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;Etrax 100LX ethernet slave controller&quot;
suffix:semicolon
multiline_comment|/* A default ethernet address. Highlevel SW will set the real one later */
DECL|variable|default_mac
r_static
r_struct
id|sockaddr
id|default_mac
op_assign
(brace
l_int|0
comma
(brace
l_int|0x00
comma
l_int|0x40
comma
l_int|0x8C
comma
l_int|0xCD
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* Tx control lock.  This protects the transmit buffer ring&n;&t; * state along with the &quot;tx full&quot; state of the driver.  This&n;&t; * means all netif_queue flow control actions are protected&n;&t; * by this lock as well.&n;&t; */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Dma descriptors etc. */
DECL|macro|RX_BUF_SIZE
mdefine_line|#define RX_BUF_SIZE 32768
DECL|macro|ETHER_HEAD_LEN
mdefine_line|#define ETHER_HEAD_LEN      14
DECL|macro|PAR0_ECP_IRQ_NBR
mdefine_line|#define PAR0_ECP_IRQ_NBR    4
DECL|macro|RX_DESC_BUF_SIZE
mdefine_line|#define RX_DESC_BUF_SIZE   256
DECL|macro|NBR_OF_RX_DESC
mdefine_line|#define NBR_OF_RX_DESC     (RX_BUF_SIZE / &bslash;&n;&t;&t;&t;    RX_DESC_BUF_SIZE)
multiline_comment|/* Size of slave etrax boot image */
DECL|macro|ETRAX_PAR_BOOT_LENGTH
mdefine_line|#define ETRAX_PAR_BOOT_LENGTH 784
DECL|variable|myNextRxDesc
r_static
id|etrax_dma_descr
op_star
id|myNextRxDesc
suffix:semicolon
multiline_comment|/* Points to the next descriptor to&n;&t;&t;&t;&t;&t;  to be processed */
DECL|variable|myLastRxDesc
r_static
id|etrax_dma_descr
op_star
id|myLastRxDesc
suffix:semicolon
multiline_comment|/* The last processed descriptor */
DECL|variable|myPrevRxDesc
r_static
id|etrax_dma_descr
op_star
id|myPrevRxDesc
suffix:semicolon
multiline_comment|/* The descriptor right before myNextRxDesc */
DECL|variable|RxBuf
r_static
r_int
r_char
id|RxBuf
(braket
id|RX_BUF_SIZE
)braket
suffix:semicolon
DECL|variable|RxDescList
r_static
id|etrax_dma_descr
id|RxDescList
(braket
id|NBR_OF_RX_DESC
)braket
id|__attribute__
(paren
(paren
id|aligned
c_func
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxDescList
r_static
id|etrax_dma_descr
id|TxDescList
(braket
l_int|3
)braket
id|__attribute__
(paren
(paren
id|aligned
c_func
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* host command, data, bogus ECP command */
DECL|variable|tx_skb
r_static
r_struct
id|sk_buff
op_star
id|tx_skb
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_static
r_int
id|etrax_ethernet_lpslave_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|e100_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|e100rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|e100tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ecp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|e100_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|e100_hardware_send_packet
c_func
(paren
r_int
r_int
id|hostcmd
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|update_rx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
)paren
suffix:semicolon
r_static
r_void
id|update_tx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_reset_tranceiver
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|boot_slave
c_func
(paren
r_int
r_char
op_star
id|code
)paren
suffix:semicolon
macro_line|#ifdef ETHDEBUG
r_static
r_void
id|dump_parport_status
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) (*R_DMA_CH0_CMD == 0)
DECL|variable|host_command
r_static
r_int
r_int
id|host_command
suffix:semicolon
r_extern
r_int
r_char
id|e100lpslaveprog
suffix:semicolon
multiline_comment|/*&n; * This driver uses PAR0 to recevice data from slave ETRAX and PAR1 to boot&n; * and send data to slave ETRAX.&n; * Used ETRAX100 DMAchannels with corresponding IRQ:&n; * PAR0 RX : DMA3 - IRQ 19&n; * PAR1 TX : DMA4 - IRQ 20&n; * IRQ 4 is used to detect ECP commands from slave ETRAX&n; *&n; * NOTE! PAR0 and PAR1 shares DMA and IRQ numbers with SER2 and SER3 &n; */
multiline_comment|/*&n; * Check for a network adaptor of this type, and return &squot;0&squot; if one exists.&n; * If dev-&gt;base_addr == 0, probe all likely locations.&n; * If dev-&gt;base_addr == 1, always return failure.&n; * If dev-&gt;base_addr == 2, allocate space for the device and return success&n; * (detachable devices only).&n; */
r_static
r_int
id|__init
DECL|function|etrax_ethernet_lpslave_init
id|etrax_ethernet_lpslave_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|anOffset
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Etrax/100 lpslave ethernet driver v0.3, (c) 1999 Axis Communications AB&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s initialized&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* make Linux aware of the new hardware  */
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: dev == NULL. Should this happen?&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
id|dev
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|panic
c_func
(paren
l_string|&quot;init_etherdev failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* setup generic handlers and stuff in the dev struct */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* make room for the local structure containing stats etc */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
multiline_comment|/* now setup our etrax specific stuff */
id|dev-&gt;irq
op_assign
id|DMA3_RX_IRQ_NBR
suffix:semicolon
multiline_comment|/* we really use DMATX as well... */
id|dev-&gt;dma
op_assign
id|PAR0_RX_DMA_NBR
suffix:semicolon
multiline_comment|/* fill in our handlers so the network layer can talk to us in the future */
id|dev-&gt;open
op_assign
id|e100_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|e100_send_packet
suffix:semicolon
id|dev-&gt;stop
op_assign
id|e100_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|e100_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|e100_set_mac_address
suffix:semicolon
multiline_comment|/* Initialise the list of Etrax DMA-descriptors */
multiline_comment|/* Initialise receive descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_RX_DESC
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RxDescList
(braket
id|i
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
id|anOffset
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|anOffset
op_add_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
)brace
id|RxDescList
(braket
id|i
)braket
dot
id|ctrl
op_assign
id|d_eol
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
id|anOffset
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialise initial pointers */
id|myNextRxDesc
op_assign
op_amp
id|RxDescList
(braket
l_int|0
)braket
suffix:semicolon
id|myLastRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
id|myPrevRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* setup some TX descriptor data */
id|TxDescList
(braket
l_int|0
)braket
dot
id|sw_len
op_assign
l_int|4
suffix:semicolon
id|TxDescList
(braket
l_int|0
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|TxDescList
(braket
l_int|0
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|host_command
)paren
suffix:semicolon
id|TxDescList
(braket
l_int|0
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxDescList
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set MAC address of the interface. called from the core after a&n; * SIOCSIFADDR ioctl, and from the bootup above.&n; */
r_static
r_int
DECL|function|e100_set_mac_address
id|e100_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|sockaddr
op_star
id|addr
op_assign
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* remember it */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
multiline_comment|/* Write it to the hardware.&n;&t; * Note the way the address is wrapped:&n;&t; * *R_NETWORK_SA_0 = a0_0 | (a0_1 &lt;&lt; 8) | (a0_2 &lt;&lt; 16) | (a0_3 &lt;&lt; 24);&n;&t; * *R_NETWORK_SA_1 = a0_4 | (a0_5 &lt;&lt; 8);&n;&t; */
id|tx_skb
op_assign
l_int|0
suffix:semicolon
id|e100_hardware_send_packet
c_func
(paren
id|HOST_CMD_SETMAC
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* show it in the log as well */
id|printk
c_func
(paren
l_string|&quot;%s: changed MAC to &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02X&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open/initialize the board. This is called (in the current kernel)&n; * sometime after booting when the &squot;ifconfig&squot; program is run.&n; *&n; * This routine should set everything up anew at each open, even&n; * registers that &quot;should&quot; only need to be set once at boot, so that&n; * there is non-reboot way to recover if something goes wrong.&n; */
r_static
r_int
DECL|function|e100_open
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* configure the PAR0 (RX) and PAR1 (TX) ports&n;&t; *&n;&t; * perror is nAckReverse, which must be 1 at the TX side,&n;         * and 0 at the RX side&n;         *&n;&t; * select is XFlag, which must be 1 at both sides&n;&t; */
macro_line|#ifdef ETHDEBUG        
id|printk
c_func
(paren
l_string|&quot;Setting up PAR ports&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_PAR0_CONFIG
op_assign
multiline_comment|/* We do not have an external buffer, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|ioe
comma
id|noninv
)paren
op_or
multiline_comment|/* Not connected, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|iseli
comma
id|noninv
)paren
op_or
multiline_comment|/* iautofd is not inverted, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|iautofd
comma
id|noninv
)paren
op_or
multiline_comment|/* Not used in reverse direction, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|istrb
comma
id|noninv
)paren
op_or
multiline_comment|/* Not connected, don&squot;t care /&n;&t;&t;IO_STATE(R_PAR0_CONFIG, iinit,   noninv)    |&n;          /* perror is GND and reverse wants 0, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|iperr
comma
id|noninv
)paren
op_or
multiline_comment|/* ack is not inverted, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|iack
comma
id|noninv
)paren
op_or
multiline_comment|/* busy is not inverted, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|ibusy
comma
id|noninv
)paren
op_or
multiline_comment|/* fault is not inverted, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|ifault
comma
id|noninv
)paren
op_or
multiline_comment|/* select is Vcc and we want 1, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|isel
comma
id|noninv
)paren
op_or
multiline_comment|/* We will run dma, enable */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|dma
comma
id|enable
)paren
op_or
multiline_comment|/* No run length encoding, disable */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|rle_in
comma
id|disable
)paren
op_or
multiline_comment|/* No run length encoding, disable */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|rle_out
comma
id|disable
)paren
op_or
multiline_comment|/* Enable parallel port */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|enable
comma
id|on
)paren
op_or
multiline_comment|/* Force mode regardless of pin status */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|force
comma
id|on
)paren
op_or
multiline_comment|/* We want ECP forward mode since PAR0 is RX */
id|IO_STATE
c_func
(paren
id|R_PAR0_CONFIG
comma
id|mode
comma
id|ecp_rev
)paren
suffix:semicolon
op_star
id|R_PAR1_CONFIG
op_assign
multiline_comment|/* We do not have an external buffer, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|ioe
comma
id|noninv
)paren
op_or
multiline_comment|/* Not connected, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|iseli
comma
id|noninv
)paren
op_or
multiline_comment|/* HostAck must indicate data cycle, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|iautofd
comma
id|noninv
)paren
op_or
multiline_comment|/* HostClk has no external inverter, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|istrb
comma
id|noninv
)paren
op_or
multiline_comment|/* Not connected, don&squot;t care */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|iinit
comma
id|noninv
)paren
op_or
multiline_comment|/* nAckReverse must be 1 in forward mode but is grounded, inv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|iperr
comma
id|inv
)paren
op_or
multiline_comment|/* PeriphClk must be 1 in forward mode, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|iack
comma
id|noninv
)paren
op_or
multiline_comment|/* PeriphAck has no external inverter, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|ibusy
comma
id|noninv
)paren
op_or
multiline_comment|/* nPerihpRequest has no external inverter, noniv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|ifault
comma
id|noninv
)paren
op_or
multiline_comment|/* Select is VCC and we want 1, noninv */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|isel
comma
id|noninv
)paren
op_or
multiline_comment|/* No EPP mode, disable */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|ext_mode
comma
id|disable
)paren
op_or
multiline_comment|/* We will run dma, enable */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|dma
comma
id|enable
)paren
op_or
multiline_comment|/* No run length encoding, disable */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|rle_in
comma
id|disable
)paren
op_or
multiline_comment|/* No run length encoding, disable */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|rle_out
comma
id|disable
)paren
op_or
multiline_comment|/* Enable parallel port */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|enable
comma
id|on
)paren
op_or
multiline_comment|/* Force mode regardless of pin status */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|force
comma
id|on
)paren
op_or
multiline_comment|/* We want ECP forward mode since PAR1 is TX */
id|IO_STATE
c_func
(paren
id|R_PAR1_CONFIG
comma
id|mode
comma
id|ecp_fwd
)paren
suffix:semicolon
multiline_comment|/* Setup time of value * 160 + 20 ns == 20 ns below */
op_star
id|R_PAR1_DELAY
op_assign
id|IO_FIELD
c_func
(paren
id|R_PAR1_DELAY
comma
id|setup
comma
l_int|0
)paren
suffix:semicolon
op_star
id|R_PAR1_CTRL
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0xE000
)paren
op_rshift
l_int|13
)paren
op_ne
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Wait for ECP_FWD mode */
macro_line|#ifdef ETHDEBUG
id|dump_parport_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* make sure ECP irq is acked when we enable it below */
(paren
r_void
)paren
op_star
id|R_PAR0_STATUS_DATA
suffix:semicolon
(paren
r_void
)paren
op_star
id|R_PAR1_STATUS_DATA
suffix:semicolon
multiline_comment|/* Reset and wait for the DMA channels */
id|RESET_DMA
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PAR1_TX_DMA_NBR */
id|RESET_DMA
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* PAR0_RX_DMA_NBR */
id|WAIT_DMA
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* boot the slave Etrax, by sending code on PAR1.&n;&t; * do this before we start up the IRQ handlers and stuff,&n;&t; * beacuse we simply poll for completion in boot_slave.&n;&t; */
id|boot_slave
c_func
(paren
op_amp
id|e100lpslaveprog
)paren
suffix:semicolon
multiline_comment|/* allocate the irq corresponding to the receiving DMA */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|DMA3_RX_IRQ_NBR
comma
id|e100rx_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to allocate DMA3_RX_IRQ_NBR&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|grace_exit
suffix:semicolon
)brace
multiline_comment|/* allocate the irq corresponding to the transmitting DMA */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|DMA4_TX_IRQ_NBR
comma
id|e100tx_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to allocate DMA4_TX_IRQ_NBR&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|grace_exit
suffix:semicolon
)brace
multiline_comment|/* allocate the irq used for detecting ECP commands on the RX port (PAR0) */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|PAR0_ECP_IRQ_NBR
comma
id|ecp_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to allocate PAR0_ECP_IRQ_NBR&bslash;n&quot;
)paren
suffix:semicolon
id|grace_exit
suffix:colon
id|free_irq
c_func
(paren
id|PAR0_ECP_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|DMA4_TX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|DMA3_RX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* We are not allocating DMA since DMA4 is reserved for &squot;cascading&squot;&n;         * and will always fail with the current dma.c&n;         */
multiline_comment|/*&n;&t; * Always allocate the DMA channels after the IRQ,&n;&t; * and clean up on failure.&n;&t; */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|PAR0_RX_DMA_NBR
comma
id|cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to allocate PAR0_RX_DMA_NBR&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|grace_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|PAR1_TX_DMA_NBR
comma
id|cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to allocate PAR1_TX_DMA_NBR&bslash;n&quot;
)paren
suffix:semicolon
id|grace_exit
suffix:colon
multiline_comment|/* this will cause some &squot;trying to free free irq&squot; but what the heck... */
id|free_dma
c_func
(paren
id|PAR1_TX_DMA_NBR
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|PAR0_RX_DMA_NBR
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|PAR0_ECP_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|DMA4_TX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|DMA3_RX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;Par port IRQ and DMA allocated&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable the irq&squot;s for PAR0/1 DMA */
op_star
id|R_IRQ_MASK2_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma3_eop
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma4_descr
comma
id|set
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|par0_ecp_cmd
comma
id|set
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure the irqs are cleared */
op_star
id|R_DMA_CH3_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
op_star
id|R_DMA_CH4_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH4_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* Write the MAC address to the slave HW */
id|udelay
c_func
(paren
l_int|5000
)paren
suffix:semicolon
id|e100_hardware_send_packet
c_func
(paren
id|HOST_CMD_SETMAC
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* make sure the rec and transmit error counters are cleared */
(paren
r_void
)paren
op_star
id|R_REC_COUNTERS
suffix:semicolon
multiline_comment|/* dummy read */
(paren
r_void
)paren
op_star
id|R_TR_COUNTERS
suffix:semicolon
multiline_comment|/* dummy read */
multiline_comment|/* start the receiving DMA channel so we can receive packets from now on */
op_star
id|R_DMA_CH3_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|myNextRxDesc
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We are now ready to accept transmit requeusts from&n;&t; * the queueing layer of the networking.&n;&t; */
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;Starting slave network transmit queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_reset_tranceiver
id|e100_reset_tranceiver
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* To do: Reboot and setup slave Etrax */
)brace
multiline_comment|/* Called by upper layers if they decide it took too long to complete&n; * sending a packet - we need to reset and stuff.&n; */
r_static
r_void
DECL|function|e100_tx_timeout
id|e100_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ problem&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* remember we got an error */
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* reset the TX DMA in case it has hung on something */
id|RESET_DMA
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Reset the tranceiver. */
id|e100_reset_tranceiver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and get rid of the packet that never got an interrupt */
id|dev_kfree_skb
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tell the upper layers we&squot;re ok again */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* This will only be invoked if the driver is _not_ in XOFF state.&n; * What this means is that we need not check it, and that this&n; * invariant will hold if we make sure that the netif_*_queue()&n; * calls are done at the proper times.&n; */
r_static
r_int
DECL|function|e100_send_packet
id|e100_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
macro_line|#ifdef ETHDEBUG
r_int
r_char
op_star
id|temp_data_ptr
op_assign
id|buf
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sending a packet of length %d:&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* dump the first bytes in the packet */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x&bslash;n&quot;
comma
id|i
op_star
l_int|8
comma
id|temp_data_ptr
(braket
l_int|0
)braket
comma
id|temp_data_ptr
(braket
l_int|1
)braket
comma
id|temp_data_ptr
(braket
l_int|2
)braket
comma
id|temp_data_ptr
(braket
l_int|3
)braket
comma
id|temp_data_ptr
(braket
l_int|4
)braket
comma
id|temp_data_ptr
(braket
l_int|5
)braket
comma
id|temp_data_ptr
(braket
l_int|6
)braket
comma
id|temp_data_ptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|temp_data_ptr
op_add_assign
l_int|8
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* protect from tx_interrupt */
id|tx_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/* remember it so we can free it in the tx irq handler later */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|e100_hardware_send_packet
c_func
(paren
id|HOST_CMD_SENDPACK
comma
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* this simple TX driver has only one send-descriptor so we&squot;re full&n;&t; * directly. If this had a send-ring instead, we would only do this if&n;&t; * the ring got full.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The typical workload of the driver:&n; *   Handle the network interface interrupts.&n; */
r_static
r_void
DECL|function|e100rx_interrupt
id|e100rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|irqbits
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_RD
comma
id|dma3_eop
comma
id|active
)paren
)paren
(brace
multiline_comment|/* acknowledge the eop interrupt */
op_star
id|R_DMA_CH3_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* check if one or more complete packets were indeed received */
r_while
c_loop
(paren
op_star
id|R_DMA_CH3_FIRST
op_ne
id|virt_to_phys
c_func
(paren
id|myNextRxDesc
)paren
)paren
(brace
multiline_comment|/* Take out the buffer and give it to the OS, then&n;&t;&t;&t; * allocate a new buffer to put a packet in.&n;&t;&t;&t; */
id|e100_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* restart/continue on the channel, for safety */
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|restart
)paren
suffix:semicolon
multiline_comment|/* clear dma channel 3 eop/descr irq bits */
op_star
id|R_DMA_CH3_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* now, we might have gotten another packet&n;&t;&t;&t;   so we have to loop back and check if so */
)brace
)brace
)brace
multiline_comment|/* the transmit dma channel interrupt&n; *&n; * this is supposed to free the skbuff which was pending during transmission,&n; * and inform the kernel that we can send one more buffer&n; */
r_static
r_void
DECL|function|e100tx_interrupt
id|e100tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|irqbits
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;We got tx interrupt&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check for a dma4_eop interrupt */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_RD
comma
id|dma4_descr
comma
id|active
)paren
)paren
(brace
multiline_comment|/* This protects us from concurrent execution of&n;&t;&t; * our dev-&gt;hard_start_xmit function above.&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* acknowledge the eop interrupt */
op_star
id|R_DMA_CH4_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH4_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* skip *R_DMA_CH4_FIRST == 0 test since we use d_wait... */
r_if
c_cond
(paren
id|tx_skb
)paren
(brace
id|np-&gt;stats.tx_bytes
op_add_assign
id|tx_skb-&gt;len
suffix:semicolon
id|np-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* dma is ready with the transmission of the data in tx_skb, so now we can release the skb memory */
id|dev_kfree_skb_irq
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: tx weird interrupt&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ecp_interrupt
id|ecp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|temp
comma
id|irqbits
op_assign
op_star
id|R_IRQ_MASK0_RD
suffix:semicolon
multiline_comment|/* check for ecp irq */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_MASK0_RD
comma
id|par0_ecp_cmd
)paren
)paren
(brace
multiline_comment|/* acknowledge by reading the bit */
id|temp
op_assign
op_star
id|R_PAR0_STATUS_DATA
suffix:semicolon
multiline_comment|/* force an EOP on the incoming channel, so we&squot;ll get an rx interrupt */
op_star
id|R_SET_EOP
op_assign
id|IO_STATE
c_func
(paren
id|R_SET_EOP
comma
id|ch3_eop
comma
id|set
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|e100_rx
id|e100_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|etrax_dma_descr
op_star
id|mySaveRxDesc
op_assign
id|myNextRxDesc
suffix:semicolon
r_int
r_char
op_star
id|skb_data_ptr
suffix:semicolon
multiline_comment|/* If the packet is broken down in many small packages then merge&n;&t; * count how much space we will need to alloc with skb_alloc() for&n;&t; * it to fit.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|myNextRxDesc-&gt;status
op_amp
id|d_eop
)paren
)paren
(brace
id|length
op_add_assign
id|myNextRxDesc-&gt;sw_len
suffix:semicolon
multiline_comment|/* use sw_len for the first descs */
id|myNextRxDesc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|myNextRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;next
)paren
suffix:semicolon
)brace
id|length
op_add_assign
id|myNextRxDesc-&gt;hw_len
suffix:semicolon
multiline_comment|/* use hw_len for the last descr */
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;Got a packet of length %d:&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* dump the first bytes in the packet */
id|skb_data_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x&bslash;n&quot;
comma
id|i
op_star
l_int|8
comma
id|skb_data_ptr
(braket
l_int|0
)braket
comma
id|skb_data_ptr
(braket
l_int|1
)braket
comma
id|skb_data_ptr
(braket
l_int|2
)braket
comma
id|skb_data_ptr
(braket
l_int|3
)braket
comma
id|skb_data_ptr
(braket
l_int|4
)braket
comma
id|skb_data_ptr
(braket
l_int|5
)braket
comma
id|skb_data_ptr
(braket
l_int|6
)braket
comma
id|skb_data_ptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|skb_data_ptr
op_add_assign
l_int|8
suffix:semicolon
)brace
macro_line|#endif
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_minus
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|np-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_put
c_func
(paren
id|skb
comma
id|length
op_minus
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
multiline_comment|/* allocate room for the packet body */
id|skb_data_ptr
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
multiline_comment|/* allocate room for the header */
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;head = 0x%x, data = 0x%x, tail = 0x%x, end = 0x%x&bslash;n&quot;
comma
id|skb-&gt;head
comma
id|skb-&gt;data
comma
id|skb-&gt;tail
comma
id|skb-&gt;end
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;copying packet to 0x%x.&bslash;n&quot;
comma
id|skb_data_ptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* this loop can be made using max two memcpy&squot;s if optimized */
r_while
c_loop
(paren
id|mySaveRxDesc
op_ne
id|myNextRxDesc
)paren
(brace
id|memcpy
c_func
(paren
id|skb_data_ptr
comma
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
comma
id|mySaveRxDesc-&gt;sw_len
)paren
suffix:semicolon
id|skb_data_ptr
op_add_assign
id|mySaveRxDesc-&gt;sw_len
suffix:semicolon
id|mySaveRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;next
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_data_ptr
comma
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
comma
id|mySaveRxDesc-&gt;hw_len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Send the packet to the upper layers */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Prepare for next packet */
id|myNextRxDesc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|myPrevRxDesc
op_assign
id|myNextRxDesc
suffix:semicolon
id|myNextRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;next
)paren
suffix:semicolon
id|myPrevRxDesc-&gt;ctrl
op_or_assign
id|d_eol
suffix:semicolon
id|myLastRxDesc-&gt;ctrl
op_and_assign
op_complement
id|d_eol
suffix:semicolon
id|myLastRxDesc
op_assign
id|myPrevRxDesc
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|e100_close
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Closing %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|par0_ecp_cmd
comma
id|clr
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK2_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma3_eop
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma4_descr
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* Stop the receiver and the transmitter */
id|RESET_DMA
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|RESET_DMA
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|free_irq
c_func
(paren
id|DMA3_RX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|DMA4_TX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|PAR0_ECP_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|PAR1_TX_DMA_NBR
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|PAR0_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
id|update_rx_stats
c_func
(paren
op_amp
id|np-&gt;stats
)paren
suffix:semicolon
id|update_tx_stats
c_func
(paren
op_amp
id|np-&gt;stats
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|update_rx_stats
id|update_rx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
id|es
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|R_REC_COUNTERS
suffix:semicolon
multiline_comment|/* update stats relevant to reception errors */
id|es-&gt;rx_fifo_errors
op_add_assign
id|r
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/* fifo overrun */
id|es-&gt;rx_crc_errors
op_add_assign
id|r
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* crc error */
id|es-&gt;rx_frame_errors
op_add_assign
(paren
id|r
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* alignment error */
id|es-&gt;rx_length_errors
op_add_assign
(paren
id|r
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* oversized frames */
)brace
r_static
r_void
DECL|function|update_tx_stats
id|update_tx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
id|es
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|R_TR_COUNTERS
suffix:semicolon
multiline_comment|/* update stats relevant to transmission errors */
id|es-&gt;collisions
op_add_assign
(paren
id|r
op_amp
l_int|0xff
)paren
op_plus
(paren
(paren
id|r
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* single_col + multiple_col */
id|es-&gt;tx_errors
op_add_assign
(paren
id|r
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* deferred transmit frames */
)brace
multiline_comment|/*&n; * Get the current statistics.&n; * This may be called with the card open or closed.&n; */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|e100_get_stats
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|update_rx_stats
c_func
(paren
op_amp
id|lp-&gt;stats
)paren
suffix:semicolon
id|update_tx_stats
c_func
(paren
op_amp
id|lp-&gt;stats
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* To do */
)brace
r_void
DECL|function|e100_hardware_send_packet
id|e100_hardware_send_packet
c_func
(paren
r_int
r_int
id|hostcmd
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_static
r_char
id|bogus_ecp
(braket
)braket
op_assign
(brace
l_int|42
comma
l_int|42
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;e100 send pack, buf 0x%x len %d&bslash;n&quot;
comma
id|buf
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
id|host_command
op_assign
id|hostcmd
suffix:semicolon
multiline_comment|/* Configure the tx dma descriptor. Desc 0 is already configured.*/
id|TxDescList
(braket
l_int|1
)braket
dot
id|sw_len
op_assign
id|length
suffix:semicolon
multiline_comment|/* bug workaround - etrax100 needs d_wait on the descriptor _before_&n;&t; * a descriptor containing an ECP command&n;&t; */
id|TxDescList
(braket
l_int|1
)braket
dot
id|ctrl
op_assign
id|d_wait
suffix:semicolon
id|TxDescList
(braket
l_int|1
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|buf
)paren
suffix:semicolon
id|TxDescList
(braket
l_int|1
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxDescList
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* append the ecp dummy descriptor - its only purpose is to &n;&t; * make the receiver generate an irq due to the ecp command&n;&t; * so the receiver knows where packets end&n;&t; */
id|TxDescList
(braket
l_int|2
)braket
dot
id|sw_len
op_assign
l_int|1
suffix:semicolon
id|TxDescList
(braket
l_int|2
)braket
dot
id|ctrl
op_assign
id|d_ecp
op_or
id|d_eol
op_or
id|d_int
suffix:semicolon
id|TxDescList
(braket
l_int|2
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|bogus_ecp
)paren
suffix:semicolon
multiline_comment|/* setup the dma channel and start it */
op_star
id|R_DMA_CH4_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|TxDescList
)paren
suffix:semicolon
op_star
id|R_DMA_CH4_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH4_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
macro_line|#ifdef ETHDEBUG         
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* send a chunk of code to the slave chip to boot it. */
r_static
r_void
DECL|function|boot_slave
id|boot_slave
c_func
(paren
r_int
r_char
op_star
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;  booting slave ETRAX...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_PORT_PB_DATA
op_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* Reset slave */
id|udelay
c_func
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* Time enough to reset WAN tranciever */
op_star
id|R_PORT_PB_DATA
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Reset slave */
multiline_comment|/* configure the tx dma data descriptor */
id|TxDescList
(braket
l_int|1
)braket
dot
id|sw_len
op_assign
id|ETRAX_PAR_BOOT_LENGTH
suffix:semicolon
id|TxDescList
(braket
l_int|1
)braket
dot
id|ctrl
op_assign
id|d_eol
op_or
id|d_int
suffix:semicolon
id|TxDescList
(braket
l_int|1
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|code
)paren
suffix:semicolon
id|TxDescList
(braket
l_int|1
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* setup the dma channel and start it */
op_star
id|R_DMA_CH4_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxDescList
(braket
l_int|1
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH4_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH4_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
r_while
c_loop
(paren
op_logical_neg
(paren
op_star
id|R_IRQ_READ2
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_READ2
comma
id|dma4_descr
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* ack the irq */
op_star
id|R_DMA_CH4_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH4_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* manual transfer of boot code - requires dma turned off */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETRAX_PAR_BOOT_LENGTH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  sending byte: %u value: %x&bslash;n&quot;
comma
id|i
comma
id|code
(braket
id|i
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait while tr_rdy is busy*/
op_star
id|R_PAR1_CTRL_DATA
op_assign
id|code
(braket
id|i
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;  done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef ETHDEBUG
multiline_comment|/* debug code to check the current status of PAR1 */
r_static
r_void
DECL|function|dump_parport_status
id|dump_parport_status
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Parport1 status:&bslash;n&quot;
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0xE000
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|13
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg mode: %u (ecp_fwd(5), ecp_rev(6))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x1000
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|12
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg perr: %u (ecp_rev(0))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x0800
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|11
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg ack: %u (inactive (1), active (0))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x0400
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|10
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg busy: %u (inactive (0), active (1))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x0200
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|9
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg fault: %u (inactive (1), active (0))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x0100
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|8
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg sel: %u (inactive (0), active (1), xflag(1))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|temp
op_assign
(paren
op_star
id|R_PAR1_STATUS
)paren
op_amp
l_int|0x02
suffix:semicolon
id|temp
op_assign
id|temp
op_rshift
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reg tr_rdy: %u (busy (0), ready (1))&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
)brace
macro_line|#endif /* ETHDEBUG */
DECL|variable|dev_etrax_slave_ethernet
r_static
r_struct
id|net_device
id|dev_etrax_slave_ethernet
suffix:semicolon
r_static
r_int
DECL|function|etrax_init_module
id|etrax_init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|d
op_assign
op_amp
id|dev_etrax_slave_ethernet
suffix:semicolon
id|d-&gt;init
op_assign
id|etrax_ethernet_lpslave_init
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|d
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|etrax_init_module
id|module_init
c_func
(paren
id|etrax_init_module
)paren
suffix:semicolon
eof
