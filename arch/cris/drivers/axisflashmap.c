multiline_comment|/*&n; * Physical mapping layer for MTD using the Axis partitiontable format&n; *&n; * Copyright (c) 2001 Axis Communications AB&n; *&n; * This file is under the GPL.&n; *&n; * First partition is always sector 0 regardless of if we find a partitiontable&n; * or not. In the start of the next sector, there can be a partitiontable that&n; * tells us what other partitions to define. If there isn&squot;t, we use a default&n; * partition split defined below.&n; *&n; * $Log: axisflashmap.c,v $&n; * Revision 1.14  2001/09/21 07:14:10  jonashg&n; * Made root filesystem (cramfs) use mtdblock driver when booting from flash.&n; *&n; * Revision 1.13  2001/08/15 13:57:35  jonashg&n; * Entire MTD updated to the linux 2.4.7 version.&n; *&n; * Revision 1.12  2001/06/11 09:50:30  jonashg&n; * Oops, 2MB is 0x200000 bytes.&n; *&n; * Revision 1.11  2001/06/08 11:39:44  jonashg&n; * Changed sizes and offsets in axis_default_partitions to use&n; * CONFIG_ETRAX_PTABLE_SECTOR.&n; *&n; * Revision 1.10  2001/05/29 09:42:03  jonashg&n; * Use macro for end marker length instead of sizeof.&n; *&n; * Revision 1.9  2001/05/29 08:52:52  jonashg&n; * Gave names to the magic fours (size of the ptable end marker).&n; *&n; * Revision 1.8  2001/05/28 15:36:20  jonashg&n; * * Removed old comment about ptable location in flash (it&squot;s a CONFIG_ option).&n; * * Variable ptable was initialized twice to the same value.&n; *&n; * Revision 1.7  2001/04/05 13:41:46  markusl&n; * Updated according to review remarks&n; *&n; * Revision 1.6  2001/03/07 09:21:21  bjornw&n; * No need to waste .data&n; *&n; * Revision 1.5  2001/03/06 16:27:01  jonashg&n; * Probe the entire flash area for flash devices.&n; *&n; * Revision 1.4  2001/02/23 12:47:15  bjornw&n; * Uncached flash in LOW_MAP moved from 0xe to 0x8&n; *&n; * Revision 1.3  2001/02/16 12:11:45  jonashg&n; * MTD driver amd_flash is now included in MTD CVS repository.&n; * (It&squot;s now in drivers/mtd).&n; *&n; * Revision 1.2  2001/02/09 11:12:22  jonashg&n; * Support for AMD compatible non-CFI flash chips.&n; * Only tested with Toshiba TC58FVT160 so far.&n; *&n; * Revision 1.1  2001/01/12 17:01:18  bjornw&n; * * Added axisflashmap.c, a physical mapping for MTD that reads and understands&n; *   Axis partition-table format.&n; *&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/map.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;asm/axisflashmap.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#ifdef CONFIG_CRIS_LOW_MAP
DECL|macro|FLASH_UNCACHED_ADDR
mdefine_line|#define FLASH_UNCACHED_ADDR  KSEG_8
DECL|macro|FLASH_CACHED_ADDR
mdefine_line|#define FLASH_CACHED_ADDR    KSEG_5
macro_line|#else
DECL|macro|FLASH_UNCACHED_ADDR
mdefine_line|#define FLASH_UNCACHED_ADDR  KSEG_E
DECL|macro|FLASH_CACHED_ADDR
mdefine_line|#define FLASH_CACHED_ADDR    KSEG_F
macro_line|#endif
multiline_comment|/*&n; * WINDOW_SIZE is the total size where the flash chips may be mapped.&n; * MTD probes should find all devices there and it does not matter&n; * if there are unmapped gaps or aliases (mirrors of flash devices).&n; * The MTD probes will ignore them.&n; */
DECL|macro|WINDOW_SIZE
mdefine_line|#define WINDOW_SIZE  (128 * 1024 * 1024)
r_extern
r_int
r_int
id|romfs_start
comma
id|romfs_length
comma
id|romfs_in_flash
suffix:semicolon
multiline_comment|/* From head.S */
multiline_comment|/* &n; * Map driver&n; *&n; * Ok this is the scoop - we need to access the flash both with and without&n; * the cache - without when doing all the fancy flash interfacing, and with&n; * when we do actual copying because otherwise it will be slow like molasses.&n; */
DECL|function|flash_read8
r_static
id|__u8
id|flash_read8
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|ofs
)paren
(brace
r_return
op_star
(paren
id|__u8
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|ofs
)paren
suffix:semicolon
)brace
DECL|function|flash_read16
r_static
id|__u16
id|flash_read16
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|ofs
)paren
(brace
r_return
op_star
(paren
id|__u16
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|ofs
)paren
suffix:semicolon
)brace
DECL|function|flash_read32
r_static
id|__u32
id|flash_read32
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|ofs
)paren
(brace
r_return
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|ofs
)paren
suffix:semicolon
)brace
DECL|function|flash_copy_from
r_static
r_void
id|flash_copy_from
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_void
op_star
id|to
comma
r_int
r_int
id|from
comma
id|ssize_t
id|len
)paren
(brace
id|memcpy
c_func
(paren
id|to
comma
(paren
r_void
op_star
)paren
(paren
id|FLASH_CACHED_ADDR
op_plus
id|from
)paren
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|flash_write8
r_static
r_void
id|flash_write8
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u8
id|d
comma
r_int
r_int
id|adr
)paren
(brace
op_star
(paren
id|__u8
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|adr
)paren
op_assign
id|d
suffix:semicolon
)brace
DECL|function|flash_write16
r_static
r_void
id|flash_write16
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u16
id|d
comma
r_int
r_int
id|adr
)paren
(brace
op_star
(paren
id|__u16
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|adr
)paren
op_assign
id|d
suffix:semicolon
)brace
DECL|function|flash_write32
r_static
r_void
id|flash_write32
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u32
id|d
comma
r_int
r_int
id|adr
)paren
(brace
op_star
(paren
id|__u32
op_star
)paren
(paren
id|FLASH_UNCACHED_ADDR
op_plus
id|adr
)paren
op_assign
id|d
suffix:semicolon
)brace
DECL|variable|axis_map
r_static
r_struct
id|map_info
id|axis_map
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Axis flash&quot;
comma
id|size
suffix:colon
id|WINDOW_SIZE
comma
id|buswidth
suffix:colon
id|CONFIG_ETRAX_FLASH_BUSWIDTH
comma
id|read8
suffix:colon
id|flash_read8
comma
id|read16
suffix:colon
id|flash_read16
comma
id|read32
suffix:colon
id|flash_read32
comma
id|copy_from
suffix:colon
id|flash_copy_from
comma
id|write8
suffix:colon
id|flash_write8
comma
id|write16
suffix:colon
id|flash_write16
comma
id|write32
suffix:colon
id|flash_write32
comma
)brace
suffix:semicolon
multiline_comment|/* If no partition-table was found, we use this default-set.&n; */
DECL|macro|MAX_PARTITIONS
mdefine_line|#define MAX_PARTITIONS         7  
DECL|macro|NUM_DEFAULT_PARTITIONS
mdefine_line|#define NUM_DEFAULT_PARTITIONS 3
multiline_comment|/* Default flash size is 2MB. CONFIG_ETRAX_PTABLE_SECTOR is most likely the&n; * size of one flash block and &quot;filesystem&quot;-partition needs 5 blocks to be able&n; * to use JFFS.&n; */
DECL|variable|axis_default_partitions
r_static
r_struct
id|mtd_partition
id|axis_default_partitions
(braket
id|NUM_DEFAULT_PARTITIONS
)braket
op_assign
(brace
(brace
id|name
suffix:colon
l_string|&quot;boot firmware&quot;
comma
id|size
suffix:colon
id|CONFIG_ETRAX_PTABLE_SECTOR
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;kernel&quot;
comma
id|size
suffix:colon
l_int|0x200000
op_minus
(paren
l_int|6
op_star
id|CONFIG_ETRAX_PTABLE_SECTOR
)paren
comma
id|offset
suffix:colon
id|CONFIG_ETRAX_PTABLE_SECTOR
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;filesystem&quot;
comma
id|size
suffix:colon
l_int|5
op_star
id|CONFIG_ETRAX_PTABLE_SECTOR
comma
id|offset
suffix:colon
l_int|0x200000
op_minus
(paren
l_int|5
op_star
id|CONFIG_ETRAX_PTABLE_SECTOR
)paren
)brace
)brace
suffix:semicolon
DECL|variable|axis_partitions
r_static
r_struct
id|mtd_partition
id|axis_partitions
(braket
id|MAX_PARTITIONS
)braket
op_assign
(brace
(brace
id|name
suffix:colon
l_string|&quot;part0&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part1&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part2&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part3&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part4&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part5&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
(brace
id|name
suffix:colon
l_string|&quot;part6&quot;
comma
id|size
suffix:colon
l_int|0
comma
id|offset
suffix:colon
l_int|0
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * This is the master MTD device for which all the others are just&n; * auto-relocating aliases.&n; */
DECL|variable|mymtd
r_static
r_struct
id|mtd_info
op_star
id|mymtd
suffix:semicolon
multiline_comment|/* CFI-scan the flash, and if there was a chip, read the partition-table&n; * and register the partitions with MTD.&n; */
r_static
r_int
id|__init
DECL|function|init_axis_flash
id|init_axis_flash
c_func
(paren
r_void
)paren
(brace
r_int
id|pidx
op_assign
l_int|0
suffix:semicolon
r_struct
id|partitiontable_head
op_star
id|ptable_head
suffix:semicolon
r_struct
id|partitiontable_entry
op_star
id|ptable
suffix:semicolon
r_int
id|use_default_ptable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Until proven otherwise */
r_const
r_char
op_star
id|pmsg
op_assign
l_string|&quot;  /dev/flash%d at 0x%x, size 0x%x&bslash;n&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Axis flash mapping: %x at %x&bslash;n&quot;
comma
id|WINDOW_SIZE
comma
id|FLASH_CACHED_ADDR
)paren
suffix:semicolon
id|mymtd
op_assign
(paren
r_struct
id|mtd_info
op_star
)paren
id|do_map_probe
c_func
(paren
l_string|&quot;cfi&quot;
comma
op_amp
id|axis_map
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_AMDSTD
r_if
c_cond
(paren
op_logical_neg
id|mymtd
)paren
(brace
id|mymtd
op_assign
(paren
r_struct
id|mtd_info
op_star
)paren
id|do_map_probe
c_func
(paren
l_string|&quot;amd_flash&quot;
comma
op_amp
id|axis_map
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|mymtd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: No flash chip found!&bslash;n&quot;
comma
id|axis_map.name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|mymtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|ptable_head
op_assign
(paren
r_struct
id|partitiontable_head
op_star
)paren
(paren
id|FLASH_CACHED_ADDR
op_plus
id|CONFIG_ETRAX_PTABLE_SECTOR
op_plus
id|PARTITION_TABLE_OFFSET
)paren
suffix:semicolon
id|pidx
op_increment
suffix:semicolon
multiline_comment|/* first partition is always set to the default */
r_if
c_cond
(paren
(paren
id|ptable_head-&gt;magic
op_eq
id|PARTITION_TABLE_MAGIC
)paren
op_logical_and
(paren
id|ptable_head-&gt;size
OL
(paren
id|MAX_PARTITIONS
op_star
r_sizeof
(paren
r_struct
id|partitiontable_entry
)paren
op_plus
id|PARTITIONTABLE_END_MARKER_SIZE
)paren
)paren
op_logical_and
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_void
op_star
)paren
id|ptable_head
op_plus
r_sizeof
(paren
op_star
id|ptable_head
)paren
op_plus
id|ptable_head-&gt;size
op_minus
id|PARTITIONTABLE_END_MARKER_SIZE
)paren
op_eq
id|PARTITIONTABLE_END_MARKER
)paren
)paren
(brace
multiline_comment|/* Looks like a start, sane length and end of a&n;&t;&t; * partition table, lets check csum etc.&n;&t;&t; */
r_int
id|ptable_ok
op_assign
l_int|0
suffix:semicolon
r_struct
id|partitiontable_entry
op_star
id|max_addr
op_assign
(paren
r_struct
id|partitiontable_entry
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|ptable_head
op_plus
r_sizeof
(paren
op_star
id|ptable_head
)paren
op_plus
id|ptable_head-&gt;size
)paren
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|CONFIG_ETRAX_PTABLE_SECTOR
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|csum
op_assign
l_int|0
suffix:semicolon
id|ptable
op_assign
(paren
r_struct
id|partitiontable_entry
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|ptable_head
op_plus
r_sizeof
(paren
op_star
id|ptable_head
)paren
)paren
suffix:semicolon
multiline_comment|/* Lets be PARANOID, and check the checksum. */
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|ptable
suffix:semicolon
r_while
c_loop
(paren
id|p
op_le
(paren
r_int
r_char
op_star
)paren
id|max_addr
)paren
(brace
id|csum
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
id|csum
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
id|csum
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
id|csum
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* printk(&quot;  total csum: 0x%08X 0x%08X&bslash;n&quot;,&n;&t;&t;   csum, ptable_head-&gt;checksum); */
id|ptable_ok
op_assign
(paren
id|csum
op_eq
id|ptable_head-&gt;checksum
)paren
suffix:semicolon
multiline_comment|/* Read the entries and use/show the info.  */
id|printk
c_func
(paren
l_string|&quot; Found %s partition table at 0x%08lX-0x%08lX.&bslash;n&quot;
comma
(paren
id|ptable_ok
ques
c_cond
l_string|&quot;valid&quot;
suffix:colon
l_string|&quot;invalid&quot;
)paren
comma
(paren
r_int
r_int
)paren
id|ptable_head
comma
(paren
r_int
r_int
)paren
id|max_addr
)paren
suffix:semicolon
multiline_comment|/* We have found a working bootblock.  Now read the&n;&t;&t;   partition table.  Scan the table.  It ends when&n;&t;&t;   there is 0xffffffff, that is, empty flash.  */
r_while
c_loop
(paren
id|ptable_ok
op_logical_and
id|ptable-&gt;offset
op_ne
l_int|0xffffffff
op_logical_and
id|ptable
OL
id|max_addr
op_logical_and
id|pidx
OL
id|MAX_PARTITIONS
)paren
(brace
id|axis_partitions
(braket
id|pidx
)braket
dot
id|offset
op_assign
id|offset
op_plus
id|ptable-&gt;offset
suffix:semicolon
id|axis_partitions
(braket
id|pidx
)braket
dot
id|size
op_assign
id|ptable-&gt;size
suffix:semicolon
id|printk
c_func
(paren
id|pmsg
comma
id|pidx
comma
id|axis_partitions
(braket
id|pidx
)braket
dot
id|offset
comma
id|axis_partitions
(braket
id|pidx
)braket
dot
id|size
)paren
suffix:semicolon
id|pidx
op_increment
suffix:semicolon
id|ptable
op_increment
suffix:semicolon
)brace
id|use_default_ptable
op_assign
op_logical_neg
id|ptable_ok
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_default_ptable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Using default partition table&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|add_mtd_partitions
c_func
(paren
id|mymtd
comma
id|axis_default_partitions
comma
id|NUM_DEFAULT_PARTITIONS
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|romfs_in_flash
)paren
(brace
id|axis_partitions
(braket
id|pidx
)braket
dot
id|name
op_assign
l_string|&quot;romfs&quot;
suffix:semicolon
id|axis_partitions
(braket
id|pidx
)braket
dot
id|size
op_assign
id|romfs_length
suffix:semicolon
id|axis_partitions
(braket
id|pidx
)braket
dot
id|offset
op_assign
id|romfs_start
op_minus
id|FLASH_CACHED_ADDR
suffix:semicolon
id|axis_partitions
(braket
id|pidx
)braket
dot
id|mask_flags
op_or_assign
id|MTD_WRITEABLE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Adding readonly partition for romfs image:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|pmsg
comma
id|pidx
comma
id|axis_partitions
(braket
id|pidx
)braket
dot
id|offset
comma
id|axis_partitions
(braket
id|pidx
)braket
dot
id|size
)paren
suffix:semicolon
id|pidx
op_increment
suffix:semicolon
)brace
r_return
id|add_mtd_partitions
c_func
(paren
id|mymtd
comma
id|axis_partitions
comma
id|pidx
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This adds the above to the kernels init-call chain */
DECL|variable|init_axis_flash
id|module_init
c_func
(paren
id|init_axis_flash
)paren
suffix:semicolon
eof
