multiline_comment|/* $Id: ethernet.c,v 1.17 2001/06/11 12:43:46 olof Exp $&n; *&n; * e100net.c: A network driver for the ETRAX 100LX network controller.&n; *&n; * Copyright (c) 1998-2001 Axis Communications AB.&n; *&n; * The outline of this driver comes from skeleton.c.&n; *&n; * $Log: ethernet.c,v $&n; * Revision 1.17  2001/06/11 12:43:46  olof&n; * Modified defines for network LED behavior&n; *&n; * Revision 1.16  2001/05/30 06:12:46  markusl&n; * TxDesc.next should not be set to NULL&n; *&n; * Revision 1.15  2001/05/29 10:27:04  markusl&n; * Updated after review remarks:&n; * +Use IO_EXTRACT&n; * +Handle underrun&n; *&n; * Revision 1.14  2001/05/29 09:20:14  jonashg&n; * Use driver name on printk output so one can tell which driver that complains.&n; *&n; * Revision 1.13  2001/05/09 12:35:59  johana&n; * Use DMA_NBR and IRQ_NBR defines from dma.h and irq.h&n; *&n; * Revision 1.12  2001/04/05 11:43:11  tobiasa&n; * Check dev before panic.&n; *&n; * Revision 1.11  2001/04/04 11:21:05  markusl&n; * Updated according to review remarks&n; *&n; * Revision 1.10  2001/03/26 16:03:06  bjornw&n; * Needs linux/config.h&n; *&n; * Revision 1.9  2001/03/19 14:47:48  pkj&n; * * Make sure there is always a pause after the network LEDs are&n; *   changed so they will not look constantly lit during heavy traffic.&n; * * Always use HZ when setting times relative to jiffies.&n; * * Use LED_NETWORK_SET() when setting the network LEDs.&n; *&n; * Revision 1.8  2001/02/27 13:52:48  bjornw&n; * malloc.h -&gt; slab.h&n; *&n; * Revision 1.7  2001/02/23 13:46:38  bjornw&n; * Spellling check&n; *&n; * Revision 1.6  2001/01/26 15:21:04  starvik&n; * Don&squot;t disable interrupts while reading MDIO registers (MDIO is slow)&n; * Corrected promiscuous mode&n; * Improved deallocation of IRQs (&quot;ifconfig eth0 down&quot; now works)&n; *&n; * Revision 1.5  2000/11/29 17:22:22  bjornw&n; * Get rid of the udword types legacy stuff&n; *&n; * Revision 1.4  2000/11/22 16:36:09  bjornw&n; * Please marketing by using the correct case when spelling Etrax.&n; *&n; * Revision 1.3  2000/11/21 16:43:04  bjornw&n; * Minor short-&gt;int change&n; *&n; * Revision 1.2  2000/11/08 14:27:57  bjornw&n; * 2.4 port&n; *&n; * Revision 1.1  2000/11/06 13:56:00  bjornw&n; * Verbatim copy of the 1.24 version of e100net.c from elinux&n; *&n; * Revision 1.24  2000/10/04 15:55:23  bjornw&n; * * Use virt_to_phys etc. for DMA addresses&n; * * Removed bogus CHECKSUM_UNNECESSARY&n; *&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/svinto.h&gt;     /* DMA and register descriptions */
macro_line|#include &lt;asm/io.h&gt;         /* LED_* I/O functions */
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
singleline_comment|//#define ETHDEBUG
DECL|macro|D
mdefine_line|#define D(x)
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;ETRAX 100LX built-in ethernet controller&quot;
suffix:semicolon
multiline_comment|/* A default ethernet address. Highlevel SW will set the real one later */
DECL|variable|default_mac
r_static
r_struct
id|sockaddr
id|default_mac
op_assign
(brace
l_int|0
comma
(brace
l_int|0x00
comma
l_int|0x40
comma
l_int|0x8C
comma
l_int|0xCD
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* Tx control lock.  This protects the transmit buffer ring&n;&t; * state along with the &quot;tx full&quot; state of the driver.  This&n;&t; * means all netif_queue flow control actions are protected&n;&t; * by this lock as well.&n;&t; */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Dma descriptors etc. */
DECL|macro|RX_BUF_SIZE
mdefine_line|#define RX_BUF_SIZE 32768
DECL|macro|MAX_MEDIA_DATA_SIZE
mdefine_line|#define MAX_MEDIA_DATA_SIZE 1518
DECL|macro|MIN_PACKET_LEN
mdefine_line|#define MIN_PACKET_LEN      46
DECL|macro|ETHER_HEAD_LEN
mdefine_line|#define ETHER_HEAD_LEN      14
multiline_comment|/* &n;** MDIO constants.&n;*/
DECL|macro|MDIO_BASE_STATUS_REG
mdefine_line|#define MDIO_BASE_STATUS_REG   0x1
DECL|macro|MDIO_BASE_CONTROL_REG
mdefine_line|#define MDIO_BASE_CONTROL_REG  0x0
DECL|macro|MDIO_LINK_UP_MASK
mdefine_line|#define MDIO_LINK_UP_MASK      0x4
DECL|macro|MDIO_START
mdefine_line|#define MDIO_START                          0x1
DECL|macro|MDIO_READ
mdefine_line|#define MDIO_READ                           0x2
DECL|macro|MDIO_WRITE
mdefine_line|#define MDIO_WRITE                          0x1
DECL|macro|MDIO_PREAMBLE
mdefine_line|#define MDIO_PREAMBLE              0xfffffffful
multiline_comment|/* Broadcom specific */
DECL|macro|MDIO_AUX_CTRL_STATUS_REG
mdefine_line|#define MDIO_AUX_CTRL_STATUS_REG           0x18
DECL|macro|MDIO_SPEED
mdefine_line|#define MDIO_SPEED                          0x2
DECL|macro|MDIO_PHYS_ADDR
mdefine_line|#define MDIO_PHYS_ADDR                      0x0
multiline_comment|/* Network flash constants */
DECL|macro|NET_FLASH_TIME
mdefine_line|#define NET_FLASH_TIME                  (HZ/50) /* 20 ms */
DECL|macro|NET_FLASH_PAUSE
mdefine_line|#define NET_FLASH_PAUSE                (HZ/100) /* 10 ms */
DECL|macro|NET_LINK_UP_CHECK_INTERVAL
mdefine_line|#define NET_LINK_UP_CHECK_INTERVAL       (2*HZ) /* 2 s   */
DECL|macro|NO_NETWORK_ACTIVITY
mdefine_line|#define NO_NETWORK_ACTIVITY 0
DECL|macro|NETWORK_ACTIVITY
mdefine_line|#define NETWORK_ACTIVITY    1
DECL|macro|RX_DESC_BUF_SIZE
mdefine_line|#define RX_DESC_BUF_SIZE   256
DECL|macro|NBR_OF_RX_DESC
mdefine_line|#define NBR_OF_RX_DESC     (RX_BUF_SIZE / &bslash;&n;&t;&t;&t;    RX_DESC_BUF_SIZE)
DECL|macro|GET_BIT
mdefine_line|#define GET_BIT(bit,val)   (((val) &gt;&gt; (bit)) &amp; 0x01)
DECL|variable|myNextRxDesc
r_static
id|etrax_dma_descr
op_star
id|myNextRxDesc
suffix:semicolon
multiline_comment|/* Points to the next descriptor to&n;&t;&t;&t;&t;&t;  to be processed */
DECL|variable|myLastRxDesc
r_static
id|etrax_dma_descr
op_star
id|myLastRxDesc
suffix:semicolon
multiline_comment|/* The last processed descriptor */
DECL|variable|myPrevRxDesc
r_static
id|etrax_dma_descr
op_star
id|myPrevRxDesc
suffix:semicolon
multiline_comment|/* The descriptor right before myNextRxDesc */
DECL|variable|RxBuf
r_static
r_int
r_char
id|RxBuf
(braket
id|RX_BUF_SIZE
)braket
suffix:semicolon
DECL|variable|RxDescList
r_static
id|etrax_dma_descr
id|RxDescList
(braket
id|NBR_OF_RX_DESC
)braket
id|__attribute__
(paren
(paren
id|aligned
c_func
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxDesc
r_static
id|etrax_dma_descr
id|TxDesc
id|__attribute__
(paren
(paren
id|aligned
c_func
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|tx_skb
r_static
r_struct
id|sk_buff
op_star
id|tx_skb
suffix:semicolon
multiline_comment|/* Network speed indication. */
DECL|variable|speed_timer
r_static
r_struct
id|timer_list
id|speed_timer
suffix:semicolon
DECL|variable|clear_led_timer
r_static
r_struct
id|timer_list
id|clear_led_timer
suffix:semicolon
DECL|variable|current_speed
r_static
r_int
id|current_speed
suffix:semicolon
DECL|variable|led_next_time
r_static
r_int
id|led_next_time
suffix:semicolon
DECL|variable|led_active
r_static
r_int
id|led_active
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_static
r_int
id|etrax_ethernet_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|e100_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|e100rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|e100tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|e100nw_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|e100_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|e100_hardware_send_packet
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|update_rx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
)paren
suffix:semicolon
r_static
r_void
id|update_tx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_check_speed
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_int
r_int
id|e100_get_mdio_reg
c_func
(paren
r_int
r_char
id|reg_num
)paren
suffix:semicolon
r_static
r_void
id|e100_send_mdio_cmd
c_func
(paren
r_int
r_int
id|cmd
comma
r_int
id|write_cmd
)paren
suffix:semicolon
r_static
r_void
id|e100_send_mdio_bit
c_func
(paren
r_int
r_char
id|bit
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_receive_mdio_bit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|e100_reset_tranceiver
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|e100_clear_network_leds
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|e100_set_network_leds
c_func
(paren
r_int
id|active
)paren
suffix:semicolon
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) (*R_DMA_CH0_CMD == 0)
multiline_comment|/*&n; * Check for a network adaptor of this type, and return &squot;0&squot; if one exists.&n; * If dev-&gt;base_addr == 0, probe all likely locations.&n; * If dev-&gt;base_addr == 1, always return failure.&n; * If dev-&gt;base_addr == 2, allocate space for the device and return success&n; * (detachable devices only).&n; */
r_static
r_int
id|__init
DECL|function|etrax_ethernet_init
id|etrax_ethernet_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|anOffset
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ETRAX 100LX 10/100MBit ethernet v2.0 (c) 2000-2001 Axis Communications AB&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
id|R_NETWORK_SA_0
suffix:semicolon
multiline_comment|/* just to have something to show */
id|printk
c_func
(paren
l_string|&quot;%s initialized&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* make Linux aware of the new hardware  */
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: dev == NULL. Should this happen?&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
id|dev
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|panic
c_func
(paren
l_string|&quot;init_etherdev failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* setup generic handlers and stuff in the dev struct */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* make room for the local structure containing stats etc */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
multiline_comment|/* now setup our etrax specific stuff */
id|dev-&gt;irq
op_assign
id|NETWORK_DMA_RX_IRQ_NBR
suffix:semicolon
multiline_comment|/* we really use DMATX as well... */
id|dev-&gt;dma
op_assign
id|NETWORK_RX_DMA_NBR
suffix:semicolon
multiline_comment|/* fill in our handlers so the network layer can talk to us in the future */
id|dev-&gt;open
op_assign
id|e100_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|e100_send_packet
suffix:semicolon
id|dev-&gt;stop
op_assign
id|e100_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|e100_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|e100_set_mac_address
suffix:semicolon
multiline_comment|/* set the default MAC address */
id|e100_set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|default_mac
)paren
suffix:semicolon
multiline_comment|/* Initialise the list of Etrax DMA-descriptors */
multiline_comment|/* Initialise receive descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_RX_DESC
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RxDescList
(braket
id|i
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
id|anOffset
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|anOffset
op_add_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
)brace
id|RxDescList
(braket
id|i
)braket
dot
id|ctrl
op_assign
id|d_eol
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
id|anOffset
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialise initial pointers */
id|myNextRxDesc
op_assign
op_amp
id|RxDescList
(braket
l_int|0
)braket
suffix:semicolon
id|myLastRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
id|myPrevRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Initialize speed indicator stuff. */
id|current_speed
op_assign
l_int|10
suffix:semicolon
id|speed_timer.expires
op_assign
id|jiffies
op_plus
id|NET_LINK_UP_CHECK_INTERVAL
suffix:semicolon
id|speed_timer.function
op_assign
id|e100_check_speed
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|speed_timer
)paren
suffix:semicolon
id|clear_led_timer.function
op_assign
id|e100_clear_network_leds
suffix:semicolon
id|clear_led_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|clear_led_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set MAC address of the interface. called from the core after a&n; * SIOCSIFADDR ioctl, and from the bootup above.&n; */
r_static
r_int
DECL|function|e100_set_mac_address
id|e100_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|sockaddr
op_star
id|addr
op_assign
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* remember it */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
multiline_comment|/* Write it to the hardware.&n;&t; * Note the way the address is wrapped:&n;&t; * *R_NETWORK_SA_0 = a0_0 | (a0_1 &lt;&lt; 8) | (a0_2 &lt;&lt; 16) | (a0_3 &lt;&lt; 24);&n;&t; * *R_NETWORK_SA_1 = a0_4 | (a0_5 &lt;&lt; 8);&n;&t; */
op_star
id|R_NETWORK_SA_0
op_assign
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
op_star
id|R_NETWORK_SA_1
op_assign
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
op_star
id|R_NETWORK_SA_2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* show it in the log as well */
id|printk
c_func
(paren
l_string|&quot;%s: changed MAC to &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02X&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open/initialize the board. This is called (in the current kernel)&n; * sometime after booting when the &squot;ifconfig&squot; program is run.&n; *&n; * This routine should set everything up anew at each open, even&n; * registers that &quot;should&quot; only need to be set once at boot, so that&n; * there is non-reboot way to recover if something goes wrong.&n; */
r_static
r_int
DECL|function|e100_open
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* disable the ethernet interface while we configure it */
op_star
id|R_NETWORK_GEN_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|phy
comma
id|mii_clk
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|enable
comma
id|off
)paren
suffix:semicolon
multiline_comment|/* enable the MDIO output pin */
op_star
id|R_NETWORK_MGM_CTRL
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdoe
comma
id|enable
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|overrun
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|underrun
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|excessive_col
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* clear dma0 and 1 eop and descr irq masks */
op_star
id|R_IRQ_MASK2_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma0_descr
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma0_eop
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma1_descr
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma1_eop
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* Reset and wait for the DMA channels */
id|RESET_DMA
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|NETWORK_RX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|NETWORK_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* Initialise the etrax network controller */
multiline_comment|/* allocate the irq corresponding to the receiving DMA */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|NETWORK_DMA_RX_IRQ_NBR
comma
id|e100rx_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
r_goto
id|grace_exit
suffix:semicolon
)brace
multiline_comment|/* allocate the irq corresponding to the transmitting DMA */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|NETWORK_DMA_TX_IRQ_NBR
comma
id|e100tx_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
r_goto
id|grace_exit
suffix:semicolon
)brace
multiline_comment|/* allocate the irq corresponding to the network errors etc */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|NETWORK_STATUS_IRQ_NBR
comma
id|e100nw_interrupt
comma
l_int|0
comma
id|cardname
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
r_goto
id|grace_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Always allocate the DMA channels after the IRQ,&n;&t; * and clean up on failure.&n;&t; */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|NETWORK_TX_DMA_NBR
comma
id|cardname
)paren
)paren
(brace
r_goto
id|grace_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|NETWORK_RX_DMA_NBR
comma
id|cardname
)paren
)paren
(brace
id|grace_exit
suffix:colon
multiline_comment|/* this will cause some &squot;trying to free free irq&squot; but what the heck... */
id|free_dma
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|NETWORK_DMA_RX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|NETWORK_DMA_TX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|NETWORK_STATUS_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* give the HW an idea of what MAC address we want */
op_star
id|R_NETWORK_SA_0
op_assign
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
op_star
id|R_NETWORK_SA_1
op_assign
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
op_star
id|R_NETWORK_SA_2
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
multiline_comment|/* use promiscuous mode for testing */
op_star
id|R_NETWORK_GA_0
op_assign
l_int|0xffffffff
suffix:semicolon
op_star
id|R_NETWORK_GA_1
op_assign
l_int|0xffffffff
suffix:semicolon
op_star
id|R_NETWORK_REC_CONFIG
op_assign
l_int|0xd
suffix:semicolon
multiline_comment|/* broadcast rec, individ. rec, ma0 enabled */
macro_line|#else
op_star
id|R_NETWORK_REC_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|broadcast
comma
id|receive
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|ma0
comma
id|enable
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_NETWORK_GEN_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|phy
comma
id|mii_clk
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|enable
comma
id|on
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable the irq&squot;s for ethernet DMA */
op_star
id|R_IRQ_MASK2_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma0_eop
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma1_eop
comma
id|set
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|overrun
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|underrun
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|excessive_col
comma
id|set
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure the irqs are cleared */
op_star
id|R_DMA_CH0_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH0_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
op_star
id|R_DMA_CH1_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* make sure the rec and transmit error counters are cleared */
(paren
r_void
)paren
op_star
id|R_REC_COUNTERS
suffix:semicolon
multiline_comment|/* dummy read */
(paren
r_void
)paren
op_star
id|R_TR_COUNTERS
suffix:semicolon
multiline_comment|/* dummy read */
multiline_comment|/* start the receiving DMA channel so we can receive packets from now on */
op_star
id|R_DMA_CH1_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|myNextRxDesc
)paren
suffix:semicolon
op_star
id|R_DMA_CH1_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We are now ready to accept transmit requeusts from&n;&t; * the queueing layer of the networking.&n;&t; */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_check_speed
id|e100_check_speed
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|data
suffix:semicolon
r_int
id|old_speed
op_assign
id|current_speed
suffix:semicolon
id|data
op_assign
id|e100_get_mdio_reg
c_func
(paren
id|MDIO_BASE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
id|MDIO_LINK_UP_MASK
)paren
)paren
(brace
id|current_speed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|data
op_assign
id|e100_get_mdio_reg
c_func
(paren
id|MDIO_AUX_CTRL_STATUS_REG
)paren
suffix:semicolon
id|current_speed
op_assign
(paren
id|data
op_amp
id|MDIO_SPEED
ques
c_cond
l_int|100
suffix:colon
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_speed
op_ne
id|current_speed
)paren
id|e100_set_network_leds
c_func
(paren
id|NO_NETWORK_ACTIVITY
)paren
suffix:semicolon
multiline_comment|/* Reinitialize the timer. */
id|speed_timer.expires
op_assign
id|jiffies
op_plus
id|NET_LINK_UP_CHECK_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|speed_timer
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|e100_get_mdio_reg
id|e100_get_mdio_reg
c_func
(paren
r_int
r_char
id|reg_num
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
multiline_comment|/* Data to be sent on MDIO port */
r_int
r_int
id|data
suffix:semicolon
multiline_comment|/* Data read from MDIO */
r_int
id|bitCounter
suffix:semicolon
multiline_comment|/* Start of frame, OP Code, Physical Address, Register Address */
id|cmd
op_assign
(paren
id|MDIO_START
op_lshift
l_int|14
)paren
op_or
(paren
id|MDIO_READ
op_lshift
l_int|12
)paren
op_or
(paren
id|MDIO_PHYS_ADDR
op_lshift
l_int|7
)paren
op_or
(paren
id|reg_num
op_lshift
l_int|2
)paren
suffix:semicolon
id|e100_send_mdio_cmd
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Data... */
r_for
c_loop
(paren
id|bitCounter
op_assign
l_int|15
suffix:semicolon
id|bitCounter
op_ge
l_int|0
suffix:semicolon
id|bitCounter
op_decrement
)paren
(brace
id|data
op_or_assign
(paren
id|e100_receive_mdio_bit
c_func
(paren
)paren
op_lshift
id|bitCounter
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_send_mdio_cmd
id|e100_send_mdio_cmd
c_func
(paren
r_int
r_int
id|cmd
comma
r_int
id|write_cmd
)paren
(brace
r_int
id|bitCounter
suffix:semicolon
r_int
r_char
id|data
op_assign
l_int|0x2
suffix:semicolon
multiline_comment|/* Preamble */
r_for
c_loop
(paren
id|bitCounter
op_assign
l_int|31
suffix:semicolon
id|bitCounter
op_ge
l_int|0
suffix:semicolon
id|bitCounter
op_decrement
)paren
(brace
id|e100_send_mdio_bit
c_func
(paren
id|GET_BIT
c_func
(paren
id|bitCounter
comma
id|MDIO_PREAMBLE
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|bitCounter
op_assign
l_int|15
suffix:semicolon
id|bitCounter
op_ge
l_int|2
suffix:semicolon
id|bitCounter
op_decrement
)paren
(brace
id|e100_send_mdio_bit
c_func
(paren
id|GET_BIT
c_func
(paren
id|bitCounter
comma
id|cmd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Turnaround */
r_for
c_loop
(paren
id|bitCounter
op_assign
l_int|1
suffix:semicolon
id|bitCounter
op_ge
l_int|0
suffix:semicolon
id|bitCounter
op_decrement
)paren
r_if
c_cond
(paren
id|write_cmd
)paren
id|e100_send_mdio_bit
c_func
(paren
id|GET_BIT
c_func
(paren
id|bitCounter
comma
id|data
)paren
)paren
suffix:semicolon
r_else
id|e100_receive_mdio_bit
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_send_mdio_bit
id|e100_send_mdio_bit
c_func
(paren
r_int
r_char
id|bit
)paren
(brace
op_star
id|R_NETWORK_MGM_CTRL
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdoe
comma
id|enable
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdio
comma
id|bit
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
op_star
id|R_NETWORK_MGM_CTRL
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdoe
comma
id|enable
)paren
op_or
id|IO_MASK
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdck
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdio
comma
id|bit
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|e100_receive_mdio_bit
id|e100_receive_mdio_bit
c_func
(paren
)paren
(brace
r_int
r_char
id|bit
suffix:semicolon
op_star
id|R_NETWORK_MGM_CTRL
op_assign
l_int|0
suffix:semicolon
id|bit
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_NETWORK_STAT
comma
id|mdio
comma
op_star
id|R_NETWORK_STAT
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
op_star
id|R_NETWORK_MGM_CTRL
op_assign
id|IO_MASK
c_func
(paren
id|R_NETWORK_MGM_CTRL
comma
id|mdck
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|bit
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_reset_tranceiver
id|e100_reset_tranceiver
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
r_int
id|bitCounter
suffix:semicolon
id|data
op_assign
id|e100_get_mdio_reg
c_func
(paren
id|MDIO_BASE_CONTROL_REG
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|MDIO_START
op_lshift
l_int|14
)paren
op_or
(paren
id|MDIO_WRITE
op_lshift
l_int|12
)paren
op_or
(paren
id|MDIO_PHYS_ADDR
op_lshift
l_int|7
)paren
op_or
(paren
id|MDIO_BASE_CONTROL_REG
op_lshift
l_int|2
)paren
suffix:semicolon
id|e100_send_mdio_cmd
c_func
(paren
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|data
op_or_assign
l_int|0x8000
suffix:semicolon
r_for
c_loop
(paren
id|bitCounter
op_assign
l_int|15
suffix:semicolon
id|bitCounter
op_ge
l_int|0
suffix:semicolon
id|bitCounter
op_decrement
)paren
(brace
id|e100_send_mdio_bit
c_func
(paren
id|GET_BIT
c_func
(paren
id|bitCounter
comma
id|data
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Called by upper layers if they decide it took too long to complete&n; * sending a packet - we need to reset and stuff.&n; */
r_static
r_void
DECL|function|e100_tx_timeout
id|e100_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ problem&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* remember we got an error */
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* reset the TX DMA in case it has hung on something */
id|RESET_DMA
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* Reset the tranceiver. */
id|e100_reset_tranceiver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and get rid of the packet that never got an interrupt */
id|dev_kfree_skb
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tell the upper layers we&squot;re ok again */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* This will only be invoked if the driver is _not_ in XOFF state.&n; * What this means is that we need not check it, and that this&n; * invariant will hold if we make sure that the netif_*_queue()&n; * calls are done at the proper times.&n; */
r_static
r_int
DECL|function|e100_send_packet
id|e100_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;send packet len %d&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* protect from tx_interrupt */
id|tx_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/* remember it so we can free it in the tx irq handler later */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|e100_hardware_send_packet
c_func
(paren
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* this simple TX driver has only one send-descriptor so we&squot;re full&n;&t; * directly. If this had a send-ring instead, we would only do this if&n;&t; * the ring got full.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The typical workload of the driver:&n; *   Handle the network interface interrupts.&n; */
r_static
r_void
DECL|function|e100rx_interrupt
id|e100rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|irqbits
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_RD
comma
id|dma1_eop
comma
id|active
)paren
)paren
(brace
multiline_comment|/* acknowledge the eop interrupt */
op_star
id|R_DMA_CH1_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* check if one or more complete packets were indeed received */
r_while
c_loop
(paren
op_star
id|R_DMA_CH1_FIRST
op_ne
id|virt_to_phys
c_func
(paren
id|myNextRxDesc
)paren
)paren
(brace
multiline_comment|/* Take out the buffer and give it to the OS, then&n;&t;&t;&t; * allocate a new buffer to put a packet in.&n;&t;&t;&t; */
id|e100_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* restart/continue on the channel, for safety */
op_star
id|R_DMA_CH1_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CMD
comma
id|cmd
comma
id|restart
)paren
suffix:semicolon
multiline_comment|/* clear dma channel 1 eop/descr irq bits */
op_star
id|R_DMA_CH1_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_DMA_CH1_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* now, we might have gotten another packet&n;&t;&t;&t;   so we have to loop back and check if so */
)brace
)brace
)brace
multiline_comment|/* the transmit dma channel interrupt&n; *&n; * this is supposed to free the skbuff which was pending during transmission,&n; * and inform the kernel that we can send one more buffer&n; */
r_static
r_void
DECL|function|e100tx_interrupt
id|e100tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|irqbits
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* check for a dma0_eop interrupt */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_RD
comma
id|dma0_eop
comma
id|active
)paren
)paren
(brace
multiline_comment|/* This protects us from concurrent execution of&n;&t;&t; * our dev-&gt;hard_start_xmit function above.&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* acknowledge the eop interrupt */
op_star
id|R_DMA_CH0_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH0_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|R_DMA_CH0_FIRST
op_eq
l_int|0
op_logical_and
id|tx_skb
)paren
(brace
id|np-&gt;stats.tx_bytes
op_add_assign
id|tx_skb-&gt;len
suffix:semicolon
id|np-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* dma is ready with the transmission of the data in tx_skb, so now&n;&t;&t;&t;   we can release the skb memory */
id|dev_kfree_skb_irq
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
id|tx_skb
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: tx weird interrupt&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|e100nw_interrupt
id|e100nw_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|irqbits
op_assign
op_star
id|R_IRQ_MASK0_RD
suffix:semicolon
multiline_comment|/* check for underrun irq */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_RD
comma
id|underrun
comma
id|active
)paren
)paren
(brace
op_star
id|R_NETWORK_TR_CTRL
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_TR_CTRL
comma
id|clr_error
comma
id|clr
)paren
suffix:semicolon
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ethernet receiver underrun!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* check for overrun irq */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_RD
comma
id|overrun
comma
id|active
)paren
)paren
(brace
id|update_rx_stats
c_func
(paren
op_amp
id|np-&gt;stats
)paren
suffix:semicolon
multiline_comment|/* this will ack the irq */
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ethernet receiver overrun!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* check for excessive collision irq */
r_if
c_cond
(paren
id|irqbits
op_amp
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_RD
comma
id|excessive_col
comma
id|active
)paren
)paren
(brace
op_star
id|R_NETWORK_TR_CTRL
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_TR_CTRL
comma
id|clr_error
comma
id|clr
)paren
suffix:semicolon
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ethernet excessive collisions!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|e100_rx
id|e100_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|etrax_dma_descr
op_star
id|mySaveRxDesc
op_assign
id|myNextRxDesc
suffix:semicolon
r_int
r_char
op_star
id|skb_data_ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|led_active
op_logical_and
id|jiffies
OG
id|led_next_time
)paren
(brace
multiline_comment|/* light the network leds depending on the current speed. */
id|e100_set_network_leds
c_func
(paren
id|NETWORK_ACTIVITY
)paren
suffix:semicolon
multiline_comment|/* Set the earliest time we may clear the LED */
id|led_next_time
op_assign
id|jiffies
op_plus
id|NET_FLASH_TIME
suffix:semicolon
id|led_active
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If the packet is broken down in many small packages then merge&n;&t; * count how much space we will need to alloc with skb_alloc() for&n;&t; * it to fit.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|myNextRxDesc-&gt;status
op_amp
id|d_eop
)paren
)paren
(brace
id|length
op_add_assign
id|myNextRxDesc-&gt;sw_len
suffix:semicolon
multiline_comment|/* use sw_len for the first descs */
id|myNextRxDesc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|myNextRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;next
)paren
suffix:semicolon
)brace
id|length
op_add_assign
id|myNextRxDesc-&gt;hw_len
suffix:semicolon
multiline_comment|/* use hw_len for the last descr */
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;Got a packet of length %d:&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* dump the first bytes in the packet */
id|skb_data_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x&bslash;n&quot;
comma
id|i
op_star
l_int|8
comma
id|skb_data_ptr
(braket
l_int|0
)braket
comma
id|skb_data_ptr
(braket
l_int|1
)braket
comma
id|skb_data_ptr
(braket
l_int|2
)braket
comma
id|skb_data_ptr
(braket
l_int|3
)braket
comma
id|skb_data_ptr
(braket
l_int|4
)braket
comma
id|skb_data_ptr
(braket
l_int|5
)braket
comma
id|skb_data_ptr
(braket
l_int|6
)braket
comma
id|skb_data_ptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|skb_data_ptr
op_add_assign
l_int|8
suffix:semicolon
)brace
macro_line|#endif
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_minus
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|np-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_put
c_func
(paren
id|skb
comma
id|length
op_minus
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
multiline_comment|/* allocate room for the packet body */
id|skb_data_ptr
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|ETHER_HEAD_LEN
)paren
suffix:semicolon
multiline_comment|/* allocate room for the header */
macro_line|#ifdef ETHDEBUG
id|printk
c_func
(paren
l_string|&quot;head = 0x%x, data = 0x%x, tail = 0x%x, end = 0x%x&bslash;n&quot;
comma
id|skb-&gt;head
comma
id|skb-&gt;data
comma
id|skb-&gt;tail
comma
id|skb-&gt;end
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;copying packet to 0x%x.&bslash;n&quot;
comma
id|skb_data_ptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* this loop can be made using max two memcpy&squot;s if optimized */
r_while
c_loop
(paren
id|mySaveRxDesc
op_ne
id|myNextRxDesc
)paren
(brace
id|memcpy
c_func
(paren
id|skb_data_ptr
comma
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
comma
id|mySaveRxDesc-&gt;sw_len
)paren
suffix:semicolon
id|skb_data_ptr
op_add_assign
id|mySaveRxDesc-&gt;sw_len
suffix:semicolon
id|mySaveRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;next
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_data_ptr
comma
id|phys_to_virt
c_func
(paren
id|mySaveRxDesc-&gt;buf
)paren
comma
id|mySaveRxDesc-&gt;hw_len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Send the packet to the upper layers */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Prepare for next packet */
id|myNextRxDesc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|myPrevRxDesc
op_assign
id|myNextRxDesc
suffix:semicolon
id|myNextRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;next
)paren
suffix:semicolon
id|myPrevRxDesc-&gt;ctrl
op_or_assign
id|d_eol
suffix:semicolon
id|myLastRxDesc-&gt;ctrl
op_and_assign
op_complement
id|d_eol
suffix:semicolon
id|myLastRxDesc
op_assign
id|myPrevRxDesc
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|e100_close
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Closing %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
op_star
id|R_NETWORK_GEN_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|phy
comma
id|mii_clk
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_GEN_CONFIG
comma
id|enable
comma
id|off
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|overrun
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|underrun
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|excessive_col
comma
id|clr
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK2_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma0_descr
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma0_eop
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma1_descr
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_CLR
comma
id|dma1_eop
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* Stop the receiver and the transmitter */
id|RESET_DMA
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|NETWORK_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|free_irq
c_func
(paren
id|NETWORK_DMA_RX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|NETWORK_DMA_TX_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|NETWORK_STATUS_IRQ_NBR
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|NETWORK_TX_DMA_NBR
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|NETWORK_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
id|update_rx_stats
c_func
(paren
op_amp
id|np-&gt;stats
)paren
suffix:semicolon
id|update_tx_stats
c_func
(paren
op_amp
id|np-&gt;stats
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|update_rx_stats
id|update_rx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
id|es
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|R_REC_COUNTERS
suffix:semicolon
multiline_comment|/* update stats relevant to reception errors */
id|es-&gt;rx_fifo_errors
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_REC_COUNTERS
comma
id|congestion
comma
id|r
)paren
suffix:semicolon
id|es-&gt;rx_crc_errors
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_REC_COUNTERS
comma
id|crc_error
comma
id|r
)paren
suffix:semicolon
id|es-&gt;rx_frame_errors
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_REC_COUNTERS
comma
id|alignment_error
comma
id|r
)paren
suffix:semicolon
id|es-&gt;rx_length_errors
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_REC_COUNTERS
comma
id|oversize
comma
id|r
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|update_tx_stats
id|update_tx_stats
c_func
(paren
r_struct
id|net_device_stats
op_star
id|es
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|R_TR_COUNTERS
suffix:semicolon
multiline_comment|/* update stats relevant to transmission errors */
id|es-&gt;collisions
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_TR_COUNTERS
comma
id|single_col
comma
id|r
)paren
op_plus
id|IO_EXTRACT
c_func
(paren
id|R_TR_COUNTERS
comma
id|multiple_col
comma
id|r
)paren
suffix:semicolon
id|es-&gt;tx_errors
op_add_assign
id|IO_EXTRACT
c_func
(paren
id|R_TR_COUNTERS
comma
id|deferred
comma
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the current statistics.&n; * This may be called with the card open or closed.&n; */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|e100_get_stats
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|update_rx_stats
c_func
(paren
op_amp
id|lp-&gt;stats
)paren
suffix:semicolon
id|update_tx_stats
c_func
(paren
op_amp
id|lp-&gt;stats
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|num_addr
op_assign
id|dev-&gt;mc_count
suffix:semicolon
r_int
r_int
r_int
id|lo_bits
suffix:semicolon
r_int
r_int
r_int
id|hi_bits
suffix:semicolon
r_if
c_cond
(paren
id|num_addr
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* promiscuous mode */
id|lo_bits
op_assign
l_int|0xfffffffful
suffix:semicolon
id|hi_bits
op_assign
l_int|0xfffffffful
suffix:semicolon
multiline_comment|/* Enable individual receive */
op_star
id|R_NETWORK_REC_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|broadcast
comma
id|receive
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|ma0
comma
id|enable
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|individual
comma
id|receive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_addr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Normal, clear the mc list */
id|lo_bits
op_assign
l_int|0x00000000ul
suffix:semicolon
id|hi_bits
op_assign
l_int|0x00000000ul
suffix:semicolon
multiline_comment|/* Disable individual receive */
op_star
id|R_NETWORK_REC_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|broadcast
comma
id|receive
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|ma0
comma
id|enable
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* MC mode, receive normal and MC packets */
r_char
id|hash_ix
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|baddr
suffix:semicolon
id|lo_bits
op_assign
l_int|0x00000000ul
suffix:semicolon
id|hi_bits
op_assign
l_int|0x00000000ul
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_addr
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Calculate the hash index for the GA registers */
id|hash_ix
op_assign
l_int|0
suffix:semicolon
id|baddr
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
op_star
id|baddr
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
op_increment
id|baddr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_lshift
l_int|2
)paren
op_amp
l_int|0x03c
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
op_increment
id|baddr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x30
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|2
)paren
op_amp
l_int|0x3f
suffix:semicolon
op_increment
id|baddr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
op_star
id|baddr
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
op_increment
id|baddr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_lshift
l_int|2
)paren
op_amp
l_int|0x03c
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
op_increment
id|baddr
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x30
suffix:semicolon
id|hash_ix
op_xor_assign
(paren
(paren
op_star
id|baddr
)paren
op_rshift
l_int|2
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|hash_ix
op_and_assign
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|hash_ix
OG
l_int|32
)paren
(brace
id|hi_bits
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|hash_ix
op_minus
l_int|32
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|lo_bits
op_or_assign
(paren
l_int|1
op_lshift
id|hash_ix
)paren
suffix:semicolon
)brace
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Disable individual receive */
op_star
id|R_NETWORK_REC_CONFIG
op_assign
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|broadcast
comma
id|receive
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_NETWORK_REC_CONFIG
comma
id|ma0
comma
id|enable
)paren
suffix:semicolon
)brace
op_star
id|R_NETWORK_GA_0
op_assign
id|lo_bits
suffix:semicolon
op_star
id|R_NETWORK_GA_1
op_assign
id|hi_bits
suffix:semicolon
)brace
r_void
DECL|function|e100_hardware_send_packet
id|e100_hardware_send_packet
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;e100 send pack, buf 0x%x len %d&bslash;n&quot;
comma
id|buf
comma
id|length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|led_active
op_logical_and
id|jiffies
OG
id|led_next_time
)paren
(brace
multiline_comment|/* light the network leds depending on the current speed. */
id|e100_set_network_leds
c_func
(paren
id|NETWORK_ACTIVITY
)paren
suffix:semicolon
multiline_comment|/* Set the earliest time we may clear the LED */
id|led_next_time
op_assign
id|jiffies
op_plus
id|NET_FLASH_TIME
suffix:semicolon
id|led_active
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* configure the tx dma descriptor */
id|TxDesc.sw_len
op_assign
id|length
suffix:semicolon
id|TxDesc.ctrl
op_assign
id|d_eop
op_or
id|d_eol
op_or
id|d_wait
suffix:semicolon
id|TxDesc.buf
op_assign
id|virt_to_phys
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* setup the dma channel and start it */
op_star
id|R_DMA_CH0_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxDesc
)paren
suffix:semicolon
op_star
id|R_DMA_CH0_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH0_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_clear_network_leds
id|e100_clear_network_leds
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_if
c_cond
(paren
id|led_active
op_logical_and
id|jiffies
OG
id|led_next_time
)paren
(brace
id|e100_set_network_leds
c_func
(paren
id|NO_NETWORK_ACTIVITY
)paren
suffix:semicolon
multiline_comment|/* Set the earliest time we may set the LED */
id|led_next_time
op_assign
id|jiffies
op_plus
id|NET_FLASH_PAUSE
suffix:semicolon
id|led_active
op_assign
l_int|0
suffix:semicolon
)brace
id|clear_led_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|clear_led_timer
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_set_network_leds
id|e100_set_network_leds
c_func
(paren
r_int
id|active
)paren
(brace
macro_line|#if defined(CONFIG_ETRAX_NETWORK_LED_ON_WHEN_LINK)
r_int
id|light_leds
op_assign
(paren
id|active
op_eq
id|NO_NETWORK_ACTIVITY
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ETRAX_NETWORK_LED_ON_WHEN_ACTIVITY)
r_int
id|light_leds
op_assign
(paren
id|active
op_eq
id|NETWORK_ACTIVITY
)paren
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Define either CONFIG_ETRAX_NETWORK_LED_ON_WHEN_LINK or CONFIG_ETRAX_NETWORK_LED_ON_WHEN_ACTIVITY&quot;
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|current_speed
)paren
(brace
multiline_comment|/* Make LED red, link is down */
id|LED_NETWORK_SET
c_func
(paren
id|LED_RED
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|light_leds
)paren
(brace
r_if
c_cond
(paren
id|current_speed
op_eq
l_int|10
)paren
(brace
id|LED_NETWORK_SET
c_func
(paren
id|LED_ORANGE
)paren
suffix:semicolon
)brace
r_else
(brace
id|LED_NETWORK_SET
c_func
(paren
id|LED_GREEN
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|LED_NETWORK_SET
c_func
(paren
id|LED_OFF
)paren
suffix:semicolon
)brace
)brace
DECL|variable|dev_etrax_ethernet
r_static
r_struct
id|net_device
id|dev_etrax_ethernet
suffix:semicolon
multiline_comment|/* only got one */
r_static
r_int
DECL|function|etrax_init_module
id|etrax_init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|d
op_assign
op_amp
id|dev_etrax_ethernet
suffix:semicolon
id|d-&gt;init
op_assign
id|etrax_ethernet_init
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|d
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|etrax_init_module
id|module_init
c_func
(paren
id|etrax_init_module
)paren
suffix:semicolon
eof
