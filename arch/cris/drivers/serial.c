multiline_comment|/* $Id: serial.c,v 1.10 2001/03/05 13:14:07 bjornw Exp $&n; *&n; * Serial port driver for the ETRAX 100LX chip&n; *&n; *      Copyright (C) 1998, 1999, 2000, 2001  Axis Communications AB&n; *&n; *      Many, many authors. Based once upon a time on serial.c for 16x50.&n; *&n; * $Log: serial.c,v $&n; * Revision 1.10  2001/03/05 13:14:07  bjornw&n; * Another spelling fix&n; *&n; * Revision 1.9  2001/02/23 13:46:38  bjornw&n; * Spellling check&n; *&n; * Revision 1.8  2001/01/23 14:56:35  markusl&n; * Made use of ser1 optional&n; * Needed by USB&n; *&n; * Revision 1.7  2001/01/19 16:14:48  perf&n; * Added kernel options for serial ports 234.&n; * Changed option names from CONFIG_ETRAX100_XYZ to CONFIG_ETRAX_XYZ.&n; *&n; * Revision 1.6  2000/11/22 16:36:09  bjornw&n; * Please marketing by using the correct case when spelling Etrax.&n; *&n; * Revision 1.5  2000/11/21 16:43:37  bjornw&n; * Fixed so it compiles under CONFIG_SVINTO_SIM&n; *&n; * Revision 1.4  2000/11/15 17:34:12  bjornw&n; * Added a timeout timer for flushing input channels. The interrupt-based&n; * fast flush system should be easy to merge with this later (works the same&n; * way, only with an irq instead of a system timer_list)&n; *&n; * Revision 1.3  2000/11/13 17:19:57  bjornw&n; * * Incredibly, this almost complete rewrite of serial.c worked (at least&n; *   for output) the first time.&n; *&n; *   Items worth noticing:&n; *&n; *      No Etrax100 port 1 workarounds (does only compile on 2.4 anyway now)&n; *      RS485 is not ported (why cant it be done in userspace as on x86 ?)&n; *      Statistics done through async_icount - if any more stats are needed,&n; *      that&squot;s the place to put them or in an arch-dep version of it.&n; *      timeout_interrupt and the other fast timeout stuff not ported yet&n; *      There be dragons in this 3k+ line driver&n; *&n; * Revision 1.2  2000/11/10 16:50:28  bjornw&n; * First shot at a 2.4 port, does not compile totally yet&n; *&n; * Revision 1.1  2000/11/10 16:47:32  bjornw&n; * Added verbatim copy of rev 1.49 etrax100ser.c from elinux&n; *&n; * Revision 1.49  2000/10/30 15:47:14  tobiasa&n; * Changed version number.&n; *&n; * Revision 1.48  2000/10/25 11:02:43  johana&n; * Changed %ul to %lu in printf&squot;s&n; *&n; * Revision 1.47  2000/10/18 15:06:53  pkj&n; * Compile correctly with CONFIG_ETRAX100_SERIAL_FLUSH_DMA_FAST and&n; * CONFIG_SERIAL_PROC_ENTRY together.&n; * Some clean-up of the /proc/serial file.&n; *&n; * Revision 1.46  2000/10/16 12:59:40  johana&n; * Added CONFIG_SERIAL_PROC_ENTRY for statistics and debug info.&n; *&n; * Revision 1.45  2000/10/13 17:10:59  pkj&n; * Do not flush DMAs while flipping TTY buffers.&n; *&n; * Revision 1.44  2000/10/13 16:34:29  pkj&n; * Added a delay in ser_interrupt() for 2.3ms when an error is detected.&n; * We do not know why this delay is required yet, but without it the&n; * irmaflash program does not work (this was the program that needed&n; * the ser_interrupt() to be needed in the first place). This should not&n; * affect normal use of the serial ports.&n; *&n; * Revision 1.43  2000/10/13 16:30:44  pkj&n; * New version of the fast flush of serial buffers code. This time&n; * it is localized to the serial driver and uses a fast timer to&n; * do the work.&n; *&n; * Revision 1.42  2000/10/13 14:54:26  bennyo&n; * Fix for switching RTS when using rs485&n; *&n; * Revision 1.41  2000/10/12 11:43:44  pkj&n; * Cleaned up a number of comments.&n; *&n; * Revision 1.40  2000/10/10 11:58:39  johana&n; * Made RS485 support generic for all ports.&n; * Toggle rts in interrupt if no delay wanted.&n; * WARNING: No true transmitter empty check??&n; * Set d_wait bit when sending data so interrupt is delayed until&n; * fifo flushed. (Fix tcdrain() problem)&n; *&n; * Revision 1.39  2000/10/04 16:08:02  bjornw&n; * * Use virt_to_phys etc. for DMA addresses&n; * * Removed CONFIG_FLUSH_DMA_FAST hacks&n; * * Indentation fix&n; *&n; * Revision 1.38  2000/10/02 12:27:10  mattias&n; * * added variable used when using fast flush on serial dma.&n; *   (CONFIG_FLUSH_DMA_FAST)&n; *&n; * Revision 1.37  2000/09/27 09:44:24  pkj&n; * Uncomment definition of SERIAL_HANDLE_EARLY_ERRORS.&n; *&n; * Revision 1.36  2000/09/20 13:12:52  johana&n; * Support for CONFIG_ETRAX100_SERIAL_RX_TIMEOUT_TICKS:&n; *   Number of timer ticks between flush of receive fifo (1 tick = 10ms).&n; *   Try 0-3 for low latency applications. Approx 5 for high load&n; *   applications (e.g. PPP). Maybe this should be more adaptive some day...&n; *&n; * Revision 1.35  2000/09/20 10:36:08  johana&n; * Typo in get_lsr_info()&n; *&n; * Revision 1.34  2000/09/20 10:29:59  johana&n; * Let rs_chars_in_buffer() check fifo content as well.&n; * get_lsr_info() might work now (not tested).&n; * Easier to change the port to debug.&n; *&n; * Revision 1.33  2000/09/13 07:52:11  torbjore&n; * Support RS485&n; *&n; * Revision 1.32  2000/08/31 14:45:37  bjornw&n; * After sending a break we need to reset the transmit DMA channel&n; *&n; * Revision 1.31  2000/06/21 12:13:29  johana&n; * Fixed wait for all chars sent when closing port.&n; * (Used to always take 1 second!)&n; * Added shadows for directions of status/ctrl signals.&n; *&n; * Revision 1.30  2000/05/29 16:27:55  bjornw&n; * Simulator ifdef moved a bit&n; *&n; * Revision 1.29  2000/05/09 09:40:30  mattias&n; * * Added description of dma registers used in timeout_interrupt&n; * * Removed old code&n; *&n; * Revision 1.28  2000/05/08 16:38:58  mattias&n; * * Bugfix for flushing fifo in timeout_interrupt&n; *   Problem occurs when bluetooth stack waits for a small number of bytes&n; *   containing an event acknowledging free buffers in bluetooth HW&n; *   As before, data was stuck in fifo until more data came on uart and&n; *   flushed it up to the stack.&n; *&n; * Revision 1.27  2000/05/02 09:52:28  jonasd&n; * Added fix for peculiar etrax behaviour when eop is forced on an empty&n; * fifo. This is used when flashing the IRMA chip. Disabled by default.&n; *&n; * Revision 1.26  2000/03/29 15:32:02  bjornw&n; * 2.0.34 updates&n; *&n; * Revision 1.25  2000/02/16 16:59:36  bjornw&n; * * Receive DMA directly into the flip-buffer, eliminating an intermediary&n; *   receive buffer and a memcpy. Will avoid some overruns.&n; * * Error message on debug port if an overrun or flip buffer overrun occurs.&n; * * Just use the first byte in the flag flip buffer for errors.&n; * * Check for timeout on the serial ports only each 5/100 s, not 1/100.&n; *&n; * Revision 1.24  2000/02/09 18:02:28  bjornw&n; * * Clear serial errors (overrun, framing, parity) correctly. Before, the&n; *   receiver would get stuck if an error occurred and we did not restart&n; *   the input DMA.&n; * * Cosmetics (indentation, some code made into inlines)&n; * * Some more debug options&n; * * Actually shut down the serial port (DMA irq, DMA reset, receiver stop)&n; *   when the last open is closed. Corresponding fixes in startup().&n; * * rs_close() &quot;tx FIFO wait&quot; code moved into right place, bug &amp; -&gt; &amp;&amp; fixed&n; *   and make a special case out of port 1 (R_DMA_CHx_STATUS is broken for that)&n; * * e100_disable_rx/enable_rx just disables/enables the receiver, not RTS&n; *&n; * Revision 1.23  2000/01/24 17:46:19  johana&n; * Wait for flush of DMA/FIFO when closing port.&n; *&n; * Revision 1.22  2000/01/20 18:10:23  johana&n; * Added TIOCMGET ioctl to return modem status.&n; * Implemented modem status/control that works with the extra signals&n; * (DTR, DSR, RI,CD) as well.&n; * 3 different modes supported:&n; * ser0 on PB (Bundy), ser1 on PB (Lisa) and ser2 on PA (Bundy)&n; * Fixed DEF_TX value that caused the serial transmitter pin (txd) to go to 0 when&n; * closing the last filehandle, NASTY!.&n; * Added break generation, not tested though!&n; * Use SA_SHIRQ when request_irq() for ser2 and ser3 (shared with) par0 and par1.&n; * You can&squot;t use them at the same time (yet..), but you can hopefully switch&n; * between ser2/par0, ser3/par1 with the same kernel config.&n; * Replaced some magic constants with defines&n; *&n; *&n; */
DECL|variable|serial_version
r_static
r_char
op_star
id|serial_version
op_assign
l_string|&quot;$Revision: 1.10 $&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#if (LINUX_VERSION_CODE &gt;= 131343)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt;= 131336)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/svinto.h&gt;
multiline_comment|/* non-arch dependant serial structures are in linux/serial.h */
macro_line|#include &lt;linux/serial.h&gt;
multiline_comment|/* while we keep our own stuff (struct e100_serial) in a local .h file */
macro_line|#include &quot;serial.h&quot;
multiline_comment|/*&n; * All of the compatibilty code so we can compile serial.c against&n; * older kernels is hidden in serial_compat.h&n; */
macro_line|#if defined(LOCAL_HEADERS) || (LINUX_VERSION_CODE &lt; 0x020317) /* 2.3.23 */
macro_line|#include &quot;serial_compat.h&quot;
macro_line|#endif
r_static
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_serial
)paren
suffix:semicolon
DECL|variable|serial_driver
DECL|variable|callout_driver
r_struct
id|tty_driver
id|serial_driver
comma
id|callout_driver
suffix:semicolon
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
multiline_comment|/* serial subtype definitions */
macro_line|#ifndef SERIAL_TYPE_NORMAL
DECL|macro|SERIAL_TYPE_NORMAL
mdefine_line|#define SERIAL_TYPE_NORMAL&t;1
DECL|macro|SERIAL_TYPE_CALLOUT
mdefine_line|#define SERIAL_TYPE_CALLOUT&t;2
macro_line|#endif
multiline_comment|/* number of characters left in xmit buffer before we ask for more */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
singleline_comment|//#define SERIAL_DEBUG_INTR
singleline_comment|//#define SERIAL_DEBUG_OPEN 
singleline_comment|//#define SERIAL_DEBUG_FLOW
singleline_comment|//#define SERIAL_DEBUG_DATA
singleline_comment|//#define SERIAL_DEBUG_THROTTLE
singleline_comment|//#define SERIAL_DEBUG_IO  /* Debug for Extra control and status pins */
DECL|macro|SERIAL_DEBUG_LINE
mdefine_line|#define SERIAL_DEBUG_LINE 0 /* What serport we want to debug */
multiline_comment|/* Enable this to use serial interrupts to handle when you&n;   expect the first received event on the serial port to&n;   be an error, break or similar. Used to be able to flash IRMA&n;   from eLinux */
singleline_comment|//#define SERIAL_HANDLE_EARLY_ERRORS
macro_line|#ifndef CONFIG_ETRAX_SERIAL_RX_TIMEOUT_TICKS
multiline_comment|/* Default number of timer ticks before flushing rx fifo &n; * When using &quot;little data, low latency applications: use 0&n; * When using &quot;much data applications (PPP)&quot; use ~5&n; */
DECL|macro|CONFIG_ETRAX_SERIAL_RX_TIMEOUT_TICKS
mdefine_line|#define CONFIG_ETRAX_SERIAL_RX_TIMEOUT_TICKS 5 
macro_line|#endif
DECL|macro|MAX_FLUSH_TIME
mdefine_line|#define MAX_FLUSH_TIME 8
DECL|macro|_INLINE_
mdefine_line|#define _INLINE_ inline
r_static
r_void
id|change_speed
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
suffix:semicolon
r_static
r_void
id|rs_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_int
id|rs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
DECL|macro|DEF_BAUD
mdefine_line|#define DEF_BAUD 0x99   /* 115.2 kbit/s */
DECL|macro|STD_FLAGS
mdefine_line|#define STD_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST )
DECL|macro|DEF_RX
mdefine_line|#define DEF_RX 0x20  /* or SERIAL_CTRL_W &gt;&gt; 8 */
multiline_comment|/* Default value of tx_ctrl register: has txd(bit 7)=1 (idle) as default */
DECL|macro|DEF_TX
mdefine_line|#define DEF_TX 0x80  /* or SERIAL_CTRL_B */
multiline_comment|/* offsets from R_SERIALx_CTRL */
DECL|macro|REG_DATA
mdefine_line|#define REG_DATA 0
DECL|macro|REG_TR_DATA
mdefine_line|#define REG_TR_DATA 0
DECL|macro|REG_STATUS
mdefine_line|#define REG_STATUS 1
DECL|macro|REG_TR_CTRL
mdefine_line|#define REG_TR_CTRL 1
DECL|macro|REG_REC_CTRL
mdefine_line|#define REG_REC_CTRL 2
DECL|macro|REG_BAUD
mdefine_line|#define REG_BAUD 3
DECL|macro|REG_XOFF
mdefine_line|#define REG_XOFF 4  /* this is a 32 bit register */
multiline_comment|/* this is the data for the four serial ports in the etrax100 */
multiline_comment|/*  DMA2(ser2), DMA4(ser3), DMA6(ser0) or DMA8(ser1) */
multiline_comment|/* R_DMA_CHx_CLR_INTR, R_DMA_CHx_FIRST, R_DMA_CHx_CMD */
DECL|variable|rs_table
r_static
r_struct
id|e100_serial
id|rs_table
(braket
)braket
op_assign
(brace
(brace
id|DEF_BAUD
comma
(paren
r_int
r_char
op_star
)paren
id|R_SERIAL0_CTRL
comma
l_int|1U
op_lshift
l_int|12
comma
multiline_comment|/* uses DMA 6 and 7 */
id|R_DMA_CH6_CLR_INTR
comma
id|R_DMA_CH6_FIRST
comma
id|R_DMA_CH6_CMD
comma
id|R_DMA_CH6_STATUS
comma
id|R_DMA_CH6_HWSW
comma
id|R_DMA_CH7_CLR_INTR
comma
id|R_DMA_CH7_FIRST
comma
id|R_DMA_CH7_CMD
comma
id|R_DMA_CH7_STATUS
comma
id|R_DMA_CH7_HWSW
comma
id|STD_FLAGS
comma
id|DEF_RX
comma
id|DEF_TX
comma
l_int|2
)brace
comma
multiline_comment|/* ttyS0 */
macro_line|#ifndef CONFIG_SVINTO_SIM
(brace
id|DEF_BAUD
comma
(paren
r_int
r_char
op_star
)paren
id|R_SERIAL1_CTRL
comma
l_int|1U
op_lshift
l_int|16
comma
multiline_comment|/* uses DMA 8 and 9 */
id|R_DMA_CH8_CLR_INTR
comma
id|R_DMA_CH8_FIRST
comma
id|R_DMA_CH8_CMD
comma
id|R_DMA_CH8_STATUS
comma
id|R_DMA_CH8_HWSW
comma
id|R_DMA_CH9_CLR_INTR
comma
id|R_DMA_CH9_FIRST
comma
id|R_DMA_CH9_CMD
comma
id|R_DMA_CH9_STATUS
comma
id|R_DMA_CH9_HWSW
comma
id|STD_FLAGS
comma
id|DEF_RX
comma
id|DEF_TX
comma
l_int|3
)brace
comma
multiline_comment|/* ttyS1 */
(brace
id|DEF_BAUD
comma
(paren
r_int
r_char
op_star
)paren
id|R_SERIAL2_CTRL
comma
l_int|1U
op_lshift
l_int|4
comma
multiline_comment|/* uses DMA 2 and 3 */
id|R_DMA_CH2_CLR_INTR
comma
id|R_DMA_CH2_FIRST
comma
id|R_DMA_CH2_CMD
comma
id|R_DMA_CH2_STATUS
comma
id|R_DMA_CH2_HWSW
comma
id|R_DMA_CH3_CLR_INTR
comma
id|R_DMA_CH3_FIRST
comma
id|R_DMA_CH3_CMD
comma
id|R_DMA_CH3_STATUS
comma
id|R_DMA_CH3_HWSW
comma
id|STD_FLAGS
comma
id|DEF_RX
comma
id|DEF_TX
comma
l_int|0
)brace
comma
multiline_comment|/* ttyS2 */
(brace
id|DEF_BAUD
comma
(paren
r_int
r_char
op_star
)paren
id|R_SERIAL3_CTRL
comma
l_int|1U
op_lshift
l_int|8
comma
multiline_comment|/* uses DMA 4 and 5 */
id|R_DMA_CH4_CLR_INTR
comma
id|R_DMA_CH4_FIRST
comma
id|R_DMA_CH4_CMD
comma
id|R_DMA_CH4_STATUS
comma
id|R_DMA_CH4_HWSW
comma
id|R_DMA_CH5_CLR_INTR
comma
id|R_DMA_CH5_FIRST
comma
id|R_DMA_CH5_CMD
comma
id|R_DMA_CH5_STATUS
comma
id|R_DMA_CH5_HWSW
comma
id|STD_FLAGS
comma
id|DEF_RX
comma
id|DEF_TX
comma
l_int|1
)brace
multiline_comment|/* ttyS3 */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|NR_PORTS
mdefine_line|#define NR_PORTS (sizeof(rs_table)/sizeof(struct e100_serial))
DECL|variable|serial_table
r_static
r_struct
id|tty_struct
op_star
id|serial_table
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|NR_PORTS
)braket
suffix:semicolon
multiline_comment|/* RS-485 */
macro_line|#if defined(CONFIG_RS485)
macro_line|#if defined(CONFIG_RS485_ON_PA)
DECL|variable|rs485_pa_bit
r_static
r_int
id|rs485_pa_bit
op_assign
id|CONFIG_RS485_ON_PA_BIT
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* For now we assume that all bits are on the same port for each serial port */
multiline_comment|/* Dummy shadow variables */
DECL|variable|dummy_ser0
r_static
r_int
r_char
id|dummy_ser0
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_ser1
r_static
r_int
r_char
id|dummy_ser1
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_ser2
r_static
r_int
r_char
id|dummy_ser2
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_ser3
r_static
r_int
r_char
id|dummy_ser3
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_dir_ser0
r_static
r_int
r_char
id|dummy_dir_ser0
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_dir_ser1
r_static
r_int
r_char
id|dummy_dir_ser1
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_dir_ser2
r_static
r_int
r_char
id|dummy_dir_ser2
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|dummy_dir_ser3
r_static
r_int
r_char
id|dummy_dir_ser3
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Info needed for each ports extra control/status signals.&n;   We only supports that all pins uses same register for each port */
DECL|struct|control_pins
r_struct
id|control_pins
(brace
DECL|member|port
r_volatile
r_int
r_char
op_star
id|port
suffix:semicolon
DECL|member|shadow
r_volatile
r_int
r_char
op_star
id|shadow
suffix:semicolon
DECL|member|dir_shadow
r_volatile
r_int
r_char
op_star
id|dir_shadow
suffix:semicolon
DECL|member|dtr_bit
r_int
r_char
id|dtr_bit
suffix:semicolon
DECL|member|ri_bit
r_int
r_char
id|ri_bit
suffix:semicolon
DECL|member|dsr_bit
r_int
r_char
id|dsr_bit
suffix:semicolon
DECL|member|cd_bit
r_int
r_char
id|cd_bit
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|e100_modem_pins
r_static
r_const
r_struct
id|control_pins
id|e100_modem_pins
(braket
id|NR_PORTS
)braket
op_assign
(brace
multiline_comment|/* Ser 0 */
(brace
macro_line|#if defined(CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB)
id|R_PORT_PB_DATA
comma
op_amp
id|port_pb_data_shadow
comma
op_amp
id|port_pb_dir_shadow
comma
id|CONFIG_ETRAX_SER0_DTR_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER0_RI_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER0_DSR_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER0_CD_ON_PB_BIT
macro_line|#else
op_amp
id|dummy_ser0
comma
op_amp
id|dummy_ser0
comma
op_amp
id|dummy_dir_ser0
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
macro_line|#endif   
)brace
comma
multiline_comment|/* Ser 1 */
(brace
macro_line|#if defined(CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB)
id|R_PORT_PB_DATA
comma
op_amp
id|port_pb_data_shadow
comma
op_amp
id|port_pb_dir_shadow
comma
id|CONFIG_ETRAX_SER1_DTR_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER1_RI_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER1_DSR_ON_PB_BIT
comma
id|CONFIG_ETRAX_SER1_CD_ON_PB_BIT
macro_line|#else
op_amp
id|dummy_ser1
comma
op_amp
id|dummy_ser1
comma
op_amp
id|dummy_dir_ser1
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
macro_line|#endif   
)brace
comma
multiline_comment|/* Ser 2 */
(brace
macro_line|#if defined(CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA)
id|R_PORT_PA_DATA
comma
op_amp
id|port_pa_data_shadow
comma
op_amp
id|port_pa_dir_shadow
comma
id|CONFIG_ETRAX_SER2_DTR_ON_PA_BIT
comma
id|CONFIG_ETRAX_SER2_RI_ON_PA_BIT
comma
id|CONFIG_ETRAX_SER2_DSR_ON_PA_BIT
comma
id|CONFIG_ETRAX_SER2_CD_ON_PA_BIT
macro_line|#else
op_amp
id|dummy_ser2
comma
op_amp
id|dummy_ser2
comma
op_amp
id|dummy_dir_ser2
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
macro_line|#endif   
)brace
comma
multiline_comment|/* Ser 3 */
(brace
op_amp
id|dummy_ser3
comma
op_amp
id|dummy_ser3
comma
op_amp
id|dummy_dir_ser3
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
)brace
)brace
suffix:semicolon
macro_line|#if defined(CONFIG_RS485) &amp;&amp; defined(CONFIG_RS485_ON_PA)
DECL|variable|rs485_pa_port
r_int
r_char
id|rs485_pa_port
op_assign
id|CONFIG_RS485_ON_PA_BIT
suffix:semicolon
macro_line|#endif
DECL|macro|E100_RTS_MASK
mdefine_line|#define E100_RTS_MASK 0x20
DECL|macro|E100_CTS_MASK
mdefine_line|#define E100_CTS_MASK 0x40
multiline_comment|/* All serial port signals are active low:&n; * active   = 0 -&gt; 3.3V to RS-232 driver -&gt; -12V on RS-232 level&n; * inactive = 1 -&gt; 0V   to RS-232 driver -&gt; +12V on RS-232 level&n; *&n; * These macros returns the pin value: 0=0V, &gt;=1 = 3.3V on ETRAX chip&n; */
multiline_comment|/* Output */
DECL|macro|E100_RTS_GET
mdefine_line|#define E100_RTS_GET(info) ((info)-&gt;rx_ctrl &amp; E100_RTS_MASK)
multiline_comment|/* Input */
DECL|macro|E100_CTS_GET
mdefine_line|#define E100_CTS_GET(info) ((info)-&gt;port[REG_STATUS] &amp; E100_CTS_MASK)
multiline_comment|/* These are typically PA or PB and 0 means 0V, 1 means 3.3V */
multiline_comment|/* Is an output */
DECL|macro|E100_DTR_GET
mdefine_line|#define E100_DTR_GET(info) ((*e100_modem_pins[(info)-&gt;line].shadow) &amp; (1 &lt;&lt; e100_modem_pins[(info)-&gt;line].dtr_bit))
multiline_comment|/* Normally inputs */
DECL|macro|E100_RI_GET
mdefine_line|#define E100_RI_GET(info) ((*e100_modem_pins[(info)-&gt;line].port) &amp; (1 &lt;&lt; e100_modem_pins[(info)-&gt;line].ri_bit))
DECL|macro|E100_CD_GET
mdefine_line|#define E100_CD_GET(info) ((*e100_modem_pins[(info)-&gt;line].port) &amp; (1 &lt;&lt; e100_modem_pins[(info)-&gt;line].cd_bit))
multiline_comment|/* Input */
DECL|macro|E100_DSR_GET
mdefine_line|#define E100_DSR_GET(info) ((*e100_modem_pins[(info)-&gt;line].port) &amp; (1 &lt;&lt; e100_modem_pins[(info)-&gt;line].dsr_bit))
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
multiline_comment|/*&n; * tmp_buf is used as a temporary buffer by serial_write.  We need to&n; * lock it in case the memcpy_fromfs blocks while swapping in a page,&n; * and some other program tries to do a serial write at the same time.&n; * Since the lock will only come under contention when the system is&n; * swapping and available memory is low, it makes sense to share one&n; * buffer across all the serial ports, since it significantly saves&n; * memory if large numbers of serial ports are open.&n; */
DECL|variable|tmp_buf
r_static
r_int
r_char
op_star
id|tmp_buf
suffix:semicolon
macro_line|#ifdef DECLARE_MUTEX
r_static
id|DECLARE_MUTEX
c_func
(paren
id|tmp_buf_sem
)paren
suffix:semicolon
macro_line|#else
DECL|variable|tmp_buf_sem
r_static
r_struct
id|semaphore
id|tmp_buf_sem
op_assign
id|MUTEX
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST
DECL|macro|TIMER1_IRQ_NBR
mdefine_line|#define TIMER1_IRQ_NBR 3
multiline_comment|/* clock select 10 for timer 1 gives 230400 Hz */
DECL|macro|FASTTIMER_SELECT
mdefine_line|#define FASTTIMER_SELECT (10)
multiline_comment|/* we use a source of 230400 Hz and a divider of 15 =&gt; 15360 Hz */
DECL|macro|FASTTIMER_DIV
mdefine_line|#define FASTTIMER_DIV (15)
multiline_comment|/* fast flush timer stuff */
DECL|variable|fast_timer_started
r_static
r_int
id|fast_timer_started
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timer_ints
r_static
r_int
r_int
r_int
id|fast_timer_ints
op_assign
l_int|0
suffix:semicolon
DECL|function|start_flush_timer
r_static
r_void
id|_INLINE_
id|start_flush_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|fast_timer_started
)paren
r_return
suffix:semicolon
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
(paren
id|r_timer_ctrl_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
)paren
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
id|FASTTIMER_DIV
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|stop_ld
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|FASTTIMER_SELECT
)paren
suffix:semicolon
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
(paren
id|r_timer_ctrl_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
)paren
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|run
)paren
suffix:semicolon
multiline_comment|/* enable timer1 irq */
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|timer1
comma
id|set
)paren
suffix:semicolon
id|fast_timer_started
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST */
multiline_comment|/*&n; * This function maps from the Bxxxx defines in asm/termbits.h into real&n; * baud rates.&n; */
r_static
r_int
DECL|function|cflag_to_baud
id|cflag_to_baud
c_func
(paren
r_int
r_int
id|cflag
)paren
(brace
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
)brace
suffix:semicolon
r_static
r_int
id|ext_baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|921600
comma
l_int|1843200
comma
l_int|6250000
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CBAUDEX
)paren
(brace
r_return
id|ext_baud_table
(braket
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_amp
op_complement
id|CBAUDEX
)braket
suffix:semicolon
)brace
r_else
r_return
id|baud_table
(braket
id|cflag
op_amp
id|CBAUD
)braket
suffix:semicolon
)brace
multiline_comment|/* and this maps to an etrax100 hardware baud constant */
r_static
r_int
r_char
DECL|function|cflag_to_etrax_baud
id|cflag_to_etrax_baud
c_func
(paren
r_int
r_int
id|cflag
)paren
(brace
r_char
id|retval
suffix:semicolon
r_static
r_char
id|baud_table
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
)brace
suffix:semicolon
r_static
r_char
id|ext_baud_table
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|8
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|13
comma
l_int|14
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CBAUDEX
)paren
(brace
id|retval
op_assign
id|ext_baud_table
(braket
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_amp
op_complement
id|CBAUDEX
)braket
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|baud_table
(braket
id|cflag
op_amp
id|CBAUD
)braket
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;serdriver tried setting invalid baud rate, flags %x.&bslash;n&quot;
comma
id|cflag
)paren
suffix:semicolon
id|retval
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* choose default 9600 instead */
)brace
r_return
id|retval
op_or
(paren
id|retval
op_lshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* choose same for both TX and RX */
)brace
multiline_comment|/* Various static support functions */
multiline_comment|/* Functions to set or clear DTR/RTS on the requested line */
multiline_comment|/* It is complicated by the fact that RTS is a serial port register, while&n; * DTR might not be implemented in the HW at all, and if it is, it can be on&n; * any general port.&n; */
r_static
r_inline
r_void
DECL|function|e100_dtr
id|e100_dtr
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|set
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
r_int
r_char
id|mask
op_assign
(paren
l_int|1
op_lshift
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|dtr_bit
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO  
id|printk
c_func
(paren
l_string|&quot;ser%i dtr %i mask: 0x%02X&bslash;n&quot;
comma
id|info-&gt;line
comma
id|set
comma
id|mask
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ser%i shadow before 0x%02X get: %i&bslash;n&quot;
comma
id|info-&gt;line
comma
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
comma
id|E100_DTR_GET
c_func
(paren
id|info
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* DTR is active low */
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_and_assign
op_complement
id|mask
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_or_assign
(paren
id|set
ques
c_cond
l_int|0
suffix:colon
id|mask
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
op_assign
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|REG_SHADOW_SET
c_func
(paren
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
comma
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
comma
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|dtr_bit
comma
op_logical_neg
id|set
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;ser%i shadow after 0x%02X get: %i&bslash;n&quot;
comma
id|info-&gt;line
comma
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
comma
id|E100_DTR_GET
c_func
(paren
id|info
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
multiline_comment|/* set = 0 means 3.3V on the pin, bitvalue: 0=active, 1=inactive  &n; *                                          0=0V    , 1=3.3V&n; */
r_static
r_inline
r_void
DECL|function|e100_rts
id|e100_rts
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|set
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
macro_line|#ifdef SERIAL_DEBUG_IO  
id|printk
c_func
(paren
l_string|&quot;ser%i rts %i&bslash;n&quot;
comma
id|info-&gt;line
comma
id|set
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;rx_ctrl
op_and_assign
op_complement
id|E100_RTS_MASK
suffix:semicolon
id|info-&gt;rx_ctrl
op_or_assign
(paren
id|set
ques
c_cond
l_int|0
suffix:colon
id|E100_RTS_MASK
)paren
suffix:semicolon
multiline_comment|/* RTS is active low */
id|info-&gt;port
(braket
id|REG_REC_CTRL
)braket
op_assign
id|info-&gt;rx_ctrl
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* If this behaves as a modem, RI and CD is an output */
r_static
r_inline
r_void
DECL|function|e100_ri_out
id|e100_ri_out
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|set
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* RI is active low */
(brace
r_int
r_char
id|mask
op_assign
(paren
l_int|1
op_lshift
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|ri_bit
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_and_assign
op_complement
id|mask
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_or_assign
(paren
id|set
ques
c_cond
l_int|0
suffix:colon
id|mask
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
op_assign
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|REG_SHADOW_SET
c_func
(paren
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
comma
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
comma
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|ri_bit
comma
op_logical_neg
id|set
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|e100_cd_out
id|e100_cd_out
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|set
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* CD is active low */
(brace
r_int
r_char
id|mask
op_assign
(paren
l_int|1
op_lshift
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|cd_bit
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_and_assign
op_complement
id|mask
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
op_or_assign
(paren
id|set
ques
c_cond
l_int|0
suffix:colon
id|mask
)paren
suffix:semicolon
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
op_assign
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|REG_SHADOW_SET
c_func
(paren
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|port
comma
op_star
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|shadow
comma
id|e100_modem_pins
(braket
id|info-&gt;line
)braket
dot
id|cd_bit
comma
op_logical_neg
id|set
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|e100_disable_rx
id|e100_disable_rx
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* disable the receiver */
id|info-&gt;port
(braket
id|REG_REC_CTRL
)braket
op_assign
(paren
id|info-&gt;rx_ctrl
op_and_assign
op_complement
l_int|0x40
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|e100_enable_rx
id|e100_enable_rx
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* enable the receiver */
id|info-&gt;port
(braket
id|REG_REC_CTRL
)braket
op_assign
(paren
id|info-&gt;rx_ctrl
op_or_assign
l_int|0x40
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* the rx DMA uses both the dma_descr and the dma_eop interrupts */
r_static
r_inline
r_void
DECL|function|e100_disable_rxdma_irq
id|e100_disable_rxdma_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;rxdma_irq(%d): 0&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK2_CLR
op_assign
(paren
id|info-&gt;irq
op_lshift
l_int|2
)paren
op_or
(paren
id|info-&gt;irq
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|e100_enable_rxdma_irq
id|e100_enable_rxdma_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;rxdma_irq(%d): 1&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK2_SET
op_assign
(paren
id|info-&gt;irq
op_lshift
l_int|2
)paren
op_or
(paren
id|info-&gt;irq
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* the tx DMA uses only dma_descr interrupt */
r_static
r_inline
r_void
DECL|function|e100_disable_txdma_irq
id|e100_disable_txdma_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;txdma_irq(%d): 0&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK2_CLR
op_assign
id|info-&gt;irq
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|e100_enable_txdma_irq
id|e100_enable_txdma_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;txdma_irq(%d): 1&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK2_SET
op_assign
id|info-&gt;irq
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS
multiline_comment|/* in order to detect and fix errors on the first byte&n; we have to use the serial interrupts as well. */
r_static
r_inline
r_void
DECL|function|e100_disable_serial_data_irq
id|e100_disable_serial_data_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;ser_irq(%d): 0&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK1_CLR
op_assign
(paren
l_int|1U
op_lshift
(paren
l_int|8
op_plus
l_int|2
op_star
id|info-&gt;line
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|e100_enable_serial_data_irq
id|e100_enable_serial_data_irq
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;ser_irq(%d): 1&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**** %d = %d&bslash;n&quot;
comma
(paren
l_int|8
op_plus
l_int|2
op_star
id|info-&gt;line
)paren
comma
(paren
l_int|1U
op_lshift
(paren
l_int|8
op_plus
l_int|2
op_star
id|info-&gt;line
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK1_SET
op_assign
(paren
l_int|1U
op_lshift
(paren
l_int|8
op_plus
l_int|2
op_star
id|info-&gt;line
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_RS485)
multiline_comment|/* Enable RS-485 mode on selected port. This is UGLY. */
r_static
r_int
DECL|function|e100_enable_rs485
id|e100_enable_rs485
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|rs485_control
op_star
id|r
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#if defined(CONFIG_RS485_ON_PA)&t;
op_star
id|R_PORT_PA_DATA
op_assign
id|port_pa_data_shadow
op_or_assign
(paren
l_int|1
op_lshift
id|rs485_pa_bit
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;rs485.rts_on_send
op_assign
l_int|0x01
op_amp
id|r-&gt;rts_on_send
suffix:semicolon
id|info-&gt;rs485.rts_after_sent
op_assign
l_int|0x01
op_amp
id|r-&gt;rts_after_sent
suffix:semicolon
id|info-&gt;rs485.delay_rts_before_send
op_assign
id|r-&gt;delay_rts_before_send
suffix:semicolon
id|info-&gt;rs485.enabled
op_assign
id|r-&gt;enabled
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Enable RS-485 mode on selected port. This is UGLY. */
r_static
r_int
DECL|function|e100_write_rs485
id|e100_write_rs485
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|rs485_write
op_star
id|r
)paren
(brace
r_int
id|stop_delay
suffix:semicolon
r_int
id|total
comma
id|i
suffix:semicolon
r_int
id|max_j
comma
id|delay_ms
comma
id|bits
suffix:semicolon
id|tcflag_t
id|cflags
suffix:semicolon
r_int
id|size
op_assign
id|r.outc_size
suffix:semicolon
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* If we are in RS-485 mode, we need to toggle RTS and disable&n;&t; * the receiver before initiating a DMA transfer&n;&t; */
id|e100_rts
c_func
(paren
id|info
comma
id|info-&gt;rs485.rts_on_send
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_RS485_DISABLE_RECEIVER)
id|e100_disable_rx
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_disable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|info-&gt;rs485.delay_rts_before_send
OG
l_int|0
)paren
(brace
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
(paren
id|info-&gt;rs485.delay_rts_before_send
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
)brace
id|total
op_assign
id|rs_write
c_func
(paren
id|tty
comma
l_int|1
comma
id|r.outc
comma
id|r.outc_size
)paren
suffix:semicolon
multiline_comment|/* If we are in RS-485 mode the following things has to be done:&n;&t; * wait until DMA is ready&n;&t; * wait on transmit shift register&n;&t; * wait to toggle RTS&n;&t; * enable the receiver&n;&t; */
multiline_comment|/* wait on transmit shift register */
multiline_comment|/* All is sent, check if we should wait more before toggling rts */
multiline_comment|/* calc. number of bits / data byte */
id|cflags
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* databits + startbit and 1 stopbit */
r_if
c_cond
(paren
(paren
id|cflags
op_amp
id|CSIZE
)paren
op_eq
id|CS7
)paren
(brace
id|bits
op_assign
l_int|9
suffix:semicolon
)brace
r_else
id|bits
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|cflags
op_amp
id|CSTOPB
)paren
(brace
multiline_comment|/* 2 stopbits ? */
id|bits
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflags
op_amp
id|PARENB
)paren
(brace
multiline_comment|/* parity bit ? */
id|bits
op_increment
suffix:semicolon
)brace
multiline_comment|/* calc timeout */
id|delay_ms
op_assign
(paren
(paren
id|bits
op_star
id|size
op_star
l_int|1000
)paren
op_div
id|info-&gt;baud
)paren
op_plus
l_int|1
suffix:semicolon
id|max_j
op_assign
id|jiffies
op_plus
(paren
id|delay_ms
op_star
id|HZ
)paren
op_div
l_int|1000
op_plus
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|max_j
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;port
(braket
id|REG_STATUS
)braket
op_amp
l_int|0x20
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;port
(braket
id|REG_STATUS
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* ~25 for loops per usec */
id|stop_delay
op_assign
l_int|25
op_star
(paren
l_int|1000000
op_div
id|info-&gt;baud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cflags
op_amp
id|CSTOPB
)paren
(brace
id|stop_delay
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|stop_delay
suffix:semicolon
id|i
op_increment
)paren
(brace
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|e100_rts
c_func
(paren
id|info
comma
id|info-&gt;rs485.rts_after_sent
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_RS485_DISABLE_RECEIVER)
id|e100_enable_rx
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_enable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
r_return
id|total
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * ------------------------------------------------------------&n; * rs_stop() and rs_start()&n; *&n; * This routines are called before setting or resetting tty-&gt;stopped.&n; * They enable or disable transmitter interrupts, as necessary.&n; * ------------------------------------------------------------&n; */
multiline_comment|/* FIXME - when are these used and what is the purpose ? &n; * In rs_stop we probably just can block the transmit DMA ready irq&n; * and in rs_start we re-enable it (and then the old one will come).&n; */
r_static
r_void
DECL|function|rs_stop
id|rs_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
r_static
r_void
DECL|function|rs_start
id|rs_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; *&n; * Here starts the interrupt handling routines.  All of the following&n; * subroutines are declared as inline and are folded into&n; * rs_interrupt().  They were separated out for readability&squot;s sake.&n; *&n; * Note: rs_interrupt() is a &quot;fast&quot; interrupt, which means that it&n; * runs with interrupts turned off.  People who may want to modify&n; * rs_interrupt() should try to keep the interrupt handler as fast as&n; * possible.  After you are done making modifications, it is not a bad&n; * idea to do:&n; * &n; * gcc -S -DKERNEL -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer serial.c&n; *&n; * and look at the resulting assemble code in serial.s.&n; *&n; * &t;&t;&t;&t;- Ted Ts&squot;o (tytso@mit.edu), 7-Mar-93&n; * -----------------------------------------------------------------------&n; */
multiline_comment|/*&n; * This routine is used by the interrupt handler to schedule&n; * processing in the software interrupt portion of the driver.&n; */
r_static
id|_INLINE_
r_void
DECL|function|rs_sched_event
id|rs_sched_event
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|event
)paren
(brace
id|info-&gt;event
op_or_assign
l_int|1
op_lshift
id|event
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tqueue
comma
op_amp
id|tq_serial
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|SERIAL_BH
)paren
suffix:semicolon
)brace
multiline_comment|/* The output DMA channel is free - use it to send as many chars as possible&n; * NOTES:&n; *   We don&squot;t pay attention to info-&gt;x_char, which means if the TTY wants to&n; *   use XON/XOFF it will set info-&gt;x_char but we won&squot;t send any X char!&n; * &n; *   To implement this, we&squot;d just start a DMA send of 1 byte pointing at a&n; *   buffer containing the X char, and skip updating xmit. We&squot;d also have to&n; *   check if the last sent char was the X char when we enter this function&n; *   the next time, to avoid updating xmit with the sent X value.&n; */
r_static
r_void
DECL|function|transmit_chars
id|transmit_chars
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_int
r_int
id|c
comma
id|sentl
suffix:semicolon
r_struct
id|etrax_dma_descr
op_star
id|descr
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* This will output too little if tail is not 0 always since&n;&t; * we don&squot;t reloop to send the other part. Anyway this SHOULD be a&n;&t; * no-op - transmit_chars would never really be called during sim&n;&t; * since rs_write does not write into the xmit buffer then.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;xmit.tail
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error in serial.c:transmit_chars(), tail!=0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit.head
op_ne
id|info-&gt;xmit.tail
)paren
(brace
id|SIMCOUT
c_func
(paren
id|info-&gt;xmit.buf
op_plus
id|info-&gt;xmit.tail
comma
id|CIRC_CNT
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
id|info-&gt;xmit.tail
suffix:semicolon
multiline_comment|/* move back head */
id|info-&gt;tr_running
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* acknowledge both a dma_descr and dma_eop irq in R_DMAx_CLRINTR */
op_star
id|info-&gt;oclrintradr
op_assign
l_int|3
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_INTR
r_if
c_cond
(paren
id|info-&gt;line
op_eq
id|SERIAL_DEBUG_LINE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tc&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tr_running
)paren
(brace
multiline_comment|/* weirdo... we shouldn&squot;t get here! */
id|printk
c_func
(paren
l_string|&quot;Achtung: transmit_chars with !tr_running&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|descr
op_assign
op_amp
id|info-&gt;tr_descr
suffix:semicolon
multiline_comment|/* first get the amount of bytes sent during the last DMA transfer,&n;&t;   and update xmit accordingly */
multiline_comment|/* if the stop bit was not set, all data has been sent */
r_if
c_cond
(paren
op_logical_neg
(paren
id|descr-&gt;status
op_amp
id|d_stop
)paren
)paren
(brace
id|sentl
op_assign
id|descr-&gt;sw_len
suffix:semicolon
)brace
r_else
multiline_comment|/* otherwise we find the amount of data sent here */
id|sentl
op_assign
id|descr-&gt;hw_len
suffix:semicolon
multiline_comment|/* update stats */
id|info-&gt;icount.tx
op_add_assign
id|sentl
suffix:semicolon
multiline_comment|/* update xmit buffer */
id|info-&gt;xmit.tail
op_assign
(paren
id|info-&gt;xmit.tail
op_plus
id|sentl
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if there is only a few chars left in the buf, wake up the blocked&n;&t;   write if any */
r_if
c_cond
(paren
id|CIRC_CNT
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
OL
id|WAKEUP_CHARS
)paren
id|rs_sched_event
c_func
(paren
id|info
comma
id|RS_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/* find out the largest amount of consecutive bytes we want to send now */
id|c
op_assign
id|CIRC_CNT_TO_END
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
multiline_comment|/* our job here is done, don&squot;t schedule any new DMA transfer */
id|info-&gt;tr_running
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_RS485)
multiline_comment|/* Check if we should toggle RTS now */
r_if
c_cond
(paren
id|info-&gt;rs485.enabled
)paren
(brace
multiline_comment|/* Make sure fifo is empty */
r_int
id|in_fifo
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|in_fifo
op_assign
(paren
op_star
id|info-&gt;ostatusadr
)paren
op_amp
l_int|0x007F
suffix:semicolon
)brace
r_while
c_loop
(paren
id|in_fifo
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Any way to really check transmitter empty? (TEMT) */
multiline_comment|/* Control RTS to set to RX mode */
id|e100_rts
c_func
(paren
id|info
comma
id|info-&gt;rs485.rts_after_sent
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_RS485_DISABLE_RECEIVER)
id|e100_enable_rx
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_enable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* RS485 */
r_return
suffix:semicolon
)brace
multiline_comment|/* ok we can schedule a dma send of c chars starting at info-&gt;xmit.tail */
multiline_comment|/* set up the descriptor correctly for output */
id|descr-&gt;ctrl
op_assign
id|d_int
op_or
id|d_eol
op_or
id|d_wait
suffix:semicolon
multiline_comment|/* Wait needed for tty_wait_until_sent() */
id|descr-&gt;sw_len
op_assign
id|c
suffix:semicolon
id|descr-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|info-&gt;xmit.buf
op_plus
id|info-&gt;xmit.tail
)paren
suffix:semicolon
id|descr-&gt;status
op_assign
l_int|0
suffix:semicolon
op_star
id|info-&gt;ofirstadr
op_assign
id|virt_to_phys
c_func
(paren
id|descr
)paren
suffix:semicolon
multiline_comment|/* write to R_DMAx_FIRST */
op_star
id|info-&gt;ocmdadr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dma command start -&gt; R_DMAx_CMD */
multiline_comment|/* DMA is now running (hopefully) */
)brace
r_static
r_void
DECL|function|start_transmit
id|start_transmit
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|info-&gt;line
op_eq
id|SERIAL_DEBUG_LINE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;x&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|info-&gt;tr_descr.sw_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tr_descr.hw_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tr_descr.status
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tr_running
op_assign
l_int|1
suffix:semicolon
id|transmit_chars
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_static
id|_INLINE_
r_void
DECL|function|receive_chars
id|receive_chars
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
id|rstat
suffix:semicolon
r_int
r_int
id|recvl
suffix:semicolon
r_struct
id|etrax_dma_descr
op_star
id|descr
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* No receive in the simulator.  Will probably be when the rest of&n;&t; * the serial interface works, and this piece will just be removed.&n;&t; */
r_return
suffix:semicolon
macro_line|#endif
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
multiline_comment|/* acknowledge both a dma_descr and dma_eop irq in R_DMAx_CLRINTR */
op_star
id|info-&gt;iclrintradr
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
multiline_comment|/* something wrong... */
r_return
suffix:semicolon
)brace
id|descr
op_assign
op_amp
id|info-&gt;rec_descr
suffix:semicolon
multiline_comment|/* find out how many bytes were read */
multiline_comment|/* if the eop bit was not set, all data has been received */
r_if
c_cond
(paren
op_logical_neg
(paren
id|descr-&gt;status
op_amp
id|d_eop
)paren
)paren
(brace
id|recvl
op_assign
id|descr-&gt;sw_len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* otherwise we find the amount of data received here */
id|recvl
op_assign
id|descr-&gt;hw_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recvl
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_struct
id|async_icount
op_star
id|icount
suffix:semicolon
id|icount
op_assign
op_amp
id|info-&gt;icount
suffix:semicolon
multiline_comment|/* update stats */
id|icount-&gt;rx
op_add_assign
id|recvl
suffix:semicolon
multiline_comment|/* read the status register so we can detect errors */
id|rstat
op_assign
id|info-&gt;port
(braket
id|REG_STATUS
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rstat
op_amp
l_int|0xe
)paren
(brace
multiline_comment|/* if we got an error, we must reset it by reading the&n;&t;&t;&t; * data_in field&n;&t;&t;&t; */
(paren
r_void
)paren
id|info-&gt;port
(braket
id|REG_DATA
)braket
suffix:semicolon
)brace
multiline_comment|/* we only ever write errors into the first byte in the flip &n;&t;&t; * flag buffer, so we dont have to clear it all every time&n;&t;&t; */
r_if
c_cond
(paren
id|rstat
op_amp
l_int|0x04
)paren
(brace
id|icount-&gt;parity
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rstat
op_amp
l_int|0x08
)paren
(brace
id|icount-&gt;overrun
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rstat
op_amp
l_int|0x02
)paren
(brace
id|icount-&gt;frame
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
)brace
r_else
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* use the flip buffer next in turn to restart DMA into */
r_if
c_cond
(paren
id|tty-&gt;flip.buf_num
)paren
(brace
id|buf
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|tty-&gt;flip.char_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
op_eq
id|phys_to_virt
c_func
(paren
id|descr-&gt;buf
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ttyS%d flip-buffer overrun!&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
id|icount-&gt;overrun
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
multiline_comment|/* restart old buffer */
)brace
r_else
(brace
id|descr-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* schedule or push a flip of the buffer */
id|info-&gt;tty-&gt;flip.count
op_assign
id|recvl
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; 131394) /* 2.1.66 */
multiline_comment|/* this includes a check for low-latency */
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
macro_line|#else
id|queue_task_irq_off
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
)brace
multiline_comment|/* restart the receiving dma */
id|descr-&gt;sw_len
op_assign
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|descr-&gt;ctrl
op_assign
id|d_int
op_or
id|d_eol
op_or
id|d_eop
suffix:semicolon
id|descr-&gt;hw_len
op_assign
l_int|0
suffix:semicolon
id|descr-&gt;status
op_assign
l_int|0
suffix:semicolon
op_star
id|info-&gt;ifirstadr
op_assign
id|virt_to_phys
c_func
(paren
id|descr
)paren
suffix:semicolon
op_star
id|info-&gt;icmdadr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start */
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS
id|e100_enable_serial_data_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/* input dma should be running now */
)brace
r_static
r_void
DECL|function|start_receive
id|start_receive
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_struct
id|etrax_dma_descr
op_star
id|descr
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* No receive in the simulator.  Will probably be when the rest of&n;&t; * the serial interface works, and this piece will just be removed.&n;&t; */
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* reset the input dma channel to be sure it works */
op_star
id|info-&gt;icmdadr
op_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|info-&gt;icmdadr
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
suffix:semicolon
)brace
id|descr
op_assign
op_amp
id|info-&gt;rec_descr
suffix:semicolon
multiline_comment|/* start the receiving dma into the flip buffer */
id|descr-&gt;ctrl
op_assign
id|d_int
op_or
id|d_eol
op_or
id|d_eop
suffix:semicolon
id|descr-&gt;sw_len
op_assign
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|descr-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|info-&gt;tty-&gt;flip.char_buf_ptr
)paren
suffix:semicolon
id|descr-&gt;hw_len
op_assign
l_int|0
suffix:semicolon
id|descr-&gt;status
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tty-&gt;flip.count
op_assign
l_int|0
suffix:semicolon
op_star
id|info-&gt;ifirstadr
op_assign
id|virt_to_phys
c_func
(paren
id|descr
)paren
suffix:semicolon
op_star
id|info-&gt;icmdadr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start */
)brace
r_static
id|_INLINE_
r_void
DECL|function|status_handle
id|status_handle
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
r_int
id|status
)paren
(brace
)brace
multiline_comment|/* the bits in the MASK2 register are laid out like this:&n;   DMAI_EOP DMAI_DESCR DMAO_EOP DMAO_DESCR&n;   where I is the input channel and O is the output channel for the port.&n;   info-&gt;irq is the bit number for the DMAO_DESCR so to check the others we&n;   shift info-&gt;irq to the left.&n;*/
multiline_comment|/* dma output channel interrupt handler&n;   this interrupt is called from DMA2(ser2), DMA4(ser3), DMA6(ser0) or&n;   DMA8(ser1) when they have finished a descriptor with the intr flag set.&n;*/
r_static
r_void
DECL|function|tr_interrupt
id|tr_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
r_int
r_int
id|ireg
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* No receive in the simulator.  Will probably be when the rest of&n;&t; * the serial interface works, and this piece will just be removed.&n;&t; */
(brace
r_const
r_char
op_star
id|s
op_assign
l_string|&quot;What? tr_interrupt in simulator??&bslash;n&quot;
suffix:semicolon
id|SIMCOUT
c_func
(paren
id|s
comma
id|strlen
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* find out the line that caused this irq and get it from rs_table */
id|ireg
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
multiline_comment|/* get the active irq bits for the dma channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info
op_assign
id|rs_table
op_plus
id|i
suffix:semicolon
multiline_comment|/* check for dma_descr (dont need to check for dma_eop in output dma for serial */
r_if
c_cond
(paren
id|ireg
op_amp
id|info-&gt;irq
)paren
(brace
multiline_comment|/* we can send a new dma bunch. make it so. */
id|transmit_chars
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: here we should really check for a change in the&n;&t;&t;   status lines and if so call status_handle(info) */
)brace
)brace
multiline_comment|/* dma input channel interrupt handler */
r_static
r_void
DECL|function|rec_interrupt
id|rec_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
r_int
r_int
id|ireg
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* No receive in the simulator.  Will probably be when the rest of&n;&t; * the serial interface works, and this piece will just be removed.&n;&t; */
(brace
r_const
r_char
op_star
id|s
op_assign
l_string|&quot;What? rec_interrupt in simulator??&bslash;n&quot;
suffix:semicolon
id|SIMCOUT
c_func
(paren
id|s
comma
id|strlen
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* find out the line that caused this irq and get it from rs_table */
id|ireg
op_assign
op_star
id|R_IRQ_MASK2_RD
suffix:semicolon
multiline_comment|/* get the active irq bits for the dma channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info
op_assign
id|rs_table
op_plus
id|i
suffix:semicolon
multiline_comment|/* check for both dma_eop and dma_descr for the input dma channel */
r_if
c_cond
(paren
id|ireg
op_amp
(paren
(paren
id|info-&gt;irq
op_lshift
l_int|2
)paren
op_or
(paren
id|info-&gt;irq
op_lshift
l_int|3
)paren
)paren
)paren
(brace
multiline_comment|/* we have received something */
id|receive_chars
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: here we should really check for a change in the&n;&t;&t;   status lines and if so call status_handle(info) */
)brace
)brace
multiline_comment|/* dma fifo/buffer timeout handler&n;   forces an end-of-packet for the dma input channel if no chars &n;   have been received for CONFIG_ETRAX_RX_TIMEOUT_TICKS/100 s.&n;   If CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST is configured then this&n;   handler is instead run at 15360 Hz.&n;*/
macro_line|#ifndef CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST
DECL|variable|timeout_divider
r_static
r_int
id|timeout_divider
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|flush_timer
r_static
r_struct
id|timer_list
id|flush_timer
suffix:semicolon
r_static
r_void
DECL|function|timed_flush_handler
id|timed_flush_handler
c_func
(paren
r_void
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|magic
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
r_return
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info
op_assign
id|rs_table
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* istatusadr (bit 6-0) hold number of bytes in fifo &n;&t;&t; * ihwswadr (bit 31-16) holds number of bytes in dma buffer&n;&t;&t; * ihwswadr (bit 15-0) specifies size of dma buffer&n;&t;&t; */
id|magic
op_assign
(paren
op_star
id|info-&gt;istatusadr
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|magic
op_add_assign
(paren
(paren
op_star
id|info-&gt;ihwswadr
op_amp
l_int|0xffff
)paren
op_minus
(paren
op_star
id|info-&gt;ihwswadr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* if magic is equal to fifo_magic (magic in previous&n;&t;&t; * timeout_interrupt) then no new data has arrived since last&n;&t;&t; * interrupt and we&squot;ll force eop to flush fifo+dma buffers&n;&t;&t; */
r_if
c_cond
(paren
id|magic
op_ne
id|info-&gt;fifo_magic
)paren
(brace
id|info-&gt;fifo_magic
op_assign
id|magic
suffix:semicolon
id|info-&gt;fifo_didmagic
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* hit the timeout, force an EOP for the input&n;&t;&t;&t; * dma channel if we haven&squot;t already&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;fifo_didmagic
op_logical_and
id|magic
)paren
(brace
id|info-&gt;fifo_didmagic
op_assign
l_int|1
suffix:semicolon
id|info-&gt;fifo_magic
op_assign
l_int|0
suffix:semicolon
op_star
id|R_SET_EOP
op_assign
l_int|1U
op_lshift
id|info-&gt;iseteop
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* restart flush timer */
id|mod_timer
c_func
(paren
op_amp
id|flush_timer
comma
id|jiffies
op_plus
id|MAX_FLUSH_TIME
)paren
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS
multiline_comment|/* If there is an error (ie break) when the DMA is running and&n; * there are no bytes in the fifo the DMA is stopped and we get no&n; * eop interrupt. Thus we have to monitor the first bytes on a DMA&n; * transfer, and if it is without error we can turn the serial&n; * interrupts off.&n; */
r_static
r_void
DECL|function|ser_interrupt
id|ser_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|rstat
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info
op_assign
id|rs_table
op_plus
id|i
suffix:semicolon
id|rstat
op_assign
id|info-&gt;port
(braket
id|REG_STATUS
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|R_IRQ_MASK1_RD
op_amp
(paren
l_int|1U
op_lshift
(paren
l_int|8
op_plus
l_int|2
op_star
id|info-&gt;line
)paren
)paren
)paren
(brace
multiline_comment|/* This line caused the irq */
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;Interrupt from serport %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rstat
op_amp
l_int|0x0e
)paren
(brace
multiline_comment|/* FIXME: This is weird, but if this delay is&n;&t;&t;&t;&t; * not present then irmaflash does not work...&n;&t;&t;&t;&t; */
id|udelay
c_func
(paren
l_int|2300
)paren
suffix:semicolon
multiline_comment|/* if we got an error, we must reset it by&n;&t;&t;&t;&t; * reading the data_in field&n;&t;&t;&t;&t; */
(paren
r_void
)paren
id|info-&gt;port
(braket
id|REG_DATA
)braket
suffix:semicolon
id|PROCSTAT
c_func
(paren
id|early_errors_cnt
(braket
id|info-&gt;line
)braket
op_increment
)paren
suffix:semicolon
multiline_comment|/* restart the DMA */
op_star
id|info-&gt;icmdadr
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it was a valid byte, now let the dma do the rest */
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;** OK, disabling ser_interrupts&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|e100_disable_serial_data_irq
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * -------------------------------------------------------------------&n; * Here ends the serial interrupt routines.&n; * -------------------------------------------------------------------&n; */
multiline_comment|/*&n; * This routine is used to handle the &quot;bottom half&quot; processing for the&n; * serial driver, known also the &quot;software interrupt&quot; processing.&n; * This processing is done at the kernel interrupt level, after the&n; * rs_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This&n; * is where time-consuming activities which can not be done in the&n; * interrupt driver proper are done; the interrupt driver schedules&n; * them using rs_sched_event(), and they get done here.&n; */
r_static
r_void
DECL|function|do_serial_bh
id|do_serial_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_serial
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_softint
id|do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|RS_EVENT_WRITE_WAKEUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called from the scheduler tqueue when the interrupt&n; * routine has signalled that a hangup has occurred.  The path of&n; * hangup processing is:&n; *&n; * &t;serial interrupt routine -&gt; (scheduler tqueue) -&gt;&n; * &t;do_serial_hangup() -&gt; tty-&gt;hangup() -&gt; rs_hangup()&n; * &n; */
r_static
r_void
DECL|function|do_serial_hangup
id|do_serial_hangup
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|startup
id|startup
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
id|page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if it was already initialized, skip this */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit.buf
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|info-&gt;xmit.buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|page
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;starting up ttyS%d (xmit_buf 0x%x)...&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;xmit.buf
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
multiline_comment|/* clear the tty flip flag buffer since we will not&n;&t;&t; * be using it (we only use the first byte..)&n;&t;&t; */
id|memset
c_func
(paren
id|info-&gt;tty-&gt;flip.flag_buf
comma
l_int|0
comma
id|TTY_FLIPBUF_SIZE
op_star
l_int|2
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* Bits and pieces collected from below.  Better to have them&n;&t;   in one ifdef:ed clause than to mix in a lot of ifdefs,&n;&t;   right? */
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
id|info-&gt;xmit.tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No real action in the simulator, but may set info important&n;&t;   to ioctl. */
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Clear the FIFO buffers and disable them&n;&t; * (they will be reenabled in change_speed())&n;&t; */
multiline_comment|/*&n;&t; * Reset the DMA channels and make sure their interrupts are cleared&n;&t; */
op_star
id|info-&gt;icmdadr
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* reset command */
op_star
id|info-&gt;ocmdadr
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* reset command */
r_while
c_loop
(paren
(paren
op_star
id|info-&gt;icmdadr
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait until reset cycle is complete */
r_while
c_loop
(paren
(paren
op_star
id|info-&gt;ocmdadr
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
suffix:semicolon
)brace
op_star
id|info-&gt;iclrintradr
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* make sure the irqs are cleared */
op_star
id|info-&gt;oclrintradr
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
id|info-&gt;xmit.tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * and set the speed and other flags of the serial port&n;&t; * this will start the rx/tx as well&n;&t; */
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS
id|e100_enable_serial_data_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif&t;
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* dummy read to reset any serial errors */
(paren
r_void
)paren
id|info-&gt;port
(braket
id|REG_DATA
)braket
suffix:semicolon
multiline_comment|/* enable the interrupts */
id|e100_enable_txdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_enable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;tr_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to be sure we dont lock up the transmitter */
multiline_comment|/* setup the dma input descriptor and start dma */
id|start_receive
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* for safety, make sure the descriptors last result is 0 bytes written */
id|info-&gt;tr_descr.sw_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tr_descr.hw_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tr_descr.status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* enable RTS/DTR last */
id|e100_rts
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
id|e100_dtr
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SVINTO_SIM */
id|info-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine will shutdown a serial port; interrupts are disabled, and&n; * DTR is dropped if the hangup on close termio flag is on.&n; */
r_static
r_void
DECL|function|shutdown
id|shutdown
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifndef CONFIG_SVINTO_SIM&t;
multiline_comment|/* shut down the transmitter and receiver  */
id|e100_disable_rx
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;port
(braket
id|REG_TR_CTRL
)braket
op_assign
(paren
id|info-&gt;tx_ctrl
op_and_assign
op_complement
l_int|0x40
)paren
suffix:semicolon
id|e100_disable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_disable_txdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;tr_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset both dma channels */
op_star
id|info-&gt;icmdadr
op_assign
l_int|4
suffix:semicolon
op_star
id|info-&gt;ocmdadr
op_assign
l_int|4
suffix:semicolon
macro_line|#endif /* CONFIG_SVINTO_SIM */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;Shutting down serial port %d (irq %d)....&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts */
r_if
c_cond
(paren
id|info-&gt;xmit.buf
)paren
(brace
r_int
r_int
id|pg
op_assign
(paren
r_int
r_int
)paren
id|info-&gt;xmit.buf
suffix:semicolon
id|info-&gt;xmit.buf
op_assign
l_int|0
suffix:semicolon
id|free_page
c_func
(paren
id|pg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
(brace
multiline_comment|/* hang up DTR and RTS if HUPCL is enabled */
id|e100_dtr
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
id|e100_rts
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* could check CRTSCTS before doing this */
)brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* change baud rate and other assorted parameters */
r_static
r_void
DECL|function|change_speed
id|change_speed
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_int
r_int
id|cflag
suffix:semicolon
multiline_comment|/* first some safety checks */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
op_logical_neg
id|info-&gt;tty-&gt;termios
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;port
)paren
r_return
suffix:semicolon
id|cflag
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* possibly, the tx/rx should be disabled first to do this safely */
multiline_comment|/* change baud-rate and write it to the hardware */
id|info-&gt;baud
op_assign
id|cflag_to_baud
c_func
(paren
id|cflag
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SVINTO_SIM
id|info-&gt;port
(braket
id|REG_BAUD
)braket
op_assign
id|cflag_to_etrax_baud
c_func
(paren
id|cflag
)paren
suffix:semicolon
multiline_comment|/* start with default settings and then fill in changes */
id|info-&gt;rx_ctrl
op_and_assign
op_complement
(paren
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* 8 bit, no/even parity */
id|info-&gt;tx_ctrl
op_and_assign
op_complement
(paren
l_int|0x37
)paren
suffix:semicolon
multiline_comment|/* 8 bit, no/even parity, 1 stop bit, no cts */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CSIZE
)paren
op_eq
id|CS7
)paren
(brace
multiline_comment|/* set 7 bit mode */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x01
suffix:semicolon
id|info-&gt;rx_ctrl
op_or_assign
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
(brace
multiline_comment|/* set 2 stop bit mode */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x10
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
(brace
multiline_comment|/* enable parity */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x02
suffix:semicolon
id|info-&gt;rx_ctrl
op_or_assign
l_int|0x02
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARODD
)paren
(brace
multiline_comment|/* set odd parity */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x04
suffix:semicolon
id|info-&gt;rx_ctrl
op_or_assign
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
(brace
multiline_comment|/* enable automatic CTS handling */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x20
suffix:semicolon
)brace
multiline_comment|/* make sure the tx and rx are enabled */
id|info-&gt;tx_ctrl
op_or_assign
l_int|0x40
suffix:semicolon
id|info-&gt;rx_ctrl
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* actually write the control regs to the hardware */
id|info-&gt;port
(braket
id|REG_TR_CTRL
)braket
op_assign
id|info-&gt;tx_ctrl
suffix:semicolon
id|info-&gt;port
(braket
id|REG_REC_CTRL
)braket
op_assign
id|info-&gt;rx_ctrl
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|info-&gt;port
(braket
id|REG_XOFF
)braket
)paren
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_SVINTO_SIM */
)brace
multiline_comment|/* start transmitting chars NOW */
r_static
r_void
DECL|function|rs_flush_chars
id|rs_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tr_running
op_logical_or
id|info-&gt;xmit.head
op_eq
id|info-&gt;xmit.tail
op_logical_or
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
op_logical_neg
id|info-&gt;xmit.buf
)paren
r_return
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_FLOW
id|printk
c_func
(paren
l_string|&quot;rs_flush_chars&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* this protection might not exactly be necessary here */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|start_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|rs_write
id|rs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* first some sanity checks */
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit.buf
op_logical_or
op_logical_neg
id|tmp_buf
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DATA
r_if
c_cond
(paren
id|info-&gt;line
op_eq
id|SERIAL_DEBUG_LINE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rs_write (%d), status %d&bslash;n&quot;
comma
id|count
comma
id|info-&gt;port
(braket
id|REG_STATUS
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* Really simple.  The output is here and now. */
id|SIMCOUT
c_func
(paren
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* the cli/restore_flags pairs below are needed because the&n;&t; * DMA interrupt handler moves the info-&gt;xmit values. the memcpy&n;&t; * needs to be in the critical region unfortunately, because we&n;&t; * need to read xmit values, memcpy, write xmit values in one&n;&t; * atomic operation... this could perhaps be avoided by more clever&n;&t; * design.&n;&t; */
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|c1
suffix:semicolon
id|c
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|c
)paren
id|c
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_sub_assign
id|copy_from_user
c_func
(paren
id|tmp_buf
comma
id|buf
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|c1
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c1
OL
id|c
)paren
id|c
op_assign
id|c1
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;xmit.buf
op_plus
id|info-&gt;xmit.head
comma
id|tmp_buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
(paren
(paren
id|info-&gt;xmit.head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|c
)paren
id|c
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;xmit.buf
op_plus
id|info-&gt;xmit.head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
(paren
id|info-&gt;xmit.head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* enable transmitter if not running, unless the tty is stopped&n;&t; * this does not need IRQ protection since if tr_running == 0&n;&t; * the IRQ&squot;s are not running anyway for this port.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;xmit.head
op_ne
id|info-&gt;xmit.tail
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
op_logical_and
op_logical_neg
id|info-&gt;tr_running
)paren
(brace
id|start_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* how much space is available in the xmit buffer? */
r_static
r_int
DECL|function|rs_write_room
id|rs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_return
id|CIRC_SPACE
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* How many chars are in the xmit buffer?&n; * This does not include any chars in the transmitter FIFO.&n; * Use wait_until_sent for waiting for FIFO drain.&n; */
r_static
r_int
DECL|function|rs_chars_in_buffer
id|rs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_return
id|CIRC_CNT
c_func
(paren
id|info-&gt;xmit.head
comma
id|info-&gt;xmit.tail
comma
id|SERIAL_XMIT_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* discard everything in the xmit buffer */
r_static
r_void
DECL|function|rs_flush_buffer
id|rs_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;xmit.head
op_assign
id|info-&gt;xmit.tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to send a high-priority XON/XOFF character to&n; * the device&n; *&n; * Since we don&squot;t bother to check for info-&gt;x_char in transmit_chars yet,&n; * we don&squot;t really implement this function yet.&n; */
DECL|function|rs_send_xchar
r_static
r_void
id|rs_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;serial.c:rs_send_xchar not implemented!&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;x_char
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
multiline_comment|/* Make sure transmit interrupts are on */
multiline_comment|/* TODO. */
)brace
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * rs_throttle()&n; * &n; * This routine is called by the upper-layer tty layer to signal that&n; * incoming characters should be throttled.&n; * ------------------------------------------------------------&n; */
r_static
r_void
DECL|function|rs_throttle
id|rs_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;throttle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|info-&gt;x_char
op_assign
id|STOP_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Turn off RTS line (do this atomic) should here be an else ?? */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|e100_rts
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|rs_unthrottle
id|rs_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;unthrottle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
r_else
id|info-&gt;x_char
op_assign
id|START_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Assert RTS line (do this atomic) */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|e100_rts
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * rs_ioctl() and friends&n; * ------------------------------------------------------------&n; */
r_static
r_int
DECL|function|get_serial_info
id|get_serial_info
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|retinfo
)paren
(brace
r_struct
id|serial_struct
id|tmp
suffix:semicolon
multiline_comment|/* this is all probably wrong, there are a lot of fields&n;&t; * here that we don&squot;t have in e100_serial and maybe we&n;&t; * should set them to something else than 0.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|retinfo
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.type
op_assign
id|info-&gt;type
suffix:semicolon
id|tmp.line
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp.port
op_assign
(paren
r_int
)paren
id|info-&gt;port
suffix:semicolon
id|tmp.irq
op_assign
id|info-&gt;irq
suffix:semicolon
id|tmp.flags
op_assign
id|info-&gt;flags
suffix:semicolon
id|tmp.close_delay
op_assign
id|info-&gt;close_delay
suffix:semicolon
id|tmp.closing_wait
op_assign
id|info-&gt;closing_wait
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|retinfo
comma
op_amp
id|tmp
comma
r_sizeof
(paren
op_star
id|retinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_serial_info
id|set_serial_info
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|new_info
)paren
(brace
r_struct
id|serial_struct
id|new_serial
suffix:semicolon
r_struct
id|e100_serial
id|old_info
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_serial
comma
id|new_info
comma
r_sizeof
(paren
id|new_serial
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|old_info
op_assign
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_serial.type
op_ne
id|info-&gt;type
)paren
op_logical_or
(paren
id|new_serial.close_delay
op_ne
id|info-&gt;close_delay
)paren
op_logical_or
(paren
(paren
id|new_serial.flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_ne
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_USR_MASK
)paren
)paren
suffix:semicolon
r_goto
id|check_and_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * OK, past this point, all the error checking has been done.&n;&t; * At this point, we start making changes.....&n;&t; */
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_FLAGS
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_FLAGS
)paren
)paren
suffix:semicolon
id|info-&gt;type
op_assign
id|new_serial.type
suffix:semicolon
id|info-&gt;close_delay
op_assign
id|new_serial.close_delay
suffix:semicolon
id|info-&gt;closing_wait
op_assign
id|new_serial.closing_wait
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; 0x20100)
id|info-&gt;tty-&gt;low_latency
op_assign
(paren
id|info-&gt;flags
op_amp
id|ASYNC_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
id|check_and_exit
suffix:colon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * get_lsr_info - get line status register info&n; *&n; * Purpose: Let user call ioctl() to get info when the UART physically&n; * &t;    is emptied.  On bus types like RS485, the transmitter must&n; * &t;    release the bus after transmitting. This must be done when&n; * &t;    the transmit shift register is empty, not be done when the&n; * &t;    transmit holding register is empty.  This functionality&n; * &t;    allows an RS485 driver to be written in user space. &n; */
r_static
r_int
DECL|function|get_lsr_info
id|get_lsr_info
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|result
suffix:semicolon
macro_line|#ifdef CONFIG_SVINTO_SIM
multiline_comment|/* Always open. */
id|result
op_assign
id|TIOCSER_TEMT
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_star
id|info-&gt;ostatusadr
op_amp
l_int|0x007F
)paren
multiline_comment|/* something in fifo */
id|result
op_assign
l_int|0
suffix:semicolon
r_else
id|result
op_assign
id|TIOCSER_TEMT
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|value
comma
op_amp
id|result
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_IO 
DECL|struct|state_str
r_struct
id|state_str
(brace
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|str
r_const
r_char
op_star
id|str
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|control_state_str
r_const
r_struct
id|state_str
id|control_state_str
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|function|get_control_state_str
r_char
op_star
id|get_control_state_str
c_func
(paren
r_int
id|MLines
comma
r_char
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|s
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
id|control_state_str
(braket
id|i
)braket
dot
id|str
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|MLines
op_amp
id|control_state_str
(braket
id|i
)braket
dot
id|state
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|strcat
c_func
(paren
id|s
comma
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|s
comma
id|control_state_str
(braket
id|i
)braket
dot
id|str
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|get_modem_info
id|get_modem_info
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|result
suffix:semicolon
multiline_comment|/* Polarity isn&squot;t verified */
macro_line|#if 0 /*def SERIAL_DEBUG_IO  */
id|printk
c_func
(paren
l_string|&quot;get_modem_info: RTS: %i DTR: %i CD: %i RI: %i DSR: %i CTS: %i&bslash;n&quot;
comma
id|E100_RTS_GET
c_func
(paren
id|info
)paren
comma
id|E100_DTR_GET
c_func
(paren
id|info
)paren
comma
id|E100_CD_GET
c_func
(paren
id|info
)paren
comma
id|E100_RI_GET
c_func
(paren
id|info
)paren
comma
id|E100_DSR_GET
c_func
(paren
id|info
)paren
comma
id|E100_CTS_GET
c_func
(paren
id|info
)paren
)paren
suffix:semicolon
macro_line|#endif
id|result
op_assign
(paren
op_logical_neg
id|E100_RTS_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
op_logical_neg
id|E100_DTR_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
op_logical_neg
id|E100_CD_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
op_logical_neg
id|E100_RI_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
op_logical_neg
id|E100_DSR_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
op_logical_neg
id|E100_CTS_GET
c_func
(paren
id|info
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO 
id|printk
c_func
(paren
l_string|&quot;e100ser: modem state: %i 0x%08X&bslash;n&quot;
comma
id|result
comma
id|result
)paren
suffix:semicolon
(brace
r_char
id|s
(braket
l_int|100
)braket
suffix:semicolon
id|get_control_state_str
c_func
(paren
id|result
comma
id|s
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;state: %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
)brace
macro_line|#endif  
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|value
comma
op_amp
id|result
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_modem_info
id|set_modem_info
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|arg
comma
id|value
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|e100_rts
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|e100_dtr
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle FEMALE behaviour */
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RI
)paren
(brace
id|e100_ri_out
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_CD
)paren
(brace
id|e100_cd_out
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|e100_rts
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|e100_dtr
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle FEMALE behaviour */
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RI
)paren
(brace
id|e100_ri_out
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_CD
)paren
(brace
id|e100_cd_out
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
id|e100_rts
c_func
(paren
id|info
comma
id|arg
op_amp
id|TIOCM_RTS
)paren
suffix:semicolon
id|e100_dtr
c_func
(paren
id|info
comma
id|arg
op_amp
id|TIOCM_DTR
)paren
suffix:semicolon
multiline_comment|/* Handle FEMALE behaviour */
id|e100_ri_out
c_func
(paren
id|info
comma
id|arg
op_amp
id|TIOCM_RI
)paren
suffix:semicolon
id|e100_cd_out
c_func
(paren
id|info
comma
id|arg
op_amp
id|TIOCM_CD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine sends a break character out the serial port.&n; */
macro_line|#if (LINUX_VERSION_CODE &lt; 131394) /* Linux 2.1.66 */
r_static
r_void
DECL|function|send_break
id|send_break
c_func
(paren
r_struct
id|e100_serial
op_star
id|info
comma
r_int
id|duration
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;port
)paren
r_return
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|duration
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Go to manual mode and set the txd pin to 0 */
id|info-&gt;tx_ctrl
op_and_assign
l_int|0x3F
suffix:semicolon
multiline_comment|/* Clear bit 7 (txd) and 6 (tr_enable) */
id|info-&gt;port
(braket
id|REG_TR_CTRL
)braket
op_assign
id|info-&gt;tx_ctrl
suffix:semicolon
multiline_comment|/* wait for &quot;duration&quot; jiffies */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;tx_ctrl
op_or_assign
(paren
l_int|0x80
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Set bit 7 (txd) and 6 (tr_enable) */
id|info-&gt;port
(braket
id|REG_TR_CTRL
)braket
op_assign
id|info-&gt;tx_ctrl
suffix:semicolon
multiline_comment|/* the DMA gets awfully confused if we toggle the tranceiver like this &n;&t; * so we need to reset it &n;&t; */
op_star
id|info-&gt;ocmdadr
op_assign
l_int|4
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_void
DECL|function|rs_break
id|rs_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;port
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Go to manual mode and set the txd pin to 0 */
id|info-&gt;tx_ctrl
op_and_assign
l_int|0x3F
suffix:semicolon
multiline_comment|/* Clear bit 7 (txd) and 6 (tr_enable) */
)brace
r_else
(brace
id|info-&gt;tx_ctrl
op_or_assign
(paren
l_int|0x80
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Set bit 7 (txd) and 6 (tr_enable) */
)brace
id|info-&gt;port
(braket
id|REG_TR_CTRL
)braket
op_assign
id|info-&gt;tx_ctrl
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|rs_ioctl
id|rs_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_ne
id|TIOCGSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERCONFIG
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERGWILD
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERSWILD
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERGSTRUCT
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; 131394) /* Linux 2.1.66 */
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
id|send_break
c_func
(paren
id|info
comma
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 1/4 second */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|send_break
c_func
(paren
id|info
comma
id|arg
ques
c_cond
id|arg
op_star
(paren
id|HZ
op_div
l_int|10
)paren
suffix:colon
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGSOFTCAR
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|put_fs_long
c_func
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
id|arg
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|arg
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_case
id|TIOCMGET
suffix:colon
r_return
id|get_modem_info
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
r_return
id|set_modem_info
c_func
(paren
id|info
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
r_return
id|get_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
r_return
id|set_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSERGETLSR
suffix:colon
multiline_comment|/* Get line status register */
r_return
id|get_lsr_info
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSERGSTRUCT
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_struct
id|e100_serial
op_star
)paren
id|arg
comma
id|info
comma
r_sizeof
(paren
r_struct
id|e100_serial
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_RS485)
r_case
id|TIOCSERSETRS485
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rs485_control
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|e100_enable_rs485
c_func
(paren
id|tty
comma
(paren
r_struct
id|rs485_control
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSERWRRS485
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rs485_write
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|e100_write_rs485
c_func
(paren
id|tty
comma
(paren
r_struct
id|rs485_write
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|rs_set_termios
id|rs_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
r_return
suffix:semicolon
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|rs_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * rs_close()&n; * &n; * This routine is called when the serial port gets closed.  First, we&n; * wait for the last remaining data to be sent.  Then, we unlink its&n; * S structure from the interrupt chain if necessary, and we free&n; * that IRQ if nothing is left in the chain.&n; * ------------------------------------------------------------&n; */
r_static
r_void
DECL|function|rs_close
id|rs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
multiline_comment|/* interrupts are disabled for this entire function */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;[%d] rs_close ttyS%d, count = %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t;&t; * structure will be freed.  Info-&gt;count should always&n;&t;&t; * be one in these conditions.  If it&squot;s greater than&n;&t;&t; * one, we&squot;ve got real problems, since it means the&n;&t;&t; * serial port won&squot;t be shutdown.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;rs_close: bad serial port count; tty-&gt;count is 1, &quot;
l_string|&quot;info-&gt;count is %d&bslash;n&quot;
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|info-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rs_close: bad serial port count for ttyS%d: %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;&t; * Save the termios structure, since this port may have&n;&t; * separate termios for callout and dialin.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|info-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|info-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/*&n;&t; * Now we wait for the transmit buffer to clear; and we notify &n;&t; * the line discipline to only process XON/XOFF characters.&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;closing_wait
op_ne
id|ASYNC_CLOSING_WAIT_NONE
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|info-&gt;closing_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point we stop accepting input.  To do this, we&n;&t; * disable the serial receiver and the DMA receive interrupt.&n;&t; */
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS 
id|e100_disable_serial_data_irq
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_SVINTO_SIM
id|e100_disable_rx
c_func
(paren
id|info
)paren
suffix:semicolon
id|e100_disable_rxdma_irq
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
multiline_comment|/*&n;&t;&t; * Before we drop DTR, make sure the UART transmitter&n;&t;&t; * has completely drained; this is especially&n;&t;&t; * important as we have a transmit FIFO!&n;&t;&t; */
id|rs_wait_until_sent
c_func
(paren
id|tty
comma
id|HZ
)paren
suffix:semicolon
)brace
macro_line|#endif
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;close_delay
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|info-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* port closed */
macro_line|#if defined(CONFIG_RS485)
r_if
c_cond
(paren
id|info-&gt;rs485.enabled
)paren
(brace
id|info-&gt;rs485.enabled
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_RS485_ON_PA)
op_star
id|R_PORT_PA_DATA
op_assign
id|port_pa_data_shadow
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|rs485_pa_bit
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * rs_wait_until_sent() --- wait until the transmitter is empty&n; */
DECL|function|rs_wait_until_sent
r_static
r_void
id|rs_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|orig_jiffies
suffix:semicolon
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
multiline_comment|/*&n;&t; * Check R_DMA_CHx_STATUS bit 0-6=number of available bytes in FIFO&n;&t; * R_DMA_CHx_HWSW bit 31-16=nbr of bytes left in DMA buffer (0=64k)&n;&t; */
id|orig_jiffies
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|info-&gt;xmit.head
op_ne
id|info-&gt;xmit.tail
op_logical_or
multiline_comment|/* More in send queue */
(paren
op_star
id|info-&gt;ostatusadr
op_amp
l_int|0x007f
)paren
)paren
(brace
multiline_comment|/* more in FIFO */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
id|time_after
c_func
(paren
id|jiffies
comma
id|orig_jiffies
op_plus
id|timeout
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * rs_hangup() --- called by tty_hangup() when a hangup is signaled.&n; */
r_void
DECL|function|rs_hangup
id|rs_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
op_assign
(paren
r_struct
id|e100_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|rs_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * rs_open() and friends&n; * ------------------------------------------------------------&n; */
r_static
r_int
DECL|function|block_til_ready
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
comma
id|extra_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is in the middle of being closed, then block&n;&t; * until it&squot;s done, and then try again.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DO_RESTART
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * If this is a callout device, then just make sure the normal&n;&t; * device isn&squot;t being used.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If non-blocking mode is set, or the port is not enabled,&n;&t; * then make the check up front and then exit.&n;&t; */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Block waiting for the carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, info-&gt;count is dropped by one, so that&n;&t; * rs_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready before block: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|extra_count
op_increment
suffix:semicolon
id|info-&gt;count
op_decrement
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|info-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
)paren
(brace
multiline_comment|/* assert RTS and DTR */
id|e100_rts
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
id|e100_dtr
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
macro_line|#ifdef SERIAL_DO_RESTART
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
id|do_clocal
)paren
multiline_comment|/* &amp;&amp; (do_clocal || DCD_IS_ASSERTED) */
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready blocking: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra_count
)paren
id|info-&gt;count
op_increment
suffix:semicolon
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready after blocking: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called whenever a serial port is opened. &n; * It performs the serial-specific initialization for the tty structure.&n; */
r_static
r_int
DECL|function|rs_open
id|rs_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
multiline_comment|/* find which port we want to open */
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
id|line
OL
l_int|0
op_logical_or
id|line
op_ge
id|NR_PORTS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* dont allow opening ports that are not enabled in the HW config */
macro_line|#ifndef CONFIG_ETRAX_SERIAL_PORT1
r_if
c_cond
(paren
id|line
op_eq
l_int|1
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_ETRAX_SERIAL_PORT2
r_if
c_cond
(paren
id|line
op_eq
l_int|2
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_ETRAX_SERIAL_PORT3
r_if
c_cond
(paren
id|line
op_eq
l_int|3
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
multiline_comment|/* find the corresponding e100_serial struct in the table */
id|info
op_assign
id|rs_table
op_plus
id|line
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;[%d] rs_open %s%d, count = %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|tty-&gt;driver.name
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;count
op_increment
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|info-&gt;tty
op_assign
id|tty
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; 0x20100)
id|info-&gt;tty-&gt;low_latency
op_assign
(paren
id|info-&gt;flags
op_amp
id|ASYNC_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
id|page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp_buf
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|tmp_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the port is the middle of closing, bail out now&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DO_RESTART
r_return
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Start up the serial port&n;&t; */
id|retval
op_assign
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|retval
op_assign
id|block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;rs_open returning after block_til_ready with %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;callout_termios
suffix:semicolon
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|info-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|info-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;rs_open ttyS%d successful...&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * /proc fs routines....&n; */
DECL|function|line_info
r_static
r_inline
r_int
id|line_info
c_func
(paren
r_char
op_star
id|buf
comma
r_struct
id|e100_serial
op_star
id|info
)paren
(brace
r_char
id|stat_buf
(braket
l_int|30
)braket
comma
id|control
comma
id|status
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d: uart:E100 port:%lX irq:%d&quot;
comma
id|info-&gt;line
comma
id|info-&gt;port
comma
id|info-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;port
op_logical_or
(paren
id|info-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
)paren
(brace
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|stat_buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|stat_buf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|E100_RTS_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|RTS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E100_CTS_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|CTS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E100_DTR_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|DTR&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E100_DSR_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|DSR&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E100_CD_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|CD&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E100_RI_GET
c_func
(paren
id|info
)paren
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|RI&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; baud:%d&quot;
comma
id|info-&gt;baud
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; tx:%d rx:%d&quot;
comma
id|info-&gt;icount.tx
comma
id|info-&gt;icount.rx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.frame
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; fe:%d&quot;
comma
id|info-&gt;icount.frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.parity
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; pe:%d&quot;
comma
id|info-&gt;icount.parity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.brk
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; brk:%d&quot;
comma
id|info-&gt;icount.brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.overrun
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; oe:%d&quot;
comma
id|info-&gt;icount.overrun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Last thing is the RS-232 status lines&n;&t; */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; %s&bslash;n&quot;
comma
id|stat_buf
op_plus
l_int|1
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|rs_read_proc
r_int
id|rs_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;serinfo:1.0 driver:%s&bslash;n&quot;
comma
id|serial_version
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
op_logical_and
id|len
OL
l_int|4000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|l
op_assign
id|line_info
c_func
(paren
id|page
op_plus
id|len
comma
op_amp
id|rs_table
(braket
id|i
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OG
id|off
op_plus
id|count
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OL
id|off
)paren
(brace
id|begin
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|off
op_ge
id|len
op_plus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
(paren
id|off
op_minus
id|begin
)paren
suffix:semicolon
r_return
(paren
(paren
id|count
OL
id|begin
op_plus
id|len
op_minus
id|off
)paren
ques
c_cond
id|count
suffix:colon
id|begin
op_plus
id|len
op_minus
id|off
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, routines used to initialize the serial driver. */
r_static
r_void
DECL|function|show_serial_version
id|show_serial_version
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ETRAX 100LX serial-driver %s, (c) 2000 Axis Communications AB&bslash;r&bslash;n&quot;
comma
id|serial_version
)paren
suffix:semicolon
)brace
multiline_comment|/* rs_init inits the driver at boot (using the module_init chain) */
r_static
r_int
id|__init
DECL|function|rs_init
id|rs_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|e100_serial
op_star
id|info
suffix:semicolon
id|show_serial_version
c_func
(paren
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|SERIAL_BH
comma
id|do_serial_bh
)paren
suffix:semicolon
multiline_comment|/* Setup the timed flush handler system */
id|init_timer
c_func
(paren
op_amp
id|flush_timer
)paren
suffix:semicolon
id|flush_timer.function
op_assign
id|timed_flush_handler
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|flush_timer
comma
id|jiffies
op_plus
id|MAX_FLUSH_TIME
)paren
suffix:semicolon
multiline_comment|/* Initialize the tty_driver structure */
id|memset
c_func
(paren
op_amp
id|serial_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|serial_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; 0x20100)
id|serial_driver.driver_name
op_assign
l_string|&quot;serial&quot;
suffix:semicolon
macro_line|#endif
id|serial_driver.name
op_assign
l_string|&quot;ttyS&quot;
suffix:semicolon
id|serial_driver.major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|serial_driver.minor_start
op_assign
l_int|64
suffix:semicolon
id|serial_driver.num
op_assign
id|NR_PORTS
suffix:semicolon
multiline_comment|/* etrax100 has 4 serial ports */
id|serial_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|serial_driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|serial_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|serial_driver.init_termios.c_cflag
op_assign
id|B115200
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
multiline_comment|/* is normally B9600 default... */
id|serial_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_NO_DEVFS
suffix:semicolon
id|serial_driver.refcount
op_assign
op_amp
id|serial_refcount
suffix:semicolon
id|serial_driver.table
op_assign
id|serial_table
suffix:semicolon
id|serial_driver.termios
op_assign
id|serial_termios
suffix:semicolon
id|serial_driver.termios_locked
op_assign
id|serial_termios_locked
suffix:semicolon
id|serial_driver.open
op_assign
id|rs_open
suffix:semicolon
id|serial_driver.close
op_assign
id|rs_close
suffix:semicolon
id|serial_driver.write
op_assign
id|rs_write
suffix:semicolon
multiline_comment|/* should we have an rs_put_char as well here ? */
id|serial_driver.flush_chars
op_assign
id|rs_flush_chars
suffix:semicolon
id|serial_driver.write_room
op_assign
id|rs_write_room
suffix:semicolon
id|serial_driver.chars_in_buffer
op_assign
id|rs_chars_in_buffer
suffix:semicolon
id|serial_driver.flush_buffer
op_assign
id|rs_flush_buffer
suffix:semicolon
id|serial_driver.ioctl
op_assign
id|rs_ioctl
suffix:semicolon
id|serial_driver.throttle
op_assign
id|rs_throttle
suffix:semicolon
id|serial_driver.unthrottle
op_assign
id|rs_unthrottle
suffix:semicolon
id|serial_driver.set_termios
op_assign
id|rs_set_termios
suffix:semicolon
id|serial_driver.stop
op_assign
id|rs_stop
suffix:semicolon
id|serial_driver.start
op_assign
id|rs_start
suffix:semicolon
id|serial_driver.hangup
op_assign
id|rs_hangup
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 131394) /* Linux 2.1.66 */
id|serial_driver.break_ctl
op_assign
id|rs_break
suffix:semicolon
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt;= 131343)
id|serial_driver.send_xchar
op_assign
id|rs_send_xchar
suffix:semicolon
id|serial_driver.wait_until_sent
op_assign
id|rs_wait_until_sent
suffix:semicolon
id|serial_driver.read_proc
op_assign
id|rs_read_proc
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * The callout device is just like normal device except for&n;&t; * major number and the subtype code.&n;&t; */
id|callout_driver
op_assign
id|serial_driver
suffix:semicolon
id|callout_driver.name
op_assign
l_string|&quot;cua&quot;
suffix:semicolon
id|callout_driver.major
op_assign
id|TTYAUX_MAJOR
suffix:semicolon
id|callout_driver.subtype
op_assign
id|SERIAL_TYPE_CALLOUT
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 131343)
id|callout_driver.read_proc
op_assign
l_int|0
suffix:semicolon
id|callout_driver.proc_entry
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|serial_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|callout_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register callout driver&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* do some initializing for the separate ports */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|info
op_assign
id|rs_table
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
comma
id|info
op_increment
)paren
(brace
id|info-&gt;line
op_assign
id|i
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|info-&gt;type
op_assign
id|PORT_ETRAX
suffix:semicolon
id|info-&gt;tr_running
op_assign
l_int|0
suffix:semicolon
id|info-&gt;fifo_magic
op_assign
l_int|0
suffix:semicolon
id|info-&gt;fifo_didmagic
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|info-&gt;close_delay
op_assign
l_int|5
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|info-&gt;closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;blocked_open
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tqueue.routine
op_assign
id|do_softint
suffix:semicolon
id|info-&gt;tqueue.data
op_assign
id|info
suffix:semicolon
id|info-&gt;callout_termios
op_assign
id|callout_driver.init_termios
suffix:semicolon
id|info-&gt;normal_termios
op_assign
id|serial_driver.init_termios
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|info-&gt;xmit.buf
op_assign
l_int|0
suffix:semicolon
id|info-&gt;xmit.tail
op_assign
id|info-&gt;xmit.head
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s%d at 0x%x is a builtin UART with DMA&bslash;n&quot;
comma
id|serial_driver.name
comma
id|info-&gt;line
comma
(paren
r_int
r_int
)paren
id|info-&gt;port
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* Not needed in simulator.  May only complicate stuff. */
multiline_comment|/* hook the irq&squot;s for DMA channel 6 and 7, serial output and input, and some more... */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|22
comma
id|tr_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial 0 dma tr&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq22&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|23
comma
id|rec_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial 0 dma rec&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq23&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_HANDLE_EARLY_ERRORS
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|8
comma
id|ser_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial &quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq8&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_SERIAL_PORT1
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|24
comma
id|tr_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial 1 dma tr&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq24&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|25
comma
id|rec_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial 1 dma rec&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq25&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_SERIAL_PORT2
multiline_comment|/* DMA Shared with par0 (and SCSI0 and ATA) */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|18
comma
id|tr_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;serial 2 dma tr&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq18&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|19
comma
id|rec_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;serial 2 dma rec&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq19&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_SERIAL_PORT3
multiline_comment|/* DMA Shared with par1 (and SCSI1 and Extern DMA 0) */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|20
comma
id|tr_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;serial 3 dma tr&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq20&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|21
comma
id|rec_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;serial 3 dma rec&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;irq21&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST
multiline_comment|/* TODO: a timeout_interrupt needs to be written that calls timeout_handler */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|TIMER1_IRQ_NBR
comma
id|timeout_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;fast serial dma timeout&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;err: timer1 irq&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* CONFIG_SVINTO_SIM */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this makes sure that rs_init is called during kernel boot */
DECL|variable|rs_init
id|module_init
c_func
(paren
id|rs_init
)paren
suffix:semicolon
multiline_comment|/*&n; * register_serial and unregister_serial allows for serial ports to be&n; * configured at run-time, to support PCMCIA modems.&n; */
r_int
DECL|function|register_serial
id|register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|unregister_serial
r_void
id|unregister_serial
c_func
(paren
r_int
id|line
)paren
(brace
)brace
eof
