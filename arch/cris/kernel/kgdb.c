multiline_comment|/*!**************************************************************************&n;*!&n;*! FILE NAME  : kgdb.c&n;*!&n;*! DESCRIPTION: Implementation of the gdb stub with respect to ETRAX 100.&n;*!              It is a mix of arch/m68k/kernel/kgdb.c and cris_stub.c.&n;*!&n;*!---------------------------------------------------------------------------&n;*! HISTORY&n;*!&n;*! DATE         NAME            CHANGES&n;*! ----         ----            -------&n;*! Apr 26 1999  Hendrik Ruijter Initial version.&n;*! May  6 1999  Hendrik Ruijter Removed call to strlen in libc and removed&n;*!                              struct assignment as it generates calls to&n;*!                              memcpy in libc.&n;*! Jun 17 1999  Hendrik Ruijter Added gdb 4.18 support. &squot;X&squot;, &squot;qC&squot; and &squot;qL&squot;.&n;*! Jul 21 1999  Bjorn Wesen     eLinux port&n;*!&n;*! $Log: kgdb.c,v $&n;*! Revision 1.6  2001/10/09 13:10:03  matsfg&n;*! Added $ on registers and removed some underscores&n;*!&n;*! Revision 1.5  2001/04/17 13:58:39  orjanf&n;*! * Renamed CONFIG_KGDB to CONFIG_ETRAX_KGDB.&n;*!&n;*! Revision 1.4  2001/02/23 13:45:19  bjornw&n;*! config.h check&n;*!&n;*! Revision 1.3  2001/01/31 18:08:23  orjanf&n;*! Removed kgdb_handle_breakpoint from being the break 8 handler.&n;*!&n;*! Revision 1.2  2001/01/12 14:22:25  orjanf&n;*! Updated kernel debugging support to work with ETRAX 100LX.&n;*!&n;*! Revision 1.1  2000/07/10 16:25:21  bjornw&n;*! Initial revision&n;*!&n;*! Revision 1.1.1.1  1999/12/03 14:57:31  bjornw&n;*! * Initial version of arch/cris, the latest CRIS architecture with an MMU.&n;*!   Mostly copied from arch/etrax100 with appropriate renames of files.&n;*!   The mm/ subdir is copied from arch/i386.&n;*!   This does not compile yet at all.&n;*!&n;*!&n;*! Revision 1.4  1999/07/22 17:25:25  bjornw&n;*! Dont wait for + in putpacket if we havent hit the initial breakpoint yet. Added a kgdb_init function which sets up the break and irq vectors.&n;*!&n;*! Revision 1.3  1999/07/21 19:51:18  bjornw&n;*! Check if the interrupting char is a ctrl-C, ignore otherwise.&n;*!&n;*! Revision 1.2  1999/07/21 18:09:39  bjornw&n;*! Ported to eLinux architecture, and added some kgdb documentation.&n;*!&n;*!&n;*!---------------------------------------------------------------------------&n;*!&n;*! $Id: kgdb.c,v 1.6 2001/10/09 13:10:03 matsfg Exp $&n;*!&n;*! (C) Copyright 1999, Axis Communications AB, LUND, SWEDEN&n;*!&n;*!**************************************************************************/
multiline_comment|/* @(#) cris_stub.c 1.3 06/17/99 */
multiline_comment|/*&n; *  kgdb usage notes:&n; *  -----------------&n; *&n; * If you select CONFIG_ETRAX_KGDB in the configuration, the kernel will be &n; * built with different gcc flags: &quot;-g&quot; is added to get debug infos, and&n; * &quot;-fomit-frame-pointer&quot; is omitted to make debugging easier. Since the&n; * resulting kernel will be quite big (approx. &gt; 7 MB), it will be stripped&n; * before compresion. Such a kernel will behave just as usually, except if&n; * given a &quot;debug=&lt;device&gt;&quot; command line option. (Only serial devices are&n; * allowed for &lt;device&gt;, i.e. no printers or the like; possible values are&n; * machine depedend and are the same as for the usual debug device, the one&n; * for logging kernel messages.) If that option is given and the device can be&n; * initialized, the kernel will connect to the remote gdb in trap_init(). The&n; * serial parameters are fixed to 8N1 and 115200 bps, for easyness of&n; * implementation.&n; *&n; * To start a debugging session, start that gdb with the debugging kernel&n; * image (the one with the symbols, vmlinux.debug) named on the command line.&n; * This file will be used by gdb to get symbol and debugging infos about the&n; * kernel. Next, select remote debug mode by&n; *    target remote &lt;device&gt;&n; * where &lt;device&gt; is the name of the serial device over which the debugged&n; * machine is connected. Maybe you have to adjust the baud rate by&n; *    set remotebaud &lt;rate&gt;&n; * or also other parameters with stty:&n; *    shell stty ... &lt;/dev/...&n; * If the kernel to debug has already booted, it waited for gdb and now&n; * connects, and you&squot;ll see a breakpoint being reported. If the kernel isn&squot;t&n; * running yet, start it now. The order of gdb and the kernel doesn&squot;t matter.&n; * Another thing worth knowing about in the getting-started phase is how to&n; * debug the remote protocol itself. This is activated with&n; *    set remotedebug 1&n; * gdb will then print out each packet sent or received. You&squot;ll also get some&n; * messages about the gdb stub on the console of the debugged machine.&n; *&n; * If all that works, you can use lots of the usual debugging techniques on&n; * the kernel, e.g. inspecting and changing variables/memory, setting&n; * breakpoints, single stepping and so on. It&squot;s also possible to interrupt the&n; * debugged kernel by pressing C-c in gdb. Have fun! :-)&n; *&n; * The gdb stub is entered (and thus the remote gdb gets control) in the&n; * following situations:&n; *&n; *  - If breakpoint() is called. This is just after kgdb initialization, or if&n; *    a breakpoint() call has been put somewhere into the kernel source.&n; *    (Breakpoints can of course also be set the usual way in gdb.)&n; *    In eLinux, we call breakpoint() in init/main.c after IRQ initialization.&n; *&n; *  - If there is a kernel exception, i.e. bad_super_trap() or die_if_kernel()&n; *    are entered. All the CPU exceptions are mapped to (more or less..., see&n; *    the hard_trap_info array below) appropriate signal, which are reported&n; *    to gdb. die_if_kernel() is usually called after some kind of access&n; *    error and thus is reported as SIGSEGV.&n; *&n; *  - When panic() is called. This is reported as SIGABRT.&n; *&n; *  - If C-c is received over the serial line, which is treated as&n; *    SIGINT.&n; *&n; * Of course, all these signals are just faked for gdb, since there is no&n; * signal concept as such for the kernel. It also isn&squot;t possible --obviously--&n; * to set signal handlers from inside gdb, or restart the kernel with a&n; * signal.&n; *&n; * Current limitations:&n; *&n; *  - While the kernel is stopped, interrupts are disabled for safety reasons&n; *    (i.e., variables not changing magically or the like). But this also&n; *    means that the clock isn&squot;t running anymore, and that interrupts from the&n; *    hardware may get lost/not be served in time. This can cause some device&n; *    errors...&n; *&n; *  - When single-stepping, only one instruction of the current thread is&n; *    executed, but interrupts are allowed for that time and will be serviced&n; *    if pending. Be prepared for that.&n; *&n; *  - All debugging happens in kernel virtual address space. There&squot;s no way to&n; *    access physical memory not mapped in kernel space, or to access user&n; *    space. A way to work around this is using get_user_long &amp; Co. in gdb&n; *    expressions, but only for the current process.&n; *&n; *  - Interrupting the kernel only works if interrupts are currently allowed,&n; *    and the interrupt of the serial line isn&squot;t blocked by some other means&n; *    (IPL too high, disabled, ...)&n; *&n; *  - The gdb stub is currently not reentrant, i.e. errors that happen therein&n; *    (e.g. accesing invalid memory) may not be caught correctly. This could&n; *    be removed in future by introducing a stack of struct registers.&n; *&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to kgdb_init() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint(). &n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *    bBB..BB&t;    Set baud rate to BB..BB&t;&t;   OK or BNN, then sets&n; *&t;&t;&t;&t;&t;&t;&t;   baud rate&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/svinto.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
DECL|variable|kgdb_started
r_static
r_int
id|kgdb_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/********************************* Register image ****************************/
multiline_comment|/* Use the order of registers as defined in &quot;AXIS ETRAX CRIS Programmer&squot;s&n;   Reference&quot;, p. 1-1, with the additional register definitions of the&n;   ETRAX 100LX in cris-opc.h.&n;   There are 16 general 32-bit registers, R0-R15, where R14 is the stack&n;   pointer, SP, and R15 is the program counter, PC.&n;   There are 16 special registers, P0-P15, where three of the unimplemented&n;   registers, P0, P4 and P8, are reserved as zero-registers. A read from&n;   any of these registers returns zero and a write has no effect. */
r_typedef
DECL|struct|register_image
r_struct
id|register_image
(brace
multiline_comment|/* Offset */
DECL|member|r0
r_int
r_int
id|r0
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|r1
r_int
r_int
id|r1
suffix:semicolon
multiline_comment|/* 0x04 */
DECL|member|r2
r_int
r_int
id|r2
suffix:semicolon
multiline_comment|/* 0x08 */
DECL|member|r3
r_int
r_int
id|r3
suffix:semicolon
multiline_comment|/* 0x0C */
DECL|member|r4
r_int
r_int
id|r4
suffix:semicolon
multiline_comment|/* 0x10 */
DECL|member|r5
r_int
r_int
id|r5
suffix:semicolon
multiline_comment|/* 0x14 */
DECL|member|r6
r_int
r_int
id|r6
suffix:semicolon
multiline_comment|/* 0x18 */
DECL|member|r7
r_int
r_int
id|r7
suffix:semicolon
multiline_comment|/* 0x1C */
DECL|member|r8
r_int
r_int
id|r8
suffix:semicolon
multiline_comment|/* 0x20 Frame pointer */
DECL|member|r9
r_int
r_int
id|r9
suffix:semicolon
multiline_comment|/* 0x24 */
DECL|member|r10
r_int
r_int
id|r10
suffix:semicolon
multiline_comment|/* 0x28 */
DECL|member|r11
r_int
r_int
id|r11
suffix:semicolon
multiline_comment|/* 0x2C */
DECL|member|r12
r_int
r_int
id|r12
suffix:semicolon
multiline_comment|/* 0x30 */
DECL|member|r13
r_int
r_int
id|r13
suffix:semicolon
multiline_comment|/* 0x34 */
DECL|member|sp
r_int
r_int
id|sp
suffix:semicolon
multiline_comment|/* 0x38 Stack pointer */
DECL|member|pc
r_int
r_int
id|pc
suffix:semicolon
multiline_comment|/* 0x3C Program counter */
DECL|member|p0
r_int
r_char
id|p0
suffix:semicolon
multiline_comment|/* 0x40 8-bit zero-register */
DECL|member|vr
r_int
r_char
id|vr
suffix:semicolon
multiline_comment|/* 0x41 Version register */
DECL|member|p4
r_int
r_int
id|p4
suffix:semicolon
multiline_comment|/* 0x42 16-bit zero-register */
DECL|member|ccr
r_int
r_int
id|ccr
suffix:semicolon
multiline_comment|/* 0x44 Condition code register */
DECL|member|mof
r_int
r_int
id|mof
suffix:semicolon
multiline_comment|/* 0x46 Multiply overflow register */
DECL|member|p8
r_int
r_int
id|p8
suffix:semicolon
multiline_comment|/* 0x4A 32-bit zero-register */
DECL|member|ibr
r_int
r_int
id|ibr
suffix:semicolon
multiline_comment|/* 0x4E Interrupt base register */
DECL|member|irp
r_int
r_int
id|irp
suffix:semicolon
multiline_comment|/* 0x52 Interrupt return pointer */
DECL|member|srp
r_int
r_int
id|srp
suffix:semicolon
multiline_comment|/* 0x56 Subroutine return pointer */
DECL|member|bar
r_int
r_int
id|bar
suffix:semicolon
multiline_comment|/* 0x5A Breakpoint address register */
DECL|member|dccr
r_int
r_int
id|dccr
suffix:semicolon
multiline_comment|/* 0x5E Double condition code register */
DECL|member|brp
r_int
r_int
id|brp
suffix:semicolon
multiline_comment|/* 0x62 Breakpoint return pointer (pc in caller) */
DECL|member|usp
r_int
r_int
id|usp
suffix:semicolon
multiline_comment|/* 0x66 User mode stack pointer */
DECL|typedef|registers
)brace
id|registers
suffix:semicolon
multiline_comment|/************** Prototypes for local library functions ***********************/
multiline_comment|/* Copy of strcpy from libc. */
r_static
r_char
op_star
id|gdb_cris_strcpy
(paren
r_char
op_star
id|s1
comma
r_const
r_char
op_star
id|s2
)paren
suffix:semicolon
multiline_comment|/* Copy of strlen from libc. */
r_static
r_int
id|gdb_cris_strlen
(paren
r_const
r_char
op_star
id|s
)paren
suffix:semicolon
multiline_comment|/* Copy of memchr from libc. */
r_static
r_void
op_star
id|gdb_cris_memchr
(paren
r_const
r_void
op_star
id|s
comma
r_int
id|c
comma
r_int
id|n
)paren
suffix:semicolon
multiline_comment|/* Copy of strtol from libc. Does only support base 16. */
r_static
r_int
id|gdb_cris_strtol
(paren
r_const
r_char
op_star
id|s
comma
r_char
op_star
op_star
id|endptr
comma
r_int
id|base
)paren
suffix:semicolon
multiline_comment|/********************** Prototypes for local functions. **********************/
multiline_comment|/* Copy the content of a register image into another. The size n is&n;   the size of the register image. Due to struct assignment generation of&n;   memcpy in libc. */
r_static
r_void
id|copy_registers
(paren
id|registers
op_star
id|dptr
comma
id|registers
op_star
id|sptr
comma
r_int
id|n
)paren
suffix:semicolon
multiline_comment|/* Copy the stored registers from the stack. Put the register contents&n;   of thread thread_id in the struct reg. */
r_static
r_void
id|copy_registers_from_stack
(paren
r_int
id|thread_id
comma
id|registers
op_star
id|reg
)paren
suffix:semicolon
multiline_comment|/* Copy the registers to the stack. Put the register contents of thread&n;   thread_id from struct reg to the stack. */
r_static
r_void
id|copy_registers_to_stack
(paren
r_int
id|thread_id
comma
id|registers
op_star
id|reg
)paren
suffix:semicolon
multiline_comment|/* Write a value to a specified register regno in the register image&n;   of the current thread. */
r_static
r_int
id|write_register
(paren
r_int
id|regno
comma
r_char
op_star
id|val
)paren
suffix:semicolon
multiline_comment|/* Write a value to a specified register in the stack of a thread other&n;   than the current thread. */
r_static
id|write_stack_register
(paren
r_int
id|thread_id
comma
r_int
id|regno
comma
r_char
op_star
id|valptr
)paren
suffix:semicolon
multiline_comment|/* Read a value from a specified register in the register image. Returns the&n;   status of the read operation. The register value is returned in valptr. */
r_static
r_int
id|read_register
(paren
r_char
id|regno
comma
r_int
r_int
op_star
id|valptr
)paren
suffix:semicolon
multiline_comment|/* Serial port, reads one character. ETRAX 100 specific. from debugport.c */
r_int
id|getDebugChar
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Serial port, writes one character. ETRAX 100 specific. from debugport.c */
r_void
id|putDebugChar
(paren
r_int
id|val
)paren
suffix:semicolon
r_void
id|enableDebugIRQ
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Returns the character equivalent of a nibble, bit 7, 6, 5, and 4 of a byte,&n;   represented by int x. */
r_static
r_char
id|highhex
(paren
r_int
id|x
)paren
suffix:semicolon
multiline_comment|/* Returns the character equivalent of a nibble, bit 3, 2, 1, and 0 of a byte,&n;   represented by int x. */
r_static
r_char
id|lowhex
(paren
r_int
id|x
)paren
suffix:semicolon
multiline_comment|/* Returns the integer equivalent of a hexadecimal character. */
r_static
r_int
id|hex
(paren
r_char
id|ch
)paren
suffix:semicolon
multiline_comment|/* Convert the memory, pointed to by mem into hexadecimal representation.&n;   Put the result in buf, and return a pointer to the last character&n;   in buf (null). */
r_static
r_char
op_star
id|mem2hex
(paren
r_char
op_star
id|buf
comma
r_int
r_char
op_star
id|mem
comma
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/* Convert the array, in hexadecimal representation, pointed to by buf into&n;   binary representation. Put the result in mem, and return a pointer to&n;   the character after the last byte written. */
r_static
r_int
r_char
op_star
id|hex2mem
(paren
r_int
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/* Put the content of the array, in binary representation, pointed to by buf&n;   into memory pointed to by mem, and return a pointer to&n;   the character after the last byte written. */
r_static
r_int
r_char
op_star
id|bin2mem
(paren
r_int
r_char
op_star
id|mem
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/* Await the sequence $&lt;data&gt;#&lt;checksum&gt; and store &lt;data&gt; in the array buffer&n;   returned. */
r_static
r_void
id|getpacket
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/* Send $&lt;data&gt;#&lt;checksum&gt; from the &lt;data&gt; in the array buffer. */
r_static
r_void
id|putpacket
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/* Build and send a response packet in order to inform the host the&n;   stub is stopped. */
r_static
r_void
id|stub_is_stopped
(paren
r_int
id|sigval
)paren
suffix:semicolon
multiline_comment|/* All expected commands are sent from remote.c. Send a response according&n;   to the description in remote.c. */
r_static
r_void
id|handle_exception
(paren
r_int
id|sigval
)paren
suffix:semicolon
multiline_comment|/* Performs a complete re-start from scratch. ETRAX specific. */
r_static
r_void
id|kill_restart
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/******************** Prototypes for global functions. ***********************/
multiline_comment|/* The string str is prepended with the GDB printout token and sent. */
r_void
id|putDebugString
(paren
r_const
r_int
r_char
op_star
id|str
comma
r_int
id|length
)paren
suffix:semicolon
multiline_comment|/* used by etrax100ser.c */
multiline_comment|/* The hook for both static (compiled) and dynamic breakpoints set by GDB.&n;   ETRAX 100 specific. */
r_void
id|handle_breakpoint
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* used by irq.c */
multiline_comment|/* The hook for an interrupt generated by GDB. ETRAX 100 specific. */
r_void
id|handle_interrupt
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* used by irq.c */
multiline_comment|/* A static breakpoint to be used at startup. */
r_void
id|breakpoint
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* called by init/main.c */
multiline_comment|/* From osys_int.c, executing_task contains the number of the current&n;   executing task in osys. Does not know of object-oriented threads. */
r_extern
r_int
r_char
id|executing_task
suffix:semicolon
multiline_comment|/* The number of characters used for a 64 bit thread identifier. */
DECL|macro|HEXCHARS_IN_THREAD_ID
mdefine_line|#define HEXCHARS_IN_THREAD_ID 16
multiline_comment|/* Avoid warning as the internal_stack is not used in the C-code. */
DECL|macro|USEDVAR
mdefine_line|#define USEDVAR(name)    { if (name) { ; } }
DECL|macro|USEDFUN
mdefine_line|#define USEDFUN(name) { void (*pf)(void) = (void *)name; USEDVAR(pf) }
multiline_comment|/********************************** Packet I/O ******************************/
multiline_comment|/* BUFMAX defines the maximum number of characters in&n;   inbound/outbound buffers */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 512
multiline_comment|/* Run-length encoding maximum length. Send 64 at most. */
DECL|macro|RUNLENMAX
mdefine_line|#define RUNLENMAX 64
multiline_comment|/* Definition of all valid hexadecimal characters */
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
multiline_comment|/* The inbound/outbound buffers used in packet I/O */
DECL|variable|remcomInBuffer
r_static
r_char
id|remcomInBuffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|remcomOutBuffer
r_static
r_char
id|remcomOutBuffer
(braket
id|BUFMAX
)braket
suffix:semicolon
multiline_comment|/* Error and warning messages. */
DECL|enum|error_type
r_enum
id|error_type
(brace
DECL|enumerator|SUCCESS
DECL|enumerator|E01
DECL|enumerator|E02
DECL|enumerator|E03
DECL|enumerator|E04
DECL|enumerator|E05
DECL|enumerator|E06
DECL|enumerator|E07
id|SUCCESS
comma
id|E01
comma
id|E02
comma
id|E03
comma
id|E04
comma
id|E05
comma
id|E06
comma
id|E07
)brace
suffix:semicolon
DECL|variable|error_message
r_static
r_char
op_star
id|error_message
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;E01 Set current or general thread - H[c,g] - internal error.&quot;
comma
l_string|&quot;E02 Change register content - P - cannot change read-only register.&quot;
comma
l_string|&quot;E03 Thread is not alive.&quot;
comma
multiline_comment|/* T, not used. */
l_string|&quot;E04 The command is not supported - [s,C,S,!,R,d,r] - internal error.&quot;
comma
l_string|&quot;E05 Change register content - P - the register is not implemented..&quot;
comma
l_string|&quot;E06 Change memory content - M - internal error.&quot;
comma
l_string|&quot;E07 Change register content - P - the register is not stored on the stack&quot;
)brace
suffix:semicolon
multiline_comment|/********************************* Register image ****************************/
multiline_comment|/* Use the order of registers as defined in &quot;AXIS ETRAX CRIS Programmer&squot;s&n;   Reference&quot;, p. 1-1, with the additional register definitions of the&n;   ETRAX 100LX in cris-opc.h.&n;   There are 16 general 32-bit registers, R0-R15, where R14 is the stack&n;   pointer, SP, and R15 is the program counter, PC.&n;   There are 16 special registers, P0-P15, where three of the unimplemented&n;   registers, P0, P4 and P8, are reserved as zero-registers. A read from&n;   any of these registers returns zero and a write has no effect. */
DECL|enum|register_name
r_enum
id|register_name
(brace
DECL|enumerator|R0
DECL|enumerator|R1
DECL|enumerator|R2
DECL|enumerator|R3
id|R0
comma
id|R1
comma
id|R2
comma
id|R3
comma
DECL|enumerator|R4
DECL|enumerator|R5
DECL|enumerator|R6
DECL|enumerator|R7
id|R4
comma
id|R5
comma
id|R6
comma
id|R7
comma
DECL|enumerator|R8
DECL|enumerator|R9
DECL|enumerator|R10
DECL|enumerator|R11
id|R8
comma
id|R9
comma
id|R10
comma
id|R11
comma
DECL|enumerator|R12
DECL|enumerator|R13
DECL|enumerator|SP
DECL|enumerator|PC
id|R12
comma
id|R13
comma
id|SP
comma
id|PC
comma
DECL|enumerator|P0
DECL|enumerator|VR
DECL|enumerator|P2
DECL|enumerator|P3
id|P0
comma
id|VR
comma
id|P2
comma
id|P3
comma
DECL|enumerator|P4
DECL|enumerator|CCR
DECL|enumerator|P6
DECL|enumerator|MOF
id|P4
comma
id|CCR
comma
id|P6
comma
id|MOF
comma
DECL|enumerator|P8
DECL|enumerator|IBR
DECL|enumerator|IRP
DECL|enumerator|SRP
id|P8
comma
id|IBR
comma
id|IRP
comma
id|SRP
comma
DECL|enumerator|BAR
DECL|enumerator|DCCR
DECL|enumerator|BRP
DECL|enumerator|USP
id|BAR
comma
id|DCCR
comma
id|BRP
comma
id|USP
)brace
suffix:semicolon
multiline_comment|/* The register sizes of the registers in register_name. An unimplemented register&n;   is designated by size 0 in this array. */
DECL|variable|register_size
r_static
r_int
id|register_size
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|2
comma
l_int|0
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/* Contains the register image of the executing thread in the assembler&n;   part of the code in order to avoid horrible addressing modes. */
DECL|variable|reg
r_static
id|registers
id|reg
suffix:semicolon
multiline_comment|/* FIXME: Should this be used? Delete otherwise. */
multiline_comment|/* Contains the assumed consistency state of the register image. Uses the&n;   enum error_type for state information. */
DECL|variable|consistency_status
r_static
r_int
id|consistency_status
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/********************************** Handle exceptions ************************/
multiline_comment|/* The variable reg contains the register image associated with the&n;   current_thread_c variable. It is a complete register image created at&n;   entry. The reg_g contains a register image of a task where the general&n;   registers are taken from the stack and all special registers are taken&n;   from the executing task. It is associated with current_thread_g and used&n;   in order to provide access mainly for &squot;g&squot;, &squot;G&squot; and &squot;P&squot;.&n;*/
multiline_comment|/* Need two task id pointers in order to handle Hct and Hgt commands. */
DECL|variable|current_thread_c
r_static
r_int
id|current_thread_c
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_thread_g
r_static
r_int
id|current_thread_g
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Need two register images in order to handle Hct and Hgt commands. The&n;   variable reg_g is in addition to reg above. */
DECL|variable|reg_g
r_static
id|registers
id|reg_g
suffix:semicolon
multiline_comment|/********************************** Breakpoint *******************************/
multiline_comment|/* Use an internal stack in the breakpoint and interrupt response routines */
DECL|macro|INTERNAL_STACK_SIZE
mdefine_line|#define INTERNAL_STACK_SIZE 1024
DECL|variable|internal_stack
r_static
r_char
id|internal_stack
(braket
id|INTERNAL_STACK_SIZE
)braket
suffix:semicolon
multiline_comment|/* Due to the breakpoint return pointer, a state variable is needed to keep&n;   track of whether it is a static (compiled) or dynamic (gdb-invoked)&n;   breakpoint to be handled. A static breakpoint uses the content of register&n;   BRP as it is whereas a dynamic breakpoint requires subtraction with 2&n;   in order to execute the instruction. The first breakpoint is static. */
DECL|variable|is_dyn_brkp
r_static
r_int
r_char
id|is_dyn_brkp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/********************************* String library ****************************/
multiline_comment|/* Single-step over library functions creates trap loops. */
multiline_comment|/* Copy char s2[] to s1[]. */
r_static
r_char
op_star
DECL|function|gdb_cris_strcpy
id|gdb_cris_strcpy
(paren
r_char
op_star
id|s1
comma
r_const
r_char
op_star
id|s2
)paren
(brace
r_char
op_star
id|s
op_assign
id|s1
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|s1
suffix:semicolon
(paren
op_star
id|s
op_increment
op_assign
op_star
id|s2
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)paren
suffix:semicolon
r_return
(paren
id|s1
)paren
suffix:semicolon
)brace
multiline_comment|/* Find length of s[]. */
r_static
r_int
DECL|function|gdb_cris_strlen
id|gdb_cris_strlen
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_const
r_char
op_star
id|sc
suffix:semicolon
r_for
c_loop
(paren
id|sc
op_assign
id|s
suffix:semicolon
op_star
id|sc
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|sc
op_increment
)paren
suffix:semicolon
r_return
(paren
id|sc
op_minus
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* Find first occurrence of c in s[n]. */
r_static
r_void
op_star
DECL|function|gdb_cris_memchr
id|gdb_cris_memchr
(paren
r_const
r_void
op_star
id|s
comma
r_int
id|c
comma
r_int
id|n
)paren
(brace
r_const
r_int
r_char
id|uc
op_assign
id|c
suffix:semicolon
r_const
r_int
r_char
op_star
id|su
suffix:semicolon
r_for
c_loop
(paren
id|su
op_assign
id|s
suffix:semicolon
l_int|0
OL
id|n
suffix:semicolon
op_increment
id|su
comma
op_decrement
id|n
)paren
r_if
c_cond
(paren
op_star
id|su
op_eq
id|uc
)paren
r_return
(paren
(paren
r_void
op_star
)paren
id|su
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/******************************* Standard library ****************************/
multiline_comment|/* Single-step over library functions creates trap loops. */
multiline_comment|/* Convert string to long. */
r_static
r_int
DECL|function|gdb_cris_strtol
id|gdb_cris_strtol
(paren
r_const
r_char
op_star
id|s
comma
r_char
op_star
op_star
id|endptr
comma
r_int
id|base
)paren
(brace
r_char
op_star
id|s1
suffix:semicolon
r_char
op_star
id|sd
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|s1
op_assign
(paren
r_char
op_star
)paren
id|s
suffix:semicolon
(paren
id|sd
op_assign
id|gdb_cris_memchr
c_func
(paren
id|hexchars
comma
op_star
id|s1
comma
id|base
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
op_increment
id|s1
)paren
id|x
op_assign
id|x
op_star
id|base
op_plus
(paren
id|sd
op_minus
id|hexchars
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endptr
)paren
(brace
multiline_comment|/* Unconverted suffix is stored in endptr unless endptr is NULL. */
op_star
id|endptr
op_assign
id|s1
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
r_int
DECL|function|double_this
id|double_this
c_func
(paren
r_int
id|x
)paren
(brace
r_return
l_int|2
op_star
id|x
suffix:semicolon
)brace
multiline_comment|/********************************* Register image ****************************/
multiline_comment|/* Copy the content of a register image into another. The size n is&n;   the size of the register image. Due to struct assignment generation of&n;   memcpy in libc. */
r_static
r_void
DECL|function|copy_registers
id|copy_registers
(paren
id|registers
op_star
id|dptr
comma
id|registers
op_star
id|sptr
comma
r_int
id|n
)paren
(brace
r_int
r_char
op_star
id|dreg
suffix:semicolon
r_int
r_char
op_star
id|sreg
suffix:semicolon
r_for
c_loop
(paren
id|dreg
op_assign
(paren
r_int
r_char
op_star
)paren
id|dptr
comma
id|sreg
op_assign
(paren
r_int
r_char
op_star
)paren
id|sptr
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
id|n
op_decrement
)paren
op_star
id|dreg
op_increment
op_assign
op_star
id|sreg
op_increment
suffix:semicolon
)brace
macro_line|#ifdef PROCESS_SUPPORT
multiline_comment|/* Copy the stored registers from the stack. Put the register contents&n;   of thread thread_id in the struct reg. */
r_static
r_void
DECL|function|copy_registers_from_stack
id|copy_registers_from_stack
(paren
r_int
id|thread_id
comma
id|registers
op_star
id|regptr
)paren
(brace
r_int
id|j
suffix:semicolon
id|stack_registers
op_star
id|s
op_assign
(paren
id|stack_registers
op_star
)paren
id|stack_list
(braket
id|thread_id
)braket
suffix:semicolon
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
id|regptr
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|13
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
op_star
id|d
op_increment
op_assign
id|s-&gt;r
(braket
id|j
)braket
suffix:semicolon
id|regptr-&gt;sp
op_assign
(paren
r_int
r_int
)paren
id|stack_list
(braket
id|thread_id
)braket
suffix:semicolon
id|regptr-&gt;pc
op_assign
id|s-&gt;pc
suffix:semicolon
id|regptr-&gt;dccr
op_assign
id|s-&gt;dccr
suffix:semicolon
id|regptr-&gt;srp
op_assign
id|s-&gt;srp
suffix:semicolon
)brace
multiline_comment|/* Copy the registers to the stack. Put the register contents of thread&n;   thread_id from struct reg to the stack. */
r_static
r_void
DECL|function|copy_registers_to_stack
id|copy_registers_to_stack
(paren
r_int
id|thread_id
comma
id|registers
op_star
id|regptr
)paren
(brace
r_int
id|i
suffix:semicolon
id|stack_registers
op_star
id|d
op_assign
(paren
id|stack_registers
op_star
)paren
id|stack_list
(braket
id|thread_id
)braket
suffix:semicolon
r_int
r_int
op_star
id|s
op_assign
(paren
r_int
r_int
op_star
)paren
id|regptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d-&gt;r
(braket
id|i
)braket
op_assign
op_star
id|s
op_increment
suffix:semicolon
)brace
id|d-&gt;pc
op_assign
id|regptr-&gt;pc
suffix:semicolon
id|d-&gt;dccr
op_assign
id|regptr-&gt;dccr
suffix:semicolon
id|d-&gt;srp
op_assign
id|regptr-&gt;srp
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Write a value to a specified register in the register image of the current&n;   thread. Returns status code SUCCESS, E02 or E05. */
r_static
r_int
DECL|function|write_register
id|write_register
(paren
r_int
id|regno
comma
r_char
op_star
id|val
)paren
(brace
r_int
id|status
op_assign
id|SUCCESS
suffix:semicolon
id|registers
op_star
id|current_reg
op_assign
op_amp
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|regno
op_ge
id|R0
op_logical_and
id|regno
op_le
id|PC
)paren
(brace
multiline_comment|/* 32-bit register with simple offset. */
id|hex2mem
(paren
(paren
r_int
r_char
op_star
)paren
id|current_reg
op_plus
id|regno
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|val
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|P0
op_logical_or
id|regno
op_eq
id|VR
op_logical_or
id|regno
op_eq
id|P4
op_logical_or
id|regno
op_eq
id|P8
)paren
(brace
multiline_comment|/* Do not support read-only registers. */
id|status
op_assign
id|E02
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|CCR
)paren
(brace
multiline_comment|/* 16 bit register with complex offset. (P4 is read-only, P6 is not implemented, &n;                   and P7 (MOF) is 32 bits in ETRAX 100LX. */
id|hex2mem
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|current_reg-&gt;ccr
)paren
op_plus
(paren
id|regno
op_minus
id|CCR
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|val
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_ge
id|MOF
op_logical_and
id|regno
op_le
id|USP
)paren
(brace
multiline_comment|/* 32 bit register with complex offset.  (P8 has been taken care of.) */
id|hex2mem
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|current_reg-&gt;ibr
)paren
op_plus
(paren
id|regno
op_minus
id|IBR
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|val
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not support nonexisting or unimplemented registers (P2, P3, and P6). */
id|status
op_assign
id|E05
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef PROCESS_SUPPORT
multiline_comment|/* Write a value to a specified register in the stack of a thread other&n;   than the current thread. Returns status code SUCCESS or E07. */
r_static
r_int
DECL|function|write_stack_register
id|write_stack_register
(paren
r_int
id|thread_id
comma
r_int
id|regno
comma
r_char
op_star
id|valptr
)paren
(brace
r_int
id|status
op_assign
id|SUCCESS
suffix:semicolon
id|stack_registers
op_star
id|d
op_assign
(paren
id|stack_registers
op_star
)paren
id|stack_list
(braket
id|thread_id
)braket
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
id|hex2mem
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|val
comma
id|valptr
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regno
op_ge
id|R0
op_logical_and
id|regno
OL
id|SP
)paren
(brace
id|d-&gt;r
(braket
id|regno
)braket
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|SP
)paren
(brace
id|stack_list
(braket
id|thread_id
)braket
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|PC
)paren
(brace
id|d-&gt;pc
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|SRP
)paren
(brace
id|d-&gt;srp
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|DCCR
)paren
(brace
id|d-&gt;dccr
op_assign
id|val
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not support registers in the current thread. */
id|status
op_assign
id|E07
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Read a value from a specified register in the register image. Returns the&n;   value in the register or -1 for non-implemented registers.&n;   Should check consistency_status after a call which may be E05 after changes&n;   in the implementation. */
r_static
r_int
DECL|function|read_register
id|read_register
(paren
r_char
id|regno
comma
r_int
r_int
op_star
id|valptr
)paren
(brace
id|registers
op_star
id|current_reg
op_assign
op_amp
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|regno
op_ge
id|R0
op_logical_and
id|regno
op_le
id|PC
)paren
(brace
multiline_comment|/* 32-bit register with simple offset. */
op_star
id|valptr
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|current_reg
op_plus
id|regno
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|P0
op_logical_or
id|regno
op_eq
id|VR
)paren
(brace
multiline_comment|/* 8 bit register with complex offset. */
op_star
id|valptr
op_assign
(paren
r_int
r_int
)paren
(paren
op_star
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|current_reg-&gt;p0
)paren
op_plus
(paren
id|regno
op_minus
id|P0
)paren
op_star
r_sizeof
(paren
r_char
)paren
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_eq
id|P4
op_logical_or
id|regno
op_eq
id|CCR
)paren
(brace
multiline_comment|/* 16 bit register with complex offset. */
op_star
id|valptr
op_assign
(paren
r_int
r_int
)paren
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|current_reg-&gt;p4
)paren
op_plus
(paren
id|regno
op_minus
id|P4
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regno
op_ge
id|MOF
op_logical_and
id|regno
op_le
id|USP
)paren
(brace
multiline_comment|/* 32 bit register with complex offset. */
op_star
id|valptr
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|current_reg-&gt;p8
)paren
op_plus
(paren
id|regno
op_minus
id|P8
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not support nonexisting or unimplemented registers (P2, P3, and P6). */
id|consistency_status
op_assign
id|E05
suffix:semicolon
r_return
id|E05
suffix:semicolon
)brace
)brace
multiline_comment|/********************************** Packet I/O ******************************/
multiline_comment|/* Returns the character equivalent of a nibble, bit 7, 6, 5, and 4 of a byte,&n;   represented by int x. */
r_static
r_inline
r_char
DECL|function|highhex
id|highhex
c_func
(paren
r_int
id|x
)paren
(brace
r_return
id|hexchars
(braket
(paren
id|x
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
multiline_comment|/* Returns the character equivalent of a nibble, bit 3, 2, 1, and 0 of a byte,&n;   represented by int x. */
r_static
r_inline
r_char
DECL|function|lowhex
id|lowhex
c_func
(paren
r_int
id|x
)paren
(brace
r_return
id|hexchars
(braket
id|x
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
multiline_comment|/* Returns the integer equivalent of a hexadecimal character. */
r_static
r_int
DECL|function|hex
id|hex
(paren
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;f&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;9&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_ge
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|ch
op_le
l_char|&squot;F&squot;
)paren
)paren
r_return
(paren
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert the memory, pointed to by mem into hexadecimal representation.&n;   Put the result in buf, and return a pointer to the last character&n;   in buf (null). */
DECL|variable|do_printk
r_static
r_int
id|do_printk
op_assign
l_int|0
suffix:semicolon
r_static
r_char
op_star
DECL|function|mem2hex
id|mem2hex
c_func
(paren
r_char
op_star
id|buf
comma
r_int
r_char
op_star
id|mem
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|mem
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Bogus read from m0. FIXME: What constitutes a valid address? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|buf
op_increment
op_assign
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|buf
op_increment
op_assign
l_char|&squot;0&squot;
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Valid mem address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|mem
op_increment
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|highhex
(paren
id|ch
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|lowhex
(paren
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Terminate properly. */
op_star
id|buf
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert the array, in hexadecimal representation, pointed to by buf into&n;   binary representation. Put the result in mem, and return a pointer to&n;   the character after the last byte written. */
r_static
r_int
r_char
op_star
DECL|function|hex2mem
id|hex2mem
(paren
r_int
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
id|hex
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_assign
id|ch
op_plus
id|hex
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
op_star
id|mem
op_increment
op_assign
id|ch
suffix:semicolon
)brace
r_return
(paren
id|mem
)paren
suffix:semicolon
)brace
multiline_comment|/* Put the content of the array, in binary representation, pointed to by buf&n;   into memory pointed to by mem, and return a pointer to the character after&n;   the last byte written.&n;   Gdb will escape $, #, and the escape char (0x7d). */
r_static
r_int
r_char
op_star
DECL|function|bin2mem
id|bin2mem
(paren
r_int
r_char
op_star
id|mem
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check for any escaped characters. Be paranoid and&n;&t;&t;   only unescape chars that should be escaped. */
r_if
c_cond
(paren
op_star
id|buf
op_eq
l_int|0x7d
)paren
(brace
id|next
op_assign
id|buf
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|next
op_eq
l_int|0x3
op_logical_or
op_star
id|next
op_eq
l_int|0x4
op_logical_or
op_star
id|next
op_eq
l_int|0x5D
)paren
multiline_comment|/* #, $, ESC */
(brace
id|buf
op_increment
suffix:semicolon
op_star
id|buf
op_add_assign
l_int|0x20
suffix:semicolon
)brace
)brace
op_star
id|mem
op_increment
op_assign
op_star
id|buf
op_increment
suffix:semicolon
)brace
r_return
(paren
id|mem
)paren
suffix:semicolon
)brace
multiline_comment|/* Await the sequence $&lt;data&gt;#&lt;checksum&gt; and store &lt;data&gt; in the array buffer&n;   returned. */
r_static
r_void
DECL|function|getpacket
id|getpacket
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_char
id|ch
suffix:semicolon
r_do
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getDebugChar
(paren
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
multiline_comment|/* Wait for the start character $ and ignore all other characters */
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Read until a # or the end of the buffer is reached */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ch
op_assign
id|getDebugChar
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
id|buffer
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
(paren
id|getDebugChar
(paren
)paren
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_add_assign
id|hex
(paren
id|getDebugChar
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
(brace
multiline_comment|/* Wrong checksum */
id|putDebugChar
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Correct checksum */
id|putDebugChar
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* If sequence characters are received, reply with them */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|putDebugChar
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|putDebugChar
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Remove the sequence characters from the buffer */
id|count
op_assign
id|gdb_cris_strlen
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
)brace
multiline_comment|/* Send $&lt;data&gt;#&lt;checksum&gt; from the &lt;data&gt; in the array buffer. */
r_static
r_void
DECL|function|putpacket
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
id|checksum
suffix:semicolon
r_int
id|runlen
suffix:semicolon
r_int
id|encode
suffix:semicolon
r_do
(brace
r_char
op_star
id|src
op_assign
id|buffer
suffix:semicolon
id|putDebugChar
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|src
)paren
(brace
multiline_comment|/* Do run length encoding */
id|putDebugChar
(paren
op_star
id|src
)paren
suffix:semicolon
id|checksum
op_add_assign
op_star
id|src
suffix:semicolon
id|runlen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|runlen
OL
id|RUNLENMAX
op_logical_and
op_star
id|src
op_eq
id|src
(braket
id|runlen
)braket
)paren
(brace
id|runlen
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runlen
OG
l_int|3
)paren
(brace
multiline_comment|/* Got a useful amount */
id|putDebugChar
(paren
l_char|&squot;*&squot;
)paren
suffix:semicolon
id|checksum
op_add_assign
l_char|&squot;*&squot;
suffix:semicolon
id|encode
op_assign
id|runlen
op_plus
l_char|&squot; &squot;
op_minus
l_int|4
suffix:semicolon
id|putDebugChar
(paren
id|encode
)paren
suffix:semicolon
id|checksum
op_add_assign
id|encode
suffix:semicolon
id|src
op_add_assign
id|runlen
suffix:semicolon
)brace
r_else
(brace
id|src
op_increment
suffix:semicolon
)brace
)brace
id|putDebugChar
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|putDebugChar
(paren
id|highhex
(paren
id|checksum
)paren
)paren
suffix:semicolon
id|putDebugChar
(paren
id|lowhex
(paren
id|checksum
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|kgdb_started
op_logical_and
(paren
id|getDebugChar
c_func
(paren
)paren
op_ne
l_char|&squot;+&squot;
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/* The string str is prepended with the GDB printout token and sent. Required&n;   in traditional implementations. */
r_void
DECL|function|putDebugString
id|putDebugString
(paren
r_const
r_int
r_char
op_star
id|str
comma
r_int
id|length
)paren
(brace
id|remcomOutBuffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;O&squot;
suffix:semicolon
id|mem2hex
c_func
(paren
op_amp
id|remcomOutBuffer
(braket
l_int|1
)braket
comma
(paren
r_int
r_char
op_star
)paren
id|str
comma
id|length
)paren
suffix:semicolon
id|putpacket
c_func
(paren
id|remcomOutBuffer
)paren
suffix:semicolon
)brace
multiline_comment|/********************************** Handle exceptions ************************/
multiline_comment|/* Build and send a response packet in order to inform the host the&n;   stub is stopped. TAAn...:r...;n...:r...;n...:r...;&n;                    AA = signal number&n;                    n... = register number (hex)&n;                    r... = register contents&n;                    n... = `thread&squot;&n;                    r... = thread process ID.  This is a hex integer.&n;                    n... = other string not starting with valid hex digit.&n;                    gdb should ignore this n,r pair and go on to the next.&n;                    This way we can extend the protocol. */
r_static
r_void
DECL|function|stub_is_stopped
id|stub_is_stopped
c_func
(paren
r_int
id|sigval
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|remcomOutBuffer
suffix:semicolon
r_int
id|regno
suffix:semicolon
r_int
r_int
id|reg_cont
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* Send trap type (converted to signal) */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|highhex
(paren
id|sigval
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|lowhex
(paren
id|sigval
)paren
suffix:semicolon
multiline_comment|/* Send register contents. We probably only need to send the&n;&t; * PC, frame pointer and stack pointer here. Other registers will be&n;&t; * explicitely asked for. But for now, send all. &n;&t; */
r_for
c_loop
(paren
id|regno
op_assign
id|R0
suffix:semicolon
id|regno
op_le
id|USP
suffix:semicolon
id|regno
op_increment
)paren
(brace
multiline_comment|/* Store n...:r...; for the registers in the buffer. */
id|status
op_assign
id|read_register
(paren
id|regno
comma
op_amp
id|reg_cont
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|SUCCESS
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|highhex
(paren
id|regno
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|lowhex
(paren
id|regno
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
id|ptr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|reg_cont
comma
id|register_size
(braket
id|regno
)braket
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
)brace
)brace
macro_line|#ifdef PROCESS_SUPPORT
multiline_comment|/* Store the registers of the executing thread. Assume that both step,&n;&t;   continue, and register content requests are with respect to this&n;&t;   thread. The executing task is from the operating system scheduler. */
id|current_thread_c
op_assign
id|executing_task
suffix:semicolon
id|current_thread_g
op_assign
id|executing_task
suffix:semicolon
multiline_comment|/* A struct assignment translates into a libc memcpy call. Avoid&n;&t;   all libc functions in order to prevent recursive break points. */
id|copy_registers
(paren
op_amp
id|reg_g
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Store thread:r...; with the executing task TID. */
id|gdb_cris_strcpy
(paren
op_amp
id|remcomOutBuffer
(braket
id|pos
)braket
comma
l_string|&quot;thread:&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|gdb_cris_strlen
(paren
l_string|&quot;thread:&quot;
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
id|pos
op_increment
)braket
op_assign
id|highhex
(paren
id|executing_task
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
id|pos
op_increment
)braket
op_assign
id|lowhex
(paren
id|executing_task
)paren
suffix:semicolon
id|gdb_cris_strcpy
(paren
op_amp
id|remcomOutBuffer
(braket
id|pos
)braket
comma
l_string|&quot;;&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* null-terminate and send it off */
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
id|putpacket
(paren
id|remcomOutBuffer
)paren
suffix:semicolon
)brace
multiline_comment|/* All expected commands are sent from remote.c. Send a response according&n;   to the description in remote.c. */
r_static
r_void
DECL|function|handle_exception
id|handle_exception
(paren
r_int
id|sigval
)paren
(brace
multiline_comment|/* Avoid warning of not used. */
id|USEDFUN
c_func
(paren
id|handle_exception
)paren
suffix:semicolon
id|USEDVAR
c_func
(paren
id|internal_stack
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Send response. */
id|stub_is_stopped
(paren
id|sigval
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|remcomOutBuffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|getpacket
(paren
id|remcomInBuffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|remcomInBuffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;g&squot;
suffix:colon
multiline_comment|/* Read registers: g&n;&t;&t;&t;&t;   Success: Each byte of register data is described by two hex digits.&n;&t;&t;&t;&t;   Registers are in the internal order for GDB, and the bytes&n;&t;&t;&t;&t;   in a register  are in the same order the machine uses.&n;&t;&t;&t;&t;   Failure: void. */
(brace
macro_line|#ifdef PROCESS_SUPPORT
multiline_comment|/* Use the special register content in the executing thread. */
id|copy_registers
(paren
op_amp
id|reg_g
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Replace the content available on the stack. */
r_if
c_cond
(paren
id|current_thread_g
op_ne
id|executing_task
)paren
(brace
id|copy_registers_from_stack
(paren
id|current_thread_g
comma
op_amp
id|reg_g
)paren
suffix:semicolon
)brace
id|mem2hex
(paren
(paren
r_int
r_char
op_star
)paren
id|remcomOutBuffer
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|reg_g
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
macro_line|#else
id|mem2hex
c_func
(paren
id|remcomOutBuffer
comma
(paren
r_char
op_star
)paren
op_amp
id|reg
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
multiline_comment|/* Write registers. GXX..XX&n;&t;&t;&t;&t;   Each byte of register data  is described by two hex digits.&n;&t;&t;&t;&t;   Success: OK&n;&t;&t;&t;&t;   Failure: void. */
macro_line|#ifdef PROCESS_SUPPORT
id|hex2mem
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|reg_g
comma
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_thread_g
op_eq
id|executing_task
)paren
(brace
id|copy_registers
(paren
op_amp
id|reg
comma
op_amp
id|reg_g
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|copy_registers_to_stack
c_func
(paren
id|current_thread_g
comma
op_amp
id|reg_g
)paren
suffix:semicolon
)brace
macro_line|#else
id|hex2mem
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|reg
comma
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|registers
)paren
)paren
suffix:semicolon
macro_line|#endif
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
multiline_comment|/* Write register. Pn...=r...&n;&t;&t;&t;&t;   Write register n..., hex value without 0x, with value r...,&n;&t;&t;&t;&t;   which contains a hex value without 0x and two hex digits&n;&t;&t;&t;&t;   for each byte in the register (target byte order). P1f=11223344 means&n;&t;&t;&t;&t;   set register 31 to 44332211.&n;&t;&t;&t;&t;   Success: OK&n;&t;&t;&t;&t;   Failure: E02, E05 */
(brace
r_char
op_star
id|suffix
suffix:semicolon
r_int
id|regno
op_assign
id|gdb_cris_strtol
(paren
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
op_amp
id|suffix
comma
l_int|16
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
macro_line|#ifdef PROCESS_SUPPORT
r_if
c_cond
(paren
id|current_thread_g
op_assign
op_logical_neg
id|executing_task
)paren
id|status
op_assign
id|write_stack_register
(paren
id|current_thread_g
comma
id|regno
comma
id|suffix
op_plus
l_int|1
)paren
suffix:semicolon
r_else
macro_line|#endif
id|status
op_assign
id|write_register
(paren
id|regno
comma
id|suffix
op_plus
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|E02
suffix:colon
multiline_comment|/* Do not support read-only registers. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E02
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E05
suffix:colon
multiline_comment|/* Do not support non-existing registers. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E05
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E07
suffix:colon
multiline_comment|/* Do not support non-existing registers on the stack. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E07
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Valid register number. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
multiline_comment|/* Read from memory. mAA..AA,LLLL&n;&t;&t;&t;&t;   AA..AA is the address and LLLL is the length.&n;&t;&t;&t;&t;   Success: XX..XX is the memory content.  Can be fewer bytes than&n;&t;&t;&t;&t;   requested if only part of the data may be read. m6000120a,6c means&n;&t;&t;&t;&t;   retrieve 108 byte from base address 6000120a.&n;&t;&t;&t;&t;   Failure: void. */
(brace
r_char
op_star
id|suffix
suffix:semicolon
r_int
r_char
op_star
id|addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|gdb_cris_strtol
c_func
(paren
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
op_amp
id|suffix
comma
l_int|16
)paren
suffix:semicolon
r_int
id|length
op_assign
id|gdb_cris_strtol
c_func
(paren
id|suffix
op_plus
l_int|1
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|mem2hex
c_func
(paren
id|remcomOutBuffer
comma
id|addr
comma
id|length
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
multiline_comment|/* Write to memory. XAA..AA,LLLL:XX..XX&n;&t;&t;&t;&t;   AA..AA is the start address,  LLLL is the number of bytes, and&n;&t;&t;&t;&t;   XX..XX is the binary data.&n;&t;&t;&t;&t;   Success: OK&n;&t;&t;&t;&t;   Failure: void. */
r_case
l_char|&squot;M&squot;
suffix:colon
multiline_comment|/* Write to memory. MAA..AA,LLLL:XX..XX&n;&t;&t;&t;&t;   AA..AA is the start address,  LLLL is the number of bytes, and&n;&t;&t;&t;&t;   XX..XX is the hexadecimal data.&n;&t;&t;&t;&t;   Success: OK&n;&t;&t;&t;&t;   Failure: void. */
(brace
r_char
op_star
id|lenptr
suffix:semicolon
r_char
op_star
id|dataptr
suffix:semicolon
r_int
r_char
op_star
id|addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|gdb_cris_strtol
c_func
(paren
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
op_amp
id|lenptr
comma
l_int|16
)paren
suffix:semicolon
r_int
id|length
op_assign
id|gdb_cris_strtol
c_func
(paren
id|lenptr
op_plus
l_int|1
comma
op_amp
id|dataptr
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|lenptr
op_eq
l_char|&squot;,&squot;
op_logical_and
op_star
id|dataptr
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|remcomInBuffer
(braket
l_int|0
)braket
op_eq
l_char|&squot;M&squot;
)paren
(brace
id|hex2mem
c_func
(paren
id|addr
comma
id|dataptr
op_plus
l_int|1
comma
id|length
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* X */
(brace
id|bin2mem
c_func
(paren
id|addr
comma
id|dataptr
op_plus
l_int|1
comma
id|length
)paren
suffix:semicolon
)brace
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E06
)braket
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* Continue execution. cAA..AA&n;&t;&t;&t;&t;   AA..AA is the address where execution is resumed. If AA..AA is&n;&t;&t;&t;&t;   omitted, resume at the present address.&n;&t;&t;&t;&t;   Success: return to the executing thread.&n;&t;&t;&t;&t;   Failure: will never know. */
r_if
c_cond
(paren
id|remcomInBuffer
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|reg.pc
op_assign
id|gdb_cris_strtol
(paren
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
)brace
id|enableDebugIRQ
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* Step. sAA..AA&n;&t;&t;&t;&t;   AA..AA is the address where execution is resumed. If AA..AA is&n;&t;&t;&t;&t;   omitted, resume at the present address. Success: return to the&n;&t;&t;&t;&t;   executing thread. Failure: will never know.&n;&t;&t;&t;&t;   &n;&t;&t;&t;&t;   Should never be invoked. The single-step is implemented on&n;&t;&t;&t;&t;   the host side. If ever invoked, it is an internal error E04. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E04
)braket
)paren
suffix:semicolon
id|putpacket
(paren
id|remcomOutBuffer
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
multiline_comment|/* The last signal which caused a stop. ?&n;&t;&t;&t;&t;   Success: SAA, where AA is the signal number.&n;&t;&t;&t;&t;   Failure: void. */
id|remcomOutBuffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|1
)braket
op_assign
id|highhex
(paren
id|sigval
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|2
)braket
op_assign
id|lowhex
(paren
id|sigval
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* Detach from host. D&n;&t;&t;&t;&t;   Success: OK, and return to the executing thread.&n;&t;&t;&t;&t;   Failure: will never know */
id|putpacket
(paren
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
r_case
l_char|&squot;r&squot;
suffix:colon
multiline_comment|/* kill request or reset request.&n;&t;&t;&t;&t;   Success: restart of target.&n;&t;&t;&t;&t;   Failure: will never know. */
id|kill_restart
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
r_case
l_char|&squot;S&squot;
suffix:colon
r_case
l_char|&squot;!&squot;
suffix:colon
r_case
l_char|&squot;R&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* Continue with signal sig. Csig;AA..AA&n;&t;&t;&t;&t;   Step with signal sig. Ssig;AA..AA&n;&t;&t;&t;&t;   Use the extended remote protocol. !&n;&t;&t;&t;&t;   Restart the target system. R0&n;&t;&t;&t;&t;   Toggle debug flag. d&n;&t;&t;&t;&t;   Search backwards. tAA:PP,MM&n;&t;&t;&t;&t;   Not supported: E04 */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E04
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef PROCESS_SUPPORT
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* Thread alive. TXX&n;&t;&t;&t;&t;   Is thread XX alive?&n;&t;&t;&t;&t;   Success: OK, thread XX is alive.&n;&t;&t;&t;&t;   Failure: E03, thread XX is dead. */
(brace
r_int
id|thread_id
op_assign
(paren
r_int
)paren
id|gdb_cris_strtol
(paren
op_amp
id|remcomInBuffer
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Cannot tell whether it is alive or not. */
r_if
c_cond
(paren
id|thread_id
op_ge
l_int|0
op_logical_and
id|thread_id
OL
id|number_of_tasks
)paren
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* Set thread for subsequent operations: Hct&n;&t;&t;&t;&t;   c = &squot;c&squot; for thread used in step and continue;&n;&t;&t;&t;&t;   t can be -1 for all threads.&n;&t;&t;&t;&t;   c = &squot;g&squot; for thread used in other  operations.&n;&t;&t;&t;&t;   t = 0 means pick any thread.&n;&t;&t;&t;&t;   Success: OK&n;&t;&t;&t;&t;   Failure: E01 */
(brace
r_int
id|thread_id
op_assign
id|gdb_cris_strtol
(paren
op_amp
id|remcomInBuffer
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remcomInBuffer
(braket
l_int|1
)braket
op_eq
l_char|&squot;c&squot;
)paren
(brace
multiline_comment|/* c = &squot;c&squot; for thread used in step and continue */
multiline_comment|/* Do not change current_thread_c here. It would create a mess in&n;&t;&t;&t;&t;&t;&t;   the scheduler. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|remcomInBuffer
(braket
l_int|1
)braket
op_eq
l_char|&squot;g&squot;
)paren
(brace
multiline_comment|/* c = &squot;g&squot; for thread used in other  operations.&n;&t;&t;&t;&t;&t;&t;   t = 0 means pick any thread. Impossible since the scheduler does&n;&t;&t;&t;&t;&t;&t;   not allow that. */
r_if
c_cond
(paren
id|thread_id
op_ge
l_int|0
op_logical_and
id|thread_id
OL
id|number_of_tasks
)paren
(brace
id|current_thread_g
op_assign
id|thread_id
suffix:semicolon
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not expected - send an error message. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E01
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Not expected - send an error message. */
id|gdb_cris_strcpy
(paren
id|remcomOutBuffer
comma
id|error_message
(braket
id|E01
)braket
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_case
l_char|&squot;Q&squot;
suffix:colon
multiline_comment|/* Query of general interest. qXXXX&n;&t;&t;&t;&t;   Set general value XXXX. QXXXX=yyyy */
(brace
r_int
id|pos
suffix:semicolon
r_int
id|nextpos
suffix:semicolon
r_int
id|thread_id
suffix:semicolon
r_switch
c_cond
(paren
id|remcomInBuffer
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
multiline_comment|/* Identify the remote current thread. */
id|gdb_cris_strcpy
(paren
op_amp
id|remcomOutBuffer
(braket
l_int|0
)braket
comma
l_string|&quot;QC&quot;
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|2
)braket
op_assign
id|highhex
(paren
id|current_thread_c
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|3
)braket
op_assign
id|lowhex
(paren
id|current_thread_c
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|4
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|gdb_cris_strcpy
(paren
op_amp
id|remcomOutBuffer
(braket
l_int|0
)braket
comma
l_string|&quot;QM&quot;
)paren
suffix:semicolon
multiline_comment|/* Reply with number of threads. */
r_if
c_cond
(paren
id|os_is_started
c_func
(paren
)paren
)paren
(brace
id|remcomOutBuffer
(braket
l_int|2
)braket
op_assign
id|highhex
(paren
id|number_of_tasks
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|3
)braket
op_assign
id|lowhex
(paren
id|number_of_tasks
)paren
suffix:semicolon
)brace
r_else
(brace
id|remcomOutBuffer
(braket
l_int|2
)braket
op_assign
id|highhex
(paren
l_int|0
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
l_int|3
)braket
op_assign
id|lowhex
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Done with the reply. */
id|remcomOutBuffer
(braket
l_int|4
)braket
op_assign
id|lowhex
(paren
l_int|1
)paren
suffix:semicolon
id|pos
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* Expects the argument thread id. */
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
(paren
l_int|5
op_plus
id|HEXCHARS_IN_THREAD_ID
)paren
suffix:semicolon
id|pos
op_increment
)paren
id|remcomOutBuffer
(braket
id|pos
)braket
op_assign
id|remcomInBuffer
(braket
id|pos
)braket
suffix:semicolon
multiline_comment|/* Reply with the thread identifiers. */
r_if
c_cond
(paren
id|os_is_started
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Store the thread identifiers of all tasks. */
r_for
c_loop
(paren
id|thread_id
op_assign
l_int|0
suffix:semicolon
id|thread_id
OL
id|number_of_tasks
suffix:semicolon
id|thread_id
op_increment
)paren
(brace
id|nextpos
op_assign
id|pos
op_plus
id|HEXCHARS_IN_THREAD_ID
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
id|nextpos
suffix:semicolon
id|pos
op_increment
)paren
id|remcomOutBuffer
(braket
id|pos
)braket
op_assign
id|lowhex
(paren
l_int|0
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
id|pos
op_increment
)braket
op_assign
id|lowhex
(paren
id|thread_id
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Store the thread identifier of the boot task. */
id|nextpos
op_assign
id|pos
op_plus
id|HEXCHARS_IN_THREAD_ID
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
id|nextpos
suffix:semicolon
id|pos
op_increment
)paren
id|remcomOutBuffer
(braket
id|pos
)braket
op_assign
id|lowhex
(paren
l_int|0
)paren
suffix:semicolon
id|remcomOutBuffer
(braket
id|pos
op_increment
)braket
op_assign
id|lowhex
(paren
id|current_thread_c
)paren
suffix:semicolon
)brace
id|remcomOutBuffer
(braket
id|pos
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Not supported: &quot;&quot; */
multiline_comment|/* Request information about section offsets: qOffsets. */
id|remcomOutBuffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#endif /* PROCESS_SUPPORT */
r_default
suffix:colon
multiline_comment|/* The stub should ignore other request and send an empty&n;&t;&t;&t;&t;   response ($#&lt;checksum&gt;). This way we can extend the protocol and GDB&n;&t;&t;&t;&t;   can tell whether the stub it is talking to uses the old or the new. */
id|remcomOutBuffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|putpacket
c_func
(paren
id|remcomOutBuffer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The jump is to the address 0x00000002. Performs a complete re-start&n;   from scratch. */
r_static
r_void
DECL|function|kill_restart
id|kill_restart
(paren
)paren
(brace
id|__asm__
r_volatile
(paren
l_string|&quot;jump 2&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/********************************** Breakpoint *******************************/
multiline_comment|/* The hook for both a static (compiled) and a dynamic breakpoint set by GDB.&n;   An internal stack is used by the stub. The register image of the caller is&n;   stored in the structure register_image.&n;   Interactive communication with the host is handled by handle_exception and&n;   finally the register image is restored. */
r_void
id|kgdb_handle_breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
id|asm
(paren
"&quot;"
dot
id|global
id|kgdb_handle_breakpoint
id|kgdb_handle_breakpoint
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Response
id|to
id|the
r_break
op_minus
id|instruction
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Create
id|a
r_register
id|image
id|of
id|the
id|caller
suffix:semicolon
suffix:semicolon
id|move
"$"
id|dccr
comma
(braket
id|reg
op_plus
l_int|0x5E
)braket
suffix:semicolon
id|Save
id|the
id|flags
id|in
id|DCCR
id|before
id|disable
id|interrupts
id|di
suffix:semicolon
id|Disable
id|interrupts
id|move.d
"$"
id|r0
comma
(braket
id|reg
)braket
suffix:semicolon
id|Save
id|R0
id|move.d
"$"
id|r1
comma
(braket
id|reg
op_plus
l_int|0x04
)braket
suffix:semicolon
id|Save
id|R1
id|move.d
"$"
id|r2
comma
(braket
id|reg
op_plus
l_int|0x08
)braket
suffix:semicolon
id|Save
id|R2
id|move.d
"$"
id|r3
comma
(braket
id|reg
op_plus
l_int|0x0C
)braket
suffix:semicolon
id|Save
id|R3
id|move.d
"$"
id|r4
comma
(braket
id|reg
op_plus
l_int|0x10
)braket
suffix:semicolon
id|Save
id|R4
id|move.d
"$"
id|r5
comma
(braket
id|reg
op_plus
l_int|0x14
)braket
suffix:semicolon
id|Save
id|R5
id|move.d
"$"
id|r6
comma
(braket
id|reg
op_plus
l_int|0x18
)braket
suffix:semicolon
id|Save
id|R6
id|move.d
"$"
id|r7
comma
(braket
id|reg
op_plus
l_int|0x1C
)braket
suffix:semicolon
id|Save
id|R7
id|move.d
"$"
id|r8
comma
(braket
id|reg
op_plus
l_int|0x20
)braket
suffix:semicolon
id|Save
id|R8
id|move.d
"$"
id|r9
comma
(braket
id|reg
op_plus
l_int|0x24
)braket
suffix:semicolon
id|Save
id|R9
id|move.d
"$"
id|r10
comma
(braket
id|reg
op_plus
l_int|0x28
)braket
suffix:semicolon
id|Save
id|R10
id|move.d
"$"
id|r11
comma
(braket
id|reg
op_plus
l_int|0x2C
)braket
suffix:semicolon
id|Save
id|R11
id|move.d
"$"
id|r12
comma
(braket
id|reg
op_plus
l_int|0x30
)braket
suffix:semicolon
id|Save
id|R12
id|move.d
"$"
id|r13
comma
(braket
id|reg
op_plus
l_int|0x34
)braket
suffix:semicolon
id|Save
id|R13
id|move.d
"$"
id|sp
comma
(braket
id|reg
op_plus
l_int|0x38
)braket
suffix:semicolon
id|Save
id|SP
(paren
id|R14
)paren
suffix:semicolon
suffix:semicolon
id|Due
id|to
id|the
id|old
id|assembler
op_minus
id|versions
id|BRP
id|might
op_logical_neg
id|be
id|recognized
dot
id|word
l_int|0xE670
suffix:semicolon
id|move
id|brp
comma
"$"
id|r0
id|subq
l_int|2
comma
"$"
id|r0
suffix:semicolon
id|Set
id|to
id|address
id|of
id|previous
id|instruction
dot
id|move.d
"$"
id|r0
comma
(braket
id|reg
op_plus
l_int|0x3c
)braket
suffix:semicolon
id|Save
id|the
id|address
id|in
id|PC
(paren
id|R15
)paren
id|clear.b
(braket
id|reg
op_plus
l_int|0x40
)braket
suffix:semicolon
id|Clear
id|P0
id|move
"$"
id|vr
comma
(braket
id|reg
op_plus
l_int|0x41
)braket
suffix:semicolon
id|Save
id|special
r_register
id|P1
id|clear.w
(braket
id|reg
op_plus
l_int|0x42
)braket
suffix:semicolon
id|Clear
id|P4
id|move
"$"
id|ccr
comma
(braket
id|reg
op_plus
l_int|0x44
)braket
suffix:semicolon
id|Save
id|special
r_register
id|CCR
id|move
"$"
id|mof
comma
(braket
id|reg
op_plus
l_int|0x46
)braket
suffix:semicolon
id|P7
id|clear.d
(braket
id|reg
op_plus
l_int|0x4A
)braket
suffix:semicolon
id|Clear
id|P8
id|move
"$"
id|ibr
comma
(braket
id|reg
op_plus
l_int|0x4E
)braket
suffix:semicolon
id|P9
comma
id|move
"$"
id|irp
comma
(braket
id|reg
op_plus
l_int|0x52
)braket
suffix:semicolon
id|P10
comma
id|move
"$"
id|srp
comma
(braket
id|reg
op_plus
l_int|0x56
)braket
suffix:semicolon
id|P11
comma
id|move
"$"
id|dtp0
comma
(braket
id|reg
op_plus
l_int|0x5A
)braket
suffix:semicolon
id|P12
comma
r_register
id|BAR
comma
id|assembler
id|might
op_logical_neg
id|know
id|BAR
suffix:semicolon
id|P13
comma
r_register
id|DCCR
id|already
id|saved
suffix:semicolon
suffix:semicolon
id|Due
id|to
id|the
id|old
id|assembler
op_minus
id|versions
id|BRP
id|might
op_logical_neg
id|be
id|recognized
dot
id|word
l_int|0xE670
suffix:semicolon
id|move
id|brp
comma
id|r0
suffix:semicolon
suffix:semicolon
id|Static
(paren
id|compiled
)paren
id|breakpoints
id|must
r_return
id|to
id|the
id|next
id|instruction
id|in
id|order
suffix:semicolon
suffix:semicolon
id|to
id|avoid
id|infinite
id|loops
dot
id|Dynamic
(paren
id|gdb
op_minus
id|invoked
)paren
id|must
id|restore
id|the
id|instruction
suffix:semicolon
suffix:semicolon
id|in
id|order
id|to
id|execute
id|it
id|when
id|execution
id|is
id|continued
dot
id|test.b
(braket
id|is_dyn_brkp
)braket
suffix:semicolon
id|Is
id|this
id|a
id|dynamic
id|breakpoint
ques
c_cond
id|beq
id|is_static
suffix:semicolon
id|No
comma
id|a
r_static
id|breakpoint
id|nop
id|subq
l_int|2
comma
"$"
id|r0
suffix:semicolon
id|rerun
id|the
id|instruction
id|the
r_break
id|replaced
id|is_static
suffix:colon
id|moveq
l_int|1
comma
"$"
id|r1
id|move.b
"$"
id|r1
comma
(braket
id|is_dyn_brkp
)braket
suffix:semicolon
id|Set
id|the
id|state
id|variable
id|to
id|dynamic
id|breakpoint
id|move.d
"$"
id|r0
comma
(braket
id|reg
op_plus
l_int|0x62
)braket
suffix:semicolon
id|Save
id|the
r_return
id|address
id|in
id|BRP
id|move
"$"
id|usp
comma
(braket
id|reg
op_plus
l_int|0x66
)braket
suffix:semicolon
id|USP
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Handle
id|the
id|communication
suffix:semicolon
suffix:semicolon
id|move.d
id|internal_stack
op_plus
l_int|1020
comma
"$"
id|sp
suffix:semicolon
id|Use
id|the
id|internal
id|stack
id|which
id|grows
id|upward
id|moveq
l_int|5
comma
"$"
id|r10
suffix:semicolon
id|SIGTRAP
id|jsr
id|handle_exception
suffix:semicolon
id|Interactive
id|routine
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Return
id|to
id|the
id|caller
suffix:semicolon
suffix:semicolon
id|move.d
(braket
id|reg
)braket
comma
"$"
id|r0
suffix:semicolon
id|Restore
id|R0
id|move.d
(braket
id|reg
op_plus
l_int|0x04
)braket
comma
"$"
id|r1
suffix:semicolon
id|Restore
id|R1
id|move.d
(braket
id|reg
op_plus
l_int|0x08
)braket
comma
"$"
id|r2
suffix:semicolon
id|Restore
id|R2
id|move.d
(braket
id|reg
op_plus
l_int|0x0C
)braket
comma
"$"
id|r3
suffix:semicolon
id|Restore
id|R3
id|move.d
(braket
id|reg
op_plus
l_int|0x10
)braket
comma
"$"
id|r4
suffix:semicolon
id|Restore
id|R4
id|move.d
(braket
id|reg
op_plus
l_int|0x14
)braket
comma
"$"
id|r5
suffix:semicolon
id|Restore
id|R5
id|move.d
(braket
id|reg
op_plus
l_int|0x18
)braket
comma
"$"
id|r6
suffix:semicolon
id|Restore
id|R6
id|move.d
(braket
id|reg
op_plus
l_int|0x1C
)braket
comma
"$"
id|r7
suffix:semicolon
id|Restore
id|R7
id|move.d
(braket
id|reg
op_plus
l_int|0x20
)braket
comma
"$"
id|r8
suffix:semicolon
id|Restore
id|R8
id|move.d
(braket
id|reg
op_plus
l_int|0x24
)braket
comma
"$"
id|r9
suffix:semicolon
id|Restore
id|R9
id|move.d
(braket
id|reg
op_plus
l_int|0x28
)braket
comma
"$"
id|r10
suffix:semicolon
id|Restore
id|R10
id|move.d
(braket
id|reg
op_plus
l_int|0x2C
)braket
comma
"$"
id|r11
suffix:semicolon
id|Restore
id|R11
id|move.d
(braket
id|reg
op_plus
l_int|0x30
)braket
comma
"$"
id|r12
suffix:semicolon
id|Restore
id|R12
id|move.d
(braket
id|reg
op_plus
l_int|0x34
)braket
comma
"$"
id|r13
suffix:semicolon
id|Restore
id|R13
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|FIXME
suffix:colon
id|Which
id|registers
id|should
id|be
id|restored
ques
c_cond
suffix:semicolon
suffix:semicolon
id|move.d
(braket
id|reg
op_plus
l_int|0x38
)braket
comma
"$"
id|sp
suffix:semicolon
id|Restore
id|SP
(paren
id|R14
)paren
id|move
(braket
id|reg
op_plus
l_int|0x56
)braket
comma
"$"
id|srp
suffix:semicolon
id|Restore
id|the
id|subroutine
r_return
id|pointer
dot
id|move
(braket
id|reg
op_plus
l_int|0x5E
)braket
comma
"$"
id|dccr
suffix:semicolon
id|Restore
id|DCCR
id|move
(braket
id|reg
op_plus
l_int|0x66
)braket
comma
"$"
id|usp
suffix:semicolon
id|Restore
id|USP
id|jump
(braket
id|reg
op_plus
l_int|0x62
)braket
suffix:semicolon
id|A
id|jump
id|to
id|the
id|content
id|in
r_register
id|BRP
id|works
dot
id|nop
suffix:semicolon
"&quot;"
)paren
suffix:semicolon
multiline_comment|/* The hook for an interrupt generated by GDB. An internal stack is used&n;   by the stub. The register image of the caller is stored in the structure&n;   register_image. Interactive communication with the host is handled by&n;   handle_exception and finally the register image is restored. Due to the&n;   old assembler which does not recognise the break instruction and the&n;   breakpoint return pointer hex-code is used. */
r_void
id|kgdb_handle_serial
c_func
(paren
r_void
)paren
suffix:semicolon
id|asm
(paren
"&quot;"
dot
id|global
id|kgdb_handle_serial
id|kgdb_handle_serial
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Response
id|to
id|a
id|serial
id|interrupt
suffix:semicolon
suffix:semicolon
id|move
"$"
id|dccr
comma
(braket
id|reg
op_plus
l_int|0x5E
)braket
suffix:semicolon
id|Save
id|the
id|flags
id|in
id|DCCR
id|di
suffix:semicolon
id|Disable
id|interrupts
id|move.d
"$"
id|r0
comma
(braket
id|reg
)braket
suffix:semicolon
id|Save
id|R0
id|move.d
"$"
id|r1
comma
(braket
id|reg
op_plus
l_int|0x04
)braket
suffix:semicolon
id|Save
id|R1
id|move.d
"$"
id|r2
comma
(braket
id|reg
op_plus
l_int|0x08
)braket
suffix:semicolon
id|Save
id|R2
id|move.d
"$"
id|r3
comma
(braket
id|reg
op_plus
l_int|0x0C
)braket
suffix:semicolon
id|Save
id|R3
id|move.d
"$"
id|r4
comma
(braket
id|reg
op_plus
l_int|0x10
)braket
suffix:semicolon
id|Save
id|R4
id|move.d
"$"
id|r5
comma
(braket
id|reg
op_plus
l_int|0x14
)braket
suffix:semicolon
id|Save
id|R5
id|move.d
"$"
id|r6
comma
(braket
id|reg
op_plus
l_int|0x18
)braket
suffix:semicolon
id|Save
id|R6
id|move.d
"$"
id|r7
comma
(braket
id|reg
op_plus
l_int|0x1C
)braket
suffix:semicolon
id|Save
id|R7
id|move.d
"$"
id|r8
comma
(braket
id|reg
op_plus
l_int|0x20
)braket
suffix:semicolon
id|Save
id|R8
id|move.d
"$"
id|r9
comma
(braket
id|reg
op_plus
l_int|0x24
)braket
suffix:semicolon
id|Save
id|R9
id|move.d
"$"
id|r10
comma
(braket
id|reg
op_plus
l_int|0x28
)braket
suffix:semicolon
id|Save
id|R10
id|move.d
"$"
id|r11
comma
(braket
id|reg
op_plus
l_int|0x2C
)braket
suffix:semicolon
id|Save
id|R11
id|move.d
"$"
id|r12
comma
(braket
id|reg
op_plus
l_int|0x30
)braket
suffix:semicolon
id|Save
id|R12
id|move.d
"$"
id|r13
comma
(braket
id|reg
op_plus
l_int|0x34
)braket
suffix:semicolon
id|Save
id|R13
id|move.d
"$"
id|sp
comma
(braket
id|reg
op_plus
l_int|0x38
)braket
suffix:semicolon
id|Save
id|SP
(paren
id|R14
)paren
id|move
"$"
id|irp
comma
(braket
id|reg
op_plus
l_int|0x3c
)braket
suffix:semicolon
id|Save
id|the
id|address
id|in
id|PC
(paren
id|R15
)paren
id|clear.b
(braket
id|reg
op_plus
l_int|0x40
)braket
suffix:semicolon
id|Clear
id|P0
id|move
"$"
id|vr
comma
(braket
id|reg
op_plus
l_int|0x41
)braket
suffix:semicolon
id|Save
id|special
r_register
id|P1
comma
id|clear.w
(braket
id|reg
op_plus
l_int|0x42
)braket
suffix:semicolon
id|Clear
id|P4
id|move
"$"
id|ccr
comma
(braket
id|reg
op_plus
l_int|0x44
)braket
suffix:semicolon
id|Save
id|special
r_register
id|CCR
id|move
"$"
id|mof
comma
(braket
id|reg
op_plus
l_int|0x46
)braket
suffix:semicolon
id|P7
id|clear.d
(braket
id|reg
op_plus
l_int|0x4A
)braket
suffix:semicolon
id|Clear
id|P8
id|move
"$"
id|ibr
comma
(braket
id|reg
op_plus
l_int|0x4E
)braket
suffix:semicolon
id|P9
comma
id|move
"$"
id|irp
comma
(braket
id|reg
op_plus
l_int|0x52
)braket
suffix:semicolon
id|P10
comma
id|move
"$"
id|srp
comma
(braket
id|reg
op_plus
l_int|0x56
)braket
suffix:semicolon
id|P11
comma
id|move
"$"
id|dtp0
comma
(braket
id|reg
op_plus
l_int|0x5A
)braket
suffix:semicolon
id|P12
comma
r_register
id|BAR
comma
id|assembler
id|might
op_logical_neg
id|know
id|BAR
suffix:semicolon
id|P13
comma
r_register
id|DCCR
id|already
id|saved
suffix:semicolon
suffix:semicolon
id|Due
id|to
id|the
id|old
id|assembler
op_minus
id|versions
id|BRP
id|might
op_logical_neg
id|be
id|recognized
dot
id|word
l_int|0xE670
suffix:semicolon
id|move
id|brp
comma
id|r0
id|move.d
"$"
id|r0
comma
(braket
id|reg
op_plus
l_int|0x62
)braket
suffix:semicolon
id|Save
id|the
r_return
id|address
id|in
id|BRP
id|move
"$"
id|usp
comma
(braket
id|reg
op_plus
l_int|0x66
)braket
suffix:semicolon
id|USP
suffix:semicolon
suffix:semicolon
id|get
id|the
id|serial
id|character
(paren
id|from
id|debugport.c
)paren
op_logical_and
id|check
r_if
id|its
id|a
id|ctrl
op_minus
id|c
id|jsr
id|getDebugChar
id|cmp.b
l_int|3
comma
"$"
id|r10
id|bne
id|goback
id|nop
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Handle
id|the
id|communication
suffix:semicolon
suffix:semicolon
id|move.d
id|internal_stack
op_plus
l_int|1020
comma
"$"
id|sp
suffix:semicolon
id|Use
id|the
id|internal
id|stack
id|moveq
l_int|2
comma
"$"
id|r10
suffix:semicolon
id|SIGINT
id|jsr
id|handle_exception
suffix:semicolon
id|Interactive
id|routine
id|goback
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Return
id|to
id|the
id|caller
suffix:semicolon
suffix:semicolon
id|move.d
(braket
id|reg
)braket
comma
"$"
id|r0
suffix:semicolon
id|Restore
id|R0
id|move.d
(braket
id|reg
op_plus
l_int|0x04
)braket
comma
"$"
id|r1
suffix:semicolon
id|Restore
id|R1
id|move.d
(braket
id|reg
op_plus
l_int|0x08
)braket
comma
"$"
id|r2
suffix:semicolon
id|Restore
id|R2
id|move.d
(braket
id|reg
op_plus
l_int|0x0C
)braket
comma
"$"
id|r3
suffix:semicolon
id|Restore
id|R3
id|move.d
(braket
id|reg
op_plus
l_int|0x10
)braket
comma
"$"
id|r4
suffix:semicolon
id|Restore
id|R4
id|move.d
(braket
id|reg
op_plus
l_int|0x14
)braket
comma
"$"
id|r5
suffix:semicolon
id|Restore
id|R5
id|move.d
(braket
id|reg
op_plus
l_int|0x18
)braket
comma
"$"
id|r6
suffix:semicolon
id|Restore
id|R6
id|move.d
(braket
id|reg
op_plus
l_int|0x1C
)braket
comma
"$"
id|r7
suffix:semicolon
id|Restore
id|R7
id|move.d
(braket
id|reg
op_plus
l_int|0x20
)braket
comma
"$"
id|r8
suffix:semicolon
id|Restore
id|R8
id|move.d
(braket
id|reg
op_plus
l_int|0x24
)braket
comma
"$"
id|r9
suffix:semicolon
id|Restore
id|R9
id|move.d
(braket
id|reg
op_plus
l_int|0x28
)braket
comma
"$"
id|r10
suffix:semicolon
id|Restore
id|R10
id|move.d
(braket
id|reg
op_plus
l_int|0x2C
)braket
comma
"$"
id|r11
suffix:semicolon
id|Restore
id|R11
id|move.d
(braket
id|reg
op_plus
l_int|0x30
)braket
comma
"$"
id|r12
suffix:semicolon
id|Restore
id|R12
id|move.d
(braket
id|reg
op_plus
l_int|0x34
)braket
comma
"$"
id|r13
suffix:semicolon
id|Restore
id|R13
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|FIXME
suffix:colon
id|Which
id|registers
id|should
id|be
id|restored
ques
c_cond
suffix:semicolon
suffix:semicolon
id|move.d
(braket
id|reg
op_plus
l_int|0x38
)braket
comma
"$"
id|sp
suffix:semicolon
id|Restore
id|SP
(paren
id|R14
)paren
id|move
(braket
id|reg
op_plus
l_int|0x56
)braket
comma
"$"
id|srp
suffix:semicolon
id|Restore
id|the
id|subroutine
r_return
id|pointer
dot
id|move
(braket
id|reg
op_plus
l_int|0x5E
)braket
comma
"$"
id|dccr
suffix:semicolon
id|Restore
id|DCCR
id|move
(braket
id|reg
op_plus
l_int|0x66
)braket
comma
"$"
id|usp
suffix:semicolon
id|Restore
id|USP
id|reti
suffix:semicolon
id|Return
id|from
id|the
id|interrupt
id|routine
id|nop
"&quot;"
)paren
suffix:semicolon
multiline_comment|/* Use this static breakpoint in the start-up only. */
r_void
DECL|function|breakpoint
id|breakpoint
c_func
(paren
r_void
)paren
(brace
id|kgdb_started
op_assign
l_int|1
suffix:semicolon
id|is_dyn_brkp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is a static, not a dynamic breakpoint. */
id|__asm__
r_volatile
(paren
l_string|&quot;break 8&quot;
)paren
suffix:semicolon
multiline_comment|/* Jump to handle_breakpoint. */
)brace
multiline_comment|/* initialize kgdb. doesn&squot;t break into the debugger, but sets up irq and ports */
r_void
DECL|function|kgdb_init
id|kgdb_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* could initialize debug port as well but it&squot;s done in head.S already... */
multiline_comment|/* breakpoint handler is now set in irq.c */
id|set_int_vector
c_func
(paren
l_int|8
comma
id|kgdb_handle_serial
comma
l_int|0
)paren
suffix:semicolon
id|enableDebugIRQ
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************** End of file **********************************/
eof
