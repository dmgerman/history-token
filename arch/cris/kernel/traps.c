multiline_comment|/* $Id: traps.c,v 1.2 2001/12/18 13:35:20 bjornw Exp $&n; *&n; *  linux/arch/cris/traps.c&n; *&n; *  Here we handle the break vectors not used by the system call &n; *  mechanism, as well as some general stack/register dumping &n; *  things.&n; * &n; *  Copyright (C) 2000,2001 Axis Communications AB&n; *&n; *  Authors:   Bjorn Wesen&n; *  &t;       Hans-Peter Nilsson&n; *&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_int
r_int
op_star
id|stack
)paren
(brace
r_int
r_int
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_extern
r_char
id|_stext
comma
id|_etext
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|VMALLOC_START
suffix:semicolon
id|module_end
op_assign
id|VMALLOC_END
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|__get_user
(paren
id|addr
comma
id|stack
)paren
)paren
(brace
multiline_comment|/* This message matches &quot;failing address&quot; marked&n;&t;&t;&t;   s390 in ksymoops, so lines containing it will&n;&t;&t;&t;   not be filtered out by ksymoops.  */
id|printk
(paren
l_string|&quot;Failing address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;                 * If the address is either in the text segment of the&n;                 * kernel, or in the region which contains vmalloc&squot;ed&n;                 * memory, it *may* be the address of a calling&n;                 * routine; if so, print it so that someone tracing&n;                 * down the cause of the crash will be able to figure&n;                 * out the call path that was taken.&n;                 */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_trace_task
r_void
id|show_trace_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/* TODO, this is not really useful since its called from&n;&t; * SysRq-T and we don&squot;t have a keyboard.. :) &n;&t; */
)brace
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments. MODULE_RANGE is a guess of how much space is likely&n; * to be vmalloced.&n; */
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
multiline_comment|/*&n; * The output (format, strings and order) is adjusted to be usable with&n; * ksymoops-2.4.1 with some necessary CRIS-specific patches.  Please don&squot;t&n; * change it unless you&squot;re serious about adjusting ksymoops and syncing&n; * with the ksymoops maintainer.&n; */
r_void
DECL|function|show_stack
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
r_int
op_star
id|stack
comma
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * debugging aid: &quot;show_stack(NULL);&quot; prints a&n;&t; * back trace.&n;&t; */
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdsp
c_func
(paren
)paren
suffix:semicolon
)brace
id|stack
op_assign
id|sp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack from %08lx:&bslash;n       &quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
(paren
id|addr
comma
id|stack
)paren
)paren
(brace
multiline_comment|/* This message matches &quot;failing address&quot; marked&n;&t;&t;&t;   s390 in ksymoops, so lines containing it will&n;&t;&t;&t;   not be filtered out by ksymoops.  */
id|printk
(paren
l_string|&quot;Failing address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stack
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
id|addr
)paren
suffix:semicolon
)brace
id|show_trace
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* displays a short stack trace */
r_int
id|show_stack
c_func
(paren
)paren
(brace
r_int
r_int
op_star
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdusp
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack dump [0x%08lx]:&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sp + %d: 0x%08lx&bslash;n&quot;
comma
id|i
op_star
l_int|4
comma
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|show_registers
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* We either use rdusp() - the USP register, which might not&n;&t;   correspond to the current process for all cases we&squot;re called,&n;&t;   or we use the current-&gt;thread.usp, which is not up to date for&n;&t;   the current process.  Experience shows we want the USP&n;&t;   register.  */
r_int
r_int
id|usp
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRP: %08lx SRP: %08lx DCCR: %08lx USP: %08lx MOF: %08lx&bslash;n&quot;
comma
id|regs-&gt;irp
comma
id|regs-&gt;srp
comma
id|regs-&gt;dccr
comma
id|usp
comma
id|regs-&gt;mof
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r0: %08lx  r1: %08lx   r2: %08lx  r3: %08lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r4: %08lx  r5: %08lx   r6: %08lx  r7: %08lx&bslash;n&quot;
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r8: %08lx  r9: %08lx  r10: %08lx r11: %08lx&bslash;n&quot;
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12: %08lx r13: %08lx oR10: %08lx&bslash;n&quot;
comma
id|regs-&gt;r12
comma
id|regs-&gt;r13
comma
id|regs-&gt;orig_r10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R_MMU_CAUSE: %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|R_MMU_CAUSE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;         * When in-kernel, we also print out the stack and code at the&n;         * time of the fault..&n;         */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|show_stack
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|usp
)paren
suffix:semicolon
multiline_comment|/* Dump kernel stack if the previous dump wasn&squot;t one.  */
r_if
c_cond
(paren
id|usp
op_ne
l_int|0
)paren
id|show_stack
(paren
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;irp
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
multiline_comment|/* Often enough the value at regs-&gt;irp does not point to&n;&t;&t;   the interesting instruction, which is most often the&n;&t;&t;   _previous_ instruction.  So we dump at an offset large&n;&t;&t;   enough that instruction decoding should be in sync at&n;&t;&t;   the interesting point, but small enough to fit on a row&n;&t;&t;   (sort of).  We point out the regs-&gt;irp location in a&n;&t;&t;   ksymoops-friendly way by wrapping the byte for that&n;&t;&t;   address in parentheses.  */
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|12
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;irp
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad IP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;(%02x) &quot;
comma
id|c
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Called from entry.S when the watchdog has bitten&n; * We print out something resembling an oops dump, and if&n; * we have the nice doggy development flag set, we halt here&n; * instead of rebooting.&n; */
r_void
DECL|function|watchdog_bite_hook
id|watchdog_bite_hook
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
id|cli
c_func
(paren
)paren
suffix:semicolon
id|stop_watchdog
c_func
(paren
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
macro_line|#else
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/* This is normally the &squot;Oops&squot; routine */
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_extern
r_void
id|reset_watchdog
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|stop_watchdog
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
multiline_comment|/* This printout might take too long and trigger the &n;&t; * watchdog normally. If we&squot;re in the nice doggy&n;&t; * development mode, stop the watchdog during printout.&n;&t; */
id|stop_watchdog
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
id|reset_watchdog
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing needs to be done */
)brace
eof
