multiline_comment|/* $Id: traps.c,v 1.12 2001/05/15 15:46:40 bjornw Exp $&n; *&n; *  linux/arch/cris/traps.c&n; *&n; *  Here we handle the break vectors not used by the system call &n; *  mechanism, as well as some general stack/register dumping &n; *  things.&n; * &n; *  Copyright (C) 2000,2001 Axis Communications AB&n; *&n; *  Authors:   Bjorn Wesen&n; *&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments. MODULE_RANGE is a guess of how much space is likely&n; * to be vmalloced.&n; */
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
r_void
DECL|function|show_stack
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
r_int
op_star
id|stack
comma
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_int
id|i
suffix:semicolon
r_extern
r_char
id|_stext
comma
id|_etext
suffix:semicolon
multiline_comment|/*&n;         * debugging aid: &quot;show_stack(NULL);&quot; prints the&n;         * back trace for this cpu.&n;         */
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdsp
c_func
(paren
)paren
suffix:semicolon
)brace
id|stack
op_assign
id|sp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
id|stack
op_assign
id|sp
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|VMALLOC_START
suffix:semicolon
id|module_end
op_assign
id|VMALLOC_END
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;                 * If the address is either in the text segment of the&n;                 * kernel, or in the region which contains vmalloc&squot;ed&n;                 * memory, it *may* be the address of a calling&n;                 * routine; if so, print it so that someone tracing&n;                 * down the cause of the crash will be able to figure&n;                 * out the call path that was taken.&n;                 */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/* displays a short stack trace */
r_int
id|show_stack
c_func
(paren
)paren
(brace
r_int
r_int
op_star
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdusp
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack dump [0x%08lx]:&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sp + %d: 0x%08lx&bslash;n&quot;
comma
id|i
op_star
l_int|4
comma
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|show_registers
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|usp
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRP: %08lx SRP: %08lx CCR: %08lx USP: %08lx MOF: %08lx&bslash;n&quot;
comma
id|regs-&gt;irp
comma
id|regs-&gt;srp
comma
id|regs-&gt;dccr
comma
id|usp
comma
id|regs-&gt;mof
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r0: %08lx  r1: %08lx  r2: %08lx  r3: %08lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r4: %08lx  r5: %08lx  r6: %08lx  r7: %08lx&bslash;n&quot;
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r8: %08lx  r9: %08lx r10: %08lx r11: %08lx&bslash;n&quot;
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12: %08lx r13: %08lx oR10: %08lx&bslash;n&quot;
comma
id|regs-&gt;r12
comma
id|regs-&gt;r13
comma
id|regs-&gt;orig_r10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
multiline_comment|/* TODO, fix in_kernel detection */
macro_line|#if 0
multiline_comment|/*&n;         * When in-kernel, we also print out the stack and code at the&n;         * time of the fault..&n;         */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack: &quot;
)paren
suffix:semicolon
id|show_stack
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|usp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;irp
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;irp
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad IP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|show_stack
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* print backtrace for kernel stack on this CPU */
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing needs to be done */
)brace
eof
