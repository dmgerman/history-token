multiline_comment|/* $Id: traps.c,v 1.7 2003/07/04 08:27:52 starvik Exp $&n; *&n; *  linux/arch/cris/traps.c&n; *&n; *  Here we handle the break vectors not used by the system call &n; *  mechanism, as well as some general stack/register dumping &n; *  things.&n; * &n; *  Copyright (C) 2000-2002 Axis Communications AB&n; *&n; *  Authors:   Bjorn Wesen&n; *  &t;       Hans-Peter Nilsson&n; *&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|kstack_depth_to_print
r_static
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_int
r_int
op_star
id|stack
)paren
(brace
r_int
r_int
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_extern
r_char
id|_stext
comma
id|_etext
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|VMALLOC_START
suffix:semicolon
id|module_end
op_assign
id|VMALLOC_END
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|__get_user
(paren
id|addr
comma
id|stack
)paren
)paren
(brace
multiline_comment|/* This message matches &quot;failing address&quot; marked&n;&t;&t;&t;   s390 in ksymoops, so lines containing it will&n;&t;&t;&t;   not be filtered out by ksymoops.  */
id|printk
(paren
l_string|&quot;Failing address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;                 * If the address is either in the text segment of the&n;                 * kernel, or in the region which contains vmalloc&squot;ed&n;                 * memory, it *may* be the address of a calling&n;                 * routine; if so, print it so that someone tracing&n;                 * down the cause of the crash will be able to figure&n;                 * out the call path that was taken.&n;                 */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_trace_task
r_void
id|show_trace_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/* TODO, this is not really useful since its called from&n;&t; * SysRq-T and we don&squot;t have a keyboard.. :) &n;&t; */
)brace
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments. MODULE_RANGE is a guess of how much space is likely&n; * to be vmalloced.&n; */
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
multiline_comment|/*&n; * The output (format, strings and order) is adjusted to be usable with&n; * ksymoops-2.4.1 with some necessary CRIS-specific patches.  Please don&squot;t&n; * change it unless you&squot;re serious about adjusting ksymoops and syncing&n; * with the ksymoops maintainer.&n; */
r_void
DECL|function|show_stack
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
r_int
op_star
id|stack
comma
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * debugging aid: &quot;show_stack(NULL);&quot; prints a&n;&t; * back trace.&n;&t; */
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|task
)paren
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|task-&gt;thread.ksp
suffix:semicolon
r_else
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdsp
c_func
(paren
)paren
suffix:semicolon
)brace
id|stack
op_assign
id|sp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack from %08lx:&bslash;n       &quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
(paren
id|addr
comma
id|stack
)paren
)paren
(brace
multiline_comment|/* This message matches &quot;failing address&quot; marked&n;&t;&t;&t;   s390 in ksymoops, so lines containing it will&n;&t;&t;&t;   not be filtered out by ksymoops.  */
id|printk
(paren
l_string|&quot;Failing address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stack
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
id|addr
)paren
suffix:semicolon
)brace
id|show_trace
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* displays a short stack trace */
r_int
id|show_stack
c_func
(paren
)paren
(brace
r_int
r_int
op_star
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdusp
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack dump [0x%08lx]:&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sp + %d: 0x%08lx&bslash;n&quot;
comma
id|i
op_star
l_int|4
comma
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
id|show_stack
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing needs to be done */
)brace
eof
