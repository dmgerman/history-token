multiline_comment|/* $Id: traps.c,v 1.8 2001/02/23 13:45:20 bjornw Exp $&n; *&n; *  linux/arch/cris/traps.c&n; *&n; *  Here we handle the break vectors not used by the system call &n; *  mechanism, as well as some general stack/register dumping &n; *  things.&n; * &n; *  Copyright (C) 2000,2001 Axis Communications AB&n; *&n; *  Authors:   Bjorn Wesen&n; *             Orjan Friberg&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments. MODULE_RANGE is a guess of how much space is likely&n; * to be vmalloced.&n; */
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
r_void
DECL|function|show_stack
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
r_int
op_star
id|stack
comma
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_int
id|i
suffix:semicolon
r_extern
r_char
id|_stext
comma
id|_etext
suffix:semicolon
singleline_comment|// debugging aid: &quot;show_stack(NULL);&quot; prints the
singleline_comment|// back trace for this cpu.
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdsp
c_func
(paren
)paren
suffix:semicolon
)brace
id|stack
op_assign
id|sp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
id|stack
op_assign
id|sp
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|VMALLOC_START
suffix:semicolon
id|module_end
op_assign
id|VMALLOC_END
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;                 * If the address is either in the text segment of the&n;                 * kernel, or in the region which contains vmalloc&squot;ed&n;                 * memory, it *may* be the address of a calling&n;                 * routine; if so, print it so that someone tracing&n;                 * down the cause of the crash will be able to figure&n;                 * out the call path that was taken.&n;                 */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/* displays a short stack trace */
r_int
id|show_stack
c_func
(paren
)paren
(brace
r_int
r_int
op_star
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|rdusp
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack dump [0x%08lx]:&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sp + %d: 0x%08lx&bslash;n&quot;
comma
id|i
op_star
l_int|4
comma
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|show_registers
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|usp
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRP: %08lx SRP: %08lx CCR: %08lx USP: %08lx&bslash;n&quot;
comma
id|regs-&gt;irp
comma
id|regs-&gt;srp
comma
id|regs-&gt;dccr
comma
id|usp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r0: %08lx  r1: %08lx  r2: %08lx  r3: %08lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r4: %08lx  r5: %08lx  r6: %08lx  r7: %08lx&bslash;n&quot;
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r8: %08lx  r9: %08lx r10: %08lx r11: %08lx&bslash;n&quot;
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12: %08lx r13: %08lx oR10: %08lx&bslash;n&quot;
comma
id|regs-&gt;r12
comma
id|regs-&gt;r13
comma
id|regs-&gt;orig_r10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
singleline_comment|// TODO, fix in_kernel detection
macro_line|#if 0
multiline_comment|/*&n;         * When in-kernel, we also print out the stack and code at the&n;         * time of the fault..&n;         */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack: &quot;
)paren
suffix:semicolon
id|show_stack
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|usp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;irp
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;irp
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad IP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|show_stack
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* print backtrace for kernel stack on this CPU */
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/* Use static variables instead of the stack for temporary storage.  */
DECL|variable|saved_r0
r_static
r_int
id|saved_r0
op_assign
l_int|0
suffix:semicolon
DECL|variable|saved_dccr
r_static
r_int
id|saved_dccr
op_assign
l_int|0
suffix:semicolon
id|asm
(paren
"&quot;"
dot
id|global
id|_gdb_handle_breakpoint
dot
id|global
id|_do_sigtrap
id|_gdb_handle_breakpoint
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|This
id|handles
id|a
r_break
id|instruction
r_for
id|entering
id|a
id|debug
id|session
dot
suffix:semicolon
suffix:semicolon
id|move
id|dccr
comma
(braket
id|_saved_dccr
)braket
suffix:semicolon
id|Save
id|dccr
dot
id|move.d
id|r0
comma
(braket
id|_saved_r0
)braket
suffix:semicolon
id|Save
id|r0
dot
"&quot;"
macro_line|#ifdef CONFIG_KGDB
"&quot;"
id|move
id|ccr
comma
id|r0
id|btstq
l_int|8
comma
id|r0
suffix:semicolon
id|Test
id|the
id|U
op_minus
id|flag
dot
id|bmi
id|_ugdb_handle_breakpoint
suffix:semicolon
id|Go
id|to
id|user
id|mode
id|debugging
dot
id|nop
suffix:semicolon
id|Delay
id|slot
dot
id|move.d
(braket
id|_saved_r0
)braket
comma
id|r0
suffix:semicolon
id|Restore
id|r0
dot
id|move
(braket
id|_saved_dccr
)braket
comma
id|dccr
suffix:semicolon
id|Restore
id|dccr
dot
id|ba
id|_kgdb_handle_breakpoint
suffix:semicolon
id|Go
id|to
id|kernel
id|debugging
dot
id|nop
suffix:semicolon
id|Delay
id|slot
dot
"&quot;"
macro_line|#endif
"&quot;"
id|_ugdb_handle_breakpoint
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Yes
comma
id|we
id|could
r_do
id|a
l_char|&squot;push brp&squot;
id|here
op_logical_and
id|let
id|gdb
id|adjust
id|the
id|pc
id|once
id|it
suffix:semicolon
suffix:semicolon
id|starts
id|talking
id|to
id|the
id|target
id|again
comma
id|but
id|this
id|way
id|we
id|avoid
id|a
l_char|&squot;P&squot;
id|packet
dot
suffix:semicolon
suffix:semicolon
id|move
id|brp
comma
id|r0
suffix:semicolon
id|Use
id|r0
id|temporarily
r_for
id|calculation
dot
id|subq
l_int|2
comma
id|r0
suffix:semicolon
id|Set
id|to
id|address
id|of
id|previous
id|instruction
dot
id|move
id|r0
comma
id|brp
suffix:semicolon
id|Restore
r_new
id|brp
dot
id|move.d
(braket
id|_saved_r0
)braket
comma
id|r0
suffix:semicolon
id|Restore
id|r0
dot
id|move
(braket
id|_saved_dccr
)braket
comma
id|dccr
suffix:semicolon
id|Restore
id|dccr
dot
id|_do_sigtrap
suffix:colon
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|SIGTRAP
id|the
id|process
id|that
id|executed
id|the
r_break
id|instruction
dot
suffix:semicolon
suffix:semicolon
id|Make
id|a
id|frame
id|that
id|Rexit
id|in
id|entry.S
id|expects
dot
suffix:semicolon
suffix:semicolon
id|push
id|brp
suffix:semicolon
id|Push
id|breakpoint
r_return
id|pointer
dot
id|push
id|srp
suffix:semicolon
id|Push
id|subroutine
r_return
id|pointer
dot
id|push
id|dccr
suffix:semicolon
id|Push
id|condition
id|codes
dot
id|push
id|mof
suffix:semicolon
id|Push
id|multiply
id|overflow
id|reg
dot
id|di
suffix:semicolon
id|Need
id|to
id|disable
id|irq
"&squot;"
id|s
id|at
id|this
id|point
dot
id|subq
l_int|14
op_star
l_int|4
comma
id|sp
suffix:semicolon
id|Make
id|room
r_for
id|r0
op_minus
id|r13
dot
id|movem
id|r13
comma
(braket
id|sp
)braket
suffix:semicolon
id|Push
id|the
id|r0
op_minus
id|r13
id|registers
dot
id|push
id|r10
suffix:semicolon
id|Push
id|orig_r10
dot
id|clear.d
(braket
id|sp
op_assign
id|sp
op_minus
l_int|4
)braket
suffix:semicolon
id|Frametype
op_minus
id|this
id|is
id|a
id|normal
id|stackframe
dot
id|movs.w
op_minus
l_int|8192
comma
id|r9
suffix:semicolon
id|THREAD_SIZE
op_eq
l_int|8192
op_logical_and
dot
id|d
id|sp
comma
id|r9
id|move.d
(braket
id|r9
op_plus
id|LTASK_PID
)braket
comma
id|r10
suffix:semicolon
id|current-&gt;pid
id|as
id|arg1
dot
id|moveq
l_int|5
comma
id|r11
suffix:semicolon
id|SIGTRAP
id|as
id|arg2
dot
id|jsr
id|_sys_kill
id|jump
id|_ret_from_intr
suffix:semicolon
id|Use
id|the
r_return
id|routine
r_for
id|interrupts
dot
"&quot;"
)paren
suffix:semicolon
eof
