multiline_comment|/* $Id: fasttimer.c,v 1.6 2004/05/14 10:18:39 starvik Exp $&n; * linux/arch/cris/kernel/fasttimer.c&n; *&n; * Fast timers for ETRAX100/ETRAX100LX&n; * This may be useful in other OS than Linux so use 2 space indentation...&n; *&n; * $Log: fasttimer.c,v $&n; * Revision 1.6  2004/05/14 10:18:39  starvik&n; * Export fast_timer_list&n; *&n; * Revision 1.5  2004/05/14 07:58:01  starvik&n; * Merge of changes from 2.4&n; *&n; * Revision 1.4  2003/07/04 08:27:41  starvik&n; * Merge of Linux 2.5.74&n; *&n; * Revision 1.3  2002/12/12 08:26:32  starvik&n; * Don&squot;t use C-comments inside CVS comments&n; *&n; * Revision 1.2  2002/12/11 15:42:02  starvik&n; * Extracted v10 (ETRAX 100LX) specific stuff from arch/cris/kernel/&n; *&n; * Revision 1.1  2002/11/18 07:58:06  starvik&n; * Fast timers (from Linux 2.4)&n; *&n; * Revision 1.5  2002/10/15 06:21:39  starvik&n; * Added call to init_waitqueue_head&n; *&n; * Revision 1.4  2002/05/28 17:47:59  johana&n; * Added del_fast_timer()&n; *&n; * Revision 1.3  2002/05/28 16:16:07  johana&n; * Handle empty fast_timer_list&n; *&n; * Revision 1.2  2002/05/27 15:38:42  johana&n; * Made it compile without warnings on Linux 2.4.&n; * (includes, wait_queue, PROC_FS and snprintf)&n; *&n; * Revision 1.1  2002/05/27 15:32:25  johana&n; * arch/etrax100/kernel/fasttimer.c v1.8 from the elinux tree.&n; *&n; * Revision 1.8  2001/11/27 13:50:40  pkj&n; * Disable interrupts while stopping the timer and while modifying the&n; * list of active timers in timer1_handler() as it may be interrupted&n; * by other interrupts (e.g., the serial interrupt) which may add fast&n; * timers.&n; *&n; * Revision 1.7  2001/11/22 11:50:32  pkj&n; * * Only store information about the last 16 timers.&n; * * proc_fasttimer_read() now uses an allocated buffer, since it&n; *   requires more space than just a page even for only writing the&n; *   last 16 timers. The buffer is only allocated on request, so&n; *   unless /proc/fasttimer is read, it is never allocated.&n; * * Renamed fast_timer_started to fast_timers_started to match&n; *   fast_timers_added and fast_timers_expired.&n; * * Some clean-up.&n; *&n; * Revision 1.6  2000/12/13 14:02:08  johana&n; * Removed volatile for fast_timer_list&n; *&n; * Revision 1.5  2000/12/13 13:55:35  johana&n; * Added DEBUG_LOG, added som cli() and cleanup&n; *&n; * Revision 1.4  2000/12/05 13:48:50  johana&n; * Added range check when writing proc file, modified timer int handling&n; *&n; * Revision 1.3  2000/11/23 10:10:20  johana&n; * More debug/logging possibilities.&n; * Moved GET_JIFFIES_USEC() to timex.h and time.c&n; *&n; * Revision 1.2  2000/11/01 13:41:04  johana&n; * Clean up and bugfixes.&n; * Created new do_gettimeofday_fast() that gets a timeval struct&n; * with time based on jiffies and *R_TIMER0_DATA, uses a table&n; * for fast conversion of timer value to microseconds.&n; * (Much faster the standard do_gettimeofday() and we don&squot;t really&n; * wan&squot;t to use the true time - we wan&squot;t the &quot;uptime&quot; so timers don&squot;t screw up&n; * when we change the time.&n; * TODO: Add efficient support for continuous timers as well.&n; *&n; * Revision 1.1  2000/10/26 15:49:16  johana&n; * Added fasttimer, highresolution timers.&n; *&n; * Copyright (C) 2000,2001 2002 Axis Communications AB, Lund, Sweden&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/rtc.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
macro_line|#include &lt;asm/fasttimer.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|macro|DEBUG_LOG_INCLUDED
mdefine_line|#define DEBUG_LOG_INCLUDED
DECL|macro|FAST_TIMER_LOG
mdefine_line|#define FAST_TIMER_LOG
singleline_comment|//#define FAST_TIMER_TEST
DECL|macro|FAST_TIMER_SANITY_CHECKS
mdefine_line|#define FAST_TIMER_SANITY_CHECKS
macro_line|#ifdef FAST_TIMER_SANITY_CHECKS
DECL|macro|SANITYCHECK
mdefine_line|#define SANITYCHECK(x) x
DECL|variable|sanity_failed
r_static
r_int
id|sanity_failed
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|macro|SANITYCHECK
mdefine_line|#define SANITYCHECK(x)
macro_line|#endif
DECL|macro|D1
mdefine_line|#define D1(x)
DECL|macro|D2
mdefine_line|#define D2(x)
DECL|macro|DP
mdefine_line|#define DP(x)
DECL|macro|__INLINE__
mdefine_line|#define __INLINE__ inline
DECL|variable|fast_timer_running
r_static
r_int
id|fast_timer_running
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timers_added
r_static
r_int
id|fast_timers_added
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timers_started
r_static
r_int
id|fast_timers_started
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timers_expired
r_static
r_int
id|fast_timers_expired
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timers_deleted
r_static
r_int
id|fast_timers_deleted
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timer_is_init
r_static
r_int
id|fast_timer_is_init
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timer_ints
r_static
r_int
id|fast_timer_ints
op_assign
l_int|0
suffix:semicolon
DECL|variable|fast_timer_list
r_struct
id|fast_timer
op_star
id|fast_timer_list
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG_LOG_INCLUDED
DECL|macro|DEBUG_LOG_MAX
mdefine_line|#define DEBUG_LOG_MAX 128
DECL|variable|debug_log_string
r_static
r_const
r_char
op_star
id|debug_log_string
(braket
id|DEBUG_LOG_MAX
)braket
suffix:semicolon
DECL|variable|debug_log_value
r_static
r_int
r_int
id|debug_log_value
(braket
id|DEBUG_LOG_MAX
)braket
suffix:semicolon
DECL|variable|debug_log_cnt
r_static
r_int
id|debug_log_cnt
op_assign
l_int|0
suffix:semicolon
DECL|variable|debug_log_cnt_wrapped
r_static
r_int
id|debug_log_cnt_wrapped
op_assign
l_int|0
suffix:semicolon
DECL|macro|DEBUG_LOG
mdefine_line|#define DEBUG_LOG(string, value) &bslash;&n;{ &bslash;&n;  unsigned long log_flags; &bslash;&n;  save_flags(log_flags); &bslash;&n;  cli(); &bslash;&n;  debug_log_string[debug_log_cnt] = (string); &bslash;&n;  debug_log_value[debug_log_cnt] = (unsigned long)(value); &bslash;&n;  if (++debug_log_cnt &gt;= DEBUG_LOG_MAX) &bslash;&n;  { &bslash;&n;    debug_log_cnt = debug_log_cnt % DEBUG_LOG_MAX; &bslash;&n;    debug_log_cnt_wrapped = 1; &bslash;&n;  } &bslash;&n;  restore_flags(log_flags); &bslash;&n;}
macro_line|#else
DECL|macro|DEBUG_LOG
mdefine_line|#define DEBUG_LOG(string, value)
macro_line|#endif
multiline_comment|/* The frequencies for index = clkselx number in R_TIMER_CTRL */
DECL|macro|NUM_TIMER_FREQ
mdefine_line|#define NUM_TIMER_FREQ 15
DECL|macro|MAX_USABLE_TIMER_FREQ
mdefine_line|#define MAX_USABLE_TIMER_FREQ 7
DECL|macro|MAX_DELAY_US
mdefine_line|#define MAX_DELAY_US  853333L
DECL|variable|timer_freq_100
r_const
r_int
r_int
id|timer_freq_100
(braket
id|NUM_TIMER_FREQ
)braket
op_assign
(brace
l_int|3
comma
multiline_comment|/* 0 3333 - 853333 us */
l_int|6
comma
multiline_comment|/* 1 1666 - 426666 us */
l_int|12
comma
multiline_comment|/* 2  833 - 213333 us */
l_int|24
comma
multiline_comment|/* 3  416 - 106666 us */
l_int|48
comma
multiline_comment|/* 4  208 -  53333 us */
l_int|96
comma
multiline_comment|/* 5  104 -  26666 us */
l_int|192
comma
multiline_comment|/* 6   52 -  13333 us */
l_int|384
comma
multiline_comment|/* 7   26 -   6666 us */
l_int|576
comma
l_int|1152
comma
l_int|2304
comma
l_int|4608
comma
l_int|9216
comma
l_int|18432
comma
l_int|62500
comma
multiline_comment|/* 15 = cascade */
)brace
suffix:semicolon
DECL|macro|NUM_TIMER_STATS
mdefine_line|#define NUM_TIMER_STATS 16
macro_line|#ifdef FAST_TIMER_LOG
DECL|variable|timer_added_log
r_struct
id|fast_timer
id|timer_added_log
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
DECL|variable|timer_started_log
r_struct
id|fast_timer
id|timer_started_log
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
DECL|variable|timer_expired_log
r_struct
id|fast_timer
id|timer_expired_log
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
macro_line|#endif
DECL|variable|timer_div_settings
r_int
id|timer_div_settings
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
DECL|variable|timer_freq_settings
r_int
id|timer_freq_settings
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
DECL|variable|timer_delay_settings
r_int
id|timer_delay_settings
(braket
id|NUM_TIMER_STATS
)braket
suffix:semicolon
multiline_comment|/* Not true gettimeofday, only checks the jiffies (uptime) + useconds */
DECL|function|do_gettimeofday_fast
r_void
id|__INLINE__
id|do_gettimeofday_fast
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
r_int
r_int
id|sec
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|usec
op_assign
id|GET_JIFFIES_USEC
c_func
(paren
)paren
suffix:semicolon
id|usec
op_add_assign
(paren
id|sec
op_mod
id|HZ
)paren
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
id|sec
op_assign
id|sec
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|usec
OG
l_int|1000000
)paren
(brace
id|usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|sec
op_increment
suffix:semicolon
)brace
id|tv-&gt;tv_sec
op_assign
id|sec
suffix:semicolon
id|tv-&gt;tv_usec
op_assign
id|usec
suffix:semicolon
)brace
DECL|function|timeval_cmp
r_int
id|__INLINE__
id|timeval_cmp
c_func
(paren
r_struct
id|timeval
op_star
id|t0
comma
r_struct
id|timeval
op_star
id|t1
)paren
(brace
r_if
c_cond
(paren
id|t0-&gt;tv_sec
OL
id|t1-&gt;tv_sec
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t0-&gt;tv_sec
OG
id|t1-&gt;tv_sec
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t0-&gt;tv_usec
OL
id|t1-&gt;tv_usec
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t0-&gt;tv_usec
OG
id|t1-&gt;tv_usec
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|start_timer1
r_void
id|__INLINE__
id|start_timer1
c_func
(paren
r_int
r_int
id|delay_us
)paren
(brace
r_int
id|freq_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is the lowest resolution */
r_int
r_int
id|upper_limit
op_assign
id|MAX_DELAY_US
suffix:semicolon
r_int
r_int
id|div
suffix:semicolon
multiline_comment|/* Start/Restart the timer to the new shorter value */
multiline_comment|/* t = 1/freq = 1/19200 = 53us&n;   * T=div*t,  div = T/t = delay_us*freq/1000000&n;   */
macro_line|#if 1 /* Adaptive timer settings */
r_while
c_loop
(paren
id|delay_us
OL
id|upper_limit
op_logical_and
id|freq_index
OL
id|MAX_USABLE_TIMER_FREQ
)paren
(brace
id|freq_index
op_increment
suffix:semicolon
id|upper_limit
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Divide by 2 using shift */
)brace
r_if
c_cond
(paren
id|freq_index
OG
l_int|0
)paren
(brace
id|freq_index
op_decrement
suffix:semicolon
)brace
macro_line|#else
id|freq_index
op_assign
l_int|6
suffix:semicolon
macro_line|#endif
id|div
op_assign
id|delay_us
op_star
id|timer_freq_100
(braket
id|freq_index
)braket
op_div
l_int|10000
suffix:semicolon
r_if
c_cond
(paren
id|div
OL
l_int|2
)paren
(brace
multiline_comment|/* Maybe increase timer freq? */
id|div
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|div
OG
l_int|255
)paren
(brace
id|div
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This means 256, the max the timer takes */
multiline_comment|/* If a longer timeout than the timer can handle is used,&n;     * then we must restart it when it goes off.&n;     */
)brace
id|timer_div_settings
(braket
id|fast_timers_started
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
id|div
suffix:semicolon
id|timer_freq_settings
(braket
id|fast_timers_started
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
id|freq_index
suffix:semicolon
id|timer_delay_settings
(braket
id|fast_timers_started
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
id|delay_us
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;start_timer1 : %d us freq: %i div: %i&bslash;n&quot;
comma
id|delay_us
comma
id|freq_index
comma
id|div
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear timer1 irq */
op_star
id|R_IRQ_MASK0_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|timer1
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* Set timer values */
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
(paren
id|r_timer_ctrl_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
)paren
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
id|div
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|stop_ld
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|freq_index
)paren
suffix:semicolon
multiline_comment|/* 6=c19k2Hz */
multiline_comment|/* Ack interrupt */
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* Start timer */
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
(paren
id|r_timer_ctrl_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
)paren
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|run
)paren
suffix:semicolon
multiline_comment|/* Enable timer1 irq */
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|timer1
comma
id|set
)paren
suffix:semicolon
id|fast_timers_started
op_increment
suffix:semicolon
id|fast_timer_running
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* In version 1.4 this function takes 27 - 50 us */
DECL|function|start_one_shot_timer
r_void
id|start_one_shot_timer
c_func
(paren
r_struct
id|fast_timer
op_star
id|t
comma
id|fast_timer_function_type
op_star
id|function
comma
r_int
r_int
id|data
comma
r_int
r_int
id|delay_us
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|fast_timer
op_star
id|tmp
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;sft %s %d us&bslash;n&quot;
comma
id|name
comma
id|delay_us
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|t-&gt;tv_set
)paren
suffix:semicolon
id|tmp
op_assign
id|fast_timer_list
suffix:semicolon
id|SANITYCHECK
c_func
(paren
(brace
multiline_comment|/* Check so this is not in the list already... */
r_while
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
r_if
(paren
id|tmp
op_eq
id|t
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;timer name: %s data: 0x%08lX already in list!&bslash;n&quot;
comma
id|name
comma
id|data
)paren
suffix:semicolon
id|sanity_failed
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|fast_timer_list
suffix:semicolon
)brace
)paren
suffix:semicolon
id|t-&gt;delay_us
op_assign
id|delay_us
suffix:semicolon
id|t-&gt;function
op_assign
id|function
suffix:semicolon
id|t-&gt;data
op_assign
id|data
suffix:semicolon
id|t-&gt;name
op_assign
id|name
suffix:semicolon
id|t-&gt;tv_expires.tv_usec
op_assign
id|t-&gt;tv_set.tv_usec
op_plus
id|delay_us
op_mod
l_int|1000000
suffix:semicolon
id|t-&gt;tv_expires.tv_sec
op_assign
id|t-&gt;tv_set.tv_sec
op_plus
id|delay_us
op_div
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;tv_expires.tv_usec
OG
l_int|1000000
)paren
(brace
id|t-&gt;tv_expires.tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|t-&gt;tv_expires.tv_sec
op_increment
suffix:semicolon
)brace
macro_line|#ifdef FAST_TIMER_LOG
id|timer_added_log
(braket
id|fast_timers_added
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
op_star
id|t
suffix:semicolon
macro_line|#endif
id|fast_timers_added
op_increment
suffix:semicolon
multiline_comment|/* Check if this should timeout before anything else */
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
op_logical_or
id|timeval_cmp
c_func
(paren
op_amp
id|t-&gt;tv_expires
comma
op_amp
id|tmp-&gt;tv_expires
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Put first in list and modify the timer value */
id|t-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;next
op_assign
id|fast_timer_list
suffix:semicolon
r_if
c_cond
(paren
id|fast_timer_list
)paren
(brace
id|fast_timer_list-&gt;prev
op_assign
id|t
suffix:semicolon
)brace
id|fast_timer_list
op_assign
id|t
suffix:semicolon
macro_line|#ifdef FAST_TIMER_LOG
id|timer_started_log
(braket
id|fast_timers_started
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
op_star
id|t
suffix:semicolon
macro_line|#endif
id|start_timer1
c_func
(paren
id|delay_us
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Put in correct place in list */
r_while
c_loop
(paren
id|tmp-&gt;next
op_logical_and
id|timeval_cmp
c_func
(paren
op_amp
id|t-&gt;tv_expires
comma
op_amp
id|tmp-&gt;next-&gt;tv_expires
)paren
OG
l_int|0
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Insert t after tmp */
id|t-&gt;prev
op_assign
id|tmp
suffix:semicolon
id|t-&gt;next
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;next
)paren
(brace
id|tmp-&gt;next-&gt;prev
op_assign
id|t
suffix:semicolon
)brace
id|tmp-&gt;next
op_assign
id|t
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;start_one_shot_timer: %d us done&bslash;n&quot;
comma
id|delay_us
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* start_one_shot_timer */
DECL|function|fast_timer_pending
r_static
r_inline
r_int
id|fast_timer_pending
(paren
r_const
r_struct
id|fast_timer
op_star
id|t
)paren
(brace
r_return
(paren
id|t-&gt;next
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|t-&gt;prev
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|t
op_eq
id|fast_timer_list
)paren
suffix:semicolon
)brace
DECL|function|detach_fast_timer
r_static
r_inline
r_int
id|detach_fast_timer
(paren
r_struct
id|fast_timer
op_star
id|t
)paren
(brace
r_struct
id|fast_timer
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fast_timer_pending
c_func
(paren
id|t
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|next
op_assign
id|t-&gt;next
suffix:semicolon
id|prev
op_assign
id|t-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_else
id|fast_timer_list
op_assign
id|next
suffix:semicolon
id|fast_timers_deleted
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|del_fast_timer
r_int
id|del_fast_timer
c_func
(paren
r_struct
id|fast_timer
op_star
id|t
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|detach_fast_timer
c_func
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;next
op_assign
id|t-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* del_fast_timer */
multiline_comment|/* Interrupt routines or functions called in interrupt context */
multiline_comment|/* Timer 1 interrupt handler */
r_static
id|irqreturn_t
DECL|function|timer1_handler
id|timer1_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|fast_timer
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear timer1 irq */
op_star
id|R_IRQ_MASK0_CLR
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_CLR
comma
id|timer1
comma
id|clr
)paren
suffix:semicolon
multiline_comment|/* First stop timer, then ack interrupt */
multiline_comment|/* Stop timer */
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
(paren
id|r_timer_ctrl_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
)paren
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|stop_ld
)paren
suffix:semicolon
multiline_comment|/* Ack interrupt */
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|clr
)paren
suffix:semicolon
id|fast_timer_running
op_assign
l_int|0
suffix:semicolon
id|fast_timer_ints
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|t
op_assign
id|fast_timer_list
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
multiline_comment|/* Has it really expired? */
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;t: %is %06ius&bslash;n&quot;
comma
id|tv.tv_sec
comma
id|tv.tv_usec
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeval_cmp
c_func
(paren
op_amp
id|t-&gt;tv_expires
comma
op_amp
id|tv
)paren
op_le
l_int|0
)paren
(brace
multiline_comment|/* Yes it has expired */
macro_line|#ifdef FAST_TIMER_LOG
id|timer_expired_log
(braket
id|fast_timers_expired
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
op_star
id|t
suffix:semicolon
macro_line|#endif
id|fast_timers_expired
op_increment
suffix:semicolon
multiline_comment|/* Remove this timer before call, since it may reuse the timer */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;prev
)paren
(brace
id|t-&gt;prev-&gt;next
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|fast_timer_list
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;next
)paren
(brace
id|t-&gt;next-&gt;prev
op_assign
id|t-&gt;prev
suffix:semicolon
)brace
id|t-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;function
op_ne
l_int|NULL
)paren
(brace
id|t
op_member_access_from_pointer
id|function
c_func
(paren
id|t-&gt;data
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG_LOG
c_func
(paren
l_string|&quot;!timer1 %i function==NULL!&bslash;n&quot;
comma
id|fast_timer_ints
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Timer is to early, let&squot;s set it again using the normal routines */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t
op_assign
id|fast_timer_list
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Start next timer.. */
r_int
id|us
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|us
op_assign
(paren
(paren
id|t-&gt;tv_expires.tv_sec
op_minus
id|tv.tv_sec
)paren
op_star
l_int|1000000
op_plus
id|t-&gt;tv_expires.tv_usec
op_minus
id|tv.tv_usec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fast_timer_running
)paren
(brace
macro_line|#ifdef FAST_TIMER_LOG
id|timer_started_log
(braket
id|fast_timers_started
op_mod
id|NUM_TIMER_STATS
)braket
op_assign
op_star
id|t
suffix:semicolon
macro_line|#endif
id|start_timer1
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Timer already expired, let&squot;s handle it better late than never.&n;         * The normal loop handles it&n;         */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;e! %d&bslash;n&quot;
comma
id|us
)paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;t1 stop!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|wake_up_func
r_static
r_void
id|wake_up_func
c_func
(paren
r_int
r_int
id|data
)paren
(brace
macro_line|#ifdef DECLARE_WAITQUEUE
id|wait_queue_head_t
op_star
id|sleep_wait_p
op_assign
(paren
id|wait_queue_head_t
op_star
)paren
id|data
suffix:semicolon
macro_line|#else
r_struct
id|wait_queue
op_star
op_star
id|sleep_wait_p
op_assign
(paren
r_struct
id|wait_queue
op_star
op_star
)paren
id|data
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
id|sleep_wait_p
)paren
suffix:semicolon
)brace
multiline_comment|/* Useful API */
DECL|function|schedule_usleep
r_void
id|schedule_usleep
c_func
(paren
r_int
r_int
id|us
)paren
(brace
r_struct
id|fast_timer
id|t
suffix:semicolon
macro_line|#ifdef DECLARE_WAITQUEUE
id|wait_queue_head_t
id|sleep_wait
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sleep_wait
)paren
suffix:semicolon
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#else
r_struct
id|wait_queue
op_star
id|sleep_wait
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;schedule_usleep(%d)&bslash;n&quot;
comma
id|us
)paren
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sleep_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|t
comma
id|wake_up_func
comma
(paren
r_int
r_int
)paren
op_amp
id|sleep_wait
comma
id|us
comma
l_string|&quot;usleep&quot;
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sleep_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;done schedule_usleep(%d)&bslash;n&quot;
comma
id|us
)paren
)paren
suffix:semicolon
macro_line|#ifdef DECLARE_WAITQUEUE
)brace
macro_line|#endif  
)brace
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|proc_fasttimer_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data_unused
macro_line|#else
comma
r_int
id|unused
macro_line|#endif
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
DECL|variable|fasttimer_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|fasttimer_proc_entry
suffix:semicolon
macro_line|#else
DECL|variable|fasttimer_proc_entry
r_static
r_struct
id|proc_dir_entry
id|fasttimer_proc_entry
op_assign
(brace
l_int|0
comma
l_int|9
comma
l_string|&quot;fasttimer&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
multiline_comment|/* ops -- default to array */
comma
op_amp
id|proc_fasttimer_read
multiline_comment|/* get_info */
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* This value is very much based on testing */
DECL|macro|BIG_BUF_SIZE
mdefine_line|#define BIG_BUF_SIZE (500 + NUM_TIMER_STATS * 300)
DECL|function|proc_fasttimer_read
r_static
r_int
id|proc_fasttimer_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data_unused
macro_line|#else
comma
r_int
id|unused
macro_line|#endif
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|num_to_show
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
r_struct
id|fast_timer
op_star
id|t
comma
op_star
id|nextt
suffix:semicolon
r_static
r_char
op_star
id|bigbuf
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
r_int
id|used
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bigbuf
op_logical_and
op_logical_neg
(paren
id|bigbuf
op_assign
id|vmalloc
c_func
(paren
id|BIG_BUF_SIZE
)paren
)paren
)paren
(brace
id|used
op_assign
l_int|0
suffix:semicolon
id|bigbuf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|offset
op_logical_or
op_logical_neg
id|used
)paren
(brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|used
op_assign
l_int|0
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timers added:     %i&bslash;n&quot;
comma
id|fast_timers_added
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timers started:   %i&bslash;n&quot;
comma
id|fast_timers_started
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timer interrupts: %i&bslash;n&quot;
comma
id|fast_timer_ints
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timers expired:   %i&bslash;n&quot;
comma
id|fast_timers_expired
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timers deleted:   %i&bslash;n&quot;
comma
id|fast_timers_deleted
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Fast timer running:    %s&bslash;n&quot;
comma
id|fast_timer_running
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Current time:          %lu.%06lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tv.tv_sec
comma
(paren
r_int
r_int
)paren
id|tv.tv_usec
)paren
suffix:semicolon
macro_line|#ifdef FAST_TIMER_SANITY_CHECKS
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Sanity failed:         %i&bslash;n&quot;
comma
id|sanity_failed
)paren
suffix:semicolon
macro_line|#endif
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_LOG_INCLUDED
(brace
r_int
id|end_i
op_assign
id|debug_log_cnt
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug_log_cnt_wrapped
)paren
(brace
id|i
op_assign
id|debug_log_cnt
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|i
op_ne
id|end_i
op_logical_or
(paren
id|debug_log_cnt_wrapped
op_logical_and
op_logical_neg
id|used
)paren
)paren
op_logical_and
id|used
op_plus
l_int|100
OL
id|BIG_BUF_SIZE
)paren
(brace
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
id|debug_log_string
(braket
id|i
)braket
comma
id|debug_log_value
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|DEBUG_LOG_MAX
suffix:semicolon
)brace
)brace
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|num_to_show
op_assign
(paren
id|fast_timers_started
OL
id|NUM_TIMER_STATS
ques
c_cond
id|fast_timers_started
suffix:colon
id|NUM_TIMER_STATS
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Timers started: %i&bslash;n&quot;
comma
id|fast_timers_started
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_to_show
op_logical_and
(paren
id|used
op_plus
l_int|100
OL
id|BIG_BUF_SIZE
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cur
op_assign
(paren
id|fast_timers_started
op_minus
id|i
op_minus
l_int|1
)paren
op_mod
id|NUM_TIMER_STATS
suffix:semicolon
macro_line|#if 1 
singleline_comment|//ndef FAST_TIMER_LOG
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;div: %i freq: %i delay: %i&quot;
l_string|&quot;&bslash;n&quot;
comma
id|timer_div_settings
(braket
id|cur
)braket
comma
id|timer_freq_settings
(braket
id|cur
)braket
comma
id|timer_delay_settings
(braket
id|cur
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef FAST_TIMER_LOG
id|t
op_assign
op_amp
id|timer_started_log
(braket
id|cur
)braket
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;%-14s s: %6lu.%06lu e: %6lu.%06lu &quot;
l_string|&quot;d: %6li us data: 0x%08lX&quot;
l_string|&quot;&bslash;n&quot;
comma
id|t-&gt;name
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_usec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_usec
comma
id|t-&gt;delay_us
comma
id|t-&gt;data
)paren
suffix:semicolon
macro_line|#endif
)brace
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef FAST_TIMER_LOG
id|num_to_show
op_assign
(paren
id|fast_timers_added
OL
id|NUM_TIMER_STATS
ques
c_cond
id|fast_timers_added
suffix:colon
id|NUM_TIMER_STATS
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Timers added: %i&bslash;n&quot;
comma
id|fast_timers_added
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_to_show
op_logical_and
(paren
id|used
op_plus
l_int|100
OL
id|BIG_BUF_SIZE
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t
op_assign
op_amp
id|timer_added_log
(braket
(paren
id|fast_timers_added
op_minus
id|i
op_minus
l_int|1
)paren
op_mod
id|NUM_TIMER_STATS
)braket
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;%-14s s: %6lu.%06lu e: %6lu.%06lu &quot;
l_string|&quot;d: %6li us data: 0x%08lX&quot;
l_string|&quot;&bslash;n&quot;
comma
id|t-&gt;name
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_usec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_usec
comma
id|t-&gt;delay_us
comma
id|t-&gt;data
)paren
suffix:semicolon
)brace
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|num_to_show
op_assign
(paren
id|fast_timers_expired
OL
id|NUM_TIMER_STATS
ques
c_cond
id|fast_timers_expired
suffix:colon
id|NUM_TIMER_STATS
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Timers expired: %i&bslash;n&quot;
comma
id|fast_timers_expired
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_to_show
op_logical_and
(paren
id|used
op_plus
l_int|100
OL
id|BIG_BUF_SIZE
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t
op_assign
op_amp
id|timer_expired_log
(braket
(paren
id|fast_timers_expired
op_minus
id|i
op_minus
l_int|1
)paren
op_mod
id|NUM_TIMER_STATS
)braket
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;%-14s s: %6lu.%06lu e: %6lu.%06lu &quot;
l_string|&quot;d: %6li us data: 0x%08lX&quot;
l_string|&quot;&bslash;n&quot;
comma
id|t-&gt;name
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_usec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_usec
comma
id|t-&gt;delay_us
comma
id|t-&gt;data
)paren
suffix:semicolon
)brace
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;Active timers:&bslash;n&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|fast_timer_list
suffix:semicolon
r_while
c_loop
(paren
id|t
op_ne
l_int|NULL
op_logical_and
(paren
id|used
op_plus
l_int|100
OL
id|BIG_BUF_SIZE
)paren
)paren
(brace
id|nextt
op_assign
id|t-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|used
op_add_assign
id|sprintf
c_func
(paren
id|bigbuf
op_plus
id|used
comma
l_string|&quot;%-14s s: %6lu.%06lu e: %6lu.%06lu &quot;
l_string|&quot;d: %6li us data: 0x%08lX&quot;
multiline_comment|/*                      &quot; func: 0x%08lX&quot; */
l_string|&quot;&bslash;n&quot;
comma
id|t-&gt;name
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_set.tv_usec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_sec
comma
(paren
r_int
r_int
)paren
id|t-&gt;tv_expires.tv_usec
comma
id|t-&gt;delay_us
comma
id|t-&gt;data
multiline_comment|/*                      , t-&gt;function */
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;next
op_ne
id|nextt
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;timer removed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|t
op_assign
id|nextt
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|used
op_minus
id|offset
OL
id|len
)paren
(brace
id|len
op_assign
id|used
op_minus
id|offset
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|bigbuf
op_plus
id|offset
comma
id|len
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buf
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* PROC_FS */
macro_line|#ifdef FAST_TIMER_TEST
DECL|variable|i
r_static
r_volatile
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
DECL|variable|num_test_timeout
r_static
r_volatile
r_int
id|num_test_timeout
op_assign
l_int|0
suffix:semicolon
DECL|variable|tr
r_static
r_struct
id|fast_timer
id|tr
(braket
l_int|10
)braket
suffix:semicolon
DECL|variable|exp_num
r_static
r_int
id|exp_num
(braket
l_int|10
)braket
suffix:semicolon
DECL|variable|tv_exp
r_static
r_struct
id|timeval
id|tv_exp
(braket
l_int|100
)braket
suffix:semicolon
DECL|function|test_timeout
r_static
r_void
id|test_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv_exp
(braket
id|data
)braket
)paren
suffix:semicolon
id|exp_num
(braket
id|data
)braket
op_assign
id|num_test_timeout
suffix:semicolon
id|num_test_timeout
op_increment
suffix:semicolon
)brace
DECL|function|test_timeout1
r_static
r_void
id|test_timeout1
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv_exp
(braket
id|data
)braket
)paren
suffix:semicolon
id|exp_num
(braket
id|data
)braket
op_assign
id|num_test_timeout
suffix:semicolon
r_if
c_cond
(paren
id|data
OL
l_int|7
)paren
(brace
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout1
comma
id|i
comma
l_int|1000
comma
l_string|&quot;timeout1&quot;
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|num_test_timeout
op_increment
suffix:semicolon
)brace
id|DP
c_func
(paren
r_static
r_char
id|buf0
(braket
l_int|2000
)braket
suffix:semicolon
r_static
r_char
id|buf1
(braket
l_int|2000
)braket
suffix:semicolon
r_static
r_char
id|buf2
(braket
l_int|2000
)braket
suffix:semicolon
r_static
r_char
id|buf3
(braket
l_int|2000
)braket
suffix:semicolon
r_static
r_char
id|buf4
(braket
l_int|2000
)braket
suffix:semicolon
)paren
suffix:semicolon
DECL|variable|buf5
r_static
r_char
id|buf5
(braket
l_int|6000
)braket
suffix:semicolon
DECL|variable|j_u
r_static
r_int
id|j_u
(braket
l_int|1000
)braket
suffix:semicolon
DECL|function|fast_timer_test
r_static
r_void
id|fast_timer_test
c_func
(paren
r_void
)paren
(brace
r_int
id|prev_num
suffix:semicolon
r_int
id|j
suffix:semicolon
r_struct
id|timeval
id|tv
comma
id|tv0
comma
id|tv1
comma
id|tv2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fast_timer_test() start&bslash;n&quot;
)paren
suffix:semicolon
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|1000
suffix:semicolon
id|j
op_increment
)paren
(brace
id|j_u
(braket
id|j
)braket
op_assign
id|GET_JIFFIES_USEC
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100
suffix:semicolon
id|j
op_increment
)paren
(brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv_exp
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fast_timer_test() %is %06i&bslash;n&quot;
comma
id|tv.tv_sec
comma
id|tv.tv_usec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|1000
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%i %i %i %i %i&bslash;n&quot;
comma
id|j_u
(braket
id|j
)braket
comma
id|j_u
(braket
id|j
op_plus
l_int|1
)braket
comma
id|j_u
(braket
id|j
op_plus
l_int|2
)braket
comma
id|j_u
(braket
id|j
op_plus
l_int|3
)braket
comma
id|j_u
(braket
id|j
op_plus
l_int|4
)braket
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%i.%i %i.%i %i.%i %i.%i %i.%i&bslash;n&quot;
comma
id|tv_exp
(braket
id|j
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
)braket
dot
id|tv_usec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|1
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|1
)braket
dot
id|tv_usec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|2
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|2
)braket
dot
id|tv_usec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|3
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|3
)braket
dot
id|tv_usec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|4
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
op_plus
l_int|4
)braket
dot
id|tv_usec
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv0
)paren
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout
comma
id|i
comma
l_int|50000
comma
l_string|&quot;test0&quot;
)paren
suffix:semicolon
id|DP
c_func
(paren
id|proc_fasttimer_read
c_func
(paren
id|buf0
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout
comma
id|i
comma
l_int|70000
comma
l_string|&quot;test1&quot;
)paren
suffix:semicolon
id|DP
c_func
(paren
id|proc_fasttimer_read
c_func
(paren
id|buf1
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout
comma
id|i
comma
l_int|40000
comma
l_string|&quot;test2&quot;
)paren
suffix:semicolon
id|DP
c_func
(paren
id|proc_fasttimer_read
c_func
(paren
id|buf2
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout
comma
id|i
comma
l_int|60000
comma
l_string|&quot;test3&quot;
)paren
suffix:semicolon
id|DP
c_func
(paren
id|proc_fasttimer_read
c_func
(paren
id|buf3
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start_one_shot_timer
c_func
(paren
op_amp
id|tr
(braket
id|i
)braket
comma
id|test_timeout1
comma
id|i
comma
l_int|55000
comma
l_string|&quot;test4xx&quot;
)paren
suffix:semicolon
id|DP
c_func
(paren
id|proc_fasttimer_read
c_func
(paren
id|buf4
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv1
)paren
suffix:semicolon
id|proc_fasttimer_read
c_func
(paren
id|buf5
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|prev_num
op_assign
id|num_test_timeout
suffix:semicolon
r_while
c_loop
(paren
id|num_test_timeout
OL
id|i
)paren
(brace
r_if
c_cond
(paren
id|num_test_timeout
op_ne
id|prev_num
)paren
(brace
id|prev_num
op_assign
id|num_test_timeout
suffix:semicolon
)brace
)brace
id|do_gettimeofday_fast
c_func
(paren
op_amp
id|tv2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Timers started    %is %06i&bslash;n&quot;
comma
id|tv0.tv_sec
comma
id|tv0.tv_usec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Timers started at %is %06i&bslash;n&quot;
comma
id|tv1.tv_sec
comma
id|tv1.tv_usec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Timers done       %is %06i&bslash;n&quot;
comma
id|tv2.tv_sec
comma
id|tv2.tv_usec
)paren
suffix:semicolon
id|DP
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;buf0:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf1:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf2:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf3:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf4:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf4
)paren
suffix:semicolon
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf5:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf5
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;timers set:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|fast_timer
op_star
id|t
op_assign
op_amp
id|tr
(braket
id|j
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-10s set: %6is %06ius exp: %6is %06ius &quot;
l_string|&quot;data: 0x%08X func: 0x%08X&bslash;n&quot;
comma
id|t-&gt;name
comma
id|t-&gt;tv_set.tv_sec
comma
id|t-&gt;tv_set.tv_usec
comma
id|t-&gt;tv_expires.tv_sec
comma
id|t-&gt;tv_expires.tv_usec
comma
id|t-&gt;data
comma
id|t-&gt;function
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;           del: %6ius     did exp: %6is %06ius as #%i error: %6li&bslash;n&quot;
comma
id|t-&gt;delay_us
comma
id|tv_exp
(braket
id|j
)braket
dot
id|tv_sec
comma
id|tv_exp
(braket
id|j
)braket
dot
id|tv_usec
comma
id|exp_num
(braket
id|j
)braket
comma
(paren
id|tv_exp
(braket
id|j
)braket
dot
id|tv_sec
op_minus
id|t-&gt;tv_expires.tv_sec
)paren
op_star
l_int|1000000
op_plus
id|tv_exp
(braket
id|j
)braket
dot
id|tv_usec
op_minus
id|t-&gt;tv_expires.tv_usec
)paren
suffix:semicolon
)brace
id|proc_fasttimer_read
c_func
(paren
id|buf5
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buf5 after all done:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf5
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fast_timer_test() done&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fast_timer_init
r_void
id|fast_timer_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* For some reason, request_irq() hangs when called froom time_init() */
r_if
c_cond
(paren
op_logical_neg
id|fast_timer_is_init
)paren
(brace
macro_line|#if 0 &amp;&amp; defined(FAST_TIMER_TEST)
r_int
id|i
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;fast_timer_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0 &amp;&amp; defined(FAST_TIMER_TEST)
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|TIMER0_DIV
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* We must be careful not to get overflow... */
id|printk
c_func
(paren
l_string|&quot;%3i %6u&bslash;n&quot;
comma
id|i
comma
id|timer0_value_us
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
r_if
c_cond
(paren
(paren
id|fasttimer_proc_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;fasttimer&quot;
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
id|fasttimer_proc_entry-&gt;read_proc
op_assign
id|proc_fasttimer_read
suffix:semicolon
macro_line|#else
id|proc_register_dynamic
c_func
(paren
op_amp
id|proc_root
comma
op_amp
id|fasttimer_proc_entry
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* PROC_FS */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|TIMER1_IRQ_NBR
comma
id|timer1_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;fast timer int&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;err: timer1 irq&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|fast_timer_is_init
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef FAST_TIMER_TEST
id|printk
c_func
(paren
l_string|&quot;do test&bslash;n&quot;
)paren
suffix:semicolon
id|fast_timer_test
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
eof
