multiline_comment|/* $Id: traps.c,v 1.2 2003/07/04 08:27:41 starvik Exp $&n; *&n; *  linux/arch/cris/arch-v10/traps.c&n; *&n; *  Heler functions for trap handlers&n; * &n; *  Copyright (C) 2000-2002 Axis Communications AB&n; *&n; *  Authors:   Bjorn Wesen&n; *  &t;       Hans-Peter Nilsson&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/arch/sv_addr_ag.h&gt;
r_void
DECL|function|show_registers
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* We either use rdusp() - the USP register, which might not&n;&t;   correspond to the current process for all cases we&squot;re called,&n;&t;   or we use the current-&gt;thread.usp, which is not up to date for&n;&t;   the current process.  Experience shows we want the USP&n;&t;   register.  */
r_int
r_int
id|usp
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRP: %08lx SRP: %08lx DCCR: %08lx USP: %08lx MOF: %08lx&bslash;n&quot;
comma
id|regs-&gt;irp
comma
id|regs-&gt;srp
comma
id|regs-&gt;dccr
comma
id|usp
comma
id|regs-&gt;mof
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r0: %08lx  r1: %08lx   r2: %08lx  r3: %08lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r4: %08lx  r5: %08lx   r6: %08lx  r7: %08lx&bslash;n&quot;
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; r8: %08lx  r9: %08lx  r10: %08lx r11: %08lx&bslash;n&quot;
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12: %08lx r13: %08lx oR10: %08lx&bslash;n&quot;
comma
id|regs-&gt;r12
comma
id|regs-&gt;r13
comma
id|regs-&gt;orig_r10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R_MMU_CAUSE: %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|R_MMU_CAUSE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;         * When in-kernel, we also print out the stack and code at the&n;         * time of the fault..&n;         */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|show_stack
c_func
(paren
l_int|NULL
comma
(paren
r_int
r_int
op_star
)paren
id|usp
)paren
suffix:semicolon
multiline_comment|/* Dump kernel stack if the previous dump wasn&squot;t one.  */
r_if
c_cond
(paren
id|usp
op_ne
l_int|0
)paren
id|show_stack
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;irp
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
multiline_comment|/* Often enough the value at regs-&gt;irp does not point to&n;&t;&t;   the interesting instruction, which is most often the&n;&t;&t;   _previous_ instruction.  So we dump at an offset large&n;&t;&t;   enough that instruction decoding should be in sync at&n;&t;&t;   the interesting point, but small enough to fit on a row&n;&t;&t;   (sort of).  We point out the regs-&gt;irp location in a&n;&t;&t;   ksymoops-friendly way by wrapping the byte for that&n;&t;&t;   address in parentheses.  */
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|12
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;irp
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad IP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;(%02x) &quot;
comma
id|c
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Called from entry.S when the watchdog has bitten&n; * We print out something resembling an oops dump, and if&n; * we have the nice doggy development flag set, we halt here&n; * instead of rebooting.&n; */
r_extern
r_void
id|reset_watchdog
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|stop_watchdog
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
DECL|function|watchdog_bite_hook
id|watchdog_bite_hook
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|stop_watchdog
c_func
(paren
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
macro_line|#else
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/* This is normally the &squot;Oops&squot; routine */
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
multiline_comment|/* This printout might take too long and trigger the &n;&t; * watchdog normally. If we&squot;re in the nice doggy&n;&t; * development mode, stop the watchdog during printout.&n;&t; */
id|stop_watchdog
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
id|reset_watchdog
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
eof
