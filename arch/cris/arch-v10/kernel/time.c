multiline_comment|/* $Id: time.c,v 1.5 2004/09/29 06:12:46 starvik Exp $&n; *&n; *  linux/arch/cris/arch-v10/kernel/time.c&n; *&n; *  Copyright (C) 1991, 1992, 1995  Linus Torvalds&n; *  Copyright (C) 1999-2002 Axis Communications AB&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/rtc.h&gt;
multiline_comment|/* define this if you need to use print_timestamp */
multiline_comment|/* it will make jiffies at 96 hz instead of 100 hz though */
DECL|macro|USE_CASCADE_TIMERS
macro_line|#undef USE_CASCADE_TIMERS
r_extern
r_void
id|update_xtime_from_cmos
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|set_rtc_mmss
c_func
(paren
r_int
r_int
id|nowtime
)paren
suffix:semicolon
r_extern
r_int
id|setup_irq
c_func
(paren
r_int
comma
r_struct
id|irqaction
op_star
)paren
suffix:semicolon
r_extern
r_int
id|have_rtc
suffix:semicolon
DECL|function|get_ns_in_jiffie
r_int
r_int
id|get_ns_in_jiffie
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|timer_count
comma
id|t1
suffix:semicolon
r_int
r_int
id|presc_count
suffix:semicolon
r_int
r_int
id|ns
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|timer_count
op_assign
op_star
id|R_TIMER0_DATA
suffix:semicolon
id|presc_count
op_assign
op_star
id|R_TIM_PRESC_STATUS
suffix:semicolon
multiline_comment|/* presc_count might be wrapped */
id|t1
op_assign
op_star
id|R_TIMER0_DATA
suffix:semicolon
r_if
c_cond
(paren
id|timer_count
op_ne
id|t1
)paren
(brace
multiline_comment|/* it wrapped, read prescaler again...  */
id|presc_count
op_assign
op_star
id|R_TIM_PRESC_STATUS
suffix:semicolon
id|timer_count
op_assign
id|t1
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|presc_count
op_ge
id|PRESCALE_VALUE
op_div
l_int|2
)paren
(brace
id|presc_count
op_assign
id|PRESCALE_VALUE
op_minus
id|presc_count
op_plus
id|PRESCALE_VALUE
op_div
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|presc_count
op_assign
id|PRESCALE_VALUE
op_minus
id|presc_count
op_minus
id|PRESCALE_VALUE
op_div
l_int|2
suffix:semicolon
)brace
id|ns
op_assign
(paren
(paren
id|TIMER0_DIV
op_minus
id|timer_count
)paren
op_star
(paren
(paren
l_int|1000000000
op_div
id|HZ
)paren
op_div
id|TIMER0_DIV
)paren
)paren
op_plus
(paren
(paren
id|presc_count
)paren
op_star
(paren
l_int|1000000000
op_div
id|PRESCALE_FREQ
)paren
)paren
suffix:semicolon
r_return
id|ns
suffix:semicolon
)brace
DECL|function|do_slow_gettimeoffset
r_int
r_int
id|do_slow_gettimeoffset
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
comma
id|t1
suffix:semicolon
r_int
r_int
id|usec_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|presc_count
suffix:semicolon
r_static
r_int
r_int
id|count_p
op_assign
id|TIMER0_DIV
suffix:semicolon
multiline_comment|/* for the first call after boot */
r_static
r_int
r_int
id|jiffies_p
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * cache volatile jiffies temporarily; we have IRQs turned off. &n;&t; */
r_int
r_int
id|jiffies_t
suffix:semicolon
multiline_comment|/* The timer interrupt comes from Etrax timer 0. In order to get&n;&t; * better precision, we check the current value. It might have&n;&t; * underflowed already though.&n;&t; */
macro_line|#ifndef CONFIG_SVINTO_SIM
multiline_comment|/* Not available in the xsim simulator. */
id|count
op_assign
op_star
id|R_TIMER0_DATA
suffix:semicolon
id|presc_count
op_assign
op_star
id|R_TIM_PRESC_STATUS
suffix:semicolon
multiline_comment|/* presc_count might be wrapped */
id|t1
op_assign
op_star
id|R_TIMER0_DATA
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
id|t1
)paren
(brace
multiline_comment|/* it wrapped, read prescaler again...  */
id|presc_count
op_assign
op_star
id|R_TIM_PRESC_STATUS
suffix:semicolon
id|count
op_assign
id|t1
suffix:semicolon
)brace
macro_line|#else
id|count
op_assign
l_int|0
suffix:semicolon
id|presc_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|jiffies_t
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * avoiding timer inconsistencies (they are rare, but they happen)...&n;&t; * there are one problem that must be avoided here:&n;&t; *  1. the timer counter underflows&n;&t; */
r_if
c_cond
(paren
id|jiffies_t
op_eq
id|jiffies_p
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|count_p
)paren
(brace
multiline_comment|/* Timer wrapped, use new count and prescale &n;&t;&t;&t; * increase the time corresponding to one jiffie&n;&t;&t;&t; */
id|usec_count
op_assign
l_int|1000000
op_div
id|HZ
suffix:semicolon
)brace
)brace
r_else
id|jiffies_p
op_assign
id|jiffies_t
suffix:semicolon
id|count_p
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|presc_count
op_ge
id|PRESCALE_VALUE
op_div
l_int|2
)paren
(brace
id|presc_count
op_assign
id|PRESCALE_VALUE
op_minus
id|presc_count
op_plus
id|PRESCALE_VALUE
op_div
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|presc_count
op_assign
id|PRESCALE_VALUE
op_minus
id|presc_count
op_minus
id|PRESCALE_VALUE
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Convert timer value to usec */
id|usec_count
op_add_assign
(paren
(paren
id|TIMER0_DIV
op_minus
id|count
)paren
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
op_div
id|TIMER0_DIV
)paren
op_plus
(paren
(paren
(paren
id|presc_count
)paren
op_star
(paren
l_int|1000000000
op_div
id|PRESCALE_FREQ
)paren
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_return
id|usec_count
suffix:semicolon
)brace
multiline_comment|/* Excerpt from the Etrax100 HSDD about the built-in watchdog:&n; *&n; * 3.10.4 Watchdog timer&n;&n; * When the watchdog timer is started, it generates an NMI if the watchdog&n; * isn&squot;t restarted or stopped within 0.1 s. If it still isn&squot;t restarted or&n; * stopped after an additional 3.3 ms, the watchdog resets the chip.&n; * The watchdog timer is stopped after reset. The watchdog timer is controlled&n; * by the R_WATCHDOG register. The R_WATCHDOG register contains an enable bit&n; * and a 3-bit key value. The effect of writing to the R_WATCHDOG register is&n; * described in the table below:&n; * &n; *   Watchdog    Value written:&n; *   state:      To enable:  To key:      Operation:&n; *   --------    ----------  -------      ----------&n; *   stopped         0         X          No effect.&n; *   stopped         1       key_val      Start watchdog with key = key_val.&n; *   started         0       ~key         Stop watchdog&n; *   started         1       ~key         Restart watchdog with key = ~key.&n; *   started         X       new_key_val  Change key to new_key_val.&n; * &n; * Note: &squot;~&squot; is the bitwise NOT operator.&n; * &n; */
multiline_comment|/* right now, starting the watchdog is the same as resetting it */
DECL|macro|start_watchdog
mdefine_line|#define start_watchdog reset_watchdog
macro_line|#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)
DECL|variable|watchdog_key
r_static
r_int
id|watchdog_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* arbitrary number */
macro_line|#endif
multiline_comment|/* number of pages to consider &quot;out of memory&quot;. it is normal that the memory&n; * is used though, so put this really low.&n; */
DECL|macro|WATCHDOG_MIN_FREE_PAGES
mdefine_line|#define WATCHDOG_MIN_FREE_PAGES 8
r_void
DECL|function|reset_watchdog
id|reset_watchdog
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)
multiline_comment|/* only keep watchdog happy as long as we have memory left! */
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OG
id|WATCHDOG_MIN_FREE_PAGES
)paren
(brace
multiline_comment|/* reset the watchdog with the inverse of the old key */
id|watchdog_key
op_xor_assign
l_int|0x7
suffix:semicolon
multiline_comment|/* invert key, which is 3 bits */
op_star
id|R_WATCHDOG
op_assign
id|IO_FIELD
c_func
(paren
id|R_WATCHDOG
comma
id|key
comma
id|watchdog_key
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_WATCHDOG
comma
id|enable
comma
id|start
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* stop the watchdog - we still need the correct key */
r_void
DECL|function|stop_watchdog
id|stop_watchdog
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)
id|watchdog_key
op_xor_assign
l_int|0x7
suffix:semicolon
multiline_comment|/* invert key, which is 3 bits */
op_star
id|R_WATCHDOG
op_assign
id|IO_FIELD
c_func
(paren
id|R_WATCHDOG
comma
id|key
comma
id|watchdog_key
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_WATCHDOG
comma
id|enable
comma
id|stop
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/* last time the cmos clock got updated */
DECL|variable|last_rtc_update
r_static
r_int
id|last_rtc_update
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * timer_interrupt() needs to keep up the real-time clock,&n; * as well as call the &quot;do_timer()&quot; routine every clocktick&n; */
singleline_comment|//static unsigned short myjiff; /* used by our debug routine print_timestamp */
r_extern
r_void
id|cris_do_profile
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_inline
id|irqreturn_t
DECL|function|timer_interrupt
id|timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* acknowledge the timer irq */
macro_line|#ifdef USE_CASCADE_TIMERS
op_star
id|R_TIMER_CTRL
op_assign
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
l_int|0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv0
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|cascade0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|clr
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm0
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel0
comma
id|c6250kHz
)paren
suffix:semicolon
macro_line|#else
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|clr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* reset watchdog otherwise it resets us! */
id|reset_watchdog
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* call the real timer interrupt handler */
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
id|cris_do_profile
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Save profiling information */
multiline_comment|/*&n;&t; * If we have an externally synchronized Linux clock, then update&n;&t; * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be&n;&t; * called as close as possible to 500 ms before the new second starts.&n;&t; *&n;&t; * The division here is not time critical since it will run once in &n;&t; * 11 minutes&n;&t; */
r_if
c_cond
(paren
(paren
id|time_status
op_amp
id|STA_UNSYNC
)paren
op_eq
l_int|0
op_logical_and
id|xtime.tv_sec
OG
id|last_rtc_update
op_plus
l_int|660
op_logical_and
(paren
id|xtime.tv_nsec
op_div
l_int|1000
)paren
op_ge
l_int|500000
op_minus
(paren
id|tick_nsec
op_div
l_int|1000
)paren
op_div
l_int|2
op_logical_and
(paren
id|xtime.tv_nsec
op_div
l_int|1000
)paren
op_le
l_int|500000
op_plus
(paren
id|tick_nsec
op_div
l_int|1000
)paren
op_div
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|set_rtc_mmss
c_func
(paren
id|xtime.tv_sec
)paren
op_eq
l_int|0
)paren
id|last_rtc_update
op_assign
id|xtime.tv_sec
suffix:semicolon
r_else
id|last_rtc_update
op_assign
id|xtime.tv_sec
op_minus
l_int|600
suffix:semicolon
multiline_comment|/* do it again in 60 s */
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* timer is SA_SHIRQ so drivers can add stuff to the timer irq chain&n; * it needs to be SA_INTERRUPT to make the jiffies update work properly&n; */
DECL|variable|irq2
r_static
r_struct
id|irqaction
id|irq2
op_assign
(brace
id|timer_interrupt
comma
id|SA_SHIRQ
op_or
id|SA_INTERRUPT
comma
id|CPU_MASK_NONE
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_void
id|__init
DECL|function|time_init
id|time_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* probe for the RTC and read it if it exists &n;&t; * Before the RTC can be probed the loops_per_usec variable needs &n;&t; * to be initialized to make usleep work. A better value for &n;&t; * loops_per_usec is calculated by the kernel later once the &n;&t; * clock has started.  &n;&t; */
id|loops_per_usec
op_assign
l_int|50
suffix:semicolon
r_if
c_cond
(paren
id|RTC_INIT
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* no RTC, start at 1980 */
id|xtime.tv_sec
op_assign
l_int|0
suffix:semicolon
id|xtime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|have_rtc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* get the current time */
id|have_rtc
op_assign
l_int|1
suffix:semicolon
id|update_xtime_from_cmos
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize wall_to_monotonic such that adding it to xtime will yield zero, the&n;&t; * tv_nsec field must be normalized (i.e., 0 &lt;= nsec &lt; NSEC_PER_SEC).&n;&t; */
id|set_normalized_timespec
c_func
(paren
op_amp
id|wall_to_monotonic
comma
op_minus
id|xtime.tv_sec
comma
op_minus
id|xtime.tv_nsec
)paren
suffix:semicolon
multiline_comment|/* Setup the etrax timers&n;&t; * Base frequency is 25000 hz, divider 250 -&gt; 100 HZ&n;&t; * In normal mode, we use timer0, so timer1 is free. In cascade&n;&t; * mode (which we sometimes use for debugging) both timers are used.&n;&t; * Remember that linux/timex.h contains #defines that rely on the&n;&t; * timer settings below (hz and divide factor) !!!&n;&t; */
macro_line|#ifdef USE_CASCADE_TIMERS
op_star
id|R_TIMER_CTRL
op_assign
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
l_int|0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv0
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|stop_ld
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|cascade0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm0
comma
id|stop_ld
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel0
comma
id|c6250kHz
)paren
suffix:semicolon
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
l_int|0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv0
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|cascade0
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm0
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel0
comma
id|c6250kHz
)paren
suffix:semicolon
macro_line|#else
op_star
id|R_TIMER_CTRL
op_assign
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
l_int|192
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv0
comma
id|TIMER0_DIV
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|stop_ld
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|c19k2Hz
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm0
comma
id|stop_ld
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel0
comma
id|flexible
)paren
suffix:semicolon
op_star
id|R_TIMER_CTRL
op_assign
id|r_timer_ctrl_shadow
op_assign
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv1
comma
l_int|192
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TIMER_CTRL
comma
id|timerdiv0
comma
id|TIMER0_DIV
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i1
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm1
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel1
comma
id|c19k2Hz
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|i0
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|tm0
comma
id|run
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TIMER_CTRL
comma
id|clksel0
comma
id|flexible
)paren
suffix:semicolon
op_star
id|R_TIMER_PRESCALE
op_assign
id|PRESCALE_VALUE
suffix:semicolon
macro_line|#endif
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|timer0
comma
id|set
)paren
suffix:semicolon
multiline_comment|/* unmask the timer irq */
multiline_comment|/* now actually register the timer irq handler that calls timer_interrupt() */
id|setup_irq
c_func
(paren
l_int|2
comma
op_amp
id|irq2
)paren
suffix:semicolon
multiline_comment|/* irq 2 is the timer0 irq in etrax */
multiline_comment|/* enable watchdog if we should use one */
macro_line|#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)
id|printk
c_func
(paren
l_string|&quot;Enabling watchdog...&bslash;n&quot;
)paren
suffix:semicolon
id|start_watchdog
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we use the hardware watchdog, we want to trap it as an NMI&n;&t;   and dump registers before it resets us.  For this to happen, we&n;&t;   must set the &quot;m&quot; NMI enable flag (which once set, is unset only&n;&t;   when an NMI is taken).&n;&n;&t;   The same goes for the external NMI, but that doesn&squot;t have any&n;&t;   driver or infrastructure support yet.  */
id|asm
(paren
l_string|&quot;setf m&quot;
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK0_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|watchdog_nmi
comma
id|set
)paren
suffix:semicolon
op_star
id|R_VECT_MASK_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_VECT_MASK_SET
comma
id|nmi
comma
id|set
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
