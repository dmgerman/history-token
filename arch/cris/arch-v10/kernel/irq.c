multiline_comment|/* $Id: irq.c,v 1.2 2004/06/09 05:30:27 starvik Exp $&n; *&n; *&t;linux/arch/cris/kernel/irq.c&n; *&n; *      Copyright (c) 2000-2002 Axis Communications AB&n; *&n; *      Authors: Bjorn Wesen (bjornw@axis.com)&n; *&n; *      This file contains the interrupt vectors and some &n; *      helper functions&n; *&n; */
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
DECL|variable|irq_shortcuts
id|irqvectptr
id|irq_shortcuts
(braket
id|NR_IRQS
)braket
suffix:semicolon
multiline_comment|/* vector of shortcut jumps after the irq prologue */
multiline_comment|/* don&squot;t use set_int_vector, it bypasses the linux interrupt handlers. it is&n; * global just so that the kernel gdb can use it.&n; */
r_void
DECL|function|set_int_vector
id|set_int_vector
c_func
(paren
r_int
id|n
comma
id|irqvectptr
id|addr
)paren
(brace
id|etrax_irv-&gt;v
(braket
id|n
op_plus
l_int|0x20
)braket
op_assign
(paren
id|irqvectptr
)paren
id|addr
suffix:semicolon
)brace
multiline_comment|/* the breakpoint vector is obviously not made just like the normal irq handlers&n; * but needs to contain _code_ to jump to addr.&n; *&n; * the BREAK n instruction jumps to IBR + n * 8&n; */
r_void
DECL|function|set_break_vector
id|set_break_vector
c_func
(paren
r_int
id|n
comma
id|irqvectptr
id|addr
)paren
(brace
r_int
r_int
op_star
id|jinstr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|etrax_irv-&gt;v
(braket
id|n
op_star
l_int|2
)braket
suffix:semicolon
r_int
r_int
op_star
id|jaddr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|jinstr
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if you don&squot;t know what this does, do not touch it! */
op_star
id|jinstr
op_assign
l_int|0x0d3f
suffix:semicolon
op_star
id|jaddr
op_assign
(paren
r_int
r_int
)paren
id|addr
suffix:semicolon
multiline_comment|/* 00000026 &lt;clrlop+1a&gt; 3f0d82000000     jump  0x82 */
)brace
multiline_comment|/*&n; * This builds up the IRQ handler stubs using some ugly macros in irq.h&n; *&n; * These macros create the low-level assembly IRQ routines that do all&n; * the operations that are needed. They are also written to be fast - and to&n; * disable interrupts as little as humanly possible.&n; *&n; */
multiline_comment|/* IRQ0 and 1 are special traps */
r_void
id|hwbreakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|IRQ1_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
id|BUILD_TIMER_IRQ
c_func
(paren
l_int|2
comma
l_int|0x04
)paren
multiline_comment|/* the timer interrupt is somewhat special */
id|BUILD_IRQ
c_func
(paren
l_int|3
comma
l_int|0x08
)paren
id|BUILD_IRQ
c_func
(paren
l_int|4
comma
l_int|0x10
)paren
id|BUILD_IRQ
c_func
(paren
l_int|5
comma
l_int|0x20
)paren
id|BUILD_IRQ
c_func
(paren
l_int|6
comma
l_int|0x40
)paren
id|BUILD_IRQ
c_func
(paren
l_int|7
comma
l_int|0x80
)paren
id|BUILD_IRQ
c_func
(paren
l_int|8
comma
l_int|0x100
)paren
id|BUILD_IRQ
c_func
(paren
l_int|9
comma
l_int|0x200
)paren
id|BUILD_IRQ
c_func
(paren
l_int|10
comma
l_int|0x400
)paren
id|BUILD_IRQ
c_func
(paren
l_int|11
comma
l_int|0x800
)paren
id|BUILD_IRQ
c_func
(paren
l_int|12
comma
l_int|0x1000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|13
comma
l_int|0x2000
)paren
r_void
id|mmu_bus_fault
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* IRQ 14 is the bus fault interrupt */
r_void
id|multiple_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* IRQ 15 is the multiple IRQ interrupt */
id|BUILD_IRQ
c_func
(paren
l_int|16
comma
l_int|0x10000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|17
comma
l_int|0x20000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|18
comma
l_int|0x40000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|19
comma
l_int|0x80000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|20
comma
l_int|0x100000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|21
comma
l_int|0x200000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|22
comma
l_int|0x400000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|23
comma
l_int|0x800000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|24
comma
l_int|0x1000000
)paren
id|BUILD_IRQ
c_func
(paren
l_int|25
comma
l_int|0x2000000
)paren
multiline_comment|/* IRQ 26-30 are reserved */
id|BUILD_IRQ
c_func
(paren
l_int|31
comma
l_int|0x80000000
)paren
multiline_comment|/*&n; * Pointers to the low-level handlers &n; */
DECL|variable|interrupt
r_static
r_void
(paren
op_star
id|interrupt
(braket
id|NR_IRQS
)braket
)paren
(paren
r_void
)paren
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|IRQ2_interrupt
comma
id|IRQ3_interrupt
comma
id|IRQ4_interrupt
comma
id|IRQ5_interrupt
comma
id|IRQ6_interrupt
comma
id|IRQ7_interrupt
comma
id|IRQ8_interrupt
comma
id|IRQ9_interrupt
comma
id|IRQ10_interrupt
comma
id|IRQ11_interrupt
comma
id|IRQ12_interrupt
comma
id|IRQ13_interrupt
comma
l_int|NULL
comma
l_int|NULL
comma
id|IRQ16_interrupt
comma
id|IRQ17_interrupt
comma
id|IRQ18_interrupt
comma
id|IRQ19_interrupt
comma
id|IRQ20_interrupt
comma
id|IRQ21_interrupt
comma
id|IRQ22_interrupt
comma
id|IRQ23_interrupt
comma
id|IRQ24_interrupt
comma
id|IRQ25_interrupt
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|IRQ31_interrupt
)brace
suffix:semicolon
DECL|variable|bad_interrupt
r_static
r_void
(paren
op_star
id|bad_interrupt
(braket
id|NR_IRQS
)braket
)paren
(paren
r_void
)paren
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|bad_IRQ3_interrupt
comma
id|bad_IRQ4_interrupt
comma
id|bad_IRQ5_interrupt
comma
id|bad_IRQ6_interrupt
comma
id|bad_IRQ7_interrupt
comma
id|bad_IRQ8_interrupt
comma
id|bad_IRQ9_interrupt
comma
id|bad_IRQ10_interrupt
comma
id|bad_IRQ11_interrupt
comma
id|bad_IRQ12_interrupt
comma
id|bad_IRQ13_interrupt
comma
l_int|NULL
comma
l_int|NULL
comma
id|bad_IRQ16_interrupt
comma
id|bad_IRQ17_interrupt
comma
id|bad_IRQ18_interrupt
comma
id|bad_IRQ19_interrupt
comma
id|bad_IRQ20_interrupt
comma
id|bad_IRQ21_interrupt
comma
id|bad_IRQ22_interrupt
comma
id|bad_IRQ23_interrupt
comma
id|bad_IRQ24_interrupt
comma
id|bad_IRQ25_interrupt
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|bad_IRQ31_interrupt
)brace
suffix:semicolon
DECL|function|arch_setup_irq
r_void
id|arch_setup_irq
c_func
(paren
r_int
id|irq
)paren
(brace
id|set_int_vector
c_func
(paren
id|irq
comma
id|interrupt
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
DECL|function|arch_free_irq
r_void
id|arch_free_irq
c_func
(paren
r_int
id|irq
)paren
(brace
id|set_int_vector
c_func
(paren
id|irq
comma
id|bad_interrupt
(braket
id|irq
)braket
)paren
suffix:semicolon
)brace
r_void
id|weird_irq
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* from entry.S */
r_void
id|do_sigtrap
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* from entry.S */
r_void
id|gdb_handle_breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* from entry.S */
multiline_comment|/* init_IRQ() is called by start_kernel and is responsible for fixing IRQ masks and&n;   setting the irq vector table to point to bad_interrupt ptrs.&n;*/
r_void
id|__init
DECL|function|init_IRQ
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* clear all interrupt masks */
macro_line|#ifndef CONFIG_SVINTO_SIM
op_star
id|R_IRQ_MASK0_CLR
op_assign
l_int|0xffffffff
suffix:semicolon
op_star
id|R_IRQ_MASK1_CLR
op_assign
l_int|0xffffffff
suffix:semicolon
op_star
id|R_IRQ_MASK2_CLR
op_assign
l_int|0xffffffff
suffix:semicolon
macro_line|#endif
op_star
id|R_VECT_MASK_CLR
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* clear the shortcut entry points */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_shortcuts
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|etrax_irv-&gt;v
(braket
id|i
)braket
op_assign
id|weird_irq
suffix:semicolon
multiline_comment|/* the entries in the break vector contain actual code to be&n;           executed by the associated break handler, rather than just a jump&n;           address. therefore we need to setup a default breakpoint handler&n;           for all breakpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|set_break_vector
c_func
(paren
id|i
comma
id|do_sigtrap
)paren
suffix:semicolon
multiline_comment|/* set all etrax irq&squot;s to the bad handlers */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|set_int_vector
c_func
(paren
id|i
comma
id|bad_interrupt
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* except IRQ 15 which is the multiple-IRQ handler on Etrax100 */
id|set_int_vector
c_func
(paren
l_int|15
comma
id|multiple_interrupt
)paren
suffix:semicolon
multiline_comment|/* 0 and 1 which are special breakpoint/NMI traps */
id|set_int_vector
c_func
(paren
l_int|0
comma
id|hwbreakpoint
)paren
suffix:semicolon
id|set_int_vector
c_func
(paren
l_int|1
comma
id|IRQ1_interrupt
)paren
suffix:semicolon
multiline_comment|/* and irq 14 which is the mmu bus fault handler */
id|set_int_vector
c_func
(paren
l_int|14
comma
id|mmu_bus_fault
)paren
suffix:semicolon
multiline_comment|/* setup the system-call trap, which is reached by BREAK 13 */
id|set_break_vector
c_func
(paren
l_int|13
comma
id|system_call
)paren
suffix:semicolon
multiline_comment|/* setup a breakpoint handler for debugging used for both user and&n;           kernel mode debugging  (which is why it is not inside an ifdef&n;           CONFIG_ETRAX_KGDB) */
id|set_break_vector
c_func
(paren
l_int|8
comma
id|gdb_handle_breakpoint
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_KGDB
multiline_comment|/* setup kgdb if its enabled, and break into the debugger */
id|kgdb_init
c_func
(paren
)paren
suffix:semicolon
id|breakpoint
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
