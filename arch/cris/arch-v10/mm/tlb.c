multiline_comment|/*&n; *  linux/arch/cris/arch-v10/mm/tlb.c&n; *&n; *  Low level TLB handling&n; *&n; *&n; *  Copyright (C) 2000-2002  Axis Communications AB&n; *  &n; *  Authors:   Bjorn Wesen (bjornw@axis.com)&n; *&n; */
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
DECL|macro|D
mdefine_line|#define D(x)
multiline_comment|/* The TLB can host up to 64 different mm contexts at the same time.&n; * The running context is R_MMU_CONTEXT, and each TLB entry contains a&n; * page_id that has to match to give a hit. In page_id_map, we keep track&n; * of which mm&squot;s we have assigned which page_id&squot;s, so that we know when&n; * to invalidate TLB entries.&n; *&n; * The last page_id is never running - it is used as an invalid page_id&n; * so we can make TLB entries that will never match.&n; *&n; * Notice that we need to make the flushes atomic, otherwise an interrupt&n; * handler that uses vmalloced memory might cause a TLB load in the middle&n; * of a flush causing.&n; */
multiline_comment|/* invalidate all TLB entries */
r_void
DECL|function|flush_tlb_all
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* the vpn of i &amp; 0xf is so we dont write similar TLB entries&n;&t; * in the same 4-way entry group. details.. &n;&t; */
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TLB_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|R_TLB_SELECT
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|i
)paren
)paren
suffix:semicolon
op_star
id|R_TLB_HI
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|INVALID_PAGEID
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|vpn
comma
id|i
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
op_star
id|R_TLB_LO
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|global
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|valid
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|kernel
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|we
comma
id|no
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_LO
comma
id|pfn
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;tlb: flushed all&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate the selected mm context only */
r_void
DECL|function|flush_tlb_mm
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|page_id
op_assign
id|mm-&gt;context
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;tlb: flush mm context %d (%p)&bslash;n&quot;
comma
id|page_id
comma
id|mm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_id
op_eq
id|NO_CONTEXT
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* mark the TLB entries that match the page_id as invalid.&n;&t; * here we could also check the _PAGE_GLOBAL bit and NOT flush&n;&t; * global pages. is it worth the extra I/O ? &n;&t; */
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TLB_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|R_TLB_SELECT
op_assign
id|IO_FIELD
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
op_star
id|R_TLB_HI
)paren
op_eq
id|page_id
)paren
(brace
op_star
id|R_TLB_HI
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|INVALID_PAGEID
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|vpn
comma
id|i
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
op_star
id|R_TLB_LO
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|global
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|valid
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|kernel
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|we
comma
id|no
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_LO
comma
id|pfn
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate a single page */
r_void
DECL|function|flush_tlb_page
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
id|page_id
op_assign
id|mm-&gt;context
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;tlb: flush page %p in context %d (%p)&bslash;n&quot;
comma
id|addr
comma
id|page_id
comma
id|mm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_id
op_eq
id|NO_CONTEXT
)paren
(brace
r_return
suffix:semicolon
)brace
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* perhaps not necessary */
multiline_comment|/* invalidate those TLB entries that match both the mm context&n;&t; * and the virtual address requested &n;&t; */
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TLB_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|tlb_hi
suffix:semicolon
op_star
id|R_TLB_SELECT
op_assign
id|IO_FIELD
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|i
)paren
suffix:semicolon
id|tlb_hi
op_assign
op_star
id|R_TLB_HI
suffix:semicolon
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|tlb_hi
)paren
op_eq
id|page_id
op_logical_and
(paren
id|tlb_hi
op_amp
id|PAGE_MASK
)paren
op_eq
id|addr
)paren
(brace
op_star
id|R_TLB_HI
op_assign
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|INVALID_PAGEID
)paren
op_or
id|addr
suffix:semicolon
multiline_comment|/* same addr as before works. */
op_star
id|R_TLB_LO
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|global
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|valid
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|kernel
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|we
comma
id|no
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_LO
comma
id|pfn
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate a page range */
r_void
DECL|function|flush_tlb_range
id|flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
id|page_id
op_assign
id|mm-&gt;context
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;tlb: flush range %p&lt;-&gt;%p in context %d (%p)&bslash;n&quot;
comma
id|start
comma
id|end
comma
id|page_id
comma
id|mm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_id
op_eq
id|NO_CONTEXT
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* probably not necessary */
id|end
op_and_assign
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* dito */
multiline_comment|/* invalidate those TLB entries that match both the mm context&n;&t; * and the virtual address range&n;&t; */
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TLB_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|tlb_hi
comma
id|vpn
suffix:semicolon
op_star
id|R_TLB_SELECT
op_assign
id|IO_FIELD
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|i
)paren
suffix:semicolon
id|tlb_hi
op_assign
op_star
id|R_TLB_HI
suffix:semicolon
id|vpn
op_assign
id|tlb_hi
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|tlb_hi
)paren
op_eq
id|page_id
op_logical_and
id|vpn
op_ge
id|start
op_logical_and
id|vpn
OL
id|end
)paren
(brace
op_star
id|R_TLB_HI
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|page_id
comma
id|INVALID_PAGEID
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_HI
comma
id|vpn
comma
id|i
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
op_star
id|R_TLB_LO
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|global
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|valid
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|kernel
comma
id|no
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_TLB_LO
comma
id|we
comma
id|no
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_TLB_LO
comma
id|pfn
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* dump the entire TLB for debug purposes */
macro_line|#if 0
r_void
id|dump_tlb_all
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLB dump. LO is: pfn | reserved | global | valid | kernel | we  |&bslash;n&quot;
)paren
suffix:semicolon
id|local_save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TLB_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|R_TLB_SELECT
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Entry %d: HI 0x%08lx, LO 0x%08lx&bslash;n&quot;
comma
id|i
comma
op_star
id|R_TLB_HI
comma
op_star
id|R_TLB_LO
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* called in schedule() just before actually doing the switch_to */
r_void
DECL|function|switch_mm
id|switch_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|prev
comma
r_struct
id|mm_struct
op_star
id|next
comma
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|cpu
)paren
(brace
multiline_comment|/* make sure we have a context */
id|get_mmu_context
c_func
(paren
id|next
)paren
suffix:semicolon
multiline_comment|/* remember the pgd for the fault handlers&n;&t; * this is similar to the pgd register in some other CPU&squot;s.&n;&t; * we need our own copy of it because current and active_mm&n;&t; * might be invalid at points where we still need to derefer&n;&t; * the pgd.&n;&t; */
id|current_pgd
op_assign
id|next-&gt;pgd
suffix:semicolon
multiline_comment|/* switch context in the MMU */
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;switching mmu_context to %d (%p)&bslash;n&quot;
comma
id|next-&gt;context
comma
id|next
)paren
)paren
suffix:semicolon
op_star
id|R_MMU_CONTEXT
op_assign
id|IO_FIELD
c_func
(paren
id|R_MMU_CONTEXT
comma
id|page_id
comma
id|next-&gt;context
)paren
suffix:semicolon
)brace
eof
