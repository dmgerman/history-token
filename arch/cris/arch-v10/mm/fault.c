multiline_comment|/*&n; *  linux/arch/cris/mm/fault.c&n; *&n; *  Low level bus fault handler&n; *&n; *&n; *  Copyright (C) 2000, 2001  Axis Communications AB&n; *&n; *  Authors:  Bjorn Wesen &n; * &n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
multiline_comment|/* debug of low-level TLB reload */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|D
mdefine_line|#define D(x) x
macro_line|#else
DECL|macro|D
mdefine_line|#define D(x)
macro_line|#endif
r_extern
r_volatile
id|pgd_t
op_star
id|current_pgd
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
op_star
id|search_exception_tables
c_func
(paren
r_int
r_int
id|addr
)paren
suffix:semicolon
id|asmlinkage
r_void
id|do_page_fault
c_func
(paren
r_int
r_int
id|address
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
suffix:semicolon
multiline_comment|/* fast TLB-fill fault handler&n; * this is called from entry.S with interrupts disabled&n; */
r_void
DECL|function|handle_mmu_bus_fault
id|handle_mmu_bus_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cause
comma
id|select
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|index
suffix:semicolon
r_int
id|page_id
suffix:semicolon
r_int
id|acc
comma
id|inv
suffix:semicolon
macro_line|#endif
r_int
id|miss
comma
id|we
comma
id|writeac
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
id|pte
suffix:semicolon
r_int
id|errcode
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
id|cause
op_assign
op_star
id|R_MMU_CAUSE
suffix:semicolon
id|select
op_assign
op_star
id|R_TLB_SELECT
suffix:semicolon
id|address
op_assign
id|cause
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* get faulting address */
macro_line|#ifdef DEBUG
id|page_id
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|page_id
comma
id|cause
)paren
suffix:semicolon
id|acc
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|acc_excp
comma
id|cause
)paren
suffix:semicolon
id|inv
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|inv_excp
comma
id|cause
)paren
suffix:semicolon
id|index
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_TLB_SELECT
comma
id|index
comma
id|select
)paren
suffix:semicolon
macro_line|#endif
id|miss
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|miss_excp
comma
id|cause
)paren
suffix:semicolon
id|we
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|we_excp
comma
id|cause
)paren
suffix:semicolon
id|writeac
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_MMU_CAUSE
comma
id|wr_rd
comma
id|cause
)paren
suffix:semicolon
multiline_comment|/* ETRAX 100LX TR89 bugfix: if the second half of an unaligned&n;&t; * write causes a MMU-fault, it will not be restarted correctly.&n;&t; * This could happen if a write crosses a page-boundary and the&n;&t; * second page is not yet COW&squot;ed or even loaded. The workaround&n;&t; * is to clear the unaligned bit in the CPU status record, so &n;&t; * that the CPU will rerun both the first and second halves of&n;&t; * the instruction. This will not have any sideeffects unless&n;&t; * the first half goes to any device or memory that can&squot;t be&n;&t; * written twice, and which is mapped through the MMU.&n;&t; *&n;&t; * We only need to do this for writes.&n;&t; */
r_if
c_cond
(paren
id|writeac
)paren
(brace
id|regs-&gt;csrinstr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Set errcode&squot;s R/W flag according to the mode which caused the&n;&t; * fault&n;&t; */
id|errcode
op_assign
id|writeac
op_lshift
l_int|1
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;bus_fault from IRP 0x%lx: addr 0x%lx, miss %d, inv %d, we %d, acc %d, dx %d pid %d&bslash;n&quot;
comma
id|regs-&gt;irp
comma
id|address
comma
id|miss
comma
id|inv
comma
id|we
comma
id|acc
comma
id|index
comma
id|page_id
)paren
)paren
suffix:semicolon
multiline_comment|/* for a miss, we need to reload the TLB entry */
r_if
c_cond
(paren
id|miss
)paren
(brace
multiline_comment|/* see if the pte exists at all&n;&t;&t; * refer through current_pgd, dont use mm-&gt;pgd&n;&t;&t; */
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|current_pgd
op_plus
id|pgd_index
c_func
(paren
id|address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_goto
id|dofault
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad pgdir entry 0x%lx at 0x%p&bslash;n&quot;
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|pmd
comma
id|pmd
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pte
op_assign
op_star
id|pte_offset_kernel
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|pte
)paren
)paren
r_goto
id|dofault
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot; found pte %lx pg %p &quot;
comma
id|pte_val
c_func
(paren
id|pte
)paren
comma
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_SILENT_WRITE
)paren
id|printk
c_func
(paren
l_string|&quot;Silent-W &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_KERNEL
)paren
id|printk
c_func
(paren
l_string|&quot;Kernel &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_SILENT_READ
)paren
id|printk
c_func
(paren
l_string|&quot;Silent-R &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_GLOBAL
)paren
id|printk
c_func
(paren
l_string|&quot;Global &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_PRESENT
)paren
id|printk
c_func
(paren
l_string|&quot;Present &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_ACCESSED
)paren
id|printk
c_func
(paren
l_string|&quot;Accessed &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_MODIFIED
)paren
id|printk
c_func
(paren
l_string|&quot;Modified &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_READ
)paren
id|printk
c_func
(paren
l_string|&quot;Readable &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_WRITE
)paren
id|printk
c_func
(paren
l_string|&quot;Writeable &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* load up the chosen TLB entry&n;&t;&t; * this assumes the pte format is the same as the TLB_LO layout.&n;&t;&t; *&n;&t;&t; * the write to R_TLB_LO also writes the vpn and page_id fields from&n;&t;&t; * R_MMU_CAUSE, which we in this case obviously want to keep&n;&t;&t; */
op_star
id|R_TLB_LO
op_assign
id|pte_val
c_func
(paren
id|pte
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|errcode
op_assign
l_int|1
op_or
(paren
id|we
op_lshift
l_int|1
)paren
suffix:semicolon
id|dofault
suffix:colon
multiline_comment|/* leave it to the MM system fault handler below */
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;do_page_fault %lx errcode %d&bslash;n&quot;
comma
id|address
comma
id|errcode
)paren
)paren
suffix:semicolon
id|do_page_fault
c_func
(paren
id|address
comma
id|regs
comma
id|errcode
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from arch/cris/mm/fault.c to find fixup code. */
r_int
DECL|function|find_fixup_code
id|find_fixup_code
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|regs-&gt;irp
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Adjust the instruction pointer in the stackframe. */
id|regs-&gt;irp
op_assign
id|fixup-&gt;fixup
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Don&squot;t return by restoring the CPU state, so switch&n;&t;&t; * frame-type. &n;&t;&t; */
id|regs-&gt;frametype
op_assign
id|CRIS_FRAME_NORMAL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
