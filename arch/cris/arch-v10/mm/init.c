multiline_comment|/*&n; *  linux/arch/cris/arch-v10/mm/init.c&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
r_extern
r_void
id|tlb_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The kernel is already mapped with a kernel segment at kseg_c so &n; * we don&squot;t need to map it with a page table. However head.S also&n; * temporarily mapped it at kseg_4 so we should set up the ksegs again,&n; * clear the TLB and do some other paging setup stuff.&n; */
r_void
id|__init
DECL|function|paging_init
id|paging_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Setting up paging and the MMU.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* clear out the init_mm.pgd that will contain the kernel&squot;s mappings */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PTRS_PER_PGD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|swapper_pg_dir
(braket
id|i
)braket
op_assign
id|__pgd
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* make sure the current pgd table points to something sane&n;&t; * (even if it is most probably not used until the next &n;&t; *  switch_mm)&n;&t; */
id|current_pgd
op_assign
id|init_mm.pgd
suffix:semicolon
multiline_comment|/* initialise the TLB (tlb.c) */
id|tlb_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* see README.mm for details on the KSEG setup */
macro_line|#ifdef CONFIG_CRIS_LOW_MAP
multiline_comment|/* Etrax-100 LX version 1 has a bug so that we cannot map anything&n;&t; * across the 0x80000000 boundary, so we need to shrink the user-virtual&n;&t; * area to 0x50000000 instead of 0xb0000000 and map things slightly&n;&t; * different. The unused areas are marked as paged so that we can catch&n;&t; * freak kernel accesses there.&n;&t; *&n;&t; * The ARTPEC chip is mapped at 0xa so we pass that segment straight&n;&t; * through. We cannot vremap it because the vmalloc area is below 0x8&n;&t; * and Juliette needs an uncached area above 0x8.&n;&t; *&n;&t; * Same thing with 0xc and 0x9, which is memory-mapped I/O on some boards.&n;&t; * We map them straight over in LOW_MAP, but use vremap in LX version 2.&n;&t; */
DECL|macro|CACHED_BOOTROM
mdefine_line|#define CACHED_BOOTROM (KSEG_F | 0x08000000UL)
op_star
id|R_MMU_KSEG
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_f
comma
id|seg
)paren
op_or
multiline_comment|/* bootrom */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_e
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_d
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_c
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_b
comma
id|seg
)paren
op_or
multiline_comment|/* kernel reg area */
macro_line|#ifdef CONFIG_JULIETTE
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_a
comma
id|seg
)paren
op_or
multiline_comment|/* ARTPEC etc. */
macro_line|#else
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_a
comma
id|page
)paren
op_or
macro_line|#endif
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_9
comma
id|seg
)paren
op_or
multiline_comment|/* LED&squot;s on some boards */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_8
comma
id|seg
)paren
op_or
multiline_comment|/* CSE0/1, flash and I/O */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_7
comma
id|page
)paren
op_or
multiline_comment|/* kernel vmalloc area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_6
comma
id|seg
)paren
op_or
multiline_comment|/* kernel DRAM area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_5
comma
id|seg
)paren
op_or
multiline_comment|/* cached flash */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_4
comma
id|page
)paren
op_or
multiline_comment|/* user area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_3
comma
id|page
)paren
op_or
multiline_comment|/* user area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_2
comma
id|page
)paren
op_or
multiline_comment|/* user area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_1
comma
id|page
)paren
op_or
multiline_comment|/* user area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_0
comma
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/* user area */
op_star
id|R_MMU_KBASE_HI
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_f
comma
l_int|0x3
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_e
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_d
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_c
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_b
comma
l_int|0xb
)paren
op_or
macro_line|#ifdef CONFIG_JULIETTE
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_a
comma
l_int|0xa
)paren
op_or
macro_line|#else
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_a
comma
l_int|0x0
)paren
op_or
macro_line|#endif
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_9
comma
l_int|0x9
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_8
comma
l_int|0x8
)paren
)paren
suffix:semicolon
op_star
id|R_MMU_KBASE_LO
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_7
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_6
comma
l_int|0x4
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_5
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_4
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_3
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_2
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_1
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_0
comma
l_int|0x0
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* This code is for the corrected Etrax-100 LX version 2... */
mdefine_line|#define CACHED_BOOTROM (KSEG_A | 0x08000000UL)
op_star
id|R_MMU_KSEG
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_f
comma
id|seg
)paren
op_or
multiline_comment|/* cached flash */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_e
comma
id|seg
)paren
op_or
multiline_comment|/* uncached flash */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_d
comma
id|page
)paren
op_or
multiline_comment|/* vmalloc area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_c
comma
id|seg
)paren
op_or
multiline_comment|/* kernel area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_b
comma
id|seg
)paren
op_or
multiline_comment|/* kernel reg area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_a
comma
id|seg
)paren
op_or
multiline_comment|/* bootrom */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_9
comma
id|page
)paren
op_or
multiline_comment|/* user area */
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_8
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_7
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_6
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_5
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_4
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_3
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_2
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_1
comma
id|page
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_KSEG
comma
id|seg_0
comma
id|page
)paren
)paren
suffix:semicolon
op_star
id|R_MMU_KBASE_HI
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_f
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_e
comma
l_int|0x8
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_d
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_c
comma
l_int|0x4
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_b
comma
l_int|0xb
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_a
comma
l_int|0x3
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_9
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_HI
comma
id|base_8
comma
l_int|0x0
)paren
)paren
suffix:semicolon
op_star
id|R_MMU_KBASE_LO
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_7
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_6
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_5
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_4
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_3
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_2
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_1
comma
l_int|0x0
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_MMU_KBASE_LO
comma
id|base_0
comma
l_int|0x0
)paren
)paren
suffix:semicolon
macro_line|#endif
op_star
id|R_MMU_CONTEXT
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_MMU_CONTEXT
comma
id|page_id
comma
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* The MMU has been enabled ever since head.S but just to make&n;&t; * it totally obvious we do it here as well.&n;&t; */
op_star
id|R_MMU_CTRL
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_MMU_CTRL
comma
id|inv_excp
comma
id|enable
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_CTRL
comma
id|acc_excp
comma
id|enable
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_MMU_CTRL
comma
id|we_excp
comma
id|enable
)paren
)paren
suffix:semicolon
op_star
id|R_MMU_ENABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_MMU_ENABLE
comma
id|mmu_enable
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the bad page table and bad page to point&n;&t; * to a couple of allocated pages&n;&t; */
id|empty_zero_page
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_zero_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* All pages are DMA&squot;able in Etrax, so put all in the DMA&squot;able zone */
id|zones_size
(braket
l_int|0
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|high_memory
op_minus
id|PAGE_OFFSET
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|zones_size
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Use free_area_init_node instead of free_area_init, because the former&n;&t; * is designed for systems where the DRAM starts at an address substantially&n;&t; * higher than 0, like us (we start at PAGE_OFFSET). This saves space in the&n;&t; * mem_map page array.&n;&t; */
id|free_area_init_node
c_func
(paren
l_int|0
comma
op_amp
id|contig_page_data
comma
id|zones_size
comma
id|PAGE_OFFSET
op_rshift
id|PAGE_SHIFT
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize remaps of some I/O-ports. It is important that this&n; * is called before any driver is initialized.&n; */
r_static
r_int
DECL|function|init_ioremap
id|__init
id|init_ioremap
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Give the external I/O-port addresses their values */
macro_line|#ifdef CONFIG_CRIS_LOW_MAP
multiline_comment|/* Simply a linear map (see the KSEG map above in paging_init) */
id|port_cse1_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|MEM_CSE1_START
op_or
id|MEM_NON_CACHEABLE
)paren
suffix:semicolon
id|port_csp0_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|MEM_CSP0_START
op_or
id|MEM_NON_CACHEABLE
)paren
suffix:semicolon
id|port_csp4_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|MEM_CSP4_START
op_or
id|MEM_NON_CACHEABLE
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Note that nothing blows up just because we do this remapping &n;&t; * it&squot;s ok even if the ports are not used or connected &n;&t; * to anything (or connected to a non-I/O thing) */
id|port_cse1_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|ioremap
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|MEM_CSE1_START
op_or
id|MEM_NON_CACHEABLE
)paren
comma
l_int|16
)paren
suffix:semicolon
id|port_csp0_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|ioremap
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|MEM_CSP0_START
op_or
id|MEM_NON_CACHEABLE
)paren
comma
l_int|16
)paren
suffix:semicolon
id|port_csp4_addr
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|ioremap
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|MEM_CSP4_START
op_or
id|MEM_NON_CACHEABLE
)paren
comma
l_int|16
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_ioremap
id|__initcall
c_func
(paren
id|init_ioremap
)paren
suffix:semicolon
multiline_comment|/* Helper function for the two below */
r_static
r_inline
r_void
DECL|function|flush_etrax_cacherange
id|flush_etrax_cacherange
c_func
(paren
r_void
op_star
id|startadr
comma
r_int
id|length
)paren
(brace
multiline_comment|/* CACHED_BOOTROM is mapped to the boot-rom area (cached) which&n;&t; * we can use to get fast dummy-reads of cachelines&n;&t; */
r_volatile
r_int
op_star
id|flushadr
op_assign
(paren
r_volatile
r_int
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|startadr
op_amp
op_complement
id|PAGE_MASK
)paren
op_or
id|CACHED_BOOTROM
)paren
suffix:semicolon
id|length
op_assign
id|length
OG
l_int|8192
ques
c_cond
l_int|8192
suffix:colon
id|length
suffix:semicolon
multiline_comment|/* No need to flush more than cache size */
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
op_star
id|flushadr
suffix:semicolon
multiline_comment|/* dummy read to flush */
id|flushadr
op_add_assign
(paren
l_int|32
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* a cacheline is 32 bytes */
id|length
op_sub_assign
l_int|32
suffix:semicolon
)brace
)brace
multiline_comment|/* Due to a bug in Etrax100(LX) all versions, receiving DMA buffers&n; * will occationally corrupt certain CPU writes if the DMA buffers&n; * happen to be hot in the cache.&n; * &n; * As a workaround, we have to flush the relevant parts of the cache&n; * before (re) inserting any receiving descriptor into the DMA HW.&n; */
r_void
DECL|function|prepare_rx_descriptor
id|prepare_rx_descriptor
c_func
(paren
r_struct
id|etrax_dma_descr
op_star
id|desc
)paren
(brace
id|flush_etrax_cacherange
c_func
(paren
(paren
r_void
op_star
)paren
id|desc-&gt;buf
comma
id|desc-&gt;sw_len
ques
c_cond
id|desc-&gt;sw_len
suffix:colon
l_int|65536
)paren
suffix:semicolon
)brace
multiline_comment|/* Do the same thing but flush the entire cache */
r_void
DECL|function|flush_etrax_cache
id|flush_etrax_cache
c_func
(paren
r_void
)paren
(brace
id|flush_etrax_cacherange
c_func
(paren
l_int|0
comma
l_int|8192
)paren
suffix:semicolon
)brace
eof
