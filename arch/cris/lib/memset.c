multiline_comment|/*#************************************************************************#*/
multiline_comment|/*#-------------------------------------------------------------------------*/
multiline_comment|/*#                                                                         */
multiline_comment|/*# FUNCTION NAME: memset()                                                 */
multiline_comment|/*#                                                                         */
multiline_comment|/*# PARAMETERS:  void* dst;   Destination address.                          */
multiline_comment|/*#              int     c;   Value of byte to write.                       */
multiline_comment|/*#              int   len;   Number of bytes to write.                     */
multiline_comment|/*#                                                                         */
multiline_comment|/*# RETURNS:     dst.                                                       */
multiline_comment|/*#                                                                         */
multiline_comment|/*# DESCRIPTION: Sets the memory dst of length len bytes to c, as standard. */
multiline_comment|/*#              Framework taken from memcpy.  This routine is              */
multiline_comment|/*#              very sensitive to compiler changes in register allocation. */
multiline_comment|/*#              Should really be rewritten to avoid this problem.          */
multiline_comment|/*#                                                                         */
multiline_comment|/*#-------------------------------------------------------------------------*/
multiline_comment|/*#                                                                         */
multiline_comment|/*# HISTORY                                                                 */
multiline_comment|/*#                                                                         */
multiline_comment|/*# DATE      NAME            CHANGES                                       */
multiline_comment|/*# ----      ----            -------                                       */
multiline_comment|/*# 990713    HP              Tired of watching this function (or           */
multiline_comment|/*#                           really, the nonoptimized generic              */
multiline_comment|/*#                           implementation) take up 90% of simulator      */
multiline_comment|/*#                           output.  Measurements needed.                 */
multiline_comment|/*#                                                                         */
multiline_comment|/*#-------------------------------------------------------------------------*/
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/* No, there&squot;s no macro saying 12*4, since it is &quot;hard&quot; to get it into&n;   the asm in a good way.  Thus better to expose the problem everywhere.&n;   */
multiline_comment|/* Assuming 1 cycle per dword written or read (ok, not really true), and&n;   one per instruction, then 43+3*(n/48-1) &lt;= 24+24*(n/48-1)&n;   so n &gt;= 45.7; n &gt;= 0.9; we win on the first full 48-byte block to set. */
DECL|macro|ZERO_BLOCK_SIZE
mdefine_line|#define ZERO_BLOCK_SIZE (1*12*4)
DECL|function|memset
r_void
op_star
id|memset
c_func
(paren
r_void
op_star
id|pdst
comma
r_int
id|c
comma
r_int
id|plen
)paren
(brace
multiline_comment|/* Ok.  Now we want the parameters put in special registers.&n;     Make sure the compiler is able to make something useful of this. */
r_register
r_char
op_star
id|return_dst
id|__asm__
(paren
l_string|&quot;r10&quot;
)paren
op_assign
id|pdst
suffix:semicolon
r_register
r_int
id|n
id|__asm__
(paren
l_string|&quot;r12&quot;
)paren
op_assign
id|plen
suffix:semicolon
r_register
r_int
id|lc
id|__asm__
(paren
l_string|&quot;r11&quot;
)paren
op_assign
id|c
suffix:semicolon
multiline_comment|/* Most apps use memset sanely.  Only those memsetting about 3..4&n;     bytes or less get penalized compared to the generic implementation&n;     - and that&squot;s not really sane use. */
multiline_comment|/* Ugh.  This is fragile at best.  Check with newer GCC releases, if&n;     they compile cascaded &quot;x |= x &lt;&lt; 8&quot; sanely! */
id|__asm__
c_func
(paren
l_string|&quot;movu.b %0,r13&bslash;n&bslash;t&quot;
l_string|&quot;lslq 8,r13&bslash;n&bslash;t&quot;
l_string|&quot;move.b %0,r13&bslash;n&bslash;t&quot;
l_string|&quot;move.d r13,%0&bslash;n&bslash;t&quot;
l_string|&quot;lslq 16,r13&bslash;n&bslash;t&quot;
l_string|&quot;or.d r13,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lc
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|lc
)paren
suffix:colon
l_string|&quot;r13&quot;
)paren
suffix:semicolon
(brace
r_register
r_char
op_star
id|dst
id|__asm__
(paren
l_string|&quot;r13&quot;
)paren
op_assign
id|pdst
suffix:semicolon
multiline_comment|/* This is NONPORTABLE, but since this whole routine is     */
multiline_comment|/* grossly nonportable that doesn&squot;t matter.                 */
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|pdst
op_amp
l_int|3
)paren
op_ne
l_int|0
multiline_comment|/* Oops! n=0 must be a legal call, regardless of alignment. */
op_logical_and
id|n
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|dst
op_amp
l_int|1
)paren
(brace
op_star
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
id|n
op_decrement
suffix:semicolon
id|dst
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|dst
op_amp
l_int|2
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|dst
op_assign
id|lc
suffix:semicolon
id|n
op_sub_assign
l_int|2
suffix:semicolon
id|dst
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* Now the fun part.  For the threshold value of this, check the equation&n;     above. */
multiline_comment|/* Decide which copying method to use. */
r_if
c_cond
(paren
id|n
op_ge
id|ZERO_BLOCK_SIZE
)paren
(brace
multiline_comment|/* For large copies we use &squot;movem&squot; */
multiline_comment|/* It is not optimal to tell the compiler about clobbering any&n;     registers; that will move the saving/restoring of those registers&n;     to the function prologue/epilogue, and make non-movem sizes&n;     suboptimal.&n;&n;      This method is not foolproof; it assumes that the &quot;asm reg&quot;&n;     declarations at the beginning of the function really are used&n;     here (beware: they may be moved to temporary registers).&n;      This way, we do not have to save/move the registers around into&n;     temporaries; we can safely use them straight away.&n;&n;      If you want to check that the allocation was right; then&n;      check the equalities in the first comment.  It should say&n;      &quot;r13=r13, r12=r12, r11=r11&quot; */
id|__asm__
r_volatile
(paren
"&quot;"
suffix:semicolon
suffix:semicolon
id|Check
id|that
id|the
id|following
id|is
l_bool|true
(paren
id|same
r_register
id|names
id|on
suffix:semicolon
suffix:semicolon
id|both
id|sides
id|of
id|equal
id|sign
comma
id|as
id|in
id|r8
op_assign
id|r8
)paren
suffix:colon
suffix:semicolon
suffix:semicolon
op_mod
l_int|0
op_assign
id|r13
comma
op_mod
l_int|1
op_assign
id|r12
comma
op_mod
l_int|4
op_assign
id|r11
suffix:semicolon
suffix:semicolon
suffix:semicolon
suffix:semicolon
id|Save
id|the
id|registers
id|we
"&squot;"
id|ll
id|clobber
id|in
id|the
id|movem
id|process
suffix:semicolon
suffix:semicolon
id|on
id|the
id|stack
dot
id|Don
"&squot;"
id|t
id|mention
id|them
id|to
id|gcc
comma
id|it
id|will
id|only
id|be
suffix:semicolon
suffix:semicolon
id|upset
dot
id|subq
l_int|11
op_star
l_int|4
comma
id|sp
id|movem
id|r10
comma
(braket
id|sp
)braket
id|move.d
id|r11
comma
id|r0
id|move.d
id|r11
comma
id|r1
id|move.d
id|r11
comma
id|r2
id|move.d
id|r11
comma
id|r3
id|move.d
id|r11
comma
id|r4
id|move.d
id|r11
comma
id|r5
id|move.d
id|r11
comma
id|r6
id|move.d
id|r11
comma
id|r7
id|move.d
id|r11
comma
id|r8
id|move.d
id|r11
comma
id|r9
id|move.d
id|r11
comma
id|r10
suffix:semicolon
suffix:semicolon
id|Now
id|we
"&squot;"
id|ve
id|got
id|this
suffix:colon
suffix:semicolon
suffix:semicolon
id|r13
op_minus
id|dst
suffix:semicolon
suffix:semicolon
id|r12
op_minus
id|n
suffix:semicolon
suffix:semicolon
id|Update
id|n
r_for
id|the
id|first
id|loop
id|subq
l_int|12
op_star
l_int|4
comma
id|r12
l_int|0
suffix:colon
id|subq
l_int|12
op_star
l_int|4
comma
id|r12
id|bge
l_int|0
id|b
id|movem
id|r11
comma
(braket
id|r13
op_plus
)braket
id|addq
l_int|12
op_star
l_int|4
comma
id|r12
suffix:semicolon
suffix:semicolon
id|compensate
r_for
id|last
id|loop
id|underflowing
id|n
suffix:semicolon
suffix:semicolon
id|Restore
id|registers
id|from
id|stack
id|movem
(braket
id|sp
op_plus
)braket
comma
id|r10
"&quot;"
multiline_comment|/* Outputs */
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dst
)paren
comma
l_string|&quot;=r&quot;
(paren
id|n
)paren
multiline_comment|/* Inputs */
suffix:colon
l_string|&quot;0&quot;
(paren
id|dst
)paren
comma
l_string|&quot;1&quot;
(paren
id|n
)paren
comma
l_string|&quot;r&quot;
(paren
id|lc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Either we directly starts copying, using dword copying&n;       in a loop, or we copy as much as possible with &squot;movem&squot; &n;       and then the last block (&lt;44 bytes) is copied here.&n;       This will work since &squot;movem&squot; will have updated src,dst,n. */
r_while
c_loop
(paren
id|n
op_ge
l_int|16
)paren
(brace
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
id|n
op_sub_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/* A switch() is definitely the fastest although it takes a LOT of code.&n;     * Particularly if you inline code this.&n;     */
r_switch
c_cond
(paren
id|n
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|dst
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|dst
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|dst
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|dst
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
id|lc
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
id|dst
)paren
op_increment
op_assign
(paren
r_int
)paren
id|lc
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
(paren
r_char
)paren
id|lc
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|return_dst
suffix:semicolon
multiline_comment|/* destination pointer. */
)brace
multiline_comment|/* memset() */
eof
