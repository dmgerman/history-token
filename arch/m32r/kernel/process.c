multiline_comment|/*&n; *  linux/arch/m32r/kernel/process.c&n; *&n; *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata,&n; *                            Hitoshi Yamamoto&n; *  Taken from sh version.&n; *    Copyright (C) 1995  Linus Torvalds&n; *    SuperH version:  Copyright (C) 1999, 2000  Niibe Yutaka &amp; Kaz Kojima&n; */
DECL|macro|DEBUG_PROCESS
macro_line|#undef DEBUG_PROCESS
macro_line|#ifdef DEBUG_PROCESS
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)  printk(&quot;%s:%d:%s: &quot; fmt, __FILE__, __LINE__, &bslash;&n;  __FUNCTION__, ##args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)
macro_line|#endif
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/hardirq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/elf.h&gt;
macro_line|#include &lt;asm/m32r.h&gt;
macro_line|#include &lt;linux/err.h&gt;
DECL|variable|hlt_counter
r_static
r_int
id|hlt_counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Return saved PC of a blocked thread.&n; */
DECL|function|thread_saved_pc
r_int
r_int
id|thread_saved_pc
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
id|tsk-&gt;thread.lr
suffix:semicolon
)brace
multiline_comment|/*&n; * Powermanagement idle function, if any..&n; */
DECL|variable|pm_idle
r_void
(paren
op_star
id|pm_idle
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|function|disable_hlt
r_void
id|disable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_increment
suffix:semicolon
)brace
DECL|variable|disable_hlt
id|EXPORT_SYMBOL
c_func
(paren
id|disable_hlt
)paren
suffix:semicolon
DECL|function|enable_hlt
r_void
id|enable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_decrement
suffix:semicolon
)brace
DECL|variable|enable_hlt
id|EXPORT_SYMBOL
c_func
(paren
id|enable_hlt
)paren
suffix:semicolon
multiline_comment|/*&n; * We use this is we don&squot;t have any better&n; * idle routine..&n; */
DECL|function|default_idle
r_void
id|default_idle
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* M32R_FIXME: Please use &quot;cpu_sleep&quot; mode.  */
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On SMP it&squot;s slightly faster (but much more power-consuming!)&n; * to poll the -&gt;work.need_resched flag instead of waiting for the&n; * cross-CPU IPI to arrive. Use this option with caution.&n; */
DECL|function|poll_idle
r_static
r_void
id|poll_idle
(paren
r_void
)paren
(brace
multiline_comment|/* M32R_FIXME */
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The idle thread. There&squot;s no useful work to be&n; * done, so just try to conserve power and have a&n; * low exit latency (ie sit in a loop waiting for&n; * somebody to say that they&squot;d like to reschedule)&n; */
DECL|function|cpu_idle
r_void
id|cpu_idle
(paren
r_void
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|need_resched
c_func
(paren
)paren
)paren
(brace
r_void
(paren
op_star
id|idle
)paren
(paren
r_void
)paren
op_assign
id|pm_idle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idle
)paren
id|idle
op_assign
id|default_idle
suffix:semicolon
id|idle
c_func
(paren
)paren
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Please push reset button!&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|machine_restart
id|EXPORT_SYMBOL
c_func
(paren
id|machine_restart
)paren
suffix:semicolon
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Please push reset button!&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|machine_halt
id|EXPORT_SYMBOL
c_func
(paren
id|machine_halt
)paren
suffix:semicolon
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* M32R_FIXME */
)brace
DECL|variable|machine_power_off
id|EXPORT_SYMBOL
c_func
(paren
id|machine_power_off
)paren
suffix:semicolon
DECL|function|idle_setup
r_static
r_int
id|__init
id|idle_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;poll&quot;
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;using poll in idle threads.&bslash;n&quot;
)paren
suffix:semicolon
id|pm_idle
op_assign
id|poll_idle
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;sleep&quot;
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;using sleep in idle threads.&bslash;n&quot;
)paren
suffix:semicolon
id|pm_idle
op_assign
id|default_idle
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;idle=&quot;
comma
id|idle_setup
)paren
suffix:semicolon
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BPC[%08lx]:PSW[%08lx]:LR [%08lx]:FP [%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;bpc
comma
id|regs-&gt;psw
comma
id|regs-&gt;lr
comma
id|regs-&gt;fp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BBPC[%08lx]:BBPSW[%08lx]:SPU[%08lx]:SPI[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;bbpc
comma
id|regs-&gt;bbpsw
comma
id|regs-&gt;spu
comma
id|regs-&gt;spi
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R0 [%08lx]:R1 [%08lx]:R2 [%08lx]:R3 [%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R4 [%08lx]:R5 [%08lx]:R6 [%08lx]:R7 [%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;r4
comma
id|regs-&gt;r5
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R8 [%08lx]:R9 [%08lx]:R10[%08lx]:R11[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R12[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;r12
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_ISA_M32R2) &amp;&amp; defined(CONFIG_ISA_DSP_LEVEL2)
id|printk
c_func
(paren
l_string|&quot;ACC0H[%08lx]:ACC0L[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;acc0h
comma
id|regs-&gt;acc0l
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ACC1H[%08lx]:ACC1L[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;acc1h
comma
id|regs-&gt;acc1l
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
id|printk
c_func
(paren
l_string|&quot;ACCH[%08lx]:ACCL[%08lx]&bslash;n&quot;
comma
"&bslash;"
id|regs-&gt;acch
comma
id|regs-&gt;accl
)paren
suffix:semicolon
macro_line|#else
macro_line|#error unknown isa configuration
macro_line|#endif
)brace
multiline_comment|/*&n; * Create a kernel thread&n; */
multiline_comment|/*&n; * This is the mechanism for creating a new kernel thread.&n; *&n; * NOTE! Only a kernel-only process(ie the swapper or direct descendants&n; * who haven&squot;t done an &quot;execve()&quot;) should use this: it will work within&n; * a system call from a &quot;real&quot; process, but the process memory space will&n; * not be free&squot;d until both the parent and the child have exited.&n; */
DECL|function|kernel_thread_helper
r_static
r_void
id|kernel_thread_helper
c_func
(paren
r_void
op_star
id|nouse
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
)paren
(brace
id|fn
c_func
(paren
id|arg
)paren
suffix:semicolon
id|do_exit
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|kernel_thread
r_int
id|kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|regs
comma
l_int|0
comma
r_sizeof
(paren
id|regs
)paren
)paren
suffix:semicolon
id|regs.r1
op_assign
(paren
r_int
r_int
)paren
id|fn
suffix:semicolon
id|regs.r2
op_assign
(paren
r_int
r_int
)paren
id|arg
suffix:semicolon
id|regs.bpc
op_assign
(paren
r_int
r_int
)paren
id|kernel_thread_helper
suffix:semicolon
id|regs.psw
op_assign
id|M32R_PSW_BIE
suffix:semicolon
multiline_comment|/* Ok, create the new process. */
r_return
id|do_fork
c_func
(paren
id|flags
op_or
id|CLONE_VM
op_or
id|CLONE_UNTRACED
comma
l_int|0
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing to do. */
id|DPRINTK
c_func
(paren
l_string|&quot;pid = %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pid = %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|current-&gt;thread.debug_trap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|debug_trap
)paren
)paren
suffix:semicolon
)brace
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
multiline_comment|/* do nothing */
id|DPRINTK
c_func
(paren
l_string|&quot;pid = %d&bslash;n&quot;
comma
id|dead_task-&gt;pid
)paren
suffix:semicolon
)brace
multiline_comment|/* Fill in the fpu structure for a core dump.. */
DECL|function|dump_fpu
r_int
id|dump_fpu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|fpu
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Task didn&squot;t use the fpu at all. */
)brace
DECL|function|copy_thread
r_int
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|spu
comma
r_int
r_int
id|unused
comma
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
r_int
r_int
id|sp
op_assign
(paren
r_int
r_int
)paren
id|tsk-&gt;thread_info
op_plus
id|THREAD_SIZE
suffix:semicolon
r_extern
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Copy registers */
id|sp
op_sub_assign
r_sizeof
(paren
r_struct
id|pt_regs
)paren
suffix:semicolon
id|childregs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|sp
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
id|childregs-&gt;spu
op_assign
id|spu
suffix:semicolon
id|childregs-&gt;r0
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Child gets zero as return value */
id|regs-&gt;r0
op_assign
id|tsk-&gt;pid
suffix:semicolon
id|tsk-&gt;thread.sp
op_assign
(paren
r_int
r_int
)paren
id|childregs
suffix:semicolon
id|tsk-&gt;thread.lr
op_assign
(paren
r_int
r_int
)paren
id|ret_from_fork
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the user structure for a core dump..&n; */
DECL|function|dump_thread
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user
op_star
id|dump
)paren
(brace
multiline_comment|/* M32R_FIXME */
)brace
multiline_comment|/*&n; * Capture the user space registers if the task is not running (in user space)&n; */
DECL|function|dump_task_regs
r_int
id|dump_task_regs
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
id|elf_gregset_t
op_star
id|regs
)paren
(brace
multiline_comment|/* M32R_FIXME */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sys_fork
id|asmlinkage
r_int
id|sys_fork
c_func
(paren
r_int
r_int
id|r0
comma
r_int
r_int
id|r1
comma
r_int
r_int
id|r2
comma
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_MMU
r_return
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|regs.spu
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif /* CONFIG_MMU */
)brace
DECL|function|sys_clone
id|asmlinkage
r_int
id|sys_clone
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|newsp
comma
r_int
r_int
id|parent_tidptr
comma
r_int
r_int
id|child_tidptr
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|newsp
)paren
id|newsp
op_assign
id|regs.spu
suffix:semicolon
r_return
id|do_fork
c_func
(paren
id|clone_flags
comma
id|newsp
comma
op_amp
id|regs
comma
l_int|0
comma
(paren
r_int
id|__user
op_star
)paren
id|parent_tidptr
comma
(paren
r_int
id|__user
op_star
)paren
id|child_tidptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is trivial, and on the face of it looks like it&n; * could equally well be done in user mode.&n; *&n; * Not so, for quite unobvious reasons - register pressure.&n; * In user mode vfork() cannot have a stack frame, and if&n; * done by calling the &quot;clone()&quot; system call directly, you&n; * do not have enough call-clobbered registers to hold all&n; * the information you need.&n; */
DECL|function|sys_vfork
id|asmlinkage
r_int
id|sys_vfork
c_func
(paren
r_int
r_int
id|r0
comma
r_int
r_int
id|r1
comma
r_int
r_int
id|r2
comma
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|regs.spu
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_execve() executes a new program.&n; */
DECL|function|sys_execve
id|asmlinkage
r_int
id|sys_execve
c_func
(paren
r_char
id|__user
op_star
id|ufilename
comma
r_char
id|__user
op_star
id|__user
op_star
id|uargv
comma
r_char
id|__user
op_star
id|__user
op_star
id|uenvp
comma
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
id|ufilename
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
id|uargv
comma
id|uenvp
comma
op_amp
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;ptrace
op_and_assign
op_complement
id|PT_DTRACE
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * These bracket the sleeping functions..&n; */
DECL|macro|first_sched
mdefine_line|#define first_sched&t;((unsigned long) scheduling_functions_start_here)
DECL|macro|last_sched
mdefine_line|#define last_sched&t;((unsigned long) scheduling_functions_end_here)
DECL|function|get_wchan
r_int
r_int
id|get_wchan
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
multiline_comment|/* M32R_FIXME */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
