multiline_comment|/*------------------------------------------------------------------------&n; . smc91111.c&n; . This is a driver for SMSC&squot;s 91C111 single-chip Ethernet device.&n; .&n; . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)&n; .       Developed by Simple Network Magic Corporation (SNMC)&n; . Copyright (C) 1996 by Erik Stahlman (ES)&n; .&n; . This program is free software; you can redistribute it and/or modify&n; . it under the terms of the GNU General Public License as published by&n; . the Free Software Foundation; either version 2 of the License, or&n; . (at your option) any later version.&n; .&n; . This program is distributed in the hope that it will be useful,&n; . but WITHOUT ANY WARRANTY; without even the implied warranty of&n; . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; . GNU General Public License for more details.&n; .&n; . You should have received a copy of the GNU General Public License&n; . along with this program; if not, write to the Free Software&n; . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; .&n; . Information contained in this file was obtained from the LAN91C111&n; . manual from SMC.  To get a copy, if you really want one, you can find&n; . information under www.smsc.com.&n; .&n; .&n; . &quot;Features&quot; of the SMC chip:&n; .   Integrated PHY/MAC for 10/100BaseT Operation&n; .   Supports internal and external MII&n; .   Integrated 8K packet memory&n; .   EEPROM interface for configuration&n; .&n; . Arguments:&n; . &t;io&t;= for the base address&n; .&t;irq&t;= for the IRQ&n; .&t;nowait&t;= 0 for normal wait states, 1 eliminates additional wait states&n; .&n; . author:&n; . &t;Erik Stahlman&t;&t;&t;&t;( erik@vt.edu )&n; . &t;Daris A Nevil&t;&t;&t;&t;( dnevil@snmc.com )&n; .  &t;Pramod B Bhardwaj   &t;&t;&t;(pramod.bhardwaj@smsc.com)&n; .&n; .&n; . Hardware multicast code from Peter Cammaert ( pc@denkart.be )&n; .&n; . Sources:&n; .    o   SMSC LAN91C111 databook (www.smsc.com)&n; .    o   smc9194.c by Erik Stahlman&n; .    o   skeleton.c by Donald Becker ( becker@cesdis.gsfc.nasa.gov )&n; .&n; . History:&n; .    09/24/01  Pramod B Bhardwaj, Added the changes for Kernel 2.4&n; .    08/21/01  Pramod B Bhardwaj Added support for RevB of LAN91C111&n; .&t;04/25/01  Daris A Nevil  Initial public release through SMSC&n; .&t;03/16/01  Daris A Nevil  Modified smc9194.c for use with LAN91C111&n; . &t;01/14/03  Takeo Takahashi Support M32RUT-LAN(Rev.B)&n; . &t;02/25/04  Hirokazu Takata, Hayato Fujiwara, Mamoru Sakugawa&n; .                SMP support for Linux/M32R.&n; ----------------------------------------------------------------------------*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#if defined(__m32r__)
DECL|macro|SMC_DEBUG
mdefine_line|#define SMC_DEBUG 0
DECL|macro|smc_init
mdefine_line|#define smc_init&t;m32r_smc_init
macro_line|#endif
macro_line|#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_OPSPUT)
DECL|macro|NO_AUTOPROBE
mdefine_line|#define NO_AUTOPROBE
macro_line|#endif
singleline_comment|// Use power-down feature of the chip
DECL|macro|POWER_DOWN
mdefine_line|#define POWER_DOWN&t;0
DECL|variable|version
r_static
r_const
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;SMSC LAN91C111 Driver (v2.0), (Linux Kernel 2.4 + Support for Odd Byte) 09/24/01 -      by Pramod Bhardwaj (pramod.bhardwaj@smsc.com)&bslash;n&quot;
suffix:semicolon
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#if defined(__m32r__)
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#else&t;/* Not __m32r__ */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
singleline_comment|//#include &lt;linux/kcomp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#ifdef CONFIG_SYSCTL
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#endif
macro_line|#include &quot;smc91111.h&quot;
multiline_comment|/*------------------------------------------------------------------------&n; .&n; . Configuration options, for the experienced user to change.&n; .&n; -------------------------------------------------------------------------*/
multiline_comment|/*&n; . Do you want to use 32 bit xfers?  This should work on all chips, as&n; . the chipset is designed to accommodate them.&n;*/
macro_line|#if !defined(__m32r__)
DECL|macro|USE_32_BIT
mdefine_line|#define USE_32_BIT 1
macro_line|#endif
multiline_comment|/*&n; .the LAN91C111 can be at any of the following port addresses.  To change,&n; .for a slightly different card, you can add it to the array.  Keep in&n; .mind that the array must end in zero.&n;*/
DECL|variable|__initdata
r_static
r_int
r_int
id|smc_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2A0
comma
l_int|0x2C0
comma
l_int|0x2E0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0x380
comma
l_int|0x3A0
comma
l_int|0x3C0
comma
l_int|0x3E0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; . Wait time for memory to be free.  This probably shouldn&squot;t be&n; . tuned that much, as waiting for this means nothing else happens&n; . in the system&n;*/
DECL|macro|MEMORY_WAIT_TIME
mdefine_line|#define MEMORY_WAIT_TIME 16
multiline_comment|/*&n; . This selects whether TX packets are sent one by one to the SMC91x internal&n; . memory ans throttled until transmission completes.  This may prevent&n; . RX overruns a litle by keeping much of the memory free for RX packets&n; . but to the expense of reduced TX throughput and increased IRQ overhead.&n; . Note this is not a cure for a too slow data bus or too high IRQ latency.&n; */
DECL|macro|THROTTLE_TX_PKTS
mdefine_line|#define THROTTLE_TX_PKTS        1
multiline_comment|/*&n; . DEBUGGING LEVELS&n; .&n; . 0 for normal operation&n; . 1 for slightly more details&n; . &gt;2 for various levels of increasingly useless information&n; .    2 for interrupt tracking, status flags&n; .    3 for packet info&n; .    4 for complete packet dumps&n;*/
singleline_comment|//#define SMC_DEBUG 3 // Must be defined in makefile
macro_line|#if (SMC_DEBUG &gt; 2 )
DECL|macro|PRINTK3
mdefine_line|#define PRINTK3(args...) printk(args)
macro_line|#else
DECL|macro|PRINTK3
mdefine_line|#define PRINTK3(args...)
macro_line|#endif
macro_line|#if SMC_DEBUG &gt; 1
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(args...) printk(args)
macro_line|#else
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(args...)
macro_line|#endif
macro_line|#ifdef SMC_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(args...) printk(args)
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(args...)
macro_line|#endif
multiline_comment|/*------------------------------------------------------------------------&n; .&n; . The internal workings of the driver.  If you are changing anything&n; . here with the SMC stuff, you should have the datasheet and know&n; . what you are doing.&n; .&n; -------------------------------------------------------------------------*/
DECL|macro|CARDNAME
mdefine_line|#define CARDNAME &quot;LAN91C111&quot;
singleline_comment|// Memory sizing constant
DECL|macro|LAN91C111_MEMORY_MULTIPLIER
mdefine_line|#define LAN91C111_MEMORY_MULTIPLIER&t;(1024*2)
multiline_comment|/* store this information for the driver.. */
DECL|struct|smc_local
r_struct
id|smc_local
(brace
singleline_comment|// these are things that the kernel wants me to keep, so users
singleline_comment|// can find out semi-useless statistics of how well the card is
singleline_comment|// performing
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
singleline_comment|// If I have to wait until memory is available to send
singleline_comment|// a packet, I will store the skbuff here, until I get the
singleline_comment|// desired memory.  Then, I&squot;ll send it out and free it.
DECL|member|saved_skb
r_struct
id|sk_buff
op_star
id|saved_skb
suffix:semicolon
singleline_comment|// This keeps track of how many packets that I have
singleline_comment|// sent out.  When an TX_EMPTY interrupt comes, I know
singleline_comment|// that all of these have been sent.
DECL|member|packets_waiting
r_int
id|packets_waiting
suffix:semicolon
singleline_comment|// Set to true during the auto-negotiation sequence
DECL|member|autoneg_active
r_int
id|autoneg_active
suffix:semicolon
singleline_comment|// Address of our PHY port
DECL|member|phyaddr
id|word
id|phyaddr
suffix:semicolon
singleline_comment|// Type of PHY
DECL|member|phytype
id|word
id|phytype
suffix:semicolon
singleline_comment|// Last contents of PHY Register 18
DECL|member|lastPhy18
id|word
id|lastPhy18
suffix:semicolon
singleline_comment|// Contains the current active transmission mode
DECL|member|tcr_cur_mode
id|word
id|tcr_cur_mode
suffix:semicolon
singleline_comment|// Contains the current active receive mode
DECL|member|rcr_cur_mode
id|word
id|rcr_cur_mode
suffix:semicolon
singleline_comment|// Contains the current active receive/phy mode
DECL|member|rpc_cur_mode
id|word
id|rpc_cur_mode
suffix:semicolon
multiline_comment|/* =&gt; Pramod, Odd Byte issue */
singleline_comment|// Contains the Current ChipID
DECL|member|ChipID
r_int
r_int
id|ChipID
suffix:semicolon
singleline_comment|//Contains the Current ChipRevision
DECL|member|ChipRev
r_int
r_int
id|ChipRev
suffix:semicolon
multiline_comment|/* &lt;= Pramod, Odd Byte issue */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
singleline_comment|// Root directory /proc/sys/dev
singleline_comment|// Second entry must be null to terminate the table
DECL|member|root_table
id|ctl_table
id|root_table
(braket
l_int|2
)braket
suffix:semicolon
singleline_comment|// Directory for this device /proc/sys/dev/ethX
singleline_comment|// Again the second entry must be zero to terminate
DECL|member|eth_table
id|ctl_table
id|eth_table
(braket
l_int|2
)braket
suffix:semicolon
singleline_comment|// This is the parameters (file) table
DECL|member|param_table
id|ctl_table
id|param_table
(braket
id|CTL_SMC_LAST_ENTRY
)braket
suffix:semicolon
singleline_comment|// Saves the sysctl header returned by register_sysctl_table()
singleline_comment|// we send this to unregister_sysctl_table()
DECL|member|sysctl_header
r_struct
id|ctl_table_header
op_star
id|sysctl_header
suffix:semicolon
singleline_comment|// Parameter variables (files) go here
DECL|member|ctl_info
r_char
id|ctl_info
(braket
l_int|1024
)braket
suffix:semicolon
DECL|member|ctl_swfdup
r_int
id|ctl_swfdup
suffix:semicolon
DECL|member|ctl_ephloop
r_int
id|ctl_ephloop
suffix:semicolon
DECL|member|ctl_miiop
r_int
id|ctl_miiop
suffix:semicolon
DECL|member|ctl_autoneg
r_int
id|ctl_autoneg
suffix:semicolon
DECL|member|ctl_rfduplx
r_int
id|ctl_rfduplx
suffix:semicolon
DECL|member|ctl_rspeed
r_int
id|ctl_rspeed
suffix:semicolon
DECL|member|ctl_afduplx
r_int
id|ctl_afduplx
suffix:semicolon
DECL|member|ctl_aspeed
r_int
id|ctl_aspeed
suffix:semicolon
DECL|member|ctl_lnkfail
r_int
id|ctl_lnkfail
suffix:semicolon
DECL|member|ctl_forcol
r_int
id|ctl_forcol
suffix:semicolon
DECL|member|ctl_filtcar
r_int
id|ctl_filtcar
suffix:semicolon
DECL|member|ctl_freemem
r_int
id|ctl_freemem
suffix:semicolon
DECL|member|ctl_totmem
r_int
id|ctl_totmem
suffix:semicolon
DECL|member|ctl_leda
r_int
id|ctl_leda
suffix:semicolon
DECL|member|ctl_ledb
r_int
id|ctl_ledb
suffix:semicolon
DECL|member|ctl_chiprev
r_int
id|ctl_chiprev
suffix:semicolon
macro_line|#ifdef SMC_DEBUG
DECL|member|ctl_reg_bsr
r_int
id|ctl_reg_bsr
suffix:semicolon
DECL|member|ctl_reg_tcr
r_int
id|ctl_reg_tcr
suffix:semicolon
DECL|member|ctl_reg_esr
r_int
id|ctl_reg_esr
suffix:semicolon
DECL|member|ctl_reg_rcr
r_int
id|ctl_reg_rcr
suffix:semicolon
DECL|member|ctl_reg_ctrr
r_int
id|ctl_reg_ctrr
suffix:semicolon
DECL|member|ctl_reg_mir
r_int
id|ctl_reg_mir
suffix:semicolon
DECL|member|ctl_reg_rpcr
r_int
id|ctl_reg_rpcr
suffix:semicolon
DECL|member|ctl_reg_cfgr
r_int
id|ctl_reg_cfgr
suffix:semicolon
DECL|member|ctl_reg_bar
r_int
id|ctl_reg_bar
suffix:semicolon
DECL|member|ctl_reg_iar0
r_int
id|ctl_reg_iar0
suffix:semicolon
DECL|member|ctl_reg_iar1
r_int
id|ctl_reg_iar1
suffix:semicolon
DECL|member|ctl_reg_iar2
r_int
id|ctl_reg_iar2
suffix:semicolon
DECL|member|ctl_reg_gpr
r_int
id|ctl_reg_gpr
suffix:semicolon
DECL|member|ctl_reg_ctlr
r_int
id|ctl_reg_ctlr
suffix:semicolon
DECL|member|ctl_reg_mcr
r_int
id|ctl_reg_mcr
suffix:semicolon
DECL|member|ctl_reg_pnr
r_int
id|ctl_reg_pnr
suffix:semicolon
DECL|member|ctl_reg_fpr
r_int
id|ctl_reg_fpr
suffix:semicolon
DECL|member|ctl_reg_ptr
r_int
id|ctl_reg_ptr
suffix:semicolon
DECL|member|ctl_reg_dr
r_int
id|ctl_reg_dr
suffix:semicolon
DECL|member|ctl_reg_isr
r_int
id|ctl_reg_isr
suffix:semicolon
DECL|member|ctl_reg_mtr1
r_int
id|ctl_reg_mtr1
suffix:semicolon
DECL|member|ctl_reg_mtr2
r_int
id|ctl_reg_mtr2
suffix:semicolon
DECL|member|ctl_reg_mtr3
r_int
id|ctl_reg_mtr3
suffix:semicolon
DECL|member|ctl_reg_mtr4
r_int
id|ctl_reg_mtr4
suffix:semicolon
DECL|member|ctl_reg_miir
r_int
id|ctl_reg_miir
suffix:semicolon
DECL|member|ctl_reg_revr
r_int
id|ctl_reg_revr
suffix:semicolon
DECL|member|ctl_reg_ercvr
r_int
id|ctl_reg_ercvr
suffix:semicolon
DECL|member|ctl_reg_extr
r_int
id|ctl_reg_extr
suffix:semicolon
DECL|member|ctl_phy_ctrl
r_int
id|ctl_phy_ctrl
suffix:semicolon
DECL|member|ctl_phy_stat
r_int
id|ctl_phy_stat
suffix:semicolon
DECL|member|ctl_phy_id1
r_int
id|ctl_phy_id1
suffix:semicolon
DECL|member|ctl_phy_id2
r_int
id|ctl_phy_id2
suffix:semicolon
DECL|member|ctl_phy_adc
r_int
id|ctl_phy_adc
suffix:semicolon
DECL|member|ctl_phy_remc
r_int
id|ctl_phy_remc
suffix:semicolon
DECL|member|ctl_phy_cfg1
r_int
id|ctl_phy_cfg1
suffix:semicolon
DECL|member|ctl_phy_cfg2
r_int
id|ctl_phy_cfg2
suffix:semicolon
DECL|member|ctl_phy_int
r_int
id|ctl_phy_int
suffix:semicolon
DECL|member|ctl_phy_mask
r_int
id|ctl_phy_mask
suffix:semicolon
macro_line|#endif 
singleline_comment|// SMC_DEBUG
macro_line|#endif 
singleline_comment|// CONFIG_SYSCTL
)brace
suffix:semicolon
multiline_comment|/*-----------------------------------------------------------------&n; .&n; .  The driver can be entered at any of the following entry points.&n; .&n; .------------------------------------------------------------------  */
multiline_comment|/*&n; . This is called by  register_netdev().  It is responsible for&n; . checking the portlist for the SMC9000 series chipset.  If it finds&n; . one, then it will initialize the device, find the hardware information,&n; . and sets up the appropriate device parameters.&n; . NOTE: Interrupts are *OFF* when this procedure is called.&n; .&n; . NB:This shouldn&squot;t be static since it is referred to externally.&n;*/
r_struct
id|net_device
op_star
id|smc_init
c_func
(paren
r_int
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n; . This is called by  unregister_netdev().  It is responsible for&n; . cleaning up before the driver is finally unregistered and discarded.&n;*/
r_void
id|smc_destructor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . The kernel calls this function when someone wants to use the net_device,&n; . typically &squot;ifconfig ethX up&squot;.&n;*/
r_static
r_int
id|smc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This is called by the kernel to send a packet out into the net.  it&squot;s&n; . responsible for doing a best-effort send, but if it&squot;s simply not possible&n; . to send it, the packet gets dropped.&n;*/
r_static
r_void
id|smc_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This is called by the kernel in response to &squot;ifconfig ethX down&squot;.  It&n; . is responsible for cleaning up everything that the open routine&n; . does, and maybe putting the card into a powerdown state.&n;*/
r_static
r_int
id|smc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This routine allows the proc file system to query the driver&squot;s&n; . statistics.&n;*/
r_static
r_struct
id|net_device_stats
op_star
id|smc_query_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . Finally, a call to set promiscuous mode ( for TCPDUMP and related&n; . programs ) and multicast modes.&n;*/
r_static
r_void
id|smc_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . Configures the PHY through the MII Management interface&n;*/
r_static
r_void
id|smc_phy_configure
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*---------------------------------------------------------------&n; .&n; . Interrupt level calls..&n; .&n; ----------------------------------------------------------------*/
multiline_comment|/*&n; . Handles the actual interrupt&n;*/
r_static
id|irqreturn_t
id|smc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; . This is a separate procedure to handle the receipt of a packet, to&n; . leave the interrupt code looking slightly cleaner&n;*/
r_static
r_inline
r_void
id|smc_rcv
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This handles a TX interrupt, which is only called when an error&n; . relating to a packet is sent.&n;*/
r_static
r_inline
r_void
id|smc_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This handles interrupts generated from PHY register 18&n;*/
r_static
r_void
id|smc_phy_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; ------------------------------------------------------------&n; .&n; . Internal routines&n; .&n; ------------------------------------------------------------&n;*/
multiline_comment|/*&n; . Test if a given location contains a chip, trying to cause as&n; . little damage as possible if it&squot;s not a SMC chip.&n;*/
r_static
r_int
id|smc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/*&n; . A rather simple routine to print out a packet for debugging purposes.&n;*/
macro_line|#if SMC_DEBUG &gt; 2
r_static
r_void
id|print_packet
c_func
(paren
id|byte
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
multiline_comment|/* this is called to actually send the packet to the chip */
r_static
r_void
id|smc_hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Since I am not sure if I will have enough room in the chip&squot;s ram&n; . to store the packet, I call this routine, which either sends it&n; . now, or generates an interrupt when the card is ready for the&n; . packet */
r_static
r_int
id|smc_wait_to_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* this does a soft reset on the device */
r_static
r_void
id|smc_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Enable Interrupts, Receive, and Transmit */
r_static
r_void
id|smc_enable
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* this puts the device in an inactive state */
r_static
r_void
id|smc_shutdown
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
macro_line|#ifndef NO_AUTOPROBE
multiline_comment|/* This routine will find the IRQ of the driver if one is not&n; . specified in the input to the device.  */
r_static
r_int
id|smc_findirq
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;  this routine will set the hardware multicast table to the specified&n;  values given it by the higher level routines&n;*/
r_static
r_void
id|smc_setmulticast
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|count
comma
r_struct
id|dev_mc_list
op_star
)paren
suffix:semicolon
r_static
r_int
id|crc32
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Routines to Read and Write the PHY Registers across the&n;   MII Management Interface&n;*/
r_static
id|word
id|smc_read_phy_register
c_func
(paren
r_int
id|ioaddr
comma
id|byte
id|phyaddr
comma
id|byte
id|phyreg
)paren
suffix:semicolon
r_static
r_void
id|smc_write_phy_register
c_func
(paren
r_int
id|ioaddr
comma
id|byte
id|phyaddr
comma
id|byte
id|phyreg
comma
id|word
id|phydata
)paren
suffix:semicolon
multiline_comment|/* Initilizes our device&squot;s sysctl proc filesystem */
macro_line|#ifdef CONFIG_SYSCTL
r_static
r_void
id|smc_sysctl_register
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|smc_sysctl_unregister
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
multiline_comment|/*&n; . Function: smc_reset( struct device* dev )&n; . Purpose:&n; .  &t;This sets the SMC91111 chip to its normal state, hopefully from whatever&n; . &t;mess that any other DOS driver has put it in.&n; .&n; . Maybe I should reset more registers to defaults in here?  SOFTRST  should&n; . do that for me.&n; .&n; . Method:&n; .&t;1.  send a SOFT RESET&n; .&t;2.  wait for it to finish&n; .&t;3.  enable autorelease mode&n; .&t;4.  reset the memory management unit&n; .&t;5.  clear all interrupts&n; .&n;*/
DECL|function|smc_reset
r_static
r_void
id|smc_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
singleline_comment|//struct smc_local *lp &t;= (struct smc_local *)dev-&gt;priv;
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_reset&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* This resets the registers mostly to defaults, but doesn&squot;t&n;&t;   affect EEPROM.  That seems unnecessary */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RCR_SOFTRST
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
multiline_comment|/* Setup the Configuration Register */
multiline_comment|/* This is necessary because the CONFIG_REG is not affected */
multiline_comment|/* by a soft reset */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CONFIG_DEFAULT
comma
id|ioaddr
op_plus
id|CONFIG_REG
)paren
suffix:semicolon
multiline_comment|/* Setup for fast accesses if requested */
multiline_comment|/* If the card/system can&squot;t handle it then there will */
multiline_comment|/* be no recovery except for a hard reset or power cycle */
r_if
c_cond
(paren
id|dev-&gt;dma
)paren
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG_REG
)paren
op_or
id|CONFIG_NO_WAIT
comma
id|ioaddr
op_plus
id|CONFIG_REG
)paren
suffix:semicolon
macro_line|#ifdef POWER_DOWN
multiline_comment|/* Release from possible power-down state */
multiline_comment|/* Configuration register is not affected by Soft Reset */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG_REG
)paren
op_or
id|CONFIG_EPH_POWER_EN
comma
id|ioaddr
op_plus
id|CONFIG_REG
)paren
suffix:semicolon
macro_line|#endif
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this should pause enough for the chip to be happy */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Disable transmit and receive functionality */
id|outw
c_func
(paren
id|RCR_CLEAR
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TCR_CLEAR
comma
id|ioaddr
op_plus
id|TCR_REG
)paren
suffix:semicolon
multiline_comment|/* set the control register to automatically&n;&t;   release successfully transmitted packets, to make the best&n;&t;   use out of our limited memory */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#if ! THROTTLE_TX_PKTS
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CTL_REG
)paren
op_or
id|CTL_AUTO_RELEASE
comma
id|ioaddr
op_plus
id|CTL_REG
)paren
suffix:semicolon
macro_line|#else
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CTL_REG
)paren
op_amp
op_complement
id|CTL_AUTO_RELEASE
comma
id|ioaddr
op_plus
id|CTL_REG
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Reset the MMU */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_RESET
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
multiline_comment|/* Note:  It doesn&squot;t seem that waiting for the MMU busy is needed here,&n;&t;   but this is a place where future chipsets _COULD_ break.  Be wary&n; &t;   of issuing another MMU command right after this */
multiline_comment|/* Disable all interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_enable&n; . Purpose: let the chip talk to the outside work&n; . Method:&n; .&t;1.  Enable the transmitter&n; .&t;2.  Enable the receiver&n; .&t;3.  Enable interrupts&n;*/
DECL|function|smc_enable
r_static
r_void
id|smc_enable
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_enable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* see the header file for options in TCR/RCR DEFAULT*/
id|outw
c_func
(paren
id|lp-&gt;tcr_cur_mode
comma
id|ioaddr
op_plus
id|TCR_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;rcr_cur_mode
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
multiline_comment|/* now, enable interrupts */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SMC_INTERRUPT_MASK
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_shutdown&n; . Purpose:  closes down the SMC91xxx chip.&n; . Method:&n; .&t;1. zero the interrupt mask&n; .&t;2. clear the enable receive flag&n; .&t;3. clear the enable xmit flags&n; .&n; . TODO:&n; .   (1) maybe utilize power down mode.&n; .&t;Why not yet?  Because while the chip will go into power down mode,&n; .&t;the manual says that it will wake up in response to any I/O requests&n; .&t;in the register space.   Empirical results do not show this working.&n;*/
DECL|function|smc_shutdown
r_static
r_void
id|smc_shutdown
c_func
(paren
r_int
id|ioaddr
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:smc_shutdown&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* no more interrupts for me */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
multiline_comment|/* and tell the card to stay away from that nasty outside world */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RCR_CLEAR
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|TCR_CLEAR
comma
id|ioaddr
op_plus
id|TCR_REG
)paren
suffix:semicolon
macro_line|#ifdef POWER_DOWN
multiline_comment|/* finally, shut the chip down */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG_REG
)paren
op_amp
op_complement
id|CONFIG_EPH_POWER_EN
comma
id|ioaddr
op_plus
id|CONFIG_REG
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )&n; . Purpose:&n; .    This sets the internal hardware table to filter out unwanted multicast&n; .    packets before they take up memory.&n; .&n; .    The SMC chip uses a hash table where the high 6 bits of the CRC of&n; .    address are the offset into the table.  If that bit is 1, then the&n; .    multicast packet is accepted.  Otherwise, it&squot;s dropped silently.&n; .&n; .    To use the 6 bits as an offset into the table, the high 3 bits are the&n; .    number of the 8 bit register, while the low 3 bits are the bit within&n; .    that register.&n; .&n; . This routine is based very heavily on the one provided by Peter Cammaert.&n;*/
DECL|function|smc_setmulticast
r_static
r_void
id|smc_setmulticast
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|count
comma
r_struct
id|dev_mc_list
op_star
id|addrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|multicast_table
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|cur_addr
suffix:semicolon
multiline_comment|/* table for flipping the order of 3 bits */
r_int
r_char
id|invert3
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|2
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|7
)brace
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:smc_setmulticast&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* start with a table of all zeros: reject all */
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
r_sizeof
(paren
id|multicast_table
)paren
)paren
suffix:semicolon
id|cur_addr
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|cur_addr
op_assign
id|cur_addr-&gt;next
)paren
(brace
r_int
id|position
suffix:semicolon
multiline_comment|/* do we have a pointer here? */
r_if
c_cond
(paren
op_logical_neg
id|cur_addr
)paren
r_break
suffix:semicolon
multiline_comment|/* make sure this is a multicast address - shouldn&squot;t this&n;&t;&t;   be a given if we have it here ? */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|cur_addr-&gt;dmi_addr
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* only use the low order bits */
id|position
op_assign
id|crc32
c_func
(paren
id|cur_addr-&gt;dmi_addr
comma
l_int|6
)paren
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* do some messy swapping to put the bit in the right spot */
id|multicast_table
(braket
id|invert3
(braket
id|position
op_amp
l_int|7
)braket
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|invert3
(braket
(paren
id|position
op_rshift
l_int|3
)paren
op_amp
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* now, the table can be loaded into the chipset */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|multicast_table
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|MCAST_REG1
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  Finds the CRC32 of a set of bytes.&n;  Again, from Peter Cammaert&squot;s code.&n;*/
DECL|function|crc32
r_static
r_int
id|crc32
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|length
)paren
(brace
multiline_comment|/* indices */
r_int
id|perByte
suffix:semicolon
r_int
id|perBit
suffix:semicolon
multiline_comment|/* crc polynomial for Ethernet */
r_const
r_int
r_int
id|poly
op_assign
l_int|0xedb88320
suffix:semicolon
multiline_comment|/* crc value - preinitialized to all 1&squot;s */
r_int
r_int
id|crc_value
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|perByte
op_assign
l_int|0
suffix:semicolon
id|perByte
OL
id|length
suffix:semicolon
id|perByte
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
id|c
op_assign
op_star
(paren
id|s
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|perBit
op_assign
l_int|0
suffix:semicolon
id|perBit
OL
l_int|8
suffix:semicolon
id|perBit
op_increment
)paren
(brace
id|crc_value
op_assign
(paren
id|crc_value
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
id|crc_value
op_xor
id|c
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
id|c
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc_value
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct device * )&n; . Purpose:&n; .    Attempt to allocate memory for a packet, if chip-memory is not&n; .    available, then tell the card to generate an interrupt when it&n; .    is available.&n; .&n; . Algorithm:&n; .&n; . o&t;if the saved_skb is not currently null, then drop this packet&n; .&t;on the floor.  This should never happen, because of TBUSY.&n; . o&t;if the saved_skb is null, then replace it with the current packet,&n; . o&t;See if I can sending it now.&n; . o &t;(NO): Enable interrupts and let the interrupt handler deal with it.&n; . o&t;(YES):Send it now.&n;*/
DECL|function|smc_wait_to_send_packet
r_static
r_int
id|smc_wait_to_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|word
id|length
suffix:semicolon
r_int
r_int
id|numPages
suffix:semicolon
id|word
id|time_out
suffix:semicolon
id|word
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_wait_to_send_packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;saved_skb
)paren
(brace
multiline_comment|/* THIS SHOULD NEVER HAPPEN. */
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Bad Craziness - sent packet while busy.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lp-&gt;saved_skb
op_assign
id|skb
suffix:semicolon
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
multiline_comment|/*&n;&t;** The MMU wants the number of pages to be the number of 256 bytes&n;&t;** &squot;pages&squot;, minus 1 ( since a packet can&squot;t ever have 0 pages :) )&n;&t;**&n;&t;** The 91C111 ignores the size bits, but the code is left intact&n;&t;** for backwards and future compatibility.&n;&t;**&n;&t;** Pkt size for allocating is data length +6 (for additional status&n;&t;** words, length and ctl!)&n;&t;**&n;&t;** If odd size then last byte is included in this header.&n;&t;*/
id|numPages
op_assign
(paren
(paren
id|length
op_amp
l_int|0xfffe
)paren
op_plus
l_int|6
)paren
suffix:semicolon
id|numPages
op_rshift_assign
l_int|8
suffix:semicolon
singleline_comment|// Divide by 256
r_if
c_cond
(paren
id|numPages
OG
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Far too big packet error. &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* freeing the packet is a good thing here... but should&n;&t;&t; . any packets of this size get down here?   */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this IS an error, but, i don&squot;t want the skb saved */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* either way, a packet is waiting now */
id|lp-&gt;packets_waiting
op_increment
suffix:semicolon
multiline_comment|/* now, try to allocate the memory */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_ALLOC
op_or
id|numPages
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
multiline_comment|/*&n; &t;. Performance Hack&n;&t;.&n; &t;. wait a short amount of time.. if I can send a packet now, I send&n;&t;. it now.  Otherwise, I enable an interrupt and wait for one to be&n;&t;. available.&n;&t;.&n;&t;. I could have handled this a slightly different way, by checking to&n;&t;. see if any memory was available in the FREE MEMORY register.  However,&n;&t;. either way, I need to generate an allocation, and the allocation works&n;&t;. no matter what, so I saw no point in checking free memory.&n;&t;*/
id|time_out
op_assign
id|MEMORY_WAIT_TIME
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
multiline_comment|/* acknowledge the interrupt */
id|outb
c_func
(paren
id|IM_ALLOC_INT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|time_out
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|time_out
)paren
(brace
macro_line|#if defined(__m32r__)
singleline_comment|//&t;&t;netif_stop_queue(dev); &t;// 2003-07-13 by takeo
macro_line|#endif
multiline_comment|/* oh well, wait until the chip finds memory later */
id|SMC_ENABLE_INT
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
multiline_comment|/* Check the status bit one more time just in case */
multiline_comment|/* it snuk in between the time we last checked it */
multiline_comment|/* and when we set the interrupt bit */
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: memory allocation deferred. &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* it&squot;s deferred, but I&squot;ll handle it later */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Looks like it did sneak in, so disable */
multiline_comment|/* the interrupt */
id|SMC_DISABLE_INT
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
)brace
multiline_comment|/* or YES! I can send the packet now.. */
macro_line|#if THROTTLE_TX_PKTS
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|smc_hardware_send_packet
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|//&t;netif_wake_queue(dev);
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; . Function:  smc_hardware_send_packet(struct device * )&n; . Purpose:&n; .&t;This sends the actual packet to the SMC9xxx chip.&n; .&n; . Algorithm:&n; . &t;First, see if a saved_skb is available.&n; .&t;&t;( this should NOT be called if there is no &squot;saved_skb&squot;&n; .&t;Now, find the packet number that the chip allocated&n; .&t;Point the data pointers at it in memory&n; .&t;Set the length word in the chip&squot;s memory&n; .&t;Dump the packet to chip memory&n; .&t;Check if a last byte is needed ( odd length packet )&n; .&t;&t;if so, set the control flag right&n; . &t;Tell the card to send it&n; .&t;Enable the transmit interrupt, so I know if it failed&n; . &t;Free the kernel data if I actually sent it.&n;*/
DECL|function|smc_hardware_send_packet
r_static
r_void
id|smc_hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|packet_no
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|lp-&gt;saved_skb
suffix:semicolon
id|word
id|length
suffix:semicolon
r_int
r_int
id|ioaddr
suffix:semicolon
id|byte
op_star
id|buf
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_hardware_send_packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: In XMIT with no packet to send &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* If I get here, I _know_ there is a packet slot waiting for me */
id|packet_no
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|AR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_no
op_amp
id|AR_FAILED
)paren
(brace
multiline_comment|/* or isn&squot;t there?  BAD CHIP! */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Memory allocation failed. &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* we have a packet address, so tell the card to use it */
id|outb
c_func
(paren
id|packet_no
comma
id|ioaddr
op_plus
id|PN_REG
)paren
suffix:semicolon
multiline_comment|/* point to the beginning of the packet */
id|outw
c_func
(paren
id|PTR_AUTOINC
comma
id|ioaddr
op_plus
id|PTR_REG
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s: Trying to xmit packet of length %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
macro_line|#if SMC_DEBUG &gt; 2
id|printk
c_func
(paren
l_string|&quot;Transmitting Packet&bslash;n&quot;
)paren
suffix:semicolon
id|print_packet
c_func
(paren
id|buf
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* send the packet length ( +6 for status, length and ctl byte )&n; &t;   and the status word ( set to zeros ) */
macro_line|#ifdef USE_32_BIT
id|outl
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_lshift
l_int|16
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
macro_line|#else
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
multiline_comment|/* send the packet length ( +6 for status words, length, and ctl*/
id|outb
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_amp
l_int|0xFF
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_rshift
l_int|8
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* send the actual data&n;&t; . I _think_ it&squot;s faster to send the longs first, and then&n;&t; . mop up by sending the last word.  It depends heavily&n; &t; . on alignment, at least on the 486.  Maybe it would be&n; &t; . a good idea to check which is optimal?  But that could take&n;&t; . almost as much time as is saved?&n;&t;*/
macro_line|#ifdef USE_32_BIT
id|outsl
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
comma
id|buf
comma
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
op_amp
l_int|0x2
)paren
id|outw
c_func
(paren
op_star
(paren
(paren
id|word
op_star
)paren
(paren
id|buf
op_plus
(paren
id|length
op_amp
l_int|0xFFFFFFFC
)paren
)paren
)paren
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
macro_line|#else
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
comma
id|buf
comma
(paren
id|length
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif 
singleline_comment|// USE_32_BIT
multiline_comment|/* Send the last byte, if there is one.   */
r_if
c_cond
(paren
(paren
id|length
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|buf
(braket
id|length
op_minus
l_int|1
)braket
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
singleline_comment|// Set odd bit in CONTROL BYTE
)brace
multiline_comment|/* and let the chipset deal with it */
id|outw
c_func
(paren
id|MC_ENQUEUE
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
multiline_comment|/* enable the interrupts */
id|SMC_ENABLE_INT
c_func
(paren
(paren
id|IM_TX_INT
op_or
id|IM_TX_EMPTY_INT
)paren
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s: Sent packet of length %d &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
macro_line|#if defined(__m32r__)
id|lp-&gt;stats.tx_bytes
op_add_assign
id|length
suffix:semicolon
macro_line|#endif
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* we can send another packet */
singleline_comment|//&t;netif_wake_queue(dev);
r_return
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------&n; |&n; | smc_init( int unit )&n; |   Input parameters:&n; |&t;dev-&gt;base_addr == 0, try to find all possible locations&n; |&t;dev-&gt;base_addr == 1, return failure code&n; |&t;dev-&gt;base_addr == 2, always allocate space,  and return success&n; |&t;dev-&gt;base_addr == &lt;anything else&gt;   this is the address to check&n; |&n; |   Output:&n; |&t;pointer to net_device or ERR_PTR(error)&n; |&n; ---------------------------------------------------------------------------&n;*/
DECL|variable|io
r_static
r_int
id|io
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
suffix:semicolon
DECL|variable|ifport
r_static
r_int
id|ifport
suffix:semicolon
DECL|function|smc_init
r_struct
id|net_device
op_star
id|__init
id|smc_init
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
r_int
r_int
op_star
id|port
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|netdev_boot_setup_check
c_func
(paren
id|dev
)paren
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|SET_MODULE_OWNER
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|io
OG
l_int|0x1ff
)paren
(brace
multiline_comment|/* Check a single specified location. */
id|err
op_assign
id|smc_probe
c_func
(paren
id|dev
comma
id|io
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|io
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t probe at all. */
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|port
op_assign
id|smc_portlist
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smc_probe
c_func
(paren
id|dev
comma
op_star
id|port
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|port
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
r_return
id|dev
suffix:semicolon
id|out1
suffix:colon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
id|out
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------&n; |&n; | smc_destructor( struct device * dev )&n; |   Input parameters:&n; |&t;dev, pointer to the device structure&n; |&n; |   Output:&n; |&t;None.&n; |&n; ---------------------------------------------------------------------------&n;*/
DECL|function|smc_destructor
r_void
id|smc_destructor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:smc_destructor&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifndef NO_AUTOPROBE
multiline_comment|/*----------------------------------------------------------------------&n; . smc_findirq&n; .&n; . This routine has a simple purpose -- make the SMC chip generate an&n; . interrupt, so an auto-detect routine can detect it, and find the IRQ,&n; ------------------------------------------------------------------------&n;*/
DECL|function|smc_findirq
r_int
id|__init
id|smc_findirq
c_func
(paren
r_int
id|ioaddr
)paren
(brace
r_int
id|timeout
op_assign
l_int|20
suffix:semicolon
r_int
r_int
id|cookie
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:smc_findirq&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* I have to do a STI() here, because this is called from&n;&t;   a routine that does an CLI during this process, making it&n;&t;   rather difficult to get interrupts for auto detection */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What I try to do here is trigger an ALLOC_INT. This is done&n;&t; * by allocating a small chunk of memory, which will give an interrupt&n;&t; * when done.&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* enable ALLOCation interrupts ONLY */
id|outb
c_func
(paren
id|IM_ALLOC_INT
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
multiline_comment|/*&n; &t; . Allocate 512 bytes of memory.  Note that the chip was just&n;&t; . reset so all the memory is available&n;&t;*/
id|outw
c_func
(paren
id|MC_ALLOC
op_or
l_int|1
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . Wait until positive that the interrupt has been generated&n;&t;*/
r_while
c_loop
(paren
id|timeout
)paren
(brace
id|byte
id|int_status
suffix:semicolon
id|int_status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
id|IM_ALLOC_INT
)paren
r_break
suffix:semicolon
multiline_comment|/* got the interrupt */
id|timeout
op_decrement
suffix:semicolon
)brace
multiline_comment|/* there is really nothing that I can do here if timeout fails,&n;&t;   as autoirq_report will return a 0 anyway, which is what I&n;&t;   want in this case.   Plus, the clean up is needed in both&n;&t;   cases.  */
multiline_comment|/* DELAY HERE!&n;&t;   On a fast machine, the status might change before the interrupt&n;&t;   is given to the processor.  This means that the interrupt was&n;&t;   never detected, and autoirq_report fails to report anything.&n;&t;   This should fix autoirq_* problems.&n;&t;*/
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* and disable all interrupts again */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
multiline_comment|/* clear hardware interrupts again, because that&squot;s how it&n;&t;   was when I was called... */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and return what I found */
r_return
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------------&n; . Function: smc_probe( int ioaddr )&n; .&n; . Purpose:&n; .&t;Tests to see if a given ioaddr points to an SMC91111 chip.&n; .&t;Returns a 0 on success&n; .&n; . Algorithm:&n; .&t;(1) see if the high byte of BANK_SELECT is 0x33&n; . &t;(2) compare the ioaddr with the base register&squot;s address&n; .&t;(3) see if I recognize the chip ID in the appropriate register&n; .&n; .---------------------------------------------------------------------&n; */
multiline_comment|/*---------------------------------------------------------------&n; . Here I do typical initialization tasks.&n; .&n; . o  Initialize the structure if needed&n; . o  print out my vanity message if not done so already&n; . o  print out what type of hardware is detected&n; . o  print out the ethernet address&n; . o  find the IRQ&n; . o  set up my private data&n; . o  configure the dev structure with my subroutines&n; . o  actually GRAB the irq.&n; . o  GRAB the region&n; .-----------------------------------------------------------------*/
DECL|function|smc_probe
r_static
r_int
id|__init
id|smc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|memory
comma
id|retval
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bank
suffix:semicolon
r_const
r_char
op_star
id|version_string
suffix:semicolon
multiline_comment|/*registers */
id|word
id|revision_register
suffix:semicolon
id|word
id|base_address_register
suffix:semicolon
id|word
id|memory_info_register
suffix:semicolon
multiline_comment|/*=&gt; Pramod */
r_struct
id|smc_local
op_star
id|lp
suffix:semicolon
multiline_comment|/*&lt;= Pramod */
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:smc_probe&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Grab the region so that no one else tries to probe our ioports. */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|SMC_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|dev-&gt;if_port
op_assign
id|ifport
suffix:semicolon
multiline_comment|/* First, see if the high byte is 0x33 */
id|bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bank
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* The above MIGHT indicate a device, but I need to write to further test this.  */
id|outw
c_func
(paren
l_int|0x0
comma
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
id|bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bank
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* well, we&squot;ve already written once, so hopefully another time won&squot;t&n; &t;   hurt.  This time, I need to switch the bank register to bank 1,&n;&t;   so I can access the base address register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_address_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BASE_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_ne
(paren
id|base_address_register
op_rshift
l_int|3
op_amp
l_int|0x3E0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CARDNAME: IOADDR %x doesn&squot;t match configuration (%x).&quot;
l_string|&quot;Probably not a SMC chip&bslash;n&quot;
comma
id|ioaddr
comma
id|base_address_register
op_rshift
l_int|3
op_amp
l_int|0x3E0
)paren
suffix:semicolon
multiline_comment|/* well, the base address register didn&squot;t match.  Must not have&n;&t;&t;   been a SMC chip after all. */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*  check if the revision register is something that I recognize.&n;&t;    These might need to be added to later, as future revisions&n;&t;    could be added.  */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|REV_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip_ids
(braket
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)braket
)paren
(brace
multiline_comment|/* I don&squot;t recognize this chip, so... */
id|printk
c_func
(paren
l_string|&quot;CARDNAME: IO %x: Unrecognized revision register:&quot;
l_string|&quot; %x, Contact author. &bslash;n&quot;
comma
id|ioaddr
comma
id|revision_register
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* at this point I&squot;ll assume that the chip is an SMC9xxx.&n;&t;   It might be prudent to check a listing of MAC addresses&n;&t;   against the hardware address, or do some other tests. */
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* fill in some of the fields */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/*&n; &t; . Get the MAC address ( bank 1, regs 4 - 9 )&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|word
id|address
suffix:semicolon
id|address
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|ADDR0_REG
op_plus
id|i
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|address
op_rshift
l_int|8
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|address
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/* get the memory information */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|memory_info_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MIR_REG
)paren
suffix:semicolon
id|memory
op_assign
id|memory_info_register
op_amp
(paren
id|word
)paren
l_int|0x00ff
suffix:semicolon
id|memory
op_mul_assign
id|LAN91C111_MEMORY_MULTIPLIER
suffix:semicolon
multiline_comment|/*&n;&t; Now, I want to find out more about the chip.  This is sort of&n; &t; redundant, but it&squot;s cleaner to have it in both, rather than having&n; &t; one VERY long probe procedure.&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|REV_REG
)paren
suffix:semicolon
id|version_string
op_assign
id|chip_ids
(braket
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_string
)paren
(brace
multiline_comment|/* I shouldn&squot;t get here because this call was done before.... */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* now, reset the chip, and put it into a known state */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . If dev-&gt;irq is 0, then the device has to be banged on to see&n;&t; . what the IRQ is.&n; &t; .&n;&t; . This banging doesn&squot;t always detect the IRQ, for unknown reasons.&n;&t; . a workaround is to reset the chip and try again.&n;&t; .&n;&t; . Interestingly, the DOS packet driver *SETS* the IRQ on the card to&n;&t; . be what is requested on the command line.   I don&squot;t do that, mostly&n;&t; . because the card that I have uses a non-standard method of accessing&n;&t; . the IRQs, and because this _should_ work in most configurations.&n;&t; .&n;&t; . Specifying an IRQ is done with the assumption that the user knows&n;&t; . what (s)he is doing.  No checking is done!!!!&n; &t; .&n;&t;*/
macro_line|#if defined(CONFIG_PLAT_M32700UT) &amp;&amp; defined(NO_AUTOPROBE)
id|dev-&gt;irq
op_assign
id|M32700UT_LAN_IRQ_LAN
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PLAT_OPSPUT) &amp;&amp; defined(NO_AUTOPROBE)
id|dev-&gt;irq
op_assign
id|OPSPUT_LAN_IRQ_LAN
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NO_AUTOPROBE&t;
singleline_comment|// by takeo
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
r_int
id|trials
suffix:semicolon
id|trials
op_assign
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|trials
op_decrement
)paren
(brace
id|dev-&gt;irq
op_assign
id|smc_findirq
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
r_break
suffix:semicolon
multiline_comment|/* kick the card and try again */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t autodetect your IRQ. Use irq=xx.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Fixup for users that don&squot;t know that IRQ 2 is really IRQ 9,&n;&t;&t; * or don&squot;t know which one to set.&n;&t;&t; */
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* now, print out the card info, in a short format.. */
id|printk
c_func
(paren
l_string|&quot;%s: %s(rev:%d) at %#3x IRQ:%d MEMSIZE:%db NOWAIT:%d &quot;
comma
id|dev-&gt;name
comma
id|version_string
comma
id|revision_register
op_amp
l_int|0xF
comma
id|ioaddr
comma
id|dev-&gt;irq
comma
id|memory
comma
id|dev-&gt;dma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . Print the Ethernet address&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;ADDR: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x &bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* set the private data to zero by default */
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab the IRQ */
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|smc_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|retval
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|dev-&gt;open
op_assign
id|smc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|smc_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|smc_wait_to_send_packet
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|smc_timeout
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|smc_query_statistics
suffix:semicolon
macro_line|#ifdef&t;HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|smc_set_multicast_list
suffix:semicolon
macro_line|#endif
multiline_comment|/* =&gt; Store the ChipRevision and ChipID, to be used in resolving the Odd-Byte issue in RevB of LAN91C111; Pramod */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|REV_REG
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;ChipID
op_assign
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
suffix:semicolon
id|lp-&gt;ChipRev
op_assign
id|revision_register
op_amp
l_int|0xF
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|release_region
(paren
id|ioaddr
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#if SMC_DEBUG &gt; 2
DECL|function|print_packet
r_static
r_void
id|print_packet
c_func
(paren
id|byte
op_star
id|buf
comma
r_int
id|length
)paren
(brace
macro_line|#if 1
r_int
id|i
suffix:semicolon
r_int
id|remainder
suffix:semicolon
r_int
id|lines
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Packet of length %d &bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
macro_line|#if SMC_DEBUG &gt; 3
id|lines
op_assign
id|length
op_div
l_int|16
suffix:semicolon
id|remainder
op_assign
id|length
op_mod
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lines
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cur
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
l_int|0
suffix:semicolon
id|cur
OL
l_int|8
suffix:semicolon
id|cur
op_increment
)paren
(brace
id|byte
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|b
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remainder
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|byte
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|b
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/*&n; * Open and Initialize the board&n; *&n; * Set up everything, reset the card, etc ..&n; *&n; */
DECL|function|smc_open
r_static
r_int
id|smc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* used to set hw ethernet address */
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* clear out all the junk that was put here before... */
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
macro_line|#endif
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
singleline_comment|// Setup the default Register Modes
id|lp-&gt;tcr_cur_mode
op_assign
id|TCR_DEFAULT
suffix:semicolon
id|lp-&gt;rcr_cur_mode
op_assign
id|RCR_DEFAULT
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_assign
id|RPC_DEFAULT
suffix:semicolon
singleline_comment|// Set default parameters (files)
id|lp-&gt;ctl_swfdup
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;ctl_ephloop
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;ctl_miiop
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;ctl_autoneg
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;ctl_rfduplx
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;ctl_rspeed
op_assign
l_int|100
suffix:semicolon
id|lp-&gt;ctl_afduplx
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;ctl_aspeed
op_assign
l_int|100
suffix:semicolon
id|lp-&gt;ctl_lnkfail
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;ctl_forcol
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;ctl_filtcar
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset the hardware */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Configure the PHY */
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;  &t;&t;According to Becker, I have to set the hardware address&n;&t;&t;at this point, because the (l)user can set it with an&n;&t;&t;ioctl.  Easily done...&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|word
id|address
suffix:semicolon
id|address
op_assign
id|dev-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_lshift
l_int|8
suffix:semicolon
id|address
op_or_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
id|outw
c_func
(paren
id|address
comma
id|ioaddr
op_plus
id|ADDR0_REG
op_plus
id|i
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYSCTL
id|smc_sysctl_register
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------&n; . Called by the kernel to send a packet out into the void&n; . of the net.  This routine is largely based on&n; . skeleton.c, from Becker.&n; .--------------------------------------------------------&n;*/
DECL|function|smc_timeout
r_static
r_void
id|smc_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *      Best would be to use synchronize_irq(); spin_lock() here&n;&t; *      lets make it work first..&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_send_packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;There should really be a &quot;kick me&quot; function call instead. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* &quot;kick&quot; the adaptor */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reconfigure the PHY */
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* clear anything saved */
(paren
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------&n; .&n; . This is the main routine of the driver, to handle the net_device when&n; . it needs some attention.&n; .&n; . So:&n; .   first, save state of the chipset&n; .   branch off into routines to handle each case, and acknowledge&n; .&t;    each to the interrupt register&n; .   and finally restore state.&n; .&n; ---------------------------------------------------------------------*/
DECL|function|smc_interrupt
r_static
id|irqreturn_t
id|smc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|status
suffix:semicolon
id|word
id|card_stats
suffix:semicolon
id|byte
id|mask
suffix:semicolon
r_int
id|timeout
suffix:semicolon
multiline_comment|/* state registers */
id|word
id|saved_bank
suffix:semicolon
id|word
id|saved_pointer
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s: SMC interrupt started &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d for unknown device.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irq
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/* will Linux let this happen ??  If not, this costs some speed&n;&t;if ( dev-&gt;interrupt ) {&n;&t;&t;printk(KERN_WARNING &quot;%s: interrupt inside interrupt.&bslash;n&quot;,&n;&t;&t;&t;dev-&gt;name);&n;&t;&t;return;&n;&t;}&n;&n;&t;dev-&gt;interrupt = 1; */
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|saved_bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|saved_pointer
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|PTR_REG
)paren
suffix:semicolon
multiline_comment|/* read the interrupt status register */
id|mask
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
multiline_comment|/* disable all interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
multiline_comment|/* set a timeout value, so I don&squot;t stay here forever */
id|timeout
op_assign
l_int|8
suffix:semicolon
id|PRINTK2
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: MASK IS %x &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mask
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* read the status flag, and mask it */
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_REG
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_break
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
id|PRINTK3
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Handling interrupt status %x &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_RCV_INT
)paren
(brace
multiline_comment|/* Got a packet(s). */
id|PRINTK2
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Receive Interrupt&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|smc_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_INT
)paren
(brace
id|PRINTK2
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: TX ERROR handled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|smc_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// Acknowledge the interrupt
id|outb
c_func
(paren
id|IM_TX_INT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
macro_line|#if THROTTLE_TX_PKTS
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_EMPTY_INT
)paren
(brace
multiline_comment|/* update stats */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|card_stats
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|COUNTER_REG
)paren
suffix:semicolon
multiline_comment|/* single collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
id|card_stats
op_rshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* multiple collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
multiline_comment|/* these are for when linux supports these statistics */
macro_line|#if 0
id|card_stats
op_rshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* deferred */
id|card_stats
op_rshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* excess deferred */
macro_line|#endif
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: TX_BUFFER_EMPTY handled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Acknowledge the interrupt
id|outb
c_func
(paren
id|IM_TX_EMPTY_INT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
id|IM_TX_EMPTY_INT
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_add_assign
id|lp-&gt;packets_waiting
suffix:semicolon
id|lp-&gt;packets_waiting
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
id|PRINTK2
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Allocation interrupt &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* clear this interrupt so it doesn&squot;t happen again */
id|mask
op_and_assign
op_complement
id|IM_ALLOC_INT
suffix:semicolon
id|smc_hardware_send_packet
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* enable xmit interrupts based on this */
id|mask
op_or_assign
(paren
id|IM_TX_EMPTY_INT
op_or
id|IM_TX_INT
)paren
suffix:semicolon
multiline_comment|/* and let the card send more packets to me */
macro_line|#if ! THROTTLE_TX_PKTS
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|PRINTK2
c_func
(paren
l_string|&quot;%s: Handoff done successfully.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_RX_OVRN_INT
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: IM_RX_OVRN_INT &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
singleline_comment|// Acknowledge the interrupt
id|outb
c_func
(paren
id|IM_RX_OVRN_INT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_EPH_INT
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: UNSUPPORTED: EPH INTERRUPT &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_MDINT
)paren
(brace
id|smc_phy_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// Acknowledge the interrupt
id|outb
c_func
(paren
id|IM_MDINT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ERCV_INT
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: UNSUPPORTED: ERCV INTERRUPT &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Acknowledge the interrupt
id|outb
c_func
(paren
id|IM_ERCV_INT
comma
id|ioaddr
op_plus
id|INT_REG
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|timeout
op_decrement
)paren
suffix:semicolon
multiline_comment|/* restore register states */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mask
comma
id|ioaddr
op_plus
id|IM_REG
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: MASK is now %x &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mask
)paren
suffix:semicolon
id|outw
c_func
(paren
id|saved_pointer
comma
id|ioaddr
op_plus
id|PTR_REG
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
id|saved_bank
)paren
suffix:semicolon
singleline_comment|//dev-&gt;interrupt = 0;
id|PRINTK3
c_func
(paren
l_string|&quot;%s: Interrupt done&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------&n; .&n; . smc_rcv -  receive a packet from the card&n; .&n; . There is ( at least ) a packet waiting to be read from&n; . chip-memory.&n; .&n; . o Read the status&n; . o If an error, record it&n; . o otherwise, read in the packet&n; --------------------------------------------------------------&n;*/
DECL|function|smc_rcv
r_static
r_inline
r_void
id|smc_rcv
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|packet_number
suffix:semicolon
id|word
id|status
suffix:semicolon
id|word
id|packet_length
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_rcv&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* assume bank 2 */
id|packet_number
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RXFIFO_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_number
op_amp
id|RXFIFO_REMPTY
)paren
(brace
multiline_comment|/* we got called , but nothing was on the FIFO */
id|PRINTK
c_func
(paren
l_string|&quot;%s: WARNING: smc_rcv with nothing on FIFO. &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* don&squot;t need to restore anything */
r_return
suffix:semicolon
)brace
multiline_comment|/*  start reading from the start of the packet */
id|outw
c_func
(paren
id|PTR_READ
op_or
id|PTR_RCV
op_or
id|PTR_AUTOINC
comma
id|ioaddr
op_plus
id|PTR_REG
)paren
suffix:semicolon
multiline_comment|/* First two words are status and packet_length */
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
id|packet_length
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
id|packet_length
op_and_assign
l_int|0x07ff
suffix:semicolon
multiline_comment|/* mask off top bits */
id|PRINTK2
c_func
(paren
l_string|&quot;RCV: STATUS %4x LENGTH %4x&bslash;n&quot;
comma
id|status
comma
id|packet_length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|RS_ERRORS
)paren
)paren
(brace
multiline_comment|/* do stuff to make a new packet */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|byte
op_star
id|data
suffix:semicolon
multiline_comment|/* set multicast stats */
r_if
c_cond
(paren
id|status
op_amp
id|RS_MULTICAST
)paren
id|lp-&gt;stats.multicast
op_increment
suffix:semicolon
singleline_comment|// Allocate enough memory for entire receive frame, to be safe
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|packet_length
)paren
suffix:semicolon
multiline_comment|/* Adjust for having already read the first two words */
id|packet_length
op_sub_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Low memory, packet dropped.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; ! This should work without alignment, but it could be&n;&t;&t; ! in the worse case&n;&t;&t;*/
multiline_comment|/* TODO: Should I use 32bit alignment here ? */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 bit alignment */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* =&gt;&n;&t;&t;   ODD-BYTE ISSUE : The odd byte problem has been fixed in the LAN91C111 Rev B.&n;&t;&t;   So we check if the Chip Revision, stored in smsc_local-&gt;ChipRev, is = 1.&n;&t;&t;   If so then we increment the packet length only if RS_ODDFRAME is set.&n;&t;&t;   If the Chip&squot;s revision is equal to 0, then we blindly increment the packet length&n;&t;&t;   by 1, thus always assuming that the packet is odd length, leaving the higher layer&n;&t;&t;   to decide the actual length.&n;&t;&t;   -- Pramod&n;&t;&t;   &lt;= */
r_if
c_cond
(paren
(paren
l_int|9
op_eq
id|lp-&gt;ChipID
)paren
op_logical_and
(paren
l_int|1
op_eq
id|lp-&gt;ChipRev
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|RS_ODDFRAME
)paren
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|packet_length
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|packet_length
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// set odd length for bug in LAN91C111, REV A
singleline_comment|// which never sets RS_ODDFRAME
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|packet_length
op_plus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef USE_32_BIT
id|PRINTK3
c_func
(paren
l_string|&quot; Reading %d dwords (and %d bytes) &bslash;n&quot;
comma
id|packet_length
op_rshift
l_int|2
comma
id|packet_length
op_amp
l_int|3
)paren
suffix:semicolon
multiline_comment|/* QUESTION:  Like in the TX routine, do I want&n;&t;&t;   to send the DWORDs or the bytes first, or some&n;&t;&t;   mixture.  A mixture might improve already slow PIO&n;&t;&t;   performance  */
id|insl
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
comma
id|data
comma
id|packet_length
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* read the left over bytes */
id|insb
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
comma
id|data
op_plus
(paren
id|packet_length
op_amp
l_int|0xFFFFFC
)paren
comma
id|packet_length
op_amp
l_int|0x3
)paren
suffix:semicolon
macro_line|#else
id|PRINTK3
c_func
(paren
l_string|&quot; Reading %d words and %d byte(s) &bslash;n&quot;
comma
(paren
id|packet_length
op_rshift
l_int|1
)paren
comma
id|packet_length
op_amp
l_int|1
)paren
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
comma
id|data
comma
id|packet_length
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif 
singleline_comment|// USE_32_BIT
macro_line|#if&t;SMC_DEBUG &gt; 2
id|printk
c_func
(paren
l_string|&quot;Receiving Packet&bslash;n&quot;
)paren
suffix:semicolon
id|print_packet
c_func
(paren
id|data
comma
id|packet_length
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
macro_line|#if defined(__m32r__)
id|lp-&gt;stats.rx_bytes
op_add_assign
id|packet_length
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* error ... */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_ALGNERR
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RS_TOOSHORT
op_or
id|RS_TOOLONG
)paren
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_BADCRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
op_amp
id|MC_BUSY
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
singleline_comment|// Wait until not busy
id|done
suffix:colon
multiline_comment|/*  error or good, tell the card to get rid of this packet */
id|outw
c_func
(paren
id|MC_RELEASE
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*************************************************************************&n; . smc_tx&n; .&n; . Purpose:  Handle a transmit error message.   This will only be called&n; .   when an error, because of the AUTO_RELEASE mode.&n; .&n; . Algorithm:&n; .&t;Save pointer and packet no&n; .&t;Get the packet no from the top of the queue&n; .&t;check if it&squot;s valid ( if not, is this an error??? )&n; .&t;read the status word&n; .&t;record the error&n; .&t;( resend?  Not really, since we don&squot;t want old packets around )&n; .&t;Restore saved values&n; ************************************************************************/
DECL|function|smc_tx
r_static
r_inline
r_void
id|smc_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|saved_packet
suffix:semicolon
id|byte
id|packet_no
suffix:semicolon
id|word
id|tx_status
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_tx&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* assume bank 2  */
id|saved_packet
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PN_REG
)paren
suffix:semicolon
id|packet_no
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RXFIFO_REG
)paren
suffix:semicolon
macro_line|#if defined(__m32r__)
multiline_comment|/* If the TX FIFO is empty then nothing to do */
r_if
c_cond
(paren
id|packet_no
op_amp
id|TXFIFO_TEMPTY
)paren
r_return
suffix:semicolon
id|packet_no
op_and_assign
l_int|0x7F
suffix:semicolon
macro_line|#else
id|packet_no
op_and_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* If the TX FIFO is empty then nothing to do */
r_if
c_cond
(paren
id|packet_no
op_amp
id|TXFIFO_TEMPTY
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* select this as the packet to read from */
id|outb
c_func
(paren
id|packet_no
comma
id|ioaddr
op_plus
id|PN_REG
)paren
suffix:semicolon
multiline_comment|/* read the first word (status word) from this packet */
id|outw
c_func
(paren
id|PTR_AUTOINC
op_or
id|PTR_READ
comma
id|ioaddr
op_plus
id|PTR_REG
)paren
suffix:semicolon
id|tx_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_REG
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s: TX DONE STATUS: %4x &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_status
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LOSTCAR
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LATCOL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Late collision occurred on last xmit.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
id|lp-&gt;ctl_forcol
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Reset forced collsion
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_16COL
)paren
(brace
dot
dot
dot
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_SUCCESS
)paren
(brace
singleline_comment|//&t;  &t;printk(&quot;%s: Successful packet caused interrupt &bslash;n&quot;, dev-&gt;name);
)brace
multiline_comment|/* re-enable transmit */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|TCR_REG
)paren
op_or
id|TCR_ENABLE
comma
id|ioaddr
op_plus
id|TCR_REG
)paren
suffix:semicolon
multiline_comment|/* kill the packet */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_FREEPKT
comma
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
suffix:semicolon
multiline_comment|/* one less packet waiting for me */
id|lp-&gt;packets_waiting
op_decrement
suffix:semicolon
multiline_comment|/* Don&squot;t change Packet Number Reg until busy bit is cleared */
multiline_comment|/* Per LAN91C111 Spec, Page 50 */
r_while
c_loop
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MMU_CMD_REG
)paren
op_amp
id|MC_BUSY
)paren
suffix:semicolon
id|outb
c_func
(paren
id|saved_packet
comma
id|ioaddr
op_plus
id|PN_REG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n; . smc_close&n; .&n; . this makes the board clean up everything that it can&n; . and not talk to the outside world.   Caused by&n; . an &squot;ifconfig ethX down&squot;&n; .&n; -----------------------------------------------------*/
DECL|function|smc_close
r_static
r_int
id|smc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|//dev-&gt;start = 0;
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_close&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|smc_sysctl_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
multiline_comment|/* clear everything */
id|smc_shutdown
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Get the current statistics.&n; . This may be called with the card open or closed.&n; .-------------------------------------------------------------*/
DECL|function|smc_query_statistics
r_static
r_struct
id|net_device_stats
op_star
id|smc_query_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_query_statistics&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------&n; . smc_set_multicast_list&n; .&n; . This routine will, depending on the values passed to it,&n; . either make it accept multicast packets, go into&n; . promiscuous mode ( for TCPDUMP and cousins ) or accept&n; . a select set of multicast packets&n;*/
DECL|function|smc_set_multicast_list
r_static
r_void
id|smc_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_set_multicast_list&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_set_multicast_list:RCR_PRMS&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR_REG
)paren
op_or
id|RCR_PRMS
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG?  I never disable promiscuous mode if multicasting was turned on.&n;   Now, I turn off promiscuous mode, but I don&squot;t do anything to multicasting&n;   when promiscuous mode is turned on.&n;*/
multiline_comment|/* Here, I am setting this to accept all multicast packets.&n;&t;   I don&squot;t need to zero the multicast table, because the flag is&n;&t;   checked before the table is&n;&t;*/
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR_REG
)paren
op_or
id|RCR_ALMUL
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_set_multicast_list:RCR_ALMUL&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* We just get all multicast packets even if we only want them&n;&t; . from one source.  This will be changed at some future&n;&t; . point. */
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
multiline_comment|/* support hardware multicasting */
multiline_comment|/* be sure I get rid of flags I might have set */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR_REG
)paren
op_amp
op_complement
(paren
id|RCR_PRMS
op_or
id|RCR_ALMUL
)paren
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
multiline_comment|/* NOTE: this has to set the bank, so make sure it is the&n;&t;&t;   last thing called.  The bank is set to zero at the top */
id|smc_setmulticast
c_func
(paren
id|ioaddr
comma
id|dev-&gt;mc_count
comma
id|dev-&gt;mc_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:smc_set_multicast_list:~(RCR_PRMS|RCR_ALMUL)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR_REG
)paren
op_amp
op_complement
(paren
id|RCR_PRMS
op_or
id|RCR_ALMUL
)paren
comma
id|ioaddr
op_plus
id|RCR_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;  since I&squot;m disabling all multicast entirely, I need to&n;&t;&t;  clear the multicast list&n;&t;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MCAST_REG1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MCAST_REG2
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MCAST_REG3
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MCAST_REG4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|devSMC91111
r_static
r_struct
id|net_device
op_star
id|devSMC91111
suffix:semicolon
DECL|variable|nowait
r_int
id|nowait
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|nowait
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*------------------------------------------------------------&n; . Module initialization function&n; .-------------------------------------------------------------*/
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;CARDNAME:init_module&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: You shouldn&squot;t use auto-probing with insmod!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* copy the parameters from insmod into the device structure */
id|devSMC91111
op_assign
id|smc_init
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|devSMC91111
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|devSMC91111
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Cleanup when module is removed with rmmod&n; .-------------------------------------------------------------*/
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
id|devSMC91111
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|devSMC91111-&gt;irq
comma
id|devSMC91111
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|devSMC91111-&gt;base_addr
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|devSMC91111
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
macro_line|#ifdef CONFIG_SYSCTL
multiline_comment|/*------------------------------------------------------------&n; . Modify a bit in the LAN91C111 register set&n; .-------------------------------------------------------------*/
DECL|function|smc_modify_regbit
r_static
id|word
id|smc_modify_regbit
c_func
(paren
r_int
id|bank
comma
r_int
id|ioaddr
comma
r_int
id|reg
comma
r_int
r_int
id|bit
comma
r_int
id|val
)paren
(brace
id|word
id|regval
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
id|bank
)paren
suffix:semicolon
id|regval
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|regval
op_or_assign
id|bit
suffix:semicolon
r_else
id|regval
op_and_assign
op_complement
id|bit
suffix:semicolon
id|outw
c_func
(paren
id|regval
comma
id|ioaddr
)paren
suffix:semicolon
r_return
id|regval
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Retrieve a bit in the LAN91C111 register set&n; .-------------------------------------------------------------*/
DECL|function|smc_get_regbit
r_static
r_int
id|smc_get_regbit
c_func
(paren
r_int
id|bank
comma
r_int
id|ioaddr
comma
r_int
id|reg
comma
r_int
r_int
id|bit
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|reg
)paren
op_amp
id|bit
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Modify a LAN91C111 register (word access only)&n; .-------------------------------------------------------------*/
DECL|function|smc_modify_reg
r_static
r_void
id|smc_modify_reg
c_func
(paren
r_int
id|bank
comma
r_int
id|ioaddr
comma
r_int
id|reg
comma
id|word
id|val
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
id|bank
)paren
suffix:semicolon
id|outw
c_func
(paren
id|val
comma
id|ioaddr
op_plus
id|reg
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Retrieve a LAN91C111 register (word access only)&n; .-------------------------------------------------------------*/
DECL|function|smc_get_reg
r_static
r_int
id|smc_get_reg
c_func
(paren
r_int
id|bank
comma
r_int
id|ioaddr
comma
r_int
id|reg
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
id|bank
)paren
suffix:semicolon
r_return
id|inw
c_func
(paren
id|ioaddr
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|variable|smc_info_string
r_static
r_const
r_char
id|smc_info_string
(braket
)braket
op_assign
l_string|&quot;&bslash;n&quot;
l_string|&quot;info           Provides this information blurb&bslash;n&quot;
l_string|&quot;swver          Prints the software version information of this driver&bslash;n&quot;
l_string|&quot;autoneg        Auto-negotiate Mode = 1&bslash;n&quot;
l_string|&quot;rspeed         Requested Speed, 100=100Mbps, 10=10Mpbs&bslash;n&quot;
l_string|&quot;rfduplx        Requested Full Duplex Operation&bslash;n&quot;
l_string|&quot;aspeed         Actual Speed, 100=100Mbps, 10=10Mpbs&bslash;n&quot;
l_string|&quot;afduplx        Actual Full Duplex Operation&bslash;n&quot;
l_string|&quot;lnkfail        PHY Link Failure when 1&bslash;n&quot;
l_string|&quot;miiop          External MII when 1, Internal PHY when 0&bslash;n&quot;
l_string|&quot;swfdup         Switched Full Duplex Mode (allowed only in MII operation)&bslash;n&quot;
l_string|&quot;ephloop        EPH Block Loopback&bslash;n&quot;
l_string|&quot;forcol         Force a collision&bslash;n&quot;
l_string|&quot;filtcar        Filter leading edge of carrier sense for 12 bit times&bslash;n&quot;
l_string|&quot;freemem        Free buffer memory in bytes&bslash;n&quot;
l_string|&quot;totmem         Total buffer memory in bytes&bslash;n&quot;
l_string|&quot;leda           Output of LED-A (green)&bslash;n&quot;
l_string|&quot;ledb           Output of LED-B (yellow)&bslash;n&quot;
l_string|&quot;chiprev        Revision ID of the LAN91C111 chip&bslash;n&quot;
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/*------------------------------------------------------------&n; . Sysctl handler for all integer parameters&n; .-------------------------------------------------------------*/
DECL|function|smc_sysctl_handler
r_static
r_int
id|smc_sysctl_handler
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ctl-&gt;extra1
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|ctl-&gt;extra2
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
op_star
id|valp
op_assign
id|ctl-&gt;data
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|ret
suffix:semicolon
singleline_comment|// Update parameters from the real registers
r_switch
c_cond
(paren
id|ctl-&gt;ctl_name
)paren
(brace
r_case
id|CTL_SMC_FORCOL
suffix:colon
op_star
id|valp
op_assign
id|smc_get_regbit
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
comma
id|TCR_FORCOL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_FREEMEM
suffix:colon
op_star
id|valp
op_assign
(paren
(paren
id|word
)paren
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|MIR_REG
)paren
op_rshift
l_int|8
)paren
op_star
id|LAN91C111_MEMORY_MULTIPLIER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_TOTMEM
suffix:colon
op_star
id|valp
op_assign
(paren
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|MIR_REG
)paren
op_amp
(paren
id|word
)paren
l_int|0x00ff
)paren
op_star
id|LAN91C111_MEMORY_MULTIPLIER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_CHIPREV
suffix:colon
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|REV_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_AFDUPLX
suffix:colon
op_star
id|valp
op_assign
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_DPLXDET
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_ASPEED
suffix:colon
op_star
id|valp
op_assign
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_SPDDET
)paren
ques
c_cond
l_int|100
suffix:colon
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_LNKFAIL
suffix:colon
op_star
id|valp
op_assign
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_LNKFAIL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_LEDA
suffix:colon
op_star
id|valp
op_assign
(paren
id|lp-&gt;rpc_cur_mode
op_rshift
id|RPC_LSXA_SHFT
)paren
op_amp
(paren
id|word
)paren
l_int|0x0007
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_LEDB
suffix:colon
op_star
id|valp
op_assign
(paren
id|lp-&gt;rpc_cur_mode
op_rshift
id|RPC_LSXB_SHFT
)paren
op_amp
(paren
id|word
)paren
l_int|0x0007
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_MIIOP
suffix:colon
op_star
id|valp
op_assign
id|smc_get_regbit
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CONFIG_REG
comma
id|CONFIG_EXT_PHY
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SMC_DEBUG
r_case
id|CTL_SMC_REG_BSR
suffix:colon
singleline_comment|// Bank Select
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|BSR_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_TCR
suffix:colon
singleline_comment|// Transmit Control
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ESR
suffix:colon
singleline_comment|// EPH Status
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|EPH_STATUS_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_RCR
suffix:colon
singleline_comment|// Receive Control
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RCR_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CTRR
suffix:colon
singleline_comment|// Counter
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|COUNTER_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MIR
suffix:colon
singleline_comment|// Memory Information
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|MIR_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_RPCR
suffix:colon
singleline_comment|// Receive/Phy Control
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RPC_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CFGR
suffix:colon
singleline_comment|// Configuration
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CONFIG_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_BAR
suffix:colon
singleline_comment|// Base Address
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|BASE_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR0
suffix:colon
singleline_comment|// Individual Address
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR0_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR1
suffix:colon
singleline_comment|// Individual Address
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR1_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR2
suffix:colon
singleline_comment|// Individual Address
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR2_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_GPR
suffix:colon
singleline_comment|// General Purpose
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|GP_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CTLR
suffix:colon
singleline_comment|// Control
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CTL_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MCR
suffix:colon
singleline_comment|// MMU Command
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|MMU_CMD_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_PNR
suffix:colon
singleline_comment|// Packet Number
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|PN_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_FPR
suffix:colon
singleline_comment|// Allocation Result/FIFO Ports
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|RXFIFO_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_PTR
suffix:colon
singleline_comment|// Pointer
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|PTR_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_DR
suffix:colon
singleline_comment|// Data
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|DATA_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ISR
suffix:colon
singleline_comment|// Interrupt Status/Mask
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|INT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR1
suffix:colon
singleline_comment|// Multicast Table Entry 1
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR2
suffix:colon
singleline_comment|// Multicast Table Entry 2
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR3
suffix:colon
singleline_comment|// Multicast Table Entry 3
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR4
suffix:colon
singleline_comment|// Multicast Table Entry 4
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MIIR
suffix:colon
singleline_comment|// Management Interface
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MII_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_REVR
suffix:colon
singleline_comment|// Revision
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|REV_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ERCVR
suffix:colon
singleline_comment|// Early RCV
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|ERCV_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_EXTR
suffix:colon
singleline_comment|// External
op_star
id|valp
op_assign
id|smc_get_reg
c_func
(paren
l_int|7
comma
id|ioaddr
comma
id|EXT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CTRL
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CNTL_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_STAT
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_STAT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ID1
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_ID1_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ID2
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_ID2_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ADC
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_AD_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_REMC
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_RMT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CFG1
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CFG1_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CFG2
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CFG2_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_INT
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_INT_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_MASK
suffix:colon
op_star
id|valp
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_MASK_REG
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif 
singleline_comment|// SMC_DEBUG
r_default
suffix:colon
singleline_comment|// Just ignore unsupported parameters
r_break
suffix:semicolon
)brace
singleline_comment|// Save old state
id|val
op_assign
op_star
id|valp
suffix:semicolon
singleline_comment|// Perform the generic integer operation
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
comma
id|ppos
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
singleline_comment|// Write changes out to the registers
r_if
c_cond
(paren
id|write
op_logical_and
op_star
id|valp
op_ne
id|val
)paren
(brace
id|val
op_assign
op_star
id|valp
suffix:semicolon
r_switch
c_cond
(paren
id|ctl-&gt;ctl_name
)paren
(brace
r_case
id|CTL_SMC_SWFDUP
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|lp-&gt;tcr_cur_mode
op_or_assign
id|TCR_SWFDUP
suffix:semicolon
r_else
id|lp-&gt;tcr_cur_mode
op_and_assign
op_complement
id|TCR_SWFDUP
suffix:semicolon
id|smc_modify_regbit
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
comma
id|TCR_SWFDUP
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_EPHLOOP
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|lp-&gt;tcr_cur_mode
op_or_assign
id|TCR_EPH_LOOP
suffix:semicolon
r_else
id|lp-&gt;tcr_cur_mode
op_and_assign
op_complement
id|TCR_EPH_LOOP
suffix:semicolon
id|smc_modify_regbit
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
comma
id|TCR_EPH_LOOP
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_FORCOL
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|lp-&gt;tcr_cur_mode
op_or_assign
id|TCR_FORCOL
suffix:semicolon
r_else
id|lp-&gt;tcr_cur_mode
op_and_assign
op_complement
id|TCR_FORCOL
suffix:semicolon
singleline_comment|// Update the EPH block
id|smc_modify_regbit
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
comma
id|TCR_FORCOL
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_FILTCAR
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|lp-&gt;rcr_cur_mode
op_or_assign
id|RCR_FILT_CAR
suffix:semicolon
r_else
id|lp-&gt;rcr_cur_mode
op_and_assign
op_complement
id|RCR_FILT_CAR
suffix:semicolon
singleline_comment|// Update the EPH block
id|smc_modify_regbit
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RCR_REG
comma
id|RCR_FILT_CAR
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_RFDUPLX
suffix:colon
singleline_comment|// Disallow changes if in auto-negotiation mode
r_if
c_cond
(paren
id|lp-&gt;ctl_autoneg
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|lp-&gt;rpc_cur_mode
op_or_assign
id|RPC_DPLX
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
id|RPC_DPLX
suffix:semicolon
)brace
singleline_comment|// Reconfigure the PHY
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_RSPEED
suffix:colon
singleline_comment|// Disallow changes if in auto-negotiation mode
r_if
c_cond
(paren
id|lp-&gt;ctl_autoneg
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|10
)paren
id|lp-&gt;rpc_cur_mode
op_or_assign
id|RPC_SPEED
suffix:semicolon
r_else
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
id|RPC_SPEED
suffix:semicolon
singleline_comment|// Reconfigure the PHY
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_AUTONEG
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|lp-&gt;rpc_cur_mode
op_or_assign
id|RPC_ANEG
suffix:semicolon
r_else
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
id|RPC_ANEG
suffix:semicolon
singleline_comment|// Reconfigure the PHY
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_LEDA
suffix:colon
id|val
op_and_assign
l_int|0x07
suffix:semicolon
singleline_comment|// Restrict to 3 ls bits
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
(paren
id|word
)paren
(paren
l_int|0x07
op_lshift
id|RPC_LSXA_SHFT
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_or_assign
(paren
id|word
)paren
(paren
id|val
op_lshift
id|RPC_LSXA_SHFT
)paren
suffix:semicolon
singleline_comment|// Update the Internal PHY block
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RPC_REG
comma
id|lp-&gt;rpc_cur_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_LEDB
suffix:colon
id|val
op_and_assign
l_int|0x07
suffix:semicolon
singleline_comment|// Restrict to 3 ls bits
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
(paren
id|word
)paren
(paren
l_int|0x07
op_lshift
id|RPC_LSXB_SHFT
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_or_assign
(paren
id|word
)paren
(paren
id|val
op_lshift
id|RPC_LSXB_SHFT
)paren
suffix:semicolon
singleline_comment|// Update the Internal PHY block
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RPC_REG
comma
id|lp-&gt;rpc_cur_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_MIIOP
suffix:colon
singleline_comment|// Update the Internal PHY block
id|smc_modify_regbit
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CONFIG_REG
comma
id|CONFIG_EXT_PHY
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SMC_DEBUG
r_case
id|CTL_SMC_REG_BSR
suffix:colon
singleline_comment|// Bank Select
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|BSR_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_TCR
suffix:colon
singleline_comment|// Transmit Control
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|TCR_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ESR
suffix:colon
singleline_comment|// EPH Status
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|EPH_STATUS_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_RCR
suffix:colon
singleline_comment|// Receive Control
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RCR_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CTRR
suffix:colon
singleline_comment|// Counter
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|COUNTER_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MIR
suffix:colon
singleline_comment|// Memory Information
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|MIR_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_RPCR
suffix:colon
singleline_comment|// Receive/Phy Control
id|smc_modify_reg
c_func
(paren
l_int|0
comma
id|ioaddr
comma
id|RPC_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CFGR
suffix:colon
singleline_comment|// Configuration
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CONFIG_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_BAR
suffix:colon
singleline_comment|// Base Address
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|BASE_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR0
suffix:colon
singleline_comment|// Individual Address
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR0_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR1
suffix:colon
singleline_comment|// Individual Address
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR1_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_IAR2
suffix:colon
singleline_comment|// Individual Address
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|ADDR2_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_GPR
suffix:colon
singleline_comment|// General Purpose
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|GP_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_CTLR
suffix:colon
singleline_comment|// Control
id|smc_modify_reg
c_func
(paren
l_int|1
comma
id|ioaddr
comma
id|CTL_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MCR
suffix:colon
singleline_comment|// MMU Command
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|MMU_CMD_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_PNR
suffix:colon
singleline_comment|// Packet Number
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|PN_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_FPR
suffix:colon
singleline_comment|// Allocation Result/FIFO Ports
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|RXFIFO_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_PTR
suffix:colon
singleline_comment|// Pointer
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|PTR_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_DR
suffix:colon
singleline_comment|// Data
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|DATA_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ISR
suffix:colon
singleline_comment|// Interrupt Status/Mask
id|smc_modify_reg
c_func
(paren
l_int|2
comma
id|ioaddr
comma
id|INT_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR1
suffix:colon
singleline_comment|// Multicast Table Entry 1
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG1
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR2
suffix:colon
singleline_comment|// Multicast Table Entry 2
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG2
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR3
suffix:colon
singleline_comment|// Multicast Table Entry 3
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG3
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MTR4
suffix:colon
singleline_comment|// Multicast Table Entry 4
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MCAST_REG4
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_MIIR
suffix:colon
singleline_comment|// Management Interface
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|MII_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_REVR
suffix:colon
singleline_comment|// Revision
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|REV_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_ERCVR
suffix:colon
singleline_comment|// Early RCV
id|smc_modify_reg
c_func
(paren
l_int|3
comma
id|ioaddr
comma
id|ERCV_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_REG_EXTR
suffix:colon
singleline_comment|// External
id|smc_modify_reg
c_func
(paren
l_int|7
comma
id|ioaddr
comma
id|EXT_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CTRL
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CNTL_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_STAT
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_STAT_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ID1
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_ID1_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ID2
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_ID2_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_ADC
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_AD_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_REMC
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_RMT_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CFG1
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CFG1_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_CFG2
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_CFG2_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_INT
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_INT_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_SMC_PHY_MASK
suffix:colon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|lp-&gt;phyaddr
comma
id|PHY_MASK_REG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif 
singleline_comment|// SMC_DEBUG
r_default
suffix:colon
singleline_comment|// Just ignore unsupported parameters
r_break
suffix:semicolon
)brace
singleline_comment|// end switch
)brace
singleline_comment|// end if
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Sysctl registration function for all parameters (files)&n; .-------------------------------------------------------------*/
DECL|function|smc_sysctl_register
r_static
r_void
id|smc_sysctl_register
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_static
r_int
id|ctl_name
op_assign
id|CTL_SMC
suffix:semicolon
id|ctl_table
op_star
id|ct
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// Make sure the ctl_tables start out as all zeros
id|memset
c_func
(paren
id|lp-&gt;root_table
comma
l_int|0
comma
r_sizeof
id|lp-&gt;root_table
)paren
suffix:semicolon
id|memset
c_func
(paren
id|lp-&gt;eth_table
comma
l_int|0
comma
r_sizeof
id|lp-&gt;eth_table
)paren
suffix:semicolon
id|memset
c_func
(paren
id|lp-&gt;param_table
comma
l_int|0
comma
r_sizeof
id|lp-&gt;param_table
)paren
suffix:semicolon
singleline_comment|// Initialize the root table
id|ct
op_assign
id|lp-&gt;root_table
suffix:semicolon
id|ct-&gt;ctl_name
op_assign
id|CTL_DEV
suffix:semicolon
id|ct-&gt;procname
op_assign
l_string|&quot;dev&quot;
suffix:semicolon
id|ct-&gt;maxlen
op_assign
l_int|0
suffix:semicolon
id|ct-&gt;mode
op_assign
l_int|0555
suffix:semicolon
id|ct-&gt;child
op_assign
id|lp-&gt;eth_table
suffix:semicolon
singleline_comment|// remaining fields are zero
singleline_comment|// Initialize the ethX table (this device&squot;s table)
id|ct
op_assign
id|lp-&gt;eth_table
suffix:semicolon
id|ct-&gt;ctl_name
op_assign
id|ctl_name
op_increment
suffix:semicolon
singleline_comment|// Must be unique
id|ct-&gt;procname
op_assign
id|dev-&gt;name
suffix:semicolon
id|ct-&gt;maxlen
op_assign
l_int|0
suffix:semicolon
id|ct-&gt;mode
op_assign
l_int|0555
suffix:semicolon
id|ct-&gt;child
op_assign
id|lp-&gt;param_table
suffix:semicolon
singleline_comment|// remaining fields are zero
singleline_comment|// Initialize the parameter (files) table
singleline_comment|// Make sure the last entry remains null
id|ct
op_assign
id|lp-&gt;param_table
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|CTL_SMC_LAST_ENTRY
op_minus
l_int|1
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
singleline_comment|// Initialize fields common to all table entries
id|ct
(braket
id|i
)braket
dot
id|proc_handler
op_assign
id|smc_sysctl_handler
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|extra1
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
singleline_comment|// Save our device pointer
id|ct
(braket
id|i
)braket
dot
id|extra2
op_assign
(paren
r_void
op_star
)paren
id|lp
suffix:semicolon
singleline_comment|// Save our smc_local data pointer
)brace
singleline_comment|// INFO - this is our only string parameter
id|i
op_assign
l_int|0
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|proc_handler
op_assign
id|proc_dostring
suffix:semicolon
singleline_comment|// use default handler
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_INFO
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;info&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
id|smc_info_string
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|smc_info_string
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// SWVER
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|proc_handler
op_assign
id|proc_dostring
suffix:semicolon
singleline_comment|// use default handler
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_SWVER
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;swver&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
id|version
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|version
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// SWFDUP
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_SWFDUP
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;swfdup&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_swfdup
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_swfdup
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// EPHLOOP
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_EPHLOOP
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;ephloop&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_ephloop
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_ephloop
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// MIIOP
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_MIIOP
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;miiop&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_miiop
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_miiop
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// AUTONEG
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_AUTONEG
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;autoneg&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_autoneg
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_autoneg
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// RFDUPLX
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_RFDUPLX
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;rfduplx&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_rfduplx
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_rfduplx
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// RSPEED
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_RSPEED
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;rspeed&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_rspeed
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_rspeed
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// AFDUPLX
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_AFDUPLX
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;afduplx&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_afduplx
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_afduplx
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// ASPEED
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_ASPEED
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;aspeed&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_aspeed
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_aspeed
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// LNKFAIL
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_LNKFAIL
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;lnkfail&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_lnkfail
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_lnkfail
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// FORCOL
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_FORCOL
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;forcol&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_forcol
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_forcol
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// FILTCAR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_FILTCAR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;filtcar&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_filtcar
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_filtcar
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// FREEMEM
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_FREEMEM
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;freemem&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_freemem
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_freemem
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// TOTMEM
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_TOTMEM
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;totmem&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_totmem
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_totmem
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
singleline_comment|// LEDA
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_LEDA
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;leda&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_leda
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_leda
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// LEDB
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_LEDB
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;ledb&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_ledb
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_ledb
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// CHIPREV
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_CHIPREV
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;chiprev&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_chiprev
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_chiprev
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0444
suffix:semicolon
singleline_comment|// Read only
macro_line|#ifdef SMC_DEBUG
singleline_comment|// REG_BSR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_BSR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_bsr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_bsr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_bsr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_TCR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_TCR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_tcr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_tcr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_tcr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_ESR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_ESR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_esr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_esr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_esr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_RCR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_RCR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_rcr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_rcr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_rcr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_CTRR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_CTRR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_ctrr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_ctrr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_ctrr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MIR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MIR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mir&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mir
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mir
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_RPCR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_RPCR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_rpcr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_rpcr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_rpcr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_CFGR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_CFGR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_cfgr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_cfgr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_cfgr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_BAR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_BAR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_bar&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_bar
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_bar
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_IAR0
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_IAR0
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_iar0&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_iar0
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_iar0
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_IAR1
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_IAR1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_iar1&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_iar1
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_iar1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_IAR2
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_IAR2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_iar2&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_iar2
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_iar2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_GPR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_GPR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_gpr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_gpr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_gpr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_CTLR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_CTLR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_ctlr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_ctlr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_ctlr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MCR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MCR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mcr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mcr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mcr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_PNR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_PNR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_pnr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_pnr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_pnr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_FPR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_FPR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_fpr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_fpr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_fpr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_PTR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_PTR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_ptr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_ptr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_ptr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_DR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_DR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_dr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_dr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_dr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_ISR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_ISR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_isr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_isr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_isr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MTR1
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MTR1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mtr1&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mtr1
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mtr1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MTR2
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MTR2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mtr2&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mtr2
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mtr2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MTR3
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MTR3
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mtr3&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mtr3
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mtr3
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MTR4
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MTR4
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_mtr4&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_mtr4
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_mtr4
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_MIIR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_MIIR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_miir&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_miir
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_miir
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_REVR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_REVR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_revr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_revr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_revr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_ERCVR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_ERCVR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_ercvr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_ercvr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_ercvr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// REG_EXTR
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_REG_EXTR
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;reg_extr&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_reg_extr
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_reg_extr
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Control
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_CTRL
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_ctrl&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_ctrl
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_ctrl
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Status
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_STAT
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_stat&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_stat
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_stat
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY ID1
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_ID1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_id1&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_id1
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_id1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY ID2
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_ID2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_id2&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_id2
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_id2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Advertise Capabilities
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_ADC
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_adc&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_adc
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_adc
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Remote Capabilities
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_REMC
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_remc&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_remc
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_remc
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Configuration 1
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_CFG1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_cfg1&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_cfg1
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_cfg1
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Configuration 2
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_CFG2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_cfg2&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_cfg2
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_cfg2
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Interrupt/Status Output
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_INT
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_int&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_int
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_int
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
singleline_comment|// PHY Interrupt/Status Mask
op_increment
id|i
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|ctl_name
op_assign
id|CTL_SMC_PHY_MASK
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|procname
op_assign
l_string|&quot;phy_mask&quot;
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|lp-&gt;ctl_phy_mask
)paren
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|maxlen
op_assign
r_sizeof
id|lp-&gt;ctl_phy_mask
suffix:semicolon
id|ct
(braket
id|i
)braket
dot
id|mode
op_assign
l_int|0644
suffix:semicolon
singleline_comment|// Read by all, write by root
macro_line|#endif 
singleline_comment|// SMC_DEBUG
singleline_comment|// Register /proc/sys/dev/ethX
id|lp-&gt;sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|lp-&gt;root_table
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Sysctl unregistration when driver is closed&n; .-------------------------------------------------------------*/
DECL|function|smc_sysctl_unregister
r_static
r_void
id|smc_sysctl_unregister
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|lp-&gt;sysctl_header
)paren
suffix:semicolon
)brace
macro_line|#endif /* endif CONFIG_SYSCTL */
singleline_comment|//---PHY CONTROL AND CONFIGURATION-----------------------------------------
macro_line|#if (SMC_DEBUG &gt; 2 )
multiline_comment|/*------------------------------------------------------------&n; . Debugging function for viewing MII Management serial bitstream&n; .-------------------------------------------------------------*/
DECL|function|smc_dump_mii_stream
r_static
r_void
id|smc_dump_mii_stream
c_func
(paren
id|byte
op_star
id|bits
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BIT#:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|i
op_mod
l_int|10
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMDOE:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|bits
(braket
id|i
)braket
op_amp
id|MII_MDOE
)paren
id|printk
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMDO :&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|bits
(braket
id|i
)braket
op_amp
id|MII_MDO
)paren
id|printk
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMDI :&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|bits
(braket
id|i
)braket
op_amp
id|MII_MDI
)paren
id|printk
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*------------------------------------------------------------&n; . Reads a register from the MII Management serial interface&n; .-------------------------------------------------------------*/
DECL|function|smc_read_phy_register
r_static
id|word
id|smc_read_phy_register
c_func
(paren
r_int
id|ioaddr
comma
id|byte
id|phyaddr
comma
id|byte
id|phyreg
)paren
(brace
r_int
id|oldBank
suffix:semicolon
r_int
id|i
suffix:semicolon
id|byte
id|mask
suffix:semicolon
id|word
id|mii_reg
suffix:semicolon
id|byte
id|bits
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|clk_idx
op_assign
l_int|0
suffix:semicolon
r_int
id|input_idx
suffix:semicolon
id|word
id|phydata
suffix:semicolon
singleline_comment|// 32 consecutive ones on MDO to establish sync
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
op_increment
id|i
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
singleline_comment|// Start code &lt;01&gt;
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
singleline_comment|// Read command &lt;10&gt;
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Output the PHY address, msb first
id|mask
op_assign
(paren
id|byte
)paren
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|phyaddr
op_amp
id|mask
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
r_else
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Shift to next lowest bit
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Output the phy register number, msb first
id|mask
op_assign
(paren
id|byte
)paren
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|phyreg
op_amp
id|mask
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
r_else
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Shift to next lowest bit
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Tristate and turnaround (2 bit times)
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|//bits[clk_idx++] = 0;
singleline_comment|// Input starts at this bit time
id|input_idx
op_assign
id|clk_idx
suffix:semicolon
singleline_comment|// Will input 16 bits
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Final clock bit
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Save the current bank
id|oldBank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
singleline_comment|// Select bank 3
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
singleline_comment|// Get the current MII register value
id|mii_reg
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
singleline_comment|// Turn off all MII Interface bits
id|mii_reg
op_and_assign
op_complement
(paren
id|MII_MDOE
op_or
id|MII_MCLK
op_or
id|MII_MDI
op_or
id|MII_MDO
)paren
suffix:semicolon
singleline_comment|// Clock all 64 cycles
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
id|bits
suffix:semicolon
op_increment
id|i
)paren
(brace
singleline_comment|// Clock Low - output data
id|outw
c_func
(paren
id|mii_reg
op_or
id|bits
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// Clock Hi - input data
id|outw
c_func
(paren
id|mii_reg
op_or
id|bits
(braket
id|i
)braket
op_or
id|MII_MCLK
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|bits
(braket
id|i
)braket
op_or_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MII_REG
)paren
op_amp
id|MII_MDI
suffix:semicolon
)brace
singleline_comment|// Return to idle state
singleline_comment|// Set clock to low, data to low, and output tristated
id|outw
c_func
(paren
id|mii_reg
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// Restore original bank select
id|SMC_SELECT_BANK
c_func
(paren
id|oldBank
)paren
suffix:semicolon
singleline_comment|// Recover input data
id|phydata
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|phydata
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bits
(braket
id|input_idx
op_increment
)braket
op_amp
id|MII_MDI
)paren
id|phydata
op_or_assign
l_int|0x0001
suffix:semicolon
)brace
macro_line|#if (SMC_DEBUG &gt; 2 )
id|printk
c_func
(paren
l_string|&quot;smc_read_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x&bslash;n&quot;
comma
id|phyaddr
comma
id|phyreg
comma
id|phydata
)paren
suffix:semicolon
id|smc_dump_mii_stream
c_func
(paren
id|bits
comma
r_sizeof
id|bits
)paren
suffix:semicolon
macro_line|#endif
r_return
id|phydata
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Writes a register to the MII Management serial interface&n; .-------------------------------------------------------------*/
DECL|function|smc_write_phy_register
r_static
r_void
id|smc_write_phy_register
c_func
(paren
r_int
id|ioaddr
comma
id|byte
id|phyaddr
comma
id|byte
id|phyreg
comma
id|word
id|phydata
)paren
(brace
r_int
id|oldBank
suffix:semicolon
r_int
id|i
suffix:semicolon
id|word
id|mask
suffix:semicolon
id|word
id|mii_reg
suffix:semicolon
id|byte
id|bits
(braket
l_int|65
)braket
suffix:semicolon
r_int
id|clk_idx
op_assign
l_int|0
suffix:semicolon
singleline_comment|// 32 consecutive ones on MDO to establish sync
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
op_increment
id|i
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
singleline_comment|// Start code &lt;01&gt;
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
singleline_comment|// Write command &lt;01&gt;
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
singleline_comment|// Output the PHY address, msb first
id|mask
op_assign
(paren
id|byte
)paren
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|phyaddr
op_amp
id|mask
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
r_else
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Shift to next lowest bit
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Output the phy register number, msb first
id|mask
op_assign
(paren
id|byte
)paren
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|phyreg
op_amp
id|mask
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
r_else
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Shift to next lowest bit
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Tristate and turnaround (2 bit times)
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Write out 16 bits of data, msb first
id|mask
op_assign
l_int|0x8000
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|phydata
op_amp
id|mask
)paren
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
op_or
id|MII_MDO
suffix:semicolon
r_else
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
id|MII_MDOE
suffix:semicolon
singleline_comment|// Shift to next lowest bit
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Final clock bit (tristate)
id|bits
(braket
id|clk_idx
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Save the current bank
id|oldBank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
singleline_comment|// Select bank 3
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
singleline_comment|// Get the current MII register value
id|mii_reg
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
singleline_comment|// Turn off all MII Interface bits
id|mii_reg
op_and_assign
op_complement
(paren
id|MII_MDOE
op_or
id|MII_MCLK
op_or
id|MII_MDI
op_or
id|MII_MDO
)paren
suffix:semicolon
singleline_comment|// Clock all cycles
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
id|bits
suffix:semicolon
op_increment
id|i
)paren
(brace
singleline_comment|// Clock Low - output data
id|outw
c_func
(paren
id|mii_reg
op_or
id|bits
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// Clock Hi - input data
id|outw
c_func
(paren
id|mii_reg
op_or
id|bits
(braket
id|i
)braket
op_or
id|MII_MCLK
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|bits
(braket
id|i
)braket
op_or_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MII_REG
)paren
op_amp
id|MII_MDI
suffix:semicolon
)brace
singleline_comment|// Return to idle state
singleline_comment|// Set clock to low, data to low, and output tristated
id|outw
c_func
(paren
id|mii_reg
comma
id|ioaddr
op_plus
id|MII_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// Restore original bank select
id|SMC_SELECT_BANK
c_func
(paren
id|oldBank
)paren
suffix:semicolon
macro_line|#if (SMC_DEBUG &gt; 2 )
id|printk
c_func
(paren
l_string|&quot;smc_write_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x&bslash;n&quot;
comma
id|phyaddr
comma
id|phyreg
comma
id|phydata
)paren
suffix:semicolon
id|smc_dump_mii_stream
c_func
(paren
id|bits
comma
r_sizeof
id|bits
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------&n; . Finds and reports the PHY address&n; .-------------------------------------------------------------*/
DECL|function|smc_detect_phy
r_static
r_int
id|smc_detect_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|word
id|phy_id1
op_assign
l_int|0
suffix:semicolon
id|word
id|phy_id2
op_assign
l_int|0
suffix:semicolon
r_int
id|phyaddr
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_detect_phy()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Scan all 32 PHY addresses if necessary
r_for
c_loop
(paren
id|phyaddr
op_assign
l_int|0
suffix:semicolon
id|phyaddr
OL
l_int|32
suffix:semicolon
op_increment
id|phyaddr
)paren
(brace
singleline_comment|// Read the PHY identifiers
id|phy_id1
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_ID1_REG
)paren
suffix:semicolon
id|phy_id2
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_ID2_REG
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s: phy_id1=%x, phy_id2=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy_id1
comma
id|phy_id2
)paren
suffix:semicolon
singleline_comment|// Make sure it is a valid identifier
r_if
c_cond
(paren
(paren
id|phy_id2
OG
l_int|0x0000
)paren
op_logical_and
(paren
id|phy_id2
OL
l_int|0xffff
)paren
op_logical_and
(paren
id|phy_id1
OG
l_int|0x0000
)paren
op_logical_and
(paren
id|phy_id1
OL
l_int|0xffff
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|phy_id1
op_ne
l_int|0x8000
)paren
op_logical_and
(paren
id|phy_id2
op_ne
l_int|0x8000
)paren
)paren
(brace
singleline_comment|// Save the PHY&squot;s address
id|lp-&gt;phyaddr
op_assign
id|phyaddr
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: No PHY found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Set the PHY type
r_if
c_cond
(paren
(paren
id|phy_id1
op_eq
l_int|0x0016
)paren
op_logical_and
(paren
(paren
id|phy_id2
op_amp
l_int|0xFFF0
)paren
op_eq
l_int|0xF840
)paren
)paren
(brace
id|lp-&gt;phytype
op_assign
id|PHY_LAN83C183
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s: PHY=LAN83C183 (LAN91C111 Internal)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy_id1
op_eq
l_int|0x0282
)paren
op_logical_and
(paren
(paren
id|phy_id2
op_amp
l_int|0xFFF0
)paren
op_eq
l_int|0x1C50
)paren
)paren
(brace
id|lp-&gt;phytype
op_assign
id|PHY_LAN83C180
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s: PHY=LAN83C180&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Waits the specified number of milliseconds - kernel friendly&n; .-------------------------------------------------------------*/
DECL|function|smc_wait_ms
r_static
r_void
id|smc_wait_ms
c_func
(paren
r_int
r_int
id|ms
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
op_plus
id|ms
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
)brace
r_else
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
op_plus
id|ms
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------&n; . Sets the PHY to a configuration as determined by the user&n; .-------------------------------------------------------------*/
DECL|function|smc_phy_fixed
r_static
r_int
id|smc_phy_fixed
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|phyaddr
op_assign
id|lp-&gt;phyaddr
suffix:semicolon
id|word
id|my_fixed_caps
suffix:semicolon
id|word
id|cfg1
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_phy_fixed()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Enter Link Disable state
id|cfg1
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CFG1_REG
)paren
suffix:semicolon
id|cfg1
op_or_assign
id|PHY_CFG1_LNKDIS
suffix:semicolon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CFG1_REG
comma
id|cfg1
)paren
suffix:semicolon
singleline_comment|// Set our fixed capabilities
singleline_comment|// Disable auto-negotiation
id|my_fixed_caps
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ctl_rfduplx
)paren
id|my_fixed_caps
op_or_assign
id|PHY_CNTL_DPLX
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_eq
l_int|100
)paren
id|my_fixed_caps
op_or_assign
id|PHY_CNTL_SPEED
suffix:semicolon
singleline_comment|// Write our capabilities to the phy control register
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CNTL_REG
comma
id|my_fixed_caps
)paren
suffix:semicolon
singleline_comment|// Re-Configure the Receive/Phy Control register
id|outw
c_func
(paren
id|lp-&gt;rpc_cur_mode
comma
id|ioaddr
op_plus
id|RPC_REG
)paren
suffix:semicolon
singleline_comment|// Success
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Configures the specified PHY using Autonegotiation. Calls&n; . smc_phy_fixed() if the user has requested a certain config.&n; .-------------------------------------------------------------*/
DECL|function|smc_phy_configure
r_static
r_void
id|smc_phy_configure
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|byte
id|phyaddr
suffix:semicolon
id|word
id|my_phy_caps
suffix:semicolon
singleline_comment|// My PHY capabilities
id|word
id|my_ad_caps
suffix:semicolon
singleline_comment|// My Advertised capabilities
id|word
id|status
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
id|PRINTK3
c_func
(paren
l_string|&quot;%s:smc_program_phy()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Set the blocking flag
id|lp-&gt;autoneg_active
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Find the address and type of our phy
r_if
c_cond
(paren
op_logical_neg
id|smc_detect_phy
c_func
(paren
id|dev
)paren
)paren
(brace
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
singleline_comment|// Get the detected phy address
id|phyaddr
op_assign
id|lp-&gt;phyaddr
suffix:semicolon
singleline_comment|// Reset the PHY, setting all other bits to zero
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CNTL_REG
comma
id|PHY_CNTL_RST
)paren
suffix:semicolon
singleline_comment|// Wait for the reset to complete, or time out
id|timeout
op_assign
l_int|6
suffix:semicolon
singleline_comment|// Wait up to 3 seconds
r_while
c_loop
(paren
id|timeout
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CNTL_REG
)paren
op_amp
id|PHY_CNTL_RST
)paren
)paren
(brace
singleline_comment|// reset complete
r_break
suffix:semicolon
)brace
id|smc_wait_ms
c_func
(paren
l_int|500
)paren
suffix:semicolon
singleline_comment|// wait 500 millisecs
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
singleline_comment|// Exit anyway if signaled
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY reset interrupted by signal&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|timeout
OL
l_int|1
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY reset timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
singleline_comment|// Read PHY Register 18, Status Output
id|lp-&gt;lastPhy18
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_INT_REG
)paren
suffix:semicolon
singleline_comment|// Enable PHY Interrupts (for register 18)
singleline_comment|// Interrupts listed here are disabled
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_MASK_REG
comma
id|PHY_INT_LOSSSYNC
op_or
id|PHY_INT_CWRD
op_or
id|PHY_INT_SSD
op_or
id|PHY_INT_ESD
op_or
id|PHY_INT_RPOL
op_or
id|PHY_INT_JAB
op_or
id|PHY_INT_SPDDET
op_or
id|PHY_INT_DPLXDET
)paren
suffix:semicolon
multiline_comment|/* Configure the Receive/Phy Control register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;rpc_cur_mode
comma
id|ioaddr
op_plus
id|RPC_REG
)paren
suffix:semicolon
singleline_comment|// Copy our capabilities from PHY_STAT_REG to PHY_AD_REG
id|my_phy_caps
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_STAT_REG
)paren
suffix:semicolon
id|my_ad_caps
op_assign
id|PHY_AD_CSMA
suffix:semicolon
singleline_comment|// I am CSMA capable
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|PHY_STAT_CAP_T4
)paren
id|my_ad_caps
op_or_assign
id|PHY_AD_T4
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|PHY_STAT_CAP_TXF
)paren
id|my_ad_caps
op_or_assign
id|PHY_AD_TX_FDX
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|PHY_STAT_CAP_TXH
)paren
id|my_ad_caps
op_or_assign
id|PHY_AD_TX_HDX
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|PHY_STAT_CAP_TF
)paren
id|my_ad_caps
op_or_assign
id|PHY_AD_10_FDX
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|PHY_STAT_CAP_TH
)paren
id|my_ad_caps
op_or_assign
id|PHY_AD_10_HDX
suffix:semicolon
singleline_comment|// Disable capabilities not selected by our user
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_ne
l_int|100
)paren
(brace
id|my_ad_caps
op_and_assign
op_complement
(paren
id|PHY_AD_T4
op_or
id|PHY_AD_TX_FDX
op_or
id|PHY_AD_TX_HDX
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;ctl_rfduplx
)paren
(brace
id|my_ad_caps
op_and_assign
op_complement
(paren
id|PHY_AD_TX_FDX
op_or
id|PHY_AD_10_FDX
)paren
suffix:semicolon
)brace
singleline_comment|// Update our Auto-Neg Advertisement Register
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_AD_REG
comma
id|my_ad_caps
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:phy caps=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|my_phy_caps
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:phy advertised caps=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|my_ad_caps
)paren
suffix:semicolon
singleline_comment|// If the user requested no auto neg, then go set his request
r_if
c_cond
(paren
op_logical_neg
(paren
id|lp-&gt;ctl_autoneg
)paren
)paren
(brace
id|smc_phy_fixed
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
singleline_comment|// Restart auto-negotiation process in order to advertise my caps
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CNTL_REG
comma
id|PHY_CNTL_ANEG_EN
op_or
id|PHY_CNTL_ANEG_RST
)paren
suffix:semicolon
singleline_comment|// Wait for the auto-negotiation to complete.  This may take from
singleline_comment|// 2 to 3 seconds.
singleline_comment|// Wait for the reset to complete, or time out
id|timeout
op_assign
l_int|20
suffix:semicolon
singleline_comment|// Wait up to 10 seconds
r_while
c_loop
(paren
id|timeout
op_decrement
)paren
(brace
id|status
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_STAT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|PHY_STAT_ANEG_ACK
)paren
(brace
singleline_comment|// auto-negotiate complete
r_break
suffix:semicolon
)brace
id|smc_wait_ms
c_func
(paren
l_int|500
)paren
suffix:semicolon
singleline_comment|// wait 500 millisecs
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
singleline_comment|// Exit anyway if signaled
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s:PHY auto-negotiate interrupted by signal&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTK3
c_func
(paren
l_string|&quot;%s:phy phy_fixed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Restart auto-negotiation if remote fault
r_if
c_cond
(paren
id|status
op_amp
id|PHY_STAT_REM_FLT
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY remote fault detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
singleline_comment|// Restart auto-negotiation
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY restarting auto-negotiation&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|smc_write_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_CNTL_REG
comma
id|PHY_CNTL_ANEG_EN
op_or
id|PHY_CNTL_ANEG_RST
op_or
id|PHY_CNTL_SPEED
op_or
id|PHY_CNTL_DPLX
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|timeout
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s:PHY auto-negotiate timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY auto-negotiate timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Fail if we detected an auto-negotiate remote fault
r_if
c_cond
(paren
id|status
op_amp
id|PHY_STAT_REM_FLT
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s:PHY remote fault detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY remote fault detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// The smc_phy_interrupt() routine will be called to update lastPhy18
singleline_comment|// Set our sysctl parameters to match auto-negotiation results
r_if
c_cond
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_SPDDET
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY 100BaseT&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_or_assign
id|RPC_SPEED
suffix:semicolon
)brace
r_else
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY 10BaseT&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
id|RPC_SPEED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_DPLXDET
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY Full Duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_or_assign
id|RPC_DPLX
suffix:semicolon
)brace
r_else
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s:PHY Half Duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_and_assign
op_complement
id|RPC_DPLX
suffix:semicolon
)brace
singleline_comment|// Re-Configure the Receive/Phy Control register
id|outw
c_func
(paren
id|lp-&gt;rpc_cur_mode
comma
id|ioaddr
op_plus
id|RPC_REG
)paren
suffix:semicolon
id|smc_phy_configure_exit
suffix:colon
singleline_comment|// Exit auto-negotiation
id|lp-&gt;autoneg_active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*************************************************************************&n; . smc_phy_interrupt&n; .&n; . Purpose:  Handle interrupts relating to PHY register 18. This is&n; .  called from the &quot;hard&quot; interrupt handler.&n; .&n; ************************************************************************/
DECL|function|smc_phy_interrupt
r_static
r_void
id|smc_phy_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|phyaddr
op_assign
id|lp-&gt;phyaddr
suffix:semicolon
id|word
id|phy18
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s: smc_phy_interrupt&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
singleline_comment|// Read PHY Register 18, Status Output
id|phy18
op_assign
id|smc_read_phy_register
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
id|PHY_INT_REG
)paren
suffix:semicolon
singleline_comment|// Exit if not more changes
r_if
c_cond
(paren
id|phy18
op_eq
id|lp-&gt;lastPhy18
)paren
r_break
suffix:semicolon
macro_line|#if (SMC_DEBUG &gt; 1 )
id|PRINTK2
c_func
(paren
l_string|&quot;%s:     phy18=0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
l_string|&quot;%s: lastPhy18=0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;lastPhy18
)paren
suffix:semicolon
singleline_comment|// Handle events
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_LNKFAIL
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_LNKFAIL
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY Link Fail=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_LNKFAIL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_LOSSSYNC
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_LOSSSYNC
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY LOSS SYNC=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_LOSSSYNC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_CWRD
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_CWRD
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY INVALID 4B5B code=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_CWRD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_SSD
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_SSD
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY No Start Of Stream=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_SSD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_ESD
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_ESD
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY No End Of Stream=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_ESD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_RPOL
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_RPOL
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY Reverse Polarity Detected=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_RPOL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_JAB
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_JAB
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY Jabber Detected=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_JAB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_SPDDET
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_SPDDET
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY Speed Detect=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_SPDDET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_DPLXDET
)paren
op_ne
(paren
id|lp-&gt;lastPhy18
op_amp
id|PHY_INT_DPLXDET
)paren
)paren
(brace
id|PRINTK2
c_func
(paren
l_string|&quot;%s: PHY Duplex Detect=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy18
op_amp
id|PHY_INT_DPLXDET
)paren
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// Update the last phy 18 variable
id|lp-&gt;lastPhy18
op_assign
id|phy18
suffix:semicolon
)brace
singleline_comment|// end while
)brace
eof
