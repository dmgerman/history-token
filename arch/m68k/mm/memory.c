multiline_comment|/*&n; *  linux/arch/m68k/mm/memory.c&n; *&n; *  Copyright (C) 1995  Hamish Macdonald&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#ifdef CONFIG_AMIGA
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#endif
multiline_comment|/* ++andreas: {get,free}_pointer_table rewritten to use unused fields from&n;   struct page instead of separately kmalloced struct.  Stolen from&n;   arch/sparc/mm/srmmu.c ... */
DECL|typedef|ptable_desc
r_typedef
r_struct
id|list_head
id|ptable_desc
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ptable_list
)paren
suffix:semicolon
DECL|macro|PD_PTABLE
mdefine_line|#define PD_PTABLE(page) ((ptable_desc *)&amp;(virt_to_page(page)-&gt;list))
DECL|macro|PD_PAGE
mdefine_line|#define PD_PAGE(ptable) (list_entry(ptable, struct page, list))
DECL|macro|PD_MARKBITS
mdefine_line|#define PD_MARKBITS(dp) (*(unsigned char *)&amp;PD_PAGE(dp)-&gt;index)
DECL|macro|PTABLE_SIZE
mdefine_line|#define PTABLE_SIZE (PTRS_PER_PMD * sizeof(pmd_t))
DECL|function|init_pointer_table
r_void
id|__init
id|init_pointer_table
c_func
(paren
r_int
r_int
id|ptable
)paren
(brace
id|ptable_desc
op_star
id|dp
suffix:semicolon
r_int
r_int
id|page
op_assign
id|ptable
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|1
op_lshift
(paren
(paren
id|ptable
op_minus
id|page
)paren
op_div
id|PTABLE_SIZE
)paren
suffix:semicolon
id|dp
op_assign
id|PD_PTABLE
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
op_amp
id|mask
)paren
)paren
(brace
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
op_assign
l_int|0xff
suffix:semicolon
id|list_add
c_func
(paren
id|dp
comma
op_amp
id|ptable_list
)paren
suffix:semicolon
)brace
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
op_and_assign
op_complement
id|mask
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;init_pointer_table: %lx, %x&bslash;n&quot;
comma
id|ptable
comma
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* unreserve the page so it&squot;s possible to free that page */
id|PD_PAGE
c_func
(paren
id|dp
)paren
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_reserved
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|PD_PAGE
c_func
(paren
id|dp
)paren
op_member_access_from_pointer
id|count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|get_pointer_table
id|pmd_t
op_star
id|get_pointer_table
(paren
r_void
)paren
(brace
id|ptable_desc
op_star
id|dp
op_assign
id|ptable_list.next
suffix:semicolon
r_int
r_char
id|mask
op_assign
id|PD_MARKBITS
(paren
id|dp
)paren
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
r_int
id|off
suffix:semicolon
multiline_comment|/*&n;&t; * For a pointer table for a user process address space, a&n;&t; * table is taken from a page allocated for the purpose.  Each&n;&t; * page can hold 8 pointer tables.  The page is remapped in&n;&t; * virtual address space to be noncacheable.&n;&t; */
r_if
c_cond
(paren
id|mask
op_eq
l_int|0
)paren
(brace
r_void
op_star
id|page
suffix:semicolon
id|ptable_desc
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|flush_tlb_kernel_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|nocache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_new
op_assign
id|PD_PTABLE
c_func
(paren
id|page
)paren
suffix:semicolon
id|PD_MARKBITS
c_func
(paren
r_new
)paren
op_assign
l_int|0xfe
suffix:semicolon
id|list_add_tail
c_func
(paren
r_new
comma
id|dp
)paren
suffix:semicolon
r_return
(paren
id|pmd_t
op_star
)paren
id|page
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tmp
op_assign
l_int|1
comma
id|off
op_assign
l_int|0
suffix:semicolon
(paren
id|mask
op_amp
id|tmp
)paren
op_eq
l_int|0
suffix:semicolon
id|tmp
op_lshift_assign
l_int|1
comma
id|off
op_add_assign
id|PTABLE_SIZE
)paren
suffix:semicolon
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
op_assign
id|mask
op_amp
op_complement
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
)paren
(brace
multiline_comment|/* move to end of list */
id|list_del
c_func
(paren
id|dp
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|dp
comma
op_amp
id|ptable_list
)paren
suffix:semicolon
)brace
r_return
(paren
id|pmd_t
op_star
)paren
(paren
id|page_address
c_func
(paren
id|PD_PAGE
c_func
(paren
id|dp
)paren
)paren
op_plus
id|off
)paren
suffix:semicolon
)brace
DECL|function|free_pointer_table
r_int
id|free_pointer_table
(paren
id|pmd_t
op_star
id|ptable
)paren
(brace
id|ptable_desc
op_star
id|dp
suffix:semicolon
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|ptable
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|1
op_lshift
(paren
(paren
(paren
r_int
r_int
)paren
id|ptable
op_minus
id|page
)paren
op_div
id|PTABLE_SIZE
)paren
suffix:semicolon
id|dp
op_assign
id|PD_PTABLE
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PD_MARKBITS
(paren
id|dp
)paren
op_amp
id|mask
)paren
id|panic
(paren
l_string|&quot;table already free!&quot;
)paren
suffix:semicolon
id|PD_MARKBITS
(paren
id|dp
)paren
op_or_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|PD_MARKBITS
c_func
(paren
id|dp
)paren
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* all tables in page are free, free page */
id|list_del
c_func
(paren
id|dp
)paren
suffix:semicolon
id|cache_page
c_func
(paren
(paren
r_void
op_star
)paren
id|page
)paren
suffix:semicolon
id|free_page
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ptable_list.next
op_ne
id|dp
)paren
(brace
multiline_comment|/*&n;&t;&t; * move this descriptor to the front of the list, since&n;&t;&t; * it has one or more free tables.&n;&t;&t; */
id|list_del
c_func
(paren
id|dp
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|dp
comma
op_amp
id|ptable_list
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if DEBUG_INVALID_PTOV
DECL|variable|mm_inv_cnt
r_int
id|mm_inv_cnt
op_assign
l_int|5
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_SINGLE_MEMORY_CHUNK
multiline_comment|/*&n; * The following two routines map from a physical address to a kernel&n; * virtual address and vice versa.&n; */
DECL|function|mm_vtop
r_int
r_int
id|mm_vtop
c_func
(paren
r_int
r_int
id|vaddr
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|voff
op_assign
(paren
r_int
r_int
)paren
id|vaddr
op_minus
id|PAGE_OFFSET
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|voff
OL
id|m68k_memory
(braket
id|i
)braket
dot
id|size
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;VTOP(%p)=%lx&bslash;n&quot;
comma
id|vaddr
comma
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
)paren
suffix:semicolon
macro_line|#endif
r_return
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
suffix:semicolon
)brace
id|voff
op_sub_assign
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|m68k_num_memory
)paren
suffix:semicolon
multiline_comment|/* As a special case allow `__pa(high_memory)&squot;.  */
r_if
c_cond
(paren
id|voff
op_eq
l_int|0
)paren
r_return
id|m68k_memory
(braket
id|i
op_minus
l_int|1
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef CONFIG_SINGLE_MEMORY_CHUNK
DECL|function|mm_ptov
r_int
r_int
id|mm_ptov
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|poff
comma
id|voff
op_assign
id|PAGE_OFFSET
suffix:semicolon
r_do
(brace
id|poff
op_assign
id|paddr
op_minus
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|poff
OL
id|m68k_memory
(braket
id|i
)braket
dot
id|size
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;PTOV(%lx)=%lx&bslash;n&quot;
comma
id|paddr
comma
id|poff
op_plus
id|voff
)paren
suffix:semicolon
macro_line|#endif
r_return
id|poff
op_plus
id|voff
suffix:semicolon
)brace
id|voff
op_add_assign
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|m68k_num_memory
)paren
suffix:semicolon
macro_line|#if DEBUG_INVALID_PTOV
r_if
c_cond
(paren
id|mm_inv_cnt
OG
l_int|0
)paren
(brace
id|mm_inv_cnt
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Invalid use of phys_to_virt(0x%lx) at 0x%p!&bslash;n&quot;
comma
id|paddr
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* invalidate page in both caches */
DECL|function|clear040
r_static
r_inline
r_void
id|clear040
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;cinvp %%bc,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|paddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate page in i-cache */
DECL|function|cleari040
r_static
r_inline
r_void
id|cleari040
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;cinvp %%ic,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|paddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* push page in both caches */
multiline_comment|/* RZ: cpush %bc DOES invalidate %ic, regardless of DPI */
DECL|function|push040
r_static
r_inline
r_void
id|push040
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;cpushp %%bc,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|paddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* push and invalidate page in both caches, must disable ints&n; * to avoid invalidating valid data */
DECL|function|pushcl040
r_static
r_inline
r_void
id|pushcl040
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|push040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_060
)paren
id|clear040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * 040: Hit every page containing an address in the range paddr..paddr+len-1.&n; * (Low order bits of the ea of a CINVP/CPUSHP are &quot;don&squot;t care&quot;s).&n; * Hit every page until there is a page or less to go. Hit the next page,&n; * and the one after that if the range hits it.&n; */
multiline_comment|/* ++roman: A little bit more care is required here: The CINVP instruction&n; * invalidates cache entries WITHOUT WRITING DIRTY DATA BACK! So the beginning&n; * and the end of the region must be treated differently if they are not&n; * exactly at the beginning or end of a page boundary. Else, maybe too much&n; * data becomes invalidated and thus lost forever. CPUSHP does what we need:&n; * it invalidates the page after pushing dirty data to memory. (Thanks to Jes&n; * for discovering the problem!)&n; */
multiline_comment|/* ... but on the &squot;060, CPUSH doesn&squot;t invalidate (for us, since we have set&n; * the DPI bit in the CACR; would it cause problems with temporarily changing&n; * this?). So we have to push first and then additionally to invalidate.&n; */
multiline_comment|/*&n; * cache_clear() semantics: Clear any cache entries for the area in question,&n; * without writing back dirty entries first. This is useful if the data will&n; * be overwritten anyway, e.g. by DMA to memory. The range is defined by a&n; * _physical_ address.&n; */
DECL|function|cache_clear
r_void
id|cache_clear
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * We need special treatment for the first page, in case it&n;&t; * is not page-aligned. Page align the addresses to work&n;&t; * around bug I17 in the 68060.&n;&t; */
r_if
c_cond
(paren
(paren
id|tmp
op_assign
op_minus
id|paddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|tmp
)paren
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|paddr
op_add_assign
id|tmp
suffix:semicolon
)brace
id|tmp
op_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len
op_sub_assign
id|tmp
)paren
op_ge
l_int|0
)paren
(brace
id|clear040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|paddr
op_add_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_add_assign
id|tmp
)paren
)paren
multiline_comment|/* a page boundary gets crossed at the end */
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I_AND_D
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_M68K_L2_CACHE
r_if
c_cond
(paren
id|mach_l2_flush
)paren
(brace
id|mach_l2_flush
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * cache_push() semantics: Write back any dirty cache data in the given area,&n; * and invalidate the range in the instruction cache. It needs not (but may)&n; * invalidate those entries also in the data cache. The range is defined by a&n; * _physical_ address.&n; */
DECL|function|cache_push
r_void
id|cache_push
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_int
id|tmp
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/*&n;         * on 68040 or 68060, push cache lines for pages in the range;&n;&t; * on the &squot;040 this also invalidates the pushed lines, but not on&n;&t; * the &squot;060!&n;&t; */
id|len
op_add_assign
id|paddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Work around bug I17 in the 68060 affecting some instruction&n;&t; * lines not being invalidated properly.&n;&t; */
id|paddr
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_do
(brace
id|push040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|paddr
op_add_assign
id|tmp
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_sub_assign
id|tmp
)paren
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * 68030/68020 have no writeback cache. On the other hand,&n;     * cache_push is actually a superset of cache_clear (the lines&n;     * get written back and invalidated), so we should make sure&n;     * to perform the corresponding actions. After all, this is getting&n;     * called in places where we&squot;ve just loaded code, or whatever, so&n;     * flushing the icache is appropriate; flushing the dcache shouldn&squot;t&n;     * be required.&n;     */
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_M68K_L2_CACHE
r_if
c_cond
(paren
id|mach_l2_flush
)paren
(brace
id|mach_l2_flush
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifndef CONFIG_SINGLE_MEMORY_CHUNK
DECL|function|mm_end_of_chunk
r_int
id|mm_end_of_chunk
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|m68k_num_memory
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
op_eq
id|addr
op_plus
id|len
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
eof
