multiline_comment|/*&n; * linux/arch/m68k/mm/sun3kmap.c&n; *&n; * Copyright (C) 2002 Sam Creasey &lt;sammy@sammy.net&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sun3mmu.h&gt;
DECL|macro|SUN3_KMAP_DEBUG
macro_line|#undef SUN3_KMAP_DEBUG
macro_line|#ifdef SUN3_KMAP_DEBUG
r_extern
r_void
id|print_pte_vaddr
c_func
(paren
r_int
r_int
id|vaddr
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|mmu_emu_map_pmeg
(paren
r_int
id|context
comma
r_int
id|vaddr
)paren
suffix:semicolon
DECL|function|do_page_mapin
r_static
r_inline
r_void
id|do_page_mapin
c_func
(paren
r_int
r_int
id|phys
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|type
)paren
(brace
r_int
r_int
id|pte
suffix:semicolon
id|pte_t
id|ptep
suffix:semicolon
id|ptep
op_assign
id|pfn_pte
c_func
(paren
id|phys
op_rshift
id|PAGE_SHIFT
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
id|pte
op_assign
id|pte_val
c_func
(paren
id|ptep
)paren
suffix:semicolon
id|pte
op_or_assign
id|type
suffix:semicolon
id|sun3_put_pte
c_func
(paren
id|virt
comma
id|pte
)paren
suffix:semicolon
macro_line|#ifdef SUN3_KMAP_DEBUG
id|print_pte_vaddr
c_func
(paren
id|virt
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_pmeg_mapin
r_static
r_inline
r_void
id|do_pmeg_mapin
c_func
(paren
r_int
r_int
id|phys
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|type
comma
r_int
id|pages
)paren
(brace
r_if
c_cond
(paren
id|sun3_get_segmap
c_func
(paren
id|virt
op_amp
op_complement
id|SUN3_PMEG_MASK
)paren
op_eq
id|SUN3_INVALID_PMEG
)paren
(brace
id|mmu_emu_map_pmeg
c_func
(paren
id|sun3_get_context
c_func
(paren
)paren
comma
id|virt
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pages
)paren
(brace
id|do_page_mapin
c_func
(paren
id|phys
comma
id|virt
comma
id|type
)paren
suffix:semicolon
id|phys
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|virt
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pages
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|sun3_ioremap
r_void
op_star
id|sun3_ioremap
c_func
(paren
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
r_int
r_int
id|offset
comma
id|virt
comma
id|ret
suffix:semicolon
r_int
id|pages
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* page align */
id|offset
op_assign
id|phys
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|phys
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
id|offset
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
comma
id|VM_IOREMAP
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef SUN3_KMAP_DEBUG
id|printk
c_func
(paren
l_string|&quot;ioremap: got virt %p size %lx(%lx)&bslash;n&quot;
comma
id|area-&gt;addr
comma
id|size
comma
id|area-&gt;size
)paren
suffix:semicolon
macro_line|#endif
id|pages
op_assign
id|size
op_div
id|PAGE_SIZE
suffix:semicolon
id|virt
op_assign
(paren
r_int
r_int
)paren
id|area-&gt;addr
suffix:semicolon
id|ret
op_assign
id|virt
op_plus
id|offset
suffix:semicolon
r_while
c_loop
(paren
id|pages
)paren
(brace
r_int
id|seg_pages
suffix:semicolon
id|seg_pages
op_assign
(paren
id|SUN3_PMEG_SIZE
op_minus
(paren
id|virt
op_amp
id|SUN3_PMEG_MASK
)paren
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|seg_pages
OG
id|pages
)paren
(brace
id|seg_pages
op_assign
id|pages
suffix:semicolon
)brace
id|do_pmeg_mapin
c_func
(paren
id|phys
comma
id|virt
comma
id|type
comma
id|seg_pages
)paren
suffix:semicolon
id|pages
op_sub_assign
id|seg_pages
suffix:semicolon
id|phys
op_add_assign
id|seg_pages
op_star
id|PAGE_SIZE
suffix:semicolon
id|virt
op_add_assign
id|seg_pages
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|ret
suffix:semicolon
)brace
DECL|function|__ioremap
r_void
op_star
id|__ioremap
c_func
(paren
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
id|cache
)paren
(brace
r_return
id|sun3_ioremap
c_func
(paren
id|phys
comma
id|size
comma
id|SUN3_PAGE_TYPE_IO
)paren
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|vfree
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|PAGE_MASK
op_amp
(paren
r_int
r_int
)paren
id|addr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* sun3_map_test(addr, val) -- Reads a byte from addr, storing to val,&n; * trapping the potential read fault.  Returns 0 if the access faulted,&n; * 1 on success.&n; *  &n; * This function is primarily used to check addresses on the VME bus.&n; *&n; * Mucking with the page fault handler seems a little hackish to me, but&n; * SunOS, NetBSD, and Mach all implemented this check in such a manner, &n; * so I figure we&squot;re allowed.&n; */
DECL|function|sun3_map_test
r_int
id|sun3_map_test
c_func
(paren
r_int
r_int
id|addr
comma
r_char
op_star
id|val
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;.globl _sun3_map_test_start&bslash;n&quot;
l_string|&quot;_sun3_map_test_start:&bslash;n&quot;
l_string|&quot;1: moveb (%2), (%0)&bslash;n&quot;
l_string|&quot;   moveq #1, %1&bslash;n&quot;
l_string|&quot;2:&bslash;n&quot;
l_string|&quot;.section .fixup,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
l_string|&quot;.even&bslash;n&quot;
l_string|&quot;3: moveq #0, %1&bslash;n&quot;
l_string|&quot;   jmp 2b&bslash;n&quot;
l_string|&quot;.previous&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;.align 4&bslash;n&quot;
l_string|&quot;.long 1b,3b&bslash;n&quot;
l_string|&quot;.previous&bslash;n&quot;
l_string|&quot;.globl _sun3_map_test_end&bslash;n&quot;
l_string|&quot;_sun3_map_test_end:&bslash;n&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|val
)paren
comma
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
