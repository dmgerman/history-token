multiline_comment|/*&n; *&n; * dasdfmt.c&n; *&n; *  S390 version&n; *    Copyright (C) 1999,2000 IBM Corporation&n; *    Author(s): Utz Bacher, &lt;utz.bacher@de.ibm.com&gt;&n; *&n; *  Device-in-use-checks by Fritz Elfert, &lt;felfert@to.com&gt;&n; *&n; * Still to do:&n; *   detect non-switch parameters (&quot;dasdfmt -n 170 XY&quot;) and complain about them &n; */
multiline_comment|/* #define _LINUX_BLKDEV_H */
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;sys/ioctl.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;getopt.h&gt;
macro_line|#include &lt;limits.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;mntent.h&gt;
DECL|macro|__KERNEL__
mdefine_line|#define __KERNEL__ /* we want to use kdev_t and not have to define it */
macro_line|#include &lt;linux/kdev_t.h&gt;
DECL|macro|__KERNEL__
macro_line|#undef __KERNEL__
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;asm/dasd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
DECL|macro|EXIT_MISUSE
mdefine_line|#define EXIT_MISUSE 1
DECL|macro|EXIT_BUSY
mdefine_line|#define EXIT_BUSY 2
DECL|macro|TEMPFILENAME
mdefine_line|#define TEMPFILENAME &quot;/tmp/ddfXXXXXX&quot;
DECL|macro|TEMPFILENAMECHARS
mdefine_line|#define TEMPFILENAMECHARS 8  /* 8 characters are fixed in all temp filenames */
DECL|macro|SLASHDEV
mdefine_line|#define SLASHDEV &quot;/dev/&quot;
DECL|macro|PROC_DASD_DEVICES
mdefine_line|#define PROC_DASD_DEVICES &quot;/proc/dasd/devices&quot;
multiline_comment|/* _PATH_MOUNTED is /etc/mtab - /proc/mounts does not show root-fs correctly */
DECL|macro|PROC_MOUNTS
mdefine_line|#define PROC_MOUNTS _PATH_MOUNTED
DECL|macro|PROC_SWAPS
mdefine_line|#define PROC_SWAPS &quot;/proc/swaps&quot;
DECL|macro|DASD_DRIVER_NAME
mdefine_line|#define DASD_DRIVER_NAME &quot;dasd&quot;
DECL|macro|LABEL_LENGTH
mdefine_line|#define LABEL_LENGTH 10
DECL|macro|PROC_LINE_LENGTH
mdefine_line|#define PROC_LINE_LENGTH 80
DECL|macro|ERR_LENGTH
mdefine_line|#define ERR_LENGTH 80
DECL|macro|MAX_FILELEN
mdefine_line|#define MAX_FILELEN NAME_MAX+PATH_MAX
DECL|macro|GIVEN_DEVNO
mdefine_line|#define GIVEN_DEVNO 1
DECL|macro|GIVEN_MAJOR
mdefine_line|#define GIVEN_MAJOR 2
DECL|macro|GIVEN_MINOR
mdefine_line|#define GIVEN_MINOR 4
DECL|macro|CHECK_START
mdefine_line|#define CHECK_START 1
DECL|macro|CHECK_END
mdefine_line|#define CHECK_END 2
DECL|macro|CHECK_BLKSIZE
mdefine_line|#define CHECK_BLKSIZE 4
DECL|macro|CHECK_ALL
mdefine_line|#define CHECK_ALL ~0
DECL|macro|ERRMSG
mdefine_line|#define ERRMSG(x...) {fflush(stdout);fprintf(stderr,x);}
DECL|macro|ERRMSG_EXIT
mdefine_line|#define ERRMSG_EXIT(ec,x...) {fflush(stdout);fprintf(stderr,x);exit(ec);}
DECL|macro|CHECK_SPEC_MAX_ONCE
mdefine_line|#define CHECK_SPEC_MAX_ONCE(i,str) &bslash;&n;&t;{if (i&gt;1) &bslash;&n;&t;&t;ERRMSG_EXIT(EXIT_MISUSE,&quot;%s: &quot; str &quot; &quot; &bslash;&n;&t;&t;&t;&quot;can only be specified once&bslash;n&quot;,prog_name);}
DECL|macro|PARSE_PARAM_INTO
mdefine_line|#define PARSE_PARAM_INTO(x,param,base,str) &bslash;&n;&t;{x=(int)strtol(param,&amp;endptr,base); &bslash;&n;&t;if (*endptr) &bslash;&n;&t;&t;ERRMSG_EXIT(EXIT_MISUSE,&quot;%s: &quot; str &quot; &quot; &bslash;&n;&t;&t;&t;&quot;is in invalid format&bslash;n&quot;,prog_name);}
DECL|variable|prog_name
r_char
op_star
id|prog_name
suffix:semicolon
multiline_comment|/*=&quot;dasdfmt&quot;;*/
DECL|variable|tempfilename
r_char
id|tempfilename
(braket
)braket
op_assign
id|TEMPFILENAME
suffix:semicolon
DECL|variable|_ascebc
id|__u8
id|_ascebc
(braket
l_int|256
)braket
op_assign
(brace
multiline_comment|/*00 NUL   SOH   STX   ETX   EOT   ENQ   ACK   BEL */
l_int|0x00
comma
l_int|0x01
comma
l_int|0x02
comma
l_int|0x03
comma
l_int|0x37
comma
l_int|0x2D
comma
l_int|0x2E
comma
l_int|0x2F
comma
multiline_comment|/*08  BS    HT    LF    VT    FF    CR    SO    SI */
multiline_comment|/*              -&gt;NL                               */
l_int|0x16
comma
l_int|0x05
comma
l_int|0x15
comma
l_int|0x0B
comma
l_int|0x0C
comma
l_int|0x0D
comma
l_int|0x0E
comma
l_int|0x0F
comma
multiline_comment|/*10 DLE   DC1   DC2   DC3   DC4   NAK   SYN   ETB */
l_int|0x10
comma
l_int|0x11
comma
l_int|0x12
comma
l_int|0x13
comma
l_int|0x3C
comma
l_int|0x3D
comma
l_int|0x32
comma
l_int|0x26
comma
multiline_comment|/*18 CAN    EM   SUB   ESC    FS    GS    RS    US */
multiline_comment|/*                               -&gt;IGS -&gt;IRS -&gt;IUS */
l_int|0x18
comma
l_int|0x19
comma
l_int|0x3F
comma
l_int|0x27
comma
l_int|0x22
comma
l_int|0x1D
comma
l_int|0x1E
comma
l_int|0x1F
comma
multiline_comment|/*20  SP     !     &quot;     #     $     %     &amp;     &squot; */
l_int|0x40
comma
l_int|0x5A
comma
l_int|0x7F
comma
l_int|0x7B
comma
l_int|0x5B
comma
l_int|0x6C
comma
l_int|0x50
comma
l_int|0x7D
comma
multiline_comment|/*28   (     )     *     +     ,     -    .      / */
l_int|0x4D
comma
l_int|0x5D
comma
l_int|0x5C
comma
l_int|0x4E
comma
l_int|0x6B
comma
l_int|0x60
comma
l_int|0x4B
comma
l_int|0x61
comma
multiline_comment|/*30   0     1     2     3     4     5     6     7 */
l_int|0xF0
comma
l_int|0xF1
comma
l_int|0xF2
comma
l_int|0xF3
comma
l_int|0xF4
comma
l_int|0xF5
comma
l_int|0xF6
comma
l_int|0xF7
comma
multiline_comment|/*38   8     9     :     ;     &lt;     =     &gt;     ? */
l_int|0xF8
comma
l_int|0xF9
comma
l_int|0x7A
comma
l_int|0x5E
comma
l_int|0x4C
comma
l_int|0x7E
comma
l_int|0x6E
comma
l_int|0x6F
comma
multiline_comment|/*40   @     A     B     C     D     E     F     G */
l_int|0x7C
comma
l_int|0xC1
comma
l_int|0xC2
comma
l_int|0xC3
comma
l_int|0xC4
comma
l_int|0xC5
comma
l_int|0xC6
comma
l_int|0xC7
comma
multiline_comment|/*48   H     I     J     K     L     M     N     O */
l_int|0xC8
comma
l_int|0xC9
comma
l_int|0xD1
comma
l_int|0xD2
comma
l_int|0xD3
comma
l_int|0xD4
comma
l_int|0xD5
comma
l_int|0xD6
comma
multiline_comment|/*50   P     Q     R     S     T     U     V     W */
l_int|0xD7
comma
l_int|0xD8
comma
l_int|0xD9
comma
l_int|0xE2
comma
l_int|0xE3
comma
l_int|0xE4
comma
l_int|0xE5
comma
l_int|0xE6
comma
multiline_comment|/*58   X     Y     Z     [     &bslash;     ]     ^     _ */
l_int|0xE7
comma
l_int|0xE8
comma
l_int|0xE9
comma
l_int|0xBA
comma
l_int|0xE0
comma
l_int|0xBB
comma
l_int|0xB0
comma
l_int|0x6D
comma
multiline_comment|/*60   `     a     b     c     d     e     f     g */
l_int|0x79
comma
l_int|0x81
comma
l_int|0x82
comma
l_int|0x83
comma
l_int|0x84
comma
l_int|0x85
comma
l_int|0x86
comma
l_int|0x87
comma
multiline_comment|/*68   h     i     j     k     l     m     n     o */
l_int|0x88
comma
l_int|0x89
comma
l_int|0x91
comma
l_int|0x92
comma
l_int|0x93
comma
l_int|0x94
comma
l_int|0x95
comma
l_int|0x96
comma
multiline_comment|/*70   p     q     r     s     t     u     v     w */
l_int|0x97
comma
l_int|0x98
comma
l_int|0x99
comma
l_int|0xA2
comma
l_int|0xA3
comma
l_int|0xA4
comma
l_int|0xA5
comma
l_int|0xA6
comma
multiline_comment|/*78   x     y     z     {     |     }     ~    DL */
l_int|0xA7
comma
l_int|0xA8
comma
l_int|0xA9
comma
l_int|0xC0
comma
l_int|0x4F
comma
l_int|0xD0
comma
l_int|0xA1
comma
l_int|0x07
comma
multiline_comment|/*80*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*88*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*90*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*98*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*A0*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*A8*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*B0*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*B8*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*C0*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*C8*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*D0*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*D8*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*E0        sz&t;&t;&t;&t;&t;&t;*/
l_int|0x3F
comma
l_int|0x59
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*E8*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*F0*/
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
multiline_comment|/*F8*/
l_int|0x90
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0x3F
comma
l_int|0xEA
comma
l_int|0x3F
comma
l_int|0xFF
)brace
suffix:semicolon
DECL|function|convert_label
r_void
id|convert_label
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LABEL_LENGTH
suffix:semicolon
id|i
op_increment
)paren
id|str
(braket
id|i
)braket
op_assign
id|_ascebc
(braket
id|str
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
r_void
DECL|function|exit_usage
id|exit_usage
c_func
(paren
r_int
id|exitcode
)paren
(brace
macro_line|#ifdef RANGE_FORMATTING
id|printf
c_func
(paren
l_string|&quot;Usage: %s [-htvyLV] [-l &lt;label&gt;] [-b &lt;blocksize&gt;] [&lt;range&gt;] &quot;
"&bslash;"
l_string|&quot;&lt;diskspec&gt;&bslash;n&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
macro_line|#else /* RANGE_FORMATTING */
id|printf
c_func
(paren
l_string|&quot;Usage: %s [-htvyLV] [-l &lt;label&gt;] [-b &lt;blocksize&gt;] &quot;
"&bslash;"
l_string|&quot;&lt;diskspec&gt;&bslash;n&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
macro_line|#endif /* RANGE_FORMATTING */
id|printf
c_func
(paren
l_string|&quot;       -t means testmode&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       -v means verbose mode&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       -V means print version&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       -L means don&squot;t write disk label&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       &lt;label&gt; is a label which is converted to EBCDIC and &quot;
"&bslash;"
l_string|&quot;written to disk&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       &lt;blocksize&gt; has to be power of 2 and at least 512&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef RANGE_FORMATTING
id|printf
c_func
(paren
l_string|&quot;       &lt;range&gt; is either&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -s &lt;start_track&gt; -e &lt;end_track&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       or&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -r &lt;start_track&gt;-&lt;end_track&gt;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* RANGE_FORMATTING */
id|printf
c_func
(paren
l_string|&quot;       and &lt;diskspec&gt; is either&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -f /dev/dasdX&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       or&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -n &lt;s390-devnr&gt;&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|exitcode
)paren
suffix:semicolon
)brace
r_void
DECL|function|get_xno_from_xno
id|get_xno_from_xno
c_func
(paren
r_int
op_star
id|devno
comma
id|kdev_t
op_star
id|major_no
comma
id|kdev_t
op_star
id|minor_no
comma
r_int
id|mode
)paren
(brace
id|FILE
op_star
id|file
suffix:semicolon
r_int
id|d
comma
id|rc
suffix:semicolon
id|kdev_t
id|mi
comma
id|ma
suffix:semicolon
r_int
id|mi_i
comma
id|ma_i
suffix:semicolon
multiline_comment|/* for scanf :-( */
r_char
id|line
(braket
id|PROC_LINE_LENGTH
)braket
suffix:semicolon
id|file
op_assign
id|fopen
c_func
(paren
id|PROC_DASD_DEVICES
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
op_eq
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to open &quot;
"&bslash;"
id|PROC_DASD_DEVICES
l_string|&quot;: %s (do you have the /proc &quot;
"&bslash;"
l_string|&quot;filesystem enabled?)&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;fgets(line,sizeof(line),file); omit first line */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|file
)paren
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
id|sscanf
c_func
(paren
id|line
comma
l_string|&quot;%X %*[(A-Z)] at (%d:%d)&quot;
comma
op_amp
id|d
comma
op_amp
id|ma_i
comma
op_amp
id|mi_i
)paren
suffix:semicolon
id|ma
op_assign
id|ma_i
suffix:semicolon
id|mi
op_assign
id|mi_i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|3
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|d
op_ne
op_star
id|devno
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_DEVNO
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|ma
op_ne
op_star
id|major_no
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_MAJOR
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|mi
op_ne
op_star
id|minor_no
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_MINOR
)paren
)paren
)paren
(brace
op_star
id|devno
op_assign
id|d
suffix:semicolon
op_star
id|major_no
op_assign
id|ma
suffix:semicolon
op_star
id|minor_no
op_assign
id|mi
suffix:semicolon
multiline_comment|/* yes, this is a quick exit, but the easiest way */
id|fclose
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|file
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to find device in the /proc &quot;
"&bslash;"
l_string|&quot;filesystem (are you sure to have the right param line?)&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
)brace
r_char
op_star
DECL|function|get_devname_from_devno
id|get_devname_from_devno
c_func
(paren
r_int
id|devno
comma
r_int
id|verbosity
)paren
(brace
id|kdev_t
id|major_no
comma
id|minor_no
suffix:semicolon
id|kdev_t
id|file_major
comma
id|file_minor
suffix:semicolon
r_struct
id|stat
id|stat_buf
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|found
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_char
id|tmpname
(braket
id|MAX_FILELEN
)braket
suffix:semicolon
id|DIR
op_star
id|dp
suffix:semicolon
r_struct
id|dirent
op_star
id|direntp
suffix:semicolon
multiline_comment|/**** get minor number ****/
id|get_xno_from_xno
c_func
(paren
op_amp
id|devno
comma
op_amp
id|major_no
comma
op_amp
id|minor_no
comma
id|GIVEN_DEVNO
)paren
suffix:semicolon
multiline_comment|/**** get device file ****/
r_if
c_cond
(paren
(paren
id|dp
op_assign
id|opendir
c_func
(paren
id|SLASHDEV
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: unable to read &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|direntp
op_assign
id|readdir
c_func
(paren
id|dp
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|tmpname
comma
id|SLASHDEV
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|tmpname
comma
id|direntp-&gt;d_name
)paren
suffix:semicolon
id|rc
op_assign
id|stat
c_func
(paren
id|tmpname
comma
op_amp
id|stat_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|file_major
op_assign
id|MAJOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
id|file_minor
op_assign
id|MINOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file_major
op_eq
id|major_no
)paren
op_logical_and
(paren
id|file_minor
op_eq
id|minor_no
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|devname
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|direntp-&gt;d_name
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|devname
comma
id|tmpname
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|closedir
c_func
(paren
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: unable to close directory &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;; continuing&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
r_return
id|devname
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;I didn&squot;t find device node in &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;; trying to create a temporary node&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**** get temp file and create device node *****/
id|rc
op_assign
id|mkstemp
c_func
(paren
id|tempfilename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to get temporary &quot;
"&bslash;"
l_string|&quot;filename: %s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|rc
)paren
suffix:semicolon
id|rc
op_assign
id|unlink
c_func
(paren
id|tempfilename
)paren
suffix:semicolon
id|rc
op_assign
id|mknod
c_func
(paren
id|tempfilename
comma
id|S_IFBLK
op_or
l_int|0600
comma
id|MKDEV
c_func
(paren
id|major_no
comma
id|minor_no
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to create temporary &quot;
"&bslash;"
l_string|&quot;device node %s: %s&bslash;n&quot;
comma
id|prog_name
comma
id|tempfilename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
id|tempfilename
suffix:semicolon
)brace
r_char
op_star
DECL|function|check_param
id|check_param
c_func
(paren
r_int
id|mode
comma
id|format_data_t
id|data
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
id|s
op_assign
id|malloc
c_func
(paren
id|ERR_LENGTH
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: not enough memory.&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_START
)paren
op_logical_and
(paren
id|data.start_unit
OL
l_int|0
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;start track must be greater than zero&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_END
)paren
op_logical_and
(paren
id|data.stop_unit
OL
op_minus
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;end track must be -1 or greater than zero&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_END
)paren
op_logical_and
(paren
id|data.start_unit
OG
id|data.stop_unit
)paren
op_logical_and
(paren
id|data.stop_unit
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;end track must be higher than start track&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_BLKSIZE
)paren
op_logical_and
(paren
id|data.blksize
OL
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;blocksize must be a positive integer&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|CHECK_BLKSIZE
)paren
r_while
c_loop
(paren
id|data.blksize
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|data.blksize
op_mod
l_int|2
)paren
op_logical_and
(paren
id|data.blksize
op_ne
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;blocksize must be a power of 2&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|data.blksize
op_div_assign
l_int|2
suffix:semicolon
)brace
id|free
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
m_exit
suffix:colon
r_return
id|s
suffix:semicolon
)brace
DECL|macro|ASK_PRINTOUT
mdefine_line|#define ASK_PRINTOUT printf(&quot;Please enter %s&quot;,output)
DECL|macro|ASK_GETBUFFER
mdefine_line|#define ASK_GETBUFFER fgets(buffer,sizeof(buffer),stdin)
DECL|macro|ASK_SCANFORNUMBER
mdefine_line|#define ASK_SCANFORNUMBER(var) rc=sscanf(buffer,&quot;%d%c&quot;,&amp;var,&amp;c)
DECL|macro|ASK_COMPLAIN_FORMAT
mdefine_line|#define ASK_COMPLAIN_FORMAT if ((rc==2)&amp;&amp;(c==&squot;&bslash;n&squot;)) rc=1; &bslash;&n;&t;if (rc==-1) rc=1; /* this happens, if enter is pressed */ &bslash;&n;&t;if (rc!=1) printf(&quot; -- wrong input, try again.&bslash;n&quot;)
DECL|macro|ASK_CHECK_PARAM
mdefine_line|#define ASK_CHECK_PARAM(mode) str=check_param(mode,params); &bslash;&n;&t;&t;if (str!=NULL) { printf(&quot; -- %s&bslash;n&quot;,str); rc=0; free(str); }
id|format_data_t
DECL|function|ask_user_for_data
id|ask_user_for_data
c_func
(paren
id|format_data_t
id|params
)paren
(brace
r_char
id|buffer
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* should be enough for inputing track numbers */
r_char
id|c
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
r_char
id|output
(braket
l_int|60
)braket
comma
id|o2
(braket
l_int|12
)braket
suffix:semicolon
macro_line|#ifdef RANGE_FORMATTING
id|i
op_assign
id|params.start_unit
suffix:semicolon
r_do
(brace
id|params.start_unit
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the start track of the range to format &quot;
"&bslash;"
l_string|&quot;[%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.start_unit
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_START
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
id|i
op_assign
id|params.stop_unit
suffix:semicolon
r_do
(brace
id|params.stop_unit
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the end track of the range to format [&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
id|sprintf
c_func
(paren
id|o2
comma
l_string|&quot;END]: &quot;
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|o2
comma
l_string|&quot;%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|output
comma
id|o2
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|buffer
comma
l_string|&quot;end&quot;
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|buffer
comma
l_string|&quot;end&bslash;n&quot;
)paren
)paren
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
id|params.stop_unit
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.stop_unit
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_END
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* RANGE_FORMATTING */
id|i
op_assign
id|params.blksize
suffix:semicolon
r_do
(brace
id|params.blksize
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the blocksize of the formatting [%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.blksize
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_BLKSIZE
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
r_return
id|params
suffix:semicolon
)brace
multiline_comment|/* Check if the device we are going to format is mounted.&n; * If true, complain and exit.&n; */
r_void
DECL|function|check_mounted
id|check_mounted
c_func
(paren
r_int
id|major
comma
r_int
id|minor
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_int
id|ishift
op_assign
l_int|0
suffix:semicolon
r_struct
id|mntent
op_star
id|ment
suffix:semicolon
r_struct
id|stat
id|stbuf
suffix:semicolon
r_char
id|line
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* If whole disk to be formatted ... */
r_if
c_cond
(paren
(paren
id|minor
op_mod
(paren
l_int|1U
op_lshift
id|DASD_PARTN_BITS
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ... ignore partition-selector */
id|minor
op_rshift_assign
id|DASD_PARTN_BITS
suffix:semicolon
id|ishift
op_assign
id|DASD_PARTN_BITS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * first, check filesystems&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
id|PROC_MOUNTS
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|PROC_MOUNTS
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ment
op_assign
id|getmntent
c_func
(paren
id|f
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|ment-&gt;mnt_fsname
comma
op_amp
id|stbuf
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|major
op_eq
id|MAJOR
c_func
(paren
id|stbuf.st_rdev
)paren
)paren
op_logical_and
(paren
id|minor
op_eq
(paren
id|MINOR
c_func
(paren
id|stbuf.st_rdev
)paren
op_rshift
id|ishift
)paren
)paren
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: device is mounted on %s!!&bslash;n&quot;
comma
id|prog_name
comma
id|ment-&gt;mnt_dir
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_BUSY
comma
l_string|&quot;If you really want to &quot;
l_string|&quot;format it, please unmount it.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * second, check active swap spaces&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
id|PROC_SWAPS
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
id|PROC_SWAPS
l_string|&quot; %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * skip header line&n;&t; */
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|f
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|f
)paren
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|line
suffix:semicolon
op_star
id|p
op_logical_and
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p
op_increment
)paren
suffix:semicolon
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|line
comma
op_amp
id|stbuf
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|major
op_eq
id|MAJOR
c_func
(paren
id|stbuf.st_rdev
)paren
)paren
op_logical_and
(paren
id|minor
op_eq
(paren
id|MINOR
c_func
(paren
id|stbuf.st_rdev
)paren
op_rshift
id|ishift
)paren
)paren
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: the device is in use for &quot;
l_string|&quot;swapping!!&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_BUSY
comma
l_string|&quot;If you really want to &quot;
l_string|&quot;format it, please use swapoff %s.&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_void
DECL|function|do_format_dasd
id|do_format_dasd
c_func
(paren
r_char
op_star
id|dev_name
comma
id|format_data_t
id|format_params
comma
r_int
id|testmode
comma
r_int
id|verbosity
comma
r_int
id|writenolabel
comma
r_int
id|labelspec
comma
r_char
op_star
id|label
comma
r_int
id|withoutprompt
comma
r_int
id|devno
)paren
(brace
r_int
id|fd
comma
id|rc
suffix:semicolon
r_struct
id|stat
id|stat_buf
suffix:semicolon
id|kdev_t
id|minor_no
comma
id|major_no
suffix:semicolon
r_int
id|new_blksize
suffix:semicolon
r_int
r_int
id|label_position
suffix:semicolon
r_struct
id|hd_geometry
id|new_geometry
suffix:semicolon
r_char
id|inp_buffer
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* to contain yes */
id|fd
op_assign
id|open
c_func
(paren
id|dev_name
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_eq
op_minus
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: error opening device %s: &quot;
"&bslash;"
l_string|&quot;%s&bslash;n&quot;
comma
id|prog_name
comma
id|dev_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|1
)paren
(brace
)brace
id|rc
op_assign
id|stat
c_func
(paren
id|dev_name
comma
op_amp
id|stat_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: error occured during stat: &quot;
"&bslash;"
l_string|&quot;%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|stat_buf.st_mode
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: file is not a &quot;
"&bslash;"
l_string|&quot;blockdevice.&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|major_no
op_assign
id|MAJOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
id|minor_no
op_assign
id|MINOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
)brace
id|check_mounted
c_func
(paren
id|major_no
comma
id|minor_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|writenolabel
)paren
op_logical_and
(paren
op_logical_neg
id|labelspec
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|label
comma
l_string|&quot;LNX1 x%04x&quot;
comma
id|devno
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|withoutprompt
)paren
op_logical_and
(paren
id|verbosity
op_ge
l_int|1
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|withoutprompt
)paren
)paren
(brace
id|get_xno_from_xno
c_func
(paren
op_amp
id|devno
comma
op_amp
id|major_no
comma
op_amp
id|minor_no
comma
id|GIVEN_MAJOR
op_or
id|GIVEN_MINOR
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nI am going to format the device %s in the &quot;
"&bslash;"
l_string|&quot;following way:&bslash;n&quot;
comma
id|dev_name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Device number of device : 0x%x&bslash;n&quot;
comma
id|devno
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Major number of device  : %u&bslash;n&quot;
comma
id|major_no
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Minor number of device  : %u&bslash;n&quot;
comma
id|minor_no
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Labelling device        : %s&bslash;n&quot;
comma
(paren
id|writenolabel
)paren
ques
c_cond
l_string|&quot;no&quot;
suffix:colon
l_string|&quot;yes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|writenolabel
)paren
id|printf
c_func
(paren
l_string|&quot;   Disk label              : %s&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
macro_line|#ifdef RANGE_FORMATTING
id|printf
c_func
(paren
l_string|&quot;   Start track             : %d&bslash;n&quot;
"&bslash;"
comma
id|format_params.start_unit
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   End track               : &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format_params.stop_unit
op_eq
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;last track of disk&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|format_params.stop_unit
)paren
suffix:semicolon
macro_line|#endif /* RANGE_FORMATTING */
id|printf
c_func
(paren
l_string|&quot;   Blocksize               : %d&bslash;n&quot;
"&bslash;"
comma
id|format_params.blksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|testmode
)paren
id|printf
c_func
(paren
l_string|&quot;Test mode active, omitting ioctl.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|testmode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|withoutprompt
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n---&gt;&gt; ATTENTION! &lt;&lt;---&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All data in the specified range of that &quot;
"&bslash;"
l_string|&quot;device will be lost.&bslash;nType &bslash;&quot;yes&bslash;&quot; to &quot;
"&bslash;"
l_string|&quot;continue, no will leave the disk untouched: &quot;
)paren
suffix:semicolon
id|fgets
c_func
(paren
id|inp_buffer
comma
r_sizeof
(paren
id|inp_buffer
)paren
comma
id|stdin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|inp_buffer
comma
l_string|&quot;yes&quot;
)paren
op_logical_and
id|strcasecmp
c_func
(paren
id|inp_buffer
comma
l_string|&quot;yes&bslash;n&quot;
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Omitting ioctl call (disk will &quot;
"&bslash;"
l_string|&quot;NOT be formatted).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|withoutprompt
)paren
op_logical_and
(paren
id|verbosity
OL
l_int|1
)paren
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;Formatting the device. This may take a &quot;
"&bslash;"
l_string|&quot;while (get yourself a coffee).&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ioctl
c_func
(paren
id|fd
comma
id|BIODASDFORMAT
comma
id|format_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: the dasd driver &quot;
"&bslash;"
l_string|&quot;returned with the following error &quot;
"&bslash;"
l_string|&quot;message:&bslash;n%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Finished formatting the device.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|writenolabel
)paren
(brace
r_if
c_cond
(paren
id|verbosity
OG
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Retrieving disk geometry... &quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ioctl
c_func
(paren
id|fd
comma
id|HDIO_GETGEO
comma
op_amp
id|new_geometry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: the ioctl call to get geometry &quot;
"&bslash;"
l_string|&quot;returned with the following error &quot;
"&bslash;"
l_string|&quot;message:&bslash;n%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|reread
suffix:semicolon
)brace
id|rc
op_assign
id|ioctl
c_func
(paren
id|fd
comma
id|BLKGETSIZE
comma
op_amp
id|new_blksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: the ioctl call to get blocksize &quot;
"&bslash;"
l_string|&quot;returned with the following error &quot;
"&bslash;"
l_string|&quot;message:&bslash;n%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|reread
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbosity
OG
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|label_position
op_assign
id|new_geometry.start
op_star
id|new_blksize
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
OG
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Writing label... &quot;
)paren
suffix:semicolon
id|convert_label
c_func
(paren
id|label
)paren
suffix:semicolon
id|rc
op_assign
id|lseek
c_func
(paren
id|fd
comma
id|label_position
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|label_position
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: lseek on the device to %i &quot;
"&bslash;"
l_string|&quot;failed with the following error &quot;
"&bslash;"
l_string|&quot;message:&bslash;n%s&bslash;n&quot;
comma
id|prog_name
comma
id|label_position
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|reread
suffix:semicolon
)brace
id|rc
op_assign
id|write
c_func
(paren
id|fd
comma
id|label
comma
id|LABEL_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|LABEL_LENGTH
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: writing the label only wrote %d &quot;
"&bslash;"
l_string|&quot;bytes.&bslash;n&quot;
comma
id|prog_name
comma
id|rc
)paren
suffix:semicolon
r_goto
id|reread
suffix:semicolon
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
OG
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|reread
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Rereading the partition table... &quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ioctl
c_func
(paren
id|fd
comma
id|BLKRRPART
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: error during rereading the partition &quot;
"&bslash;"
l_string|&quot;table: %s.&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rc
op_assign
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: error during close: &quot;
"&bslash;"
l_string|&quot;%s; continuing.&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|verbosity
suffix:semicolon
r_int
id|testmode
suffix:semicolon
r_int
id|withoutprompt
suffix:semicolon
r_int
id|writenolabel
comma
id|labelspec
suffix:semicolon
r_char
op_star
id|dev_name
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_char
op_star
id|dev_filename
comma
op_star
id|devno_param_str
comma
op_star
id|range_param_str
suffix:semicolon
r_char
op_star
id|start_param_str
comma
op_star
id|end_param_str
comma
op_star
id|blksize_param_str
suffix:semicolon
r_char
id|label
(braket
id|LABEL_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
id|format_data_t
id|format_params
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|oc
suffix:semicolon
r_char
op_star
id|endptr
suffix:semicolon
r_char
id|c1
comma
id|c2
comma
id|cbuffer
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* should be able to contain -end plus 1 char */
r_int
id|i
comma
id|i1
comma
id|i2
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
r_int
id|start_specified
comma
id|end_specified
comma
id|blksize_specified
suffix:semicolon
r_int
id|devfile_specified
comma
id|devno_specified
comma
id|range_specified
suffix:semicolon
multiline_comment|/******************* initialization ********************/
id|prog_name
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|endptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set default values */
id|format_params.start_unit
op_assign
id|DASD_FORMAT_DEFAULT_START_UNIT
suffix:semicolon
id|format_params.stop_unit
op_assign
id|DASD_FORMAT_DEFAULT_STOP_UNIT
suffix:semicolon
id|format_params.blksize
op_assign
id|DASD_FORMAT_DEFAULT_BLOCKSIZE
suffix:semicolon
id|format_params.intensity
op_assign
id|DASD_FORMAT_DEFAULT_INTENSITY
suffix:semicolon
id|testmode
op_assign
l_int|0
suffix:semicolon
id|verbosity
op_assign
l_int|0
suffix:semicolon
id|withoutprompt
op_assign
l_int|0
suffix:semicolon
id|writenolabel
op_assign
l_int|0
suffix:semicolon
id|labelspec
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LABEL_LENGTH
suffix:semicolon
id|i
op_increment
)paren
id|label
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|label
(braket
id|LABEL_LENGTH
)braket
op_assign
l_int|0
suffix:semicolon
id|start_specified
op_assign
id|end_specified
op_assign
id|blksize_specified
op_assign
l_int|0
suffix:semicolon
id|devfile_specified
op_assign
id|devno_specified
op_assign
id|range_specified
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*************** parse parameters **********************/
multiline_comment|/* avoid error message generated by getopt */
id|opterr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef RANGE_FORMATTING
r_while
c_loop
(paren
(paren
id|oc
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;r:s:e:b:n:l:f:hLty?vV&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
macro_line|#endif /* RANGE_FORMATTING */
r_while
c_loop
(paren
(paren
id|oc
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;b:n:l:f:hLty?vV&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_switch
c_cond
(paren
id|oc
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
id|withoutprompt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|testmode
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;v&squot;
suffix:colon
id|verbosity
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
multiline_comment|/* fall-through */
r_case
l_char|&squot;:&squot;
suffix:colon
id|exit_usage
c_func
(paren
id|EXIT_MISUSE
)paren
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|exit_usage
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s version 0.99&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|strncpy
c_func
(paren
id|label
comma
id|optarg
comma
id|LABEL_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|optarg
)paren
OL
id|LABEL_LENGTH
)paren
id|label
(braket
id|strlen
c_func
(paren
id|optarg
)paren
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|labelspec
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|writenolabel
op_increment
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef RANGE_FORMATTING
r_case
l_char|&squot;s&squot;
suffix:colon
id|start_param_str
op_assign
id|optarg
suffix:semicolon
id|start_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|end_param_str
op_assign
id|optarg
suffix:semicolon
id|end_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|range_param_str
op_assign
id|optarg
suffix:semicolon
id|range_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* RANGE_FORMATTING */
r_case
l_char|&squot;b&squot;
suffix:colon
id|blksize_param_str
op_assign
id|optarg
suffix:semicolon
id|blksize_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|devno_param_str
op_assign
id|optarg
suffix:semicolon
id|devno_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|dev_filename
op_assign
id|optarg
suffix:semicolon
id|devfile_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/******************** checking of parameters **************/
multiline_comment|/* convert range into -s and -e */
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|range_specified
comma
l_string|&quot;formatting range&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|range_specified
)paren
(brace
id|start_specified
op_increment
suffix:semicolon
id|end_specified
op_increment
suffix:semicolon
multiline_comment|/* scan for 1 or 2 integers, separated by a dash */
id|rc
op_assign
id|sscanf
c_func
(paren
id|range_param_str
comma
l_string|&quot;%d%c%d%c&quot;
comma
op_amp
id|i1
comma
op_amp
id|c1
comma
op_amp
id|i2
comma
op_amp
id|c2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|3
)paren
op_logical_and
(paren
id|c1
op_eq
l_char|&squot;-&squot;
)paren
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
id|format_params.stop_unit
op_assign
id|i2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* scan for integer and -END */
id|rc
op_assign
id|sscanf
c_func
(paren
id|range_param_str
comma
l_string|&quot;%d%s&quot;
comma
op_amp
id|i1
comma
id|cbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|2
)paren
op_logical_and
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|cbuffer
comma
l_string|&quot;-END&quot;
)paren
)paren
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
id|format_params.stop_unit
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: specified range &quot;
"&bslash;"
l_string|&quot;is in invalid format&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|devfile_specified
)paren
op_logical_and
(paren
op_logical_neg
id|devno_specified
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: device to format &quot;
"&bslash;"
l_string|&quot;not specified&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devfile_specified
op_plus
id|devno_specified
)paren
OG
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: device to format &quot;
"&bslash;"
l_string|&quot;can only be specified once&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|start_specified
)paren
op_logical_and
(paren
op_logical_neg
id|end_specified
)paren
op_logical_and
(paren
op_logical_neg
id|range_specified
)paren
op_logical_and
(paren
op_logical_neg
id|blksize_specified
)paren
)paren
(brace
id|format_params
op_assign
id|ask_user_for_data
c_func
(paren
id|format_params
)paren
suffix:semicolon
)brace
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|start_specified
comma
l_string|&quot;start track&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|end_specified
comma
l_string|&quot;end track&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|blksize_specified
comma
l_string|&quot;blocksize&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|labelspec
comma
l_string|&quot;label&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|writenolabel
comma
l_string|&quot;omit-label-writing flag&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devno_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|devno
comma
id|devno_param_str
comma
l_int|16
comma
l_string|&quot;device number&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_specified
op_logical_and
op_logical_neg
id|range_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.start_unit
comma
id|start_param_str
comma
l_int|10
comma
l_string|&quot;start track&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end_specified
op_logical_and
op_logical_neg
id|range_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.stop_unit
comma
id|end_param_str
comma
l_int|10
comma
l_string|&quot;end track&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blksize_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.blksize
comma
id|blksize_param_str
comma
l_int|10
comma
l_string|&quot;blocksize&quot;
)paren
suffix:semicolon
multiline_comment|/***********get dev_name *********************/
id|dev_name
op_assign
(paren
id|devno_specified
)paren
ques
c_cond
id|get_devname_from_devno
c_func
(paren
id|devno
comma
id|verbosity
)paren
suffix:colon
id|dev_filename
suffix:semicolon
multiline_comment|/*** range checking *********/
id|str
op_assign
id|check_param
c_func
(paren
id|CHECK_ALL
comma
id|format_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
op_ne
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|prog_name
comma
id|str
)paren
suffix:semicolon
multiline_comment|/******* issue the real command and reread part table *******/
id|do_format_dasd
c_func
(paren
id|dev_name
comma
id|format_params
comma
id|testmode
comma
id|verbosity
comma
id|writenolabel
comma
id|labelspec
comma
id|label
comma
id|withoutprompt
comma
id|devno
)paren
suffix:semicolon
multiline_comment|/*************** cleanup ********************************/
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|dev_name
comma
id|TEMPFILENAME
comma
id|TEMPFILENAMECHARS
)paren
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|unlink
c_func
(paren
id|dev_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
)paren
op_logical_and
(paren
id|verbosity
op_ge
l_int|1
)paren
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: temporary device node %s could not be &quot;
"&bslash;"
l_string|&quot;removed: %s&bslash;n&quot;
comma
id|prog_name
comma
id|dev_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|devno_specified
)paren
(brace
multiline_comment|/* so we have allocated space for the filename */
id|free
c_func
(paren
id|dev_name
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
