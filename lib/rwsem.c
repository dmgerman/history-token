multiline_comment|/* rwsem.c: R/W semaphores: contention handling functions&n; *&n; * Written by David Howells (dhowells@redhat.com).&n; * Derived from arch/i386/kernel/semaphore.c&n; */
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n; * wait for the read lock to be granted&n; * - need to repeal the increment made inline by the caller&n; * - need to throw a write-lock style spanner into the works (sub 0x00010000 from count)&n; */
DECL|function|rwsem_down_read_failed
r_struct
id|rw_semaphore
op_star
id|rwsem_down_read_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering rwsem_down_read_failed(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
multiline_comment|/* this waitqueue context flag will be cleared when we are granted the lock */
id|__set_bit
c_func
(paren
id|RWSEM_WAITING_FOR_READ
comma
op_amp
id|wait.flags
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* FIFO */
multiline_comment|/* note that we&squot;re now waiting on the lock, but no longer actively read-locking */
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
id|RWSEM_WAITING_BIAS
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;X(%08lx)&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* if there are no longer active locks, wake the front queued process(es) up&n;&t; * - it might even be this process, since the waker takes a more active part&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
id|rwsem_wake
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|RWSEM_WAITING_FOR_READ
comma
op_amp
id|wait.flags
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving rwsem_down_read_failed(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * wait for the write lock to be granted&n; */
DECL|function|rwsem_down_write_failed
r_struct
id|rw_semaphore
op_star
id|rwsem_down_write_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering rwsem_down_write_failed(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
multiline_comment|/* this waitqueue context flag will be cleared when we are granted the lock */
id|__set_bit
c_func
(paren
id|RWSEM_WAITING_FOR_WRITE
comma
op_amp
id|wait.flags
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* FIFO */
multiline_comment|/* note that we&squot;re waiting on the lock, but no longer actively locking */
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] updated(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* if there are no longer active locks, wake the front queued process(es) up&n;&t; * - it might even be this process, since the waker takes a more active part&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
id|rwsem_wake
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|RWSEM_WAITING_FOR_WRITE
comma
op_amp
id|wait.flags
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving rwsem_down_write_failed(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * handle the lock being released whilst there are processes blocked on it that can now run&n; * - if we come here, then:&n; *   - the &squot;active part&squot; of the count (&amp;0x0000ffff) reached zero (but may no longer be zero)&n; *   - the &squot;waiting part&squot; of the count (&amp;0xffff0000) is negative (and will still be so)&n; */
DECL|function|rwsem_wake
r_struct
id|rw_semaphore
op_star
id|rwsem_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_int
id|woken
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Entering rwsem_wake(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
id|try_again
suffix:colon
multiline_comment|/* try to grab an &squot;activity&squot; marker&n;&t; * - need to make sure two copies of rwsem_wake() don&squot;t do this for two separate processes&n;&t; *   simultaneously&n;&t; * - be horribly naughty, and only deal with the LSW of the atomic counter&n;&t; */
r_if
c_cond
(paren
id|rwsem_cmpxchgw
c_func
(paren
id|sem
comma
l_int|0
comma
id|RWSEM_ACTIVE_BIAS
)paren
op_ne
l_int|0
)paren
(brace
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] rwsem_wake: abort wakeup due to renewed activity&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* try to grant a single write lock if there&squot;s a writer at the front of the queue&n;&t; * - note we leave the &squot;active part&squot; of the count incremented by 1 and the waiting part&n;&t; *   incremented by 0x00010000&n;&t; */
r_if
c_cond
(paren
id|wake_up_ctx
c_func
(paren
op_amp
id|sem-&gt;wait
comma
l_int|1
comma
op_minus
id|RWSEM_WAITING_FOR_WRITE
)paren
op_eq
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* grant an infinite number of read locks to the readers at the front of the queue&n;&t; * - note we increment the &squot;active part&squot; of the count by the number of readers just woken,&n;&t; *   less one for the activity decrement we&squot;ve already done&n;&t; */
id|woken
op_assign
id|wake_up_ctx
c_func
(paren
op_amp
id|sem-&gt;wait
comma
l_int|65535
comma
op_minus
id|RWSEM_WAITING_FOR_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|woken
op_le
l_int|0
)paren
r_goto
id|counter_correction
suffix:semicolon
id|woken
op_mul_assign
id|RWSEM_ACTIVE_BIAS
op_minus
id|RWSEM_WAITING_BIAS
suffix:semicolon
id|woken
op_sub_assign
id|RWSEM_ACTIVE_BIAS
suffix:semicolon
id|rwsem_atomic_update
c_func
(paren
id|woken
comma
id|sem
)paren
suffix:semicolon
id|out
suffix:colon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] Leaving rwsem_wake(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|sem-&gt;count
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
multiline_comment|/* come here if we need to correct the counter for odd SMP-isms */
id|counter_correction
suffix:colon
id|count
op_assign
id|rwsem_atomic_update
c_func
(paren
op_minus
id|RWSEM_ACTIVE_BIAS
comma
id|sem
)paren
suffix:semicolon
id|rwsemdebug
c_func
(paren
l_string|&quot;[%d] corrected(%08lx)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
id|RWSEM_ACTIVE_MASK
)paren
)paren
r_goto
id|try_again
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|rwsem_down_read_failed
id|EXPORT_SYMBOL
c_func
(paren
id|rwsem_down_read_failed
)paren
suffix:semicolon
DECL|variable|rwsem_down_write_failed
id|EXPORT_SYMBOL
c_func
(paren
id|rwsem_down_write_failed
)paren
suffix:semicolon
DECL|variable|rwsem_wake
id|EXPORT_SYMBOL
c_func
(paren
id|rwsem_wake
)paren
suffix:semicolon
eof
