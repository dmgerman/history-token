multiline_comment|/*&n; * A fast, small, non-recursive O(nlog n) sort for the Linux kernel&n; *&n; * Jan 23 2005  Matt Mackall &lt;mpm@selenic.com&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|function|u32_swap
r_void
id|u32_swap
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|b
comma
r_int
id|size
)paren
(brace
id|u32
id|t
op_assign
op_star
(paren
id|u32
op_star
)paren
id|a
suffix:semicolon
op_star
(paren
id|u32
op_star
)paren
id|a
op_assign
op_star
(paren
id|u32
op_star
)paren
id|b
suffix:semicolon
op_star
(paren
id|u32
op_star
)paren
id|b
op_assign
id|t
suffix:semicolon
)brace
DECL|function|generic_swap
r_void
id|generic_swap
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|b
comma
r_int
id|size
)paren
(brace
r_char
id|t
suffix:semicolon
r_do
(brace
id|t
op_assign
op_star
(paren
r_char
op_star
)paren
id|a
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|a
op_increment
op_assign
op_star
(paren
r_char
op_star
)paren
id|b
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|b
op_increment
op_assign
id|t
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|size
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sort - sort an array of elements&n; * @base: pointer to data to sort&n; * @num: number of elements&n; * @size: size of each element&n; * @cmp: pointer to comparison function&n; * @swap: pointer to swap function or NULL&n; *&n; * This function does a heapsort on the given array. You may provide a&n; * swap function optimized to your element type.&n; *&n; * Sorting time is O(n log n) both on average and worst-case. While&n; * qsort is about 20% faster on average, it suffers from exploitable&n; * O(n*n) worst-case behavior and extra memory requirements that make&n; * it less suitable for kernel use.&n; */
DECL|function|sort
r_void
id|sort
c_func
(paren
r_void
op_star
id|base
comma
r_int
id|num
comma
r_int
id|size
comma
r_int
(paren
op_star
id|cmp
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|swap
)paren
(paren
r_void
op_star
comma
r_void
op_star
comma
r_int
id|size
)paren
)paren
(brace
multiline_comment|/* pre-scale counters for performance */
r_int
id|i
op_assign
(paren
id|num
op_div
l_int|2
)paren
op_star
id|size
comma
id|n
op_assign
id|num
op_star
id|size
comma
id|c
comma
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap
)paren
id|swap
op_assign
(paren
id|size
op_eq
l_int|4
ques
c_cond
id|u32_swap
suffix:colon
id|generic_swap
)paren
suffix:semicolon
multiline_comment|/* heapify */
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_sub_assign
id|size
)paren
(brace
r_for
c_loop
(paren
id|r
op_assign
id|i
suffix:semicolon
id|r
op_star
l_int|2
OL
id|n
suffix:semicolon
id|r
op_assign
id|c
)paren
(brace
id|c
op_assign
id|r
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
id|n
op_minus
id|size
op_logical_and
id|cmp
c_func
(paren
id|base
op_plus
id|c
comma
id|base
op_plus
id|c
op_plus
id|size
)paren
OL
l_int|0
)paren
id|c
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|cmp
c_func
(paren
id|base
op_plus
id|r
comma
id|base
op_plus
id|c
)paren
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|swap
c_func
(paren
id|base
op_plus
id|r
comma
id|base
op_plus
id|c
comma
id|size
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sort */
r_for
c_loop
(paren
id|i
op_assign
id|n
op_minus
id|size
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_sub_assign
id|size
)paren
(brace
id|swap
c_func
(paren
id|base
comma
id|base
op_plus
id|i
comma
id|size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
l_int|0
suffix:semicolon
id|r
op_star
l_int|2
OL
id|i
suffix:semicolon
id|r
op_assign
id|c
)paren
(brace
id|c
op_assign
id|r
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
id|i
op_minus
id|size
op_logical_and
id|cmp
c_func
(paren
id|base
op_plus
id|c
comma
id|base
op_plus
id|c
op_plus
id|size
)paren
OL
l_int|0
)paren
id|c
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|cmp
c_func
(paren
id|base
op_plus
id|r
comma
id|base
op_plus
id|c
)paren
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|swap
c_func
(paren
id|base
op_plus
id|r
comma
id|base
op_plus
id|c
comma
id|size
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|sort
id|EXPORT_SYMBOL
c_func
(paren
id|sort
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* a simple boot-time regression test */
r_int
id|cmpint
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_return
op_star
(paren
r_int
op_star
)paren
id|a
op_minus
op_star
(paren
r_int
op_star
)paren
id|b
suffix:semicolon
)brace
r_static
r_int
id|sort_test
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|a
comma
id|i
comma
id|r
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
id|kmalloc
c_func
(paren
l_int|1000
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|a
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;testing sort()&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_assign
(paren
id|r
op_star
l_int|725861
)paren
op_mod
l_int|6599
suffix:semicolon
id|a
(braket
id|i
)braket
op_assign
id|r
suffix:semicolon
)brace
id|sort
c_func
(paren
id|a
comma
l_int|1000
comma
r_sizeof
(paren
r_int
)paren
comma
id|cmpint
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|999
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|a
(braket
id|i
)braket
OG
id|a
(braket
id|i
op_plus
l_int|1
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sort() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|sort_test
)paren
suffix:semicolon
macro_line|#endif
eof
