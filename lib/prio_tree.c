multiline_comment|/*&n; * lib/prio_tree.c - priority search tree&n; *&n; * Copyright (C) 2004, Rajesh Venkatasubramanian &lt;vrajesh@umich.edu&gt;&n; *&n; * This file is released under the GPL v2.&n; *&n; * Based on the radix priority search tree proposed by Edward M. McCreight&n; * SIAM Journal of Computing, vol. 14, no.2, pages 257-276, May 1985&n; *&n; * 02Feb2004&t;Initial version&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/prio_tree.h&gt;
multiline_comment|/*&n; * A clever mix of heap and radix trees forms a radix priority search tree (PST)&n; * which is useful for storing intervals, e.g, we can consider a vma as a closed&n; * interval of file pages [offset_begin, offset_end], and store all vmas that&n; * map a file in a PST. Then, using the PST, we can answer a stabbing query,&n; * i.e., selecting a set of stored intervals (vmas) that overlap with (map) a&n; * given input interval X (a set of consecutive file pages), in &quot;O(log n + m)&quot;&n; * time where &squot;log n&squot; is the height of the PST, and &squot;m&squot; is the number of stored&n; * intervals (vmas) that overlap (map) with the input interval X (the set of&n; * consecutive file pages).&n; *&n; * In our implementation, we store closed intervals of the form [radix_index,&n; * heap_index]. We assume that always radix_index &lt;= heap_index. McCreight&squot;s PST&n; * is designed for storing intervals with unique radix indices, i.e., each&n; * interval have different radix_index. However, this limitation can be easily&n; * overcome by using the size, i.e., heap_index - radix_index, as part of the&n; * index, so we index the tree using [(radix_index,size), heap_index].&n; *&n; * When the above-mentioned indexing scheme is used, theoretically, in a 32 bit&n; * machine, the maximum height of a PST can be 64. We can use a balanced version&n; * of the priority search tree to optimize the tree height, but the balanced&n; * tree proposed by McCreight is too complex and memory-hungry for our purpose.&n; */
multiline_comment|/*&n; * The following macros are used for implementing prio_tree for i_mmap&n; */
DECL|macro|RADIX_INDEX
mdefine_line|#define RADIX_INDEX(vma)  ((vma)-&gt;vm_pgoff)
DECL|macro|VMA_SIZE
mdefine_line|#define VMA_SIZE(vma)&t;  (((vma)-&gt;vm_end - (vma)-&gt;vm_start) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* avoid overflow */
DECL|macro|HEAP_INDEX
mdefine_line|#define HEAP_INDEX(vma)&t;  ((vma)-&gt;vm_pgoff + (VMA_SIZE(vma) - 1))
DECL|function|get_index
r_static
r_void
id|get_index
c_func
(paren
r_const
r_struct
id|prio_tree_root
op_star
id|root
comma
r_const
r_struct
id|prio_tree_node
op_star
id|node
comma
r_int
r_int
op_star
id|radix
comma
r_int
r_int
op_star
id|heap
)paren
(brace
r_if
c_cond
(paren
id|root-&gt;raw
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|prio_tree_entry
c_func
(paren
id|node
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
op_star
id|radix
op_assign
id|RADIX_INDEX
c_func
(paren
id|vma
)paren
suffix:semicolon
op_star
id|heap
op_assign
id|HEAP_INDEX
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|radix
op_assign
id|node-&gt;start
suffix:semicolon
op_star
id|heap
op_assign
id|node-&gt;last
suffix:semicolon
)brace
)brace
DECL|variable|index_bits_to_maxindex
r_static
r_int
r_int
id|index_bits_to_maxindex
(braket
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|function|prio_tree_init
r_void
id|__init
id|prio_tree_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|index_bits_to_maxindex
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|index_bits_to_maxindex
(braket
id|i
)braket
op_assign
(paren
l_int|1UL
op_lshift
(paren
id|i
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|index_bits_to_maxindex
(braket
id|ARRAY_SIZE
c_func
(paren
id|index_bits_to_maxindex
)paren
op_minus
l_int|1
)braket
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/*&n; * Maximum heap_index that can be stored in a PST with index_bits bits&n; */
DECL|function|prio_tree_maxindex
r_static
r_inline
r_int
r_int
id|prio_tree_maxindex
c_func
(paren
r_int
r_int
id|bits
)paren
(brace
r_return
id|index_bits_to_maxindex
(braket
id|bits
op_minus
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Extend a priority search tree so that it can store a node with heap_index&n; * max_heap_index. In the worst case, this algorithm takes O((log n)^2).&n; * However, this function is used rarely and the common case performance is&n; * not bad.&n; */
DECL|function|prio_tree_expand
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_expand
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
comma
r_int
r_int
id|max_heap_index
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|first
op_assign
l_int|NULL
comma
op_star
id|prev
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|max_heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
id|root-&gt;index_bits
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|max_heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
(brace
id|root-&gt;index_bits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_int|NULL
)paren
(brace
id|first
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|prio_tree_remove
c_func
(paren
id|root
comma
id|root-&gt;prio_tree_node
)paren
suffix:semicolon
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|first
)paren
suffix:semicolon
id|last
op_assign
id|first
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|last
suffix:semicolon
id|last
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|prio_tree_remove
c_func
(paren
id|root
comma
id|root-&gt;prio_tree_node
)paren
suffix:semicolon
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|last
)paren
suffix:semicolon
id|prev-&gt;left
op_assign
id|last
suffix:semicolon
id|last-&gt;parent
op_assign
id|prev
suffix:semicolon
)brace
)brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|node-&gt;left
op_assign
id|first
suffix:semicolon
id|first-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_else
id|last
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
(brace
id|last-&gt;left
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|last-&gt;left-&gt;parent
op_assign
id|last
suffix:semicolon
)brace
id|root-&gt;prio_tree_node
op_assign
id|node
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace a prio_tree_node with a new node and return the old node&n; */
DECL|function|prio_tree_replace
r_struct
id|prio_tree_node
op_star
id|prio_tree_replace
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|old
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|old
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|root-&gt;prio_tree_node
op_ne
id|old
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can reduce root-&gt;index_bits here. However, it is complex&n;&t;&t; * and does not help much to improve performance (IMO).&n;&t;&t; */
id|node-&gt;parent
op_assign
id|node
suffix:semicolon
id|root-&gt;prio_tree_node
op_assign
id|node
suffix:semicolon
)brace
r_else
(brace
id|node-&gt;parent
op_assign
id|old-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|old-&gt;parent-&gt;left
op_eq
id|old
)paren
id|old-&gt;parent-&gt;left
op_assign
id|node
suffix:semicolon
r_else
id|old-&gt;parent-&gt;right
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|old
)paren
)paren
(brace
id|node-&gt;left
op_assign
id|old-&gt;left
suffix:semicolon
id|old-&gt;left-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|old
)paren
)paren
(brace
id|node-&gt;right
op_assign
id|old-&gt;right
suffix:semicolon
id|old-&gt;right-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_return
id|old
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a prio_tree_node @node into a radix priority search tree @root. The&n; * algorithm typically takes O(log n) time where &squot;log n&squot; is the number of bits&n; * required to represent the maximum heap_index. In the worst case, the algo&n; * can take O((log n)^2) - check prio_tree_expand.&n; *&n; * If a prior node with same radix_index and heap_index is already found in&n; * the tree, then returns the address of the prior node. Otherwise, inserts&n; * @node into the tree and returns @node.&n; */
DECL|function|prio_tree_insert
r_struct
id|prio_tree_node
op_star
id|prio_tree_insert
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|cur
comma
op_star
id|res
op_assign
id|node
suffix:semicolon
r_int
r_int
id|radix_index
comma
id|heap_index
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index
comma
id|index
comma
id|mask
suffix:semicolon
r_int
id|size_flag
op_assign
l_int|0
suffix:semicolon
id|get_index
c_func
(paren
id|root
comma
id|node
comma
op_amp
id|radix_index
comma
op_amp
id|heap_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
op_logical_or
id|heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
r_return
id|prio_tree_expand
c_func
(paren
id|root
comma
id|node
comma
id|heap_index
)paren
suffix:semicolon
id|cur
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|root-&gt;index_bits
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
id|get_index
c_func
(paren
id|root
comma
id|cur
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_index
op_eq
id|radix_index
op_logical_and
id|h_index
op_eq
id|heap_index
)paren
r_return
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|h_index
OL
id|heap_index
op_logical_or
(paren
id|h_index
op_eq
id|heap_index
op_logical_and
id|r_index
OG
id|radix_index
)paren
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|tmp
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|prio_tree_replace
c_func
(paren
id|root
comma
id|cur
comma
id|node
)paren
suffix:semicolon
id|cur
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* swap indices */
id|index
op_assign
id|r_index
suffix:semicolon
id|r_index
op_assign
id|radix_index
suffix:semicolon
id|radix_index
op_assign
id|index
suffix:semicolon
id|index
op_assign
id|h_index
suffix:semicolon
id|h_index
op_assign
id|heap_index
suffix:semicolon
id|heap_index
op_assign
id|index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size_flag
)paren
id|index
op_assign
id|heap_index
op_minus
id|radix_index
suffix:semicolon
r_else
id|index
op_assign
id|radix_index
suffix:semicolon
r_if
c_cond
(paren
id|index
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
id|cur-&gt;right
op_assign
id|node
suffix:semicolon
id|node-&gt;parent
op_assign
id|cur
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_else
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
id|cur-&gt;left
op_assign
id|node
suffix:semicolon
id|node-&gt;parent
op_assign
id|cur
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_else
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
id|size_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Should not reach here */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a prio_tree_node @node from a radix priority search tree @root. The&n; * algorithm takes O(log n) time where &squot;log n&squot; is the number of bits required&n; * to represent the maximum heap_index.&n; */
DECL|function|prio_tree_remove
r_void
id|prio_tree_remove
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|cur
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index_right
comma
id|h_index_left
suffix:semicolon
id|cur
op_assign
id|node
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
op_logical_or
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
)paren
id|get_index
c_func
(paren
id|root
comma
id|cur-&gt;left
comma
op_amp
id|r_index
comma
op_amp
id|h_index_left
)paren
suffix:semicolon
r_else
(brace
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
id|get_index
c_func
(paren
id|root
comma
id|cur-&gt;right
comma
op_amp
id|r_index
comma
op_amp
id|h_index_right
)paren
suffix:semicolon
r_else
(brace
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* both h_index_left and h_index_right cannot be 0 */
r_if
c_cond
(paren
id|h_index_left
op_ge
id|h_index_right
)paren
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
r_else
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|cur
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|root-&gt;prio_tree_node
op_ne
id|cur
)paren
suffix:semicolon
id|__INIT_PRIO_TREE_ROOT
c_func
(paren
id|root
comma
id|root-&gt;raw
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur-&gt;parent-&gt;right
op_eq
id|cur
)paren
id|cur-&gt;parent-&gt;right
op_assign
id|cur-&gt;parent
suffix:semicolon
r_else
id|cur-&gt;parent-&gt;left
op_assign
id|cur-&gt;parent
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
id|node
)paren
id|cur
op_assign
id|prio_tree_replace
c_func
(paren
id|root
comma
id|cur-&gt;parent
comma
id|cur
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Following functions help to enumerate all prio_tree_nodes in the tree that&n; * overlap with the input interval X [radix_index, heap_index]. The enumeration&n; * takes O(log n + m) time where &squot;log n&squot; is the height of the tree (which is&n; * proportional to # of bits required to represent the maximum heap_index) and&n; * &squot;m&squot; is the number of prio_tree_nodes that overlap the interval X.&n; */
DECL|function|prio_tree_left
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_left
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
op_star
id|r_index
comma
r_int
r_int
op_star
id|h_index
)paren
(brace
r_if
c_cond
(paren
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|get_index
c_func
(paren
id|iter-&gt;root
comma
id|iter-&gt;cur-&gt;left
comma
id|r_index
comma
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
op_le
op_star
id|h_index
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;left
suffix:semicolon
id|iter-&gt;mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
)paren
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|iter-&gt;size_level
op_increment
suffix:semicolon
id|iter-&gt;mask
op_assign
id|ULONG_MAX
suffix:semicolon
)brace
r_else
(brace
id|iter-&gt;size_level
op_assign
l_int|1
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|prio_tree_right
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_right
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
op_star
id|r_index
comma
r_int
r_int
op_star
id|h_index
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|value
op_assign
id|iter-&gt;value
suffix:semicolon
r_else
id|value
op_assign
id|iter-&gt;value
op_or
id|iter-&gt;mask
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;h_index
OL
id|value
)paren
r_return
l_int|NULL
suffix:semicolon
id|get_index
c_func
(paren
id|iter-&gt;root
comma
id|iter-&gt;cur-&gt;right
comma
id|r_index
comma
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
op_le
op_star
id|h_index
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;right
suffix:semicolon
id|iter-&gt;mask
op_rshift_assign
l_int|1
suffix:semicolon
id|iter-&gt;value
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
)paren
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|iter-&gt;size_level
op_increment
suffix:semicolon
id|iter-&gt;mask
op_assign
id|ULONG_MAX
suffix:semicolon
)brace
r_else
(brace
id|iter-&gt;size_level
op_assign
l_int|1
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|prio_tree_parent
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_parent
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
op_eq
id|ULONG_MAX
)paren
id|iter-&gt;mask
op_assign
l_int|1UL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iter-&gt;size_level
op_eq
l_int|1
)paren
id|iter-&gt;mask
op_assign
l_int|1UL
suffix:semicolon
r_else
id|iter-&gt;mask
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iter-&gt;size_level
op_logical_and
(paren
id|iter-&gt;value
op_amp
id|iter-&gt;mask
)paren
)paren
id|iter-&gt;value
op_xor_assign
id|iter-&gt;mask
suffix:semicolon
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
DECL|function|overlap
r_static
r_inline
r_int
id|overlap
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
id|r_index
comma
r_int
r_int
id|h_index
)paren
(brace
r_return
id|iter-&gt;h_index
op_ge
id|r_index
op_logical_and
id|iter-&gt;r_index
op_le
id|h_index
suffix:semicolon
)brace
multiline_comment|/*&n; * prio_tree_first:&n; *&n; * Get the first prio_tree_node that overlaps with the interval [radix_index,&n; * heap_index]. Note that always radix_index &lt;= heap_index. We do a pre-order&n; * traversal of the tree.&n; */
DECL|function|prio_tree_first
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_first
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_struct
id|prio_tree_root
op_star
id|root
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index
suffix:semicolon
id|INIT_PRIO_TREE_ITER
c_func
(paren
id|iter
)paren
suffix:semicolon
id|root
op_assign
id|iter-&gt;root
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|get_index
c_func
(paren
id|root
comma
id|root-&gt;prio_tree_node
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
OG
id|h_index
)paren
r_return
l_int|NULL
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|root-&gt;index_bits
op_minus
l_int|1
)paren
suffix:semicolon
id|iter-&gt;cur
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_left
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_right
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * prio_tree_next:&n; *&n; * Get the next prio_tree_node that overlaps with the input interval in iter&n; */
DECL|function|prio_tree_next
r_struct
id|prio_tree_node
op_star
id|prio_tree_next
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_int
r_int
id|r_index
comma
id|h_index
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;cur
op_eq
l_int|NULL
)paren
r_return
id|prio_tree_first
c_func
(paren
id|iter
)paren
suffix:semicolon
id|repeat
suffix:colon
r_while
c_loop
(paren
id|prio_tree_left
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_right
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_root
c_func
(paren
id|iter-&gt;cur
)paren
op_logical_and
id|iter-&gt;cur-&gt;parent-&gt;right
op_eq
id|iter-&gt;cur
)paren
id|prio_tree_parent
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|prio_tree_parent
c_func
(paren
id|iter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
eof
