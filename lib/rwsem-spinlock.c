multiline_comment|/* rwsem-spinlock.c: R/W semaphores: contention handling functions for generic spinlock&n; *                                   implementation&n; *&n; * Copyright (c) 2001   David Howells (dhowells@redhat.com).&n; * - Derived partially from idea by Andrea Arcangeli &lt;andrea@suse.de&gt;&n; * - Derived also from comments by Linus&n; */
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|struct|rwsem_waiter
r_struct
id|rwsem_waiter
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|macro|RWSEM_WAITING_FOR_READ
mdefine_line|#define RWSEM_WAITING_FOR_READ&t;0x00000001
DECL|macro|RWSEM_WAITING_FOR_WRITE
mdefine_line|#define RWSEM_WAITING_FOR_WRITE&t;0x00000002
)brace
suffix:semicolon
macro_line|#if RWSEM_DEBUG
DECL|function|rwsemtrace
r_void
id|rwsemtrace
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;[%d] %s({%d,%d})&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|str
comma
id|sem-&gt;activity
comma
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * initialise the semaphore&n; */
DECL|function|init_rwsem
r_void
id|fastcall
id|init_rwsem
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|sem-&gt;activity
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
suffix:semicolon
macro_line|#if RWSEM_DEBUG
id|sem-&gt;debug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * handle the lock being released whilst there are processes blocked on it that can now run&n; * - if we come here, then:&n; *   - the &squot;active count&squot; _reached_ zero&n; *   - the &squot;waiting count&squot; is non-zero&n; * - the spinlock must be held by the caller&n; * - woken process blocks are discarded from the list after having flags zeroised&n; * - writers are only woken if wakewrite is non-zero&n; */
DECL|function|__rwsem_do_wake
r_static
r_inline
r_struct
id|rw_semaphore
op_star
id|__rwsem_do_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|wakewrite
)paren
(brace
r_struct
id|rwsem_waiter
op_star
id|waiter
suffix:semicolon
r_int
id|woken
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __rwsem_do_wake&quot;
)paren
suffix:semicolon
id|waiter
op_assign
id|list_entry
c_func
(paren
id|sem-&gt;wait_list.next
comma
r_struct
id|rwsem_waiter
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wakewrite
)paren
(brace
r_if
c_cond
(paren
id|waiter-&gt;flags
op_amp
id|RWSEM_WAITING_FOR_WRITE
)paren
r_goto
id|out
suffix:semicolon
r_goto
id|dont_wake_writers
suffix:semicolon
)brace
multiline_comment|/* if we are allowed to wake writers try to grant a single write lock if there&squot;s a&n;&t; * writer at the front of the queue&n;&t; * - we leave the &squot;waiting count&squot; incremented to signify potential contention&n;&t; */
r_if
c_cond
(paren
id|waiter-&gt;flags
op_amp
id|RWSEM_WAITING_FOR_WRITE
)paren
(brace
id|sem-&gt;activity
op_assign
op_minus
l_int|1
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|waiter-&gt;list
)paren
suffix:semicolon
id|waiter-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|wake_up_process
c_func
(paren
id|waiter-&gt;task
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* grant an infinite number of read locks to the readers at the front of the queue */
id|dont_wake_writers
suffix:colon
id|woken
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|waiter-&gt;flags
op_amp
id|RWSEM_WAITING_FOR_READ
)paren
(brace
r_struct
id|list_head
op_star
id|next
op_assign
id|waiter-&gt;list.next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|waiter-&gt;list
)paren
suffix:semicolon
id|waiter-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|wake_up_process
c_func
(paren
id|waiter-&gt;task
)paren
suffix:semicolon
id|woken
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
r_break
suffix:semicolon
id|waiter
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|rwsem_waiter
comma
id|list
)paren
suffix:semicolon
)brace
id|sem-&gt;activity
op_add_assign
id|woken
suffix:semicolon
id|out
suffix:colon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __rwsem_do_wake&quot;
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * wake a single writer&n; */
DECL|function|__rwsem_wake_one_writer
r_static
r_inline
r_struct
id|rw_semaphore
op_star
id|__rwsem_wake_one_writer
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|rwsem_waiter
op_star
id|waiter
suffix:semicolon
id|sem-&gt;activity
op_assign
op_minus
l_int|1
suffix:semicolon
id|waiter
op_assign
id|list_entry
c_func
(paren
id|sem-&gt;wait_list.next
comma
r_struct
id|rwsem_waiter
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|waiter-&gt;list
)paren
suffix:semicolon
id|waiter-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|wake_up_process
c_func
(paren
id|waiter-&gt;task
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * get a read lock on the semaphore&n; */
DECL|function|__down_read
r_void
id|fastcall
id|__down_read
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|rwsem_waiter
id|waiter
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down_read&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;activity
op_ge
l_int|0
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
(brace
multiline_comment|/* granted */
id|sem-&gt;activity
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tsk
op_assign
id|current
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* set up my own style of waitqueue */
id|waiter.task
op_assign
id|tsk
suffix:semicolon
id|waiter.flags
op_assign
id|RWSEM_WAITING_FOR_READ
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|waiter.list
comma
op_amp
id|sem-&gt;wait_list
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t need to touch the semaphore struct anymore */
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|waiter.flags
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|out
suffix:colon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down_read&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * trylock for reading -- returns 1 if successful, 0 if contention&n; */
DECL|function|__down_read_trylock
r_int
id|fastcall
id|__down_read_trylock
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down_read_trylock&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;activity
op_ge
l_int|0
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
(brace
multiline_comment|/* granted */
id|sem-&gt;activity
op_increment
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down_read_trylock&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * get a write lock on the semaphore&n; * - note that we increment the waiting count anyway to indicate an exclusive lock&n; */
DECL|function|__down_write
r_void
id|fastcall
id|__down_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|rwsem_waiter
id|waiter
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down_write&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;activity
op_eq
l_int|0
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
(brace
multiline_comment|/* granted */
id|sem-&gt;activity
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tsk
op_assign
id|current
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* set up my own style of waitqueue */
id|waiter.task
op_assign
id|tsk
suffix:semicolon
id|waiter.flags
op_assign
id|RWSEM_WAITING_FOR_WRITE
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|waiter.list
comma
op_amp
id|sem-&gt;wait_list
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t need to touch the semaphore struct anymore */
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
multiline_comment|/* wait to be given the lock */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|waiter.flags
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|out
suffix:colon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down_write&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * trylock for writing -- returns 1 if successful, 0 if contention&n; */
DECL|function|__down_write_trylock
r_int
id|fastcall
id|__down_write_trylock
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __down_write_trylock&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;activity
op_eq
l_int|0
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
(brace
multiline_comment|/* granted */
id|sem-&gt;activity
op_assign
op_minus
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __down_write_trylock&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * release a read lock on the semaphore&n; */
DECL|function|__up_read
r_void
id|fastcall
id|__up_read
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __up_read&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|sem-&gt;activity
op_eq
l_int|0
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
id|sem
op_assign
id|__rwsem_wake_one_writer
c_func
(paren
id|sem
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __up_read&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * release a write lock on the semaphore&n; */
DECL|function|__up_write
r_void
id|fastcall
id|__up_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __up_write&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|sem-&gt;activity
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
id|sem
op_assign
id|__rwsem_do_wake
c_func
(paren
id|sem
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __up_write&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * downgrade a write lock into a read lock&n; * - just wake up any readers at the front of the queue&n; */
DECL|function|__downgrade_write
r_void
id|fastcall
id|__downgrade_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Entering __downgrade_write&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|sem-&gt;activity
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sem-&gt;wait_list
)paren
)paren
id|sem
op_assign
id|__rwsem_do_wake
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sem-&gt;wait_lock
)paren
suffix:semicolon
id|rwsemtrace
c_func
(paren
id|sem
comma
l_string|&quot;Leaving __downgrade_write&quot;
)paren
suffix:semicolon
)brace
DECL|variable|init_rwsem
id|EXPORT_SYMBOL
c_func
(paren
id|init_rwsem
)paren
suffix:semicolon
DECL|variable|__down_read
id|EXPORT_SYMBOL
c_func
(paren
id|__down_read
)paren
suffix:semicolon
DECL|variable|__down_read_trylock
id|EXPORT_SYMBOL
c_func
(paren
id|__down_read_trylock
)paren
suffix:semicolon
DECL|variable|__down_write
id|EXPORT_SYMBOL
c_func
(paren
id|__down_write
)paren
suffix:semicolon
DECL|variable|__down_write_trylock
id|EXPORT_SYMBOL
c_func
(paren
id|__down_write_trylock
)paren
suffix:semicolon
DECL|variable|__up_read
id|EXPORT_SYMBOL
c_func
(paren
id|__up_read
)paren
suffix:semicolon
DECL|variable|__up_write
id|EXPORT_SYMBOL
c_func
(paren
id|__up_write
)paren
suffix:semicolon
DECL|variable|__downgrade_write
id|EXPORT_SYMBOL
c_func
(paren
id|__downgrade_write
)paren
suffix:semicolon
macro_line|#if RWSEM_DEBUG
DECL|variable|rwsemtrace
id|EXPORT_SYMBOL
c_func
(paren
id|rwsemtrace
)paren
suffix:semicolon
macro_line|#endif
eof
