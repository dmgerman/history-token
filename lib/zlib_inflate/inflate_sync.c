multiline_comment|/* inflate.c -- zlib interface to inflate modules&n; * Copyright (C) 1995-1998 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h&n; */
macro_line|#include &lt;linux/zutil.h&gt;
macro_line|#include &quot;infblock.h&quot;
macro_line|#include &quot;infutil.h&quot;
DECL|function|zlib_inflateSync
r_int
id|zlib_inflateSync
c_func
(paren
id|z_streamp
id|z
)paren
(brace
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of bytes to look at */
id|Byte
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer to bytes */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* number of marker bytes found in a row */
id|uLong
id|r
comma
id|w
suffix:semicolon
multiline_comment|/* temporaries to save total_in and total_out */
multiline_comment|/* set up */
r_if
c_cond
(paren
id|z
op_eq
l_int|NULL
op_logical_or
id|z-&gt;state
op_eq
l_int|NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|I_BAD
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|I_BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|z-&gt;avail_in
)paren
op_eq
l_int|0
)paren
r_return
id|Z_BUF_ERROR
suffix:semicolon
id|p
op_assign
id|z-&gt;next_in
suffix:semicolon
id|m
op_assign
id|z-&gt;state-&gt;sub.marker
suffix:semicolon
multiline_comment|/* search */
r_while
c_loop
(paren
id|n
op_logical_and
id|m
OL
l_int|4
)paren
(brace
r_static
r_const
id|Byte
id|mark
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
id|mark
(braket
id|m
)braket
)paren
id|m
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
)paren
id|m
op_assign
l_int|0
suffix:semicolon
r_else
id|m
op_assign
l_int|4
op_minus
id|m
suffix:semicolon
id|p
op_increment
comma
id|n
op_decrement
suffix:semicolon
)brace
multiline_comment|/* restore */
id|z-&gt;total_in
op_add_assign
id|p
op_minus
id|z-&gt;next_in
suffix:semicolon
id|z-&gt;next_in
op_assign
id|p
suffix:semicolon
id|z-&gt;avail_in
op_assign
id|n
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
id|m
suffix:semicolon
multiline_comment|/* return no joy or set up to restart on a new block */
r_if
c_cond
(paren
id|m
op_ne
l_int|4
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|r
op_assign
id|z-&gt;total_in
suffix:semicolon
id|w
op_assign
id|z-&gt;total_out
suffix:semicolon
id|zlib_inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
id|z-&gt;total_in
op_assign
id|r
suffix:semicolon
id|z-&gt;total_out
op_assign
id|w
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Returns true if inflate is currently at the end of a block generated&n; * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP&n; * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH&n; * but removes the length bytes of the resulting empty stored block. When&n; * decompressing, PPP checks that at the end of input packet, inflate is&n; * waiting for these length bytes.&n; */
DECL|function|zlib_inflateSyncPoint
r_int
id|zlib_inflateSyncPoint
c_func
(paren
id|z_streamp
id|z
)paren
(brace
r_if
c_cond
(paren
id|z
op_eq
l_int|NULL
op_logical_or
id|z-&gt;state
op_eq
l_int|NULL
op_logical_or
id|z-&gt;state-&gt;blocks
op_eq
l_int|NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_return
id|zlib_inflate_blocks_sync_point
c_func
(paren
id|z-&gt;state-&gt;blocks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|zlib_inflate_addhistory
r_static
r_int
id|zlib_inflate_addhistory
c_func
(paren
id|inflate_blocks_statef
op_star
id|s
comma
id|z_stream
op_star
id|z
)paren
(brace
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|t
suffix:semicolon
multiline_comment|/* temporary storage */
id|Byte
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Byte
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_ne
id|TYPE
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
multiline_comment|/* we&squot;re ready to rock */
id|LOAD
multiline_comment|/* while there is input ready, copy to output buffer, moving&n;     * pointers as needed.&n;     */
r_while
c_loop
(paren
id|n
)paren
(brace
id|t
op_assign
id|n
suffix:semicolon
multiline_comment|/* how many to do */
multiline_comment|/* is there room until end of buffer? */
r_if
c_cond
(paren
id|t
OG
id|m
)paren
id|t
op_assign
id|m
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
l_int|NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|t
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|q
comma
id|p
comma
id|t
)paren
suffix:semicolon
id|q
op_add_assign
id|t
suffix:semicolon
id|p
op_add_assign
id|t
suffix:semicolon
id|n
op_sub_assign
id|t
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|t
suffix:semicolon
id|s-&gt;read
op_assign
id|q
suffix:semicolon
multiline_comment|/* drag read pointer forward */
multiline_comment|/*      WWRAP  */
multiline_comment|/* expand WWRAP macro by hand to handle s-&gt;read */
r_if
c_cond
(paren
id|q
op_eq
id|s-&gt;end
)paren
(brace
id|s-&gt;read
op_assign
id|q
op_assign
id|s-&gt;window
suffix:semicolon
id|m
op_assign
id|WAVAIL
suffix:semicolon
)brace
)brace
id|UPDATE
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|zlib_inflateIncomp
r_int
id|zlib_inflateIncomp
c_func
(paren
id|z_stream
op_star
id|z
)paren
(brace
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BLOCKS
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_return
id|zlib_inflate_addhistory
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
)paren
suffix:semicolon
)brace
eof
