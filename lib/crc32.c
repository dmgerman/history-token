multiline_comment|/*&n; * Oct 15, 2000 Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; * Nicer crc32 functions/docs submitted by linux@horizon.com.  Thanks!&n; * Code was from the public domain, copyright abandoned.  Code was&n; * subsequently included in the kernel, thus was re-licensed under the&n; * GNU GPL v2.&n; *&n; * Oct 12, 2000 Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; * Same crc32 function was used in 5 other places in the kernel.&n; * I made one version, and deleted the others.&n; * There are various incantations of crc32().  Some use a seed of 0 or ~0.&n; * Some xor at the end with ~0.  The generic crc32() function takes&n; * seed as an argument, and doesn&squot;t xor at the end.  Then individual&n; * users can do whatever they need.&n; *   drivers/net/smc9194.c uses seed ~0, doesn&squot;t xor with ~0.&n; *   fs/jffs2 uses seed 0, doesn&squot;t xor with ~0.&n; *   fs/partitions/efi.c uses seed ~0, xor&squot;s with ~0.&n; *&n; * This source code is licensed under the GNU General Public License,&n; * Version 2.  See the file COPYING for more details.&n; */
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &quot;crc32defs.h&quot;
macro_line|#if CRC_LE_BITS == 8
DECL|macro|tole
mdefine_line|#define tole(x) __constant_cpu_to_le32(x)
DECL|macro|tobe
mdefine_line|#define tobe(x) __constant_cpu_to_be32(x)
macro_line|#else
DECL|macro|tole
mdefine_line|#define tole(x) (x)
DECL|macro|tobe
mdefine_line|#define tobe(x) (x)
macro_line|#endif
macro_line|#include &quot;crc32table.h&quot;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matt Domsch &lt;Matt_Domsch@dell.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Ethernet CRC32 calculations&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#if CRC_LE_BITS == 1
multiline_comment|/*&n; * In fact, the table-based code will work in this case, but it can be&n; * simplified by inlining the table in ?: form.&n; */
multiline_comment|/**&n; * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_le
id|u32
id|__attribute_pure__
id|crc32_le
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|1
)paren
ques
c_cond
id|CRCPOLY_LE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* Table-based approach */
multiline_comment|/**&n; * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_le
id|u32
id|__attribute_pure__
id|crc32_le
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
macro_line|# if CRC_LE_BITS == 8
r_const
id|u32
op_star
id|b
op_assign
(paren
id|u32
op_star
)paren
id|p
suffix:semicolon
r_const
id|u32
op_star
id|tab
op_assign
id|crc32table_le
suffix:semicolon
macro_line|# ifdef __LITTLE_ENDIAN
DECL|macro|DO_CRC
macro_line|#  define DO_CRC(x) crc = tab[ (crc ^ (x)) &amp; 255 ] ^ (crc&gt;&gt;8)
macro_line|# else
macro_line|#  define DO_CRC(x) crc = tab[ ((crc &gt;&gt; 24) ^ (x)) &amp; 255] ^ (crc&lt;&lt;8)
macro_line|# endif
id|crc
op_assign
id|__cpu_to_le32
c_func
(paren
id|crc
)paren
suffix:semicolon
multiline_comment|/* Align it */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_int
)paren
id|b
)paren
op_amp
l_int|3
op_logical_and
id|len
)paren
)paren
(brace
r_do
(brace
id|u8
op_star
id|p
op_assign
(paren
id|u8
op_star
)paren
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
id|b
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_decrement
id|len
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|b
)paren
op_amp
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|len
op_ge
l_int|4
)paren
)paren
(brace
multiline_comment|/* load data 32 bits wide, xor data 32 bits wide. */
r_int
id|save_len
op_assign
id|len
op_amp
l_int|3
suffix:semicolon
id|len
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
op_decrement
id|b
suffix:semicolon
multiline_comment|/* use pre increment below(*++b) for speed */
r_do
(brace
id|crc
op_xor_assign
op_star
op_increment
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
)paren
suffix:semicolon
id|b
op_increment
suffix:semicolon
multiline_comment|/* point to next byte(s) */
id|len
op_assign
id|save_len
suffix:semicolon
)brace
multiline_comment|/* And the last few bytes */
r_if
c_cond
(paren
id|len
)paren
(brace
r_do
(brace
id|u8
op_star
id|p
op_assign
(paren
id|u8
op_star
)paren
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
id|b
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
)paren
suffix:semicolon
)brace
r_return
id|__le32_to_cpu
c_func
(paren
id|crc
)paren
suffix:semicolon
DECL|macro|ENDIAN_SHIFT
macro_line|#undef ENDIAN_SHIFT
DECL|macro|DO_CRC
macro_line|#undef DO_CRC
macro_line|# elif CRC_LE_BITS == 4
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|4
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|15
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|4
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|15
)braket
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
macro_line|# elif CRC_LE_BITS == 2
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
macro_line|# endif
)brace
macro_line|#endif
macro_line|#if CRC_BE_BITS == 1
multiline_comment|/*&n; * In fact, the table-based code will work in this case, but it can be&n; * simplified by inlining the table in ?: form.&n; */
multiline_comment|/**&n; * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_be
id|u32
id|__attribute_pure__
id|crc32_be
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|CRCPOLY_BE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* Table-based approach */
multiline_comment|/**&n; * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_be
id|u32
id|__attribute_pure__
id|crc32_be
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
macro_line|# if CRC_BE_BITS == 8
r_const
id|u32
op_star
id|b
op_assign
(paren
id|u32
op_star
)paren
id|p
suffix:semicolon
r_const
id|u32
op_star
id|tab
op_assign
id|crc32table_be
suffix:semicolon
macro_line|# ifdef __LITTLE_ENDIAN
DECL|macro|DO_CRC
macro_line|#  define DO_CRC(x) crc = tab[ (crc ^ (x)) &amp; 255 ] ^ (crc&gt;&gt;8)
macro_line|# else
macro_line|#  define DO_CRC(x) crc = tab[ ((crc &gt;&gt; 24) ^ (x)) &amp; 255] ^ (crc&lt;&lt;8)
macro_line|# endif
id|crc
op_assign
id|__cpu_to_be32
c_func
(paren
id|crc
)paren
suffix:semicolon
multiline_comment|/* Align it */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_int
)paren
id|b
)paren
op_amp
l_int|3
op_logical_and
id|len
)paren
)paren
(brace
r_do
(brace
id|u8
op_star
id|p
op_assign
(paren
id|u8
op_star
)paren
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
id|b
op_assign
(paren
id|u32
op_star
)paren
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_decrement
id|len
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|b
)paren
op_amp
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|len
op_ge
l_int|4
)paren
)paren
(brace
multiline_comment|/* load data 32 bits wide, xor data 32 bits wide. */
r_int
id|save_len
op_assign
id|len
op_amp
l_int|3
suffix:semicolon
id|len
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
op_decrement
id|b
suffix:semicolon
multiline_comment|/* use pre increment below(*++b) for speed */
r_do
(brace
id|crc
op_xor_assign
op_star
op_increment
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|DO_CRC
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
)paren
suffix:semicolon
id|b
op_increment
suffix:semicolon
multiline_comment|/* point to next byte(s) */
id|len
op_assign
id|save_len
suffix:semicolon
)brace
multiline_comment|/* And the last few bytes */
r_if
c_cond
(paren
id|len
)paren
(brace
r_do
(brace
id|u8
op_star
id|p
op_assign
(paren
id|u8
op_star
)paren
id|b
suffix:semicolon
id|DO_CRC
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
id|b
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
)paren
suffix:semicolon
)brace
r_return
id|__be32_to_cpu
c_func
(paren
id|crc
)paren
suffix:semicolon
DECL|macro|ENDIAN_SHIFT
macro_line|#undef ENDIAN_SHIFT
DECL|macro|DO_CRC
macro_line|#undef DO_CRC
macro_line|# elif CRC_BE_BITS == 4
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|28
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|28
)braket
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
macro_line|# elif CRC_BE_BITS == 2
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
macro_line|# endif
)brace
macro_line|#endif
DECL|function|bitreverse
id|u32
id|bitreverse
c_func
(paren
id|u32
id|x
)paren
(brace
id|x
op_assign
(paren
id|x
op_rshift
l_int|16
)paren
op_or
(paren
id|x
op_lshift
l_int|16
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|8
op_amp
l_int|0x00ff00ff
)paren
op_or
(paren
id|x
op_lshift
l_int|8
op_amp
l_int|0xff00ff00
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|4
op_amp
l_int|0x0f0f0f0f
)paren
op_or
(paren
id|x
op_lshift
l_int|4
op_amp
l_int|0xf0f0f0f0
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|2
op_amp
l_int|0x33333333
)paren
op_or
(paren
id|x
op_lshift
l_int|2
op_amp
l_int|0xcccccccc
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|1
op_amp
l_int|0x55555555
)paren
op_or
(paren
id|x
op_lshift
l_int|1
op_amp
l_int|0xaaaaaaaa
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|variable|crc32_le
id|EXPORT_SYMBOL
c_func
(paren
id|crc32_le
)paren
suffix:semicolon
DECL|variable|crc32_be
id|EXPORT_SYMBOL
c_func
(paren
id|crc32_be
)paren
suffix:semicolon
DECL|variable|bitreverse
id|EXPORT_SYMBOL
c_func
(paren
id|bitreverse
)paren
suffix:semicolon
multiline_comment|/*&n; * A brief CRC tutorial.&n; *&n; * A CRC is a long-division remainder.  You add the CRC to the message,&n; * and the whole thing (message+CRC) is a multiple of the given&n; * CRC polynomial.  To check the CRC, you can either check that the&n; * CRC matches the recomputed value, *or* you can check that the&n; * remainder computed on the message+CRC is 0.  This latter approach&n; * is used by a lot of hardware implementations, and is why so many&n; * protocols put the end-of-frame flag after the CRC.&n; *&n; * It&squot;s actually the same long division you learned in school, except that&n; * - We&squot;re working in binary, so the digits are only 0 and 1, and&n; * - When dividing polynomials, there are no carries.  Rather than add and&n; *   subtract, we just xor.  Thus, we tend to get a bit sloppy about&n; *   the difference between adding and subtracting.&n; *&n; * A 32-bit CRC polynomial is actually 33 bits long.  But since it&squot;s&n; * 33 bits long, bit 32 is always going to be set, so usually the CRC&n; * is written in hex with the most significant bit omitted.  (If you&squot;re&n; * familiar with the IEEE 754 floating-point format, it&squot;s the same idea.)&n; *&n; * Note that a CRC is computed over a string of *bits*, so you have&n; * to decide on the endianness of the bits within each byte.  To get&n; * the best error-detecting properties, this should correspond to the&n; * order they&squot;re actually sent.  For example, standard RS-232 serial is&n; * little-endian; the most significant bit (sometimes used for parity)&n; * is sent last.  And when appending a CRC word to a message, you should&n; * do it in the right order, matching the endianness.&n; *&n; * Just like with ordinary division, the remainder is always smaller than&n; * the divisor (the CRC polynomial) you&squot;re dividing by.  Each step of the&n; * division, you take one more digit (bit) of the dividend and append it&n; * to the current remainder.  Then you figure out the appropriate multiple&n; * of the divisor to subtract to being the remainder back into range.&n; * In binary, it&squot;s easy - it has to be either 0 or 1, and to make the&n; * XOR cancel, it&squot;s just a copy of bit 32 of the remainder.&n; *&n; * When computing a CRC, we don&squot;t care about the quotient, so we can&n; * throw the quotient bit away, but subtract the appropriate multiple of&n; * the polynomial from the remainder and we&squot;re back to where we started,&n; * ready to process the next bit.&n; *&n; * A big-endian CRC written this way would be coded like:&n; * for (i = 0; i &lt; input_bits; i++) {&n; * &t;multiple = remainder &amp; 0x80000000 ? CRCPOLY : 0;&n; * &t;remainder = (remainder &lt;&lt; 1 | next_input_bit()) ^ multiple;&n; * }&n; * Notice how, to get at bit 32 of the shifted remainder, we look&n; * at bit 31 of the remainder *before* shifting it.&n; *&n; * But also notice how the next_input_bit() bits we&squot;re shifting into&n; * the remainder don&squot;t actually affect any decision-making until&n; * 32 bits later.  Thus, the first 32 cycles of this are pretty boring.&n; * Also, to add the CRC to a message, we need a 32-bit-long hole for it at&n; * the end, so we have to add 32 extra cycles shifting in zeros at the&n; * end of every message,&n; *&n; * So the standard trick is to rearrage merging in the next_input_bit()&n; * until the moment it&squot;s needed.  Then the first 32 cycles can be precomputed,&n; * and merging in the final 32 zero bits to make room for the CRC can be&n; * skipped entirely.&n; * This changes the code to:&n; * for (i = 0; i &lt; input_bits; i++) {&n; *      remainder ^= next_input_bit() &lt;&lt; 31;&n; * &t;multiple = (remainder &amp; 0x80000000) ? CRCPOLY : 0;&n; * &t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * }&n; * With this optimization, the little-endian code is simpler:&n; * for (i = 0; i &lt; input_bits; i++) {&n; *      remainder ^= next_input_bit();&n; * &t;multiple = (remainder &amp; 1) ? CRCPOLY : 0;&n; * &t;remainder = (remainder &gt;&gt; 1) ^ multiple;&n; * }&n; *&n; * Note that the other details of endianness have been hidden in CRCPOLY&n; * (which must be bit-reversed) and next_input_bit().&n; *&n; * However, as long as next_input_bit is returning the bits in a sensible&n; * order, we can actually do the merging 8 or more bits at a time rather&n; * than one bit at a time:&n; * for (i = 0; i &lt; input_bytes; i++) {&n; * &t;remainder ^= next_input_byte() &lt;&lt; 24;&n; * &t;for (j = 0; j &lt; 8; j++) {&n; * &t;&t;multiple = (remainder &amp; 0x80000000) ? CRCPOLY : 0;&n; * &t;&t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * &t;}&n; * }&n; * Or in little-endian:&n; * for (i = 0; i &lt; input_bytes; i++) {&n; * &t;remainder ^= next_input_byte();&n; * &t;for (j = 0; j &lt; 8; j++) {&n; * &t;&t;multiple = (remainder &amp; 1) ? CRCPOLY : 0;&n; * &t;&t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * &t;}&n; * }&n; * If the input is a multiple of 32 bits, you can even XOR in a 32-bit&n; * word at a time and increase the inner loop count to 32.&n; *&n; * You can also mix and match the two loop styles, for example doing the&n; * bulk of a message byte-at-a-time and adding bit-at-a-time processing&n; * for any fractional bytes at the end.&n; *&n; * The only remaining optimization is to the byte-at-a-time table method.&n; * Here, rather than just shifting one bit of the remainder to decide&n; * in the correct multiple to subtract, we can shift a byte at a time.&n; * This produces a 40-bit (rather than a 33-bit) intermediate remainder,&n; * but again the multiple of the polynomial to subtract depends only on&n; * the high bits, the high 8 bits in this case.  &n; *&n; * The multile we need in that case is the low 32 bits of a 40-bit&n; * value whose high 8 bits are given, and which is a multiple of the&n; * generator polynomial.  This is simply the CRC-32 of the given&n; * one-byte message.&n; *&n; * Two more details: normally, appending zero bits to a message which&n; * is already a multiple of a polynomial produces a larger multiple of that&n; * polynomial.  To enable a CRC to detect this condition, it&squot;s common to&n; * invert the CRC before appending it.  This makes the remainder of the&n; * message+crc come out not as zero, but some fixed non-zero value.&n; *&n; * The same problem applies to zero bits prepended to the message, and&n; * a similar solution is used.  Instead of starting with a remainder of&n; * 0, an initial remainder of all ones is used.  As long as you start&n; * the same way on decoding, it doesn&squot;t make a difference.&n; */
macro_line|#ifdef UNITTEST
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#if 0&t;&t;&t;&t;/*Not used at present */
r_static
r_void
id|buf_dump
c_func
(paren
r_char
r_const
op_star
id|prefix
comma
r_int
r_char
r_const
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|fputs
c_func
(paren
id|prefix
comma
id|stdout
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
id|printf
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bytereverse
r_static
r_void
id|bytereverse
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_int
r_char
id|x
op_assign
op_star
id|buf
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|4
)paren
op_or
(paren
id|x
op_lshift
l_int|4
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|2
op_amp
l_int|0x33
)paren
op_or
(paren
id|x
op_lshift
l_int|2
op_amp
l_int|0xcc
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|1
op_amp
l_int|0x55
)paren
op_or
(paren
id|x
op_lshift
l_int|1
op_amp
l_int|0xaa
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|x
suffix:semicolon
)brace
)brace
DECL|function|random_garbage
r_static
r_void
id|random_garbage
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|buf
op_increment
op_assign
(paren
r_int
r_char
)paren
id|random
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;&t;&t;&t;/* Not used at present */
r_static
r_void
id|store_le
c_func
(paren
id|u32
id|x
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
)paren
id|x
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|8
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|store_be
r_static
r_void
id|store_be
c_func
(paren
id|u32
id|x
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|24
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|8
)paren
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|x
suffix:semicolon
)brace
multiline_comment|/*&n; * This checks that CRC(buf + CRC(buf)) = 0, and that&n; * CRC commutes with bit-reversal.  This has the side effect&n; * of bytewise bit-reversing the input buffer, and returns&n; * the CRC of the reversed buffer.&n; */
DECL|function|test_step
r_static
id|u32
id|test_step
c_func
(paren
id|u32
id|init
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|u32
id|crc1
comma
id|crc2
suffix:semicolon
r_int
id|i
suffix:semicolon
id|crc1
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|store_be
c_func
(paren
id|crc1
comma
id|buf
op_plus
id|len
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC cancellation fail: 0x%08x should be 0&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|len
op_plus
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|crc2
comma
id|buf
op_plus
id|i
comma
id|len
op_plus
l_int|4
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC split fail: 0x%08x&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
)brace
multiline_comment|/* Now swap it around for the other test */
id|bytereverse
c_func
(paren
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
id|init
op_assign
id|bitreverse
c_func
(paren
id|init
)paren
suffix:semicolon
id|crc2
op_assign
id|bitreverse
c_func
(paren
id|crc1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc1
op_ne
id|bitreverse
c_func
(paren
id|crc2
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nBit reversal fail: 0x%08x -&gt; %0x08x -&gt; 0x%08x&bslash;n&quot;
comma
id|crc1
comma
id|crc2
comma
id|bitreverse
c_func
(paren
id|crc2
)paren
)paren
suffix:semicolon
id|crc1
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc1
op_ne
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC endianness fail: 0x%08x != 0x%08x&bslash;n&quot;
comma
id|crc1
comma
id|crc2
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC cancellation fail: 0x%08x should be 0&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|len
op_plus
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|crc2
comma
id|buf
op_plus
id|i
comma
id|len
op_plus
l_int|4
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC split fail: 0x%08x&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
)brace
r_return
id|crc1
suffix:semicolon
)brace
DECL|macro|SIZE
mdefine_line|#define SIZE 64
DECL|macro|INIT1
mdefine_line|#define INIT1 0
DECL|macro|INIT2
mdefine_line|#define INIT2 0
DECL|function|main
r_int
id|main
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|buf1
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
r_char
id|buf2
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
r_char
id|buf3
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|crc1
comma
id|crc2
comma
id|crc3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;rTesting length %d...&quot;
comma
id|i
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|random_garbage
c_func
(paren
id|buf1
comma
id|i
)paren
suffix:semicolon
id|random_garbage
c_func
(paren
id|buf2
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|buf3
(braket
id|j
)braket
op_assign
id|buf1
(braket
id|j
)braket
op_xor
id|buf2
(braket
id|j
)braket
suffix:semicolon
id|crc1
op_assign
id|test_step
c_func
(paren
id|INIT1
comma
id|buf1
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|test_step
c_func
(paren
id|INIT2
comma
id|buf2
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Now check that CRC(buf1 ^ buf2) = CRC(buf1) ^ CRC(buf2) */
id|crc3
op_assign
id|test_step
c_func
(paren
id|INIT1
op_xor
id|INIT2
comma
id|buf3
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc3
op_ne
(paren
id|crc1
op_xor
id|crc2
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;CRC XOR fail: 0x%08x != 0x%08x ^ 0x%08x&bslash;n&quot;
comma
id|crc3
comma
id|crc1
comma
id|crc2
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nAll test complete.  No failures expected.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* UNITTEST */
eof
