multiline_comment|/* &n; * Oct 15, 2000 Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; * Nicer crc32 functions/docs submitted by linux@horizon.com.  Thanks!&n; *&n; * Oct 12, 2000 Matt Domsch &lt;Matt_Domsch@dell.com&gt;&n; * Same crc32 function was used in 5 other places in the kernel.&n; * I made one version, and deleted the others.&n; * There are various incantations of crc32().  Some use a seed of 0 or ~0.&n; * Some xor at the end with ~0.  The generic crc32() function takes&n; * seed as an argument, and doesn&squot;t xor at the end.  Then individual&n; * users can do whatever they need.&n; *   drivers/net/smc9194.c uses seed ~0, doesn&squot;t xor with ~0.&n; *   fs/jffs2 uses seed 0, doesn&squot;t xor with ~0.&n; *   fs/partitions/efi.c uses seed ~0, xor&squot;s with ~0.&n; * &n; */
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#if __GNUC__ &gt;= 3&t;/* 2.x has &quot;attribute&quot;, but only 3.0 has &quot;pure */
DECL|macro|attribute
mdefine_line|#define attribute(x) __attribute__(x)
macro_line|#else
DECL|macro|attribute
mdefine_line|#define attribute(x)
macro_line|#endif
multiline_comment|/*&n; * This code is in the public domain; copyright abandoned.&n; * Liability for non-performance of this code is limited to the amount&n; * you paid for it.  Since it is distributed for free, your refund will&n; * be very very small.  If it breaks, you get to keep both pieces.&n; */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matt Domsch &lt;Matt_Domsch@dell.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Ethernet CRC32 calculations&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL and additional rights&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * There are multiple 16-bit CRC polynomials in common use, but this is&n; * *the* standard CRC-32 polynomial, first popularized by Ethernet.&n; * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0&n; */
DECL|macro|CRCPOLY_LE
mdefine_line|#define CRCPOLY_LE 0xedb88320
DECL|macro|CRCPOLY_BE
mdefine_line|#define CRCPOLY_BE 0x04c11db7
multiline_comment|/* How many bits at a time to use.  Requires a table of 4&lt;&lt;CRC_xx_BITS bytes. */
multiline_comment|/* For less performance-sensitive, use 4 */
DECL|macro|CRC_LE_BITS
mdefine_line|#define CRC_LE_BITS 8
DECL|macro|CRC_BE_BITS
mdefine_line|#define CRC_BE_BITS 8
multiline_comment|/*&n; * Little-endian CRC computation.  Used with serial bit streams sent&n; * lsbit-first.  Be sure to use cpu_to_le32() to append the computed CRC.&n; */
macro_line|#if CRC_LE_BITS &gt; 8 || CRC_LE_BITS &lt; 1 || CRC_LE_BITS &amp; CRC_LE_BITS-1
macro_line|# error CRC_LE_BITS must be a power of 2 between 1 and 8
macro_line|#endif
macro_line|#if CRC_LE_BITS == 1
multiline_comment|/*&n; * In fact, the table-based code will work in this case, but it can be&n; * simplified by inlining the table in ?: form.&n; */
DECL|macro|crc32init_le
mdefine_line|#define crc32init_le()
DECL|macro|crc32cleanup_le
mdefine_line|#define crc32cleanup_le()
multiline_comment|/**&n; * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_le
id|u32
id|attribute
c_func
(paren
(paren
id|pure
)paren
)paren
id|crc32_le
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|1
)paren
ques
c_cond
id|CRCPOLY_LE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* Table-based approach */
DECL|variable|crc32table_le
r_static
id|u32
op_star
id|crc32table_le
suffix:semicolon
multiline_comment|/**&n; * crc32init_le() - allocate and initialize LE table data&n; *&n; * crc is the crc of the byte i; other entries are filled in based on the&n; * fact that crctable[i^j] = crctable[i] ^ crctable[j].&n; *&n; */
DECL|function|crc32init_le
r_static
r_int
id|__init
id|crc32init_le
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|crc
op_assign
l_int|1
suffix:semicolon
id|crc32table_le
op_assign
id|kmalloc
c_func
(paren
(paren
l_int|1
op_lshift
id|CRC_LE_BITS
)paren
op_star
r_sizeof
(paren
id|u32
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crc32table_le
)paren
r_return
l_int|1
suffix:semicolon
id|crc32table_le
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
op_lshift
(paren
id|CRC_LE_BITS
op_minus
l_int|1
)paren
suffix:semicolon
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|1
)paren
ques
c_cond
id|CRCPOLY_LE
suffix:colon
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|1
op_lshift
id|CRC_LE_BITS
suffix:semicolon
id|j
op_add_assign
l_int|2
op_star
id|i
)paren
id|crc32table_le
(braket
id|i
op_plus
id|j
)braket
op_assign
id|crc
op_xor
id|crc32table_le
(braket
id|j
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * crc32cleanup_le(): free LE table data&n; */
DECL|function|crc32cleanup_le
r_static
r_void
id|__exit
id|crc32cleanup_le
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|crc32table_le
)paren
id|kfree
c_func
(paren
id|crc32table_le
)paren
suffix:semicolon
id|crc32table_le
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_le
id|u32
id|attribute
c_func
(paren
(paren
id|pure
)paren
)paren
id|crc32_le
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
macro_line|# if CRC_LE_BITS == 8
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|8
)paren
op_xor
id|crc32table_le
(braket
(paren
id|crc
op_xor
op_star
id|p
op_increment
)paren
op_amp
l_int|255
)braket
suffix:semicolon
macro_line|# elif CRC_LE_BITS == 4
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|4
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|15
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|4
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|15
)braket
suffix:semicolon
macro_line|# elif CRC_LE_BITS == 2
id|crc
op_xor_assign
op_star
id|p
op_increment
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|2
)paren
op_xor
id|crc32table_le
(braket
id|crc
op_amp
l_int|3
)braket
suffix:semicolon
macro_line|# endif
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Big-endian CRC computation.  Used with serial bit streams sent&n; * msbit-first.  Be sure to use cpu_to_be32() to append the computed CRC.&n; */
macro_line|#if CRC_BE_BITS &gt; 8 || CRC_BE_BITS &lt; 1 || CRC_BE_BITS &amp; CRC_BE_BITS-1
macro_line|# error CRC_BE_BITS must be a power of 2 between 1 and 8
macro_line|#endif
macro_line|#if CRC_BE_BITS == 1
multiline_comment|/*&n; * In fact, the table-based code will work in this case, but it can be&n; * simplified by inlining the table in ?: form.&n; */
DECL|macro|crc32init_be
mdefine_line|#define crc32init_be()
DECL|macro|crc32cleanup_be
mdefine_line|#define crc32cleanup_be()
multiline_comment|/**&n; * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_be
id|u32
id|attribute
c_func
(paren
(paren
id|pure
)paren
)paren
id|crc32_be
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|CRCPOLY_BE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* Table-based approach */
DECL|variable|crc32table_be
r_static
id|u32
op_star
id|crc32table_be
suffix:semicolon
multiline_comment|/**&n; * crc32init_be() - allocate and initialize BE table data&n; */
DECL|function|crc32init_be
r_static
r_int
id|__init
id|crc32init_be
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|crc
op_assign
l_int|0x80000000
suffix:semicolon
id|crc32table_be
op_assign
id|kmalloc
c_func
(paren
(paren
l_int|1
op_lshift
id|CRC_BE_BITS
)paren
op_star
r_sizeof
(paren
id|u32
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crc32table_be
)paren
r_return
l_int|1
suffix:semicolon
id|crc32table_be
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|CRC_BE_BITS
suffix:semicolon
id|i
op_lshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|1
)paren
op_xor
(paren
(paren
id|crc
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|CRCPOLY_BE
suffix:colon
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|crc32table_be
(braket
id|i
op_plus
id|j
)braket
op_assign
id|crc
op_xor
id|crc32table_be
(braket
id|j
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * crc32cleanup_be(): free BE table data&n; */
DECL|function|crc32cleanup_be
r_static
r_void
id|__exit
id|crc32cleanup_be
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|crc32table_be
)paren
id|kfree
c_func
(paren
id|crc32table_be
)paren
suffix:semicolon
id|crc32table_be
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32&n; * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for&n; *        other uses, or the previous crc32 value if computing incrementally.&n; * @p   - pointer to buffer over which CRC is run&n; * @len - length of buffer @p&n; * &n; */
DECL|function|crc32_be
id|u32
id|attribute
c_func
(paren
(paren
id|pure
)paren
)paren
id|crc32_be
c_func
(paren
id|u32
id|crc
comma
r_int
r_char
r_const
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
macro_line|# if CRC_BE_BITS == 8
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|8
)paren
op_xor
id|crc32table_be
(braket
(paren
id|crc
op_rshift
l_int|24
)paren
op_xor
op_star
id|p
op_increment
)braket
suffix:semicolon
macro_line|# elif CRC_BE_BITS == 4
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|28
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|28
)braket
suffix:semicolon
macro_line|# elif CRC_BE_BITS == 2
id|crc
op_xor_assign
op_star
id|p
op_increment
op_lshift
l_int|24
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|2
)paren
op_xor
id|crc32table_be
(braket
id|crc
op_rshift
l_int|30
)braket
suffix:semicolon
macro_line|# endif
)brace
r_return
id|crc
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * A brief CRC tutorial.&n; *&n; * A CRC is a long-division remainder.  You add the CRC to the message,&n; * and the whole thing (message+CRC) is a multiple of the given&n; * CRC polynomial.  To check the CRC, you can either check that the&n; * CRC matches the recomputed value, *or* you can check that the&n; * remainder computed on the message+CRC is 0.  This latter approach&n; * is used by a lot of hardware implementations, and is why so many&n; * protocols put the end-of-frame flag after the CRC.&n; *&n; * It&squot;s actually the same long division you learned in school, except that&n; * - We&squot;re working in binary, so the digits are only 0 and 1, and&n; * - When dividing polynomials, there are no carries.  Rather than add and&n; *   subtract, we just xor.  Thus, we tend to get a bit sloppy about&n; *   the difference between adding and subtracting.&n; *&n; * A 32-bit CRC polynomial is actually 33 bits long.  But since it&squot;s&n; * 33 bits long, bit 32 is always going to be set, so usually the CRC&n; * is written in hex with the most significant bit omitted.  (If you&squot;re&n; * familiar with the IEEE 754 floating-point format, it&squot;s the same idea.)&n; *&n; * Note that a CRC is computed over a string of *bits*, so you have&n; * to decide on the endianness of the bits within each byte.  To get&n; * the best error-detecting properties, this should correspond to the&n; * order they&squot;re actually sent.  For example, standard RS-232 serial is&n; * little-endian; the most significant bit (sometimes used for parity)&n; * is sent last.  And when appending a CRC word to a message, you should&n; * do it in the right order, matching the endianness.&n; *&n; * Just like with ordinary division, the remainder is always smaller than&n; * the divisor (the CRC polynomial) you&squot;re dividing by.  Each step of the&n; * division, you take one more digit (bit) of the dividend and append it&n; * to the current remainder.  Then you figure out the appropriate multiple&n; * of the divisor to subtract to being the remainder back into range.&n; * In binary, it&squot;s easy - it has to be either 0 or 1, and to make the&n; * XOR cancel, it&squot;s just a copy of bit 32 of the remainder.&n; *&n; * When computing a CRC, we don&squot;t care about the quotient, so we can&n; * throw the quotient bit away, but subtract the appropriate multiple of&n; * the polynomial from the remainder and we&squot;re back to where we started,&n; * ready to process the next bit.&n; *&n; * A big-endian CRC written this way would be coded like:&n; * for (i = 0; i &lt; input_bits; i++) {&n; * &t;multiple = remainder &amp; 0x80000000 ? CRCPOLY : 0;&n; * &t;remainder = (remainder &lt;&lt; 1 | next_input_bit()) ^ multiple;&n; * }&n; * Notice how, to get at bit 32 of the shifted remainder, we look&n; * at bit 31 of the remainder *before* shifting it.&n; *&n; * But also notice how the next_input_bit() bits we&squot;re shifting into&n; * the remainder don&squot;t actually affect any decision-making until&n; * 32 bits later.  Thus, the first 32 cycles of this are pretty boring.&n; * Also, to add the CRC to a message, we need a 32-bit-long hole for it at&n; * the end, so we have to add 32 extra cycles shifting in zeros at the&n; * end of every message,&n; *&n; * So the standard trick is to rearrage merging in the next_input_bit()&n; * until the moment it&squot;s needed.  Then the first 32 cycles can be precomputed,&n; * and merging in the final 32 zero bits to make room for the CRC can be&n; * skipped entirely.&n; * This changes the code to:&n; * for (i = 0; i &lt; input_bits; i++) {&n; *      remainder ^= next_input_bit() &lt;&lt; 31;&n; * &t;multiple = (remainder &amp; 0x80000000) ? CRCPOLY : 0;&n; * &t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * }&n; * With this optimization, the little-endian code is simpler:&n; * for (i = 0; i &lt; input_bits; i++) {&n; *      remainder ^= next_input_bit();&n; * &t;multiple = (remainder &amp; 1) ? CRCPOLY : 0;&n; * &t;remainder = (remainder &gt;&gt; 1) ^ multiple;&n; * }&n; *&n; * Note that the other details of endianness have been hidden in CRCPOLY&n; * (which must be bit-reversed) and next_input_bit().&n; *&n; * However, as long as next_input_bit is returning the bits in a sensible&n; * order, we can actually do the merging 8 or more bits at a time rather&n; * than one bit at a time:&n; * for (i = 0; i &lt; input_bytes; i++) {&n; * &t;remainder ^= next_input_byte() &lt;&lt; 24;&n; * &t;for (j = 0; j &lt; 8; j++) {&n; * &t;&t;multiple = (remainder &amp; 0x80000000) ? CRCPOLY : 0;&n; * &t;&t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * &t;}&n; * }&n; * Or in little-endian:&n; * for (i = 0; i &lt; input_bytes; i++) {&n; * &t;remainder ^= next_input_byte();&n; * &t;for (j = 0; j &lt; 8; j++) {&n; * &t;&t;multiple = (remainder &amp; 1) ? CRCPOLY : 0;&n; * &t;&t;remainder = (remainder &lt;&lt; 1) ^ multiple;&n; * &t;}&n; * }&n; * If the input is a multiple of 32 bits, you can even XOR in a 32-bit&n; * word at a time and increase the inner loop count to 32.&n; *&n; * You can also mix and match the two loop styles, for example doing the&n; * bulk of a message byte-at-a-time and adding bit-at-a-time processing&n; * for any fractional bytes at the end.&n; *&n; * The only remaining optimization is to the byte-at-a-time table method.&n; * Here, rather than just shifting one bit of the remainder to decide&n; * in the correct multiple to subtract, we can shift a byte at a time.&n; * This produces a 40-bit (rather than a 33-bit) intermediate remainder,&n; * but again the multiple of the polynomial to subtract depends only on&n; * the high bits, the high 8 bits in this case.  &n; *&n; * The multile we need in that case is the low 32 bits of a 40-bit&n; * value whose high 8 bits are given, and which is a multiple of the&n; * generator polynomial.  This is simply the CRC-32 of the given&n; * one-byte message.&n; *&n; * Two more details: normally, appending zero bits to a message which&n; * is already a multiple of a polynomial produces a larger multiple of that&n; * polynomial.  To enable a CRC to detect this condition, it&squot;s common to&n; * invert the CRC before appending it.  This makes the remainder of the&n; * message+crc come out not as zero, but some fixed non-zero value.&n; *&n; * The same problem applies to zero bits prepended to the message, and&n; * a similar solution is used.  Instead of starting with a remainder of&n; * 0, an initial remainder of all ones is used.  As long as you start&n; * the same way on decoding, it doesn&squot;t make a difference.&n; */
macro_line|#if UNITTEST
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#if 0&t;&t;&t;&t;/*Not used at present */
r_static
r_void
id|buf_dump
c_func
(paren
r_char
r_const
op_star
id|prefix
comma
r_int
r_char
r_const
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|fputs
c_func
(paren
id|prefix
comma
id|stdout
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
id|printf
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bitreverse
r_static
id|u32
id|attribute
c_func
(paren
(paren
r_const
)paren
)paren
id|bitreverse
c_func
(paren
id|u32
id|x
)paren
(brace
id|x
op_assign
(paren
id|x
op_rshift
l_int|16
)paren
op_or
(paren
id|x
op_lshift
l_int|16
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|8
op_amp
l_int|0x00ff00ff
)paren
op_or
(paren
id|x
op_lshift
l_int|8
op_amp
l_int|0xff00ff00
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|4
op_amp
l_int|0x0f0f0f0f
)paren
op_or
(paren
id|x
op_lshift
l_int|4
op_amp
l_int|0xf0f0f0f0
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|2
op_amp
l_int|0x33333333
)paren
op_or
(paren
id|x
op_lshift
l_int|2
op_amp
l_int|0xcccccccc
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|1
op_amp
l_int|0x55555555
)paren
op_or
(paren
id|x
op_lshift
l_int|1
op_amp
l_int|0xaaaaaaaa
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|bytereverse
r_static
r_void
id|bytereverse
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_int
r_char
id|x
op_assign
op_star
id|buf
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|4
)paren
op_or
(paren
id|x
op_lshift
l_int|4
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|2
op_amp
l_int|0x33
)paren
op_or
(paren
id|x
op_lshift
l_int|2
op_amp
l_int|0xcc
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
l_int|1
op_amp
l_int|0x55
)paren
op_or
(paren
id|x
op_lshift
l_int|1
op_amp
l_int|0xaa
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|x
suffix:semicolon
)brace
)brace
DECL|function|random_garbage
r_static
r_void
id|random_garbage
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|buf
op_increment
op_assign
(paren
r_int
r_char
)paren
id|random
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;&t;&t;&t;/* Not used at present */
r_static
r_void
id|store_le
c_func
(paren
id|u32
id|x
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
)paren
id|x
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|8
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|store_be
r_static
r_void
id|store_be
c_func
(paren
id|u32
id|x
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|24
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|x
op_rshift
l_int|8
)paren
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|x
suffix:semicolon
)brace
multiline_comment|/*&n; * This checks that CRC(buf + CRC(buf)) = 0, and that&n; * CRC commutes with bit-reversal.  This has the side effect&n; * of bytewise bit-reversing the input buffer, and returns&n; * the CRC of the reversed buffer.&n; */
DECL|function|test_step
r_static
id|u32
id|test_step
c_func
(paren
id|u32
id|init
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|u32
id|crc1
comma
id|crc2
suffix:semicolon
r_int
id|i
suffix:semicolon
id|crc1
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|store_be
c_func
(paren
id|crc1
comma
id|buf
op_plus
id|len
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC cancellation fail: 0x%08x should be 0&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|len
op_plus
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|init
comma
id|buf
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_be
c_func
(paren
id|crc2
comma
id|buf
op_plus
id|i
comma
id|len
op_plus
l_int|4
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC split fail: 0x%08x&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
)brace
multiline_comment|/* Now swap it around for the other test */
id|bytereverse
c_func
(paren
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
id|init
op_assign
id|bitreverse
c_func
(paren
id|init
)paren
suffix:semicolon
id|crc2
op_assign
id|bitreverse
c_func
(paren
id|crc1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc1
op_ne
id|bitreverse
c_func
(paren
id|crc2
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nBit reversal fail: 0x%08x -&gt; %0x08x -&gt; 0x%08x&bslash;n&quot;
comma
id|crc1
comma
id|crc2
comma
id|bitreverse
c_func
(paren
id|crc2
)paren
)paren
suffix:semicolon
id|crc1
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc1
op_ne
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC endianness fail: 0x%08x != 0x%08x&bslash;n&quot;
comma
id|crc1
comma
id|crc2
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|len
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC cancellation fail: 0x%08x should be 0&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|len
op_plus
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|init
comma
id|buf
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|crc32_le
c_func
(paren
id|crc2
comma
id|buf
op_plus
id|i
comma
id|len
op_plus
l_int|4
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc2
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nCRC split fail: 0x%08x&bslash;n&quot;
comma
id|crc2
)paren
suffix:semicolon
)brace
r_return
id|crc1
suffix:semicolon
)brace
DECL|macro|SIZE
mdefine_line|#define SIZE 64
DECL|macro|INIT1
mdefine_line|#define INIT1 0
DECL|macro|INIT2
mdefine_line|#define INIT2 0
DECL|function|main
r_int
id|main
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|buf1
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
r_char
id|buf2
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
r_char
id|buf3
(braket
id|SIZE
op_plus
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|crc1
comma
id|crc2
comma
id|crc3
suffix:semicolon
id|crc32init_le
c_func
(paren
)paren
suffix:semicolon
id|crc32init_be
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;rTesting length %d...&quot;
comma
id|i
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|random_garbage
c_func
(paren
id|buf1
comma
id|i
)paren
suffix:semicolon
id|random_garbage
c_func
(paren
id|buf2
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|buf3
(braket
id|j
)braket
op_assign
id|buf1
(braket
id|j
)braket
op_xor
id|buf2
(braket
id|j
)braket
suffix:semicolon
id|crc1
op_assign
id|test_step
c_func
(paren
id|INIT1
comma
id|buf1
comma
id|i
)paren
suffix:semicolon
id|crc2
op_assign
id|test_step
c_func
(paren
id|INIT2
comma
id|buf2
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Now check that CRC(buf1 ^ buf2) = CRC(buf1) ^ CRC(buf2) */
id|crc3
op_assign
id|test_step
c_func
(paren
id|INIT1
op_xor
id|INIT2
comma
id|buf3
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc3
op_ne
(paren
id|crc1
op_xor
id|crc2
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;CRC XOR fail: 0x%08x != 0x%08x ^ 0x%08x&bslash;n&quot;
comma
id|crc3
comma
id|crc1
comma
id|crc2
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nAll test complete.  No failures expected.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* UNITTEST */
multiline_comment|/**&n; * init_crc32(): generates CRC32 tables&n; * &n; * On successful initialization, use count is increased.&n; * This guarantees that the library functions will stay resident&n; * in memory, and prevents someone from &squot;rmmod crc32&squot; while&n; * a driver that needs it is still loaded.&n; * This also greatly simplifies drivers, as there&squot;s no need&n; * to call an initialization/cleanup function from each driver.&n; * Since crc32.o is a library module, there&squot;s no requirement&n; * that the user can unload it.&n; */
DECL|function|init_crc32
r_static
r_int
id|__init
id|init_crc32
c_func
(paren
r_void
)paren
(brace
r_int
id|rc1
comma
id|rc2
comma
id|rc
suffix:semicolon
id|rc1
op_assign
id|crc32init_le
c_func
(paren
)paren
suffix:semicolon
id|rc2
op_assign
id|crc32init_be
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|rc1
op_logical_or
id|rc2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * cleanup_crc32(): frees crc32 data when no longer needed&n; */
DECL|function|cleanup_crc32
r_static
r_void
id|__exit
id|cleanup_crc32
c_func
(paren
r_void
)paren
(brace
id|crc32cleanup_le
c_func
(paren
)paren
suffix:semicolon
id|crc32cleanup_be
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_crc32
id|fs_initcall
c_func
(paren
id|init_crc32
)paren
suffix:semicolon
DECL|variable|cleanup_crc32
id|module_exit
c_func
(paren
id|cleanup_crc32
)paren
suffix:semicolon
DECL|variable|crc32_le
id|EXPORT_SYMBOL
c_func
(paren
id|crc32_le
)paren
suffix:semicolon
DECL|variable|crc32_be
id|EXPORT_SYMBOL
c_func
(paren
id|crc32_be
)paren
suffix:semicolon
eof
