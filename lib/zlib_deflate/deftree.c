multiline_comment|/* +++ trees.c */
multiline_comment|/* trees.c -- output deflated data using Huffman coding&n; * Copyright (C) 1995-1996 Jean-loup Gailly&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/*&n; *  ALGORITHM&n; *&n; *      The &quot;deflation&quot; process uses several Huffman trees. The more&n; *      common source values are represented by shorter bit sequences.&n; *&n; *      Each code tree is stored in a compressed form which is itself&n; * a Huffman encoding of the lengths of all the code strings (in&n; * ascending order by source values).  The actual code strings are&n; * reconstructed from the lengths in the inflate process, as described&n; * in the deflate specification.&n; *&n; *  REFERENCES&n; *&n; *      Deutsch, L.P.,&quot;&squot;Deflate&squot; Compressed Data Format Specification&quot;.&n; *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc&n; *&n; *      Storer, James A.&n; *          Data Compression:  Methods and Theory, pp. 49-50.&n; *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.&n; *&n; *      Sedgewick, R.&n; *          Algorithms, p290.&n; *          Addison-Wesley, 1983. ISBN 0-201-06672-6.&n; */
multiline_comment|/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */
multiline_comment|/* #include &quot;deflate.h&quot; */
macro_line|#include &lt;linux/zutil.h&gt;
macro_line|#include &quot;defutil.h&quot;
macro_line|#ifdef DEBUG_ZLIB
macro_line|#  include &lt;ctype.h&gt;
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Constants&n; */
DECL|macro|MAX_BL_BITS
mdefine_line|#define MAX_BL_BITS 7
multiline_comment|/* Bit length codes must not exceed MAX_BL_BITS bits */
DECL|macro|END_BLOCK
mdefine_line|#define END_BLOCK 256
multiline_comment|/* end of block literal code */
DECL|macro|REP_3_6
mdefine_line|#define REP_3_6      16
multiline_comment|/* repeat previous bit length 3-6 times (2 bits of repeat count) */
DECL|macro|REPZ_3_10
mdefine_line|#define REPZ_3_10    17
multiline_comment|/* repeat a zero length 3-10 times  (3 bits of repeat count) */
DECL|macro|REPZ_11_138
mdefine_line|#define REPZ_11_138  18
multiline_comment|/* repeat a zero length 11-138 times  (7 bits of repeat count) */
DECL|variable|extra_lbits
id|local
r_const
r_int
id|extra_lbits
(braket
id|LENGTH_CODES
)braket
multiline_comment|/* extra bits for each length code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|extra_dbits
id|local
r_const
r_int
id|extra_dbits
(braket
id|D_CODES
)braket
multiline_comment|/* extra bits for each distance code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|6
comma
l_int|6
comma
l_int|7
comma
l_int|7
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
)brace
suffix:semicolon
DECL|variable|extra_blbits
id|local
r_const
r_int
id|extra_blbits
(braket
id|BL_CODES
)braket
multiline_comment|/* extra bits for each bit length code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|3
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|bl_order
id|local
r_const
id|uch
id|bl_order
(braket
id|BL_CODES
)braket
op_assign
(brace
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|0
comma
l_int|8
comma
l_int|7
comma
l_int|9
comma
l_int|6
comma
l_int|10
comma
l_int|5
comma
l_int|11
comma
l_int|4
comma
l_int|12
comma
l_int|3
comma
l_int|13
comma
l_int|2
comma
l_int|14
comma
l_int|1
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/* The lengths of the bit length codes are sent in order of decreasing&n; * probability, to avoid transmitting the lengths for unused bit length codes.&n; */
DECL|macro|Buf_size
mdefine_line|#define Buf_size (8 * 2*sizeof(char))
multiline_comment|/* Number of bits used within bi_buf. (bi_buf might be implemented on&n; * more than 16 bits on some systems.)&n; */
multiline_comment|/* ===========================================================================&n; * Local data. These are initialized only once.&n; */
DECL|variable|static_ltree
id|local
id|ct_data
id|static_ltree
(braket
id|L_CODES
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* The static literal tree. Since the bit lengths are imposed, there is no&n; * need for the L_CODES extra codes used during heap construction. However&n; * The codes 286 and 287 are needed to build a canonical tree (see zlib_tr_init&n; * below).&n; */
DECL|variable|static_dtree
id|local
id|ct_data
id|static_dtree
(braket
id|D_CODES
)braket
suffix:semicolon
multiline_comment|/* The static distance tree. (Actually a trivial tree since all codes use&n; * 5 bits.)&n; */
DECL|variable|dist_code
id|local
id|uch
id|dist_code
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* distance codes. The first 256 values correspond to the distances&n; * 3 .. 258, the last 256 values correspond to the top 8 bits of&n; * the 15 bit distances.&n; */
DECL|variable|length_code
id|local
id|uch
id|length_code
(braket
id|MAX_MATCH
op_minus
id|MIN_MATCH
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* length code for each normalized match length (0 == MIN_MATCH) */
DECL|variable|base_length
id|local
r_int
id|base_length
(braket
id|LENGTH_CODES
)braket
suffix:semicolon
multiline_comment|/* First normalized length for each code (0 = MIN_MATCH) */
DECL|variable|base_dist
id|local
r_int
id|base_dist
(braket
id|D_CODES
)braket
suffix:semicolon
multiline_comment|/* First normalized distance for each code (0 = distance of 1) */
DECL|struct|static_tree_desc_s
r_struct
id|static_tree_desc_s
(brace
DECL|member|static_tree
r_const
id|ct_data
op_star
id|static_tree
suffix:semicolon
multiline_comment|/* static tree or NULL */
DECL|member|extra_bits
r_const
id|intf
op_star
id|extra_bits
suffix:semicolon
multiline_comment|/* extra bits for each code or NULL */
DECL|member|extra_base
r_int
id|extra_base
suffix:semicolon
multiline_comment|/* base index for extra_bits */
DECL|member|elems
r_int
id|elems
suffix:semicolon
multiline_comment|/* max number of elements in the tree */
DECL|member|max_length
r_int
id|max_length
suffix:semicolon
multiline_comment|/* max bit length for the codes */
)brace
suffix:semicolon
DECL|variable|static_l_desc
id|local
id|static_tree_desc
id|static_l_desc
op_assign
(brace
id|static_ltree
comma
id|extra_lbits
comma
id|LITERALS
op_plus
l_int|1
comma
id|L_CODES
comma
id|MAX_BITS
)brace
suffix:semicolon
DECL|variable|static_d_desc
id|local
id|static_tree_desc
id|static_d_desc
op_assign
(brace
id|static_dtree
comma
id|extra_dbits
comma
l_int|0
comma
id|D_CODES
comma
id|MAX_BITS
)brace
suffix:semicolon
DECL|variable|static_bl_desc
id|local
id|static_tree_desc
id|static_bl_desc
op_assign
(brace
(paren
r_const
id|ct_data
op_star
)paren
l_int|0
comma
id|extra_blbits
comma
l_int|0
comma
id|BL_CODES
comma
id|MAX_BL_BITS
)brace
suffix:semicolon
multiline_comment|/* ===========================================================================&n; * Local (static) routines in this file.&n; */
id|local
r_void
id|tr_static_init
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
id|local
r_void
id|init_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|pqdownheap
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|k
)paren
)paren
suffix:semicolon
id|local
r_void
id|gen_bitlen
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|tree_desc
op_star
id|desc
)paren
)paren
suffix:semicolon
id|local
r_void
id|gen_codes
id|OF
c_func
(paren
(paren
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
comma
id|ushf
op_star
id|bl_count
)paren
)paren
suffix:semicolon
id|local
r_void
id|build_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|tree_desc
op_star
id|desc
)paren
)paren
suffix:semicolon
id|local
r_void
id|scan_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
)paren
)paren
suffix:semicolon
id|local
r_void
id|send_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
)paren
)paren
suffix:semicolon
id|local
r_int
id|build_bl_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|send_all_trees
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|lcodes
comma
r_int
id|dcodes
comma
r_int
id|blcodes
)paren
)paren
suffix:semicolon
id|local
r_void
id|compress_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|ltree
comma
id|ct_data
op_star
id|dtree
)paren
)paren
suffix:semicolon
id|local
r_void
id|set_data_type
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_int
id|bi_reverse
id|OF
c_func
(paren
(paren
r_int
id|value
comma
r_int
id|length
)paren
)paren
suffix:semicolon
id|local
r_void
id|bi_windup
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|bi_flush
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|copy_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|charf
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|header
)paren
)paren
suffix:semicolon
macro_line|#ifndef DEBUG_ZLIB
DECL|macro|send_code
macro_line|#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
multiline_comment|/* Send a code of the given tree. c and tree must not have side effects */
macro_line|#else /* DEBUG_ZLIB */
DECL|macro|send_code
macro_line|#  define send_code(s, c, tree) &bslash;&n;     { if (z_verbose&gt;2) fprintf(stderr,&quot;&bslash;ncd %3d &quot;,(c)); &bslash;&n;       send_bits(s, tree[c].Code, tree[c].Len); }
macro_line|#endif
DECL|macro|d_code
mdefine_line|#define d_code(dist) &bslash;&n;   ((dist) &lt; 256 ? dist_code[dist] : dist_code[256+((dist)&gt;&gt;7)])
multiline_comment|/* Mapping from a distance to a distance code. dist is the distance - 1 and&n; * must not have side effects. dist_code[256] and dist_code[257] are never&n; * used.&n; */
multiline_comment|/* ===========================================================================&n; * Send a value on a given number of bits.&n; * IN assertion: length &lt;= 16 and value fits in length bits.&n; */
macro_line|#ifdef DEBUG_ZLIB
id|local
r_void
id|send_bits
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|value
comma
r_int
id|length
)paren
)paren
suffix:semicolon
DECL|function|send_bits
id|local
r_void
id|send_bits
c_func
(paren
id|s
comma
id|value
comma
id|length
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|value
suffix:semicolon
multiline_comment|/* value to send */
r_int
id|length
suffix:semicolon
multiline_comment|/* number of bits */
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot; l %2d v %4x &quot;
comma
id|length
comma
id|value
)paren
)paren
suffix:semicolon
id|Assert
c_func
(paren
id|length
OG
l_int|0
op_logical_and
id|length
op_le
l_int|15
comma
l_string|&quot;invalid length&quot;
)paren
suffix:semicolon
id|s-&gt;bits_sent
op_add_assign
(paren
id|ulg
)paren
id|length
suffix:semicolon
multiline_comment|/* If not enough room in bi_buf, use (valid) bits from bi_buf and&n;     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))&n;     * unused bits in value.&n;     */
r_if
c_cond
(paren
id|s-&gt;bi_valid
OG
(paren
r_int
)paren
id|Buf_size
op_minus
id|length
)paren
(brace
id|s-&gt;bi_buf
op_or_assign
(paren
id|value
op_lshift
id|s-&gt;bi_valid
)paren
suffix:semicolon
id|put_short
c_func
(paren
id|s
comma
id|s-&gt;bi_buf
)paren
suffix:semicolon
id|s-&gt;bi_buf
op_assign
(paren
id|ush
)paren
id|value
op_rshift
(paren
id|Buf_size
op_minus
id|s-&gt;bi_valid
)paren
suffix:semicolon
id|s-&gt;bi_valid
op_add_assign
id|length
op_minus
id|Buf_size
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;bi_buf
op_or_assign
id|value
op_lshift
id|s-&gt;bi_valid
suffix:semicolon
id|s-&gt;bi_valid
op_add_assign
id|length
suffix:semicolon
)brace
)brace
macro_line|#else /* !DEBUG_ZLIB */
DECL|macro|send_bits
mdefine_line|#define send_bits(s, value, length) &bslash;&n;{ int len = length;&bslash;&n;  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {&bslash;&n;    int val = value;&bslash;&n;    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);&bslash;&n;    put_short(s, s-&gt;bi_buf);&bslash;&n;    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);&bslash;&n;    s-&gt;bi_valid += len - Buf_size;&bslash;&n;  } else {&bslash;&n;    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;&bslash;&n;    s-&gt;bi_valid += len;&bslash;&n;  }&bslash;&n;}
macro_line|#endif /* DEBUG_ZLIB */
DECL|macro|MAX
mdefine_line|#define MAX(a,b) (a &gt;= b ? a : b)
multiline_comment|/* the arguments must not have side effects */
multiline_comment|/* ===========================================================================&n; * Initialize the various &squot;constant&squot; tables. In a multi-threaded environment,&n; * this function may be called by two threads concurrently, but this is&n; * harmless since both invocations do exactly the same thing.&n; */
DECL|function|tr_static_init
id|local
r_void
id|tr_static_init
c_func
(paren
)paren
(brace
r_static
r_int
id|static_init_done
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over tree elements */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit counter */
r_int
id|length
suffix:semicolon
multiline_comment|/* length value */
r_int
id|code
suffix:semicolon
multiline_comment|/* code value */
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance index */
id|ush
id|bl_count
(braket
id|MAX_BITS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* number of codes at each bit length for an optimal tree */
r_if
c_cond
(paren
id|static_init_done
)paren
r_return
suffix:semicolon
multiline_comment|/* Initialize the mapping length (0..255) -&gt; length code (0..28) */
id|length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|code
op_assign
l_int|0
suffix:semicolon
id|code
OL
id|LENGTH_CODES
op_minus
l_int|1
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_length
(braket
id|code
)braket
op_assign
id|length
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
id|extra_lbits
(braket
id|code
)braket
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|length_code
(braket
id|length
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|length
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: length != 256&quot;
)paren
suffix:semicolon
multiline_comment|/* Note that the length 255 (match length 258) can be represented&n;     * in two different ways: code 284 + 5 bits or code 285, so we&n;     * overwrite length_code[255] to use the best encoding:&n;     */
id|length_code
(braket
id|length
op_minus
l_int|1
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
multiline_comment|/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */
id|dist
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|code
op_assign
l_int|0
suffix:semicolon
id|code
OL
l_int|16
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_dist
(braket
id|code
)braket
op_assign
id|dist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
id|extra_dbits
(braket
id|code
)braket
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|dist_code
(braket
id|dist
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|dist
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: dist != 256&quot;
)paren
suffix:semicolon
id|dist
op_rshift_assign
l_int|7
suffix:semicolon
multiline_comment|/* from now on, all distances are divided by 128 */
r_for
c_loop
(paren
suffix:semicolon
id|code
OL
id|D_CODES
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_dist
(braket
id|code
)braket
op_assign
id|dist
op_lshift
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
(paren
id|extra_dbits
(braket
id|code
)braket
op_minus
l_int|7
)paren
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|dist_code
(braket
l_int|256
op_plus
id|dist
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|dist
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: 256+dist != 512&quot;
)paren
suffix:semicolon
multiline_comment|/* Construct the codes of the static literal tree */
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
id|bl_count
(braket
id|bits
)braket
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|143
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|8
comma
id|bl_count
(braket
l_int|8
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|255
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|9
comma
id|bl_count
(braket
l_int|9
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|279
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|7
comma
id|bl_count
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|287
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|8
comma
id|bl_count
(braket
l_int|8
)braket
op_increment
suffix:semicolon
multiline_comment|/* Codes 286 and 287 do not exist, but we must include them in the&n;     * tree construction to get a canonical Huffman tree (longest code&n;     * all ones)&n;     */
id|gen_codes
c_func
(paren
(paren
id|ct_data
op_star
)paren
id|static_ltree
comma
id|L_CODES
op_plus
l_int|1
comma
id|bl_count
)paren
suffix:semicolon
multiline_comment|/* The static distance tree is trivial: */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|D_CODES
suffix:semicolon
id|n
op_increment
)paren
(brace
id|static_dtree
(braket
id|n
)braket
dot
id|Len
op_assign
l_int|5
suffix:semicolon
id|static_dtree
(braket
id|n
)braket
dot
id|Code
op_assign
id|bi_reverse
c_func
(paren
(paren
r_int
)paren
id|n
comma
l_int|5
)paren
suffix:semicolon
)brace
id|static_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize the tree data structures for a new zlib stream.&n; */
DECL|function|zlib_tr_init
r_void
id|zlib_tr_init
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|tr_static_init
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;l_desc.dyn_tree
op_assign
id|s-&gt;dyn_ltree
suffix:semicolon
id|s-&gt;l_desc.stat_desc
op_assign
op_amp
id|static_l_desc
suffix:semicolon
id|s-&gt;d_desc.dyn_tree
op_assign
id|s-&gt;dyn_dtree
suffix:semicolon
id|s-&gt;d_desc.stat_desc
op_assign
op_amp
id|static_d_desc
suffix:semicolon
id|s-&gt;bl_desc.dyn_tree
op_assign
id|s-&gt;bl_tree
suffix:semicolon
id|s-&gt;bl_desc.stat_desc
op_assign
op_amp
id|static_bl_desc
suffix:semicolon
id|s-&gt;bi_buf
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bi_valid
op_assign
l_int|0
suffix:semicolon
id|s-&gt;last_eob_len
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* enough lookahead for inflate */
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_assign
l_int|0L
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the first block of the first file: */
id|init_block
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize a new block.&n; */
DECL|function|init_block
id|local
r_void
id|init_block
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over tree elements */
multiline_comment|/* Initialize the trees. */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|L_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;dyn_ltree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|D_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;dyn_dtree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|BL_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;bl_tree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dyn_ltree
(braket
id|END_BLOCK
)braket
dot
id|Freq
op_assign
l_int|1
suffix:semicolon
id|s-&gt;opt_len
op_assign
id|s-&gt;static_len
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;last_lit
op_assign
id|s-&gt;matches
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|SMALLEST
mdefine_line|#define SMALLEST 1
multiline_comment|/* Index within the heap array of least frequent node in the Huffman tree */
multiline_comment|/* ===========================================================================&n; * Remove the smallest element from the heap and recreate the heap with&n; * one less element. Updates heap and heap_len.&n; */
DECL|macro|pqremove
mdefine_line|#define pqremove(s, tree, top) &bslash;&n;{&bslash;&n;    top = s-&gt;heap[SMALLEST]; &bslash;&n;    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; &bslash;&n;    pqdownheap(s, tree, SMALLEST); &bslash;&n;}
multiline_comment|/* ===========================================================================&n; * Compares to subtrees, using the tree depth as tie breaker when&n; * the subtrees have equal frequency. This minimizes the worst case length.&n; */
DECL|macro|smaller
mdefine_line|#define smaller(tree, n, m, depth) &bslash;&n;   (tree[n].Freq &lt; tree[m].Freq || &bslash;&n;   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))
multiline_comment|/* ===========================================================================&n; * Restore the heap property by moving down the tree starting at node k,&n; * exchanging a node with the smallest of its two sons if necessary, stopping&n; * when the heap property is re-established (each father smaller than its&n; * two sons).&n; */
DECL|function|pqdownheap
id|local
r_void
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|k
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to restore */
r_int
id|k
suffix:semicolon
multiline_comment|/* node to move down */
(brace
r_int
id|v
op_assign
id|s-&gt;heap
(braket
id|k
)braket
suffix:semicolon
r_int
id|j
op_assign
id|k
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* left son of k */
r_while
c_loop
(paren
id|j
op_le
id|s-&gt;heap_len
)paren
(brace
multiline_comment|/* Set j to the smallest of the two sons: */
r_if
c_cond
(paren
id|j
OL
id|s-&gt;heap_len
op_logical_and
id|smaller
c_func
(paren
id|tree
comma
id|s-&gt;heap
(braket
id|j
op_plus
l_int|1
)braket
comma
id|s-&gt;heap
(braket
id|j
)braket
comma
id|s-&gt;depth
)paren
)paren
(brace
id|j
op_increment
suffix:semicolon
)brace
multiline_comment|/* Exit if v is smaller than both sons */
r_if
c_cond
(paren
id|smaller
c_func
(paren
id|tree
comma
id|v
comma
id|s-&gt;heap
(braket
id|j
)braket
comma
id|s-&gt;depth
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Exchange v with the smallest son */
id|s-&gt;heap
(braket
id|k
)braket
op_assign
id|s-&gt;heap
(braket
id|j
)braket
suffix:semicolon
id|k
op_assign
id|j
suffix:semicolon
multiline_comment|/* And continue down the tree, setting j to the left son of k */
id|j
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|s-&gt;heap
(braket
id|k
)braket
op_assign
id|v
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Compute the optimal bit lengths for a tree and update the total bit length&n; * for the current block.&n; * IN assertion: the fields freq and dad are set, heap[heap_max] and&n; *    above are the tree nodes sorted by increasing frequency.&n; * OUT assertions: the field len is set to the optimal bit length, the&n; *     array bl_count contains the frequencies for each bit length.&n; *     The length opt_len is updated; static_len is also updated if stree is&n; *     not null.&n; */
DECL|function|gen_bitlen
id|local
r_void
id|gen_bitlen
c_func
(paren
id|s
comma
id|desc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|tree_desc
op_star
id|desc
suffix:semicolon
multiline_comment|/* the tree descriptor */
(brace
id|ct_data
op_star
id|tree
op_assign
id|desc-&gt;dyn_tree
suffix:semicolon
r_int
id|max_code
op_assign
id|desc-&gt;max_code
suffix:semicolon
r_const
id|ct_data
op_star
id|stree
op_assign
id|desc-&gt;stat_desc-&gt;static_tree
suffix:semicolon
r_const
id|intf
op_star
id|extra
op_assign
id|desc-&gt;stat_desc-&gt;extra_bits
suffix:semicolon
r_int
id|base
op_assign
id|desc-&gt;stat_desc-&gt;extra_base
suffix:semicolon
r_int
id|max_length
op_assign
id|desc-&gt;stat_desc-&gt;max_length
suffix:semicolon
r_int
id|h
suffix:semicolon
multiline_comment|/* heap index */
r_int
id|n
comma
id|m
suffix:semicolon
multiline_comment|/* iterate over the tree elements */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit length */
r_int
id|xbits
suffix:semicolon
multiline_comment|/* extra bits */
id|ush
id|f
suffix:semicolon
multiline_comment|/* frequency */
r_int
id|overflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of elements with bit length too large */
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
id|s-&gt;bl_count
(braket
id|bits
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* In a first pass, compute the optimal bit lengths (which may&n;     * overflow in the case of the bit length tree).&n;     */
id|tree
(braket
id|s-&gt;heap
(braket
id|s-&gt;heap_max
)braket
)braket
dot
id|Len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* root of the heap */
r_for
c_loop
(paren
id|h
op_assign
id|s-&gt;heap_max
op_plus
l_int|1
suffix:semicolon
id|h
OL
id|HEAP_SIZE
suffix:semicolon
id|h
op_increment
)paren
(brace
id|n
op_assign
id|s-&gt;heap
(braket
id|h
)braket
suffix:semicolon
id|bits
op_assign
id|tree
(braket
id|tree
(braket
id|n
)braket
dot
id|Dad
)braket
dot
id|Len
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bits
OG
id|max_length
)paren
id|bits
op_assign
id|max_length
comma
id|overflow
op_increment
suffix:semicolon
id|tree
(braket
id|n
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
id|bits
suffix:semicolon
multiline_comment|/* We overwrite tree[n].Dad which is no longer needed */
r_if
c_cond
(paren
id|n
OG
id|max_code
)paren
r_continue
suffix:semicolon
multiline_comment|/* not a leaf node */
id|s-&gt;bl_count
(braket
id|bits
)braket
op_increment
suffix:semicolon
id|xbits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|base
)paren
id|xbits
op_assign
id|extra
(braket
id|n
op_minus
id|base
)braket
suffix:semicolon
id|f
op_assign
id|tree
(braket
id|n
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;opt_len
op_add_assign
(paren
id|ulg
)paren
id|f
op_star
(paren
id|bits
op_plus
id|xbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stree
)paren
id|s-&gt;static_len
op_add_assign
(paren
id|ulg
)paren
id|f
op_star
(paren
id|stree
(braket
id|n
)braket
dot
id|Len
op_plus
id|xbits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overflow
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbit length overflow&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* This happens for example on obj2 and pic of the Calgary corpus */
multiline_comment|/* Find the first bit length which could increase: */
r_do
(brace
id|bits
op_assign
id|max_length
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;bl_count
(braket
id|bits
)braket
op_eq
l_int|0
)paren
id|bits
op_decrement
suffix:semicolon
id|s-&gt;bl_count
(braket
id|bits
)braket
op_decrement
suffix:semicolon
multiline_comment|/* move one leaf down the tree */
id|s-&gt;bl_count
(braket
id|bits
op_plus
l_int|1
)braket
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* move one overflow item as its brother */
id|s-&gt;bl_count
(braket
id|max_length
)braket
op_decrement
suffix:semicolon
multiline_comment|/* The brother of the overflow item also moves one step up,&n;         * but this does not affect bl_count[max_length]&n;         */
id|overflow
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|overflow
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now recompute all bit lengths, scanning in increasing frequency.&n;     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all&n;     * lengths instead of fixing only the wrong ones. This idea is taken&n;     * from &squot;ar&squot; written by Haruhiko Okumura.)&n;     */
r_for
c_loop
(paren
id|bits
op_assign
id|max_length
suffix:semicolon
id|bits
op_ne
l_int|0
suffix:semicolon
id|bits
op_decrement
)paren
(brace
id|n
op_assign
id|s-&gt;bl_count
(braket
id|bits
)braket
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ne
l_int|0
)paren
(brace
id|m
op_assign
id|s-&gt;heap
(braket
op_decrement
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|max_code
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tree
(braket
id|m
)braket
dot
id|Len
op_ne
(paren
r_int
)paren
id|bits
)paren
(brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;code %d bits %d-&gt;%d&bslash;n&quot;
comma
id|m
comma
id|tree
(braket
id|m
)braket
dot
id|Len
comma
id|bits
)paren
)paren
suffix:semicolon
id|s-&gt;opt_len
op_add_assign
(paren
(paren
r_int
)paren
id|bits
op_minus
(paren
r_int
)paren
id|tree
(braket
id|m
)braket
dot
id|Len
)paren
op_star
(paren
r_int
)paren
id|tree
(braket
id|m
)braket
dot
id|Freq
suffix:semicolon
id|tree
(braket
id|m
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
id|bits
suffix:semicolon
)brace
id|n
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Generate the codes for a given tree and bit counts (which need not be&n; * optimal).&n; * IN assertion: the array bl_count contains the bit length statistics for&n; * the given tree and the field len is set for all tree elements.&n; * OUT assertion: the field code is set for all tree elements of non&n; *     zero code length.&n; */
DECL|function|gen_codes
id|local
r_void
id|gen_codes
(paren
id|tree
comma
id|max_code
comma
id|bl_count
)paren
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to decorate */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* largest code with non zero frequency */
id|ushf
op_star
id|bl_count
suffix:semicolon
multiline_comment|/* number of codes at each bit length */
(brace
id|ush
id|next_code
(braket
id|MAX_BITS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* next code value for each bit length */
id|ush
id|code
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* running code value */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit index */
r_int
id|n
suffix:semicolon
multiline_comment|/* code index */
multiline_comment|/* The distribution counts are first used to generate the code values&n;     * without bit reversal.&n;     */
r_for
c_loop
(paren
id|bits
op_assign
l_int|1
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
(brace
id|next_code
(braket
id|bits
)braket
op_assign
id|code
op_assign
(paren
id|code
op_plus
id|bl_count
(braket
id|bits
op_minus
l_int|1
)braket
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check that the bit counts in bl_count are consistent. The last code&n;     * must be all ones.&n;     */
id|Assert
(paren
id|code
op_plus
id|bl_count
(braket
id|MAX_BITS
)braket
op_minus
l_int|1
op_eq
(paren
l_int|1
op_lshift
id|MAX_BITS
)paren
op_minus
l_int|1
comma
l_string|&quot;inconsistent bit counts&quot;
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ngen_codes: max_code %d &quot;
comma
id|max_code
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|len
op_assign
id|tree
(braket
id|n
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now reverse the bits */
id|tree
(braket
id|n
)braket
dot
id|Code
op_assign
id|bi_reverse
c_func
(paren
id|next_code
(braket
id|len
)braket
op_increment
comma
id|len
)paren
suffix:semicolon
id|Tracecv
c_func
(paren
id|tree
op_ne
id|static_ltree
comma
(paren
id|stderr
comma
l_string|&quot;&bslash;nn %3d %c l %2d c %4x (%x) &quot;
comma
id|n
comma
(paren
id|isgraph
c_func
(paren
id|n
)paren
ques
c_cond
id|n
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|len
comma
id|tree
(braket
id|n
)braket
dot
id|Code
comma
id|next_code
(braket
id|len
)braket
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Construct one Huffman tree and assigns the code bit strings and lengths.&n; * Update the total bit length for the current block.&n; * IN assertion: the field freq is set for all tree elements.&n; * OUT assertions: the fields len and code are set to the optimal bit length&n; *     and corresponding code. The length opt_len is updated; static_len is&n; *     also updated if stree is not null. The field max_code is set.&n; */
DECL|function|build_tree
id|local
r_void
id|build_tree
c_func
(paren
id|s
comma
id|desc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|tree_desc
op_star
id|desc
suffix:semicolon
multiline_comment|/* the tree descriptor */
(brace
id|ct_data
op_star
id|tree
op_assign
id|desc-&gt;dyn_tree
suffix:semicolon
r_const
id|ct_data
op_star
id|stree
op_assign
id|desc-&gt;stat_desc-&gt;static_tree
suffix:semicolon
r_int
id|elems
op_assign
id|desc-&gt;stat_desc-&gt;elems
suffix:semicolon
r_int
id|n
comma
id|m
suffix:semicolon
multiline_comment|/* iterate over heap elements */
r_int
id|max_code
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* largest code with non zero frequency */
r_int
id|node
suffix:semicolon
multiline_comment|/* new node being created */
multiline_comment|/* Construct the initial heap, with least frequent element in&n;     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].&n;     * heap[0] is not used.&n;     */
id|s-&gt;heap_len
op_assign
l_int|0
comma
id|s-&gt;heap_max
op_assign
id|HEAP_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|elems
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tree
(braket
id|n
)braket
dot
id|Freq
op_ne
l_int|0
)paren
(brace
id|s-&gt;heap
(braket
op_increment
(paren
id|s-&gt;heap_len
)paren
)braket
op_assign
id|max_code
op_assign
id|n
suffix:semicolon
id|s-&gt;depth
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tree
(braket
id|n
)braket
dot
id|Len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* The pkzip format requires that at least one distance code exists,&n;     * and that at least one bit should be sent even if there is only one&n;     * possible code. So to avoid special checks later on we force at least&n;     * two codes of non zero frequency.&n;     */
r_while
c_loop
(paren
id|s-&gt;heap_len
OL
l_int|2
)paren
(brace
id|node
op_assign
id|s-&gt;heap
(braket
op_increment
(paren
id|s-&gt;heap_len
)paren
)braket
op_assign
(paren
id|max_code
OL
l_int|2
ques
c_cond
op_increment
id|max_code
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tree
(braket
id|node
)braket
dot
id|Freq
op_assign
l_int|1
suffix:semicolon
id|s-&gt;depth
(braket
id|node
)braket
op_assign
l_int|0
suffix:semicolon
id|s-&gt;opt_len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|stree
)paren
id|s-&gt;static_len
op_sub_assign
id|stree
(braket
id|node
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* node is 0 or 1 so it does not have extra bits */
)brace
id|desc-&gt;max_code
op_assign
id|max_code
suffix:semicolon
multiline_comment|/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,&n;     * establish sub-heaps of increasing lengths:&n;     */
r_for
c_loop
(paren
id|n
op_assign
id|s-&gt;heap_len
op_div
l_int|2
suffix:semicolon
id|n
op_ge
l_int|1
suffix:semicolon
id|n
op_decrement
)paren
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* Construct the Huffman tree by repeatedly combining the least two&n;     * frequent nodes.&n;     */
id|node
op_assign
id|elems
suffix:semicolon
multiline_comment|/* next internal node of the tree */
r_do
(brace
id|pqremove
c_func
(paren
id|s
comma
id|tree
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* n = node of least frequency */
id|m
op_assign
id|s-&gt;heap
(braket
id|SMALLEST
)braket
suffix:semicolon
multiline_comment|/* m = node of next least frequency */
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|n
suffix:semicolon
multiline_comment|/* keep the nodes sorted by frequency */
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|m
suffix:semicolon
multiline_comment|/* Create a new node father of n and m */
id|tree
(braket
id|node
)braket
dot
id|Freq
op_assign
id|tree
(braket
id|n
)braket
dot
id|Freq
op_plus
id|tree
(braket
id|m
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;depth
(braket
id|node
)braket
op_assign
(paren
id|uch
)paren
(paren
id|MAX
c_func
(paren
id|s-&gt;depth
(braket
id|n
)braket
comma
id|s-&gt;depth
(braket
id|m
)braket
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|tree
(braket
id|n
)braket
dot
id|Dad
op_assign
id|tree
(braket
id|m
)braket
dot
id|Dad
op_assign
(paren
id|ush
)paren
id|node
suffix:semicolon
macro_line|#ifdef DUMP_BL_TREE
r_if
c_cond
(paren
id|tree
op_eq
id|s-&gt;bl_tree
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;nnode %d(%d), sons %d(%d) %d(%d)&quot;
comma
id|node
comma
id|tree
(braket
id|node
)braket
dot
id|Freq
comma
id|n
comma
id|tree
(braket
id|n
)braket
dot
id|Freq
comma
id|m
comma
id|tree
(braket
id|m
)braket
dot
id|Freq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* and insert the new node in the heap */
id|s-&gt;heap
(braket
id|SMALLEST
)braket
op_assign
id|node
op_increment
suffix:semicolon
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|SMALLEST
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|s-&gt;heap_len
op_ge
l_int|2
)paren
suffix:semicolon
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|s-&gt;heap
(braket
id|SMALLEST
)braket
suffix:semicolon
multiline_comment|/* At this point, the fields freq and dad are set. We can now&n;     * generate the bit lengths.&n;     */
id|gen_bitlen
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
id|desc
)paren
suffix:semicolon
multiline_comment|/* The field len is now set, we can generate the bit codes */
id|gen_codes
(paren
(paren
id|ct_data
op_star
)paren
id|tree
comma
id|max_code
comma
id|s-&gt;bl_count
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Scan a literal or distance tree to determine the frequencies of the codes&n; * in the bit length tree.&n; */
DECL|function|scan_tree
id|local
r_void
id|scan_tree
(paren
id|s
comma
id|tree
comma
id|max_code
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to be scanned */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* and its largest code of non zero frequency */
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over all tree elements */
r_int
id|prevlen
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last emitted length */
r_int
id|curlen
suffix:semicolon
multiline_comment|/* length of current code */
r_int
id|nextlen
op_assign
id|tree
(braket
l_int|0
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* length of next code */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* repeat count of the current code */
r_int
id|max_count
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* max repeat count */
r_int
id|min_count
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* min repeat count */
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
id|tree
(braket
id|max_code
op_plus
l_int|1
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
l_int|0xffff
suffix:semicolon
multiline_comment|/* guard */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
id|curlen
op_assign
id|nextlen
suffix:semicolon
id|nextlen
op_assign
id|tree
(braket
id|n
op_plus
l_int|1
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
id|max_count
op_logical_and
id|curlen
op_eq
id|nextlen
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
id|min_count
)paren
(brace
id|s-&gt;bl_tree
(braket
id|curlen
)braket
dot
id|Freq
op_add_assign
id|count
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|curlen
op_ne
id|prevlen
)paren
id|s-&gt;bl_tree
(braket
id|curlen
)braket
dot
id|Freq
op_increment
suffix:semicolon
id|s-&gt;bl_tree
(braket
id|REP_3_6
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
op_le
l_int|10
)paren
(brace
id|s-&gt;bl_tree
(braket
id|REPZ_3_10
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;bl_tree
(braket
id|REPZ_11_138
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
id|prevlen
op_assign
id|curlen
suffix:semicolon
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
(brace
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_eq
id|nextlen
)paren
(brace
id|max_count
op_assign
l_int|6
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|max_count
op_assign
l_int|7
comma
id|min_count
op_assign
l_int|4
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Send a literal or distance tree in compressed form, using the codes in&n; * bl_tree.&n; */
DECL|function|send_tree
id|local
r_void
id|send_tree
(paren
id|s
comma
id|tree
comma
id|max_code
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to be scanned */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* and its largest code of non zero frequency */
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over all tree elements */
r_int
id|prevlen
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last emitted length */
r_int
id|curlen
suffix:semicolon
multiline_comment|/* length of current code */
r_int
id|nextlen
op_assign
id|tree
(braket
l_int|0
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* length of next code */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* repeat count of the current code */
r_int
id|max_count
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* max repeat count */
r_int
id|min_count
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* min repeat count */
multiline_comment|/* tree[max_code+1].Len = -1; */
multiline_comment|/* guard already set */
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
id|curlen
op_assign
id|nextlen
suffix:semicolon
id|nextlen
op_assign
id|tree
(braket
id|n
op_plus
l_int|1
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
id|max_count
op_logical_and
id|curlen
op_eq
id|nextlen
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
id|min_count
)paren
(brace
r_do
(brace
id|send_code
c_func
(paren
id|s
comma
id|curlen
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|curlen
op_ne
id|prevlen
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|curlen
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
id|Assert
c_func
(paren
id|count
op_ge
l_int|3
op_logical_and
id|count
op_le
l_int|6
comma
l_string|&quot; 3_6?&quot;
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|REP_3_6
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|3
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
op_le
l_int|10
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|REPZ_3_10
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|3
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|send_code
c_func
(paren
id|s
comma
id|REPZ_11_138
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|11
comma
l_int|7
)paren
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
id|prevlen
op_assign
id|curlen
suffix:semicolon
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
(brace
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_eq
id|nextlen
)paren
(brace
id|max_count
op_assign
l_int|6
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|max_count
op_assign
l_int|7
comma
id|min_count
op_assign
l_int|4
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Construct the Huffman tree for the bit lengths and return the index in&n; * bl_order of the last bit length code to send.&n; */
DECL|function|build_bl_tree
id|local
r_int
id|build_bl_tree
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|max_blindex
suffix:semicolon
multiline_comment|/* index of last bit length code of non zero freq */
multiline_comment|/* Determine the bit length frequencies for literal and distance trees */
id|scan_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
id|s-&gt;l_desc.max_code
)paren
suffix:semicolon
id|scan_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
comma
id|s-&gt;d_desc.max_code
)paren
suffix:semicolon
multiline_comment|/* Build the bit length tree: */
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;bl_desc
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* opt_len now includes the length of the tree representations, except&n;     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.&n;     */
multiline_comment|/* Determine the number of bit length codes to send. The pkzip format&n;     * requires that at least 4 bit length codes be sent. (appnote.txt says&n;     * 3 but the actual value used is 4.)&n;     */
r_for
c_loop
(paren
id|max_blindex
op_assign
id|BL_CODES
op_minus
l_int|1
suffix:semicolon
id|max_blindex
op_ge
l_int|3
suffix:semicolon
id|max_blindex
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;bl_tree
(braket
id|bl_order
(braket
id|max_blindex
)braket
)braket
dot
id|Len
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Update opt_len to include the bit length tree and counts */
id|s-&gt;opt_len
op_add_assign
l_int|3
op_star
(paren
id|max_blindex
op_plus
l_int|1
)paren
op_plus
l_int|5
op_plus
l_int|5
op_plus
l_int|4
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndyn trees: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
r_return
id|max_blindex
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send the header for a block using dynamic Huffman trees: the counts, the&n; * lengths of the bit length codes, the literal tree and the distance tree.&n; * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.&n; */
DECL|function|send_all_trees
id|local
r_void
id|send_all_trees
c_func
(paren
id|s
comma
id|lcodes
comma
id|dcodes
comma
id|blcodes
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|lcodes
comma
id|dcodes
comma
id|blcodes
suffix:semicolon
multiline_comment|/* number of codes for each tree */
(brace
r_int
id|rank
suffix:semicolon
multiline_comment|/* index in bl_order */
id|Assert
(paren
id|lcodes
op_ge
l_int|257
op_logical_and
id|dcodes
op_ge
l_int|1
op_logical_and
id|blcodes
op_ge
l_int|4
comma
l_string|&quot;not enough codes&quot;
)paren
suffix:semicolon
id|Assert
(paren
id|lcodes
op_le
id|L_CODES
op_logical_and
id|dcodes
op_le
id|D_CODES
op_logical_and
id|blcodes
op_le
id|BL_CODES
comma
l_string|&quot;too many codes&quot;
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl counts: &quot;
)paren
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|lcodes
op_minus
l_int|257
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* not +255 as stated in appnote.txt */
id|send_bits
c_func
(paren
id|s
comma
id|dcodes
op_minus
l_int|1
comma
l_int|5
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|blcodes
op_minus
l_int|4
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* not -3 as stated in appnote.txt */
r_for
c_loop
(paren
id|rank
op_assign
l_int|0
suffix:semicolon
id|rank
OL
id|blcodes
suffix:semicolon
id|rank
op_increment
)paren
(brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl code %2d &quot;
comma
id|bl_order
(braket
id|rank
)braket
)paren
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|s-&gt;bl_tree
(braket
id|bl_order
(braket
id|rank
)braket
)braket
dot
id|Len
comma
l_int|3
)paren
suffix:semicolon
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
id|send_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
id|lcodes
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* literal tree */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlit tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
id|send_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
comma
id|dcodes
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* distance tree */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndist tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send a stored block&n; */
DECL|function|zlib_tr_stored_block
r_void
id|zlib_tr_stored_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* input block */
id|ulg
id|stored_len
suffix:semicolon
multiline_comment|/* length of input block */
r_int
id|eof
suffix:semicolon
multiline_comment|/* true if this is the last block for a file */
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STORED_BLOCK
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* send block type */
id|s-&gt;compressed_len
op_assign
(paren
id|s-&gt;compressed_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_amp
(paren
id|ulg
)paren
op_complement
l_int|7L
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
(paren
id|stored_len
op_plus
l_int|4
)paren
op_lshift
l_int|3
suffix:semicolon
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
(paren
r_int
)paren
id|stored_len
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* with header */
)brace
multiline_comment|/* Send just the `stored block&squot; type code without any length bytes or data.&n; */
DECL|function|zlib_tr_stored_type_only
r_void
id|zlib_tr_stored_type_only
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STORED_BLOCK
op_lshift
l_int|1
)paren
comma
l_int|3
)paren
suffix:semicolon
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_assign
(paren
id|s-&gt;compressed_len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|7L
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send one empty static block to give enough lookahead for inflate.&n; * This takes 10 bits, of which 7 may remain in the bit buffer.&n; * The current inflate code requires 9 bits of lookahead. If the&n; * last two codes for the previous block (real code plus EOB) were coded&n; * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode&n; * the last real code. In this case we send two empty static blocks instead&n; * of one. (There are no problems if the previous block is stored or fixed.)&n; * To simplify the code, we assume the worst case of last real code encoded&n; * on one bit only.&n; */
DECL|function|zlib_tr_align
r_void
id|zlib_tr_align
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|send_bits
c_func
(paren
id|s
comma
id|STATIC_TREES
op_lshift
l_int|1
comma
l_int|3
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|static_ltree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|10L
suffix:semicolon
multiline_comment|/* 3 for block type, 7 for EOB */
id|bi_flush
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Of the 10 bits for the empty block, we have already sent&n;     * (10 - bi_valid) bits. The lookahead for the last real code (before&n;     * the EOB of the previous block) was thus at least one plus the length&n;     * of the EOB plus what we have just sent of the empty static block.&n;     */
r_if
c_cond
(paren
l_int|1
op_plus
id|s-&gt;last_eob_len
op_plus
l_int|10
op_minus
id|s-&gt;bi_valid
OL
l_int|9
)paren
(brace
id|send_bits
c_func
(paren
id|s
comma
id|STATIC_TREES
op_lshift
l_int|1
comma
l_int|3
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|static_ltree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|10L
suffix:semicolon
id|bi_flush
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|s-&gt;last_eob_len
op_assign
l_int|7
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Determine the best encoding for the current block: dynamic trees, static&n; * trees or store, and output the encoded block to the zip file. This function&n; * returns the total compressed length for the file so far.&n; */
DECL|function|zlib_tr_flush_block
id|ulg
id|zlib_tr_flush_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* input block, or NULL if too old */
id|ulg
id|stored_len
suffix:semicolon
multiline_comment|/* length of input block */
r_int
id|eof
suffix:semicolon
multiline_comment|/* true if this is the last block for a file */
(brace
id|ulg
id|opt_lenb
comma
id|static_lenb
suffix:semicolon
multiline_comment|/* opt_len and static_len in bytes */
r_int
id|max_blindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of last bit length code of non zero freq */
multiline_comment|/* Build the Huffman trees unless a stored block is forced */
r_if
c_cond
(paren
id|s-&gt;level
OG
l_int|0
)paren
(brace
multiline_comment|/* Check if the file is ascii or binary */
r_if
c_cond
(paren
id|s-&gt;data_type
op_eq
id|Z_UNKNOWN
)paren
id|set_data_type
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Construct the literal and distance trees */
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;l_desc
)paren
)paren
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlit data: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;d_desc
)paren
)paren
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndist data: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
multiline_comment|/* At this point, opt_len and static_len are the total bit lengths of&n;&t; * the compressed block data, excluding the tree representations.&n;&t; */
multiline_comment|/* Build the bit length tree for the above two trees, and get the index&n;&t; * in bl_order of the last bit length code to send.&n;&t; */
id|max_blindex
op_assign
id|build_bl_tree
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Determine the best encoding. Compute first the block length in bytes*/
id|opt_lenb
op_assign
(paren
id|s-&gt;opt_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|static_lenb
op_assign
(paren
id|s-&gt;static_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;
comma
id|opt_lenb
comma
id|s-&gt;opt_len
comma
id|static_lenb
comma
id|s-&gt;static_len
comma
id|stored_len
comma
id|s-&gt;last_lit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|static_lenb
op_le
id|opt_lenb
)paren
id|opt_lenb
op_assign
id|static_lenb
suffix:semicolon
)brace
r_else
(brace
id|Assert
c_func
(paren
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
comma
l_string|&quot;lost buf&quot;
)paren
suffix:semicolon
id|opt_lenb
op_assign
id|static_lenb
op_assign
id|stored_len
op_plus
l_int|5
suffix:semicolon
multiline_comment|/* force a stored block */
)brace
multiline_comment|/* If compression failed and this is the first and last block,&n;     * and if the .zip file can be seeked (to rewrite the local header),&n;     * the whole file is transformed into a stored file:&n;     */
macro_line|#ifdef STORED_FILE_OK
macro_line|#  ifdef FORCE_STORED_FILE
r_if
c_cond
(paren
id|eof
op_logical_and
id|s-&gt;compressed_len
op_eq
l_int|0L
)paren
(brace
multiline_comment|/* force stored file */
macro_line|#  else
r_if
c_cond
(paren
id|stored_len
op_le
id|opt_lenb
op_logical_and
id|eof
op_logical_and
id|s-&gt;compressed_len
op_eq
l_int|0L
op_logical_and
id|seekable
c_func
(paren
)paren
)paren
(brace
macro_line|#  endif
multiline_comment|/* Since LIT_BUFSIZE &lt;= 2*WSIZE, the input data must be there: */
r_if
c_cond
(paren
id|buf
op_eq
(paren
id|charf
op_star
)paren
l_int|0
)paren
id|error
(paren
l_string|&quot;block vanished&quot;
)paren
suffix:semicolon
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
(paren
r_int
)paren
id|stored_len
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* without header */
id|s-&gt;compressed_len
op_assign
id|stored_len
op_lshift
l_int|3
suffix:semicolon
id|s-&gt;method
op_assign
id|STORED
suffix:semicolon
)brace
r_else
macro_line|#endif /* STORED_FILE_OK */
macro_line|#ifdef FORCE_STORED
r_if
c_cond
(paren
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* force stored block */
macro_line|#else
r_if
c_cond
(paren
id|stored_len
op_plus
l_int|4
op_le
id|opt_lenb
op_logical_and
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* 4: two words for the lengths */
macro_line|#endif
multiline_comment|/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.&n;         * Otherwise we can&squot;t have processed more than WSIZE input bytes since&n;         * the last block flush, because compression would have been&n;         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to&n;         * transform a block into a stored block.&n;         */
id|zlib_tr_stored_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
suffix:semicolon
macro_line|#ifdef FORCE_STATIC
)brace
r_else
r_if
c_cond
(paren
id|static_lenb
op_ge
l_int|0
)paren
(brace
multiline_comment|/* force static trees */
macro_line|#else
)brace
r_else
r_if
c_cond
(paren
id|static_lenb
op_eq
id|opt_lenb
)paren
(brace
macro_line|#endif
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STATIC_TREES
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
id|compress_block
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|static_ltree
comma
(paren
id|ct_data
op_star
)paren
id|static_dtree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|3
op_plus
id|s-&gt;static_len
suffix:semicolon
)brace
r_else
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|DYN_TREES
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
id|send_all_trees
c_func
(paren
id|s
comma
id|s-&gt;l_desc.max_code
op_plus
l_int|1
comma
id|s-&gt;d_desc.max_code
op_plus
l_int|1
comma
id|max_blindex
op_plus
l_int|1
)paren
suffix:semicolon
id|compress_block
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|3
op_plus
id|s-&gt;opt_len
suffix:semicolon
)brace
id|Assert
(paren
id|s-&gt;compressed_len
op_eq
id|s-&gt;bits_sent
comma
l_string|&quot;bad compressed size&quot;
)paren
suffix:semicolon
id|init_block
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eof
)paren
(brace
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|7
suffix:semicolon
multiline_comment|/* align on byte boundary */
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ncomprlen %lu(%lu) &quot;
comma
id|s-&gt;compressed_len
op_rshift
l_int|3
comma
id|s-&gt;compressed_len
op_minus
l_int|7
op_star
id|eof
)paren
)paren
suffix:semicolon
r_return
id|s-&gt;compressed_len
op_rshift
l_int|3
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Save the match info and tally the frequency counts. Return true if&n; * the current block must be flushed.&n; */
DECL|function|zlib_tr_tally
r_int
id|zlib_tr_tally
(paren
id|s
comma
id|dist
comma
id|lc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance of matched string */
r_int
id|lc
suffix:semicolon
multiline_comment|/* match length-MIN_MATCH or unmatched char (if dist==0) */
(brace
id|s-&gt;d_buf
(braket
id|s-&gt;last_lit
)braket
op_assign
(paren
id|ush
)paren
id|dist
suffix:semicolon
id|s-&gt;l_buf
(braket
id|s-&gt;last_lit
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|lc
suffix:semicolon
r_if
c_cond
(paren
id|dist
op_eq
l_int|0
)paren
(brace
multiline_comment|/* lc is the unmatched char */
id|s-&gt;dyn_ltree
(braket
id|lc
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;matches
op_increment
suffix:semicolon
multiline_comment|/* Here, lc is the match length - MIN_MATCH */
id|dist
op_decrement
suffix:semicolon
multiline_comment|/* dist = match distance - 1 */
id|Assert
c_func
(paren
(paren
id|ush
)paren
id|dist
OL
(paren
id|ush
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
op_logical_and
(paren
id|ush
)paren
id|lc
op_le
(paren
id|ush
)paren
(paren
id|MAX_MATCH
op_minus
id|MIN_MATCH
)paren
op_logical_and
(paren
id|ush
)paren
id|d_code
c_func
(paren
id|dist
)paren
OL
(paren
id|ush
)paren
id|D_CODES
comma
l_string|&quot;zlib_tr_tally: bad match&quot;
)paren
suffix:semicolon
id|s-&gt;dyn_ltree
(braket
id|length_code
(braket
id|lc
)braket
op_plus
id|LITERALS
op_plus
l_int|1
)braket
dot
id|Freq
op_increment
suffix:semicolon
id|s-&gt;dyn_dtree
(braket
id|d_code
c_func
(paren
id|dist
)paren
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
multiline_comment|/* Try to guess if it is profitable to stop the current block here */
r_if
c_cond
(paren
(paren
id|s-&gt;last_lit
op_amp
l_int|0xfff
)paren
op_eq
l_int|0
op_logical_and
id|s-&gt;level
OG
l_int|2
)paren
(brace
multiline_comment|/* Compute an upper bound for the compressed length */
id|ulg
id|out_length
op_assign
(paren
id|ulg
)paren
id|s-&gt;last_lit
op_star
l_int|8L
suffix:semicolon
id|ulg
id|in_length
op_assign
(paren
id|ulg
)paren
(paren
(paren
r_int
)paren
id|s-&gt;strstart
op_minus
id|s-&gt;block_start
)paren
suffix:semicolon
r_int
id|dcode
suffix:semicolon
r_for
c_loop
(paren
id|dcode
op_assign
l_int|0
suffix:semicolon
id|dcode
OL
id|D_CODES
suffix:semicolon
id|dcode
op_increment
)paren
(brace
id|out_length
op_add_assign
(paren
id|ulg
)paren
id|s-&gt;dyn_dtree
(braket
id|dcode
)braket
dot
id|Freq
op_star
(paren
l_int|5L
op_plus
id|extra_dbits
(braket
id|dcode
)braket
)paren
suffix:semicolon
)brace
id|out_length
op_rshift_assign
l_int|3
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlast_lit %u, in %ld, out ~%ld(%ld%%) &quot;
comma
id|s-&gt;last_lit
comma
id|in_length
comma
id|out_length
comma
l_int|100L
op_minus
id|out_length
op_star
l_int|100L
op_div
id|in_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;matches
OL
id|s-&gt;last_lit
op_div
l_int|2
op_logical_and
id|out_length
OL
id|in_length
op_div
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|s-&gt;last_lit
op_eq
id|s-&gt;lit_bufsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* We avoid equality with lit_bufsize because of wraparound at 64K&n;     * on 16 bit machines and because stored blocks are restricted to&n;     * 64K-1 bytes.&n;     */
)brace
multiline_comment|/* ===========================================================================&n; * Send the block data compressed using the given Huffman trees&n; */
DECL|function|compress_block
id|local
r_void
id|compress_block
c_func
(paren
id|s
comma
id|ltree
comma
id|dtree
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|ltree
suffix:semicolon
multiline_comment|/* literal tree */
id|ct_data
op_star
id|dtree
suffix:semicolon
multiline_comment|/* distance tree */
(brace
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance of matched string */
r_int
id|lc
suffix:semicolon
multiline_comment|/* match length or unmatched char (if dist == 0) */
r_int
id|lx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* running index in l_buf */
r_int
id|code
suffix:semicolon
multiline_comment|/* the code to send */
r_int
id|extra
suffix:semicolon
multiline_comment|/* number of extra bits to send */
r_if
c_cond
(paren
id|s-&gt;last_lit
op_ne
l_int|0
)paren
r_do
(brace
id|dist
op_assign
id|s-&gt;d_buf
(braket
id|lx
)braket
suffix:semicolon
id|lc
op_assign
id|s-&gt;l_buf
(braket
id|lx
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dist
op_eq
l_int|0
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|lc
comma
id|ltree
)paren
suffix:semicolon
multiline_comment|/* send a literal byte */
id|Tracecv
c_func
(paren
id|isgraph
c_func
(paren
id|lc
)paren
comma
(paren
id|stderr
comma
l_string|&quot; &squot;%c&squot; &quot;
comma
id|lc
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Here, lc is the match length - MIN_MATCH */
id|code
op_assign
id|length_code
(braket
id|lc
)braket
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|code
op_plus
id|LITERALS
op_plus
l_int|1
comma
id|ltree
)paren
suffix:semicolon
multiline_comment|/* send the length code */
id|extra
op_assign
id|extra_lbits
(braket
id|code
)braket
suffix:semicolon
r_if
c_cond
(paren
id|extra
op_ne
l_int|0
)paren
(brace
id|lc
op_sub_assign
id|base_length
(braket
id|code
)braket
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|lc
comma
id|extra
)paren
suffix:semicolon
multiline_comment|/* send the extra length bits */
)brace
id|dist
op_decrement
suffix:semicolon
multiline_comment|/* dist is now the match distance - 1 */
id|code
op_assign
id|d_code
c_func
(paren
id|dist
)paren
suffix:semicolon
id|Assert
(paren
id|code
OL
id|D_CODES
comma
l_string|&quot;bad d_code&quot;
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|code
comma
id|dtree
)paren
suffix:semicolon
multiline_comment|/* send the distance code */
id|extra
op_assign
id|extra_dbits
(braket
id|code
)braket
suffix:semicolon
r_if
c_cond
(paren
id|extra
op_ne
l_int|0
)paren
(brace
id|dist
op_sub_assign
id|base_dist
(braket
id|code
)braket
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|dist
comma
id|extra
)paren
suffix:semicolon
multiline_comment|/* send the extra distance bits */
)brace
)brace
multiline_comment|/* literal or match pair ? */
multiline_comment|/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
id|Assert
c_func
(paren
id|s-&gt;pending
OL
id|s-&gt;lit_bufsize
op_plus
l_int|2
op_star
id|lx
comma
l_string|&quot;pendingBuf overflow&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lx
OL
id|s-&gt;last_lit
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|ltree
)paren
suffix:semicolon
id|s-&gt;last_eob_len
op_assign
id|ltree
(braket
id|END_BLOCK
)braket
dot
id|Len
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Set the data type to ASCII or BINARY, using a crude approximation:&n; * binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.&n; * IN assertion: the fields freq of dyn_ltree are set and the total of all&n; * frequencies does not exceed 64K (to fit in an int on 16 bit machines).&n; */
DECL|function|set_data_type
id|local
r_void
id|set_data_type
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|ascii_freq
op_assign
l_int|0
suffix:semicolon
r_int
id|bin_freq
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
l_int|7
)paren
id|bin_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
l_int|128
)paren
id|ascii_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
id|LITERALS
)paren
id|bin_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;data_type
op_assign
(paren
id|Byte
)paren
(paren
id|bin_freq
OG
(paren
id|ascii_freq
op_rshift
l_int|2
)paren
ques
c_cond
id|Z_BINARY
suffix:colon
id|Z_ASCII
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Copy a stored block, storing first the length and its&n; * one&squot;s complement if requested.&n; */
DECL|function|copy_block
id|local
r_void
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
id|len
comma
id|header
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* the input data */
r_int
id|len
suffix:semicolon
multiline_comment|/* its length */
r_int
id|header
suffix:semicolon
multiline_comment|/* true if block header must be written */
(brace
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* align on byte boundary */
id|s-&gt;last_eob_len
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* enough lookahead for inflate */
r_if
c_cond
(paren
id|header
)paren
(brace
id|put_short
c_func
(paren
id|s
comma
(paren
id|ush
)paren
id|len
)paren
suffix:semicolon
id|put_short
c_func
(paren
id|s
comma
(paren
id|ush
)paren
op_complement
id|len
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_add_assign
l_int|2
op_star
l_int|16
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_add_assign
(paren
id|ulg
)paren
id|len
op_lshift
l_int|3
suffix:semicolon
macro_line|#endif
multiline_comment|/* bundle up the put_byte(s, *buf++) calls */
id|memcpy
c_func
(paren
op_amp
id|s-&gt;pending_buf
(braket
id|s-&gt;pending
)braket
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|s-&gt;pending
op_add_assign
id|len
suffix:semicolon
)brace
eof
