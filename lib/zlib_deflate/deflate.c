multiline_comment|/* +++ deflate.c */
multiline_comment|/* deflate.c -- compress data using the deflation algorithm&n; * Copyright (C) 1995-1996 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/*&n; *  ALGORITHM&n; *&n; *      The &quot;deflation&quot; process depends on being able to identify portions&n; *      of the input text which are identical to earlier input (within a&n; *      sliding window trailing behind the input currently being processed).&n; *&n; *      The most straightforward technique turns out to be the fastest for&n; *      most input files: try all possible matches and select the longest.&n; *      The key feature of this algorithm is that insertions into the string&n; *      dictionary are very simple and thus fast, and deletions are avoided&n; *      completely. Insertions are performed at each input character, whereas&n; *      string matches are performed only when the previous match ends. So it&n; *      is preferable to spend more time in matches to allow very fast string&n; *      insertions and avoid deletions. The matching algorithm for small&n; *      strings is inspired from that of Rabin &amp; Karp. A brute force approach&n; *      is used to find longer strings when a small match has been found.&n; *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze&n; *      (by Leonid Broukhis).&n; *         A previous version of this file used a more sophisticated algorithm&n; *      (by Fiala and Greene) which is guaranteed to run in linear amortized&n; *      time, but has a larger average cost, uses more memory and is patented.&n; *      However the F&amp;G algorithm may be faster for some highly redundant&n; *      files if the parameter max_chain_length (described below) is too large.&n; *&n; *  ACKNOWLEDGEMENTS&n; *&n; *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and&n; *      I found it in &squot;freeze&squot; written by Leonid Broukhis.&n; *      Thanks to many people for bug reports and testing.&n; *&n; *  REFERENCES&n; *&n; *      Deutsch, L.P.,&quot;DEFLATE Compressed Data Format Specification&quot;.&n; *      Available in ftp://ds.internic.net/rfc/rfc1951.txt&n; *&n; *      A description of the Rabin and Karp algorithm is given in the book&n; *         &quot;Algorithms&quot; by R. Sedgewick, Addison-Wesley, p252.&n; *&n; *      Fiala,E.R., and Greene,D.H.&n; *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/zutil.h&gt;
macro_line|#include &quot;defutil.h&quot;
multiline_comment|/* ===========================================================================&n; *  Function prototypes.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|need_more
id|need_more
comma
multiline_comment|/* block not completed, need more input or more output */
DECL|enumerator|block_done
id|block_done
comma
multiline_comment|/* block flush performed */
DECL|enumerator|finish_started
id|finish_started
comma
multiline_comment|/* finish started, need only more output at next deflate */
DECL|enumerator|finish_done
id|finish_done
multiline_comment|/* finish done, accept no more input or output */
DECL|typedef|block_state
)brace
id|block_state
suffix:semicolon
DECL|typedef|compress_func
r_typedef
id|block_state
(paren
op_star
id|compress_func
)paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
suffix:semicolon
multiline_comment|/* Compression function. Returns the block state after the call. */
r_static
r_void
id|fill_window
(paren
id|deflate_state
op_star
id|s
)paren
suffix:semicolon
r_static
id|block_state
id|deflate_stored
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
suffix:semicolon
r_static
id|block_state
id|deflate_fast
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
suffix:semicolon
r_static
id|block_state
id|deflate_slow
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
suffix:semicolon
r_static
r_void
id|lm_init
(paren
id|deflate_state
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|putShortMSB
(paren
id|deflate_state
op_star
id|s
comma
id|uInt
id|b
)paren
suffix:semicolon
r_static
r_void
id|flush_pending
(paren
id|z_streamp
id|strm
)paren
suffix:semicolon
r_static
r_int
id|read_buf
(paren
id|z_streamp
id|strm
comma
id|Byte
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_static
id|uInt
id|longest_match
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|cur_match
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
r_static
r_void
id|check_match
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|start
comma
id|IPos
id|match
comma
r_int
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Local data&n; */
DECL|macro|NIL
mdefine_line|#define NIL 0
multiline_comment|/* Tail of hash chains */
macro_line|#ifndef TOO_FAR
DECL|macro|TOO_FAR
macro_line|#  define TOO_FAR 4096
macro_line|#endif
multiline_comment|/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
DECL|macro|MIN_LOOKAHEAD
mdefine_line|#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
multiline_comment|/* Minimum amount of lookahead, except at the end of the input file.&n; * See deflate.c for comments about the MIN_MATCH+1.&n; */
multiline_comment|/* Values for max_lazy_match, good_match and max_chain_length, depending on&n; * the desired pack level (0..9). The values given below have been tuned to&n; * exclude worst case performance for pathological files. Better values may be&n; * found for specific files.&n; */
DECL|struct|config_s
r_typedef
r_struct
id|config_s
(brace
DECL|member|good_length
id|ush
id|good_length
suffix:semicolon
multiline_comment|/* reduce lazy search above this match length */
DECL|member|max_lazy
id|ush
id|max_lazy
suffix:semicolon
multiline_comment|/* do not perform lazy search above this match length */
DECL|member|nice_length
id|ush
id|nice_length
suffix:semicolon
multiline_comment|/* quit search above this match length */
DECL|member|max_chain
id|ush
id|max_chain
suffix:semicolon
DECL|member|func
id|compress_func
id|func
suffix:semicolon
DECL|typedef|config
)brace
id|config
suffix:semicolon
DECL|variable|configuration_table
r_static
r_const
id|config
id|configuration_table
(braket
l_int|10
)braket
op_assign
(brace
multiline_comment|/*      good lazy nice chain */
multiline_comment|/* 0 */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|deflate_stored
)brace
comma
multiline_comment|/* store only */
multiline_comment|/* 1 */
(brace
l_int|4
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
id|deflate_fast
)brace
comma
multiline_comment|/* maximum speed, no lazy matches */
multiline_comment|/* 2 */
(brace
l_int|4
comma
l_int|5
comma
l_int|16
comma
l_int|8
comma
id|deflate_fast
)brace
comma
multiline_comment|/* 3 */
(brace
l_int|4
comma
l_int|6
comma
l_int|32
comma
l_int|32
comma
id|deflate_fast
)brace
comma
multiline_comment|/* 4 */
(brace
l_int|4
comma
l_int|4
comma
l_int|16
comma
l_int|16
comma
id|deflate_slow
)brace
comma
multiline_comment|/* lazy matches */
multiline_comment|/* 5 */
(brace
l_int|8
comma
l_int|16
comma
l_int|32
comma
l_int|32
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 6 */
(brace
l_int|8
comma
l_int|16
comma
l_int|128
comma
l_int|128
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 7 */
(brace
l_int|8
comma
l_int|32
comma
l_int|128
comma
l_int|256
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 8 */
(brace
l_int|32
comma
l_int|128
comma
l_int|258
comma
l_int|1024
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 9 */
(brace
l_int|32
comma
l_int|258
comma
l_int|258
comma
l_int|4096
comma
id|deflate_slow
)brace
)brace
suffix:semicolon
multiline_comment|/* maximum compression */
multiline_comment|/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4&n; * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different&n; * meaning.&n; */
DECL|macro|EQUAL
mdefine_line|#define EQUAL 0
multiline_comment|/* result of memcmp for equal strings */
multiline_comment|/* ===========================================================================&n; * Update a hash value with the given input byte&n; * IN  assertion: all calls to to UPDATE_HASH are made with consecutive&n; *    input characters, so that a running hash key can be computed from the&n; *    previous key instead of complete recalculation each time.&n; */
DECL|macro|UPDATE_HASH
mdefine_line|#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)
multiline_comment|/* ===========================================================================&n; * Insert string str in the dictionary and set match_head to the previous head&n; * of the hash chain (the most recent string with same hash key). Return&n; * the previous length of the hash chain.&n; * IN  assertion: all calls to to INSERT_STRING are made with consecutive&n; *    input characters and the first MIN_MATCH bytes of str are valid&n; *    (except for the last MIN_MATCH-1 bytes of the input file).&n; */
DECL|macro|INSERT_STRING
mdefine_line|#define INSERT_STRING(s, str, match_head) &bslash;&n;   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), &bslash;&n;    s-&gt;prev[(str) &amp; s-&gt;w_mask] = match_head = s-&gt;head[s-&gt;ins_h], &bslash;&n;    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
multiline_comment|/* ===========================================================================&n; * Initialize the hash table (avoiding 64K overflow for 16 bit systems).&n; * prev[] will be initialized on the fly.&n; */
DECL|macro|CLEAR_HASH
mdefine_line|#define CLEAR_HASH(s) &bslash;&n;    s-&gt;head[s-&gt;hash_size-1] = NIL; &bslash;&n;    memset((char *)s-&gt;head, 0, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateInit_
r_int
id|zlib_deflateInit_
c_func
(paren
id|z_streamp
id|strm
comma
r_int
id|level
comma
r_const
r_char
op_star
id|version
comma
r_int
id|stream_size
)paren
(brace
r_return
id|zlib_deflateInit2_
c_func
(paren
id|strm
comma
id|level
comma
id|Z_DEFLATED
comma
id|MAX_WBITS
comma
id|DEF_MEM_LEVEL
comma
id|Z_DEFAULT_STRATEGY
comma
id|version
comma
id|stream_size
)paren
suffix:semicolon
multiline_comment|/* To do: ignore strm-&gt;next_in if we use it as window */
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateInit2_
r_int
id|zlib_deflateInit2_
c_func
(paren
id|z_streamp
id|strm
comma
r_int
id|level
comma
r_int
id|method
comma
r_int
id|windowBits
comma
r_int
id|memLevel
comma
r_int
id|strategy
comma
r_const
r_char
op_star
id|version
comma
r_int
id|stream_size
)paren
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|noheader
op_assign
l_int|0
suffix:semicolon
r_static
r_char
op_star
id|my_version
op_assign
id|ZLIB_VERSION
suffix:semicolon
id|deflate_workspace
op_star
id|mem
suffix:semicolon
id|ush
op_star
id|overlay
suffix:semicolon
multiline_comment|/* We overlay pending_buf and d_buf+l_buf. This works since the average&n;     * output size for (length,distance) codes is &lt;= 24 bits.&n;     */
r_if
c_cond
(paren
id|version
op_eq
id|Z_NULL
op_logical_or
id|version
(braket
l_int|0
)braket
op_ne
id|my_version
(braket
l_int|0
)braket
op_logical_or
id|stream_size
op_ne
r_sizeof
(paren
id|z_stream
)paren
)paren
(brace
r_return
id|Z_VERSION_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|Z_DEFAULT_COMPRESSION
)paren
id|level
op_assign
l_int|6
suffix:semicolon
id|mem
op_assign
(paren
id|deflate_workspace
op_star
)paren
id|strm-&gt;workspace
suffix:semicolon
r_if
c_cond
(paren
id|windowBits
OL
l_int|0
)paren
(brace
multiline_comment|/* undocumented feature: suppress zlib header */
id|noheader
op_assign
l_int|1
suffix:semicolon
id|windowBits
op_assign
op_minus
id|windowBits
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memLevel
template_param
id|MAX_MEM_LEVEL
op_logical_or
id|method
op_ne
id|Z_DEFLATED
op_logical_or
id|windowBits
template_param
l_int|15
op_logical_or
id|level
template_param
l_int|9
op_logical_or
id|strategy
template_param
id|Z_HUFFMAN_ONLY
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
op_amp
(paren
id|mem-&gt;deflate_memory
)paren
suffix:semicolon
id|strm-&gt;state
op_assign
(paren
r_struct
id|internal_state
op_star
)paren
id|s
suffix:semicolon
id|s-&gt;strm
op_assign
id|strm
suffix:semicolon
id|s-&gt;noheader
op_assign
id|noheader
suffix:semicolon
id|s-&gt;w_bits
op_assign
id|windowBits
suffix:semicolon
id|s-&gt;w_size
op_assign
l_int|1
op_lshift
id|s-&gt;w_bits
suffix:semicolon
id|s-&gt;w_mask
op_assign
id|s-&gt;w_size
op_minus
l_int|1
suffix:semicolon
id|s-&gt;hash_bits
op_assign
id|memLevel
op_plus
l_int|7
suffix:semicolon
id|s-&gt;hash_size
op_assign
l_int|1
op_lshift
id|s-&gt;hash_bits
suffix:semicolon
id|s-&gt;hash_mask
op_assign
id|s-&gt;hash_size
op_minus
l_int|1
suffix:semicolon
id|s-&gt;hash_shift
op_assign
(paren
(paren
id|s-&gt;hash_bits
op_plus
id|MIN_MATCH
op_minus
l_int|1
)paren
op_div
id|MIN_MATCH
)paren
suffix:semicolon
id|s-&gt;window
op_assign
(paren
id|Byte
op_star
)paren
id|mem-&gt;window_memory
suffix:semicolon
id|s-&gt;prev
op_assign
(paren
id|Pos
op_star
)paren
id|mem-&gt;prev_memory
suffix:semicolon
id|s-&gt;head
op_assign
(paren
id|Pos
op_star
)paren
id|mem-&gt;head_memory
suffix:semicolon
id|s-&gt;lit_bufsize
op_assign
l_int|1
op_lshift
(paren
id|memLevel
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* 16K elements by default */
id|overlay
op_assign
(paren
id|ush
op_star
)paren
id|mem-&gt;overlay_memory
suffix:semicolon
id|s-&gt;pending_buf
op_assign
(paren
id|uch
op_star
)paren
id|overlay
suffix:semicolon
id|s-&gt;pending_buf_size
op_assign
(paren
id|ulg
)paren
id|s-&gt;lit_bufsize
op_star
(paren
r_sizeof
(paren
id|ush
)paren
op_plus
l_int|2L
)paren
suffix:semicolon
id|s-&gt;d_buf
op_assign
id|overlay
op_plus
id|s-&gt;lit_bufsize
op_div
r_sizeof
(paren
id|ush
)paren
suffix:semicolon
id|s-&gt;l_buf
op_assign
id|s-&gt;pending_buf
op_plus
(paren
l_int|1
op_plus
r_sizeof
(paren
id|ush
)paren
)paren
op_star
id|s-&gt;lit_bufsize
suffix:semicolon
id|s-&gt;level
op_assign
id|level
suffix:semicolon
id|s-&gt;strategy
op_assign
id|strategy
suffix:semicolon
id|s-&gt;method
op_assign
(paren
id|Byte
)paren
id|method
suffix:semicolon
r_return
id|zlib_deflateReset
c_func
(paren
id|strm
)paren
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateSetDictionary
r_int
id|zlib_deflateSetDictionary
c_func
(paren
id|z_streamp
id|strm
comma
r_const
id|Byte
op_star
id|dictionary
comma
id|uInt
id|dictLength
)paren
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
id|uInt
id|length
op_assign
id|dictLength
suffix:semicolon
id|uInt
id|n
suffix:semicolon
id|IPos
id|hash_head
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|dictionary
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;status
op_ne
id|INIT_STATE
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;adler
op_assign
id|zlib_adler32
c_func
(paren
id|strm-&gt;adler
comma
id|dictionary
comma
id|dictLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|MIN_MATCH
)paren
r_return
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|length
op_assign
id|MAX_DIST
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#ifndef USE_DICT_HEAD
id|dictionary
op_add_assign
id|dictLength
op_minus
id|length
suffix:semicolon
multiline_comment|/* use the tail of the dictionary */
macro_line|#endif
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|s-&gt;window
comma
id|dictionary
comma
id|length
)paren
suffix:semicolon
id|s-&gt;strstart
op_assign
id|length
suffix:semicolon
id|s-&gt;block_start
op_assign
(paren
r_int
)paren
id|length
suffix:semicolon
multiline_comment|/* Insert all strings in the hash table (except for the last two bytes).&n;     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next&n;     * call of fill_window.&n;     */
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
l_int|0
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|length
op_minus
id|MIN_MATCH
suffix:semicolon
id|n
op_increment
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|n
comma
id|hash_head
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hash_head
)paren
id|hash_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make compiler happy */
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateReset
r_int
id|zlib_deflateReset
c_func
(paren
id|z_streamp
id|strm
)paren
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;total_in
op_assign
id|strm-&gt;total_out
op_assign
l_int|0
suffix:semicolon
id|strm-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
id|strm-&gt;data_type
op_assign
id|Z_UNKNOWN
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
id|s-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|s-&gt;pending_out
op_assign
id|s-&gt;pending_buf
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;noheader
OL
l_int|0
)paren
(brace
id|s-&gt;noheader
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* was set to -1 by deflate(..., Z_FINISH); */
)brace
id|s-&gt;status
op_assign
id|s-&gt;noheader
ques
c_cond
id|BUSY_STATE
suffix:colon
id|INIT_STATE
suffix:semicolon
id|strm-&gt;adler
op_assign
l_int|1
suffix:semicolon
id|s-&gt;last_flush
op_assign
id|Z_NO_FLUSH
suffix:semicolon
id|zlib_tr_init
c_func
(paren
id|s
)paren
suffix:semicolon
id|lm_init
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateParams
r_int
id|zlib_deflateParams
c_func
(paren
id|z_streamp
id|strm
comma
r_int
id|level
comma
r_int
id|strategy
)paren
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
id|compress_func
id|func
suffix:semicolon
r_int
id|err
op_assign
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|Z_DEFAULT_COMPRESSION
)paren
(brace
id|level
op_assign
l_int|6
suffix:semicolon
)brace
r_if
c_cond
(paren
id|level
template_param
l_int|9
op_logical_or
id|strategy
template_param
id|Z_HUFFMAN_ONLY
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|func
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|func
suffix:semicolon
r_if
c_cond
(paren
id|func
op_ne
id|configuration_table
(braket
id|level
)braket
dot
id|func
op_logical_and
id|strm-&gt;total_in
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Flush the last buffer: */
id|err
op_assign
id|zlib_deflate
c_func
(paren
id|strm
comma
id|Z_PARTIAL_FLUSH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;level
op_ne
id|level
)paren
(brace
id|s-&gt;level
op_assign
id|level
suffix:semicolon
id|s-&gt;max_lazy_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|max_lazy
suffix:semicolon
id|s-&gt;good_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|good_length
suffix:semicolon
id|s-&gt;nice_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|nice_length
suffix:semicolon
id|s-&gt;max_chain_length
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|max_chain
suffix:semicolon
)brace
id|s-&gt;strategy
op_assign
id|strategy
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Put a short in the pending buffer. The 16-bit value is put in MSB order.&n; * IN assertion: the stream state is correct and there is enough room in&n; * pending_buf.&n; */
DECL|function|putShortMSB
r_static
r_void
id|putShortMSB
c_func
(paren
id|deflate_state
op_star
id|s
comma
id|uInt
id|b
)paren
(brace
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
(paren
id|b
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
(paren
id|b
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Flush as much pending output as possible. All deflate() output goes&n; * through this function so some applications may wish to modify it&n; * to avoid allocating a large strm-&gt;next_out buffer and copying into it.&n; * (See also read_buf()).&n; */
DECL|function|flush_pending
r_static
r_void
id|flush_pending
c_func
(paren
id|z_streamp
id|strm
)paren
(brace
id|deflate_state
op_star
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_int
id|len
op_assign
id|s-&gt;pending
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|strm-&gt;avail_out
)paren
id|len
op_assign
id|strm-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;next_out
op_ne
id|Z_NULL
)paren
(brace
id|memcpy
c_func
(paren
id|strm-&gt;next_out
comma
id|s-&gt;pending_out
comma
id|len
)paren
suffix:semicolon
id|strm-&gt;next_out
op_add_assign
id|len
suffix:semicolon
)brace
id|s-&gt;pending_out
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;total_out
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;avail_out
op_sub_assign
id|len
suffix:semicolon
id|s-&gt;pending
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;pending
op_eq
l_int|0
)paren
(brace
id|s-&gt;pending_out
op_assign
id|s-&gt;pending_buf
suffix:semicolon
)brace
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflate
r_int
id|zlib_deflate
c_func
(paren
id|z_streamp
id|strm
comma
r_int
id|flush
)paren
(brace
r_int
id|old_flush
suffix:semicolon
multiline_comment|/* value of flush param for previous deflate call */
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|flush
OG
id|Z_FINISH
op_logical_or
id|flush
OL
l_int|0
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|strm-&gt;next_in
op_eq
id|Z_NULL
op_logical_and
id|strm-&gt;avail_in
op_ne
l_int|0
)paren
op_logical_or
(paren
id|s-&gt;status
op_eq
id|FINISH_STATE
op_logical_and
id|flush
op_ne
id|Z_FINISH
)paren
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
r_return
id|Z_BUF_ERROR
suffix:semicolon
id|s-&gt;strm
op_assign
id|strm
suffix:semicolon
multiline_comment|/* just in case */
id|old_flush
op_assign
id|s-&gt;last_flush
suffix:semicolon
id|s-&gt;last_flush
op_assign
id|flush
suffix:semicolon
multiline_comment|/* Write the zlib header */
r_if
c_cond
(paren
id|s-&gt;status
op_eq
id|INIT_STATE
)paren
(brace
id|uInt
id|header
op_assign
(paren
id|Z_DEFLATED
op_plus
(paren
(paren
id|s-&gt;w_bits
op_minus
l_int|8
)paren
op_lshift
l_int|4
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|uInt
id|level_flags
op_assign
(paren
id|s-&gt;level
op_minus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|level_flags
OG
l_int|3
)paren
id|level_flags
op_assign
l_int|3
suffix:semicolon
id|header
op_or_assign
(paren
id|level_flags
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strstart
op_ne
l_int|0
)paren
id|header
op_or_assign
id|PRESET_DICT
suffix:semicolon
id|header
op_add_assign
l_int|31
op_minus
(paren
id|header
op_mod
l_int|31
)paren
suffix:semicolon
id|s-&gt;status
op_assign
id|BUSY_STATE
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
id|header
)paren
suffix:semicolon
multiline_comment|/* Save the adler32 of the preset dictionary: */
r_if
c_cond
(paren
id|s-&gt;strstart
op_ne
l_int|0
)paren
(brace
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
id|strm-&gt;adler
op_assign
l_int|1L
suffix:semicolon
)brace
multiline_comment|/* Flush as much pending output as possible */
r_if
c_cond
(paren
id|s-&gt;pending
op_ne
l_int|0
)paren
(brace
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Since avail_out is 0, deflate will be called again with&n;&t;     * more output space, but possibly with both pending and&n;&t;     * avail_in equal to zero. There won&squot;t be anything to do,&n;&t;     * but this is not an error situation so make sure we&n;&t;     * return OK instead of BUF_ERROR at next call of deflate:&n;             */
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Make sure there is something to do and avoid duplicate consecutive&n;     * flushes. For repeated and useless calls with Z_FINISH, we keep&n;     * returning Z_STREAM_END instead of Z_BUFF_ERROR.&n;     */
)brace
r_else
r_if
c_cond
(paren
id|strm-&gt;avail_in
op_eq
l_int|0
op_logical_and
id|flush
op_le
id|old_flush
op_logical_and
id|flush
op_ne
id|Z_FINISH
)paren
(brace
r_return
id|Z_BUF_ERROR
suffix:semicolon
)brace
multiline_comment|/* User must not provide more input after the first FINISH: */
r_if
c_cond
(paren
id|s-&gt;status
op_eq
id|FINISH_STATE
op_logical_and
id|strm-&gt;avail_in
op_ne
l_int|0
)paren
(brace
r_return
id|Z_BUF_ERROR
suffix:semicolon
)brace
multiline_comment|/* Start a new block or continue the current one.&n;     */
r_if
c_cond
(paren
id|strm-&gt;avail_in
op_ne
l_int|0
op_logical_or
id|s-&gt;lookahead
op_ne
l_int|0
op_logical_or
(paren
id|flush
op_ne
id|Z_NO_FLUSH
op_logical_and
id|s-&gt;status
op_ne
id|FINISH_STATE
)paren
)paren
(brace
id|block_state
id|bstate
suffix:semicolon
id|bstate
op_assign
(paren
op_star
(paren
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|func
)paren
)paren
(paren
id|s
comma
id|flush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bstate
op_eq
id|finish_started
op_logical_or
id|bstate
op_eq
id|finish_done
)paren
(brace
id|s-&gt;status
op_assign
id|FINISH_STATE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bstate
op_eq
id|need_more
op_logical_or
id|bstate
op_eq
id|finish_started
)paren
(brace
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid BUF_ERROR next call, see above */
)brace
r_return
id|Z_OK
suffix:semicolon
multiline_comment|/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call&n;&t;     * of deflate should use the same flush parameter to make sure&n;&t;     * that the flush is complete. So we don&squot;t have to output an&n;&t;     * empty block here, this will be done at next call. This also&n;&t;     * ensures that for a very small output buffer, we emit at most&n;&t;     * one empty block.&n;&t;     */
)brace
r_if
c_cond
(paren
id|bstate
op_eq
id|block_done
)paren
(brace
r_if
c_cond
(paren
id|flush
op_eq
id|Z_PARTIAL_FLUSH
)paren
(brace
id|zlib_tr_align
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flush
op_eq
id|Z_PACKET_FLUSH
)paren
(brace
multiline_comment|/* Output just the 3-bit `stored&squot; block type value,&n;&t;&t;   but not a zero length. */
id|zlib_tr_stored_type_only
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* FULL_FLUSH or SYNC_FLUSH */
id|zlib_tr_stored_block
c_func
(paren
id|s
comma
(paren
r_char
op_star
)paren
l_int|0
comma
l_int|0L
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* For a full flush, this empty block will be recognized&n;                 * as a special marker by inflate_sync().&n;                 */
r_if
c_cond
(paren
id|flush
op_eq
id|Z_FULL_FLUSH
)paren
(brace
id|CLEAR_HASH
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* forget history */
)brace
)brace
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid BUF_ERROR at next call, see above */
r_return
id|Z_OK
suffix:semicolon
)brace
)brace
)brace
id|Assert
c_func
(paren
id|strm-&gt;avail_out
OG
l_int|0
comma
l_string|&quot;bug2&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
op_ne
id|Z_FINISH
)paren
r_return
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;noheader
)paren
r_return
id|Z_STREAM_END
suffix:semicolon
multiline_comment|/* Write the zlib trailer (adler32) */
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
multiline_comment|/* If avail_out is zero, the application will call deflate again&n;     * to flush the rest.&n;     */
id|s-&gt;noheader
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* write the trailer only once! */
r_return
id|s-&gt;pending
op_ne
l_int|0
ques
c_cond
id|Z_OK
suffix:colon
id|Z_STREAM_END
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|zlib_deflateEnd
r_int
id|zlib_deflateEnd
c_func
(paren
id|z_streamp
id|strm
)paren
(brace
r_int
id|status
suffix:semicolon
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
id|status
op_assign
id|s-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|INIT_STATE
op_logical_and
id|status
op_ne
id|BUSY_STATE
op_logical_and
id|status
op_ne
id|FINISH_STATE
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|strm-&gt;state
op_assign
id|Z_NULL
suffix:semicolon
r_return
id|status
op_eq
id|BUSY_STATE
ques
c_cond
id|Z_DATA_ERROR
suffix:colon
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Copy the source state to the destination state.&n; */
DECL|function|zlib_deflateCopy
r_int
id|zlib_deflateCopy
(paren
id|z_streamp
id|dest
comma
id|z_streamp
id|source
)paren
(brace
macro_line|#ifdef MAXSEG_64K
r_return
id|Z_STREAM_ERROR
suffix:semicolon
macro_line|#else
id|deflate_state
op_star
id|ds
suffix:semicolon
id|deflate_state
op_star
id|ss
suffix:semicolon
id|ush
op_star
id|overlay
suffix:semicolon
id|deflate_workspace
op_star
id|mem
suffix:semicolon
r_if
c_cond
(paren
id|source
op_eq
id|Z_NULL
op_logical_or
id|dest
op_eq
id|Z_NULL
op_logical_or
id|source-&gt;state
op_eq
id|Z_NULL
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|ss
op_assign
(paren
id|deflate_state
op_star
)paren
id|source-&gt;state
suffix:semicolon
op_star
id|dest
op_assign
op_star
id|source
suffix:semicolon
id|mem
op_assign
(paren
id|deflate_workspace
op_star
)paren
id|dest-&gt;workspace
suffix:semicolon
id|ds
op_assign
op_amp
(paren
id|mem-&gt;deflate_memory
)paren
suffix:semicolon
id|dest-&gt;state
op_assign
(paren
r_struct
id|internal_state
op_star
)paren
id|ds
suffix:semicolon
op_star
id|ds
op_assign
op_star
id|ss
suffix:semicolon
id|ds-&gt;strm
op_assign
id|dest
suffix:semicolon
id|ds-&gt;window
op_assign
(paren
id|Byte
op_star
)paren
id|mem-&gt;window_memory
suffix:semicolon
id|ds-&gt;prev
op_assign
(paren
id|Pos
op_star
)paren
id|mem-&gt;prev_memory
suffix:semicolon
id|ds-&gt;head
op_assign
(paren
id|Pos
op_star
)paren
id|mem-&gt;head_memory
suffix:semicolon
id|overlay
op_assign
(paren
id|ush
op_star
)paren
id|mem-&gt;overlay_memory
suffix:semicolon
id|ds-&gt;pending_buf
op_assign
(paren
id|uch
op_star
)paren
id|overlay
suffix:semicolon
id|memcpy
c_func
(paren
id|ds-&gt;window
comma
id|ss-&gt;window
comma
id|ds-&gt;w_size
op_star
l_int|2
op_star
r_sizeof
(paren
id|Byte
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ds-&gt;prev
comma
id|ss-&gt;prev
comma
id|ds-&gt;w_size
op_star
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ds-&gt;head
comma
id|ss-&gt;head
comma
id|ds-&gt;hash_size
op_star
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ds-&gt;pending_buf
comma
id|ss-&gt;pending_buf
comma
(paren
id|uInt
)paren
id|ds-&gt;pending_buf_size
)paren
suffix:semicolon
id|ds-&gt;pending_out
op_assign
id|ds-&gt;pending_buf
op_plus
(paren
id|ss-&gt;pending_out
op_minus
id|ss-&gt;pending_buf
)paren
suffix:semicolon
id|ds-&gt;d_buf
op_assign
id|overlay
op_plus
id|ds-&gt;lit_bufsize
op_div
r_sizeof
(paren
id|ush
)paren
suffix:semicolon
id|ds-&gt;l_buf
op_assign
id|ds-&gt;pending_buf
op_plus
(paren
l_int|1
op_plus
r_sizeof
(paren
id|ush
)paren
)paren
op_star
id|ds-&gt;lit_bufsize
suffix:semicolon
id|ds-&gt;l_desc.dyn_tree
op_assign
id|ds-&gt;dyn_ltree
suffix:semicolon
id|ds-&gt;d_desc.dyn_tree
op_assign
id|ds-&gt;dyn_dtree
suffix:semicolon
id|ds-&gt;bl_desc.dyn_tree
op_assign
id|ds-&gt;bl_tree
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ===========================================================================&n; * Read a new buffer from the current input stream, update the adler32&n; * and total number of bytes read.  All deflate() input goes through&n; * this function so some applications may wish to modify it to avoid&n; * allocating a large strm-&gt;next_in buffer and copying from it.&n; * (See also flush_pending()).&n; */
DECL|function|read_buf
r_static
r_int
id|read_buf
c_func
(paren
id|z_streamp
id|strm
comma
id|Byte
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|len
op_assign
id|strm-&gt;avail_in
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|size
)paren
id|len
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|strm-&gt;avail_in
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|deflate_state
op_star
)paren
(paren
id|strm-&gt;state
)paren
)paren
op_member_access_from_pointer
id|noheader
)paren
(brace
id|strm-&gt;adler
op_assign
id|zlib_adler32
c_func
(paren
id|strm-&gt;adler
comma
id|strm-&gt;next_in
comma
id|len
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|strm-&gt;next_in
comma
id|len
)paren
suffix:semicolon
id|strm-&gt;next_in
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;total_in
op_add_assign
id|len
suffix:semicolon
r_return
(paren
r_int
)paren
id|len
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize the &quot;longest match&quot; routines for a new zlib stream&n; */
DECL|function|lm_init
r_static
r_void
id|lm_init
c_func
(paren
id|deflate_state
op_star
id|s
)paren
(brace
id|s-&gt;window_size
op_assign
(paren
id|ulg
)paren
l_int|2L
op_star
id|s-&gt;w_size
suffix:semicolon
id|CLEAR_HASH
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Set the default configuration parameters:&n;     */
id|s-&gt;max_lazy_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|max_lazy
suffix:semicolon
id|s-&gt;good_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|good_length
suffix:semicolon
id|s-&gt;nice_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|nice_length
suffix:semicolon
id|s-&gt;max_chain_length
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|max_chain
suffix:semicolon
id|s-&gt;strstart
op_assign
l_int|0
suffix:semicolon
id|s-&gt;block_start
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;lookahead
op_assign
l_int|0
suffix:semicolon
id|s-&gt;match_length
op_assign
id|s-&gt;prev_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ins_h
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Set match_start to the longest match starting at the given string and&n; * return its length. Matches shorter or equal to prev_length are discarded,&n; * in which case the result is equal to prev_length and match_start is&n; * garbage.&n; * IN assertions: cur_match is the head of the hash chain for the current&n; *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1&n; * OUT assertion: the match length is not greater than s-&gt;lookahead.&n; */
multiline_comment|/* For 80x86 and 680x0, an optimized version will be provided in match.asm or&n; * match.S. The code will be functionally equivalent.&n; */
DECL|function|longest_match
r_static
id|uInt
id|longest_match
c_func
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|cur_match
multiline_comment|/* current match */
)paren
(brace
r_int
id|chain_length
op_assign
id|s-&gt;max_chain_length
suffix:semicolon
multiline_comment|/* max hash chain length */
r_register
id|Byte
op_star
id|scan
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
suffix:semicolon
multiline_comment|/* current string */
r_register
id|Byte
op_star
id|match
suffix:semicolon
multiline_comment|/* matched string */
r_register
r_int
id|len
suffix:semicolon
multiline_comment|/* length of current match */
r_int
id|best_len
op_assign
id|s-&gt;prev_length
suffix:semicolon
multiline_comment|/* best match length so far */
r_int
id|nice_match
op_assign
id|s-&gt;nice_match
suffix:semicolon
multiline_comment|/* stop if match long enough */
id|IPos
id|limit
op_assign
id|s-&gt;strstart
OG
(paren
id|IPos
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
ques
c_cond
id|s-&gt;strstart
op_minus
(paren
id|IPos
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
suffix:colon
id|NIL
suffix:semicolon
multiline_comment|/* Stop when cur_match becomes &lt;= limit. To simplify the code,&n;     * we prevent matches with the string of window index 0.&n;     */
id|Pos
op_star
id|prev
op_assign
id|s-&gt;prev
suffix:semicolon
id|uInt
id|wmask
op_assign
id|s-&gt;w_mask
suffix:semicolon
macro_line|#ifdef UNALIGNED_OK
multiline_comment|/* Compare two bytes at a time. Note: this is not always beneficial.&n;     * Try with and without -DUNALIGNED_OK to check.&n;     */
r_register
id|Byte
op_star
id|strend
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|MAX_MATCH
op_minus
l_int|1
suffix:semicolon
r_register
id|ush
id|scan_start
op_assign
op_star
(paren
id|ush
op_star
)paren
id|scan
suffix:semicolon
r_register
id|ush
id|scan_end
op_assign
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_plus
id|best_len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_register
id|Byte
op_star
id|strend
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|MAX_MATCH
suffix:semicolon
r_register
id|Byte
id|scan_end1
op_assign
id|scan
(braket
id|best_len
op_minus
l_int|1
)braket
suffix:semicolon
r_register
id|Byte
id|scan_end
op_assign
id|scan
(braket
id|best_len
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.&n;     * It is easy to get rid of this optimization if necessary.&n;     */
id|Assert
c_func
(paren
id|s-&gt;hash_bits
op_ge
l_int|8
op_logical_and
id|MAX_MATCH
op_eq
l_int|258
comma
l_string|&quot;Code too clever&quot;
)paren
suffix:semicolon
multiline_comment|/* Do not waste too much time if we already have a good match: */
r_if
c_cond
(paren
id|s-&gt;prev_length
op_ge
id|s-&gt;good_match
)paren
(brace
id|chain_length
op_rshift_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Do not look for matches beyond the end of the input. This is necessary&n;     * to make deflate deterministic.&n;     */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|nice_match
OG
id|s-&gt;lookahead
)paren
id|nice_match
op_assign
id|s-&gt;lookahead
suffix:semicolon
id|Assert
c_func
(paren
(paren
id|ulg
)paren
id|s-&gt;strstart
op_le
id|s-&gt;window_size
op_minus
id|MIN_LOOKAHEAD
comma
l_string|&quot;need lookahead&quot;
)paren
suffix:semicolon
r_do
(brace
id|Assert
c_func
(paren
id|cur_match
OL
id|s-&gt;strstart
comma
l_string|&quot;no future&quot;
)paren
suffix:semicolon
id|match
op_assign
id|s-&gt;window
op_plus
id|cur_match
suffix:semicolon
multiline_comment|/* Skip to next match if the match length cannot increase&n;         * or if the match length is less than 2:&n;         */
macro_line|#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)
multiline_comment|/* This code assumes sizeof(unsigned short) == 2. Do not use&n;         * UNALIGNED_OK if your compiler uses a different size.&n;         */
r_if
c_cond
(paren
op_star
(paren
id|ush
op_star
)paren
(paren
id|match
op_plus
id|best_len
op_minus
l_int|1
)paren
op_ne
id|scan_end
op_logical_or
op_star
(paren
id|ush
op_star
)paren
id|match
op_ne
id|scan_start
)paren
r_continue
suffix:semicolon
multiline_comment|/* It is not necessary to compare scan[2] and match[2] since they are&n;         * always equal when the other bytes match, given that the hash keys&n;         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at&n;         * strstart+3, +5, ... up to strstart+257. We check for insufficient&n;         * lookahead only every 4th comparison; the 128th check will be made&n;         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is&n;         * necessary to put more guard bytes at the end of the window, or&n;         * to check more often for insufficient lookahead.&n;         */
id|Assert
c_func
(paren
id|scan
(braket
l_int|2
)braket
op_eq
id|match
(braket
l_int|2
)braket
comma
l_string|&quot;scan[2]?&quot;
)paren
suffix:semicolon
id|scan
op_increment
comma
id|match
op_increment
suffix:semicolon
r_do
(brace
)brace
r_while
c_loop
(paren
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ush
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ush
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ush
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ush
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
id|scan
OL
id|strend
)paren
suffix:semicolon
multiline_comment|/* The funny &quot;do {}&quot; generates better code on most compilers */
multiline_comment|/* Here, scan &lt;= window+strstart+257 */
id|Assert
c_func
(paren
id|scan
op_le
id|s-&gt;window
op_plus
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
l_int|1
)paren
comma
l_string|&quot;wild scan&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|scan
op_eq
op_star
id|match
)paren
id|scan
op_increment
suffix:semicolon
id|len
op_assign
(paren
id|MAX_MATCH
op_minus
l_int|1
)paren
op_minus
(paren
r_int
)paren
(paren
id|strend
op_minus
id|scan
)paren
suffix:semicolon
id|scan
op_assign
id|strend
op_minus
(paren
id|MAX_MATCH
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else /* UNALIGNED_OK */
r_if
c_cond
(paren
id|match
(braket
id|best_len
)braket
op_ne
id|scan_end
op_logical_or
id|match
(braket
id|best_len
op_minus
l_int|1
)braket
op_ne
id|scan_end1
op_logical_or
op_star
id|match
op_ne
op_star
id|scan
op_logical_or
op_star
op_increment
id|match
op_ne
id|scan
(braket
l_int|1
)braket
)paren
r_continue
suffix:semicolon
multiline_comment|/* The check at best_len-1 can be removed because it will be made&n;         * again later. (This heuristic is not always a win.)&n;         * It is not necessary to compare scan[2] and match[2] since they&n;         * are always equal when the other bytes match, given that&n;         * the hash keys are equal and that HASH_BITS &gt;= 8.&n;         */
id|scan
op_add_assign
l_int|2
comma
id|match
op_increment
suffix:semicolon
id|Assert
c_func
(paren
op_star
id|scan
op_eq
op_star
id|match
comma
l_string|&quot;match[2]?&quot;
)paren
suffix:semicolon
multiline_comment|/* We check for insufficient lookahead only every 8th comparison;&n;         * the 256th check will be made at strstart+258.&n;         */
r_do
(brace
)brace
r_while
c_loop
(paren
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
id|scan
OL
id|strend
)paren
suffix:semicolon
id|Assert
c_func
(paren
id|scan
op_le
id|s-&gt;window
op_plus
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
l_int|1
)paren
comma
l_string|&quot;wild scan&quot;
)paren
suffix:semicolon
id|len
op_assign
id|MAX_MATCH
op_minus
(paren
r_int
)paren
(paren
id|strend
op_minus
id|scan
)paren
suffix:semicolon
id|scan
op_assign
id|strend
op_minus
id|MAX_MATCH
suffix:semicolon
macro_line|#endif /* UNALIGNED_OK */
r_if
c_cond
(paren
id|len
OG
id|best_len
)paren
(brace
id|s-&gt;match_start
op_assign
id|cur_match
suffix:semicolon
id|best_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|nice_match
)paren
r_break
suffix:semicolon
macro_line|#ifdef UNALIGNED_OK
id|scan_end
op_assign
op_star
(paren
id|ush
op_star
)paren
(paren
id|scan
op_plus
id|best_len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else
id|scan_end1
op_assign
id|scan
(braket
id|best_len
op_minus
l_int|1
)braket
suffix:semicolon
id|scan_end
op_assign
id|scan
(braket
id|best_len
)braket
suffix:semicolon
macro_line|#endif
)brace
)brace
r_while
c_loop
(paren
(paren
id|cur_match
op_assign
id|prev
(braket
id|cur_match
op_amp
id|wmask
)braket
)paren
OG
id|limit
op_logical_and
op_decrement
id|chain_length
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|best_len
op_le
id|s-&gt;lookahead
)paren
r_return
id|best_len
suffix:semicolon
r_return
id|s-&gt;lookahead
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ZLIB
multiline_comment|/* ===========================================================================&n; * Check that the match at match_start is indeed a match.&n; */
DECL|function|check_match
r_static
r_void
id|check_match
c_func
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|start
comma
id|IPos
id|match
comma
r_int
id|length
)paren
(brace
multiline_comment|/* check that the match is indeed a match */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|s-&gt;window
op_plus
id|match
comma
(paren
r_char
op_star
)paren
id|s-&gt;window
op_plus
id|start
comma
id|length
)paren
op_ne
id|EQUAL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; start %u, match %u, length %d&bslash;n&quot;
comma
id|start
comma
id|match
comma
id|length
)paren
suffix:semicolon
r_do
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%c%c&quot;
comma
id|s-&gt;window
(braket
id|match
op_increment
)braket
comma
id|s-&gt;window
(braket
id|start
op_increment
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
op_ne
l_int|0
)paren
suffix:semicolon
id|z_error
c_func
(paren
l_string|&quot;invalid match&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|z_verbose
OG
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;&bslash;[%d,%d]&quot;
comma
id|start
op_minus
id|match
comma
id|length
)paren
suffix:semicolon
r_do
(brace
id|putc
c_func
(paren
id|s-&gt;window
(braket
id|start
op_increment
)braket
comma
id|stderr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|check_match
macro_line|#  define check_match(s, start, match, length)
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Fill the window when the lookahead becomes insufficient.&n; * Updates strstart and lookahead.&n; *&n; * IN assertion: lookahead &lt; MIN_LOOKAHEAD&n; * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD&n; *    At least one byte has been read, or avail_in == 0; reads are&n; *    performed for at least two bytes (required for the zip translate_eol&n; *    option -- not supported here).&n; */
DECL|function|fill_window
r_static
r_void
id|fill_window
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_register
r_int
id|n
comma
id|m
suffix:semicolon
r_register
id|Pos
op_star
id|p
suffix:semicolon
r_int
id|more
suffix:semicolon
multiline_comment|/* Amount of free space at the end of the window. */
id|uInt
id|wsize
op_assign
id|s-&gt;w_size
suffix:semicolon
r_do
(brace
id|more
op_assign
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
(paren
id|ulg
)paren
id|s-&gt;lookahead
op_minus
(paren
id|ulg
)paren
id|s-&gt;strstart
)paren
suffix:semicolon
multiline_comment|/* Deal with !@#$% 64K limit: */
r_if
c_cond
(paren
id|more
op_eq
l_int|0
op_logical_and
id|s-&gt;strstart
op_eq
l_int|0
op_logical_and
id|s-&gt;lookahead
op_eq
l_int|0
)paren
(brace
id|more
op_assign
id|wsize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|more
op_eq
(paren
r_int
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Very unlikely, but possible on 16 bit machine if strstart == 0&n;             * and lookahead == 1 (input done one byte at time)&n;             */
id|more
op_decrement
suffix:semicolon
multiline_comment|/* If the window is almost full and there is insufficient lookahead,&n;         * move the upper half to the lower one to make room in the upper half.&n;         */
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;strstart
op_ge
id|wsize
op_plus
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|s-&gt;window
comma
(paren
r_char
op_star
)paren
id|s-&gt;window
op_plus
id|wsize
comma
(paren
r_int
)paren
id|wsize
)paren
suffix:semicolon
id|s-&gt;match_start
op_sub_assign
id|wsize
suffix:semicolon
id|s-&gt;strstart
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/* we now have strstart &gt;= MAX_DIST */
id|s-&gt;block_start
op_sub_assign
(paren
r_int
)paren
id|wsize
suffix:semicolon
multiline_comment|/* Slide the hash table (could be avoided with 32 bit values&n;               at the expense of memory usage). We slide even when level == 0&n;               to keep the hash table consistent if we switch back to level &gt; 0&n;               later. (Using level 0 permanently is not an optimal usage of&n;               zlib, so we don&squot;t care about this pathological case.)&n;             */
id|n
op_assign
id|s-&gt;hash_size
suffix:semicolon
id|p
op_assign
op_amp
id|s-&gt;head
(braket
id|n
)braket
suffix:semicolon
r_do
(brace
id|m
op_assign
op_star
op_decrement
id|p
suffix:semicolon
op_star
id|p
op_assign
(paren
id|Pos
)paren
(paren
id|m
op_ge
id|wsize
ques
c_cond
id|m
op_minus
id|wsize
suffix:colon
id|NIL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
suffix:semicolon
id|n
op_assign
id|wsize
suffix:semicolon
id|p
op_assign
op_amp
id|s-&gt;prev
(braket
id|n
)braket
suffix:semicolon
r_do
(brace
id|m
op_assign
op_star
op_decrement
id|p
suffix:semicolon
op_star
id|p
op_assign
(paren
id|Pos
)paren
(paren
id|m
op_ge
id|wsize
ques
c_cond
id|m
op_minus
id|wsize
suffix:colon
id|NIL
)paren
suffix:semicolon
multiline_comment|/* If n is not on any hash chain, prev[n] is garbage but&n;                 * its value will never be used.&n;                 */
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
suffix:semicolon
id|more
op_add_assign
id|wsize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;strm-&gt;avail_in
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* If there was no sliding:&n;         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;&n;         *    more == window_size - lookahead - strstart&n;         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)&n;         * =&gt; more &gt;= window_size - 2*WSIZE + 2&n;         * In the BIG_MEM or MMAP case (not yet supported),&n;         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;&n;         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.&n;         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.&n;         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.&n;         */
id|Assert
c_func
(paren
id|more
op_ge
l_int|2
comma
l_string|&quot;more &lt; 2&quot;
)paren
suffix:semicolon
id|n
op_assign
id|read_buf
c_func
(paren
id|s-&gt;strm
comma
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|s-&gt;lookahead
comma
id|more
)paren
suffix:semicolon
id|s-&gt;lookahead
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Initialize the hash value now that we have some input: */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_plus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if MIN_MATCH != 3
id|Call
id|UPDATE_HASH
c_func
(paren
)paren
id|MIN_MATCH
op_minus
l_int|3
id|more
id|times
macro_line|#endif
)brace
multiline_comment|/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,&n;         * but this is not important since only literal bytes will be emitted.&n;         */
)brace
r_while
c_loop
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|s-&gt;strm-&gt;avail_in
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Flush the current block, with given end-of-file flag.&n; * IN assertion: strstart is set to the end of the current match.&n; */
DECL|macro|FLUSH_BLOCK_ONLY
mdefine_line|#define FLUSH_BLOCK_ONLY(s, eof) { &bslash;&n;   zlib_tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? &bslash;&n;                   (char *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : &bslash;&n;                   (char *)Z_NULL), &bslash;&n;&t;&t;(ulg)((long)s-&gt;strstart - s-&gt;block_start), &bslash;&n;&t;&t;(eof)); &bslash;&n;   s-&gt;block_start = s-&gt;strstart; &bslash;&n;   flush_pending(s-&gt;strm); &bslash;&n;   Tracev((stderr,&quot;[FLUSH]&quot;)); &bslash;&n;}
multiline_comment|/* Same but force premature exit if necessary. */
DECL|macro|FLUSH_BLOCK
mdefine_line|#define FLUSH_BLOCK(s, eof) { &bslash;&n;   FLUSH_BLOCK_ONLY(s, eof); &bslash;&n;   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; &bslash;&n;}
multiline_comment|/* ===========================================================================&n; * Copy without compression as much as possible from the input stream, return&n; * the current block state.&n; * This function does not insert new strings in the dictionary since&n; * uncompressible data is probably not useful. This function is used&n; * only for the level=0 compression option.&n; * NOTE: this function should be optimized to avoid extra copying from&n; * window to pending_buf.&n; */
DECL|function|deflate_stored
r_static
id|block_state
id|deflate_stored
c_func
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
(brace
multiline_comment|/* Stored blocks are limited to 0xffff bytes, pending_buf is limited&n;     * to pending_buf_size, and each stored block has a 5 byte header:&n;     */
id|ulg
id|max_block_size
op_assign
l_int|0xffff
suffix:semicolon
id|ulg
id|max_start
suffix:semicolon
r_if
c_cond
(paren
id|max_block_size
OG
id|s-&gt;pending_buf_size
op_minus
l_int|5
)paren
(brace
id|max_block_size
op_assign
id|s-&gt;pending_buf_size
op_minus
l_int|5
suffix:semicolon
)brace
multiline_comment|/* Copy as much as possible from input to output: */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Fill the window as much as possible: */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_le
l_int|1
)paren
(brace
id|Assert
c_func
(paren
id|s-&gt;strstart
OL
id|s-&gt;w_size
op_plus
id|MAX_DIST
c_func
(paren
id|s
)paren
op_logical_or
id|s-&gt;block_start
op_ge
(paren
r_int
)paren
id|s-&gt;w_size
comma
l_string|&quot;slide too late&quot;
)paren
suffix:semicolon
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
r_return
id|need_more
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
id|Assert
c_func
(paren
id|s-&gt;block_start
op_ge
l_int|0L
comma
l_string|&quot;block gone&quot;
)paren
suffix:semicolon
id|s-&gt;strstart
op_add_assign
id|s-&gt;lookahead
suffix:semicolon
id|s-&gt;lookahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Emit a stored block if pending_buf will be full: */
id|max_start
op_assign
id|s-&gt;block_start
op_plus
id|max_block_size
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strstart
op_eq
l_int|0
op_logical_or
(paren
id|ulg
)paren
id|s-&gt;strstart
op_ge
id|max_start
)paren
(brace
multiline_comment|/* strstart == 0 is possible when wraparound on 16-bit machine */
id|s-&gt;lookahead
op_assign
(paren
id|uInt
)paren
(paren
id|s-&gt;strstart
op_minus
id|max_start
)paren
suffix:semicolon
id|s-&gt;strstart
op_assign
(paren
id|uInt
)paren
id|max_start
suffix:semicolon
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush if we may have to slide, otherwise block_start may become&n;         * negative and the data will be gone:&n;         */
r_if
c_cond
(paren
id|s-&gt;strstart
op_minus
(paren
id|uInt
)paren
id|s-&gt;block_start
op_ge
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Compress as much as possible from the input stream, return the current&n; * block state.&n; * This function does not perform lazy evaluation of matches and inserts&n; * new strings in the dictionary only for unmatched strings or for short&n; * matches. It is used only for the fast compression options.&n; */
DECL|function|deflate_fast
r_static
id|block_state
id|deflate_fast
c_func
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
(brace
id|IPos
id|hash_head
op_assign
id|NIL
suffix:semicolon
multiline_comment|/* head of the hash chain */
r_int
id|bflush
suffix:semicolon
multiline_comment|/* set if current block must be flushed */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Make sure that we always have enough lookahead, except&n;         * at the end of the input file. We need MAX_MATCH bytes&n;         * for the next match, plus MIN_MATCH bytes to insert the&n;         * string following the next match.&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
)paren
(brace
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
(brace
r_return
id|need_more
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
multiline_comment|/* Insert the string window[strstart .. strstart+2] in the&n;         * dictionary, and set hash_head to the head of the hash chain:&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the longest match, discarding those &lt;= prev_length.&n;         * At this point we have always match_length &lt; MIN_MATCH&n;         */
r_if
c_cond
(paren
id|hash_head
op_ne
id|NIL
op_logical_and
id|s-&gt;strstart
op_minus
id|hash_head
op_le
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* To simplify the code, we prevent matches with the string&n;             * of window index 0 (in particular we have to avoid a match&n;             * of the string with itself at the start of the input file).&n;             */
r_if
c_cond
(paren
id|s-&gt;strategy
op_ne
id|Z_HUFFMAN_ONLY
)paren
(brace
id|s-&gt;match_length
op_assign
id|longest_match
(paren
id|s
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* longest_match() sets match_start */
)brace
r_if
c_cond
(paren
id|s-&gt;match_length
op_ge
id|MIN_MATCH
)paren
(brace
id|check_match
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|s-&gt;match_start
comma
id|s-&gt;match_length
)paren
suffix:semicolon
id|bflush
op_assign
id|zlib_tr_tally
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
id|s-&gt;match_start
comma
id|s-&gt;match_length
op_minus
id|MIN_MATCH
)paren
suffix:semicolon
id|s-&gt;lookahead
op_sub_assign
id|s-&gt;match_length
suffix:semicolon
multiline_comment|/* Insert new strings in the hash table only if the match length&n;             * is not too large. This saves time but degrades compression.&n;             */
r_if
c_cond
(paren
id|s-&gt;match_length
op_le
id|s-&gt;max_insert_length
op_logical_and
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|s-&gt;match_length
op_decrement
suffix:semicolon
multiline_comment|/* string at strstart already in hash table */
r_do
(brace
id|s-&gt;strstart
op_increment
suffix:semicolon
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
multiline_comment|/* strstart never exceeds WSIZE-MAX_MATCH, so there are&n;                     * always MIN_MATCH bytes ahead.&n;                     */
)brace
r_while
c_loop
(paren
op_decrement
id|s-&gt;match_length
op_ne
l_int|0
)paren
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;strstart
op_add_assign
id|s-&gt;match_length
suffix:semicolon
id|s-&gt;match_length
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_plus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if MIN_MATCH != 3
id|Call
id|UPDATE_HASH
c_func
(paren
)paren
id|MIN_MATCH
op_minus
l_int|3
id|more
id|times
macro_line|#endif
multiline_comment|/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not&n;                 * matter since it will be recomputed at next deflate call.&n;                 */
)brace
)brace
r_else
(brace
multiline_comment|/* No match, output a literal byte */
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
)paren
)paren
suffix:semicolon
id|bflush
op_assign
id|zlib_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
)paren
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bflush
)paren
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Same as above, but achieves better compression. We use a lazy&n; * evaluation for matches: a match is finally adopted only if there is&n; * no better match at the next window position.&n; */
DECL|function|deflate_slow
r_static
id|block_state
id|deflate_slow
c_func
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
(brace
id|IPos
id|hash_head
op_assign
id|NIL
suffix:semicolon
multiline_comment|/* head of hash chain */
r_int
id|bflush
suffix:semicolon
multiline_comment|/* set if current block must be flushed */
multiline_comment|/* Process the input block. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Make sure that we always have enough lookahead, except&n;         * at the end of the input file. We need MAX_MATCH bytes&n;         * for the next match, plus MIN_MATCH bytes to insert the&n;         * string following the next match.&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
)paren
(brace
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
(brace
r_return
id|need_more
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
multiline_comment|/* Insert the string window[strstart .. strstart+2] in the&n;         * dictionary, and set hash_head to the head of the hash chain:&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the longest match, discarding those &lt;= prev_length.&n;         */
id|s-&gt;prev_length
op_assign
id|s-&gt;match_length
comma
id|s-&gt;prev_match
op_assign
id|s-&gt;match_start
suffix:semicolon
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hash_head
op_ne
id|NIL
op_logical_and
id|s-&gt;prev_length
OL
id|s-&gt;max_lazy_match
op_logical_and
id|s-&gt;strstart
op_minus
id|hash_head
op_le
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* To simplify the code, we prevent matches with the string&n;             * of window index 0 (in particular we have to avoid a match&n;             * of the string with itself at the start of the input file).&n;             */
r_if
c_cond
(paren
id|s-&gt;strategy
op_ne
id|Z_HUFFMAN_ONLY
)paren
(brace
id|s-&gt;match_length
op_assign
id|longest_match
(paren
id|s
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* longest_match() sets match_start */
r_if
c_cond
(paren
id|s-&gt;match_length
op_le
l_int|5
op_logical_and
(paren
id|s-&gt;strategy
op_eq
id|Z_FILTERED
op_logical_or
(paren
id|s-&gt;match_length
op_eq
id|MIN_MATCH
op_logical_and
id|s-&gt;strstart
op_minus
id|s-&gt;match_start
OG
id|TOO_FAR
)paren
)paren
)paren
(brace
multiline_comment|/* If prev_match is also MIN_MATCH, match_start is garbage&n;                 * but we will ignore the current match anyway.&n;                 */
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* If there was a match at the previous step and the current&n;         * match is not better, output the previous match:&n;         */
r_if
c_cond
(paren
id|s-&gt;prev_length
op_ge
id|MIN_MATCH
op_logical_and
id|s-&gt;match_length
op_le
id|s-&gt;prev_length
)paren
(brace
id|uInt
id|max_insert
op_assign
id|s-&gt;strstart
op_plus
id|s-&gt;lookahead
op_minus
id|MIN_MATCH
suffix:semicolon
multiline_comment|/* Do not insert strings in hash table beyond this. */
id|check_match
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
l_int|1
comma
id|s-&gt;prev_match
comma
id|s-&gt;prev_length
)paren
suffix:semicolon
id|bflush
op_assign
id|zlib_tr_tally
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
l_int|1
op_minus
id|s-&gt;prev_match
comma
id|s-&gt;prev_length
op_minus
id|MIN_MATCH
)paren
suffix:semicolon
multiline_comment|/* Insert in hash table all strings up to the end of the match.&n;             * strstart-1 and strstart are already inserted. If there is not&n;             * enough lookahead, the last two strings are not inserted in&n;             * the hash table.&n;             */
id|s-&gt;lookahead
op_sub_assign
id|s-&gt;prev_length
op_minus
l_int|1
suffix:semicolon
id|s-&gt;prev_length
op_sub_assign
l_int|2
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_increment
id|s-&gt;strstart
op_le
id|max_insert
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|s-&gt;prev_length
op_ne
l_int|0
)paren
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bflush
)paren
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;match_available
)paren
(brace
multiline_comment|/* If there was no match at the previous position, output a&n;             * single literal. If there was a match but the current match&n;             * is longer, truncate the previous match to a single literal.&n;             */
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zlib_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
(brace
id|FLUSH_BLOCK_ONLY
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
id|s-&gt;strstart
op_increment
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strm-&gt;avail_out
op_eq
l_int|0
)paren
r_return
id|need_more
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is no previous match to compare with, wait for&n;             * the next step to decide.&n;             */
id|s-&gt;match_available
op_assign
l_int|1
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|flush
op_ne
id|Z_NO_FLUSH
comma
l_string|&quot;no flush?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;match_available
)paren
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|zlib_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
DECL|function|zlib_deflate_workspacesize
r_extern
r_int
id|zlib_deflate_workspacesize
(paren
)paren
(brace
r_return
r_sizeof
(paren
id|deflate_workspace
)paren
suffix:semicolon
)brace
eof
