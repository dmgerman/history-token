multiline_comment|/* &n; * lib/reed_solomon/decode_rs.c&n; *&n; * Overview:&n; *   Generic Reed Solomon encoder / decoder library&n; *   &n; * Copyright 2002, Phil Karn, KA9Q&n; * May be used under the terms of the GNU General Public License (GPL)&n; *&n; * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)&n; *&n; * $Id: decode_rs.c,v 1.6 2004/10/22 15:41:47 gleixner Exp $&n; *&n; */
multiline_comment|/* Generic data width independent code which is included by the &n; * wrappers.&n; */
(brace
r_int
id|deg_lambda
comma
id|el
comma
id|deg_omega
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|r
comma
id|k
comma
id|pad
suffix:semicolon
r_int
id|nn
op_assign
id|rs-&gt;nn
suffix:semicolon
r_int
id|nroots
op_assign
id|rs-&gt;nroots
suffix:semicolon
r_int
id|fcr
op_assign
id|rs-&gt;fcr
suffix:semicolon
r_int
id|prim
op_assign
id|rs-&gt;prim
suffix:semicolon
r_int
id|iprim
op_assign
id|rs-&gt;iprim
suffix:semicolon
r_uint16
op_star
id|alpha_to
op_assign
id|rs-&gt;alpha_to
suffix:semicolon
r_uint16
op_star
id|index_of
op_assign
id|rs-&gt;index_of
suffix:semicolon
r_uint16
id|u
comma
id|q
comma
id|tmp
comma
id|num1
comma
id|num2
comma
id|den
comma
id|discr_r
comma
id|syn_error
suffix:semicolon
multiline_comment|/* Err+Eras Locator poly and syndrome poly The maximum value&n;&t; * of nroots is 8. So the necessary stack size will be about&n;&t; * 220 bytes max.&n;&t; */
r_uint16
id|lambda
(braket
id|nroots
op_plus
l_int|1
)braket
comma
id|syn
(braket
id|nroots
)braket
suffix:semicolon
r_uint16
id|b
(braket
id|nroots
op_plus
l_int|1
)braket
comma
id|t
(braket
id|nroots
op_plus
l_int|1
)braket
comma
id|omega
(braket
id|nroots
op_plus
l_int|1
)braket
suffix:semicolon
r_uint16
id|root
(braket
id|nroots
)braket
comma
id|reg
(braket
id|nroots
op_plus
l_int|1
)braket
comma
id|loc
(braket
id|nroots
)braket
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_uint16
id|msk
op_assign
(paren
r_uint16
)paren
id|rs-&gt;nn
suffix:semicolon
multiline_comment|/* Check length parameter for validity */
id|pad
op_assign
id|nn
op_minus
id|nroots
op_minus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pad
OL
l_int|0
op_logical_or
id|pad
op_ge
id|nn
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
multiline_comment|/* Does the caller provide the syndrome ? */
r_if
c_cond
(paren
id|s
op_ne
l_int|NULL
)paren
r_goto
id|decode
suffix:semicolon
multiline_comment|/* form the syndromes; i.e., evaluate data(x) at roots of&n;&t; * g(x) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
)paren
id|syn
(braket
id|i
)braket
op_assign
(paren
(paren
(paren
r_uint16
)paren
id|data
(braket
l_int|0
)braket
)paren
op_xor
id|invmsk
)paren
op_amp
id|msk
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|syn
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|syn
(braket
id|i
)braket
op_assign
(paren
(paren
(paren
r_uint16
)paren
id|data
(braket
id|j
)braket
)paren
op_xor
id|invmsk
)paren
op_amp
id|msk
suffix:semicolon
)brace
r_else
(brace
id|syn
(braket
id|i
)braket
op_assign
(paren
(paren
(paren
(paren
r_uint16
)paren
id|data
(braket
id|j
)braket
)paren
op_xor
id|invmsk
)paren
op_amp
id|msk
)paren
op_xor
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|index_of
(braket
id|syn
(braket
id|i
)braket
)braket
op_plus
(paren
id|fcr
op_plus
id|i
)paren
op_star
id|prim
)paren
)braket
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nroots
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|syn
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|syn
(braket
id|i
)braket
op_assign
(paren
(paren
r_uint16
)paren
id|par
(braket
id|j
)braket
)paren
op_amp
id|msk
suffix:semicolon
)brace
r_else
(brace
id|syn
(braket
id|i
)braket
op_assign
(paren
(paren
(paren
r_uint16
)paren
id|par
(braket
id|j
)braket
)paren
op_amp
id|msk
)paren
op_xor
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|index_of
(braket
id|syn
(braket
id|i
)braket
)braket
op_plus
(paren
id|fcr
op_plus
id|i
)paren
op_star
id|prim
)paren
)braket
suffix:semicolon
)brace
)brace
)brace
id|s
op_assign
id|syn
suffix:semicolon
multiline_comment|/* Convert syndromes to index form, checking for nonzero condition */
id|syn_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
)paren
(brace
id|syn_error
op_or_assign
id|s
(braket
id|i
)braket
suffix:semicolon
id|s
(braket
id|i
)braket
op_assign
id|index_of
(braket
id|s
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|syn_error
)paren
(brace
multiline_comment|/* if syndrome is zero, data[] is a codeword and there are no&n;&t;&t; * errors to correct. So return data[] unmodified&n;&t;&t; */
id|count
op_assign
l_int|0
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
id|decode
suffix:colon
id|memset
c_func
(paren
op_amp
id|lambda
(braket
l_int|1
)braket
comma
l_int|0
comma
id|nroots
op_star
r_sizeof
(paren
id|lambda
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|lambda
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|no_eras
OG
l_int|0
)paren
(brace
multiline_comment|/* Init lambda to be the erasure locator polynomial */
id|lambda
(braket
l_int|1
)braket
op_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|prim
op_star
(paren
id|nn
op_minus
l_int|1
op_minus
id|eras_pos
(braket
l_int|0
)braket
)paren
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|no_eras
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u
op_assign
id|rs_modnn
c_func
(paren
id|rs
comma
id|prim
op_star
(paren
id|nn
op_minus
l_int|1
op_minus
id|eras_pos
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|tmp
op_assign
id|index_of
(braket
id|lambda
(braket
id|j
op_minus
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
id|nn
)paren
(brace
id|lambda
(braket
id|j
)braket
op_xor_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|u
op_plus
id|tmp
)paren
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|b
(braket
id|i
)braket
op_assign
id|index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Begin Berlekamp-Massey algorithm to determine error+erasure&n;&t; * locator polynomial&n;&t; */
id|r
op_assign
id|no_eras
suffix:semicolon
id|el
op_assign
id|no_eras
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|r
op_le
id|nroots
)paren
(brace
multiline_comment|/* r is the step number */
multiline_comment|/* Compute discrepancy at the r-th step in poly-form */
id|discr_r
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|r
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lambda
(braket
id|i
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|s
(braket
id|r
op_minus
id|i
op_minus
l_int|1
)braket
op_ne
id|nn
)paren
)paren
(brace
id|discr_r
op_xor_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
op_plus
id|s
(braket
id|r
op_minus
id|i
op_minus
l_int|1
)braket
)paren
)braket
suffix:semicolon
)brace
)brace
id|discr_r
op_assign
id|index_of
(braket
id|discr_r
)braket
suffix:semicolon
multiline_comment|/* Index form */
r_if
c_cond
(paren
id|discr_r
op_eq
id|nn
)paren
(brace
multiline_comment|/* 2 lines below: B(x) &lt;-- x*B(x) */
id|memmove
(paren
op_amp
id|b
(braket
l_int|1
)braket
comma
id|b
comma
id|nroots
op_star
r_sizeof
(paren
id|b
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
id|nn
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 7 lines below: T(x) &lt;-- lambda(x)-discr_r*x*b(x) */
id|t
(braket
l_int|0
)braket
op_assign
id|lambda
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|b
(braket
id|i
)braket
op_ne
id|nn
)paren
(brace
id|t
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_xor
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|discr_r
op_plus
id|b
(braket
id|i
)braket
)paren
)braket
suffix:semicolon
)brace
r_else
id|t
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|2
op_star
id|el
op_le
id|r
op_plus
id|no_eras
op_minus
l_int|1
)paren
(brace
id|el
op_assign
id|r
op_plus
id|no_eras
op_minus
id|el
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * 2 lines below: B(x) &lt;-- inv(discr_r) *&n;&t;&t;&t;&t; * lambda(x)&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|nroots
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
(braket
id|i
)braket
op_assign
(paren
id|lambda
(braket
id|i
)braket
op_eq
l_int|0
)paren
ques
c_cond
id|nn
suffix:colon
id|rs_modnn
c_func
(paren
id|rs
comma
id|index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
op_minus
id|discr_r
op_plus
id|nn
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 2 lines below: B(x) &lt;-- x*B(x) */
id|memmove
c_func
(paren
op_amp
id|b
(braket
l_int|1
)braket
comma
id|b
comma
id|nroots
op_star
r_sizeof
(paren
id|b
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
id|nn
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|lambda
comma
id|t
comma
(paren
id|nroots
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|t
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Convert lambda to index form and compute deg(lambda(x)) */
id|deg_lambda
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nroots
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lambda
(braket
id|i
)braket
op_assign
id|index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lambda
(braket
id|i
)braket
op_ne
id|nn
)paren
id|deg_lambda
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Find roots of error+erasure locator polynomial by Chien search */
id|memcpy
c_func
(paren
op_amp
id|reg
(braket
l_int|1
)braket
comma
op_amp
id|lambda
(braket
l_int|1
)braket
comma
id|nroots
op_star
r_sizeof
(paren
id|reg
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of roots of lambda(x) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|k
op_assign
id|iprim
op_minus
l_int|1
suffix:semicolon
id|i
op_le
id|nn
suffix:semicolon
id|i
op_increment
comma
id|k
op_assign
id|rs_modnn
c_func
(paren
id|rs
comma
id|k
op_plus
id|iprim
)paren
)paren
(brace
id|q
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* lambda[0] is always 0 */
r_for
c_loop
(paren
id|j
op_assign
id|deg_lambda
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|reg
(braket
id|j
)braket
op_ne
id|nn
)paren
(brace
id|reg
(braket
id|j
)braket
op_assign
id|rs_modnn
c_func
(paren
id|rs
comma
id|reg
(braket
id|j
)braket
op_plus
id|j
)paren
suffix:semicolon
id|q
op_xor_assign
id|alpha_to
(braket
id|reg
(braket
id|j
)braket
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|q
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Not a root */
multiline_comment|/* store root (index-form) and error location number */
id|root
(braket
id|count
)braket
op_assign
id|i
suffix:semicolon
id|loc
(braket
id|count
)braket
op_assign
id|k
suffix:semicolon
multiline_comment|/* If we&squot;ve already found max possible roots,&n;&t;&t; * abort the search to save time&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|deg_lambda
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|deg_lambda
op_ne
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * deg(lambda) unequal to number of roots =&gt; uncorrectable&n;&t;&t; * error detected&n;&t;&t; */
id|count
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo&n;&t; * x**nroots). in index form. Also find deg(omega).&n;&t; */
id|deg_omega
op_assign
id|deg_lambda
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|deg_omega
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|s
(braket
id|i
op_minus
id|j
)braket
op_ne
id|nn
)paren
op_logical_and
(paren
id|lambda
(braket
id|j
)braket
op_ne
id|nn
)paren
)paren
id|tmp
op_xor_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|s
(braket
id|i
op_minus
id|j
)braket
op_plus
id|lambda
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
id|omega
(braket
id|i
)braket
op_assign
id|index_of
(braket
id|tmp
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =&n;&t; * inv(X(l))**(fcr-1) and den = lambda_pr(inv(X(l))) all in poly-form&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
id|count
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|num1
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|deg_omega
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|omega
(braket
id|i
)braket
op_ne
id|nn
)paren
id|num1
op_xor_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|omega
(braket
id|i
)braket
op_plus
id|i
op_star
id|root
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
id|num2
op_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|root
(braket
id|j
)braket
op_star
(paren
id|fcr
op_minus
l_int|1
)paren
op_plus
id|nn
)paren
)braket
suffix:semicolon
id|den
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lambda[i+1] for i even is the formal derivative&n;&t;&t; * lambda_pr of lambda[i] */
r_for
c_loop
(paren
id|i
op_assign
id|min
c_func
(paren
id|deg_lambda
comma
id|nroots
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_sub_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_ne
id|nn
)paren
(brace
id|den
op_xor_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_plus
id|i
op_star
id|root
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* Apply error to data */
r_if
c_cond
(paren
id|num1
op_ne
l_int|0
op_logical_and
id|loc
(braket
id|j
)braket
op_ge
id|pad
)paren
(brace
r_uint16
id|cor
op_assign
id|alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|index_of
(braket
id|num1
)braket
op_plus
id|index_of
(braket
id|num2
)braket
op_plus
id|nn
op_minus
id|index_of
(braket
id|den
)braket
)paren
)braket
suffix:semicolon
multiline_comment|/* Store the error correction pattern, if a&n;&t;&t;&t; * correction buffer is available */
r_if
c_cond
(paren
id|corr
)paren
(brace
id|corr
(braket
id|j
)braket
op_assign
id|cor
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If a data buffer is given and the&n;&t;&t;&t;&t; * error is inside the message,&n;&t;&t;&t;&t; * correct it */
r_if
c_cond
(paren
id|data
op_logical_and
(paren
id|loc
(braket
id|j
)braket
OL
(paren
id|nn
op_minus
id|nroots
)paren
)paren
)paren
id|data
(braket
id|loc
(braket
id|j
)braket
op_minus
id|pad
)braket
op_xor_assign
id|cor
suffix:semicolon
)brace
)brace
)brace
id|finish
suffix:colon
r_if
c_cond
(paren
id|eras_pos
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|eras_pos
(braket
id|i
)braket
op_assign
id|loc
(braket
id|i
)braket
op_minus
id|pad
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
eof
