multiline_comment|/* &n; * lib/reed_solomon/rslib.c&n; *&n; * Overview:&n; *   Generic Reed Solomon encoder / decoder library&n; *   &n; * Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)&n; *&n; * Reed Solomon code lifted from reed solomon library written by Phil Karn&n; * Copyright 2002 Phil Karn, KA9Q&n; *&n; * $Id: rslib.c,v 1.5 2004/10/22 15:41:47 gleixner Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * Description:&n; *&t;&n; * The generic Reed Solomon library provides runtime configurable&n; * encoding / decoding of RS codes.&n; * Each user must call init_rs to get a pointer to a rs_control&n; * structure for the given rs parameters. This structure is either&n; * generated or a already available matching control structure is used.&n; * If a structure is generated then the polynomial arrays for&n; * fast encoding / decoding are built. This can take some time so&n; * make sure not to call this function from a time critical path.&n; * Usually a module / driver should initialize the necessary &n; * rs_control structure on module / driver init and release it&n; * on exit.&n; * The encoding puts the calculated syndrome into a given syndrome &n; * buffer. &n; * The decoding is a two step process. The first step calculates&n; * the syndrome over the received (data + syndrome) and calls the&n; * second stage, which does the decoding / error correction itself.&n; * Many hw encoders provide a syndrome calculation over the received&n; * data + syndrome and can call the second stage directly.&n; *&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/rslib.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/* This list holds all currently allocated rs control structures */
r_static
id|LIST_HEAD
(paren
id|rslist
)paren
suffix:semicolon
multiline_comment|/* Protection for the list */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|rslistlock
)paren
suffix:semicolon
multiline_comment|/** &n; * rs_init - Initialize a Reed-Solomon codec&n; *&n; * @symsize:&t;symbol size, bits (1-8)&n; * @gfpoly:&t;Field generator polynomial coefficients&n; * @fcr:&t;first root of RS code generator polynomial, index form&n; * @prim:&t;primitive element to generate polynomial roots&n; * @nroots:&t;RS code generator polynomial degree (number of roots)&n; *&n; * Allocate a control structure and the polynom arrays for faster&n; * en/decoding. Fill the arrays according to the given parameters&n; */
DECL|function|rs_init
r_static
r_struct
id|rs_control
op_star
id|rs_init
c_func
(paren
r_int
id|symsize
comma
r_int
id|gfpoly
comma
r_int
id|fcr
comma
r_int
id|prim
comma
r_int
id|nroots
)paren
(brace
r_struct
id|rs_control
op_star
id|rs
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|sr
comma
id|root
comma
id|iprim
suffix:semicolon
multiline_comment|/* Allocate the control structure */
id|rs
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rs_control
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rs-&gt;list
)paren
suffix:semicolon
id|rs-&gt;mm
op_assign
id|symsize
suffix:semicolon
id|rs-&gt;nn
op_assign
(paren
l_int|1
op_lshift
id|symsize
)paren
op_minus
l_int|1
suffix:semicolon
id|rs-&gt;fcr
op_assign
id|fcr
suffix:semicolon
id|rs-&gt;prim
op_assign
id|prim
suffix:semicolon
id|rs-&gt;nroots
op_assign
id|nroots
suffix:semicolon
id|rs-&gt;gfpoly
op_assign
id|gfpoly
suffix:semicolon
multiline_comment|/* Allocate the arrays */
id|rs-&gt;alpha_to
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_uint16
)paren
op_star
(paren
id|rs-&gt;nn
op_plus
l_int|1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;alpha_to
op_eq
l_int|NULL
)paren
r_goto
id|errrs
suffix:semicolon
id|rs-&gt;index_of
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_uint16
)paren
op_star
(paren
id|rs-&gt;nn
op_plus
l_int|1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;index_of
op_eq
l_int|NULL
)paren
r_goto
id|erralp
suffix:semicolon
id|rs-&gt;genpoly
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_uint16
)paren
op_star
(paren
id|rs-&gt;nroots
op_plus
l_int|1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;genpoly
op_eq
l_int|NULL
)paren
(brace
r_goto
id|erridx
suffix:semicolon
)brace
multiline_comment|/* Generate Galois field lookup tables */
id|rs-&gt;index_of
(braket
l_int|0
)braket
op_assign
id|rs-&gt;nn
suffix:semicolon
multiline_comment|/* log(zero) = -inf */
id|rs-&gt;alpha_to
(braket
id|rs-&gt;nn
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* alpha**-inf = 0 */
id|sr
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs-&gt;nn
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rs-&gt;index_of
(braket
id|sr
)braket
op_assign
id|i
suffix:semicolon
id|rs-&gt;alpha_to
(braket
id|i
)braket
op_assign
id|sr
suffix:semicolon
id|sr
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_amp
(paren
l_int|1
op_lshift
id|symsize
)paren
)paren
id|sr
op_xor_assign
id|gfpoly
suffix:semicolon
id|sr
op_and_assign
id|rs-&gt;nn
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s not primitive, exit */
r_if
c_cond
(paren
id|sr
op_ne
l_int|1
)paren
(brace
r_goto
id|errpol
suffix:semicolon
)brace
multiline_comment|/* Find prim-th root of 1, used in decoding */
r_for
c_loop
(paren
id|iprim
op_assign
l_int|1
suffix:semicolon
(paren
id|iprim
op_mod
id|prim
)paren
op_ne
l_int|0
suffix:semicolon
id|iprim
op_add_assign
id|rs-&gt;nn
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* prim-th root of 1, index form */
id|rs-&gt;iprim
op_assign
id|iprim
op_div
id|prim
suffix:semicolon
multiline_comment|/* Form RS code generator polynomial from its roots */
id|rs-&gt;genpoly
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|root
op_assign
id|fcr
op_star
id|prim
suffix:semicolon
id|i
OL
id|nroots
suffix:semicolon
id|i
op_increment
comma
id|root
op_add_assign
id|prim
)paren
(brace
id|rs-&gt;genpoly
(braket
id|i
op_plus
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Multiply rs-&gt;genpoly[] by  @**(root + x) */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|rs-&gt;genpoly
(braket
id|j
)braket
op_ne
l_int|0
)paren
(brace
id|rs-&gt;genpoly
(braket
id|j
)braket
op_assign
id|rs-&gt;genpoly
(braket
id|j
op_minus
l_int|1
)braket
op_xor
id|rs-&gt;alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|rs-&gt;index_of
(braket
id|rs-&gt;genpoly
(braket
id|j
)braket
)braket
op_plus
id|root
)paren
)braket
suffix:semicolon
)brace
r_else
id|rs-&gt;genpoly
(braket
id|j
)braket
op_assign
id|rs-&gt;genpoly
(braket
id|j
op_minus
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/* rs-&gt;genpoly[0] can never be zero */
id|rs-&gt;genpoly
(braket
l_int|0
)braket
op_assign
id|rs-&gt;alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|rs-&gt;index_of
(braket
id|rs-&gt;genpoly
(braket
l_int|0
)braket
)braket
op_plus
id|root
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/* convert rs-&gt;genpoly[] to index form for quicker encoding */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|nroots
suffix:semicolon
id|i
op_increment
)paren
id|rs-&gt;genpoly
(braket
id|i
)braket
op_assign
id|rs-&gt;index_of
(braket
id|rs-&gt;genpoly
(braket
id|i
)braket
)braket
suffix:semicolon
r_return
id|rs
suffix:semicolon
multiline_comment|/* Error exit */
id|errpol
suffix:colon
id|kfree
c_func
(paren
id|rs-&gt;genpoly
)paren
suffix:semicolon
id|erridx
suffix:colon
id|kfree
c_func
(paren
id|rs-&gt;index_of
)paren
suffix:semicolon
id|erralp
suffix:colon
id|kfree
c_func
(paren
id|rs-&gt;alpha_to
)paren
suffix:semicolon
id|errrs
suffix:colon
id|kfree
c_func
(paren
id|rs
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/** &n; *  free_rs - Free the rs control structure, if its not longer used&n; *&n; *  @rs:&t;the control structure which is not longer used by the&n; *&t;&t;caller&n; */
DECL|function|free_rs
r_void
id|free_rs
c_func
(paren
r_struct
id|rs_control
op_star
id|rs
)paren
(brace
id|down
c_func
(paren
op_amp
id|rslistlock
)paren
suffix:semicolon
id|rs-&gt;users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rs-&gt;users
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|rs-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rs-&gt;alpha_to
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rs-&gt;index_of
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rs-&gt;genpoly
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rs
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rslistlock
)paren
suffix:semicolon
)brace
multiline_comment|/** &n; * init_rs - Find a matching or allocate a new rs control structure&n; *&n; *  @symsize:&t;the symbol size (number of bits)&n; *  @gfpoly:&t;the extended Galois field generator polynomial coefficients,&n; *&t;&t;with the 0th coefficient in the low order bit. The polynomial&n; *&t;&t;must be primitive;&n; *  @fcr:  &t;the first consecutive root of the rs code generator polynomial &n; *&t;&t;in index form&n; *  @prim:&t;primitive element to generate polynomial roots&n; *  @nroots:&t;RS code generator polynomial degree (number of roots)&n; */
DECL|function|init_rs
r_struct
id|rs_control
op_star
id|init_rs
c_func
(paren
r_int
id|symsize
comma
r_int
id|gfpoly
comma
r_int
id|fcr
comma
r_int
id|prim
comma
r_int
id|nroots
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|rs_control
op_star
id|rs
suffix:semicolon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|symsize
OL
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fcr
OL
l_int|0
op_logical_or
id|fcr
op_ge
(paren
l_int|1
op_lshift
id|symsize
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|prim
op_le
l_int|0
op_logical_or
id|prim
op_ge
(paren
l_int|1
op_lshift
id|symsize
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|nroots
template_param
l_int|8
)paren
r_return
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rslistlock
)paren
suffix:semicolon
multiline_comment|/* Walk through the list and look for a matching entry */
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|rslist
)paren
(brace
id|rs
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|rs_control
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|symsize
op_ne
id|rs-&gt;mm
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|gfpoly
op_ne
id|rs-&gt;gfpoly
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fcr
op_ne
id|rs-&gt;fcr
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|prim
op_ne
id|rs-&gt;prim
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|nroots
op_ne
id|rs-&gt;nroots
)paren
r_continue
suffix:semicolon
multiline_comment|/* We have a matching one already */
id|rs-&gt;users
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Create a new one */
id|rs
op_assign
id|rs_init
c_func
(paren
id|symsize
comma
id|gfpoly
comma
id|fcr
comma
id|prim
comma
id|nroots
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs
)paren
(brace
id|rs-&gt;users
op_assign
l_int|1
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rs-&gt;list
comma
op_amp
id|rslist
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rslistlock
)paren
suffix:semicolon
r_return
id|rs
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REED_SOLOMON_ENC8
multiline_comment|/** &n; *  encode_rs8 - Calculate the parity for data values (8bit data width)&n; *&n; *  @rs:&t;the rs control structure&n; *  @data:&t;data field of a given type&n; *  @len:&t;data length &n; *  @par:&t;parity data, must be initialized by caller (usually all 0)&n; *  @invmsk:&t;invert data mask (will be xored on data)&n; *&n; *  The parity uses a uint16_t data type to enable&n; *  symbol size &gt; 8. The calling code must take care of encoding of the&n; *  syndrome result for storage itself.&n; */
DECL|function|encode_rs8
r_int
id|encode_rs8
c_func
(paren
r_struct
id|rs_control
op_star
id|rs
comma
r_uint8
op_star
id|data
comma
r_int
id|len
comma
r_uint16
op_star
id|par
comma
r_uint16
id|invmsk
)paren
(brace
macro_line|#include &quot;encode_rs.c&quot;
)brace
DECL|variable|encode_rs8
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|encode_rs8
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REED_SOLOMON_DEC8
multiline_comment|/** &n; *  decode_rs8 - Decode codeword (8bit data width)&n; *&n; *  @rs:&t;the rs control structure&n; *  @data:&t;data field of a given type&n; *  @par:&t;received parity data field&n; *  @len:&t;data length&n; *  @s:&t;&t;syndrome data field (if NULL, syndrome is calculated)&n; *  @no_eras:&t;number of erasures&n; *  @eras_pos:&t;position of erasures, can be NULL&n; *  @invmsk:&t;invert data mask (will be xored on data, not on parity!)&n; *  @corr:&t;buffer to store correction bitmask on eras_pos&n; *&n; *  The syndrome and parity uses a uint16_t data type to enable&n; *  symbol size &gt; 8. The calling code must take care of decoding of the&n; *  syndrome result and the received parity before calling this code.&n; */
DECL|function|decode_rs8
r_int
id|decode_rs8
c_func
(paren
r_struct
id|rs_control
op_star
id|rs
comma
r_uint8
op_star
id|data
comma
r_uint16
op_star
id|par
comma
r_int
id|len
comma
r_uint16
op_star
id|s
comma
r_int
id|no_eras
comma
r_int
op_star
id|eras_pos
comma
r_uint16
id|invmsk
comma
r_uint16
op_star
id|corr
)paren
(brace
macro_line|#include &quot;decode_rs.c&quot;
)brace
DECL|variable|decode_rs8
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|decode_rs8
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REED_SOLOMON_ENC16
multiline_comment|/**&n; *  encode_rs16 - Calculate the parity for data values (16bit data width)&n; *&n; *  @rs:&t;the rs control structure&n; *  @data:&t;data field of a given type&n; *  @len:&t;data length &n; *  @par:&t;parity data, must be initialized by caller (usually all 0)&n; *  @invmsk:&t;invert data mask (will be xored on data, not on parity!)&n; *&n; *  Each field in the data array contains up to symbol size bits of valid data.&n; */
DECL|function|encode_rs16
r_int
id|encode_rs16
c_func
(paren
r_struct
id|rs_control
op_star
id|rs
comma
r_uint16
op_star
id|data
comma
r_int
id|len
comma
r_uint16
op_star
id|par
comma
r_uint16
id|invmsk
)paren
(brace
macro_line|#include &quot;encode_rs.c&quot;
)brace
DECL|variable|encode_rs16
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|encode_rs16
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REED_SOLOMON_DEC16
multiline_comment|/** &n; *  decode_rs16 - Decode codeword (16bit data width)&n; *&n; *  @rs:&t;the rs control structure&n; *  @data:&t;data field of a given type&n; *  @par:&t;received parity data field&n; *  @len:&t;data length&n; *  @s:&t;&t;syndrome data field (if NULL, syndrome is calculated)&n; *  @no_eras:&t;number of erasures&n; *  @eras_pos:&t;position of erasures, can be NULL&n; *  @invmsk:&t;invert data mask (will be xored on data, not on parity!) &n; *  @corr:&t;buffer to store correction bitmask on eras_pos&n; *&n; *  Each field in the data array contains up to symbol size bits of valid data.&n; */
DECL|function|decode_rs16
r_int
id|decode_rs16
c_func
(paren
r_struct
id|rs_control
op_star
id|rs
comma
r_uint16
op_star
id|data
comma
r_uint16
op_star
id|par
comma
r_int
id|len
comma
r_uint16
op_star
id|s
comma
r_int
id|no_eras
comma
r_int
op_star
id|eras_pos
comma
r_uint16
id|invmsk
comma
r_uint16
op_star
id|corr
)paren
(brace
macro_line|#include &quot;decode_rs.c&quot;
)brace
DECL|variable|decode_rs16
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|decode_rs16
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|init_rs
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|init_rs
)paren
suffix:semicolon
DECL|variable|free_rs
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|free_rs
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Reed Solomon encoder/decoder&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Phil Karn, Thomas Gleixner&quot;
)paren
suffix:semicolon
eof
