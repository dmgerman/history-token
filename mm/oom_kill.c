multiline_comment|/*&n; *  linux/mm/oom_kill.c&n; * &n; *  Copyright (C)  1998,2000  Rik van Riel&n; *&t;Thanks go out to Claus Fischer for some serious inspiration and&n; *&t;for goading me into coding this file...&n; *&n; *  The routines in this file are used to kill a process when&n; *  we&squot;re seriously out of memory. This gets called from kswapd()&n; *  in linux/mm/vmscan.c when we really run out of memory.&n; *&n; *  Since we won&squot;t call these routines often (on a well-configured&n; *  machine) this file will double as a &squot;coding guide&squot; and a signpost&n; *  for newbie kernel hackers. It features several pointers to major&n; *  kernel subsystems and hints as to where to find out what things do.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
multiline_comment|/* #define DEBUG */
multiline_comment|/**&n; * oom_badness - calculate a numeric value for how bad this task has been&n; * @p: task struct of which task we should calculate&n; * @p: current uptime in seconds&n; *&n; * The formula used is relatively simple and documented inline in the&n; * function. The main rationale is that we want to select a good task&n; * to kill when we run out of memory.&n; *&n; * Good in this context means that:&n; * 1) we lose the minimum amount of work done&n; * 2) we recover a large amount of memory&n; * 3) we don&squot;t kill anything innocent of eating tons of memory&n; * 4) we want to kill the minimum amount of processes (one)&n; * 5) we try to kill the process the user expects us to kill, this&n; *    algorithm has been meticulously tuned to meet the principle&n; *    of least surprise ... (be careful when you change it)&n; */
DECL|function|badness
r_int
r_int
id|badness
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|uptime
)paren
(brace
r_int
r_int
id|points
comma
id|cpu_time
comma
id|run_time
comma
id|s
suffix:semicolon
r_struct
id|list_head
op_star
id|tsk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;mm
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The memory size of the process is the basis for the badness.&n;&t; */
id|points
op_assign
id|p-&gt;mm-&gt;total_vm
suffix:semicolon
multiline_comment|/*&n;&t; * Processes which fork a lot of child processes are likely&n;&t; * a good choice. We add the vmsize of the childs if they&n;&t; * have an own mm. This prevents forking servers to flood the&n;&t; * machine with an endless amount of childs&n;&t; */
id|list_for_each
c_func
(paren
id|tsk
comma
op_amp
id|p-&gt;children
)paren
(brace
r_struct
id|task_struct
op_star
id|chld
suffix:semicolon
id|chld
op_assign
id|list_entry
c_func
(paren
id|tsk
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chld-&gt;mm
op_ne
id|p-&gt;mm
op_logical_and
id|chld-&gt;mm
)paren
id|points
op_add_assign
id|chld-&gt;mm-&gt;total_vm
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * CPU time is in tens of seconds and run time is in thousands&n;         * of seconds. There is no particular reason for this other than&n;         * that it turned out to work very well in practice.&n;&t; */
id|cpu_time
op_assign
(paren
id|cputime_to_jiffies
c_func
(paren
id|p-&gt;utime
)paren
op_plus
id|cputime_to_jiffies
c_func
(paren
id|p-&gt;stime
)paren
)paren
op_rshift
(paren
id|SHIFT_HZ
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptime
op_ge
id|p-&gt;start_time.tv_sec
)paren
id|run_time
op_assign
(paren
id|uptime
op_minus
id|p-&gt;start_time.tv_sec
)paren
op_rshift
l_int|10
suffix:semicolon
r_else
id|run_time
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
id|int_sqrt
c_func
(paren
id|cpu_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
id|points
op_div_assign
id|s
suffix:semicolon
id|s
op_assign
id|int_sqrt
c_func
(paren
id|int_sqrt
c_func
(paren
id|run_time
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
id|points
op_div_assign
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * Niced processes are most likely less important, so double&n;&t; * their badness points.&n;&t; */
r_if
c_cond
(paren
id|task_nice
c_func
(paren
id|p
)paren
OG
l_int|0
)paren
id|points
op_mul_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Superuser processes are usually more important, so we make it&n;&t; * less likely that we kill those.&n;&t; */
r_if
c_cond
(paren
id|cap_t
c_func
(paren
id|p-&gt;cap_effective
)paren
op_amp
id|CAP_TO_MASK
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_or
id|p-&gt;uid
op_eq
l_int|0
op_logical_or
id|p-&gt;euid
op_eq
l_int|0
)paren
id|points
op_div_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want to kill a process with direct hardware access.&n;&t; * Not only could that mess up the hardware, but usually users&n;&t; * tend to only have this flag set on applications they think&n;&t; * of as important.&n;&t; */
r_if
c_cond
(paren
id|cap_t
c_func
(paren
id|p-&gt;cap_effective
)paren
op_amp
id|CAP_TO_MASK
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
id|points
op_div_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the score by oomkilladj.&n;&t; */
r_if
c_cond
(paren
id|p-&gt;oomkilladj
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;oomkilladj
OG
l_int|0
)paren
id|points
op_lshift_assign
id|p-&gt;oomkilladj
suffix:semicolon
r_else
id|points
op_rshift_assign
op_minus
(paren
id|p-&gt;oomkilladj
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;OOMkill: task %d (%s) got %d points&bslash;n&quot;
comma
id|p-&gt;pid
comma
id|p-&gt;comm
comma
id|points
)paren
suffix:semicolon
macro_line|#endif
r_return
id|points
suffix:semicolon
)brace
multiline_comment|/*&n; * Simple selection loop. We chose the process with the highest&n; * number of &squot;points&squot;. We expect the caller will lock the tasklist.&n; *&n; * (not docbooked, we don&squot;t want this one cluttering up the manual)&n; */
DECL|function|select_bad_process
r_static
r_struct
id|task_struct
op_star
id|select_bad_process
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|maxpoints
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
r_struct
id|task_struct
op_star
id|chosen
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|timespec
id|uptime
suffix:semicolon
id|do_posix_clock_monotonic_gettime
c_func
(paren
op_amp
id|uptime
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
multiline_comment|/* skip the init task with pid == 1 */
r_if
c_cond
(paren
id|p-&gt;pid
OG
l_int|1
)paren
(brace
r_int
r_int
id|points
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This is in the process of releasing memory so wait it&n;&t;&t;&t; * to finish before killing some other task by mistake.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|unlikely
c_func
(paren
id|test_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_MEMDIE
)paren
)paren
op_logical_or
(paren
id|p-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|PF_DEAD
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
l_int|1UL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|PF_SWAPOFF
)paren
r_return
id|p
suffix:semicolon
id|points
op_assign
id|badness
c_func
(paren
id|p
comma
id|uptime.tv_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|points
OG
id|maxpoints
op_logical_or
op_logical_neg
id|chosen
)paren
(brace
id|chosen
op_assign
id|p
suffix:semicolon
id|maxpoints
op_assign
id|points
suffix:semicolon
)brace
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
r_return
id|chosen
suffix:semicolon
)brace
multiline_comment|/**&n; * We must be careful though to never send SIGKILL a process with&n; * CAP_SYS_RAW_IO set, send SIGTERM instead (but it&squot;s unlikely that&n; * we select a process with CAP_SYS_RAW_IO set).&n; */
DECL|function|__oom_kill_task
r_static
r_void
id|__oom_kill_task
c_func
(paren
id|task_t
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
op_eq
l_int|1
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;tried to kill init!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|task_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;mm
op_logical_or
id|p-&gt;mm
op_eq
op_amp
id|init_mm
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;tried to kill an mm-less task!&bslash;n&quot;
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Out of Memory: Killed process %d (%s).&bslash;n&quot;
comma
id|p-&gt;pid
comma
id|p-&gt;comm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We give our sacrificial lamb high priority and access to&n;&t; * all the memory it needs. That way it should be able to&n;&t; * exit() and clear out its resources quickly...&n;&t; */
id|p-&gt;time_slice
op_assign
id|HZ
suffix:semicolon
id|set_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_MEMDIE
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGKILL
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|oom_kill_task
r_static
r_struct
id|mm_struct
op_star
id|oom_kill_task
c_func
(paren
id|task_t
op_star
id|p
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|get_task_mm
c_func
(paren
id|p
)paren
suffix:semicolon
id|task_t
op_star
id|g
comma
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
op_amp
id|init_mm
)paren
(brace
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|__oom_kill_task
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * kill all processes that share the -&gt;mm (i.e. all threads),&n;&t; * but are in a different thread group&n;&t; */
id|do_each_thread
c_func
(paren
id|g
comma
id|q
)paren
r_if
c_cond
(paren
id|q-&gt;mm
op_eq
id|mm
op_logical_and
id|q-&gt;tgid
op_ne
id|p-&gt;tgid
)paren
id|__oom_kill_task
c_func
(paren
id|q
)paren
suffix:semicolon
id|while_each_thread
c_func
(paren
id|g
comma
id|q
)paren
suffix:semicolon
r_return
id|mm
suffix:semicolon
)brace
DECL|function|oom_kill_process
r_static
r_struct
id|mm_struct
op_star
id|oom_kill_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|task_struct
op_star
id|c
suffix:semicolon
r_struct
id|list_head
op_star
id|tsk
suffix:semicolon
multiline_comment|/* Try to kill a child first */
id|list_for_each
c_func
(paren
id|tsk
comma
op_amp
id|p-&gt;children
)paren
(brace
id|c
op_assign
id|list_entry
c_func
(paren
id|tsk
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;mm
op_eq
id|p-&gt;mm
)paren
r_continue
suffix:semicolon
id|mm
op_assign
id|oom_kill_task
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
r_return
id|mm
suffix:semicolon
)brace
r_return
id|oom_kill_task
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * oom_kill - kill the &quot;best&quot; process when we run out of memory&n; *&n; * If we run out of memory, we have the choice between either&n; * killing a random task (bad), letting the system crash (worse)&n; * OR try to be smart about which process to kill. Note that we&n; * don&squot;t have to be perfect here, we just have to be good.&n; */
DECL|function|out_of_memory
r_void
id|out_of_memory
c_func
(paren
r_int
r_int
id|__nocast
id|gfp_mask
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
l_int|NULL
suffix:semicolon
id|task_t
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retry
suffix:colon
id|p
op_assign
id|select_bad_process
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|p
)paren
op_eq
op_minus
l_int|1UL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Found nothing?!?! Either we hang forever, or we panic. */
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Out of memory and no killable processes...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;oom-killer: gfp_mask=0x%x&bslash;n&quot;
comma
id|gfp_mask
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|mm
op_assign
id|oom_kill_process
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|retry
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Give &quot;p&quot; a good chance of killing itself before we&n;&t; * retry to allocate memory.&n;&t; */
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
eof
