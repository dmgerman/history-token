multiline_comment|/*&n; * mm/prio_tree.c - priority search tree for mapping-&gt;i_mmap&n; *&n; * Copyright (C) 2004, Rajesh Venkatasubramanian &lt;vrajesh@umich.edu&gt;&n; *&n; * This file is released under the GPL v2.&n; *&n; * Based on the radix priority search tree proposed by Edward M. McCreight&n; * SIAM Journal of Computing, vol. 14, no.2, pages 257-276, May 1985&n; *&n; * 02Feb2004&t;Initial version&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/prio_tree.h&gt;
multiline_comment|/*&n; * A clever mix of heap and radix trees forms a radix priority search tree (PST)&n; * which is useful for storing intervals, e.g, we can consider a vma as a closed&n; * interval of file pages [offset_begin, offset_end], and store all vmas that&n; * map a file in a PST. Then, using the PST, we can answer a stabbing query,&n; * i.e., selecting a set of stored intervals (vmas) that overlap with (map) a&n; * given input interval X (a set of consecutive file pages), in &quot;O(log n + m)&quot;&n; * time where &squot;log n&squot; is the height of the PST, and &squot;m&squot; is the number of stored&n; * intervals (vmas) that overlap (map) with the input interval X (the set of&n; * consecutive file pages).&n; *&n; * In our implementation, we store closed intervals of the form [radix_index,&n; * heap_index]. We assume that always radix_index &lt;= heap_index. McCreight&squot;s PST&n; * is designed for storing intervals with unique radix indices, i.e., each&n; * interval have different radix_index. However, this limitation can be easily&n; * overcome by using the size, i.e., heap_index - radix_index, as part of the&n; * index, so we index the tree using [(radix_index,size), heap_index].&n; *&n; * When the above-mentioned indexing scheme is used, theoretically, in a 32 bit&n; * machine, the maximum height of a PST can be 64. We can use a balanced version&n; * of the priority search tree to optimize the tree height, but the balanced&n; * tree proposed by McCreight is too complex and memory-hungry for our purpose.&n; */
multiline_comment|/*&n; * The following macros are used for implementing prio_tree for i_mmap&n; */
DECL|macro|RADIX_INDEX
mdefine_line|#define RADIX_INDEX(vma)  ((vma)-&gt;vm_pgoff)
DECL|macro|VMA_SIZE
mdefine_line|#define VMA_SIZE(vma)&t;  (((vma)-&gt;vm_end - (vma)-&gt;vm_start) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* avoid overflow */
DECL|macro|HEAP_INDEX
mdefine_line|#define HEAP_INDEX(vma)&t;  ((vma)-&gt;vm_pgoff + (VMA_SIZE(vma) - 1))
DECL|macro|GET_INDEX_VMA
mdefine_line|#define GET_INDEX_VMA(vma, radix, heap)&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;radix = RADIX_INDEX(vma);&t;&t;&bslash;&n;&t;heap = HEAP_INDEX(vma);&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|GET_INDEX
mdefine_line|#define GET_INDEX(node, radix, heap)&t;&t;&bslash;&n;do { &t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct vm_area_struct *__tmp = &t;&t;&bslash;&n;&t;  prio_tree_entry(node, struct vm_area_struct, shared.prio_tree_node);&bslash;&n;&t;GET_INDEX_VMA(__tmp, radix, heap); &t;&bslash;&n;} while (0)
DECL|variable|index_bits_to_maxindex
r_static
r_int
r_int
id|index_bits_to_maxindex
(braket
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|function|prio_tree_init
r_void
id|__init
id|prio_tree_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|index_bits_to_maxindex
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|index_bits_to_maxindex
(braket
id|i
)braket
op_assign
(paren
l_int|1UL
op_lshift
(paren
id|i
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|index_bits_to_maxindex
(braket
id|ARRAY_SIZE
c_func
(paren
id|index_bits_to_maxindex
)paren
op_minus
l_int|1
)braket
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/*&n; * Maximum heap_index that can be stored in a PST with index_bits bits&n; */
DECL|function|prio_tree_maxindex
r_static
r_inline
r_int
r_int
id|prio_tree_maxindex
c_func
(paren
r_int
r_int
id|bits
)paren
(brace
r_return
id|index_bits_to_maxindex
(braket
id|bits
op_minus
l_int|1
)braket
suffix:semicolon
)brace
r_static
r_void
id|prio_tree_remove
c_func
(paren
r_struct
id|prio_tree_root
op_star
comma
r_struct
id|prio_tree_node
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Extend a priority search tree so that it can store a node with heap_index&n; * max_heap_index. In the worst case, this algorithm takes O((log n)^2).&n; * However, this function is used rarely and the common case performance is&n; * not bad.&n; */
DECL|function|prio_tree_expand
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_expand
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
comma
r_int
r_int
id|max_heap_index
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|first
op_assign
l_int|NULL
comma
op_star
id|prev
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|max_heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
id|root-&gt;index_bits
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|max_heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
(brace
id|root-&gt;index_bits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_int|NULL
)paren
(brace
id|first
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|prio_tree_remove
c_func
(paren
id|root
comma
id|root-&gt;prio_tree_node
)paren
suffix:semicolon
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|first
)paren
suffix:semicolon
id|last
op_assign
id|first
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|last
suffix:semicolon
id|last
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|prio_tree_remove
c_func
(paren
id|root
comma
id|root-&gt;prio_tree_node
)paren
suffix:semicolon
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|last
)paren
suffix:semicolon
id|prev-&gt;left
op_assign
id|last
suffix:semicolon
id|last-&gt;parent
op_assign
id|prev
suffix:semicolon
)brace
)brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|node-&gt;left
op_assign
id|first
suffix:semicolon
id|first-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_else
id|last
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
(brace
id|last-&gt;left
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|last-&gt;left-&gt;parent
op_assign
id|last
suffix:semicolon
)brace
id|root-&gt;prio_tree_node
op_assign
id|node
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace a prio_tree_node with a new node and return the old node&n; */
DECL|function|prio_tree_replace
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_replace
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|old
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|old
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|root-&gt;prio_tree_node
op_ne
id|old
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can reduce root-&gt;index_bits here. However, it is complex&n;&t;&t; * and does not help much to improve performance (IMO).&n;&t;&t; */
id|node-&gt;parent
op_assign
id|node
suffix:semicolon
id|root-&gt;prio_tree_node
op_assign
id|node
suffix:semicolon
)brace
r_else
(brace
id|node-&gt;parent
op_assign
id|old-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|old-&gt;parent-&gt;left
op_eq
id|old
)paren
id|old-&gt;parent-&gt;left
op_assign
id|node
suffix:semicolon
r_else
id|old-&gt;parent-&gt;right
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|old
)paren
)paren
(brace
id|node-&gt;left
op_assign
id|old-&gt;left
suffix:semicolon
id|old-&gt;left-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|old
)paren
)paren
(brace
id|node-&gt;right
op_assign
id|old-&gt;right
suffix:semicolon
id|old-&gt;right-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_return
id|old
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a prio_tree_node @node into a radix priority search tree @root. The&n; * algorithm typically takes O(log n) time where &squot;log n&squot; is the number of bits&n; * required to represent the maximum heap_index. In the worst case, the algo&n; * can take O((log n)^2) - check prio_tree_expand.&n; *&n; * If a prior node with same radix_index and heap_index is already found in&n; * the tree, then returns the address of the prior node. Otherwise, inserts&n; * @node into the tree and returns @node.&n; */
DECL|function|prio_tree_insert
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_insert
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|cur
comma
op_star
id|res
op_assign
id|node
suffix:semicolon
r_int
r_int
id|radix_index
comma
id|heap_index
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index
comma
id|index
comma
id|mask
suffix:semicolon
r_int
id|size_flag
op_assign
l_int|0
suffix:semicolon
id|GET_INDEX
c_func
(paren
id|node
comma
id|radix_index
comma
id|heap_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
op_logical_or
id|heap_index
OG
id|prio_tree_maxindex
c_func
(paren
id|root-&gt;index_bits
)paren
)paren
r_return
id|prio_tree_expand
c_func
(paren
id|root
comma
id|node
comma
id|heap_index
)paren
suffix:semicolon
id|cur
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|root-&gt;index_bits
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
id|GET_INDEX
c_func
(paren
id|cur
comma
id|r_index
comma
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_index
op_eq
id|radix_index
op_logical_and
id|h_index
op_eq
id|heap_index
)paren
r_return
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|h_index
OL
id|heap_index
op_logical_or
(paren
id|h_index
op_eq
id|heap_index
op_logical_and
id|r_index
OG
id|radix_index
)paren
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|tmp
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|prio_tree_replace
c_func
(paren
id|root
comma
id|cur
comma
id|node
)paren
suffix:semicolon
id|cur
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* swap indices */
id|index
op_assign
id|r_index
suffix:semicolon
id|r_index
op_assign
id|radix_index
suffix:semicolon
id|radix_index
op_assign
id|index
suffix:semicolon
id|index
op_assign
id|h_index
suffix:semicolon
id|h_index
op_assign
id|heap_index
suffix:semicolon
id|heap_index
op_assign
id|index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size_flag
)paren
id|index
op_assign
id|heap_index
op_minus
id|radix_index
suffix:semicolon
r_else
id|index
op_assign
id|radix_index
suffix:semicolon
r_if
c_cond
(paren
id|index
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
id|cur-&gt;right
op_assign
id|node
suffix:semicolon
id|node-&gt;parent
op_assign
id|cur
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_else
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
)paren
(brace
id|INIT_PRIO_TREE_NODE
c_func
(paren
id|node
)paren
suffix:semicolon
id|cur-&gt;left
op_assign
id|node
suffix:semicolon
id|node-&gt;parent
op_assign
id|cur
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_else
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
id|size_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Should not reach here */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a prio_tree_node @node from a radix priority search tree @root. The&n; * algorithm takes O(log n) time where &squot;log n&squot; is the number of bits required&n; * to represent the maximum heap_index.&n; */
DECL|function|prio_tree_remove
r_static
r_void
id|prio_tree_remove
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|prio_tree_node
op_star
id|node
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|cur
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index_right
comma
id|h_index_left
suffix:semicolon
id|cur
op_assign
id|node
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
op_logical_or
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|cur
)paren
)paren
id|GET_INDEX
c_func
(paren
id|cur-&gt;left
comma
id|r_index
comma
id|h_index_left
)paren
suffix:semicolon
r_else
(brace
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|cur
)paren
)paren
id|GET_INDEX
c_func
(paren
id|cur-&gt;right
comma
id|r_index
comma
id|h_index_right
)paren
suffix:semicolon
r_else
(brace
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* both h_index_left and h_index_right cannot be 0 */
r_if
c_cond
(paren
id|h_index_left
op_ge
id|h_index_right
)paren
id|cur
op_assign
id|cur-&gt;left
suffix:semicolon
r_else
id|cur
op_assign
id|cur-&gt;right
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|cur
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|root-&gt;prio_tree_node
op_ne
id|cur
)paren
suffix:semicolon
id|INIT_PRIO_TREE_ROOT
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur-&gt;parent-&gt;right
op_eq
id|cur
)paren
id|cur-&gt;parent-&gt;right
op_assign
id|cur-&gt;parent
suffix:semicolon
r_else
id|cur-&gt;parent-&gt;left
op_assign
id|cur-&gt;parent
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
id|node
)paren
id|cur
op_assign
id|prio_tree_replace
c_func
(paren
id|root
comma
id|cur-&gt;parent
comma
id|cur
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Following functions help to enumerate all prio_tree_nodes in the tree that&n; * overlap with the input interval X [radix_index, heap_index]. The enumeration&n; * takes O(log n + m) time where &squot;log n&squot; is the height of the tree (which is&n; * proportional to # of bits required to represent the maximum heap_index) and&n; * &squot;m&squot; is the number of prio_tree_nodes that overlap the interval X.&n; */
DECL|function|prio_tree_left
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_left
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
op_star
id|r_index
comma
r_int
r_int
op_star
id|h_index
)paren
(brace
r_if
c_cond
(paren
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|GET_INDEX
c_func
(paren
id|iter-&gt;cur-&gt;left
comma
op_star
id|r_index
comma
op_star
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
op_le
op_star
id|h_index
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;left
suffix:semicolon
id|iter-&gt;mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
)paren
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|iter-&gt;size_level
op_increment
suffix:semicolon
id|iter-&gt;mask
op_assign
id|ULONG_MAX
suffix:semicolon
)brace
r_else
(brace
id|iter-&gt;size_level
op_assign
l_int|1
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|prio_tree_right
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_right
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
op_star
id|r_index
comma
r_int
r_int
op_star
id|h_index
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|value
op_assign
id|iter-&gt;value
suffix:semicolon
r_else
id|value
op_assign
id|iter-&gt;value
op_or
id|iter-&gt;mask
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;h_index
OL
id|value
)paren
r_return
l_int|NULL
suffix:semicolon
id|GET_INDEX
c_func
(paren
id|iter-&gt;cur-&gt;right
comma
op_star
id|r_index
comma
op_star
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
op_le
op_star
id|h_index
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;right
suffix:semicolon
id|iter-&gt;mask
op_rshift_assign
l_int|1
suffix:semicolon
id|iter-&gt;value
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
)paren
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_left_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|prio_tree_right_empty
c_func
(paren
id|iter-&gt;cur
)paren
)paren
suffix:semicolon
id|iter-&gt;size_level
op_increment
suffix:semicolon
id|iter-&gt;mask
op_assign
id|ULONG_MAX
suffix:semicolon
)brace
r_else
(brace
id|iter-&gt;size_level
op_assign
l_int|1
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|prio_tree_parent
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_parent
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
id|iter-&gt;cur
op_assign
id|iter-&gt;cur-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;mask
op_eq
id|ULONG_MAX
)paren
id|iter-&gt;mask
op_assign
l_int|1UL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iter-&gt;size_level
op_eq
l_int|1
)paren
id|iter-&gt;mask
op_assign
l_int|1UL
suffix:semicolon
r_else
id|iter-&gt;mask
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;size_level
)paren
id|iter-&gt;size_level
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iter-&gt;size_level
op_logical_and
(paren
id|iter-&gt;value
op_amp
id|iter-&gt;mask
)paren
)paren
id|iter-&gt;value
op_xor_assign
id|iter-&gt;mask
suffix:semicolon
r_return
id|iter-&gt;cur
suffix:semicolon
)brace
DECL|function|overlap
r_static
r_inline
r_int
id|overlap
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
comma
r_int
r_int
id|r_index
comma
r_int
r_int
id|h_index
)paren
(brace
r_return
id|iter-&gt;h_index
op_ge
id|r_index
op_logical_and
id|iter-&gt;r_index
op_le
id|h_index
suffix:semicolon
)brace
multiline_comment|/*&n; * prio_tree_first:&n; *&n; * Get the first prio_tree_node that overlaps with the interval [radix_index,&n; * heap_index]. Note that always radix_index &lt;= heap_index. We do a pre-order&n; * traversal of the tree.&n; */
DECL|function|prio_tree_first
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_first
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_struct
id|prio_tree_root
op_star
id|root
suffix:semicolon
r_int
r_int
id|r_index
comma
id|h_index
suffix:semicolon
id|INIT_PRIO_TREE_ITER
c_func
(paren
id|iter
)paren
suffix:semicolon
id|root
op_assign
id|iter-&gt;root
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_empty
c_func
(paren
id|root
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|GET_INDEX
c_func
(paren
id|root-&gt;prio_tree_node
comma
id|r_index
comma
id|h_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;r_index
OG
id|h_index
)paren
r_return
l_int|NULL
suffix:semicolon
id|iter-&gt;mask
op_assign
l_int|1UL
op_lshift
(paren
id|root-&gt;index_bits
op_minus
l_int|1
)paren
suffix:semicolon
id|iter-&gt;cur
op_assign
id|root-&gt;prio_tree_node
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_left
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_right
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * prio_tree_next:&n; *&n; * Get the next prio_tree_node that overlaps with the input interval in iter&n; */
DECL|function|prio_tree_next
r_static
r_struct
id|prio_tree_node
op_star
id|prio_tree_next
c_func
(paren
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_int
r_int
id|r_index
comma
id|h_index
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;cur
op_eq
l_int|NULL
)paren
r_return
id|prio_tree_first
c_func
(paren
id|iter
)paren
suffix:semicolon
id|repeat
suffix:colon
r_while
c_loop
(paren
id|prio_tree_left
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_right
c_func
(paren
id|iter
comma
op_amp
id|r_index
comma
op_amp
id|h_index
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|prio_tree_root
c_func
(paren
id|iter-&gt;cur
)paren
op_logical_and
id|iter-&gt;cur-&gt;parent-&gt;right
op_eq
id|iter-&gt;cur
)paren
id|prio_tree_parent
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio_tree_root
c_func
(paren
id|iter-&gt;cur
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|prio_tree_parent
c_func
(paren
id|iter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overlap
c_func
(paren
id|iter
comma
id|r_index
comma
id|h_index
)paren
)paren
r_return
id|iter-&gt;cur
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n; * Radix priority search tree for address_space-&gt;i_mmap&n; *&n; * For each vma that map a unique set of file pages i.e., unique [radix_index,&n; * heap_index] value, we have a corresponing priority search tree node. If&n; * multiple vmas have identical [radix_index, heap_index] value, then one of&n; * them is used as a tree node and others are stored in a vm_set list. The tree&n; * node points to the first vma (head) of the list using vm_set.head.&n; *&n; * prio_tree_root&n; *      |&n; *      A       vm_set.head&n; *     / &bslash;      /&n; *    L   R -&gt; H-I-J-K-M-N-O-P-Q-S&n; *    ^   ^    &lt;-- vm_set.list --&gt;&n; *  tree nodes&n; *&n; * We need some way to identify whether a vma is a tree node, head of a vm_set&n; * list, or just a member of a vm_set list. We cannot use vm_flags to store&n; * such information. The reason is, in the above figure, it is possible that&n; * vm_flags&squot; of R and H are covered by the different mmap_sems. When R is&n; * removed under R-&gt;mmap_sem, H replaces R as a tree node. Since we do not hold&n; * H-&gt;mmap_sem, we cannot use H-&gt;vm_flags for marking that H is a tree node now.&n; * That&squot;s why some trick involving shared.vm_set.parent is used for identifying&n; * tree nodes and list head nodes.&n; *&n; * vma radix priority search tree node rules:&n; *&n; * vma-&gt;shared.vm_set.parent != NULL    ==&gt; a tree node&n; *      vma-&gt;shared.vm_set.head != NULL ==&gt; list of others mapping same range&n; *      vma-&gt;shared.vm_set.head == NULL ==&gt; no others map the same range&n; *&n; * vma-&gt;shared.vm_set.parent == NULL&n; * &t;vma-&gt;shared.vm_set.head != NULL ==&gt; list head of vmas mapping same range&n; * &t;vma-&gt;shared.vm_set.head == NULL ==&gt; a list node&n; */
multiline_comment|/*&n; * Add a new vma known to map the same set of pages as the old vma:&n; * useful for fork&squot;s dup_mmap as well as vma_prio_tree_insert below.&n; * Note that it just happens to work correctly on i_mmap_nonlinear too.&n; */
DECL|function|vma_prio_tree_add
r_void
id|vma_prio_tree_add
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|old
)paren
(brace
multiline_comment|/* Leave these BUG_ONs till prio_tree patch stabilizes */
id|BUG_ON
c_func
(paren
id|RADIX_INDEX
c_func
(paren
id|vma
)paren
op_ne
id|RADIX_INDEX
c_func
(paren
id|old
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|HEAP_INDEX
c_func
(paren
id|vma
)paren
op_ne
id|HEAP_INDEX
c_func
(paren
id|old
)paren
)paren
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;shared.vm_set.parent
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;shared.vm_set.parent
)paren
id|list_add
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
comma
op_amp
id|old-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old-&gt;shared.vm_set.head
)paren
id|list_add_tail
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
comma
op_amp
id|old-&gt;shared.vm_set.head-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
id|old
suffix:semicolon
id|old-&gt;shared.vm_set.head
op_assign
id|vma
suffix:semicolon
)brace
)brace
DECL|function|vma_prio_tree_insert
r_void
id|vma_prio_tree_insert
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_root
op_star
id|root
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|old
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_assign
id|prio_tree_insert
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ne
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
(brace
id|old
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|vma_prio_tree_add
c_func
(paren
id|vma
comma
id|old
)paren
suffix:semicolon
)brace
)brace
DECL|function|vma_prio_tree_remove
r_void
id|vma_prio_tree_remove
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_root
op_star
id|root
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
comma
op_star
id|head
comma
op_star
id|new_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;shared.vm_set.head
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;shared.vm_set.parent
)paren
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
id|prio_tree_remove
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Leave this BUG_ON till prio_tree patch stabilizes */
id|BUG_ON
c_func
(paren
id|vma-&gt;shared.vm_set.head-&gt;shared.vm_set.head
op_ne
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.parent
)paren
(brace
id|head
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|head-&gt;shared.vm_set.list
)paren
)paren
(brace
id|new_head
op_assign
id|list_entry
c_func
(paren
id|head-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|head-&gt;shared.vm_set.list
)paren
suffix:semicolon
)brace
r_else
id|new_head
op_assign
l_int|NULL
suffix:semicolon
id|prio_tree_replace
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
comma
op_amp
id|head-&gt;shared.prio_tree_node
)paren
suffix:semicolon
id|head-&gt;shared.vm_set.head
op_assign
id|new_head
suffix:semicolon
r_if
c_cond
(paren
id|new_head
)paren
id|new_head-&gt;shared.vm_set.head
op_assign
id|head
suffix:semicolon
)brace
r_else
(brace
id|node
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
)paren
(brace
id|new_head
op_assign
id|list_entry
c_func
(paren
id|vma-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
id|node-&gt;shared.vm_set.head
op_assign
id|new_head
suffix:semicolon
id|new_head-&gt;shared.vm_set.head
op_assign
id|node
suffix:semicolon
)brace
r_else
id|node-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Helper function to enumerate vmas that map a given file page or a set of&n; * contiguous file pages. The function returns vmas that at least map a single&n; * page in the given range of contiguous file pages.&n; */
DECL|function|vma_prio_tree_next
r_struct
id|vm_area_struct
op_star
id|vma_prio_tree_next
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
multiline_comment|/*&n;&t;&t; * First call is with NULL vma&n;&t;&t; */
id|ptr
op_assign
id|prio_tree_next
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|next
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.head
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.parent
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.head
)paren
(brace
id|next
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.list.next
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
)brace
r_else
(brace
id|next
op_assign
id|list_entry
c_func
(paren
id|vma-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next-&gt;shared.vm_set.head
)paren
(brace
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.list.next
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
)brace
id|ptr
op_assign
id|prio_tree_next
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|next
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.head
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
eof
