multiline_comment|/*&n; * mm/prio_tree.c - priority search tree for mapping-&gt;i_mmap&n; *&n; * Copyright (C) 2004, Rajesh Venkatasubramanian &lt;vrajesh@umich.edu&gt;&n; *&n; * This file is released under the GPL v2.&n; *&n; * Based on the radix priority search tree proposed by Edward M. McCreight&n; * SIAM Journal of Computing, vol. 14, no.2, pages 257-276, May 1985&n; *&n; * 02Feb2004&t;Initial version&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/prio_tree.h&gt;
multiline_comment|/*&n; * See lib/prio_tree.c for details on the general radix priority search tree&n; * code.&n; */
multiline_comment|/*&n; * The following #defines are mirrored from lib/prio_tree.c. They&squot;re only used&n; * for debugging, and should be removed (along with the debugging code using&n; * them) when switching also VMAs to the regular prio_tree code.&n; */
DECL|macro|RADIX_INDEX
mdefine_line|#define RADIX_INDEX(vma)  ((vma)-&gt;vm_pgoff)
DECL|macro|VMA_SIZE
mdefine_line|#define VMA_SIZE(vma)&t;  (((vma)-&gt;vm_end - (vma)-&gt;vm_start) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* avoid overflow */
DECL|macro|HEAP_INDEX
mdefine_line|#define HEAP_INDEX(vma)   ((vma)-&gt;vm_pgoff + (VMA_SIZE(vma) - 1))
multiline_comment|/*&n; * Radix priority search tree for address_space-&gt;i_mmap&n; *&n; * For each vma that map a unique set of file pages i.e., unique [radix_index,&n; * heap_index] value, we have a corresponing priority search tree node. If&n; * multiple vmas have identical [radix_index, heap_index] value, then one of&n; * them is used as a tree node and others are stored in a vm_set list. The tree&n; * node points to the first vma (head) of the list using vm_set.head.&n; *&n; * prio_tree_root&n; *      |&n; *      A       vm_set.head&n; *     / &bslash;      /&n; *    L   R -&gt; H-I-J-K-M-N-O-P-Q-S&n; *    ^   ^    &lt;-- vm_set.list --&gt;&n; *  tree nodes&n; *&n; * We need some way to identify whether a vma is a tree node, head of a vm_set&n; * list, or just a member of a vm_set list. We cannot use vm_flags to store&n; * such information. The reason is, in the above figure, it is possible that&n; * vm_flags&squot; of R and H are covered by the different mmap_sems. When R is&n; * removed under R-&gt;mmap_sem, H replaces R as a tree node. Since we do not hold&n; * H-&gt;mmap_sem, we cannot use H-&gt;vm_flags for marking that H is a tree node now.&n; * That&squot;s why some trick involving shared.vm_set.parent is used for identifying&n; * tree nodes and list head nodes.&n; *&n; * vma radix priority search tree node rules:&n; *&n; * vma-&gt;shared.vm_set.parent != NULL    ==&gt; a tree node&n; *      vma-&gt;shared.vm_set.head != NULL ==&gt; list of others mapping same range&n; *      vma-&gt;shared.vm_set.head == NULL ==&gt; no others map the same range&n; *&n; * vma-&gt;shared.vm_set.parent == NULL&n; * &t;vma-&gt;shared.vm_set.head != NULL ==&gt; list head of vmas mapping same range&n; * &t;vma-&gt;shared.vm_set.head == NULL ==&gt; a list node&n; */
multiline_comment|/*&n; * Add a new vma known to map the same set of pages as the old vma:&n; * useful for fork&squot;s dup_mmap as well as vma_prio_tree_insert below.&n; * Note that it just happens to work correctly on i_mmap_nonlinear too.&n; */
DECL|function|vma_prio_tree_add
r_void
id|vma_prio_tree_add
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|old
)paren
(brace
multiline_comment|/* Leave these BUG_ONs till prio_tree patch stabilizes */
id|BUG_ON
c_func
(paren
id|RADIX_INDEX
c_func
(paren
id|vma
)paren
op_ne
id|RADIX_INDEX
c_func
(paren
id|old
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|HEAP_INDEX
c_func
(paren
id|vma
)paren
op_ne
id|HEAP_INDEX
c_func
(paren
id|old
)paren
)paren
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;shared.vm_set.parent
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;shared.vm_set.parent
)paren
id|list_add
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
comma
op_amp
id|old-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old-&gt;shared.vm_set.head
)paren
id|list_add_tail
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
comma
op_amp
id|old-&gt;shared.vm_set.head-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
id|old
suffix:semicolon
id|old-&gt;shared.vm_set.head
op_assign
id|vma
suffix:semicolon
)brace
)brace
DECL|function|vma_prio_tree_insert
r_void
id|vma_prio_tree_insert
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_root
op_star
id|root
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|old
suffix:semicolon
id|vma-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_assign
id|raw_prio_tree_insert
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ne
(paren
r_struct
id|prio_tree_node
op_star
)paren
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
(brace
id|old
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|vma_prio_tree_add
c_func
(paren
id|vma
comma
id|old
)paren
suffix:semicolon
)brace
)brace
DECL|function|vma_prio_tree_remove
r_void
id|vma_prio_tree_remove
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_root
op_star
id|root
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
comma
op_star
id|head
comma
op_star
id|new_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;shared.vm_set.head
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;shared.vm_set.parent
)paren
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
id|raw_prio_tree_remove
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Leave this BUG_ON till prio_tree patch stabilizes */
id|BUG_ON
c_func
(paren
id|vma-&gt;shared.vm_set.head-&gt;shared.vm_set.head
op_ne
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.parent
)paren
(brace
id|head
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|head-&gt;shared.vm_set.list
)paren
)paren
(brace
id|new_head
op_assign
id|list_entry
c_func
(paren
id|head-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|head-&gt;shared.vm_set.list
)paren
suffix:semicolon
)brace
r_else
id|new_head
op_assign
l_int|NULL
suffix:semicolon
id|raw_prio_tree_replace
c_func
(paren
id|root
comma
op_amp
id|vma-&gt;shared.prio_tree_node
comma
op_amp
id|head-&gt;shared.prio_tree_node
)paren
suffix:semicolon
id|head-&gt;shared.vm_set.head
op_assign
id|new_head
suffix:semicolon
r_if
c_cond
(paren
id|new_head
)paren
id|new_head-&gt;shared.vm_set.head
op_assign
id|head
suffix:semicolon
)brace
r_else
(brace
id|node
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
)paren
(brace
id|new_head
op_assign
id|list_entry
c_func
(paren
id|vma-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
id|node-&gt;shared.vm_set.head
op_assign
id|new_head
suffix:semicolon
id|new_head-&gt;shared.vm_set.head
op_assign
id|node
suffix:semicolon
)brace
r_else
id|node-&gt;shared.vm_set.head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Helper function to enumerate vmas that map a given file page or a set of&n; * contiguous file pages. The function returns vmas that at least map a single&n; * page in the given range of contiguous file pages.&n; */
DECL|function|vma_prio_tree_next
r_struct
id|vm_area_struct
op_star
id|vma_prio_tree_next
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|prio_tree_iter
op_star
id|iter
)paren
(brace
r_struct
id|prio_tree_node
op_star
id|ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
multiline_comment|/*&n;&t;&t; * First call is with NULL vma&n;&t;&t; */
id|ptr
op_assign
id|prio_tree_next
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|next
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.head
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.parent
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;shared.vm_set.head
)paren
(brace
id|next
op_assign
id|vma-&gt;shared.vm_set.head
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.list.next
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
)brace
r_else
(brace
id|next
op_assign
id|list_entry
c_func
(paren
id|vma-&gt;shared.vm_set.list.next
comma
r_struct
id|vm_area_struct
comma
id|shared.vm_set.list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next-&gt;shared.vm_set.head
)paren
(brace
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.list.next
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
)brace
id|ptr
op_assign
id|prio_tree_next
c_func
(paren
id|iter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|next
op_assign
id|prio_tree_entry
c_func
(paren
id|ptr
comma
r_struct
id|vm_area_struct
comma
id|shared.prio_tree_node
)paren
suffix:semicolon
id|prefetch
c_func
(paren
id|next-&gt;shared.vm_set.head
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
eof
