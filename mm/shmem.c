multiline_comment|/*&n; * Resizable virtual memory filesystem for Linux.&n; *&n; * Copyright (C) 2000 Linus Torvalds.&n; *&t;&t; 2000 Transmeta Corp.&n; *&t;&t; 2000-2001 Christoph Rohland&n; *&t;&t; 2000-2001 SAP AG&n; * &n; * This file is released under the GPL.&n; */
multiline_comment|/*&n; * This virtual memory filesystem is heavily based on the ramfs. It&n; * extends ramfs by the ability to use swap and honor resource limits&n; * which makes it a completely usable filesystem.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/smplock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* This magic number is used in glibc for posix shared memory */
DECL|macro|TMPFS_MAGIC
mdefine_line|#define TMPFS_MAGIC&t;0x01021994
DECL|macro|ENTRIES_PER_PAGE
mdefine_line|#define ENTRIES_PER_PAGE (PAGE_SIZE/sizeof(unsigned long))
DECL|macro|SHMEM_MAX_BLOCKS
mdefine_line|#define SHMEM_MAX_BLOCKS (SHMEM_NR_DIRECT + ENTRIES_PER_PAGE*ENTRIES_PER_PAGE)
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
suffix:semicolon
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
suffix:semicolon
DECL|variable|shmem_dir_operations
r_static
r_struct
id|file_operations
id|shmem_dir_operations
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
suffix:semicolon
DECL|variable|shmem_symlink_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inode_operations
suffix:semicolon
DECL|variable|shmem_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_vm_ops
suffix:semicolon
DECL|variable|shmem_inodes
id|LIST_HEAD
(paren
id|shmem_inodes
)paren
suffix:semicolon
DECL|variable|shmem_ilock
r_static
id|spinlock_t
id|shmem_ilock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|BLOCKS_PER_PAGE
mdefine_line|#define BLOCKS_PER_PAGE (PAGE_SIZE/512)
multiline_comment|/*&n; * shmem_recalc_inode - recalculate the size of an inode&n; *&n; * @inode: inode to recalc&n; *&n; * We have to calculate the free blocks since the mm can drop pages&n; * behind our back&n; *&n; * But we know that normally&n; * inodes-&gt;i_blocks/BLOCKS_PER_PAGE == &n; * &t;&t;&t;inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped&n; *&n; * So the mm freed &n; * inodes-&gt;i_blocks/BLOCKS_PER_PAGE - &n; *&t;&t;&t;(inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped)&n; *&n; * It has to be called with the spinlock held.&n; */
DECL|function|shmem_recalc_inode
r_static
r_void
id|shmem_recalc_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|freed
suffix:semicolon
id|freed
op_assign
(paren
id|inode-&gt;i_blocks
op_div
id|BLOCKS_PER_PAGE
)paren
op_minus
(paren
id|inode-&gt;i_mapping-&gt;nrpages
op_plus
id|inode-&gt;u.shmem_i.swapped
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freed
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
id|freed
op_star
id|BLOCKS_PER_PAGE
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|info-&gt;free_blocks
op_add_assign
id|freed
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
)brace
)brace
DECL|function|shmem_swp_entry
r_static
id|swp_entry_t
op_star
id|shmem_swp_entry
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
r_int
r_int
id|index
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SHMEM_NR_DIRECT
)paren
r_return
id|info-&gt;i_direct
op_plus
id|index
suffix:semicolon
id|index
op_sub_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|offset
op_assign
id|index
op_mod
id|ENTRIES_PER_PAGE
suffix:semicolon
id|index
op_div_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|ENTRIES_PER_PAGE
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFBIG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
(brace
id|info-&gt;i_indirect
op_assign
(paren
id|swp_entry_t
op_star
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;i_indirect
(braket
id|index
)braket
)paren
)paren
(brace
id|info-&gt;i_indirect
(braket
id|index
)braket
op_assign
(paren
id|swp_entry_t
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
(braket
id|index
)braket
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_return
id|info-&gt;i_indirect
(braket
id|index
)braket
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|shmem_free_swp
r_static
r_int
id|shmem_free_swp
c_func
(paren
id|swp_entry_t
op_star
id|dir
comma
r_int
r_int
id|count
)paren
(brace
id|swp_entry_t
op_star
id|ptr
comma
id|entry
suffix:semicolon
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|dir
suffix:semicolon
id|ptr
OL
id|dir
op_plus
id|count
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ptr-&gt;val
)paren
r_continue
suffix:semicolon
id|entry
op_assign
op_star
id|ptr
suffix:semicolon
op_star
id|ptr
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
id|freed
op_increment
suffix:semicolon
multiline_comment|/* vmscan will do the actual page freeing later.. */
id|swap_free
(paren
id|entry
)paren
suffix:semicolon
)brace
r_return
id|freed
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_truncate_part - free a bunch of swap entries&n; *&n; * @dir:&t;pointer to swp_entries &n; * @size:&t;number of entries in dir&n; * @start:&t;offset to start from&n; * @freed:&t;counter for freed pages&n; *&n; * It frees the swap entries from dir+start til dir+size&n; *&n; * returns 0 if it truncated something, else (offset-size)&n; */
r_static
r_int
r_int
DECL|function|shmem_truncate_part
id|shmem_truncate_part
(paren
id|swp_entry_t
op_star
id|dir
comma
r_int
r_int
id|size
comma
r_int
r_int
id|start
comma
r_int
r_int
op_star
id|freed
)paren
(brace
r_if
c_cond
(paren
id|start
OG
id|size
)paren
r_return
id|start
op_minus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
op_star
id|freed
op_add_assign
id|shmem_free_swp
(paren
id|dir
op_plus
id|start
comma
id|size
op_minus
id|start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_truncate
r_static
r_void
id|shmem_truncate
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|clear_base
suffix:semicolon
r_int
r_int
id|index
comma
id|start
suffix:semicolon
r_int
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
id|swp_entry_t
op_star
op_star
id|base
comma
op_star
op_star
id|ptr
comma
op_star
op_star
id|last
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|index
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|info-&gt;max_index
)paren
r_goto
id|out
suffix:semicolon
id|start
op_assign
id|shmem_truncate_part
(paren
id|info-&gt;i_direct
comma
id|SHMEM_NR_DIRECT
comma
id|index
comma
op_amp
id|freed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_assign
id|info-&gt;i_indirect
)paren
)paren
r_goto
id|out
suffix:semicolon
id|clear_base
op_assign
l_int|1
suffix:semicolon
id|last
op_assign
id|base
op_plus
(paren
(paren
id|info-&gt;max_index
op_minus
id|SHMEM_NR_DIRECT
op_plus
id|ENTRIES_PER_PAGE
op_minus
l_int|1
)paren
op_div
id|ENTRIES_PER_PAGE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|base
suffix:semicolon
id|ptr
OL
id|last
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|start
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ptr
)paren
r_continue
suffix:semicolon
id|freed
op_add_assign
id|shmem_free_swp
(paren
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
)paren
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
op_star
id|ptr
)paren
suffix:semicolon
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|clear_base
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|shmem_truncate_part
(paren
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
comma
id|start
comma
op_amp
id|freed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clear_base
)paren
(brace
id|free_page
(paren
(paren
r_int
r_int
)paren
id|base
)paren
suffix:semicolon
id|info-&gt;i_indirect
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/*&n;&t; * We have no chance to give an error, so we limit it to max&n;&t; * size here and the application will fail later&n;&t; */
r_if
c_cond
(paren
id|index
OG
id|SHMEM_MAX_BLOCKS
)paren
id|info-&gt;max_index
op_assign
id|SHMEM_MAX_BLOCKS
suffix:semicolon
r_else
id|info-&gt;max_index
op_assign
id|index
suffix:semicolon
id|info-&gt;swapped
op_sub_assign
id|freed
suffix:semicolon
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|shmem_delete_inode
r_static
r_void
id|shmem_delete_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb
suffix:semicolon
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|inode-&gt;u.shmem_i.list
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|shmem_truncate
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|info-&gt;free_inodes
op_increment
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move the page from the page cache to the swap cache.&n; *&n; * The page lock prevents multiple occurences of shmem_writepage at&n; * once.  We still need to guard against racing with&n; * shmem_getpage_locked().  &n; */
DECL|function|shmem_writepage
r_static
r_int
id|shmem_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
id|swp_entry_t
op_star
id|entry
comma
id|swap
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|index
op_assign
id|page-&gt;index
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_entry
c_func
(paren
id|info
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
multiline_comment|/* this had been allocated on page allocation */
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;val
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Remove it from the page cache */
id|lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap.val
)paren
(brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Add it back to the page cache */
id|add_to_page_cache_locked
c_func
(paren
id|page
comma
id|mapping
comma
id|index
)paren
suffix:semicolon
id|activate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Add it to the swap cache */
id|add_to_swap_cache
c_func
(paren
id|page
comma
id|swap
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|info-&gt;swapped
op_increment
suffix:semicolon
op_star
id|entry
op_assign
id|swap
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_getpage_locked - either get the page from swap or allocate a new one&n; *&n; * If we allocate a new one we do not mark it dirty. That&squot;s up to the&n; * vm. If we swap it in we mark it dirty since we also free the swap&n; * entry since a page cannot live in both the swap and page cache&n; *&n; * Called with the inode locked, so it cannot race with itself, but we&n; * still need to guard against racing with shm_writepage(), which might&n; * be trying to move the page to the swap cache as we run.&n; */
DECL|function|shmem_getpage_locked
r_static
r_struct
id|page
op_star
id|shmem_getpage_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|idx
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|swp_entry_t
op_star
id|entry
suffix:semicolon
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|find_lock_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
id|page
suffix:semicolon
id|entry
op_assign
id|shmem_swp_entry
(paren
id|info
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
r_return
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* The shmem_swp_entry() call may have blocked, and&n;&t; * shmem_writepage may have been moving a page between the page&n;&t; * cache and swap cache.  We need to recheck the page cache&n;&t; * under the protection of the info-&gt;lock spinlock. */
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_goto
id|wait_retry
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Look it up and read it in.. */
id|page
op_assign
id|find_get_page
c_func
(paren
op_amp
id|swapper_space
comma
id|entry-&gt;val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|swp_entry_t
id|swap
op_assign
op_star
id|entry
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|swapin_readahead
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
id|page
op_assign
id|read_swap_cache_async
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;val
op_ne
id|swap.val
)paren
r_goto
id|repeat
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
op_logical_and
id|entry-&gt;val
op_eq
id|swap.val
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Too bad we can&squot;t trust this page, because we&n;&t;&t;&t; * dropped the info-&gt;lock spinlock */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* We have to this with page locked to prevent races */
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_goto
id|wait_retry
suffix:semicolon
id|swap_free
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
op_star
id|entry
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|flags
op_assign
id|page-&gt;flags
op_amp
op_complement
(paren
l_int|1
op_lshift
id|PG_uptodate
op_or
l_int|1
op_lshift
id|PG_error
op_or
l_int|1
op_lshift
id|PG_referenced
op_or
l_int|1
op_lshift
id|PG_arch_1
)paren
suffix:semicolon
id|page-&gt;flags
op_assign
id|flags
op_or
(paren
l_int|1
op_lshift
id|PG_dirty
)paren
suffix:semicolon
id|add_to_page_cache_locked
c_func
(paren
id|page
comma
id|mapping
comma
id|idx
)paren
suffix:semicolon
id|info-&gt;swapped
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks
op_eq
l_int|0
)paren
r_goto
id|no_space
suffix:semicolon
id|inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
multiline_comment|/* Ok, get a new page.  We don&squot;t have to worry about the&n;&t;&t; * info-&gt;lock spinlock here: we cannot race against&n;&t;&t; * shm_writepage because we have already verified that&n;&t;&t; * there is no page present either in memory or in the&n;&t;&t; * swap cache, so we are guaranteed to be populating a&n;&t;&t; * new shm entry.  The inode semaphore we already hold&n;&t;&t; * is enough to make this atomic. */
id|page
op_assign
id|page_cache_alloc
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|clear_highpage
c_func
(paren
id|page
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_add_assign
id|BLOCKS_PER_PAGE
suffix:semicolon
id|add_to_page_cache
(paren
id|page
comma
id|mapping
comma
id|idx
)paren
suffix:semicolon
)brace
multiline_comment|/* We have the page */
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;locked
)paren
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
id|no_space
suffix:colon
id|spin_unlock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOSPC
)paren
suffix:semicolon
id|wait_retry
suffix:colon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|shmem_getpage
r_static
r_int
id|shmem_getpage
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|idx
comma
r_struct
id|page
op_star
op_star
id|ptr
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
op_le
(paren
id|loff_t
)paren
id|idx
op_star
id|PAGE_CACHE_SIZE
)paren
r_goto
id|sigbus
suffix:semicolon
op_star
id|ptr
op_assign
id|shmem_getpage_locked
c_func
(paren
id|inode
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
op_star
id|ptr
)paren
)paren
r_goto
id|failed
suffix:semicolon
id|UnlockPage
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|NOPAGE_OOM
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|EFBIG
)paren
op_star
id|ptr
op_assign
id|NOPAGE_SIGBUS
suffix:semicolon
r_return
id|error
suffix:semicolon
id|sigbus
suffix:colon
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|NOPAGE_SIGBUS
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|shmem_nopage
r_struct
id|page
op_star
id|shmem_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|no_share
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|idx
op_assign
(paren
id|address
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|idx
op_add_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
r_if
c_cond
(paren
id|shmem_getpage
c_func
(paren
id|inode
comma
id|idx
comma
op_amp
id|page
)paren
)paren
r_return
id|page
suffix:semicolon
r_if
c_cond
(paren
id|no_share
)paren
(brace
r_struct
id|page
op_star
id|new_page
op_assign
id|page_cache_alloc
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_page
)paren
(brace
id|copy_user_highpage
c_func
(paren
id|new_page
comma
id|page
comma
id|address
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|new_page
)paren
suffix:semicolon
)brace
r_else
id|new_page
op_assign
id|NOPAGE_OOM
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
)brace
id|flush_page_to_ram
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|function|shmem_lock
r_void
id|shmem_lock
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|lock
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|idx
comma
id|size
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;locked
op_eq
id|lock
)paren
r_return
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|info-&gt;locked
op_assign
id|lock
suffix:semicolon
id|size
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|size
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|page
op_assign
id|find_lock_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
multiline_comment|/* release the extra count and our reference */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
DECL|function|shmem_mmap
r_static
r_int
id|shmem_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_operations_struct
op_star
id|ops
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|ops
op_assign
op_amp
id|shmem_vm_ops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
id|ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_get_inode
r_struct
id|inode
op_star
id|shmem_get_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|mode
comma
r_int
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|spin_lock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;u.shmem_sb.free_inodes
)paren
(brace
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;u.shmem_sb.free_inodes
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|NODEV
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|shmem_aops
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|inode-&gt;u.shmem_i.lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_default
suffix:colon
id|init_special_inode
c_func
(paren
id|inode
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|shmem_dir_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_symlink_inode_operations
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|inode-&gt;u.shmem_i.list
comma
op_amp
id|shmem_inodes
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
DECL|function|shmem_set_size
r_static
r_int
id|shmem_set_size
c_func
(paren
r_struct
id|shmem_sb_info
op_star
id|info
comma
r_int
r_int
id|max_blocks
comma
r_int
r_int
id|max_inodes
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|blocks
comma
id|inodes
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|blocks
op_assign
id|info-&gt;max_blocks
op_minus
id|info-&gt;free_blocks
suffix:semicolon
id|inodes
op_assign
id|info-&gt;max_inodes
op_minus
id|info-&gt;free_inodes
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|max_blocks
OL
id|blocks
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|max_inodes
OL
id|inodes
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|info-&gt;max_blocks
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;free_blocks
op_assign
id|max_blocks
op_minus
id|blocks
suffix:semicolon
id|info-&gt;max_inodes
op_assign
id|max_inodes
suffix:semicolon
id|info-&gt;free_inodes
op_assign
id|max_inodes
op_minus
id|inodes
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TMPFS
r_static
id|ssize_t
DECL|function|shmem_file_write
id|shmem_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|file-&gt;f_error
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|file-&gt;f_error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|written
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
id|pos
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we&squot;ve reached the file size limit.&n;&t; */
id|err
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
)paren
(brace
r_if
c_cond
(paren
id|pos
op_ge
id|limit
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
id|limit
op_minus
id|pos
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|count
op_assign
id|limit
op_minus
id|pos
suffix:semicolon
)brace
)brace
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|remove_suid
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
r_int
r_int
id|bytes
comma
id|index
comma
id|offset
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|deactivate
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to find the page in the cache. If it isn&squot;t there,&n;&t;&t; * allocate a free page.&n;&t;&t; */
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
(brace
id|bytes
op_assign
id|count
suffix:semicolon
id|deactivate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Bring in the user page that we will copy from _first_.&n;&t;&t; * Otherwise there&squot;s a nasty deadlock on copying from the&n;&t;&t; * same page as we&squot;re writing to, without it being marked&n;&t;&t; * up-to-date.&n;&t;&t; */
(brace
r_volatile
r_int
r_char
id|dummy
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
)paren
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
op_plus
id|bytes
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|page
op_assign
id|shmem_getpage_locked
c_func
(paren
id|inode
comma
id|index
)paren
suffix:semicolon
id|status
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* We have exclusive IO access to the page.. */
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
singleline_comment|// can this do a truncated write? cr
id|status
op_assign
id|copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|fail_write
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
l_int|0
)paren
(brace
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|written
op_add_assign
id|bytes
suffix:semicolon
id|count
op_sub_assign
id|bytes
suffix:semicolon
id|pos
op_add_assign
id|bytes
suffix:semicolon
id|buf
op_add_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;u.shmem_i.max_index
op_le
id|index
)paren
id|inode-&gt;u.shmem_i.max_index
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
)brace
id|unlock
suffix:colon
multiline_comment|/* Mark it unlocked again and drop the page.. */
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deactivate
)paren
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
id|err
op_assign
id|written
ques
c_cond
id|written
suffix:colon
id|status
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|fail_write
suffix:colon
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
DECL|function|do_shmem_file_read
r_static
r_void
id|do_shmem_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|ppos
comma
id|read_descriptor_t
op_star
id|desc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
r_int
id|nr
op_assign
l_int|1
suffix:semicolon
id|index
op_assign
op_star
id|ppos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
op_star
id|ppos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_logical_and
id|desc-&gt;count
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|end_index
comma
id|nr
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|end_index
)paren
r_break
suffix:semicolon
id|nr
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|end_index
)paren
(brace
id|nr
op_assign
id|inode-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|offset
)paren
r_break
suffix:semicolon
)brace
id|nr
op_assign
id|nr
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|desc-&gt;error
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
id|index
comma
op_amp
id|page
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;i_mmap_shared
op_ne
l_int|NULL
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ok, we have the page, and it&squot;s up-to-date, so&n;&t;&t; * now we can copy it to user space...&n;&t;&t; *&n;&t;&t; * The actor routine returns how many bytes were actually used..&n;&t;&t; * NOTE! This may not be the same as how much of a user buffer&n;&t;&t; * we filled up (we may be padding etc), so we can only update&n;&t;&t; * &quot;pos&quot; here (the actor routine has to update the user buffer&n;&t;&t; * pointers and the remaining count).&n;&t;&t; */
id|nr
op_assign
id|file_read_actor
c_func
(paren
id|desc
comma
id|page
comma
id|offset
comma
id|nr
)paren
suffix:semicolon
id|offset
op_add_assign
id|nr
suffix:semicolon
id|index
op_add_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
op_star
id|ppos
op_assign
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|offset
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|shmem_file_read
r_static
id|ssize_t
id|shmem_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|buf
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_shmem_file_read
c_func
(paren
id|filp
comma
id|ppos
comma
op_amp
id|desc
)paren
suffix:semicolon
id|retval
op_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|desc.error
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|shmem_statfs
r_static
r_int
id|shmem_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|buf-&gt;f_type
op_assign
id|TMPFS_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|spin_lock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|buf-&gt;f_blocks
op_assign
id|sb-&gt;u.shmem_sb.max_blocks
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
op_assign
id|sb-&gt;u.shmem_sb.free_blocks
suffix:semicolon
id|buf-&gt;f_files
op_assign
id|sb-&gt;u.shmem_sb.max_inodes
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
id|sb-&gt;u.shmem_sb.free_inodes
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
l_int|255
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the data. This is trivial - if the dentry didn&squot;t already&n; * exist, we know it is negative.&n; */
DECL|function|shmem_lookup
r_static
r_struct
id|dentry
op_star
id|shmem_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|d_add
c_func
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * File creation. Allocate an inode, and we&squot;re done..&n; */
DECL|function|shmem_mknod
r_static
r_int
id|shmem_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra count - pin the dentry in core */
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_mkdir
r_static
r_int
id|shmem_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFDIR
comma
l_int|0
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|dir-&gt;i_nlink
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_create
r_static
r_int
id|shmem_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_return
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFREG
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Link a file..&n; */
DECL|function|shmem_link
r_static
r_int
id|shmem_link
c_func
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
multiline_comment|/* New dentry reference */
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra pinning count for the created dentry */
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_positive
r_static
r_inline
r_int
id|shmem_positive
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|dentry-&gt;d_inode
op_logical_and
op_logical_neg
id|d_unhashed
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that a directory is empty (this works&n; * for regular files too, they&squot;ll just always be&n; * considered empty..).&n; *&n; * Note that an empty directory can still have&n; * children, they just all have to be negative..&n; */
DECL|function|shmem_empty
r_static
r_int
id|shmem_empty
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list
op_assign
id|dentry-&gt;d_subdirs.next
suffix:semicolon
r_while
c_loop
(paren
id|list
op_ne
op_amp
id|dentry-&gt;d_subdirs
)paren
(brace
r_struct
id|dentry
op_star
id|de
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shmem_positive
c_func
(paren
id|de
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|shmem_unlink
r_static
r_int
id|shmem_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Undo the count from &quot;create&quot; - this does all the work */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_rmdir
r_static
r_int
id|shmem_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|shmem_empty
c_func
(paren
id|dentry
)paren
)paren
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
id|dir-&gt;i_nlink
op_decrement
suffix:semicolon
r_return
id|shmem_unlink
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The VFS layer already does all the dentry stuff for rename,&n; * we just have to decrement the usage count for the target if&n; * it exists so that the VFS layer correctly free&squot;s it when it&n; * gets overwritten.&n; */
DECL|function|shmem_rename
r_static
r_int
id|shmem_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|shmem_empty
c_func
(paren
id|new_dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|old_dentry-&gt;d_inode-&gt;i_ctime
op_assign
id|old_dir-&gt;i_ctime
op_assign
id|old_dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_symlink
r_static
r_int
id|shmem_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
id|error
op_assign
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|S_IFLNK
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|symname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|PAGE_SIZE
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|page
op_assign
id|shmem_getpage_locked
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|kaddr
comma
id|symname
comma
id|len
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|len
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|shmem_readlink
r_static
r_int
id|shmem_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|res
op_assign
id|shmem_getpage
c_func
(paren
id|dentry-&gt;d_inode
comma
l_int|0
comma
op_amp
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|vfs_readlink
c_func
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
id|kmap
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|shmem_follow_link
r_static
r_int
id|shmem_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|res
op_assign
id|shmem_getpage
c_func
(paren
id|dentry-&gt;d_inode
comma
l_int|0
comma
op_amp
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|vfs_follow_link
c_func
(paren
id|nd
comma
id|kmap
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|shmem_parse_options
r_static
r_int
id|shmem_parse_options
c_func
(paren
r_char
op_star
id|options
comma
r_int
op_star
id|mode
comma
r_int
r_int
op_star
id|blocks
comma
r_int
r_int
op_star
id|inodes
)paren
(brace
r_char
op_star
id|this_char
comma
op_star
id|value
suffix:semicolon
id|this_char
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|this_char
op_assign
id|strtok
c_func
(paren
id|options
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|this_char
suffix:semicolon
id|this_char
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
c_func
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;size&quot;
)paren
)paren
(brace
r_int
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|blocks
)paren
r_return
l_int|1
suffix:semicolon
id|size
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|blocks
op_assign
id|size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_blocks&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|blocks
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|blocks
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_inodes&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|inodes
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|inodes
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;mode&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|mode
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|mode
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|value
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_remount_fs
r_static
r_int
id|shmem_remount_fs
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|info
op_assign
op_amp
id|sb-&gt;u.shmem_sb
suffix:semicolon
r_int
r_int
id|max_blocks
op_assign
id|info-&gt;max_blocks
suffix:semicolon
r_int
r_int
id|max_inodes
op_assign
id|info-&gt;max_inodes
suffix:semicolon
r_if
c_cond
(paren
id|shmem_parse_options
(paren
id|data
comma
l_int|NULL
comma
op_amp
id|max_blocks
comma
op_amp
id|max_inodes
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|shmem_set_size
c_func
(paren
id|info
comma
id|max_blocks
comma
id|max_inodes
)paren
suffix:semicolon
)brace
DECL|function|shmem_sync_file
r_int
id|shmem_sync_file
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|shmem_read_super
r_static
r_struct
id|super_block
op_star
id|shmem_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|root
suffix:semicolon
r_int
r_int
id|blocks
comma
id|inodes
suffix:semicolon
r_int
id|mode
op_assign
id|S_IRWXUGO
op_or
id|S_ISVTX
suffix:semicolon
r_struct
id|sysinfo
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * Per default we only allow half of the physical ram per&n;&t; * tmpfs instance&n;&t; */
id|si_meminfo
c_func
(paren
op_amp
id|si
)paren
suffix:semicolon
id|blocks
op_assign
id|inodes
op_assign
id|si.totalram
op_div
l_int|2
suffix:semicolon
macro_line|#ifdef CONFIG_TMPFS
r_if
c_cond
(paren
id|shmem_parse_options
(paren
id|data
comma
op_amp
id|mode
comma
op_amp
id|blocks
comma
op_amp
id|inodes
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tmpfs invalid option&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_init
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|sb-&gt;u.shmem_sb.max_blocks
op_assign
id|blocks
suffix:semicolon
id|sb-&gt;u.shmem_sb.free_blocks
op_assign
id|blocks
suffix:semicolon
id|sb-&gt;u.shmem_sb.max_inodes
op_assign
id|inodes
suffix:semicolon
id|sb-&gt;u.shmem_sb.free_inodes
op_assign
id|inodes
suffix:semicolon
id|sb-&gt;s_maxbytes
op_assign
(paren
r_int
r_int
r_int
)paren
id|SHMEM_MAX_BLOCKS
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|TMPFS_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|shmem_ops
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|sb
comma
id|S_IFDIR
op_or
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
l_int|NULL
suffix:semicolon
id|root
op_assign
id|d_alloc_root
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;s_root
op_assign
id|root
suffix:semicolon
r_return
id|sb
suffix:semicolon
)brace
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
op_assign
(brace
id|writepage
suffix:colon
id|shmem_writepage
)brace
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
op_assign
(brace
id|mmap
suffix:colon
id|shmem_mmap
comma
macro_line|#ifdef CONFIG_TMPFS
id|read
suffix:colon
id|shmem_file_read
comma
id|write
suffix:colon
id|shmem_file_write
comma
id|fsync
suffix:colon
id|shmem_sync_file
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
op_assign
(brace
id|truncate
suffix:colon
id|shmem_truncate
comma
)brace
suffix:semicolon
DECL|variable|shmem_symlink_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inode_operations
op_assign
(brace
id|truncate
suffix:colon
id|shmem_truncate
comma
macro_line|#ifdef CONFIG_TMPFS
id|readlink
suffix:colon
id|shmem_readlink
comma
id|follow_link
suffix:colon
id|shmem_follow_link
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_dir_operations
r_static
r_struct
id|file_operations
id|shmem_dir_operations
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
id|readdir
suffix:colon
id|dcache_readdir
comma
macro_line|#ifdef CONFIG_TMPFS
id|fsync
suffix:colon
id|shmem_sync_file
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
op_assign
(brace
macro_line|#ifdef CONFIG_TMPFS
id|create
suffix:colon
id|shmem_create
comma
id|lookup
suffix:colon
id|shmem_lookup
comma
id|link
suffix:colon
id|shmem_link
comma
id|unlink
suffix:colon
id|shmem_unlink
comma
id|symlink
suffix:colon
id|shmem_symlink
comma
id|mkdir
suffix:colon
id|shmem_mkdir
comma
id|rmdir
suffix:colon
id|shmem_rmdir
comma
id|mknod
suffix:colon
id|shmem_mknod
comma
id|rename
suffix:colon
id|shmem_rename
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
op_assign
(brace
macro_line|#ifdef CONFIG_TMPFS
id|statfs
suffix:colon
id|shmem_statfs
comma
id|remount_fs
suffix:colon
id|shmem_remount_fs
comma
macro_line|#endif
id|delete_inode
suffix:colon
id|shmem_delete_inode
comma
id|put_inode
suffix:colon
id|force_delete
comma
)brace
suffix:semicolon
DECL|variable|shmem_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_vm_ops
op_assign
(brace
id|nopage
suffix:colon
id|shmem_nopage
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_TMPFS
multiline_comment|/* type &quot;shm&quot; will be tagged obsolete in 2.5 */
r_static
id|DECLARE_FSTYPE
c_func
(paren
id|shmem_fs_type
comma
l_string|&quot;shm&quot;
comma
id|shmem_read_super
comma
id|FS_LITTER
)paren
suffix:semicolon
r_static
id|DECLARE_FSTYPE
c_func
(paren
id|tmpfs_fs_type
comma
l_string|&quot;tmpfs&quot;
comma
id|shmem_read_super
comma
id|FS_LITTER
)paren
suffix:semicolon
macro_line|#else
r_static
id|DECLARE_FSTYPE
c_func
(paren
id|tmpfs_fs_type
comma
l_string|&quot;tmpfs&quot;
comma
id|shmem_read_super
comma
id|FS_LITTER
op_or
id|FS_NOMOUNT
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|shm_mnt
r_static
r_struct
id|vfsmount
op_star
id|shm_mnt
suffix:semicolon
DECL|function|init_shmem_fs
r_static
r_int
id|__init
id|init_shmem_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|vfsmount
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Could not register tmpfs&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TMPFS
r_if
c_cond
(paren
(paren
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|shmem_fs_type
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Could not register shm fs&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;shm&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|res
op_assign
id|kern_mount
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;could not kern_mount tmpfs&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
id|shm_mnt
op_assign
id|res
suffix:semicolon
multiline_comment|/* The internal instance should not do size checking */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|shmem_set_size
c_func
(paren
op_amp
id|res-&gt;mnt_sb-&gt;u.shmem_sb
comma
id|ULONG_MAX
comma
id|ULONG_MAX
)paren
)paren
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;could not set limits on internal tmpfs&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_shmem_fs
r_static
r_void
id|__exit
id|exit_shmem_fs
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_TMPFS
id|unregister_filesystem
c_func
(paren
op_amp
id|shmem_fs_type
)paren
suffix:semicolon
macro_line|#endif
id|unregister_filesystem
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|shm_mnt
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_shmem_fs
)paren
id|module_exit
c_func
(paren
id|exit_shmem_fs
)paren
DECL|function|shmem_clear_swp
r_static
r_int
id|shmem_clear_swp
(paren
id|swp_entry_t
id|entry
comma
id|swp_entry_t
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
id|swp_entry_t
op_star
id|test
suffix:semicolon
r_for
c_loop
(paren
id|test
op_assign
id|ptr
suffix:semicolon
id|test
OL
id|ptr
op_plus
id|size
suffix:semicolon
id|test
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test-&gt;val
op_eq
id|entry.val
)paren
(brace
id|swap_free
(paren
id|entry
)paren
suffix:semicolon
op_star
id|test
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
r_return
id|test
op_minus
id|ptr
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|shmem_unuse_inode
r_static
r_int
id|shmem_unuse_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|swp_entry_t
op_star
op_star
id|base
comma
op_star
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_assign
id|shmem_clear_swp
(paren
id|entry
comma
id|info-&gt;i_direct
comma
id|SHMEM_NR_DIRECT
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|idx
op_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_assign
id|info-&gt;i_indirect
)paren
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|base
suffix:semicolon
id|ptr
OL
id|base
op_plus
id|ENTRIES_PER_PAGE
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_logical_and
(paren
id|offset
op_assign
id|shmem_clear_swp
(paren
id|entry
comma
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|found
suffix:colon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode-&gt;i_mapping
comma
id|offset
op_plus
id|idx
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|info-&gt;swapped
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * unuse_shmem() search for an eventually swapped out shmem page.&n; */
DECL|function|shmem_unuse
r_void
id|shmem_unuse
c_func
(paren
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|shmem_inodes
)paren
(brace
id|inode
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|inode
comma
id|u.shmem_i.list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shmem_unuse_inode
c_func
(paren
id|inode
comma
id|entry
comma
id|page
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_file_setup - get an unlinked file living in shmem fs&n; *&n; * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps&n; * @size: size to be set for the file&n; *&n; */
DECL|function|shmem_file_setup
r_struct
id|file
op_star
id|shmem_file_setup
c_func
(paren
r_char
op_star
id|name
comma
id|loff_t
id|size
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|root
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_int
id|vm_enough_memory
c_func
(paren
r_int
id|pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
r_int
r_int
r_int
)paren
id|SHMEM_MAX_BLOCKS
op_lshift
id|PAGE_CACHE_SHIFT
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
(paren
id|size
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will go */
id|root
op_assign
id|shm_mnt-&gt;mnt_root
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|put_dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|root-&gt;d_sb
comma
id|S_IFREG
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|close_file
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_size
op_assign
id|size
suffix:semicolon
id|shmem_truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|shm_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_WRITE
op_or
id|FMODE_READ
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* It is unlinked */
r_return
id|file
suffix:semicolon
id|close_file
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_dentry
suffix:colon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_zero_setup - setup a shared anonymous mapping&n; *&n; * @vma: the vma to be mmapped is prepared by do_mmap_pgoff&n; */
DECL|function|shmem_zero_setup
r_int
id|shmem_zero_setup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|loff_t
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|file
op_assign
id|shmem_file_setup
c_func
(paren
l_string|&quot;dev/zero&quot;
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|fput
(paren
id|vma-&gt;vm_file
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
op_amp
id|shmem_vm_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|shmem_file_setup
id|EXPORT_SYMBOL
c_func
(paren
id|shmem_file_setup
)paren
suffix:semicolon
eof
