multiline_comment|/*&n; * Resizable virtual memory filesystem for Linux.&n; *&n; * Copyright (C) 2000 Linus Torvalds.&n; *&t;&t; 2000 Transmeta Corp.&n; *&t;&t; 2000-2001 Christoph Rohland&n; *&t;&t; 2000-2001 SAP AG&n; *&t;&t; 2002 Red Hat Inc.&n; *&n; * This file is released under the GPL.&n; */
multiline_comment|/*&n; * This virtual memory filesystem is heavily based on the ramfs. It&n; * extends ramfs by the ability to use swap and honor resource limits&n; * which makes it a completely usable filesystem.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/shmem_fs.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* This magic number is used in glibc for posix shared memory */
DECL|macro|TMPFS_MAGIC
mdefine_line|#define TMPFS_MAGIC&t;0x01021994
DECL|macro|ENTRIES_PER_PAGE
mdefine_line|#define ENTRIES_PER_PAGE (PAGE_CACHE_SIZE/sizeof(unsigned long))
DECL|macro|ENTRIES_PER_PAGEPAGE
mdefine_line|#define ENTRIES_PER_PAGEPAGE (ENTRIES_PER_PAGE*ENTRIES_PER_PAGE)
DECL|macro|BLOCKS_PER_PAGE
mdefine_line|#define BLOCKS_PER_PAGE  (PAGE_CACHE_SIZE/512)
DECL|macro|SHMEM_MAX_INDEX
mdefine_line|#define SHMEM_MAX_INDEX  (SHMEM_NR_DIRECT + (ENTRIES_PER_PAGEPAGE/2) * (ENTRIES_PER_PAGE+1))
DECL|macro|SHMEM_MAX_BYTES
mdefine_line|#define SHMEM_MAX_BYTES  ((unsigned long long)SHMEM_MAX_INDEX &lt;&lt; PAGE_CACHE_SHIFT)
DECL|macro|VM_ACCT
mdefine_line|#define VM_ACCT(size)    (PAGE_CACHE_ALIGN(size) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* Pretend that each entry is of this size in directory&squot;s i_size */
DECL|macro|BOGO_DIRENT_SIZE
mdefine_line|#define BOGO_DIRENT_SIZE 20
multiline_comment|/* Keep swapped page count in private field of indirect struct page */
DECL|macro|nr_swapped
mdefine_line|#define nr_swapped&t;&t;private
multiline_comment|/* Flag allocation requirements to shmem_getpage and shmem_swp_alloc */
DECL|enum|sgp_type
r_enum
id|sgp_type
(brace
DECL|enumerator|SGP_QUICK
id|SGP_QUICK
comma
multiline_comment|/* don&squot;t try more than file page cache lookup */
DECL|enumerator|SGP_READ
id|SGP_READ
comma
multiline_comment|/* don&squot;t exceed i_size, don&squot;t allocate page */
DECL|enumerator|SGP_CACHE
id|SGP_CACHE
comma
multiline_comment|/* don&squot;t exceed i_size, may allocate page */
DECL|enumerator|SGP_WRITE
id|SGP_WRITE
comma
multiline_comment|/* may exceed i_size, may allocate page */
)brace
suffix:semicolon
r_static
r_int
id|shmem_getpage
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|idx
comma
r_struct
id|page
op_star
op_star
id|pagep
comma
r_enum
id|sgp_type
id|sgp
)paren
suffix:semicolon
DECL|function|shmem_dir_alloc
r_static
r_inline
r_struct
id|page
op_star
id|shmem_dir_alloc
c_func
(paren
r_int
r_int
id|gfp_mask
)paren
(brace
multiline_comment|/*&n;&t; * The above definition of ENTRIES_PER_PAGE, and the use of&n;&t; * BLOCKS_PER_PAGE on indirect pages, assume PAGE_CACHE_SIZE:&n;&t; * might be reconsidered if it ever diverges from PAGE_SIZE.&n;&t; */
r_return
id|alloc_pages
c_func
(paren
id|gfp_mask
comma
id|PAGE_CACHE_SHIFT
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
DECL|function|shmem_dir_free
r_static
r_inline
r_void
id|shmem_dir_free
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|__free_pages
c_func
(paren
id|page
comma
id|PAGE_CACHE_SHIFT
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
DECL|function|shmem_dir_map
r_static
r_struct
id|page
op_star
op_star
id|shmem_dir_map
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
(paren
r_struct
id|page
op_star
op_star
)paren
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
DECL|function|shmem_dir_unmap
r_static
r_inline
r_void
id|shmem_dir_unmap
c_func
(paren
r_struct
id|page
op_star
op_star
id|dir
)paren
(brace
id|kunmap_atomic
c_func
(paren
id|dir
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
DECL|function|shmem_swp_map
r_static
id|swp_entry_t
op_star
id|shmem_swp_map
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/*&n;&t; * We have to avoid the unconditional inc_preempt_count()&n;&t; * in kmap_atomic(), since shmem_swp_unmap() will also be&n;&t; * applied to the low memory addresses within i_direct[].&n;&t; * PageHighMem and high_memory tests are good for all arches&n;&t; * and configs: highmem_start_page and FIXADDR_START are not.&n;&t; */
r_return
id|PageHighMem
c_func
(paren
id|page
)paren
ques
c_cond
(paren
id|swp_entry_t
op_star
)paren
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER1
)paren
suffix:colon
(paren
id|swp_entry_t
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|shmem_swp_unmap
r_static
r_inline
r_void
id|shmem_swp_unmap
c_func
(paren
id|swp_entry_t
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry
op_ge
(paren
id|swp_entry_t
op_star
)paren
id|high_memory
)paren
id|kunmap_atomic
c_func
(paren
id|entry
comma
id|KM_USER1
)paren
suffix:semicolon
)brace
DECL|function|SHMEM_SB
r_static
r_inline
r_struct
id|shmem_sb_info
op_star
id|SHMEM_SB
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_return
id|sb-&gt;s_fs_info
suffix:semicolon
)brace
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
suffix:semicolon
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
suffix:semicolon
DECL|variable|shmem_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_vm_ops
suffix:semicolon
DECL|variable|shmem_backing_dev_info
r_static
r_struct
id|backing_dev_info
id|shmem_backing_dev_info
op_assign
(brace
dot
id|ra_pages
op_assign
l_int|0
comma
multiline_comment|/* No readahead */
dot
id|memory_backed
op_assign
l_int|1
comma
multiline_comment|/* Does not contribute to dirty memory */
)brace
suffix:semicolon
DECL|variable|shmem_inodes
id|LIST_HEAD
(paren
id|shmem_inodes
)paren
suffix:semicolon
DECL|variable|shmem_ilock
r_static
id|spinlock_t
id|shmem_ilock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|shmem_nrpages
id|atomic_t
id|shmem_nrpages
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Not used right now */
DECL|function|shmem_free_block
r_static
r_void
id|shmem_free_block
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|sbinfo-&gt;free_blocks
op_increment
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
id|BLOCKS_PER_PAGE
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_recalc_inode - recalculate the size of an inode&n; *&n; * @inode: inode to recalc&n; *&n; * We have to calculate the free blocks since the mm can drop&n; * undirtied hole pages behind our back.&n; *&n; * But normally   info-&gt;alloced == inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped&n; * So mm freed is info-&gt;alloced - (inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped)&n; *&n; * It has to be called with the spinlock held.&n; */
DECL|function|shmem_recalc_inode
r_static
r_void
id|shmem_recalc_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|freed
suffix:semicolon
id|freed
op_assign
id|info-&gt;alloced
op_minus
id|info-&gt;swapped
op_minus
id|inode-&gt;i_mapping-&gt;nrpages
suffix:semicolon
r_if
c_cond
(paren
id|freed
OG
l_int|0
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|info-&gt;alloced
op_sub_assign
id|freed
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|sbinfo-&gt;free_blocks
op_add_assign
id|freed
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
id|freed
op_star
id|BLOCKS_PER_PAGE
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * shmem_swp_entry - find the swap vector position in the info structure&n; *&n; * @info:  info structure for the inode&n; * @index: index of the page to find&n; * @page:  optional page to add to the structure. Has to be preset to&n; *         all zeros&n; *&n; * If there is no space allocated yet it will return NULL when&n; * page is NULL, else it will use the page for the needed block,&n; * setting it to NULL on return to indicate that it has been used.&n; *&n; * The swap vector is organized the following way:&n; *&n; * There are SHMEM_NR_DIRECT entries directly stored in the&n; * shmem_inode_info structure. So small files do not need an addional&n; * allocation.&n; *&n; * For pages with index &gt; SHMEM_NR_DIRECT there is the pointer&n; * i_indirect which points to a page which holds in the first half&n; * doubly indirect blocks, in the second half triple indirect blocks:&n; *&n; * For an artificial ENTRIES_PER_PAGE = 4 this would lead to the&n; * following layout (for SHMEM_NR_DIRECT == 16):&n; *&n; * i_indirect -&gt; dir --&gt; 16-19&n; * &t;      |&t;     +-&gt; 20-23&n; * &t;      |&n; * &t;      +--&gt;dir2 --&gt; 24-27&n; * &t;      |&t;       +-&gt; 28-31&n; * &t;      |&t;       +-&gt; 32-35&n; * &t;      |&t;       +-&gt; 36-39&n; * &t;      |&n; * &t;      +--&gt;dir3 --&gt; 40-43&n; * &t;       &t;       +-&gt; 44-47&n; * &t;      &t;       +-&gt; 48-51&n; * &t;      &t;       +-&gt; 52-55&n; */
DECL|function|shmem_swp_entry
r_static
id|swp_entry_t
op_star
id|shmem_swp_entry
c_func
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
r_int
r_int
id|index
comma
r_struct
id|page
op_star
op_star
id|page
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|page
op_star
op_star
id|dir
suffix:semicolon
r_struct
id|page
op_star
id|subdir
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SHMEM_NR_DIRECT
)paren
r_return
id|info-&gt;i_direct
op_plus
id|index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|info-&gt;i_indirect
op_assign
op_star
id|page
suffix:semicolon
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* need another page */
)brace
id|index
op_sub_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|offset
op_assign
id|index
op_mod
id|ENTRIES_PER_PAGE
suffix:semicolon
id|index
op_div_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|info-&gt;i_indirect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|ENTRIES_PER_PAGE
op_div
l_int|2
)paren
(brace
id|index
op_sub_assign
id|ENTRIES_PER_PAGE
op_div
l_int|2
suffix:semicolon
id|dir
op_add_assign
id|ENTRIES_PER_PAGE
op_div
l_int|2
op_plus
id|index
op_div
id|ENTRIES_PER_PAGE
suffix:semicolon
id|index
op_mod_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subdir
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
op_star
id|dir
op_assign
op_star
id|page
suffix:semicolon
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* need another page */
)brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|subdir
)paren
suffix:semicolon
)brace
id|dir
op_add_assign
id|index
suffix:semicolon
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subdir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
op_logical_neg
(paren
id|subdir
op_assign
op_star
id|page
)paren
)paren
(brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* need a page */
)brace
op_star
id|dir
op_assign
id|subdir
suffix:semicolon
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * With apologies... caller shmem_swp_alloc passes non-NULL&n;&t; * page (though perhaps NULL *page); and now we know that this&n;&t; * indirect page has been allocated, we can shortcut the final&n;&t; * kmap if we know it contains no swap entries, as is commonly&n;&t; * the case: return pointer to a 0 which doesn&squot;t need kmapping.&n;&t; */
r_return
(paren
id|page
op_logical_and
op_logical_neg
id|subdir-&gt;nr_swapped
)paren
ques
c_cond
(paren
id|swp_entry_t
op_star
)paren
op_amp
id|subdir-&gt;nr_swapped
suffix:colon
id|shmem_swp_map
c_func
(paren
id|subdir
)paren
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|shmem_swp_set
r_static
r_void
id|shmem_swp_set
c_func
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
id|swp_entry_t
op_star
id|entry
comma
r_int
r_int
id|value
)paren
(brace
r_int
id|incdec
op_assign
id|value
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|entry-&gt;val
op_assign
id|value
suffix:semicolon
id|info-&gt;swapped
op_add_assign
id|incdec
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
(paren
id|entry
op_minus
id|info-&gt;i_direct
)paren
op_ge
id|SHMEM_NR_DIRECT
)paren
id|kmap_atomic_to_page
c_func
(paren
id|entry
)paren
op_member_access_from_pointer
id|nr_swapped
op_add_assign
id|incdec
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_swp_alloc - get the position of the swap entry for the page.&n; *                   If it does not exist allocate the entry.&n; *&n; * @info:&t;info structure for the inode&n; * @index:&t;index of the page to find&n; * @sgp:&t;check and recheck i_size? skip allocation?&n; */
DECL|function|shmem_swp_alloc
r_static
id|swp_entry_t
op_star
id|shmem_swp_alloc
c_func
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
r_int
r_int
id|index
comma
r_enum
id|sgp_type
id|sgp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
op_amp
id|info-&gt;vfs_inode
suffix:semicolon
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
id|swp_entry_t
op_star
id|entry
suffix:semicolon
r_static
r_const
id|swp_entry_t
id|unswapped
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sgp
op_ne
id|SGP_WRITE
op_logical_and
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_ge
id|inode-&gt;i_size
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|entry
op_assign
id|shmem_swp_entry
c_func
(paren
id|info
comma
id|index
comma
op_amp
id|page
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sgp
op_eq
id|SGP_READ
)paren
r_return
(paren
id|swp_entry_t
op_star
)paren
op_amp
id|unswapped
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Test free_blocks against 1 not 0, since we have 1 data&n;&t;&t; * page (and perhaps indirect index pages) yet to allocate:&n;&t;&t; * a waste to allocate index if we cannot allocate data.&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbinfo-&gt;free_blocks
op_le
l_int|1
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOSPC
)paren
suffix:semicolon
)brace
id|sbinfo-&gt;free_blocks
op_decrement
suffix:semicolon
id|inode-&gt;i_blocks
op_add_assign
id|BLOCKS_PER_PAGE
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|page
op_assign
id|shmem_dir_alloc
c_func
(paren
id|inode-&gt;i_mapping-&gt;gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|clear_highpage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;nr_swapped
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|shmem_free_block
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sgp
op_ne
id|SGP_WRITE
op_logical_and
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_ge
id|inode-&gt;i_size
)paren
(brace
id|entry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;next_index
op_le
id|index
)paren
id|info-&gt;next_index
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
)paren
(brace
multiline_comment|/* another task gave its page, or truncated the file */
id|shmem_free_block
c_func
(paren
id|inode
)paren
suffix:semicolon
id|shmem_dir_free
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;next_index
op_le
id|index
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
id|info-&gt;next_index
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_free_swp - free some swap entries in a directory&n; *&n; * @dir:   pointer to the directory&n; * @edir:  pointer after last entry of the directory&n; */
DECL|function|shmem_free_swp
r_static
r_int
id|shmem_free_swp
c_func
(paren
id|swp_entry_t
op_star
id|dir
comma
id|swp_entry_t
op_star
id|edir
)paren
(brace
id|swp_entry_t
op_star
id|ptr
suffix:semicolon
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|dir
suffix:semicolon
id|ptr
OL
id|edir
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;val
)paren
(brace
id|free_swap_and_cache
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_star
id|ptr
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
id|freed
op_increment
suffix:semicolon
)brace
)brace
r_return
id|freed
suffix:semicolon
)brace
DECL|function|shmem_truncate
r_static
r_void
id|shmem_truncate
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_int
r_int
id|stage
suffix:semicolon
r_struct
id|page
op_star
op_star
id|dir
suffix:semicolon
r_struct
id|page
op_star
id|subdir
suffix:semicolon
r_struct
id|page
op_star
id|empty
suffix:semicolon
id|swp_entry_t
op_star
id|ptr
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|freed
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|idx
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|info-&gt;next_index
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|limit
op_assign
id|info-&gt;next_index
suffix:semicolon
id|info-&gt;next_index
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;swapped
op_logical_and
id|idx
OL
id|SHMEM_NR_DIRECT
)paren
(brace
id|ptr
op_assign
id|info-&gt;i_direct
suffix:semicolon
id|size
op_assign
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|SHMEM_NR_DIRECT
)paren
id|size
op_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|info-&gt;swapped
op_sub_assign
id|shmem_free_swp
c_func
(paren
id|ptr
op_plus
id|idx
comma
id|ptr
op_plus
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
r_goto
id|done2
suffix:semicolon
id|BUG_ON
c_func
(paren
id|limit
op_le
id|SHMEM_NR_DIRECT
)paren
suffix:semicolon
id|limit
op_sub_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|idx
op_assign
(paren
id|idx
OG
id|SHMEM_NR_DIRECT
)paren
ques
c_cond
(paren
id|idx
op_minus
id|SHMEM_NR_DIRECT
)paren
suffix:colon
l_int|0
suffix:semicolon
id|offset
op_assign
id|idx
op_mod
id|ENTRIES_PER_PAGE
suffix:semicolon
id|idx
op_sub_assign
id|offset
suffix:semicolon
id|empty
op_assign
l_int|NULL
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|info-&gt;i_indirect
)paren
suffix:semicolon
id|stage
op_assign
id|ENTRIES_PER_PAGEPAGE
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
id|ENTRIES_PER_PAGEPAGE
op_div
l_int|2
)paren
id|dir
op_add_assign
id|idx
op_div
id|ENTRIES_PER_PAGE
suffix:semicolon
r_else
(brace
id|dir
op_add_assign
id|ENTRIES_PER_PAGE
op_div
l_int|2
suffix:semicolon
id|dir
op_add_assign
(paren
id|idx
op_minus
id|ENTRIES_PER_PAGEPAGE
op_div
l_int|2
)paren
op_div
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_while
c_loop
(paren
id|stage
op_le
id|idx
)paren
id|stage
op_add_assign
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dir
)paren
(brace
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
id|size
op_assign
(paren
(paren
id|idx
op_minus
id|ENTRIES_PER_PAGEPAGE
op_div
l_int|2
)paren
op_mod
id|ENTRIES_PER_PAGEPAGE
)paren
op_div
id|ENTRIES_PER_PAGE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
op_logical_and
op_logical_neg
id|offset
)paren
(brace
id|empty
op_assign
id|subdir
suffix:semicolon
op_star
id|dir
op_assign
l_int|NULL
suffix:semicolon
)brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|subdir
)paren
op_plus
id|size
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
id|stage
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|idx
OL
id|limit
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGE
comma
id|dir
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|idx
op_eq
id|stage
)paren
)paren
(brace
id|shmem_dir_unmap
c_func
(paren
id|dir
op_minus
l_int|1
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|info-&gt;i_indirect
)paren
op_plus
id|ENTRIES_PER_PAGE
op_div
l_int|2
op_plus
id|idx
op_div
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
op_star
id|dir
)paren
(brace
id|dir
op_increment
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|limit
)paren
r_goto
id|done1
suffix:semicolon
)brace
id|stage
op_assign
id|idx
op_plus
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
op_star
id|dir
op_assign
l_int|NULL
suffix:semicolon
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
(brace
id|shmem_dir_free
c_func
(paren
id|empty
)paren
suffix:semicolon
id|info-&gt;alloced
op_increment
suffix:semicolon
)brace
id|empty
op_assign
id|subdir
suffix:semicolon
id|cond_resched_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|subdir
)paren
suffix:semicolon
)brace
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|subdir
op_logical_and
id|subdir-&gt;nr_swapped
)paren
(brace
id|ptr
op_assign
id|shmem_swp_map
c_func
(paren
id|subdir
)paren
suffix:semicolon
id|size
op_assign
id|limit
op_minus
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|ENTRIES_PER_PAGE
)paren
id|size
op_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
id|freed
op_assign
id|shmem_free_swp
c_func
(paren
id|ptr
op_plus
id|offset
comma
id|ptr
op_plus
id|size
)paren
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|info-&gt;swapped
op_sub_assign
id|freed
suffix:semicolon
id|subdir-&gt;nr_swapped
op_sub_assign
id|freed
suffix:semicolon
id|BUG_ON
c_func
(paren
id|subdir-&gt;nr_swapped
OG
id|offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|subdir
)paren
(brace
op_star
id|dir
op_assign
l_int|NULL
suffix:semicolon
id|shmem_dir_free
c_func
(paren
id|subdir
)paren
suffix:semicolon
id|info-&gt;alloced
op_increment
suffix:semicolon
)brace
)brace
id|done1
suffix:colon
id|shmem_dir_unmap
c_func
(paren
id|dir
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
(brace
id|shmem_dir_free
c_func
(paren
id|empty
)paren
suffix:semicolon
id|info-&gt;alloced
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;next_index
op_le
id|SHMEM_NR_DIRECT
)paren
(brace
id|shmem_dir_free
c_func
(paren
id|info-&gt;i_indirect
)paren
suffix:semicolon
id|info-&gt;i_indirect
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;alloced
op_increment
suffix:semicolon
)brace
id|done2
suffix:colon
id|BUG_ON
c_func
(paren
id|info-&gt;swapped
OG
id|info-&gt;next_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_mapping-&gt;nrpages
)paren
(brace
multiline_comment|/*&n;&t;&t; * Call truncate_inode_pages again: racing shmem_unuse_inode&n;&t;&t; * may have swizzled a page in from swap since vmtruncate or&n;&t;&t; * generic_delete_inode did it, before we lowered next_index.&n;&t;&t; */
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|inode-&gt;i_mapping
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|shmem_notify_change
r_static
r_int
id|shmem_notify_change
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|change
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
op_logical_and
(paren
id|attr-&gt;ia_size
op_le
id|SHMEM_MAX_BYTES
)paren
)paren
(brace
multiline_comment|/*&n;&t; &t; * Account swap file usage based on new file size,&n;&t;&t; * but just let vmtruncate fail on out-of-range sizes.&n;&t; &t; */
id|change
op_assign
id|VM_ACCT
c_func
(paren
id|attr-&gt;ia_size
)paren
op_minus
id|VM_ACCT
c_func
(paren
id|inode-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|change
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|change
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|attr-&gt;ia_size
OL
id|inode-&gt;i_size
)paren
(brace
id|vm_unacct_memory
c_func
(paren
op_minus
id|change
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If truncating down to a partial page, then&n;&t;&t;&t; * if that page is already allocated, hold it&n;&t;&t;&t; * in memory until the truncation is over, so&n;&t;&t;&t; * truncate_partial_page cannnot miss it were&n;&t;&t;&t; * it assigned to swap.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|attr-&gt;ia_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
(paren
r_void
)paren
id|shmem_getpage
c_func
(paren
id|inode
comma
id|attr-&gt;ia_size
op_rshift
id|PAGE_CACHE_SHIFT
comma
op_amp
id|page
comma
id|SGP_READ
)paren
suffix:semicolon
)brace
)brace
)brace
id|error
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|vm_unacct_memory
c_func
(paren
id|change
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_delete_inode
r_static
r_void
id|shmem_delete_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;truncate
op_eq
id|shmem_truncate
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|info-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|VM_ACCOUNT
)paren
id|vm_unacct_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
id|inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|shmem_truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|inode-&gt;i_blocks
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|sbinfo-&gt;free_inodes
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|shmem_find_swp
r_static
r_inline
r_int
id|shmem_find_swp
c_func
(paren
id|swp_entry_t
id|entry
comma
id|swp_entry_t
op_star
id|dir
comma
id|swp_entry_t
op_star
id|edir
)paren
(brace
id|swp_entry_t
op_star
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|dir
suffix:semicolon
id|ptr
OL
id|edir
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;val
op_eq
id|entry.val
)paren
r_return
id|ptr
op_minus
id|dir
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|shmem_unuse_inode
r_static
r_int
id|shmem_unuse_inode
c_func
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_int
r_int
id|stage
suffix:semicolon
r_struct
id|page
op_star
op_star
id|dir
suffix:semicolon
r_struct
id|page
op_star
id|subdir
suffix:semicolon
id|swp_entry_t
op_star
id|ptr
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
id|info-&gt;i_direct
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|limit
op_assign
id|info-&gt;next_index
suffix:semicolon
id|size
op_assign
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|SHMEM_NR_DIRECT
)paren
id|size
op_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|offset
op_assign
id|shmem_find_swp
c_func
(paren
id|entry
comma
id|ptr
comma
id|ptr
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
l_int|0
)paren
r_goto
id|found
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
r_goto
id|lost2
suffix:semicolon
multiline_comment|/* we might be racing with shmem_truncate */
r_if
c_cond
(paren
id|limit
op_le
id|SHMEM_NR_DIRECT
)paren
r_goto
id|lost2
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|info-&gt;i_indirect
)paren
suffix:semicolon
id|stage
op_assign
id|SHMEM_NR_DIRECT
op_plus
id|ENTRIES_PER_PAGEPAGE
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
id|idx
OL
id|limit
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGE
comma
id|dir
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|idx
op_eq
id|stage
)paren
)paren
(brace
id|shmem_dir_unmap
c_func
(paren
id|dir
op_minus
l_int|1
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|info-&gt;i_indirect
)paren
op_plus
id|ENTRIES_PER_PAGE
op_div
l_int|2
op_plus
id|idx
op_div
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
op_star
id|dir
)paren
(brace
id|dir
op_increment
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|limit
)paren
r_goto
id|lost1
suffix:semicolon
)brace
id|stage
op_assign
id|idx
op_plus
id|ENTRIES_PER_PAGEPAGE
suffix:semicolon
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|shmem_dir_map
c_func
(paren
id|subdir
)paren
suffix:semicolon
)brace
id|subdir
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|subdir
op_logical_and
id|subdir-&gt;nr_swapped
)paren
(brace
id|ptr
op_assign
id|shmem_swp_map
c_func
(paren
id|subdir
)paren
suffix:semicolon
id|size
op_assign
id|limit
op_minus
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|ENTRIES_PER_PAGE
)paren
id|size
op_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
id|offset
op_assign
id|shmem_find_swp
c_func
(paren
id|entry
comma
id|ptr
comma
id|ptr
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
l_int|0
)paren
(brace
id|shmem_dir_unmap
c_func
(paren
id|dir
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
id|shmem_swp_unmap
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
)brace
id|lost1
suffix:colon
id|shmem_dir_unmap
c_func
(paren
id|dir
op_minus
l_int|1
)paren
suffix:semicolon
id|lost2
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|move_from_swap_cache
c_func
(paren
id|page
comma
id|idx
op_plus
id|offset
comma
id|info-&gt;vfs_inode.i_mapping
)paren
op_eq
l_int|0
)paren
id|shmem_swp_set
c_func
(paren
id|info
comma
id|ptr
op_plus
id|offset
comma
l_int|0
)paren
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decrement swap count even when the entry is left behind:&n;&t; * try_to_unuse will skip over mms, then reincrement count.&n;&t; */
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_unuse() search for an eventually swapped out shmem page.&n; */
DECL|function|shmem_unuse
r_int
id|shmem_unuse
c_func
(paren
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|shmem_inodes
)paren
(brace
id|info
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|shmem_inode_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;swapped
op_logical_and
id|shmem_unuse_inode
c_func
(paren
id|info
comma
id|entry
comma
id|page
)paren
)paren
(brace
multiline_comment|/* move head to start search for next from here */
id|list_move_tail
c_func
(paren
op_amp
id|shmem_inodes
comma
op_amp
id|info-&gt;list
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Move the page from the page cache to the swap cache.&n; */
DECL|function|shmem_writepage
r_static
r_int
id|shmem_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
id|swp_entry_t
op_star
id|entry
comma
id|swap
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|page_mapped
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|index
op_assign
id|page-&gt;index
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|VM_LOCKED
)paren
r_goto
id|redirty
suffix:semicolon
id|swap
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap.val
)paren
r_goto
id|redirty
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|index
op_ge
id|info-&gt;next_index
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_entry
c_func
(paren
id|info
comma
id|index
comma
l_int|NULL
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|entry
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|entry-&gt;val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|move_to_swap_cache
c_func
(paren
id|page
comma
id|swap
)paren
op_eq
l_int|0
)paren
(brace
id|shmem_swp_set
c_func
(paren
id|info
comma
id|entry
comma
id|swap.val
)paren
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|swap
)paren
suffix:semicolon
id|redirty
suffix:colon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|WRITEPAGE_ACTIVATE
suffix:semicolon
multiline_comment|/* Return with the page locked */
)brace
multiline_comment|/*&n; * shmem_getpage - either get the page from swap or allocate a new one&n; *&n; * If we allocate a new one we do not mark it dirty. That&squot;s up to the&n; * vm. If we swap it in we mark it dirty since we also free the swap&n; * entry since a page cannot live in both the swap and page cache&n; */
DECL|function|shmem_getpage
r_static
r_int
id|shmem_getpage
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|idx
comma
r_struct
id|page
op_star
op_star
id|pagep
comma
r_enum
id|sgp_type
id|sgp
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|shmem_sb_info
op_star
id|sbinfo
suffix:semicolon
r_struct
id|page
op_star
id|filepage
op_assign
op_star
id|pagep
suffix:semicolon
r_struct
id|page
op_star
id|swappage
suffix:semicolon
id|swp_entry_t
op_star
id|entry
suffix:semicolon
id|swp_entry_t
id|swap
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|SHMEM_MAX_INDEX
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
multiline_comment|/*&n;&t; * Normally, filepage is NULL on entry, and either found&n;&t; * uptodate immediately, or allocated and zeroed, or read&n;&t; * in under swappage, which is then assigned to filepage.&n;&t; * But shmem_prepare_write passes in a locked filepage,&n;&t; * which may be found not uptodate by other callers too,&n;&t; * and may need to be copied from the swappage read in.&n;&t; */
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|filepage
)paren
id|filepage
op_assign
id|find_lock_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filepage
op_logical_and
id|PageUptodate
c_func
(paren
id|filepage
)paren
)paren
r_goto
id|done
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sgp
op_eq
id|SGP_QUICK
)paren
r_goto
id|failed
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|shmem_recalc_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_alloc
c_func
(paren
id|info
comma
id|idx
comma
id|sgp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|swap
op_assign
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|swap.val
)paren
(brace
multiline_comment|/* Look it up and read it in.. */
id|swappage
op_assign
id|lookup_swap_cache
c_func
(paren
id|swap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swappage
)paren
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|swapin_readahead
c_func
(paren
id|swap
)paren
suffix:semicolon
id|swappage
op_assign
id|read_swap_cache_async
c_func
(paren
id|swap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swappage
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_alloc
c_func
(paren
id|info
comma
id|idx
comma
id|sgp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|entry-&gt;val
op_eq
id|swap.val
)paren
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|failed
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|wait_on_page_locked
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* We have to do this with page locked to prevent races */
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|swappage
)paren
)paren
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|wait_on_page_locked
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|swappage
)paren
)paren
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|swappage
)paren
)paren
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filepage
)paren
(brace
id|shmem_swp_set
c_func
(paren
id|info
comma
id|entry
comma
l_int|0
)paren
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|delete_from_swap_cache
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|copy_highpage
c_func
(paren
id|filepage
comma
id|swappage
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|swap
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|move_from_swap_cache
c_func
(paren
id|swappage
comma
id|idx
comma
id|mapping
)paren
)paren
)paren
(brace
id|shmem_swp_set
c_func
(paren
id|info
comma
id|entry
comma
l_int|0
)paren
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|filepage
op_assign
id|swappage
suffix:semicolon
id|swap_free
c_func
(paren
id|swap
)paren
suffix:semicolon
)brace
r_else
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|swappage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|swappage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOMEM
)paren
(brace
multiline_comment|/* let kswapd refresh zone for GFP_ATOMICs */
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sgp
op_eq
id|SGP_READ
op_logical_and
op_logical_neg
id|filepage
)paren
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|filepage
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filepage
op_logical_and
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|filepage
)paren
op_logical_or
id|TestSetPageLocked
c_func
(paren
id|filepage
)paren
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|wait_on_page_locked
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|filepage
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbinfo-&gt;free_blocks
op_eq
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|sbinfo-&gt;free_blocks
op_decrement
suffix:semicolon
id|inode-&gt;i_blocks
op_add_assign
id|BLOCKS_PER_PAGE
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filepage
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|filepage
op_assign
id|page_cache_alloc
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filepage
)paren
(brace
id|shmem_free_block
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_alloc
c_func
(paren
id|info
comma
id|idx
comma
id|sgp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|entry
)paren
)paren
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
(brace
id|swap
op_assign
op_star
id|entry
suffix:semicolon
id|shmem_swp_unmap
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_logical_or
id|swap.val
op_logical_or
l_int|0
op_ne
id|add_to_page_cache_lru
c_func
(paren
id|filepage
comma
id|mapping
comma
id|idx
comma
id|GFP_ATOMIC
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|shmem_free_block
c_func
(paren
id|inode
)paren
suffix:semicolon
id|filepage
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|failed
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|info-&gt;alloced
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|clear_highpage
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|filepage
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
op_star
id|pagep
)paren
(brace
r_if
c_cond
(paren
id|filepage
)paren
(brace
id|unlock_page
c_func
(paren
id|filepage
)paren
suffix:semicolon
op_star
id|pagep
op_assign
id|filepage
suffix:semicolon
)brace
r_else
op_star
id|pagep
op_assign
id|ZERO_PAGE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
r_if
c_cond
(paren
op_star
id|pagep
op_ne
id|filepage
)paren
(brace
id|unlock_page
c_func
(paren
id|filepage
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|filepage
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_nopage
r_struct
id|page
op_star
id|shmem_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|unused
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_int
id|error
suffix:semicolon
id|idx
op_assign
(paren
id|address
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|idx
op_add_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|idx
op_rshift_assign
id|PAGE_CACHE_SHIFT
op_minus
id|PAGE_SHIFT
suffix:semicolon
id|error
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
id|idx
comma
op_amp
id|page
comma
id|SGP_CACHE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
op_eq
op_minus
id|ENOMEM
)paren
ques
c_cond
id|NOPAGE_OOM
suffix:colon
id|NOPAGE_SIGBUS
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|function|shmem_populate
r_static
r_int
id|shmem_populate
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
id|pgprot_t
id|prot
comma
r_int
r_int
id|pgoff
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_enum
id|sgp_type
id|sgp
op_assign
id|nonblock
ques
c_cond
id|SGP_QUICK
suffix:colon
id|SGP_CACHE
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|pgoff
op_ge
id|size
op_logical_or
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
OG
id|size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|len
OG
l_int|0
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Will need changing if PAGE_CACHE_SIZE != PAGE_SIZE&n;&t;&t; */
id|err
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
id|pgoff
comma
op_amp
id|page
comma
id|sgp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
id|install_page
c_func
(paren
id|mm
comma
id|vma
comma
id|addr
comma
id|page
comma
id|prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pgoff
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_lock
r_void
id|shmem_lock
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|lock
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|info-&gt;flags
op_or_assign
id|VM_LOCKED
suffix:semicolon
r_else
id|info-&gt;flags
op_and_assign
op_complement
id|VM_LOCKED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|shmem_mmap
r_static
r_int
id|shmem_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_operations_struct
op_star
id|ops
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|ops
op_assign
op_amp
id|shmem_vm_ops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
id|ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|inode
op_star
DECL|function|shmem_get_inode
id|shmem_get_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbinfo-&gt;free_inodes
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sbinfo-&gt;free_inodes
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|NODEV
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|shmem_aops
suffix:semicolon
id|inode-&gt;i_mapping-&gt;backing_dev_info
op_assign
op_amp
id|shmem_backing_dev_info
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|inode
op_minus
(paren
r_char
op_star
)paren
id|info
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|info-&gt;flags
op_assign
id|VM_ACCOUNT
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_default
suffix:colon
id|init_special_inode
c_func
(paren
id|inode
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|info-&gt;list
comma
op_amp
id|shmem_inodes
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
multiline_comment|/* Some things misbehave if size == 0 on a directory */
id|inode-&gt;i_size
op_assign
l_int|2
op_star
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|simple_dir_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
id|inode
suffix:semicolon
)brace
DECL|function|shmem_set_size
r_static
r_int
id|shmem_set_size
c_func
(paren
r_struct
id|shmem_sb_info
op_star
id|info
comma
r_int
r_int
id|max_blocks
comma
r_int
r_int
id|max_inodes
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|blocks
comma
id|inodes
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|blocks
op_assign
id|info-&gt;max_blocks
op_minus
id|info-&gt;free_blocks
suffix:semicolon
id|inodes
op_assign
id|info-&gt;max_inodes
op_minus
id|info-&gt;free_inodes
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|max_blocks
OL
id|blocks
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|max_inodes
OL
id|inodes
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|info-&gt;max_blocks
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;free_blocks
op_assign
id|max_blocks
op_minus
id|blocks
suffix:semicolon
id|info-&gt;max_inodes
op_assign
id|max_inodes
suffix:semicolon
id|info-&gt;free_inodes
op_assign
id|max_inodes
op_minus
id|inodes
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TMPFS
DECL|variable|shmem_symlink_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inode_operations
suffix:semicolon
DECL|variable|shmem_symlink_inline_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inline_operations
suffix:semicolon
multiline_comment|/*&n; * Normally tmpfs makes no use of shmem_prepare_write, but it&n; * lets a tmpfs file be used read-write below the loop driver.&n; */
r_static
r_int
DECL|function|shmem_prepare_write
id|shmem_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_return
id|shmem_getpage
c_func
(paren
id|inode
comma
id|page-&gt;index
comma
op_amp
id|page
comma
id|SGP_WRITE
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|shmem_file_write
id|shmem_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
id|err
suffix:semicolon
id|loff_t
id|maxpos
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|generic_write_checks
c_func
(paren
id|inode
comma
id|file
comma
op_amp
id|pos
comma
op_amp
id|count
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
op_logical_neg
id|count
)paren
r_goto
id|out
suffix:semicolon
id|maxpos
op_assign
id|inode-&gt;i_size
suffix:semicolon
r_if
c_cond
(paren
id|maxpos
OL
id|pos
op_plus
id|count
)paren
(brace
id|maxpos
op_assign
id|pos
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
id|maxpos
)paren
op_minus
id|VM_ACCT
c_func
(paren
id|inode-&gt;i_size
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|remove_suid
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|bytes
comma
id|index
comma
id|offset
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|left
suffix:semicolon
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
id|bytes
op_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t hold page lock across copy from user -&n;&t;&t; * what would it guard against? - so no deadlock here.&n;&t;&t; * But it still may be a good idea to prefault below.&n;&t;&t; */
id|err
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
id|index
comma
op_amp
id|page
comma
id|SGP_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|left
op_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|page
)paren
)paren
(brace
r_volatile
r_int
r_char
id|dummy
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
)paren
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
op_plus
id|bytes
op_minus
l_int|1
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|left
op_assign
id|__copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
(brace
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|left
op_assign
id|__copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageReferenced
c_func
(paren
id|page
)paren
)paren
id|SetPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Our dirty pages are not counted in nr_dirty,&n;&t;&t; * and we do not attempt to balance dirty pages.&n;&t;&t; */
id|written
op_add_assign
id|bytes
suffix:semicolon
id|count
op_sub_assign
id|bytes
suffix:semicolon
id|pos
op_add_assign
id|bytes
suffix:semicolon
id|buf
op_add_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|written
)paren
id|err
op_assign
id|written
suffix:semicolon
multiline_comment|/* Short writes give back address space */
r_if
c_cond
(paren
id|inode-&gt;i_size
op_ne
id|maxpos
)paren
id|vm_unacct_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
id|maxpos
)paren
op_minus
id|VM_ACCT
c_func
(paren
id|inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|do_shmem_file_read
r_static
r_void
id|do_shmem_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|ppos
comma
id|read_descriptor_t
op_star
id|desc
comma
id|read_actor_t
id|actor
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
id|index
op_assign
op_star
id|ppos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
op_star
id|ppos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|end_index
comma
id|nr
comma
id|ret
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|end_index
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|end_index
)paren
(brace
id|nr
op_assign
id|inode-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|offset
)paren
r_break
suffix:semicolon
)brace
id|desc-&gt;error
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
id|index
comma
op_amp
id|page
comma
id|SGP_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;error
)paren
(brace
r_if
c_cond
(paren
id|desc-&gt;error
op_eq
op_minus
id|EINVAL
)paren
id|desc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We must evaluate after, since reads (unlike writes)&n;&t;&t; * are called without i_sem protection against truncate&n;&t;&t; */
id|nr
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|end_index
)paren
(brace
id|nr
op_assign
id|inode-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|offset
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|nr
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|page
op_ne
id|ZERO_PAGE
c_func
(paren
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If users can be writing to this page using arbitrary&n;&t;&t;&t; * virtual addresses, take care about potential aliasing&n;&t;&t;&t; * before reading the page on the kernel side.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_shared
)paren
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mark the page accessed if we read the beginning.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ok, we have the page, and it&squot;s up-to-date, so&n;&t;&t; * now we can copy it to user space...&n;&t;&t; *&n;&t;&t; * The actor routine returns how many bytes were actually used..&n;&t;&t; * NOTE! This may not be the same as how much of a user buffer&n;&t;&t; * we filled up (we may be padding etc), so we can only update&n;&t;&t; * &quot;pos&quot; here (the actor routine has to update the user buffer&n;&t;&t; * pointers and the remaining count).&n;&t;&t; */
id|ret
op_assign
id|actor
c_func
(paren
id|desc
comma
id|page
comma
id|offset
comma
id|nr
)paren
suffix:semicolon
id|offset
op_add_assign
id|ret
suffix:semicolon
id|index
op_add_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|nr
op_logical_or
op_logical_neg
id|desc-&gt;count
)paren
r_break
suffix:semicolon
)brace
op_star
id|ppos
op_assign
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|offset
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|shmem_file_read
r_static
id|ssize_t
id|shmem_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|buf
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_shmem_file_read
c_func
(paren
id|filp
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_read_actor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc.written
)paren
r_return
id|desc.written
suffix:semicolon
r_return
id|desc.error
suffix:semicolon
)brace
DECL|function|shmem_file_sendfile
r_static
id|ssize_t
id|shmem_file_sendfile
c_func
(paren
r_struct
id|file
op_star
id|in_file
comma
id|loff_t
op_star
id|ppos
comma
r_int
id|count
comma
id|read_actor_t
id|actor
comma
r_void
op_star
id|target
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|target
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_shmem_file_read
c_func
(paren
id|in_file
comma
id|ppos
comma
op_amp
id|desc
comma
id|actor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc.written
)paren
r_return
id|desc.written
suffix:semicolon
r_return
id|desc.error
suffix:semicolon
)brace
DECL|function|shmem_statfs
r_static
r_int
id|shmem_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|buf-&gt;f_type
op_assign
id|TMPFS_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|buf-&gt;f_blocks
op_assign
id|sbinfo-&gt;max_blocks
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
op_assign
id|sbinfo-&gt;free_blocks
suffix:semicolon
id|buf-&gt;f_files
op_assign
id|sbinfo-&gt;max_inodes
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
id|sbinfo-&gt;free_inodes
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
id|NAME_MAX
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * File creation. Allocate an inode, and we&squot;re done..&n; */
r_static
r_int
DECL|function|shmem_mknod
id|shmem_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|dir-&gt;i_size
op_add_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra count - pin the dentry in core */
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_mkdir
r_static
r_int
id|shmem_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFDIR
comma
l_int|0
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|dir-&gt;i_nlink
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_create
r_static
r_int
id|shmem_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_return
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFREG
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Link a file..&n; */
DECL|function|shmem_link
r_static
r_int
id|shmem_link
c_func
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
id|dir-&gt;i_size
op_add_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
multiline_comment|/* New dentry reference */
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra pinning count for the created dentry */
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_unlink
r_static
r_int
id|shmem_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|dir-&gt;i_size
op_sub_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Undo the count from &quot;create&quot; - this does all the work */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_rmdir
r_static
r_int
id|shmem_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|simple_empty
c_func
(paren
id|dentry
)paren
)paren
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
id|dir-&gt;i_nlink
op_decrement
suffix:semicolon
r_return
id|shmem_unlink
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The VFS layer already does all the dentry stuff for rename,&n; * we just have to decrement the usage count for the target if&n; * it exists so that the VFS layer correctly free&squot;s it when it&n; * gets overwritten.&n; */
DECL|function|shmem_rename
r_static
r_int
id|shmem_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_int
id|they_are_dirs
op_assign
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|simple_empty
c_func
(paren
id|new_dentry
)paren
)paren
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|new_dentry-&gt;d_inode
)paren
(brace
(paren
r_void
)paren
id|shmem_unlink
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|they_are_dirs
)paren
id|old_dir-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|they_are_dirs
)paren
(brace
id|old_dir-&gt;i_nlink
op_decrement
suffix:semicolon
id|new_dir-&gt;i_nlink
op_increment
suffix:semicolon
)brace
id|old_dir-&gt;i_size
op_sub_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|new_dir-&gt;i_size
op_add_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|old_dir-&gt;i_ctime
op_assign
id|old_dir-&gt;i_mtime
op_assign
id|new_dir-&gt;i_ctime
op_assign
id|new_dir-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_symlink
r_static
r_int
id|shmem_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|symname
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|PAGE_CACHE_SIZE
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|S_IFLNK
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|info
op_assign
id|SHMEM_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
(paren
r_char
op_star
)paren
id|inode
op_minus
(paren
r_char
op_star
)paren
id|info
)paren
(brace
multiline_comment|/* do it inline */
id|memcpy
c_func
(paren
id|info
comma
id|symname
comma
id|len
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_symlink_inline_operations
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
l_int|1
)paren
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|error
op_assign
id|shmem_getpage
c_func
(paren
id|inode
comma
l_int|0
comma
op_amp
id|page
comma
id|SGP_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|vm_unacct_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_symlink_inode_operations
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|info-&gt;list
comma
op_amp
id|shmem_inodes
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|kaddr
comma
id|symname
comma
id|len
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|dir-&gt;i_size
op_add_assign
id|BOGO_DIRENT_SIZE
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_readlink_inline
r_static
r_int
id|shmem_readlink_inline
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_return
id|vfs_readlink
c_func
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
(paren
r_const
r_char
op_star
)paren
id|SHMEM_I
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|shmem_follow_link_inline
r_static
r_int
id|shmem_follow_link_inline
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_return
id|vfs_follow_link
c_func
(paren
id|nd
comma
(paren
r_const
r_char
op_star
)paren
id|SHMEM_I
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|shmem_readlink
r_static
r_int
id|shmem_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|res
op_assign
id|shmem_getpage
c_func
(paren
id|dentry-&gt;d_inode
comma
l_int|0
comma
op_amp
id|page
comma
id|SGP_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|vfs_readlink
c_func
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
id|kmap
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|shmem_follow_link
r_static
r_int
id|shmem_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|res
op_assign
id|shmem_getpage
c_func
(paren
id|dentry-&gt;d_inode
comma
l_int|0
comma
op_amp
id|page
comma
id|SGP_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|vfs_follow_link
c_func
(paren
id|nd
comma
id|kmap
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|variable|shmem_symlink_inline_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inline_operations
op_assign
(brace
dot
id|readlink
op_assign
id|shmem_readlink_inline
comma
dot
id|follow_link
op_assign
id|shmem_follow_link_inline
comma
)brace
suffix:semicolon
DECL|variable|shmem_symlink_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_symlink_inode_operations
op_assign
(brace
dot
id|truncate
op_assign
id|shmem_truncate
comma
dot
id|readlink
op_assign
id|shmem_readlink
comma
dot
id|follow_link
op_assign
id|shmem_follow_link
comma
)brace
suffix:semicolon
DECL|function|shmem_parse_options
r_static
r_int
id|shmem_parse_options
c_func
(paren
r_char
op_star
id|options
comma
r_int
op_star
id|mode
comma
id|uid_t
op_star
id|uid
comma
id|gid_t
op_star
id|gid
comma
r_int
r_int
op_star
id|blocks
comma
r_int
r_int
op_star
id|inodes
)paren
(brace
r_char
op_star
id|this_char
comma
op_star
id|value
comma
op_star
id|rest
suffix:semicolon
r_while
c_loop
(paren
(paren
id|this_char
op_assign
id|strsep
c_func
(paren
op_amp
id|options
comma
l_string|&quot;,&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|this_char
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
c_func
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tmpfs: No value for mount option &squot;%s&squot;&bslash;n&quot;
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;size&quot;
)paren
)paren
(brace
r_int
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|rest
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
op_star
id|blocks
op_assign
id|size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_blocks&quot;
)paren
)paren
(brace
op_star
id|blocks
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|rest
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_inodes&quot;
)paren
)paren
(brace
op_star
id|inodes
op_assign
id|memparse
c_func
(paren
id|value
comma
op_amp
id|rest
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;mode&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mode
)paren
r_continue
suffix:semicolon
op_star
id|mode
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|rest
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;uid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|uid
)paren
r_continue
suffix:semicolon
op_star
id|uid
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|rest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;gid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gid
)paren
r_continue
suffix:semicolon
op_star
id|gid
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|rest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rest
)paren
r_goto
id|bad_val
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tmpfs: Bad mount option %s&bslash;n&quot;
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|bad_val
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tmpfs: Bad value &squot;%s&squot; for mount option &squot;%s&squot;&bslash;n&quot;
comma
id|value
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|shmem_remount_fs
r_static
r_int
id|shmem_remount_fs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|sbinfo
op_assign
id|SHMEM_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|max_blocks
op_assign
id|sbinfo-&gt;max_blocks
suffix:semicolon
r_int
r_int
id|max_inodes
op_assign
id|sbinfo-&gt;max_inodes
suffix:semicolon
r_if
c_cond
(paren
id|shmem_parse_options
c_func
(paren
id|data
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|max_blocks
comma
op_amp
id|max_inodes
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|shmem_set_size
c_func
(paren
id|sbinfo
comma
id|max_blocks
comma
id|max_inodes
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|shmem_fill_super
r_static
r_int
id|shmem_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|root
suffix:semicolon
r_int
r_int
id|blocks
comma
id|inodes
suffix:semicolon
r_int
id|mode
op_assign
id|S_IRWXUGO
op_or
id|S_ISVTX
suffix:semicolon
id|uid_t
id|uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|gid_t
id|gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
r_struct
id|shmem_sb_info
op_star
id|sbinfo
suffix:semicolon
r_struct
id|sysinfo
id|si
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|sbinfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|shmem_sb_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbinfo
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sb-&gt;s_fs_info
op_assign
id|sbinfo
suffix:semicolon
id|memset
c_func
(paren
id|sbinfo
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|shmem_sb_info
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Per default we only allow half of the physical ram per&n;&t; * tmpfs instance&n;&t; */
id|si_meminfo
c_func
(paren
op_amp
id|si
)paren
suffix:semicolon
id|blocks
op_assign
id|inodes
op_assign
id|si.totalram
op_div
l_int|2
suffix:semicolon
macro_line|#ifdef CONFIG_TMPFS
r_if
c_cond
(paren
id|shmem_parse_options
c_func
(paren
id|data
comma
op_amp
id|mode
comma
op_amp
id|uid
comma
op_amp
id|gid
comma
op_amp
id|blocks
comma
op_amp
id|inodes
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
macro_line|#else
id|sb-&gt;s_flags
op_or_assign
id|MS_NOUSER
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|sbinfo-&gt;stat_lock
)paren
suffix:semicolon
id|sbinfo-&gt;max_blocks
op_assign
id|blocks
suffix:semicolon
id|sbinfo-&gt;free_blocks
op_assign
id|blocks
suffix:semicolon
id|sbinfo-&gt;max_inodes
op_assign
id|inodes
suffix:semicolon
id|sbinfo-&gt;free_inodes
op_assign
id|inodes
suffix:semicolon
id|sb-&gt;s_maxbytes
op_assign
id|SHMEM_MAX_BYTES
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|TMPFS_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|shmem_ops
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|sb
comma
id|S_IFDIR
op_or
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|failed
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|gid
suffix:semicolon
id|root
op_assign
id|d_alloc_root
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
r_goto
id|failed_iput
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|root
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed_iput
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|failed
suffix:colon
id|kfree
c_func
(paren
id|sbinfo
)paren
suffix:semicolon
id|sb-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|shmem_put_super
r_static
r_void
id|shmem_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|kfree
c_func
(paren
id|sb-&gt;s_fs_info
)paren
suffix:semicolon
id|sb-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|shmem_inode_cachep
r_static
id|kmem_cache_t
op_star
id|shmem_inode_cachep
suffix:semicolon
DECL|function|shmem_alloc_inode
r_static
r_struct
id|inode
op_star
id|shmem_alloc_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|shmem_inode_info
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|shmem_inode_info
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|shmem_inode_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|p-&gt;vfs_inode
suffix:semicolon
)brace
DECL|function|shmem_destroy_inode
r_static
r_void
id|shmem_destroy_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|shmem_inode_cachep
comma
id|SHMEM_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|shmem_inode_info
op_star
id|p
op_assign
(paren
r_struct
id|shmem_inode_info
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
(brace
id|inode_init_once
c_func
(paren
op_amp
id|p-&gt;vfs_inode
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_inodecache
r_static
r_int
id|init_inodecache
c_func
(paren
r_void
)paren
(brace
id|shmem_inode_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;shmem_inode_cache&quot;
comma
r_sizeof
(paren
r_struct
id|shmem_inode_info
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shmem_inode_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|destroy_inodecache
r_static
r_void
id|destroy_inodecache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|shmem_inode_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;shmem_inode_cache: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
op_assign
(brace
dot
id|writepage
op_assign
id|shmem_writepage
comma
dot
id|set_page_dirty
op_assign
id|__set_page_dirty_nobuffers
comma
macro_line|#ifdef CONFIG_TMPFS
dot
id|prepare_write
op_assign
id|shmem_prepare_write
comma
dot
id|commit_write
op_assign
id|simple_commit_write
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
op_assign
(brace
dot
id|mmap
op_assign
id|shmem_mmap
comma
macro_line|#ifdef CONFIG_TMPFS
dot
id|llseek
op_assign
id|generic_file_llseek
comma
dot
id|read
op_assign
id|shmem_file_read
comma
dot
id|write
op_assign
id|shmem_file_write
comma
dot
id|fsync
op_assign
id|simple_sync_file
comma
dot
id|sendfile
op_assign
id|shmem_file_sendfile
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
op_assign
(brace
dot
id|truncate
op_assign
id|shmem_truncate
comma
dot
id|setattr
op_assign
id|shmem_notify_change
comma
)brace
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
op_assign
(brace
macro_line|#ifdef CONFIG_TMPFS
dot
id|create
op_assign
id|shmem_create
comma
dot
id|lookup
op_assign
id|simple_lookup
comma
dot
id|link
op_assign
id|shmem_link
comma
dot
id|unlink
op_assign
id|shmem_unlink
comma
dot
id|symlink
op_assign
id|shmem_symlink
comma
dot
id|mkdir
op_assign
id|shmem_mkdir
comma
dot
id|rmdir
op_assign
id|shmem_rmdir
comma
dot
id|mknod
op_assign
id|shmem_mknod
comma
dot
id|rename
op_assign
id|shmem_rename
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
op_assign
(brace
dot
id|alloc_inode
op_assign
id|shmem_alloc_inode
comma
dot
id|destroy_inode
op_assign
id|shmem_destroy_inode
comma
macro_line|#ifdef CONFIG_TMPFS
dot
id|statfs
op_assign
id|shmem_statfs
comma
dot
id|remount_fs
op_assign
id|shmem_remount_fs
comma
macro_line|#endif
dot
id|delete_inode
op_assign
id|shmem_delete_inode
comma
dot
id|drop_inode
op_assign
id|generic_delete_inode
comma
dot
id|put_super
op_assign
id|shmem_put_super
comma
)brace
suffix:semicolon
DECL|variable|shmem_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_vm_ops
op_assign
(brace
dot
id|nopage
op_assign
id|shmem_nopage
comma
dot
id|populate
op_assign
id|shmem_populate
comma
)brace
suffix:semicolon
DECL|function|shmem_get_sb
r_static
r_struct
id|super_block
op_star
id|shmem_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_nodev
c_func
(paren
id|fs_type
comma
id|flags
comma
id|data
comma
id|shmem_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|tmpfs_fs_type
r_static
r_struct
id|file_system_type
id|tmpfs_fs_type
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;tmpfs&quot;
comma
dot
id|get_sb
op_assign
id|shmem_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_litter_super
comma
)brace
suffix:semicolon
DECL|variable|shm_mnt
r_static
r_struct
id|vfsmount
op_star
id|shm_mnt
suffix:semicolon
DECL|function|init_tmpfs
r_static
r_int
id|__init
id|init_tmpfs
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|init_inodecache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out3
suffix:semicolon
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could not register tmpfs&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TMPFS
id|devfs_mk_dir
c_func
(paren
l_string|&quot;shm&quot;
)paren
suffix:semicolon
macro_line|#endif
id|shm_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|shm_mnt
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|shm_mnt
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could not kern_mount tmpfs&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
multiline_comment|/* The internal instance should not do size checking */
id|shmem_set_size
c_func
(paren
id|SHMEM_SB
c_func
(paren
id|shm_mnt-&gt;mnt_sb
)paren
comma
id|ULONG_MAX
comma
id|ULONG_MAX
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out1
suffix:colon
id|unregister_filesystem
c_func
(paren
op_amp
id|tmpfs_fs_type
)paren
suffix:semicolon
id|out2
suffix:colon
id|destroy_inodecache
c_func
(paren
)paren
suffix:semicolon
id|out3
suffix:colon
id|shm_mnt
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|module_init
id|module_init
c_func
(paren
id|init_tmpfs
)paren
multiline_comment|/*&n; * shmem_file_setup - get an unlinked file living in tmpfs&n; *&n; * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps&n; * @size: size to be set for the file&n; *&n; */
r_struct
id|file
op_star
id|shmem_file_setup
c_func
(paren
r_char
op_star
id|name
comma
id|loff_t
id|size
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|root
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|shm_mnt
)paren
)paren
r_return
(paren
r_void
op_star
)paren
id|shm_mnt
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|SHMEM_MAX_BYTES
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|VM_ACCOUNT
)paren
op_logical_and
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
id|size
)paren
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will go */
id|root
op_assign
id|shm_mnt-&gt;mnt_root
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|put_memory
suffix:semicolon
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|put_dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|root-&gt;d_sb
comma
id|S_IFREG
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|close_file
suffix:semicolon
id|SHMEM_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|flags
op_and_assign
id|flags
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|size
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* It is unlinked */
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|shm_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_WRITE
op_or
id|FMODE_READ
suffix:semicolon
r_return
id|file
suffix:semicolon
id|close_file
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_dentry
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|put_memory
suffix:colon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_ACCOUNT
)paren
id|vm_unacct_memory
c_func
(paren
id|VM_ACCT
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_zero_setup - setup a shared anonymous mapping&n; *&n; * @vma: the vma to be mmapped is prepared by do_mmap_pgoff&n; */
DECL|function|shmem_zero_setup
r_int
id|shmem_zero_setup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|loff_t
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|file
op_assign
id|shmem_file_setup
c_func
(paren
l_string|&quot;dev/zero&quot;
comma
id|size
comma
id|vma-&gt;vm_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|fput
c_func
(paren
id|vma-&gt;vm_file
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
op_amp
id|shmem_vm_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|shmem_file_setup
id|EXPORT_SYMBOL
c_func
(paren
id|shmem_file_setup
)paren
suffix:semicolon
eof
