multiline_comment|/*&n; * linux/mm/slab.c&n; * Written by Mark Hemment, 1996/97.&n; * (markhe@nextd.demon.co.uk)&n; *&n; * kmem_cache_destroy() + some cleanup - 1999 Andrea Arcangeli&n; *&n; * Major cleanup, different bufctl logic, per-cpu arrays&n; *&t;(c) 2000 Manfred Spraul&n; *&n; * Cleanup, make the head arrays unconditional, preparation for NUMA&n; * &t;(c) 2002 Manfred Spraul&n; *&n; * An implementation of the Slab Allocator as described in outline in;&n; *&t;UNIX Internals: The New Frontiers by Uresh Vahalia&n; *&t;Pub: Prentice Hall&t;ISBN 0-13-101908-2&n; * or with a little more detail in;&n; *&t;The Slab Allocator: An Object-Caching Kernel Memory Allocator&n; *&t;Jeff Bonwick (Sun Microsystems).&n; *&t;Presented at: USENIX Summer 1994 Technical Conference&n; *&n; * The memory is organized in caches, one cache for each object type.&n; * (e.g. inode_cache, dentry_cache, buffer_head, vm_area_struct)&n; * Each cache consists out of many slabs (they are small (usually one&n; * page long) and always contiguous), and each slab contains multiple&n; * initialized objects.&n; *&n; * This means, that your constructor is used only for newly allocated&n; * slabs and you must pass objects with the same intializations to&n; * kmem_cache_free.&n; *&n; * Each cache can only support one memory type (GFP_DMA, GFP_HIGHMEM,&n; * normal). If you need a special memory type, then must create a new&n; * cache for that memory type.&n; *&n; * In order to reduce fragmentation, the slabs are sorted in 3 groups:&n; *   full slabs with 0 free objects&n; *   partial slabs&n; *   empty slabs with no allocated objects&n; *&n; * If partial slabs exist, then new allocations come from these slabs,&n; * otherwise from empty slabs or new slabs are allocated.&n; *&n; * kmem_cache_destroy() CAN CRASH if you try to allocate from the cache&n; * during kmem_cache_destroy(). The caller must prevent concurrent allocs.&n; *&n; * Each cache has a short per-cpu head array, most allocs&n; * and frees go into that array, and if that array overflows, then 1/2&n; * of the entries in the array are given back into the global cache.&n; * The head array is strictly LIFO and should improve the cache hit rates.&n; * On SMP, it additionally reduces the spinlock operations.&n; *&n; * The c_cpuarray may not be read with enabled local interrupts - &n; * it&squot;s changed with a smp_call_function().&n; *&n; * SMP synchronization:&n; *  constructors and destructors are called without any locking.&n; *  Several members in kmem_cache_t and struct slab never change, they&n; *&t;are accessed without any locking.&n; *  The per-cpu arrays are never accessed from the wrong cpu, no locking,&n; *  &t;and local interrupts are disabled so slab code is preempt-safe.&n; *  The non-constant members are protected with a per-cache irq spinlock.&n; *&n; * Many thanks to Mark Hemment, who wrote another per-cpu slab patch&n; * in 2000 - many ideas in the current implementation are derived from&n; * his patch.&n; *&n; * Further notes from the original documentation:&n; *&n; * 11 April &squot;97.  Started multi-threading - markhe&n; *&t;The global cache-chain is protected by the semaphore &squot;cache_chain_sem&squot;.&n; *&t;The sem is only needed when accessing/extending the cache-chain, which&n; *&t;can never happen inside an interrupt (kmem_cache_create(),&n; *&t;kmem_cache_shrink() and kmem_cache_reap()).&n; *&n; *&t;At present, each engine can be growing a cache.  This should be blocked.&n; *&n; */
macro_line|#include&t;&lt;linux/config.h&gt;
macro_line|#include&t;&lt;linux/slab.h&gt;
macro_line|#include&t;&lt;linux/mm.h&gt;
macro_line|#include&t;&lt;linux/swap.h&gt;
macro_line|#include&t;&lt;linux/cache.h&gt;
macro_line|#include&t;&lt;linux/interrupt.h&gt;
macro_line|#include&t;&lt;linux/init.h&gt;
macro_line|#include&t;&lt;linux/compiler.h&gt;
macro_line|#include&t;&lt;linux/seq_file.h&gt;
macro_line|#include&t;&lt;linux/notifier.h&gt;
macro_line|#include&t;&lt;linux/kallsyms.h&gt;
macro_line|#include&t;&lt;linux/cpu.h&gt;
macro_line|#include&t;&lt;linux/sysctl.h&gt;
macro_line|#include&t;&lt;linux/module.h&gt;
macro_line|#include&t;&lt;linux/rcupdate.h&gt;
macro_line|#include&t;&lt;asm/uaccess.h&gt;
macro_line|#include&t;&lt;asm/cacheflush.h&gt;
macro_line|#include&t;&lt;asm/tlbflush.h&gt;
macro_line|#include&t;&lt;asm/page.h&gt;
multiline_comment|/*&n; * DEBUG&t;- 1 for kmem_cache_create() to honour; SLAB_DEBUG_INITIAL,&n; *&t;&t;  SLAB_RED_ZONE &amp; SLAB_POISON.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * STATS&t;- 1 to collect stats for /proc/slabinfo.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * FORCED_DEBUG&t;- 1 enables SLAB_RED_ZONE and SLAB_POISON (if possible)&n; */
macro_line|#ifdef CONFIG_DEBUG_SLAB
DECL|macro|DEBUG
mdefine_line|#define&t;DEBUG&t;&t;1
DECL|macro|STATS
mdefine_line|#define&t;STATS&t;&t;1
DECL|macro|FORCED_DEBUG
mdefine_line|#define&t;FORCED_DEBUG&t;1
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define&t;DEBUG&t;&t;0
DECL|macro|STATS
mdefine_line|#define&t;STATS&t;&t;0
DECL|macro|FORCED_DEBUG
mdefine_line|#define&t;FORCED_DEBUG&t;0
macro_line|#endif
multiline_comment|/* Shouldn&squot;t this be in a header file somewhere? */
DECL|macro|BYTES_PER_WORD
mdefine_line|#define&t;BYTES_PER_WORD&t;&t;sizeof(void *)
macro_line|#ifndef cache_line_size
DECL|macro|cache_line_size
mdefine_line|#define cache_line_size()&t;L1_CACHE_BYTES
macro_line|#endif
macro_line|#ifndef ARCH_KMALLOC_MINALIGN
multiline_comment|/*&n; * Enforce a minimum alignment for the kmalloc caches.&n; * Usually, the kmalloc caches are cache_line_size() aligned, except when&n; * DEBUG and FORCED_DEBUG are enabled, then they are BYTES_PER_WORD aligned.&n; * Some archs want to perform DMA into kmalloc caches and need a guaranteed&n; * alignment larger than BYTES_PER_WORD. ARCH_KMALLOC_MINALIGN allows that.&n; * Note that this flag disables some debug features.&n; */
DECL|macro|ARCH_KMALLOC_MINALIGN
mdefine_line|#define ARCH_KMALLOC_MINALIGN 0
macro_line|#endif
macro_line|#ifndef ARCH_SLAB_MINALIGN
multiline_comment|/*&n; * Enforce a minimum alignment for all caches.&n; * Intended for archs that get misalignment faults even for BYTES_PER_WORD&n; * aligned buffers. Includes ARCH_KMALLOC_MINALIGN.&n; * If possible: Do not enable this flag for CONFIG_DEBUG_SLAB, it disables&n; * some debug features.&n; */
DECL|macro|ARCH_SLAB_MINALIGN
mdefine_line|#define ARCH_SLAB_MINALIGN 0
macro_line|#endif
macro_line|#ifndef ARCH_KMALLOC_FLAGS
DECL|macro|ARCH_KMALLOC_FLAGS
mdefine_line|#define ARCH_KMALLOC_FLAGS SLAB_HWCACHE_ALIGN
macro_line|#endif
multiline_comment|/* Legal flag mask for kmem_cache_create(). */
macro_line|#if DEBUG
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_DEBUG_INITIAL | SLAB_RED_ZONE | &bslash;&n;&t;&t;&t; SLAB_POISON | SLAB_HWCACHE_ALIGN | &bslash;&n;&t;&t;&t; SLAB_NO_REAP | SLAB_CACHE_DMA | &bslash;&n;&t;&t;&t; SLAB_MUST_HWCACHE_ALIGN | SLAB_STORE_USER | &bslash;&n;&t;&t;&t; SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | &bslash;&n;&t;&t;&t; SLAB_DESTROY_BY_RCU)
macro_line|#else
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_HWCACHE_ALIGN | SLAB_NO_REAP | &bslash;&n;&t;&t;&t; SLAB_CACHE_DMA | SLAB_MUST_HWCACHE_ALIGN | &bslash;&n;&t;&t;&t; SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | &bslash;&n;&t;&t;&t; SLAB_DESTROY_BY_RCU)
macro_line|#endif
multiline_comment|/*&n; * kmem_bufctl_t:&n; *&n; * Bufctl&squot;s are used for linking objs within a slab&n; * linked offsets.&n; *&n; * This implementation relies on &quot;struct page&quot; for locating the cache &amp;&n; * slab an object belongs to.&n; * This allows the bufctl structure to be small (one int), but limits&n; * the number of objects a slab (not a cache) can contain when off-slab&n; * bufctls are used. The limit is the size of the largest general cache&n; * that does not use off-slab slabs.&n; * For 32bit archs with 4 kB pages, is this 56.&n; * This is not serious, as it is only for large objects, when it is unwise&n; * to have too many per slab.&n; * Note: This limit can be raised by introducing a general cache whose size&n; * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.&n; */
DECL|macro|BUFCTL_END
mdefine_line|#define BUFCTL_END&t;(((kmem_bufctl_t)(~0U))-0)
DECL|macro|BUFCTL_FREE
mdefine_line|#define BUFCTL_FREE&t;(((kmem_bufctl_t)(~0U))-1)
DECL|macro|SLAB_LIMIT
mdefine_line|#define&t;SLAB_LIMIT&t;(((kmem_bufctl_t)(~0U))-2)
multiline_comment|/* Max number of objs-per-slab for caches which use off-slab slabs.&n; * Needed to avoid a possible looping condition in cache_grow().&n; */
DECL|variable|offslab_limit
r_static
r_int
r_int
id|offslab_limit
suffix:semicolon
multiline_comment|/*&n; * struct slab&n; *&n; * Manages the objs in a slab. Placed either at the beginning of mem allocated&n; * for a slab, or allocated from an general cache.&n; * Slabs are chained into three list: fully used, partial, fully free slabs.&n; */
DECL|struct|slab
r_struct
id|slab
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|colouroff
r_int
r_int
id|colouroff
suffix:semicolon
DECL|member|s_mem
r_void
op_star
id|s_mem
suffix:semicolon
multiline_comment|/* including colour offset */
DECL|member|inuse
r_int
r_int
id|inuse
suffix:semicolon
multiline_comment|/* num of objs active in slab */
DECL|member|free
id|kmem_bufctl_t
id|free
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * struct slab_rcu&n; *&n; * slab_destroy on a SLAB_DESTROY_BY_RCU cache uses this structure to&n; * arrange for kmem_freepages to be called via RCU.  This is useful if&n; * we need to approach a kernel structure obliquely, from its address&n; * obtained without the usual locking.  We can lock the structure to&n; * stabilize it and check it&squot;s still at the given address, only if we&n; * can be sure that the memory has not been meanwhile reused for some&n; * other kind of object (which our subsystem&squot;s lock might corrupt).&n; *&n; * rcu_read_lock before reading the address, then rcu_read_unlock after&n; * taking the spinlock within the structure expected at that address.&n; *&n; * We assume struct slab_rcu can overlay struct slab when destroying.&n; */
DECL|struct|slab_rcu
r_struct
id|slab_rcu
(brace
DECL|member|head
r_struct
id|rcu_head
id|head
suffix:semicolon
DECL|member|cachep
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
DECL|member|addr
r_void
op_star
id|addr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * struct array_cache&n; *&n; * Per cpu structures&n; * Purpose:&n; * - LIFO ordering, to hand out cache-warm objects from _alloc&n; * - reduce the number of linked list operations&n; * - reduce spinlock operations&n; *&n; * The limit is stored in the per-cpu structure to reduce the data cache&n; * footprint.&n; *&n; */
DECL|struct|array_cache
r_struct
id|array_cache
(brace
DECL|member|avail
r_int
r_int
id|avail
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|batchcount
r_int
r_int
id|batchcount
suffix:semicolon
DECL|member|touched
r_int
r_int
id|touched
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* bootstrap: The caches do not work without cpuarrays anymore,&n; * but the cpuarrays are allocated from the generic caches...&n; */
DECL|macro|BOOT_CPUCACHE_ENTRIES
mdefine_line|#define BOOT_CPUCACHE_ENTRIES&t;1
DECL|struct|arraycache_init
r_struct
id|arraycache_init
(brace
DECL|member|cache
r_struct
id|array_cache
id|cache
suffix:semicolon
DECL|member|entries
r_void
op_star
id|entries
(braket
id|BOOT_CPUCACHE_ENTRIES
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The slab lists of all objects.&n; * Hopefully reduce the internal fragmentation&n; * NUMA: The spinlock could be moved from the kmem_cache_t&n; * into this structure, too. Figure out what causes&n; * fewer cross-node spinlock operations.&n; */
DECL|struct|kmem_list3
r_struct
id|kmem_list3
(brace
DECL|member|slabs_partial
r_struct
id|list_head
id|slabs_partial
suffix:semicolon
multiline_comment|/* partial list first, better asm code */
DECL|member|slabs_full
r_struct
id|list_head
id|slabs_full
suffix:semicolon
DECL|member|slabs_free
r_struct
id|list_head
id|slabs_free
suffix:semicolon
DECL|member|free_objects
r_int
r_int
id|free_objects
suffix:semicolon
DECL|member|free_touched
r_int
id|free_touched
suffix:semicolon
DECL|member|next_reap
r_int
r_int
id|next_reap
suffix:semicolon
DECL|member|shared
r_struct
id|array_cache
op_star
id|shared
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|LIST3_INIT
mdefine_line|#define LIST3_INIT(parent) &bslash;&n;&t;{ &bslash;&n;&t;&t;.slabs_full&t;= LIST_HEAD_INIT(parent.slabs_full), &bslash;&n;&t;&t;.slabs_partial&t;= LIST_HEAD_INIT(parent.slabs_partial), &bslash;&n;&t;&t;.slabs_free&t;= LIST_HEAD_INIT(parent.slabs_free) &bslash;&n;&t;}
DECL|macro|list3_data
mdefine_line|#define list3_data(cachep) &bslash;&n;&t;(&amp;(cachep)-&gt;lists)
multiline_comment|/* NUMA: per-node */
DECL|macro|list3_data_ptr
mdefine_line|#define list3_data_ptr(cachep, ptr) &bslash;&n;&t;&t;list3_data(cachep)
multiline_comment|/*&n; * kmem_cache_t&n; *&n; * manages a cache.&n; */
DECL|struct|kmem_cache_s
r_struct
id|kmem_cache_s
(brace
multiline_comment|/* 1) per-cpu data, touched during every alloc/free */
DECL|member|array
r_struct
id|array_cache
op_star
id|array
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|member|batchcount
r_int
r_int
id|batchcount
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
multiline_comment|/* 2) touched by every alloc &amp; free from the backend */
DECL|member|lists
r_struct
id|kmem_list3
id|lists
suffix:semicolon
multiline_comment|/* NUMA: kmem_3list_t&t;*nodelists[MAX_NUMNODES] */
DECL|member|objsize
r_int
r_int
id|objsize
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* constant flags */
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
multiline_comment|/* # of objs per slab */
DECL|member|free_limit
r_int
r_int
id|free_limit
suffix:semicolon
multiline_comment|/* upper limit of objects in the lists */
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
multiline_comment|/* 3) cache_grow/shrink */
multiline_comment|/* order of pgs per slab (2^n) */
DECL|member|gfporder
r_int
r_int
id|gfporder
suffix:semicolon
multiline_comment|/* force GFP flags, e.g. GFP_DMA */
DECL|member|gfpflags
r_int
r_int
id|gfpflags
suffix:semicolon
DECL|member|colour
r_int
id|colour
suffix:semicolon
multiline_comment|/* cache colouring range */
DECL|member|colour_off
r_int
r_int
id|colour_off
suffix:semicolon
multiline_comment|/* colour offset */
DECL|member|colour_next
r_int
r_int
id|colour_next
suffix:semicolon
multiline_comment|/* cache colouring */
DECL|member|slabp_cache
id|kmem_cache_t
op_star
id|slabp_cache
suffix:semicolon
DECL|member|slab_size
r_int
r_int
id|slab_size
suffix:semicolon
DECL|member|dflags
r_int
r_int
id|dflags
suffix:semicolon
multiline_comment|/* dynamic flags */
multiline_comment|/* constructor func */
DECL|member|ctor
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* de-constructor func */
DECL|member|dtor
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* 4) cache creation/removal */
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
multiline_comment|/* 5) statistics */
macro_line|#if STATS
DECL|member|num_active
r_int
r_int
id|num_active
suffix:semicolon
DECL|member|num_allocations
r_int
r_int
id|num_allocations
suffix:semicolon
DECL|member|high_mark
r_int
r_int
id|high_mark
suffix:semicolon
DECL|member|grown
r_int
r_int
id|grown
suffix:semicolon
DECL|member|reaped
r_int
r_int
id|reaped
suffix:semicolon
DECL|member|errors
r_int
r_int
id|errors
suffix:semicolon
DECL|member|max_freeable
r_int
r_int
id|max_freeable
suffix:semicolon
DECL|member|node_allocs
r_int
r_int
id|node_allocs
suffix:semicolon
DECL|member|allochit
id|atomic_t
id|allochit
suffix:semicolon
DECL|member|allocmiss
id|atomic_t
id|allocmiss
suffix:semicolon
DECL|member|freehit
id|atomic_t
id|freehit
suffix:semicolon
DECL|member|freemiss
id|atomic_t
id|freemiss
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG
DECL|member|dbghead
r_int
id|dbghead
suffix:semicolon
DECL|member|reallen
r_int
id|reallen
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|CFLGS_OFF_SLAB
mdefine_line|#define CFLGS_OFF_SLAB&t;&t;(0x80000000UL)
DECL|macro|OFF_SLAB
mdefine_line|#define&t;OFF_SLAB(x)&t;((x)-&gt;flags &amp; CFLGS_OFF_SLAB)
DECL|macro|BATCHREFILL_LIMIT
mdefine_line|#define BATCHREFILL_LIMIT&t;16
multiline_comment|/* Optimization question: fewer reaps means less &n; * probability for unnessary cpucache drain/refill cycles.&n; *&n; * OTHO the cpuarrays can contain lots of objects,&n; * which could lock up otherwise freeable slabs.&n; */
DECL|macro|REAPTIMEOUT_CPUC
mdefine_line|#define REAPTIMEOUT_CPUC&t;(2*HZ)
DECL|macro|REAPTIMEOUT_LIST3
mdefine_line|#define REAPTIMEOUT_LIST3&t;(4*HZ)
macro_line|#if STATS
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;((x)-&gt;num_active++)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;((x)-&gt;num_active--)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;((x)-&gt;num_allocations++)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;((x)-&gt;grown++)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;((x)-&gt;reaped++)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { if ((x)-&gt;num_active &gt; (x)-&gt;high_mark) &bslash;&n;&t;&t;&t;&t;&t;(x)-&gt;high_mark = (x)-&gt;num_active; &bslash;&n;&t;&t;&t;&t;} while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;((x)-&gt;errors++)
DECL|macro|STATS_INC_NODEALLOCS
mdefine_line|#define&t;STATS_INC_NODEALLOCS(x)&t;((x)-&gt;node_allocs++)
DECL|macro|STATS_SET_FREEABLE
mdefine_line|#define&t;STATS_SET_FREEABLE(x, i) &bslash;&n;&t;&t;&t;&t;do { if ((x)-&gt;max_freeable &lt; i) &bslash;&n;&t;&t;&t;&t;&t;(x)-&gt;max_freeable = i; &bslash;&n;&t;&t;&t;&t;} while (0)
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;atomic_inc(&amp;(x)-&gt;allochit)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;atomic_inc(&amp;(x)-&gt;allocmiss)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;atomic_inc(&amp;(x)-&gt;freehit)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;atomic_inc(&amp;(x)-&gt;freemiss)
macro_line|#else
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;do { } while (0)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;do { } while (0)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;do { } while (0)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { } while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;do { } while (0)
DECL|macro|STATS_INC_NODEALLOCS
mdefine_line|#define&t;STATS_INC_NODEALLOCS(x)&t;do { } while (0)
DECL|macro|STATS_SET_FREEABLE
mdefine_line|#define&t;STATS_SET_FREEABLE(x, i) &bslash;&n;&t;&t;&t;&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;do { } while (0)
macro_line|#endif
macro_line|#if DEBUG
multiline_comment|/* Magic nums for obj red zoning.&n; * Placed in the first word before and the first word after an obj.&n; */
DECL|macro|RED_INACTIVE
mdefine_line|#define&t;RED_INACTIVE&t;0x5A2CF071UL&t;/* when obj is inactive */
DECL|macro|RED_ACTIVE
mdefine_line|#define&t;RED_ACTIVE&t;0x170FC2A5UL&t;/* when obj is active */
multiline_comment|/* ...and for poisoning */
DECL|macro|POISON_INUSE
mdefine_line|#define&t;POISON_INUSE&t;0x5a&t;/* for use-uninitialised poisoning */
DECL|macro|POISON_FREE
mdefine_line|#define POISON_FREE&t;0x6b&t;/* for use-after-free poisoning */
DECL|macro|POISON_END
mdefine_line|#define&t;POISON_END&t;0xa5&t;/* end-byte of poisoning */
multiline_comment|/* memory layout of objects:&n; * 0&t;&t;: objp&n; * 0 .. cachep-&gt;dbghead - BYTES_PER_WORD - 1: padding. This ensures that&n; * &t;&t;the end of an object is aligned with the end of the real&n; * &t;&t;allocation. Catches writes behind the end of the allocation.&n; * cachep-&gt;dbghead - BYTES_PER_WORD .. cachep-&gt;dbghead - 1:&n; * &t;&t;redzone word.&n; * cachep-&gt;dbghead: The real object.&n; * cachep-&gt;objsize - 2* BYTES_PER_WORD: redzone word [BYTES_PER_WORD long]&n; * cachep-&gt;objsize - 1* BYTES_PER_WORD: last caller address [BYTES_PER_WORD long]&n; */
DECL|function|obj_dbghead
r_static
r_int
id|obj_dbghead
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_return
id|cachep-&gt;dbghead
suffix:semicolon
)brace
DECL|function|obj_reallen
r_static
r_int
id|obj_reallen
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_return
id|cachep-&gt;reallen
suffix:semicolon
)brace
DECL|function|dbg_redzone1
r_static
r_int
r_int
op_star
id|dbg_redzone1
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
op_minus
id|BYTES_PER_WORD
)paren
suffix:semicolon
)brace
DECL|function|dbg_redzone2
r_static
r_int
r_int
op_star
id|dbg_redzone2
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
r_return
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
l_int|2
op_star
id|BYTES_PER_WORD
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
suffix:semicolon
)brace
DECL|function|dbg_userword
r_static
r_void
op_star
op_star
id|dbg_userword
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|obj_dbghead
mdefine_line|#define obj_dbghead(x)&t;&t;&t;0
DECL|macro|obj_reallen
mdefine_line|#define obj_reallen(cachep)&t;&t;(cachep-&gt;objsize)
DECL|macro|dbg_redzone1
mdefine_line|#define dbg_redzone1(cachep, objp)&t;({BUG(); (unsigned long *)NULL;})
DECL|macro|dbg_redzone2
mdefine_line|#define dbg_redzone2(cachep, objp)&t;({BUG(); (unsigned long *)NULL;})
DECL|macro|dbg_userword
mdefine_line|#define dbg_userword(cachep, objp)&t;({BUG(); (void **)NULL;})
macro_line|#endif
multiline_comment|/*&n; * Maximum size of an obj (in 2^order pages)&n; * and absolute limit for the gfp order.&n; */
macro_line|#if defined(CONFIG_LARGE_ALLOCS)
DECL|macro|MAX_OBJ_ORDER
mdefine_line|#define&t;MAX_OBJ_ORDER&t;13&t;/* up to 32Mb */
DECL|macro|MAX_GFP_ORDER
mdefine_line|#define&t;MAX_GFP_ORDER&t;13&t;/* up to 32Mb */
macro_line|#elif defined(CONFIG_MMU)
DECL|macro|MAX_OBJ_ORDER
mdefine_line|#define&t;MAX_OBJ_ORDER&t;5&t;/* 32 pages */
DECL|macro|MAX_GFP_ORDER
mdefine_line|#define&t;MAX_GFP_ORDER&t;5&t;/* 32 pages */
macro_line|#else
DECL|macro|MAX_OBJ_ORDER
mdefine_line|#define&t;MAX_OBJ_ORDER&t;8&t;/* up to 1Mb */
DECL|macro|MAX_GFP_ORDER
mdefine_line|#define&t;MAX_GFP_ORDER&t;8&t;/* up to 1Mb */
macro_line|#endif
multiline_comment|/*&n; * Do not go above this order unless 0 objects fit into the slab.&n; */
DECL|macro|BREAK_GFP_ORDER_HI
mdefine_line|#define&t;BREAK_GFP_ORDER_HI&t;1
DECL|macro|BREAK_GFP_ORDER_LO
mdefine_line|#define&t;BREAK_GFP_ORDER_LO&t;0
DECL|variable|slab_break_gfp_order
r_static
r_int
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_LO
suffix:semicolon
multiline_comment|/* Macros for storing/retrieving the cachep and or slab from the&n; * global &squot;mem_map&squot;. These are used to find the slab an obj belongs to.&n; * With kfree(), these are used to find the cache which an obj belongs to.&n; */
DECL|macro|SET_PAGE_CACHE
mdefine_line|#define&t;SET_PAGE_CACHE(pg,x)  ((pg)-&gt;lru.next = (struct list_head *)(x))
DECL|macro|GET_PAGE_CACHE
mdefine_line|#define&t;GET_PAGE_CACHE(pg)    ((kmem_cache_t *)(pg)-&gt;lru.next)
DECL|macro|SET_PAGE_SLAB
mdefine_line|#define&t;SET_PAGE_SLAB(pg,x)   ((pg)-&gt;lru.prev = (struct list_head *)(x))
DECL|macro|GET_PAGE_SLAB
mdefine_line|#define&t;GET_PAGE_SLAB(pg)     ((struct slab *)(pg)-&gt;lru.prev)
multiline_comment|/* These are the default caches for kmalloc. Custom caches can have other sizes. */
DECL|variable|malloc_sizes
r_struct
id|cache_sizes
id|malloc_sizes
(braket
)braket
op_assign
(brace
DECL|macro|CACHE
mdefine_line|#define CACHE(x) { .cs_size = (x) },
macro_line|#include &lt;linux/kmalloc_sizes.h&gt;
(brace
l_int|0
comma
)brace
DECL|macro|CACHE
macro_line|#undef CACHE
)brace
suffix:semicolon
DECL|variable|malloc_sizes
id|EXPORT_SYMBOL
c_func
(paren
id|malloc_sizes
)paren
suffix:semicolon
multiline_comment|/* Must match cache_sizes above. Out of line to keep cache footprint low. */
DECL|struct|cache_names
r_struct
id|cache_names
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|name_dma
r_char
op_star
id|name_dma
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cache_names
r_static
r_struct
id|cache_names
id|__initdata
id|cache_names
(braket
)braket
op_assign
(brace
DECL|macro|CACHE
mdefine_line|#define CACHE(x) { .name = &quot;size-&quot; #x, .name_dma = &quot;size-&quot; #x &quot;(DMA)&quot; },
macro_line|#include &lt;linux/kmalloc_sizes.h&gt;
(brace
l_int|NULL
comma
)brace
DECL|macro|CACHE
macro_line|#undef CACHE
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|arraycache_init
id|initarray_cache
id|__initdata
op_assign
(brace
(brace
l_int|0
comma
id|BOOT_CPUCACHE_ENTRIES
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|initarray_generic
r_static
r_struct
id|arraycache_init
id|initarray_generic
op_assign
(brace
(brace
l_int|0
comma
id|BOOT_CPUCACHE_ENTRIES
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* internal cache of cache description objs */
DECL|variable|cache_cache
r_static
id|kmem_cache_t
id|cache_cache
op_assign
(brace
dot
id|lists
op_assign
id|LIST3_INIT
c_func
(paren
id|cache_cache.lists
)paren
comma
dot
id|batchcount
op_assign
l_int|1
comma
dot
id|limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
comma
dot
id|objsize
op_assign
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
dot
id|flags
op_assign
id|SLAB_NO_REAP
comma
dot
id|spinlock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|name
op_assign
l_string|&quot;kmem_cache&quot;
comma
macro_line|#if DEBUG
dot
id|reallen
op_assign
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Guard access to the cache-chain. */
DECL|variable|cache_chain_sem
r_static
r_struct
id|semaphore
id|cache_chain_sem
suffix:semicolon
DECL|variable|cache_chain
r_static
r_struct
id|list_head
id|cache_chain
suffix:semicolon
multiline_comment|/*&n; * vm_enough_memory() looks at this to determine how many&n; * slab-allocated pages are possibly freeable under pressure&n; *&n; * SLAB_RECLAIM_ACCOUNT turns this on per-slab&n; */
DECL|variable|slab_reclaim_pages
id|atomic_t
id|slab_reclaim_pages
suffix:semicolon
DECL|variable|slab_reclaim_pages
id|EXPORT_SYMBOL
c_func
(paren
id|slab_reclaim_pages
)paren
suffix:semicolon
multiline_comment|/*&n; * chicken and egg problem: delay the per-cpu array allocation&n; * until the general caches are up.&n; */
r_static
r_enum
(brace
DECL|enumerator|NONE
id|NONE
comma
DECL|enumerator|PARTIAL
id|PARTIAL
comma
DECL|enumerator|FULL
id|FULL
DECL|variable|g_cpucache_up
)brace
id|g_cpucache_up
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|work_struct
comma
id|reap_work
)paren
suffix:semicolon
r_static
r_void
id|free_block
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
suffix:semicolon
r_static
r_void
id|cache_reap
(paren
r_void
op_star
id|unused
)paren
suffix:semicolon
DECL|function|ac_entry
r_static
r_inline
r_void
op_star
op_star
id|ac_entry
c_func
(paren
r_struct
id|array_cache
op_star
id|ac
)paren
(brace
r_return
(paren
r_void
op_star
op_star
)paren
(paren
id|ac
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ac_data
r_static
r_inline
r_struct
id|array_cache
op_star
id|ac_data
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_return
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
)brace
DECL|function|kmem_find_general_cachep
r_static
id|kmem_cache_t
op_star
id|kmem_find_general_cachep
(paren
r_int
id|size
comma
r_int
id|gfpflags
)paren
(brace
r_struct
id|cache_sizes
op_star
id|csizep
op_assign
id|malloc_sizes
suffix:semicolon
multiline_comment|/* This function could be moved to the header file, and&n;&t; * made inline so consumers can quickly determine what&n;&t; * cache pointer they require.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|gfpflags
op_amp
id|GFP_DMA
)paren
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
suffix:semicolon
)brace
multiline_comment|/* Cal the num objs, wastage, and bytes left over for a given slab size. */
DECL|function|cache_estimate
r_static
r_void
id|cache_estimate
(paren
r_int
r_int
id|gfporder
comma
r_int
id|size
comma
r_int
id|align
comma
r_int
id|flags
comma
r_int
op_star
id|left_over
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wastage
op_assign
id|PAGE_SIZE
op_lshift
id|gfporder
suffix:semicolon
r_int
id|extra
op_assign
l_int|0
suffix:semicolon
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
)paren
(brace
id|base
op_assign
r_sizeof
(paren
r_struct
id|slab
)paren
suffix:semicolon
id|extra
op_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_star
id|size
op_plus
id|ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
comma
id|align
)paren
op_le
id|wastage
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|SLAB_LIMIT
)paren
id|i
op_assign
id|SLAB_LIMIT
suffix:semicolon
op_star
id|num
op_assign
id|i
suffix:semicolon
id|wastage
op_sub_assign
id|i
op_star
id|size
suffix:semicolon
id|wastage
op_sub_assign
id|ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
comma
id|align
)paren
suffix:semicolon
op_star
id|left_over
op_assign
id|wastage
suffix:semicolon
)brace
DECL|macro|slab_error
mdefine_line|#define slab_error(cachep, msg) __slab_error(__FUNCTION__, cachep, msg)
DECL|function|__slab_error
r_static
r_void
id|__slab_error
c_func
(paren
r_const
r_char
op_star
id|function
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_char
op_star
id|msg
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;slab error in %s(): cache `%s&squot;: %s&bslash;n&quot;
comma
id|function
comma
id|cachep-&gt;name
comma
id|msg
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initiate the reap timer running on the target CPU.  We run at around 1 to 2Hz&n; * via the workqueue/eventd.&n; * Add the CPU number into the expiration time to minimize the possibility of&n; * the CPUs getting into lockstep and contending for the global cache chain&n; * lock.&n; */
DECL|function|start_cpu_timer
r_static
r_void
id|__devinit
id|start_cpu_timer
c_func
(paren
r_int
id|cpu
)paren
(brace
r_struct
id|work_struct
op_star
id|reap_work
op_assign
op_amp
id|per_cpu
c_func
(paren
id|reap_work
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When this gets called from do_initcalls via cpucache_init(),&n;&t; * init_workqueues() has already run, so keventd will be setup&n;&t; * at that time.&n;&t; */
r_if
c_cond
(paren
id|keventd_up
c_func
(paren
)paren
op_logical_and
id|reap_work-&gt;func
op_eq
l_int|NULL
)paren
(brace
id|INIT_WORK
c_func
(paren
id|reap_work
comma
id|cache_reap
comma
l_int|NULL
)paren
suffix:semicolon
id|schedule_delayed_work_on
c_func
(paren
id|cpu
comma
id|reap_work
comma
id|HZ
op_plus
l_int|3
op_star
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|alloc_arraycache
r_static
r_struct
id|array_cache
op_star
id|alloc_arraycache
c_func
(paren
r_int
id|cpu
comma
r_int
id|entries
comma
r_int
id|batchcount
)paren
(brace
r_int
id|memsize
op_assign
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|entries
op_plus
r_sizeof
(paren
r_struct
id|array_cache
)paren
suffix:semicolon
r_struct
id|array_cache
op_star
id|nc
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ne
op_minus
l_int|1
)paren
(brace
id|nc
op_assign
id|kmem_cache_alloc_node
c_func
(paren
id|kmem_find_general_cachep
c_func
(paren
id|memsize
comma
id|GFP_KERNEL
)paren
comma
id|cpu_to_node
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nc
)paren
id|nc
op_assign
id|kmalloc
c_func
(paren
id|memsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nc
)paren
(brace
id|nc-&gt;avail
op_assign
l_int|0
suffix:semicolon
id|nc-&gt;limit
op_assign
id|entries
suffix:semicolon
id|nc-&gt;batchcount
op_assign
id|batchcount
suffix:semicolon
id|nc-&gt;touched
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|nc
suffix:semicolon
)brace
DECL|function|cpuup_callback
r_static
r_int
id|__devinit
id|cpuup_callback
c_func
(paren
r_struct
id|notifier_block
op_star
id|nfb
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
)paren
id|hcpu
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|CPU_UP_PREPARE
suffix:colon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cachep
comma
op_amp
id|cache_chain
comma
id|next
)paren
(brace
r_struct
id|array_cache
op_star
id|nc
suffix:semicolon
id|nc
op_assign
id|alloc_arraycache
c_func
(paren
id|cpu
comma
id|cachep-&gt;limit
comma
id|cachep-&gt;batchcount
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nc
)paren
r_goto
id|bad
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;array
(braket
id|cpu
)braket
op_assign
id|nc
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_ONLINE
suffix:colon
id|start_cpu_timer
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
r_case
id|CPU_DEAD
suffix:colon
multiline_comment|/* fall thru */
r_case
id|CPU_UP_CANCELED
suffix:colon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cachep
comma
op_amp
id|cache_chain
comma
id|next
)paren
(brace
r_struct
id|array_cache
op_star
id|nc
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* cpu is dead; no one can alloc from it. */
id|nc
op_assign
id|cachep-&gt;array
(braket
id|cpu
)braket
suffix:semicolon
id|cachep-&gt;array
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cachep-&gt;free_limit
op_sub_assign
id|cachep-&gt;batchcount
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
id|ac_entry
c_func
(paren
id|nc
)paren
comma
id|nc-&gt;avail
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nc
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
id|bad
suffix:colon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
id|NOTIFY_BAD
suffix:semicolon
)brace
DECL|variable|cpucache_notifier
r_static
r_struct
id|notifier_block
id|cpucache_notifier
op_assign
(brace
op_amp
id|cpuup_callback
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Initialisation.&n; * Called after the gfp() functions have been enabled, and before smp_init().&n; */
DECL|function|kmem_cache_init
r_void
id|__init
id|kmem_cache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|left_over
suffix:semicolon
r_struct
id|cache_sizes
op_star
id|sizes
suffix:semicolon
r_struct
id|cache_names
op_star
id|names
suffix:semicolon
multiline_comment|/*&n;&t; * Fragmentation resistance on low memory - only use bigger&n;&t; * page orders on machines with more than 32MB of memory.&n;&t; */
r_if
c_cond
(paren
id|num_physpages
OG
(paren
l_int|32
op_lshift
l_int|20
)paren
op_rshift
id|PAGE_SHIFT
)paren
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_HI
suffix:semicolon
multiline_comment|/* Bootstrap is tricky, because several objects are allocated&n;&t; * from caches that do not exist yet:&n;&t; * 1) initialize the cache_cache cache: it contains the kmem_cache_t&n;&t; *    structures of all caches, except cache_cache itself: cache_cache&n;&t; *    is statically allocated.&n;&t; *    Initially an __init data area is used for the head array, it&squot;s&n;&t; *    replaced with a kmalloc allocated array at the end of the bootstrap.&n;&t; * 2) Create the first kmalloc cache.&n;&t; *    The kmem_cache_t for the new cache is allocated normally. An __init&n;&t; *    data area is used for the head array.&n;&t; * 3) Create the remaining kmalloc caches, with minimally sized head arrays.&n;&t; * 4) Replace the __init data head arrays for cache_cache and the first&n;&t; *    kmalloc cache with kmalloc allocated arrays.&n;&t; * 5) Resize the head arrays of the kmalloc caches to their final sizes.&n;&t; */
multiline_comment|/* 1) create the cache_cache */
id|init_MUTEX
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cache_chain
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cache_cache.next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|cache_cache.colour_off
op_assign
id|cache_line_size
c_func
(paren
)paren
suffix:semicolon
id|cache_cache.array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
op_amp
id|initarray_cache.cache
suffix:semicolon
id|cache_cache.objsize
op_assign
id|ALIGN
c_func
(paren
id|cache_cache.objsize
comma
id|cache_line_size
c_func
(paren
)paren
)paren
suffix:semicolon
id|cache_estimate
c_func
(paren
l_int|0
comma
id|cache_cache.objsize
comma
id|cache_line_size
c_func
(paren
)paren
comma
l_int|0
comma
op_amp
id|left_over
comma
op_amp
id|cache_cache.num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_cache.num
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cache_cache.colour
op_assign
id|left_over
op_div
id|cache_cache.colour_off
suffix:semicolon
id|cache_cache.colour_next
op_assign
l_int|0
suffix:semicolon
id|cache_cache.slab_size
op_assign
id|ALIGN
c_func
(paren
id|cache_cache.num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|slab
)paren
comma
id|cache_line_size
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* 2+3) create the kmalloc caches */
id|sizes
op_assign
id|malloc_sizes
suffix:semicolon
id|names
op_assign
id|cache_names
suffix:semicolon
r_while
c_loop
(paren
id|sizes-&gt;cs_size
)paren
(brace
multiline_comment|/* For performance, all the general caches are L1 aligned.&n;&t;&t; * This should be particularly beneficial on SMP boxes, as it&n;&t;&t; * eliminates &quot;false sharing&quot;.&n;&t;&t; * Note for systems short on memory removing the alignment will&n;&t;&t; * allow tighter packing of the smaller caches. */
id|sizes-&gt;cs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|names-&gt;name
comma
id|sizes-&gt;cs_size
comma
id|ARCH_KMALLOC_MINALIGN
comma
(paren
id|ARCH_KMALLOC_FLAGS
op_or
id|SLAB_PANIC
)paren
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Inc off-slab bufctl limit until the ceiling is hit. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|OFF_SLAB
c_func
(paren
id|sizes-&gt;cs_cachep
)paren
)paren
)paren
(brace
id|offslab_limit
op_assign
id|sizes-&gt;cs_size
op_minus
r_sizeof
(paren
r_struct
id|slab
)paren
suffix:semicolon
id|offslab_limit
op_div_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
id|sizes-&gt;cs_dmacachep
op_assign
id|kmem_cache_create
c_func
(paren
id|names-&gt;name_dma
comma
id|sizes-&gt;cs_size
comma
id|ARCH_KMALLOC_MINALIGN
comma
(paren
id|ARCH_KMALLOC_FLAGS
op_or
id|SLAB_CACHE_DMA
op_or
id|SLAB_PANIC
)paren
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|sizes
op_increment
suffix:semicolon
id|names
op_increment
suffix:semicolon
)brace
multiline_comment|/* 4) Replace the bootstrap head arrays */
(brace
r_void
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac_data
c_func
(paren
op_amp
id|cache_cache
)paren
op_ne
op_amp
id|initarray_cache.cache
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|ac_data
c_func
(paren
op_amp
id|cache_cache
)paren
comma
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
)paren
suffix:semicolon
id|cache_cache.array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|ptr
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac_data
c_func
(paren
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep
)paren
op_ne
op_amp
id|initarray_generic.cache
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|ac_data
c_func
(paren
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep
)paren
comma
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
)paren
suffix:semicolon
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|ptr
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* 5) resize the head arrays to their final sizes */
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cachep
comma
op_amp
id|cache_chain
comma
id|next
)paren
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Done! */
id|g_cpucache_up
op_assign
id|FULL
suffix:semicolon
multiline_comment|/* Register a cpu startup notifier callback&n;&t; * that initializes ac_data for all new cpus&n;&t; */
id|register_cpu_notifier
c_func
(paren
op_amp
id|cpucache_notifier
)paren
suffix:semicolon
multiline_comment|/* The reap timers are started later, with a module init call:&n;&t; * That part of the kernel is not yet operational.&n;&t; */
)brace
DECL|function|cpucache_init
r_static
r_int
id|__init
id|cpucache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
suffix:semicolon
multiline_comment|/* &n;&t; * Register the timers that return unneeded&n;&t; * pages to gfp.&n;&t; */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
id|start_cpu_timer
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cpucache_init
id|__initcall
c_func
(paren
id|cpucache_init
)paren
suffix:semicolon
multiline_comment|/*&n; * Interface to system&squot;s page allocator. No need to hold the cache-lock.&n; *&n; * If we requested dmaable memory, we will get it. Even if we&n; * did not request dmaable memory, we might get it, but that&n; * would be relatively rare and ignorable.&n; */
DECL|function|kmem_getpages
r_static
r_void
op_star
id|kmem_getpages
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
comma
r_int
id|nodeid
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|flags
op_or_assign
id|cachep-&gt;gfpflags
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|nodeid
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|page
op_assign
id|alloc_pages
c_func
(paren
id|flags
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
)brace
r_else
(brace
id|page
op_assign
id|alloc_pages_node
c_func
(paren
id|nodeid
comma
id|flags
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|NULL
suffix:semicolon
id|addr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|i
op_assign
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RECLAIM_ACCOUNT
)paren
id|atomic_add
c_func
(paren
id|i
comma
op_amp
id|slab_reclaim_pages
)paren
suffix:semicolon
id|add_page_state
c_func
(paren
id|nr_slab
comma
id|i
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|SetPageSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Interface to system&squot;s page release.&n; */
DECL|function|kmem_freepages
r_static
r_void
id|kmem_freepages
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|i
op_assign
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
r_const
r_int
r_int
id|nr_freed
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageSlab
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
id|sub_page_state
c_func
(paren
id|nr_slab
comma
id|nr_freed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;reclaim_state
)paren
id|current-&gt;reclaim_state-&gt;reclaimed_slab
op_add_assign
id|nr_freed
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RECLAIM_ACCOUNT
)paren
id|atomic_sub
c_func
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
comma
op_amp
id|slab_reclaim_pages
)paren
suffix:semicolon
)brace
DECL|function|kmem_rcu_free
r_static
r_void
id|kmem_rcu_free
c_func
(paren
r_struct
id|rcu_head
op_star
id|head
)paren
(brace
r_struct
id|slab_rcu
op_star
id|slab_rcu
op_assign
(paren
r_struct
id|slab_rcu
op_star
)paren
id|head
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
id|slab_rcu-&gt;cachep
suffix:semicolon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slab_rcu-&gt;addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|slab_rcu
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
macro_line|#ifdef CONFIG_DEBUG_PAGEALLOC
DECL|function|store_stackinfo
r_static
r_void
id|store_stackinfo
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
op_star
id|addr
comma
r_int
r_int
id|caller
)paren
(brace
r_int
id|size
op_assign
id|obj_reallen
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|addr
)paren
(braket
id|obj_dbghead
c_func
(paren
id|cachep
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|5
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_return
suffix:semicolon
op_star
id|addr
op_increment
op_assign
l_int|0x12345678
suffix:semicolon
op_star
id|addr
op_increment
op_assign
id|caller
suffix:semicolon
op_star
id|addr
op_increment
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|size
op_sub_assign
l_int|3
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
(brace
r_int
r_int
op_star
id|sptr
op_assign
op_amp
id|caller
suffix:semicolon
r_int
r_int
id|svalue
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|kstack_end
c_func
(paren
id|sptr
)paren
)paren
(brace
id|svalue
op_assign
op_star
id|sptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|kernel_text_address
c_func
(paren
id|svalue
)paren
)paren
(brace
op_star
id|addr
op_increment
op_assign
id|svalue
suffix:semicolon
id|size
op_sub_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
op_star
id|addr
op_increment
op_assign
l_int|0x87654321
suffix:semicolon
)brace
macro_line|#endif
DECL|function|poison_obj
r_static
r_void
id|poison_obj
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
comma
r_int
r_char
id|val
)paren
(brace
r_int
id|size
op_assign
id|obj_reallen
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|addr
op_assign
op_amp
(paren
(paren
r_char
op_star
)paren
id|addr
)paren
(braket
id|obj_dbghead
c_func
(paren
id|cachep
)paren
)braket
suffix:semicolon
id|memset
c_func
(paren
id|addr
comma
id|val
comma
id|size
)paren
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
op_assign
id|POISON_END
suffix:semicolon
)brace
DECL|function|dump_line
r_static
r_void
id|dump_line
c_func
(paren
r_char
op_star
id|data
comma
r_int
id|offset
comma
r_int
id|limit
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%03x:&quot;
comma
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
r_char
)paren
id|data
(braket
id|offset
op_plus
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if DEBUG
DECL|function|print_objinfo
r_static
r_void
id|print_objinfo
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
id|lines
)paren
(brace
r_int
id|i
comma
id|size
suffix:semicolon
r_char
op_star
id|realobj
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Redzone: 0x%lx/0x%lx.&bslash;n&quot;
comma
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
comma
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Last user: [&lt;%p&gt;]&quot;
comma
op_star
id|dbg_userword
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;(%s)&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|dbg_userword
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|realobj
op_assign
(paren
r_char
op_star
)paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|size
op_assign
id|obj_reallen
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
op_logical_and
id|lines
suffix:semicolon
id|i
op_add_assign
l_int|16
comma
id|lines
op_decrement
)paren
(brace
r_int
id|limit
suffix:semicolon
id|limit
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
id|limit
OG
id|size
)paren
id|limit
op_assign
id|size
op_minus
id|i
suffix:semicolon
id|dump_line
c_func
(paren
id|realobj
comma
id|i
comma
id|limit
)paren
suffix:semicolon
)brace
)brace
DECL|function|check_poison_obj
r_static
r_void
id|check_poison_obj
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_char
op_star
id|realobj
suffix:semicolon
r_int
id|size
comma
id|i
suffix:semicolon
r_int
id|lines
op_assign
l_int|0
suffix:semicolon
id|realobj
op_assign
(paren
r_char
op_star
)paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|size
op_assign
id|obj_reallen
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|exp
op_assign
id|POISON_FREE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|size
op_minus
l_int|1
)paren
id|exp
op_assign
id|POISON_END
suffix:semicolon
r_if
c_cond
(paren
id|realobj
(braket
id|i
)braket
op_ne
id|exp
)paren
(brace
r_int
id|limit
suffix:semicolon
multiline_comment|/* Mismatch ! */
multiline_comment|/* Print header */
r_if
c_cond
(paren
id|lines
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Slab corruption: start=%p, len=%d&bslash;n&quot;
comma
id|realobj
comma
id|size
)paren
suffix:semicolon
id|print_objinfo
c_func
(paren
id|cachep
comma
id|objp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Hexdump the affected line */
id|i
op_assign
(paren
id|i
op_div
l_int|16
)paren
op_star
l_int|16
suffix:semicolon
id|limit
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
id|limit
OG
id|size
)paren
id|limit
op_assign
id|size
op_minus
id|i
suffix:semicolon
id|dump_line
c_func
(paren
id|realobj
comma
id|i
comma
id|limit
)paren
suffix:semicolon
id|i
op_add_assign
l_int|16
suffix:semicolon
id|lines
op_increment
suffix:semicolon
multiline_comment|/* Limit to 5 lines */
r_if
c_cond
(paren
id|lines
OG
l_int|5
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lines
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Print some data about the neighboring objects, if they&n;&t;&t; * exist:&n;&t;&t; */
r_struct
id|slab
op_star
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
r_int
id|objnr
suffix:semicolon
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
r_if
c_cond
(paren
id|objnr
)paren
(brace
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
(paren
id|objnr
op_minus
l_int|1
)paren
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|realobj
op_assign
(paren
r_char
op_star
)paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Prev obj: start=%p, len=%d&bslash;n&quot;
comma
id|realobj
comma
id|size
)paren
suffix:semicolon
id|print_objinfo
c_func
(paren
id|cachep
comma
id|objp
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|objnr
op_plus
l_int|1
OL
id|cachep-&gt;num
)paren
(brace
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
(paren
id|objnr
op_plus
l_int|1
)paren
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|realobj
op_assign
(paren
r_char
op_star
)paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Next obj: start=%p, len=%d&bslash;n&quot;
comma
id|realobj
comma
id|size
)paren
suffix:semicolon
id|print_objinfo
c_func
(paren
id|cachep
comma
id|objp
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/* Destroy all the objs in a slab, and release the mem back to the system.&n; * Before calling the slab must have been unlinked from the cache.&n; * The cache-lock is not held/needed.&n; */
DECL|function|slab_destroy
r_static
r_void
id|slab_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
r_void
op_star
id|addr
op_assign
id|slabp-&gt;s_mem
op_minus
id|slabp-&gt;colouroff
suffix:semicolon
macro_line|#if DEBUG
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_PAGEALLOC
r_if
c_cond
(paren
(paren
id|cachep-&gt;objsize
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
op_logical_and
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kernel_map_pages
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
comma
id|cachep-&gt;objsize
op_div
id|PAGE_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_else
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
macro_line|#else
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
)paren
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;start of a freed object &quot;
l_string|&quot;was overwritten&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
)paren
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;end of a freed object &quot;
l_string|&quot;was overwritten&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;dtor
op_logical_and
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
)paren
(paren
id|cachep-&gt;dtor
)paren
(paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|cachep-&gt;dtor
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
(paren
id|cachep-&gt;dtor
)paren
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_DESTROY_BY_RCU
)paren
)paren
(brace
r_struct
id|slab_rcu
op_star
id|slab_rcu
suffix:semicolon
id|slab_rcu
op_assign
(paren
r_struct
id|slab_rcu
op_star
)paren
id|slabp
suffix:semicolon
id|slab_rcu-&gt;cachep
op_assign
id|cachep
suffix:semicolon
id|slab_rcu-&gt;addr
op_assign
id|addr
suffix:semicolon
id|call_rcu
c_func
(paren
op_amp
id|slab_rcu-&gt;head
comma
id|kmem_rcu_free
)paren
suffix:semicolon
)brace
r_else
(brace
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|slabp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * kmem_cache_create - Create a cache.&n; * @name: A string which is used in /proc/slabinfo to identify this cache.&n; * @size: The size of objects to be created in this cache.&n; * @align: The required alignment for the objects.&n; * @flags: SLAB flags&n; * @ctor: A constructor for the objects.&n; * @dtor: A destructor for the objects.&n; *&n; * Returns a ptr to the cache on success, NULL on failure.&n; * Cannot be called within a int, but can be interrupted.&n; * The @ctor is run when new pages are allocated by the cache&n; * and the @dtor is run before the pages are handed back.&n; *&n; * @name must be valid until the cache is destroyed. This implies that&n; * the module calling this has to destroy the cache before getting &n; * unloaded.&n; * &n; * The flags are&n; *&n; * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)&n; * to catch references to uninitialised memory.&n; *&n; * %SLAB_RED_ZONE - Insert `Red&squot; zones around the allocated memory to check&n; * for buffer overruns.&n; *&n; * %SLAB_NO_REAP - Don&squot;t automatically reap this cache when we&squot;re under&n; * memory pressure.&n; *&n; * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware&n; * cacheline.  This can be beneficial if you&squot;re counting cycles as closely&n; * as davem.&n; */
id|kmem_cache_t
op_star
DECL|function|kmem_cache_create
id|kmem_cache_create
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|size
comma
r_int
id|align
comma
r_int
r_int
id|flags
comma
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
comma
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
)paren
(brace
r_int
id|left_over
comma
id|slab_size
comma
id|ralign
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity checks... these are all serious usage bugs.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|name
)paren
op_logical_or
id|in_interrupt
c_func
(paren
)paren
op_logical_or
(paren
id|size
OL
id|BYTES_PER_WORD
)paren
op_logical_or
(paren
id|size
OG
(paren
l_int|1
op_lshift
id|MAX_OBJ_ORDER
)paren
op_star
id|PAGE_SIZE
)paren
op_logical_or
(paren
id|dtor
op_logical_and
op_logical_neg
id|ctor
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Early error in slab %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|name
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
id|WARN_ON
c_func
(paren
id|strchr
c_func
(paren
id|name
comma
l_char|&squot; &squot;
)paren
)paren
suffix:semicolon
multiline_comment|/* It confuses parsers */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* No constructor, but inital state check requested */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No con, but init state check &quot;
l_string|&quot;requested - %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_DEBUG_INITIAL
suffix:semicolon
)brace
macro_line|#if FORCED_DEBUG
multiline_comment|/*&n;&t; * Enable redzoning and last user accounting, except for caches with&n;&t; * large objects, if the increased size would increase the object size&n;&t; * above the next power of two: caches with object sizes just above a&n;&t; * power of two have a significant amount of internal fragmentation.&n;&t; */
r_if
c_cond
(paren
(paren
id|size
OL
l_int|4096
op_logical_or
id|fls
c_func
(paren
id|size
op_minus
l_int|1
)paren
op_eq
id|fls
c_func
(paren
id|size
op_minus
l_int|1
op_plus
l_int|3
op_star
id|BYTES_PER_WORD
)paren
)paren
)paren
id|flags
op_or_assign
id|SLAB_RED_ZONE
op_or
id|SLAB_STORE_USER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SLAB_DESTROY_BY_RCU
)paren
)paren
id|flags
op_or_assign
id|SLAB_POISON
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DESTROY_BY_RCU
)paren
id|BUG_ON
c_func
(paren
id|flags
op_amp
id|SLAB_POISON
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DESTROY_BY_RCU
)paren
id|BUG_ON
c_func
(paren
id|dtor
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Always checks flags, a caller might be expecting debug&n;&t; * support which isn&squot;t available.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|CREATE_MASK
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check that size is in terms of words.  This is needed to avoid&n;&t; * unaligned accesses for some archs when redzoning is used, and makes&n;&t; * sure any on-slab bufctl&squot;s are also correctly aligned.&n;&t; */
r_if
c_cond
(paren
id|size
op_amp
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
)paren
(brace
id|size
op_add_assign
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* calculate out the final buffer alignment: */
multiline_comment|/* 1) arch recommendation: can be overridden for debug */
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
multiline_comment|/* Default alignment: as specified by the arch code.&n;&t;&t; * Except if an object is really small, then squeeze multiple&n;&t;&t; * objects into one cacheline.&n;&t;&t; */
id|ralign
op_assign
id|cache_line_size
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
op_le
id|ralign
op_div
l_int|2
)paren
id|ralign
op_div_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|ralign
op_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
multiline_comment|/* 2) arch mandated alignment: disables debug if necessary */
r_if
c_cond
(paren
id|ralign
OL
id|ARCH_SLAB_MINALIGN
)paren
(brace
id|ralign
op_assign
id|ARCH_SLAB_MINALIGN
suffix:semicolon
r_if
c_cond
(paren
id|ralign
OG
id|BYTES_PER_WORD
)paren
id|flags
op_and_assign
op_complement
(paren
id|SLAB_RED_ZONE
op_or
id|SLAB_STORE_USER
)paren
suffix:semicolon
)brace
multiline_comment|/* 3) caller mandated alignment: disables debug if necessary */
r_if
c_cond
(paren
id|ralign
OL
id|align
)paren
(brace
id|ralign
op_assign
id|align
suffix:semicolon
r_if
c_cond
(paren
id|ralign
OG
id|BYTES_PER_WORD
)paren
id|flags
op_and_assign
op_complement
(paren
id|SLAB_RED_ZONE
op_or
id|SLAB_STORE_USER
)paren
suffix:semicolon
)brace
multiline_comment|/* 4) Store it. Note that the debug code below can reduce&n;&t; *    the alignment to BYTES_PER_WORD.&n;&t; */
id|align
op_assign
id|ralign
suffix:semicolon
multiline_comment|/* Get cache&squot;s description obj. */
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|opps
suffix:semicolon
id|memset
c_func
(paren
id|cachep
comma
l_int|0
comma
r_sizeof
(paren
id|kmem_cache_t
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG
id|cachep-&gt;reallen
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/* redzoning only works with word aligned caches */
id|align
op_assign
id|BYTES_PER_WORD
suffix:semicolon
multiline_comment|/* add space for red zone words */
id|cachep-&gt;dbghead
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_add_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_STORE_USER
)paren
(brace
multiline_comment|/* user store requires word alignment and&n;&t;&t; * one word storage behind the end of the real&n;&t;&t; * object.&n;&t;&t; */
id|align
op_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
macro_line|#if FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)
r_if
c_cond
(paren
id|size
OG
l_int|128
op_logical_and
id|cachep-&gt;reallen
OG
id|cache_line_size
c_func
(paren
)paren
op_logical_and
id|size
OL
id|PAGE_SIZE
)paren
(brace
id|cachep-&gt;dbghead
op_add_assign
id|PAGE_SIZE
op_minus
id|size
suffix:semicolon
id|size
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/* Determine if the slab management is &squot;on&squot; or &squot;off&squot; slab. */
r_if
c_cond
(paren
id|size
op_ge
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
multiline_comment|/*&n;&t;&t; * Size is large, assume best to place the slab management obj&n;&t;&t; * off-slab (should allow better packing of objs).&n;&t;&t; */
id|flags
op_or_assign
id|CFLGS_OFF_SLAB
suffix:semicolon
id|size
op_assign
id|ALIGN
c_func
(paren
id|size
comma
id|align
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_RECLAIM_ACCOUNT
)paren
op_logical_and
id|size
op_le
id|PAGE_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * A VFS-reclaimable slab tends to have most allocations&n;&t;&t; * as GFP_NOFS and we really don&squot;t want to have to be allocating&n;&t;&t; * higher-order pages when we are unable to shrink dcache.&n;&t;&t; */
id|cachep-&gt;gfporder
op_assign
l_int|0
suffix:semicolon
id|cache_estimate
c_func
(paren
id|cachep-&gt;gfporder
comma
id|size
comma
id|align
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|cachep-&gt;num
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Calculate size (in pages) of slabs, and the num of objs per&n;&t;&t; * slab.  This could be made much more intelligent.  For now,&n;&t;&t; * try to avoid using high page-orders for slabs.  When the&n;&t;&t; * gfp() funcs are more friendly towards high-order requests,&n;&t;&t; * this should be changed.&n;&t;&t; */
r_do
(brace
r_int
r_int
id|break_flag
op_assign
l_int|0
suffix:semicolon
id|cal_wastage
suffix:colon
id|cache_estimate
c_func
(paren
id|cachep-&gt;gfporder
comma
id|size
comma
id|align
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|cachep-&gt;num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_flag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|MAX_GFP_ORDER
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|cachep-&gt;num
OG
id|offslab_limit
)paren
(brace
multiline_comment|/* This num of objs will cause problems. */
id|cachep-&gt;gfporder
op_decrement
suffix:semicolon
id|break_flag
op_increment
suffix:semicolon
r_goto
id|cal_wastage
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Large num of objs is good, but v. large slabs are&n;&t;&t;&t; * currently bad for the gfp()s.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|slab_break_gfp_order
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left_over
op_star
l_int|8
)paren
op_le
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Acceptable internal fragmentation. */
id|next
suffix:colon
id|cachep-&gt;gfporder
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_create: couldn&squot;t create cache %s.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
id|cachep
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
id|slab_size
op_assign
id|ALIGN
c_func
(paren
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|slab
)paren
comma
id|align
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the slab has been placed off-slab, and we have enough space then&n;&t; * move it on-slab. This is at the expense of any extra colouring.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|left_over
op_ge
id|slab_size
)paren
(brace
id|flags
op_and_assign
op_complement
id|CFLGS_OFF_SLAB
suffix:semicolon
id|left_over
op_sub_assign
id|slab_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
(brace
multiline_comment|/* really off slab. No need for manual alignment */
id|slab_size
op_assign
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|slab
)paren
suffix:semicolon
)brace
id|cachep-&gt;colour_off
op_assign
id|cache_line_size
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Offset must be a multiple of the alignment. */
r_if
c_cond
(paren
id|cachep-&gt;colour_off
OL
id|align
)paren
id|cachep-&gt;colour_off
op_assign
id|align
suffix:semicolon
id|cachep-&gt;colour
op_assign
id|left_over
op_div
id|cachep-&gt;colour_off
suffix:semicolon
id|cachep-&gt;slab_size
op_assign
id|slab_size
suffix:semicolon
id|cachep-&gt;flags
op_assign
id|flags
suffix:semicolon
id|cachep-&gt;gfpflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_CACHE_DMA
)paren
id|cachep-&gt;gfpflags
op_or_assign
id|GFP_DMA
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;objsize
op_assign
id|size
suffix:semicolon
multiline_comment|/* NUMA */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_full
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
id|cachep-&gt;slabp_cache
op_assign
id|kmem_find_general_cachep
c_func
(paren
id|slab_size
comma
l_int|0
)paren
suffix:semicolon
id|cachep-&gt;ctor
op_assign
id|ctor
suffix:semicolon
id|cachep-&gt;dtor
op_assign
id|dtor
suffix:semicolon
id|cachep-&gt;name
op_assign
id|name
suffix:semicolon
multiline_comment|/* Don&squot;t let CPUs to come and go */
id|lock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|g_cpucache_up
op_eq
id|FULL
)paren
(brace
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|g_cpucache_up
op_eq
id|NONE
)paren
(brace
multiline_comment|/* Note: the first kmem_cache_create must create&n;&t;&t;&t; * the cache that&squot;s used by kmalloc(24), otherwise&n;&t;&t;&t; * the creation of further caches will BUG().&n;&t;&t;&t; */
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
op_amp
id|initarray_generic.cache
suffix:semicolon
id|g_cpucache_up
op_assign
id|PARTIAL
suffix:semicolon
)brace
r_else
(brace
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ac_data
c_func
(paren
id|cachep
)paren
)paren
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|avail
op_assign
l_int|0
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|batchcount
op_assign
l_int|1
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|touched
op_assign
l_int|0
suffix:semicolon
id|cachep-&gt;batchcount
op_assign
l_int|1
suffix:semicolon
id|cachep-&gt;limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
)brace
id|cachep-&gt;lists.next_reap
op_assign
id|jiffies
op_plus
id|REAPTIMEOUT_LIST3
op_plus
(paren
(paren
r_int
r_int
)paren
id|cachep
)paren
op_mod
id|REAPTIMEOUT_LIST3
suffix:semicolon
multiline_comment|/* Need the semaphore to access the chain. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|pc
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_char
id|tmp
suffix:semicolon
multiline_comment|/* This happens when the module gets unloaded and doesn&squot;t&n;&t;&t;&t;   destroy its slab cache and noone else reuses the vmalloc&n;&t;&t;&t;   area of the module. Print a warning. */
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|tmp
comma
id|pc-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SLAB: cache with size %d has lost its name&bslash;n&quot;
comma
id|pc-&gt;objsize
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|pc-&gt;name
comma
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_create: duplicate cache %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|unlock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
)brace
multiline_comment|/* cache setup completed, link it into the list */
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|unlock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
id|opps
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_and
(paren
id|flags
op_amp
id|SLAB_PANIC
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;kmem_cache_create(): failed to create slab `%s&squot;&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|cachep
suffix:semicolon
)brace
DECL|variable|kmem_cache_create
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_create
)paren
suffix:semicolon
macro_line|#if DEBUG
DECL|function|check_irq_off
r_static
r_void
id|check_irq_off
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_irq_on
r_static
r_void
id|check_irq_on
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_spinlock_acquired
r_static
r_void
id|check_spinlock_acquired
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|spin_trylock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
DECL|macro|check_irq_off
mdefine_line|#define check_irq_off()&t;do { } while(0)
DECL|macro|check_irq_on
mdefine_line|#define check_irq_on()&t;do { } while(0)
DECL|macro|check_spinlock_acquired
mdefine_line|#define check_spinlock_acquired(x) do { } while(0)
macro_line|#endif
multiline_comment|/*&n; * Waits for all CPUs to execute func().&n; */
DECL|function|smp_call_function_all_cpus
r_static
r_void
id|smp_call_function_all_cpus
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|arg
)paren
comma
r_void
op_star
id|arg
)paren
(brace
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|func
c_func
(paren
id|arg
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|func
comma
id|arg
comma
l_int|1
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|drain_array_locked
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|array_cache
op_star
id|ac
comma
r_int
id|force
)paren
suffix:semicolon
DECL|function|do_drain
r_static
r_void
id|do_drain
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
id|ac-&gt;avail
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|ac-&gt;avail
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|drain_cpu_caches
r_static
r_void
id|drain_cpu_caches
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|smp_call_function_all_cpus
c_func
(paren
id|do_drain
comma
id|cachep
)paren
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;lists.shared
)paren
id|drain_array_locked
c_func
(paren
id|cachep
comma
id|cachep-&gt;lists.shared
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
multiline_comment|/* NUMA shrink all list3s */
DECL|function|__cache_shrink
r_static
r_int
id|__cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|drain_cpu_caches
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|p
op_assign
id|cachep-&gt;lists.slabs_free.prev
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cachep-&gt;lists.slabs_free
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|cachep-&gt;lists.slabs_free.prev
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|cachep-&gt;lists.free_objects
op_sub_assign
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_full
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_shrink - Shrink a cache.&n; * @cachep: The cache to shrink.&n; *&n; * Releases as many slabs as possible for a cache.&n; * To help debugging, a zero exit status indicates all slabs were released.&n; */
DECL|function|kmem_cache_shrink
r_int
id|kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|__cache_shrink
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
DECL|variable|kmem_cache_shrink
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_shrink
)paren
suffix:semicolon
multiline_comment|/**&n; * kmem_cache_destroy - delete a cache&n; * @cachep: the cache to destroy&n; *&n; * Remove a kmem_cache_t object from the slab cache.&n; * Returns 0 on success.&n; *&n; * It is expected this function will be called by a module when it is&n; * unloaded.  This will remove the cache completely, and avoid a duplicate&n; * cache being allocated each time a module is loaded and unloaded, if the&n; * module doesn&squot;t have persistent in-kernel storage across loads and unloads.&n; *&n; * The cache must be empty before calling this function.&n; *&n; * The caller must guarantee that noone will allocate memory from the cache&n; * during the kmem_cache_destroy().&n; */
DECL|function|kmem_cache_destroy
r_int
id|kmem_cache_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t let CPUs to come and go */
id|lock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the chain is never empty, cache_cache is never destroyed&n;&t; */
id|list_del
c_func
(paren
op_amp
id|cachep-&gt;next
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__cache_shrink
c_func
(paren
id|cachep
)paren
)paren
(brace
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;Can&squot;t free all objects&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|unlock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_DESTROY_BY_RCU
)paren
)paren
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no cpu_online check required here since we clear the percpu&n;&t; * array on cpu offline and set this to NULL.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|cachep-&gt;array
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* NUMA: free the list3 structures */
id|kfree
c_func
(paren
id|cachep-&gt;lists.shared
)paren
suffix:semicolon
id|cachep-&gt;lists.shared
op_assign
l_int|NULL
suffix:semicolon
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
id|unlock_cpu_hotplug
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|kmem_cache_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_destroy
)paren
suffix:semicolon
multiline_comment|/* Get the memory for a slab management obj. */
DECL|function|alloc_slabmgmt
r_static
r_struct
id|slab
op_star
id|alloc_slabmgmt
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
id|colour_off
comma
r_int
id|local_flags
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
(brace
multiline_comment|/* Slab management obj is off-slab. */
id|slabp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|local_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|slabp
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
id|colour_off
op_add_assign
id|cachep-&gt;slab_size
suffix:semicolon
)brace
id|slabp-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|slabp-&gt;colouroff
op_assign
id|colour_off
suffix:semicolon
id|slabp-&gt;s_mem
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
r_return
id|slabp
suffix:semicolon
)brace
DECL|function|slab_bufctl
r_static
r_inline
id|kmem_bufctl_t
op_star
id|slab_bufctl
c_func
(paren
r_struct
id|slab
op_star
id|slabp
)paren
(brace
r_return
(paren
id|kmem_bufctl_t
op_star
)paren
(paren
id|slabp
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|cache_init_objs
r_static
r_void
id|cache_init_objs
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
comma
r_int
r_int
id|ctor_flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
macro_line|#if DEBUG
multiline_comment|/* need to poison the objs? */
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
comma
id|POISON_FREE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
op_star
id|dbg_userword
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_INACTIVE
suffix:semicolon
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_INACTIVE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Constructors are not allowed to allocate memory from&n;&t;&t; * the same cache which they are a constructor for.&n;&t;&t; * Otherwise, deadlock. They must also be threaded.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;ctor
op_logical_and
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
)paren
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
)paren
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;constructor overwrote the&quot;
l_string|&quot; end of an object&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
)paren
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;constructor overwrote the&quot;
l_string|&quot; start of an object&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cachep-&gt;objsize
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
op_logical_and
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
op_logical_and
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
id|kernel_map_pages
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
comma
id|cachep-&gt;objsize
op_div
id|PAGE_SIZE
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|cachep-&gt;ctor
)paren
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
macro_line|#endif
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|BUFCTL_END
suffix:semicolon
id|slabp-&gt;free
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|kmem_flagcheck
r_static
r_void
id|kmem_flagcheck
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|set_slab_attr
r_static
r_void
id|set_slab_attr
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
comma
r_void
op_star
id|objp
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* Nasty!!!!!! I hope this is OK. */
id|i
op_assign
l_int|1
op_lshift
id|cachep-&gt;gfporder
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_do
(brace
id|SET_PAGE_CACHE
c_func
(paren
id|page
comma
id|cachep
)paren
suffix:semicolon
id|SET_PAGE_SLAB
c_func
(paren
id|page
comma
id|slabp
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Grow (by 1) the number of slabs within a cache.  This is called by&n; * kmem_cache_alloc() when there are no active objs left in a cache.&n; */
DECL|function|cache_grow
r_static
r_int
id|cache_grow
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
comma
r_int
id|nodeid
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|local_flags
suffix:semicolon
r_int
r_int
id|ctor_flags
suffix:semicolon
multiline_comment|/* Be lazy and only check for valid flags here,&n; &t; * keeping it out of the critical path in kmem_cache_alloc().&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_NO_GROW
)paren
r_return
l_int|0
suffix:semicolon
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
id|local_flags
op_assign
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
)paren
multiline_comment|/*&n;&t;&t; * Not allowed to sleep.  Need to tell a constructor about&n;&t;&t; * this - it might need to know...&n;&t;&t; */
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
multiline_comment|/* About to mess with non-constant members - lock. */
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* Get colour for the slab, and cal the next value. */
id|offset
op_assign
id|cachep-&gt;colour_next
suffix:semicolon
id|cachep-&gt;colour_next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;colour_next
op_ge
id|cachep-&gt;colour
)paren
id|cachep-&gt;colour_next
op_assign
l_int|0
suffix:semicolon
id|offset
op_mul_assign
id|cachep-&gt;colour_off
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The test for missing atomic flag is performed here, rather than&n;&t; * the more obvious place, simply to reduce the critical path length&n;&t; * in kmem_cache_alloc(). If a caller is seriously mis-behaving they&n;&t; * will eventually be caught here (where it matters).&n;&t; */
id|kmem_flagcheck
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get mem for the objs. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|objp
op_assign
id|kmem_getpages
c_func
(paren
id|cachep
comma
id|flags
comma
id|nodeid
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* Get slab management. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|alloc_slabmgmt
c_func
(paren
id|cachep
comma
id|objp
comma
id|offset
comma
id|local_flags
)paren
)paren
)paren
r_goto
id|opps1
suffix:semicolon
id|set_slab_attr
c_func
(paren
id|cachep
comma
id|slabp
comma
id|objp
)paren
suffix:semicolon
id|cache_init_objs
c_func
(paren
id|cachep
comma
id|slabp
comma
id|ctor_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* Make slab active. */
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
(paren
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
suffix:semicolon
id|STATS_INC_GROWN
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|free_objects
op_add_assign
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|opps1
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|failed
suffix:colon
r_if
c_cond
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if DEBUG
multiline_comment|/*&n; * Perform extra freeing checks:&n; * - detect bad pointers.&n; * - POISON/RED_ZONE checking&n; * - destructor calls, for caches with POISON+dtor&n; */
DECL|function|kfree_debugcheck
r_static
r_void
id|kfree_debugcheck
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|virt_addr_valid
c_func
(paren
id|objp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree_debugcheck: out of range ptr %lxh.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|objp
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageSlab
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree_debugcheck: bad ptr %lxh.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|objp
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|cache_free_debugcheck
r_static
r_void
op_star
id|cache_free_debugcheck
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_void
op_star
id|caller
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|objnr
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|objp
op_sub_assign
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|kfree_debugcheck
c_func
(paren
id|objp
)paren
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
op_ne
id|cachep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;mismatch in kmem_cache_free: expected cache %p, got %p&bslash;n&quot;
comma
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
comma
id|cachep
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%p is %s.&bslash;n&quot;
comma
id|cachep
comma
id|cachep-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%p is %s.&bslash;n&quot;
comma
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
comma
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_ACTIVE
op_logical_or
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_ACTIVE
)paren
(brace
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;double free, or memory outside&quot;
l_string|&quot; object was overwritten&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%p: redzone 1: 0x%lx, redzone 2: 0x%lx.&bslash;n&quot;
comma
id|objp
comma
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
comma
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
suffix:semicolon
)brace
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_INACTIVE
suffix:semicolon
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_INACTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
op_star
id|dbg_userword
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|caller
suffix:semicolon
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
id|BUG_ON
c_func
(paren
id|objnr
op_ge
id|cachep-&gt;num
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|objp
op_ne
id|slabp-&gt;s_mem
op_plus
id|objnr
op_star
id|cachep-&gt;objsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
(brace
multiline_comment|/* Need to call the slab&squot;s constructor so the&n;&t;&t; * caller can perform a verify of its state (debugging).&n;&t;&t; * Called without the cache-lock held.&n;&t;&t; */
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
comma
id|cachep
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
op_logical_and
id|cachep-&gt;dtor
)paren
(brace
multiline_comment|/* we want to cache poison the object,&n;&t;&t; * call the destruction callback&n;&t;&t; */
id|cachep
op_member_access_from_pointer
id|dtor
c_func
(paren
id|objp
op_plus
id|obj_dbghead
c_func
(paren
id|cachep
)paren
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_PAGEALLOC
r_if
c_cond
(paren
(paren
id|cachep-&gt;objsize
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
op_logical_and
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
(brace
id|store_stackinfo
c_func
(paren
id|cachep
comma
id|objp
comma
(paren
r_int
r_int
)paren
id|caller
)paren
suffix:semicolon
id|kernel_map_pages
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
comma
id|cachep-&gt;objsize
op_div
id|PAGE_SIZE
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
comma
id|POISON_FREE
)paren
suffix:semicolon
)brace
macro_line|#else
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
comma
id|POISON_FREE
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|objp
suffix:semicolon
)brace
DECL|function|check_slabp
r_static
r_void
id|check_slabp
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|entries
op_assign
l_int|0
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* Check slab&squot;s freelist to see if this obj is there. */
r_for
c_loop
(paren
id|i
op_assign
id|slabp-&gt;free
suffix:semicolon
id|i
op_ne
id|BUFCTL_END
suffix:semicolon
id|i
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
)paren
(brace
id|entries
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|entries
OG
id|cachep-&gt;num
op_logical_or
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|cachep-&gt;num
)paren
r_goto
id|bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entries
op_ne
id|cachep-&gt;num
op_minus
id|slabp-&gt;inuse
)paren
(brace
r_int
id|i
suffix:semicolon
id|bad
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;slab: Internal list corruption detected in cache &squot;%s&squot;(%d), slabp %p(%d). Hexdump:&bslash;n&quot;
comma
id|cachep-&gt;name
comma
id|cachep-&gt;num
comma
id|slabp
comma
id|slabp-&gt;inuse
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|slabp
)paren
op_plus
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%03x:&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|slabp
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|kfree_debugcheck
mdefine_line|#define kfree_debugcheck(x) do { } while(0)
DECL|macro|cache_free_debugcheck
mdefine_line|#define cache_free_debugcheck(x,objp,z) (objp)
DECL|macro|check_slabp
mdefine_line|#define check_slabp(x,y) do { } while(0)
macro_line|#endif
DECL|function|cache_alloc_refill
r_static
r_void
op_star
id|cache_alloc_refill
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
id|batchcount
suffix:semicolon
r_struct
id|kmem_list3
op_star
id|l3
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|retry
suffix:colon
id|batchcount
op_assign
id|ac-&gt;batchcount
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ac-&gt;touched
op_logical_and
id|batchcount
OG
id|BATCHREFILL_LIMIT
)paren
(brace
multiline_comment|/* if there was little recent activity on this&n;&t;&t; * cache, then perform only a partial refill.&n;&t;&t; * Otherwise we could generate refill bouncing.&n;&t;&t; */
id|batchcount
op_assign
id|BATCHREFILL_LIMIT
suffix:semicolon
)brace
id|l3
op_assign
id|list3_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac-&gt;avail
OG
l_int|0
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l3-&gt;shared
)paren
(brace
r_struct
id|array_cache
op_star
id|shared_array
op_assign
id|l3-&gt;shared
suffix:semicolon
r_if
c_cond
(paren
id|shared_array-&gt;avail
)paren
(brace
r_if
c_cond
(paren
id|batchcount
OG
id|shared_array-&gt;avail
)paren
id|batchcount
op_assign
id|shared_array-&gt;avail
suffix:semicolon
id|shared_array-&gt;avail
op_sub_assign
id|batchcount
suffix:semicolon
id|ac-&gt;avail
op_assign
id|batchcount
suffix:semicolon
id|memcpy
c_func
(paren
id|ac_entry
c_func
(paren
id|ac
)paren
comma
op_amp
id|ac_entry
c_func
(paren
id|shared_array
)paren
(braket
id|shared_array-&gt;avail
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|batchcount
)paren
suffix:semicolon
id|shared_array-&gt;touched
op_assign
l_int|1
suffix:semicolon
r_goto
id|alloc_done
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|batchcount
OG
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
multiline_comment|/* Get slab alloc is to come from. */
id|entry
op_assign
id|l3-&gt;slabs_partial.next
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|l3-&gt;slabs_partial
)paren
(brace
id|l3-&gt;free_touched
op_assign
l_int|1
suffix:semicolon
id|entry
op_assign
id|l3-&gt;slabs_free.next
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|l3-&gt;slabs_free
)paren
r_goto
id|must_grow
suffix:semicolon
)brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slabp-&gt;inuse
OL
id|cachep-&gt;num
op_logical_and
id|batchcount
op_decrement
)paren
(brace
id|kmem_bufctl_t
id|next
suffix:semicolon
id|STATS_INC_ALLOCED
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_SET_HIGH
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* get obj pointer */
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|slabp-&gt;s_mem
op_plus
id|slabp-&gt;free
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|slabp-&gt;inuse
op_increment
suffix:semicolon
id|next
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
suffix:semicolon
macro_line|#if DEBUG
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
op_assign
id|BUFCTL_FREE
suffix:semicolon
macro_line|#endif
id|slabp-&gt;free
op_assign
id|next
suffix:semicolon
)brace
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
multiline_comment|/* move slabp to correct slabp list: */
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;free
op_eq
id|BUFCTL_END
)paren
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|l3-&gt;slabs_full
)paren
suffix:semicolon
r_else
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|l3-&gt;slabs_partial
)paren
suffix:semicolon
)brace
id|must_grow
suffix:colon
id|l3-&gt;free_objects
op_sub_assign
id|ac-&gt;avail
suffix:semicolon
id|alloc_done
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ac-&gt;avail
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|x
op_assign
id|cache_grow
c_func
(paren
id|cachep
comma
id|flags
comma
op_minus
l_int|1
)paren
suffix:semicolon
singleline_comment|// cache_grow can reenable interrupts, then ac could change.
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
op_logical_and
id|ac-&gt;avail
op_eq
l_int|0
)paren
singleline_comment|// no objects in sight? abort
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ac-&gt;avail
)paren
singleline_comment|// objects refilled by interrupt?
r_goto
id|retry
suffix:semicolon
)brace
id|ac-&gt;touched
op_assign
l_int|1
suffix:semicolon
r_return
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
op_decrement
id|ac-&gt;avail
)braket
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|cache_alloc_debugcheck_before
id|cache_alloc_debugcheck_before
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
id|might_sleep_if
c_func
(paren
id|flags
op_amp
id|__GFP_WAIT
)paren
suffix:semicolon
macro_line|#if DEBUG
id|kmem_flagcheck
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if DEBUG
r_static
r_void
op_star
DECL|function|cache_alloc_debugcheck_after
id|cache_alloc_debugcheck_after
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
comma
r_void
op_star
id|objp
comma
r_void
op_star
id|caller
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_return
id|objp
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_PAGEALLOC
r_if
c_cond
(paren
(paren
id|cachep-&gt;objsize
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
op_logical_and
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kernel_map_pages
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
comma
id|cachep-&gt;objsize
op_div
id|PAGE_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_else
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
macro_line|#else
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
macro_line|#endif
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
comma
id|POISON_INUSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_STORE_USER
)paren
op_star
id|dbg_userword
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|caller
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
op_logical_or
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_ne
id|RED_INACTIVE
)paren
(brace
id|slab_error
c_func
(paren
id|cachep
comma
l_string|&quot;double free, or memory outside&quot;
l_string|&quot; object was overwritten&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%p: redzone 1: 0x%lx, redzone 2: 0x%lx.&bslash;n&quot;
comma
id|objp
comma
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
comma
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
suffix:semicolon
)brace
op_star
id|dbg_redzone1
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_ACTIVE
suffix:semicolon
op_star
id|dbg_redzone2
c_func
(paren
id|cachep
comma
id|objp
)paren
op_assign
id|RED_ACTIVE
suffix:semicolon
)brace
id|objp
op_add_assign
id|obj_dbghead
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;ctor
op_logical_and
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
r_int
r_int
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|__GFP_WAIT
)paren
)paren
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
)brace
r_return
id|objp
suffix:semicolon
)brace
macro_line|#else
DECL|macro|cache_alloc_debugcheck_after
mdefine_line|#define cache_alloc_debugcheck_after(a,b,objp,d) (objp)
macro_line|#endif
DECL|function|__cache_alloc
r_static
r_inline
r_void
op_star
id|__cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|save_flags
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|cache_alloc_debugcheck_before
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ac-&gt;avail
)paren
)paren
(brace
id|STATS_INC_ALLOCHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|ac-&gt;touched
op_assign
l_int|1
suffix:semicolon
id|objp
op_assign
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
op_decrement
id|ac-&gt;avail
)braket
suffix:semicolon
)brace
r_else
(brace
id|STATS_INC_ALLOCMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|objp
op_assign
id|cache_alloc_refill
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|objp
op_assign
id|cache_alloc_debugcheck_after
c_func
(paren
id|cachep
comma
id|flags
comma
id|objp
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|objp
suffix:semicolon
)brace
multiline_comment|/* &n; * NUMA: different approach needed if the spinlock is moved into&n; * the l3 structure&n; */
DECL|function|free_block
r_static
r_void
id|free_block
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|nr_objects
)paren
(brace
r_int
id|i
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* NUMA: move add into loop */
id|cachep-&gt;lists.free_objects
op_add_assign
id|nr_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|objpp
(braket
id|i
)braket
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|objnr
suffix:semicolon
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|objnr
)braket
op_ne
id|BUFCTL_FREE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;slab: double free detected in cache &squot;%s&squot;, objp %p.&bslash;n&quot;
comma
id|cachep-&gt;name
comma
id|objp
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|objnr
)braket
op_assign
id|slabp-&gt;free
suffix:semicolon
id|slabp-&gt;free
op_assign
id|objnr
suffix:semicolon
id|STATS_DEC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;inuse
op_decrement
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
multiline_comment|/* fixup slab chains */
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;lists.free_objects
OG
id|cachep-&gt;free_limit
)paren
(brace
id|cachep-&gt;lists.free_objects
op_sub_assign
id|cachep-&gt;num
suffix:semicolon
id|slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|list3_data_ptr
c_func
(paren
id|cachep
comma
id|objp
)paren
op_member_access_from_pointer
id|slabs_free
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Unconditionally move a slab to the end of the&n;&t;&t;&t; * partial list on free - maximum time for the&n;&t;&t;&t; * other objects to be freed, too.&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|list3_data_ptr
c_func
(paren
id|cachep
comma
id|objp
)paren
op_member_access_from_pointer
id|slabs_partial
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|cache_flusharray
r_static
r_void
id|cache_flusharray
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|array_cache
op_star
id|ac
)paren
(brace
r_int
id|batchcount
suffix:semicolon
id|batchcount
op_assign
id|ac-&gt;batchcount
suffix:semicolon
macro_line|#if DEBUG
id|BUG_ON
c_func
(paren
op_logical_neg
id|batchcount
op_logical_or
id|batchcount
OG
id|ac-&gt;avail
)paren
suffix:semicolon
macro_line|#endif
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;lists.shared
)paren
(brace
r_struct
id|array_cache
op_star
id|shared_array
op_assign
id|cachep-&gt;lists.shared
suffix:semicolon
r_int
id|max
op_assign
id|shared_array-&gt;limit
op_minus
id|shared_array-&gt;avail
suffix:semicolon
r_if
c_cond
(paren
id|max
)paren
(brace
r_if
c_cond
(paren
id|batchcount
OG
id|max
)paren
id|batchcount
op_assign
id|max
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ac_entry
c_func
(paren
id|shared_array
)paren
(braket
id|shared_array-&gt;avail
)braket
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|batchcount
)paren
suffix:semicolon
id|shared_array-&gt;avail
op_add_assign
id|batchcount
suffix:semicolon
r_goto
id|free_done
suffix:semicolon
)brace
)brace
id|free_block
c_func
(paren
id|cachep
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
id|batchcount
)paren
suffix:semicolon
id|free_done
suffix:colon
macro_line|#if STATS
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|p
op_assign
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free.next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
(paren
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|slabp-&gt;inuse
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|STATS_SET_FREEABLE
c_func
(paren
id|cachep
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|ac-&gt;avail
op_sub_assign
id|batchcount
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|batchcount
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|ac-&gt;avail
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * __cache_free&n; * Release an obj back to its cache. If the obj has a constructed&n; * state, it must be in this state _before_ it is released.&n; *&n; * Called with disabled ints.&n; */
DECL|function|__cache_free
r_static
r_inline
r_void
id|__cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_struct
id|array_cache
op_star
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|objp
op_assign
id|cache_free_debugcheck
c_func
(paren
id|cachep
comma
id|objp
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ac-&gt;avail
OL
id|ac-&gt;limit
)paren
)paren
(brace
id|STATS_INC_FREEHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|STATS_INC_FREEMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cache_flusharray
c_func
(paren
id|cachep
comma
id|ac
)paren
suffix:semicolon
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * kmem_cache_alloc - Allocate an object&n; * @cachep: The cache to allocate from.&n; * @flags: See kmalloc().&n; *&n; * Allocate an object from this cache.  The flags are only relevant&n; * if the cache has no available objects.&n; */
DECL|function|kmem_cache_alloc
r_void
op_star
id|kmem_cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_return
id|__cache_alloc
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|kmem_cache_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_alloc
)paren
suffix:semicolon
multiline_comment|/**&n; * kmem_ptr_validate - check if an untrusted pointer might&n; *&t;be a slab entry.&n; * @cachep: the cache we&squot;re checking against&n; * @ptr: pointer to validate&n; *&n; * This verifies that the untrusted pointer looks sane:&n; * it is _not_ a guarantee that the pointer is actually&n; * part of the slab cache in question, but it at least&n; * validates that the pointer can be dereferenced and&n; * looks half-way sane.&n; *&n; * Currently only used for dentry validation.&n; */
DECL|function|kmem_ptr_validate
r_int
id|fastcall
id|kmem_ptr_validate
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|ptr
)paren
(brace
r_int
r_int
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
r_int
r_int
id|min_addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
r_int
r_int
id|align_mask
op_assign
id|BYTES_PER_WORD
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|size
op_assign
id|cachep-&gt;objsize
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|addr
OL
id|min_addr
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|addr
OG
(paren
r_int
r_int
)paren
id|high_memory
op_minus
id|size
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|addr
op_amp
id|align_mask
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|kern_addr_valid
c_func
(paren
id|addr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|kern_addr_valid
c_func
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|PageSlab
c_func
(paren
id|page
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
op_ne
id|cachep
)paren
)paren
r_goto
id|out
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
multiline_comment|/**&n; * kmem_cache_alloc_node - Allocate an object on the specified node&n; * @cachep: The cache to allocate from.&n; * @flags: See kmalloc().&n; * @nodeid: node number of the target node.&n; *&n; * Identical to kmem_cache_alloc, except that this function is slow&n; * and can sleep. And it will allocate memory on the given node, which&n; * can improve the performance for cpu bound structures.&n; */
DECL|function|kmem_cache_alloc_node
r_void
op_star
id|kmem_cache_alloc_node
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|nodeid
)paren
(brace
r_int
id|loop
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|kmem_bufctl_t
id|next
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|loop
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|q
suffix:semicolon
id|objp
op_assign
l_int|NULL
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* walk through all partial and empty slab and find one&n;&t;&t; * from the right node */
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_to_nid
c_func
(paren
id|virt_to_page
c_func
(paren
id|slabp-&gt;s_mem
)paren
)paren
op_eq
id|nodeid
op_logical_or
id|loop
OG
l_int|2
)paren
r_goto
id|got_slabp
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_free
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_to_nid
c_func
(paren
id|virt_to_page
c_func
(paren
id|slabp-&gt;s_mem
)paren
)paren
op_eq
id|nodeid
op_logical_or
id|loop
OG
l_int|2
)paren
r_goto
id|got_slabp
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_grow
c_func
(paren
id|cachep
comma
id|GFP_KERNEL
comma
id|nodeid
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
id|got_slabp
suffix:colon
multiline_comment|/* found one: allocate object */
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ALLOCED
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_SET_HIGH
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_NODEALLOCS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|slabp-&gt;free
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|slabp-&gt;inuse
op_increment
suffix:semicolon
id|next
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
suffix:semicolon
macro_line|#if DEBUG
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
op_assign
id|BUFCTL_FREE
suffix:semicolon
macro_line|#endif
id|slabp-&gt;free
op_assign
id|next
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
multiline_comment|/* move slabp to correct slabp list: */
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;free
op_eq
id|BUFCTL_END
)paren
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|cachep-&gt;lists.slabs_full
)paren
suffix:semicolon
r_else
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
suffix:semicolon
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|free_objects
op_decrement
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|objp
op_assign
id|cache_alloc_debugcheck_after
c_func
(paren
id|cachep
comma
id|GFP_KERNEL
comma
id|objp
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|objp
suffix:semicolon
)brace
DECL|variable|kmem_cache_alloc_node
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_alloc_node
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * kmalloc - allocate memory&n; * @size: how many bytes of memory are required.&n; * @flags: the type of memory to allocate.&n; *&n; * kmalloc is the normal method of allocating memory&n; * in the kernel.&n; *&n; * The @flags argument may be one of:&n; *&n; * %GFP_USER - Allocate memory on behalf of user.  May sleep.&n; *&n; * %GFP_KERNEL - Allocate normal kernel ram.  May sleep.&n; *&n; * %GFP_ATOMIC - Allocation will not sleep.  Use inside interrupt handlers.&n; *&n; * Additionally, the %GFP_DMA flag may be set to indicate the memory&n; * must be suitable for DMA.  This can mean different things on different&n; * platforms.  For example, on i386, it means that the memory must come&n; * from the first 16MB.&n; */
DECL|function|__kmalloc
r_void
op_star
id|__kmalloc
(paren
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|cache_sizes
op_star
id|csizep
op_assign
id|malloc_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
macro_line|#if DEBUG
multiline_comment|/* This happens if someone tries to call&n;&t;&t; * kmem_cache_create(), or kmalloc(), before&n;&t;&t; * the generic caches are initialized.&n;&t;&t; */
id|BUG_ON
c_func
(paren
id|csizep-&gt;cs_cachep
op_eq
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
id|__cache_alloc
c_func
(paren
id|flags
op_amp
id|GFP_DMA
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|__kmalloc
id|EXPORT_SYMBOL
c_func
(paren
id|__kmalloc
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/**&n; * __alloc_percpu - allocate one copy of the object for every present&n; * cpu in the system, zeroing them.&n; * Objects should be dereferenced using the per_cpu_ptr macro only.&n; *&n; * @size: how many bytes of memory are required.&n; * @align: the alignment, which can&squot;t be greater than SMP_CACHE_BYTES.&n; */
DECL|function|__alloc_percpu
r_void
op_star
id|__alloc_percpu
c_func
(paren
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|percpu_data
op_star
id|pdata
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pdata
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdata
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|pdata-&gt;ptrs
(braket
id|i
)braket
op_assign
id|kmem_cache_alloc_node
c_func
(paren
id|kmem_find_general_cachep
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
comma
id|cpu_to_node
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdata-&gt;ptrs
(braket
id|i
)braket
)paren
r_goto
id|unwind_oom
suffix:semicolon
id|memset
c_func
(paren
id|pdata-&gt;ptrs
(braket
id|i
)braket
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* Catch derefs w/o wrappers */
r_return
(paren
r_void
op_star
)paren
(paren
op_complement
(paren
r_int
r_int
)paren
id|pdata
)paren
suffix:semicolon
id|unwind_oom
suffix:colon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|kfree
c_func
(paren
id|pdata-&gt;ptrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pdata
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|__alloc_percpu
id|EXPORT_SYMBOL
c_func
(paren
id|__alloc_percpu
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * kmem_cache_free - Deallocate an object&n; * @cachep: The cache the allocation was from.&n; * @objp: The previously allocated object.&n; *&n; * Free an object which was previously allocated from this&n; * cache.&n; */
DECL|function|kmem_cache_free
r_void
id|kmem_cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|kmem_cache_free
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_free
)paren
suffix:semicolon
multiline_comment|/**&n; * kcalloc - allocate memory for an array. The memory is set to zero.&n; * @n: number of elements.&n; * @size: element size.&n; * @flags: the type of memory to allocate.&n; */
DECL|function|kcalloc
r_void
op_star
id|kcalloc
c_func
(paren
r_int
id|n
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_void
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ne
l_int|0
op_logical_and
id|size
OG
id|INT_MAX
op_div
id|n
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|kmalloc
c_func
(paren
id|n
op_star
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|n
op_star
id|size
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kcalloc
id|EXPORT_SYMBOL
c_func
(paren
id|kcalloc
)paren
suffix:semicolon
multiline_comment|/**&n; * kfree - free previously allocated memory&n; * @objp: pointer returned by kmalloc.&n; *&n; * Don&squot;t free memory not originally allocated by kmalloc()&n; * or you will run into trouble.&n; */
DECL|function|kfree
r_void
id|kfree
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_cache_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_debugcheck
c_func
(paren
id|objp
)paren
suffix:semicolon
id|c
op_assign
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|__cache_free
c_func
(paren
id|c
comma
(paren
r_void
op_star
)paren
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|kfree
id|EXPORT_SYMBOL
c_func
(paren
id|kfree
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/**&n; * free_percpu - free previously allocated percpu memory&n; * @objp: pointer returned by alloc_percpu.&n; *&n; * Don&squot;t free memory not originally allocated by alloc_percpu()&n; * The complemented objp is to check for that.&n; */
r_void
DECL|function|free_percpu
id|free_percpu
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|percpu_data
op_star
id|p
op_assign
(paren
r_struct
id|percpu_data
op_star
)paren
(paren
op_complement
(paren
r_int
r_int
)paren
id|objp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|kfree
c_func
(paren
id|p-&gt;ptrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|variable|free_percpu
id|EXPORT_SYMBOL
c_func
(paren
id|free_percpu
)paren
suffix:semicolon
macro_line|#endif
DECL|function|kmem_cache_size
r_int
r_int
id|kmem_cache_size
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_return
id|obj_reallen
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
DECL|variable|kmem_cache_size
id|EXPORT_SYMBOL
c_func
(paren
id|kmem_cache_size
)paren
suffix:semicolon
DECL|struct|ccupdate_struct
r_struct
id|ccupdate_struct
(brace
DECL|member|cachep
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
DECL|member|new
r_struct
id|array_cache
op_star
r_new
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|do_ccupdate_local
r_static
r_void
id|do_ccupdate_local
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|ccupdate_struct
op_star
r_new
op_assign
(paren
r_struct
id|ccupdate_struct
op_star
)paren
id|info
suffix:semicolon
r_struct
id|array_cache
op_star
id|old
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|old
op_assign
id|ac_data
c_func
(paren
r_new
op_member_access_from_pointer
id|cachep
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|old
suffix:semicolon
)brace
DECL|function|do_tune_cpucache
r_static
r_int
id|do_tune_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|limit
comma
r_int
id|batchcount
comma
r_int
id|shared
)paren
(brace
r_struct
id|ccupdate_struct
r_new
suffix:semicolon
r_struct
id|array_cache
op_star
id|new_shared
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
dot
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
dot
r_new
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
)paren
(brace
r_new
dot
r_new
(braket
id|i
)braket
op_assign
id|alloc_arraycache
c_func
(paren
id|i
comma
id|limit
comma
id|batchcount
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
dot
r_new
(braket
id|i
)braket
)paren
(brace
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|kfree
c_func
(paren
r_new
dot
r_new
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
r_new
dot
r_new
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_new
dot
id|cachep
op_assign
id|cachep
suffix:semicolon
id|smp_call_function_all_cpus
c_func
(paren
id|do_ccupdate_local
comma
(paren
r_void
op_star
)paren
op_amp
r_new
)paren
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;batchcount
op_assign
id|batchcount
suffix:semicolon
id|cachep-&gt;limit
op_assign
id|limit
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|array_cache
op_star
id|ccold
op_assign
r_new
dot
r_new
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccold
)paren
r_continue
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
id|ac_entry
c_func
(paren
id|ccold
)paren
comma
id|ccold-&gt;avail
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ccold
)paren
suffix:semicolon
)brace
id|new_shared
op_assign
id|alloc_arraycache
c_func
(paren
op_minus
l_int|1
comma
id|batchcount
op_star
id|shared
comma
l_int|0xbaadf00d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_shared
)paren
(brace
r_struct
id|array_cache
op_star
id|old
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|old
op_assign
id|cachep-&gt;lists.shared
suffix:semicolon
id|cachep-&gt;lists.shared
op_assign
id|new_shared
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
id|free_block
c_func
(paren
id|cachep
comma
id|ac_entry
c_func
(paren
id|old
)paren
comma
id|old-&gt;avail
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|enable_cpucache
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|limit
comma
id|shared
suffix:semicolon
multiline_comment|/* The head array serves three purposes:&n;&t; * - create a LIFO ordering, i.e. return objects that are cache-warm&n;&t; * - reduce the number of spinlock operations.&n;&t; * - reduce the number of linked list operations on the slab and &n;&t; *   bufctl chains: array operations are cheaper.&n;&t; * The numbers are guessed, we should auto-tune as described by&n;&t; * Bonwick.&n;&t; */
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|131072
)paren
id|limit
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
id|PAGE_SIZE
)paren
id|limit
op_assign
l_int|8
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|1024
)paren
id|limit
op_assign
l_int|24
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|256
)paren
id|limit
op_assign
l_int|54
suffix:semicolon
r_else
id|limit
op_assign
l_int|120
suffix:semicolon
multiline_comment|/* Cpu bound tasks (e.g. network routing) can exhibit cpu bound&n;&t; * allocation behaviour: Most allocs on one cpu, most free operations&n;&t; * on another cpu. For these cases, an efficient object passing between&n;&t; * cpus is necessary. This is provided by a shared array. The array&n;&t; * replaces Bonwick&squot;s magazine layer.&n;&t; * On uniprocessor, it&squot;s functionally equivalent (but less efficient)&n;&t; * to a larger limit. Thus disabled by default.&n;&t; */
id|shared
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|cachep-&gt;objsize
op_le
id|PAGE_SIZE
)paren
id|shared
op_assign
l_int|8
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG
multiline_comment|/* With debugging enabled, large batchcount lead to excessively&n;&t; * long periods with disabled local interrupts. Limit the &n;&t; * batchcount&n;&t; */
r_if
c_cond
(paren
id|limit
OG
l_int|32
)paren
id|limit
op_assign
l_int|32
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|do_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
(paren
id|limit
op_plus
l_int|1
)paren
op_div
l_int|2
comma
id|shared
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;enable_cpucache failed for %s, error %d.&bslash;n&quot;
comma
id|cachep-&gt;name
comma
op_minus
id|err
)paren
suffix:semicolon
)brace
DECL|function|drain_array_locked
r_static
r_void
id|drain_array_locked
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|array_cache
op_star
id|ac
comma
r_int
id|force
)paren
(brace
r_int
id|tofree
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ac-&gt;touched
op_logical_and
op_logical_neg
id|force
)paren
(brace
id|ac-&gt;touched
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ac-&gt;avail
)paren
(brace
id|tofree
op_assign
id|force
ques
c_cond
id|ac-&gt;avail
suffix:colon
(paren
id|ac-&gt;limit
op_plus
l_int|4
)paren
op_div
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|tofree
OG
id|ac-&gt;avail
)paren
(brace
id|tofree
op_assign
(paren
id|ac-&gt;avail
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
)brace
id|free_block
c_func
(paren
id|cachep
comma
id|ac_entry
c_func
(paren
id|ac
)paren
comma
id|tofree
)paren
suffix:semicolon
id|ac-&gt;avail
op_sub_assign
id|tofree
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|tofree
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|ac-&gt;avail
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * cache_reap - Reclaim memory from caches.&n; *&n; * Called from workqueue/eventd every few seconds.&n; * Purpose:&n; * - clear the per-cpu caches for this CPU.&n; * - return freeable pages to the main free memory pool.&n; *&n; * If we cannot acquire the cache chain semaphore then just give up - we&squot;ll&n; * try again on the next iteration.&n; */
DECL|function|cache_reap
r_static
r_void
id|cache_reap
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|list_head
op_star
id|walk
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|cache_chain_sem
)paren
)paren
(brace
multiline_comment|/* Give up. Setup the next iteration. */
id|schedule_delayed_work
c_func
(paren
op_amp
id|__get_cpu_var
c_func
(paren
id|reap_work
)paren
comma
id|REAPTIMEOUT_CPUC
op_plus
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|walk
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|tofree
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|searchp
op_assign
id|list_entry
c_func
(paren
id|walk
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;flags
op_amp
id|SLAB_NO_REAP
)paren
r_goto
id|next
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|drain_array_locked
c_func
(paren
id|searchp
comma
id|ac_data
c_func
(paren
id|searchp
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|searchp-&gt;lists.next_reap
comma
id|jiffies
)paren
)paren
(brace
r_goto
id|next_unlock
suffix:semicolon
)brace
id|searchp-&gt;lists.next_reap
op_assign
id|jiffies
op_plus
id|REAPTIMEOUT_LIST3
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;lists.shared
)paren
id|drain_array_locked
c_func
(paren
id|searchp
comma
id|searchp-&gt;lists.shared
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;lists.free_touched
)paren
(brace
id|searchp-&gt;lists.free_touched
op_assign
l_int|0
suffix:semicolon
r_goto
id|next_unlock
suffix:semicolon
)brace
id|tofree
op_assign
(paren
id|searchp-&gt;free_limit
op_plus
l_int|5
op_star
id|searchp-&gt;num
op_minus
l_int|1
)paren
op_div
(paren
l_int|5
op_star
id|searchp-&gt;num
)paren
suffix:semicolon
r_do
(brace
id|p
op_assign
id|list3_data
c_func
(paren
id|searchp
)paren
op_member_access_from_pointer
id|slabs_free.next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
(paren
id|list3_data
c_func
(paren
id|searchp
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|slabp-&gt;inuse
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|STATS_INC_REAPED
c_func
(paren
id|searchp
)paren
suffix:semicolon
multiline_comment|/* Safe to drop the lock. The slab is no longer&n;&t;&t;&t; * linked to the cache.&n;&t;&t;&t; * searchp cannot disappear, we hold&n;&t;&t;&t; * cache_chain_lock&n;&t;&t;&t; */
id|searchp-&gt;lists.free_objects
op_sub_assign
id|searchp-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|slab_destroy
c_func
(paren
id|searchp
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|tofree
OG
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|next_unlock
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|next
suffix:colon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
multiline_comment|/* Setup the next iteration */
id|schedule_delayed_work
c_func
(paren
op_amp
id|__get_cpu_var
c_func
(paren
id|reap_work
)paren
comma
id|REAPTIMEOUT_CPUC
op_plus
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|s_start
r_static
r_void
op_star
id|s_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|loff_t
id|n
op_assign
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
multiline_comment|/*&n;&t;&t; * Output format version, so at least we can change it&n;&t;&t; * without _too_ many complaints.&n;&t;&t; */
macro_line|#if STATS
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;slabinfo - version: 2.1 (statistics)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;slabinfo - version: 2.1&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt;&quot;
)paren
suffix:semicolon
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot; : tunables &lt;batchcount&gt; &lt;limit&gt; &lt;sharedfactor&gt;&quot;
)paren
suffix:semicolon
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;&quot;
)paren
suffix:semicolon
macro_line|#if STATS
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot; : globalstat &lt;listallocs&gt; &lt;maxobjs&gt; &lt;grown&gt; &lt;reaped&gt;&quot;
l_string|&quot; &lt;error&gt; &lt;maxfreeable&gt; &lt;freelimit&gt; &lt;nodeallocs&gt;&quot;
)paren
suffix:semicolon
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot; : cpustat &lt;allochit&gt; &lt;allocmiss&gt; &lt;freehit&gt; &lt;freemiss&gt;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|seq_putc
c_func
(paren
id|m
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|p
op_assign
id|cache_chain.next
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cache_chain
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
)brace
DECL|function|s_next
r_static
r_void
op_star
id|s_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|p
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|cachep-&gt;next.next
op_eq
op_amp
id|cache_chain
ques
c_cond
l_int|NULL
suffix:colon
id|list_entry
c_func
(paren
id|cachep-&gt;next.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
)brace
DECL|function|s_stop
r_static
r_void
id|s_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
DECL|function|s_show
r_static
r_int
id|s_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|q
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|active_objs
suffix:semicolon
r_int
r_int
id|num_objs
suffix:semicolon
r_int
r_int
id|active_slabs
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|num_slabs
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_char
op_star
id|error
op_assign
l_int|NULL
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|active_objs
op_assign
l_int|0
suffix:semicolon
id|num_slabs
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_full
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_ne
id|cachep-&gt;num
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
l_string|&quot;slabs_full accounting error&quot;
suffix:semicolon
id|active_objs
op_add_assign
id|cachep-&gt;num
suffix:semicolon
id|active_slabs
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_eq
id|cachep-&gt;num
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
l_string|&quot;slabs_partial inuse accounting error&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;inuse
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
l_string|&quot;slabs_partial/inuse accounting error&quot;
suffix:semicolon
id|active_objs
op_add_assign
id|slabp-&gt;inuse
suffix:semicolon
id|active_slabs
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_free
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
l_string|&quot;slabs_free/inuse accounting error&quot;
suffix:semicolon
id|num_slabs
op_increment
suffix:semicolon
)brace
id|num_slabs
op_add_assign
id|active_slabs
suffix:semicolon
id|num_objs
op_assign
id|num_slabs
op_star
id|cachep-&gt;num
suffix:semicolon
r_if
c_cond
(paren
id|num_objs
op_minus
id|active_objs
op_ne
id|cachep-&gt;lists.free_objects
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
l_string|&quot;free_objects accounting error&quot;
suffix:semicolon
id|name
op_assign
id|cachep-&gt;name
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;slab: cache %s error: %s&bslash;n&quot;
comma
id|name
comma
id|error
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%-17s %6lu %6lu %6u %4u %4d&quot;
comma
id|name
comma
id|active_objs
comma
id|num_objs
comma
id|cachep-&gt;objsize
comma
id|cachep-&gt;num
comma
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : tunables %4u %4u %4u&quot;
comma
id|cachep-&gt;limit
comma
id|cachep-&gt;batchcount
comma
id|cachep-&gt;lists.shared-&gt;limit
op_div
id|cachep-&gt;batchcount
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : slabdata %6lu %6lu %6u&quot;
comma
id|active_slabs
comma
id|num_slabs
comma
id|cachep-&gt;lists.shared-&gt;avail
)paren
suffix:semicolon
macro_line|#if STATS
(brace
multiline_comment|/* list3 stats */
r_int
r_int
id|high
op_assign
id|cachep-&gt;high_mark
suffix:semicolon
r_int
r_int
id|allocs
op_assign
id|cachep-&gt;num_allocations
suffix:semicolon
r_int
r_int
id|grown
op_assign
id|cachep-&gt;grown
suffix:semicolon
r_int
r_int
id|reaped
op_assign
id|cachep-&gt;reaped
suffix:semicolon
r_int
r_int
id|errors
op_assign
id|cachep-&gt;errors
suffix:semicolon
r_int
r_int
id|max_freeable
op_assign
id|cachep-&gt;max_freeable
suffix:semicolon
r_int
r_int
id|free_limit
op_assign
id|cachep-&gt;free_limit
suffix:semicolon
r_int
r_int
id|node_allocs
op_assign
id|cachep-&gt;node_allocs
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu&quot;
comma
id|allocs
comma
id|high
comma
id|grown
comma
id|reaped
comma
id|errors
comma
id|max_freeable
comma
id|free_limit
comma
id|node_allocs
)paren
suffix:semicolon
)brace
multiline_comment|/* cpu stats */
(brace
r_int
r_int
id|allochit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allochit
)paren
suffix:semicolon
r_int
r_int
id|allocmiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allocmiss
)paren
suffix:semicolon
r_int
r_int
id|freehit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freehit
)paren
suffix:semicolon
r_int
r_int
id|freemiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freemiss
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : cpustat %6lu %6lu %6lu %6lu&quot;
comma
id|allochit
comma
id|allocmiss
comma
id|freehit
comma
id|freemiss
)paren
suffix:semicolon
)brace
macro_line|#endif
id|seq_putc
c_func
(paren
id|m
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * slabinfo_op - iterator that generates /proc/slabinfo&n; *&n; * Output layout:&n; * cache-name&n; * num-active-objs&n; * total-objs&n; * object size&n; * num-active-slabs&n; * total-slabs&n; * num-pages-per-slab&n; * + further values on SMP and with statistics enabled&n; */
DECL|variable|slabinfo_op
r_struct
id|seq_operations
id|slabinfo_op
op_assign
(brace
dot
id|start
op_assign
id|s_start
comma
dot
id|next
op_assign
id|s_next
comma
dot
id|stop
op_assign
id|s_stop
comma
dot
id|show
op_assign
id|s_show
comma
)brace
suffix:semicolon
DECL|macro|MAX_SLABINFO_WRITE
mdefine_line|#define MAX_SLABINFO_WRITE 128
multiline_comment|/**&n; * slabinfo_write - Tuning for the slab allocator&n; * @file: unused&n; * @buffer: user buffer&n; * @count: data length&n; * @ppos: unused&n; */
DECL|function|slabinfo_write
id|ssize_t
id|slabinfo_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_char
id|kbuf
(braket
id|MAX_SLABINFO_WRITE
op_plus
l_int|1
)braket
comma
op_star
id|tmp
suffix:semicolon
r_int
id|limit
comma
id|batchcount
comma
id|shared
comma
id|res
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|MAX_SLABINFO_WRITE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kbuf
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|kbuf
(braket
id|MAX_SLABINFO_WRITE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_assign
id|strchr
c_func
(paren
id|kbuf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|tmp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|tmp
comma
l_string|&quot; %d %d %d&quot;
comma
op_amp
id|limit
comma
op_amp
id|batchcount
comma
op_amp
id|shared
)paren
op_ne
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cachep-&gt;name
comma
id|kbuf
)paren
)paren
(brace
r_if
c_cond
(paren
id|limit
OL
l_int|1
op_logical_or
id|batchcount
template_param
id|limit
op_logical_or
id|shared
OL
l_int|0
)paren
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|do_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
id|batchcount
comma
id|shared
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ge
l_int|0
)paren
id|res
op_assign
id|count
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ksize
r_int
r_int
id|ksize
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_cache_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|objp
op_ne
l_int|NULL
)paren
)paren
(brace
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|size
op_assign
id|kmem_cache_size
c_func
(paren
id|c
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
eof
