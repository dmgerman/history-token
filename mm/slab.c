multiline_comment|/*&n; * linux/mm/slab.c&n; * Written by Mark Hemment, 1996/97.&n; * (markhe@nextd.demon.co.uk)&n; *&n; * kmem_cache_destroy() + some cleanup - 1999 Andrea Arcangeli&n; *&n; * Major cleanup, different bufctl logic, per-cpu arrays&n; *&t;(c) 2000 Manfred Spraul&n; *&n; * Cleanup, make the head arrays unconditional, preparation for NUMA&n; * &t;(c) 2002 Manfred Spraul&n; *&n; * An implementation of the Slab Allocator as described in outline in;&n; *&t;UNIX Internals: The New Frontiers by Uresh Vahalia&n; *&t;Pub: Prentice Hall&t;ISBN 0-13-101908-2&n; * or with a little more detail in;&n; *&t;The Slab Allocator: An Object-Caching Kernel Memory Allocator&n; *&t;Jeff Bonwick (Sun Microsystems).&n; *&t;Presented at: USENIX Summer 1994 Technical Conference&n; *&n; * The memory is organized in caches, one cache for each object type.&n; * (e.g. inode_cache, dentry_cache, buffer_head, vm_area_struct)&n; * Each cache consists out of many slabs (they are small (usually one&n; * page long) and always contiguous), and each slab contains multiple&n; * initialized objects.&n; *&n; * Each cache can only support one memory type (GFP_DMA, GFP_HIGHMEM,&n; * normal). If you need a special memory type, then must create a new&n; * cache for that memory type.&n; *&n; * In order to reduce fragmentation, the slabs are sorted in 3 groups:&n; *   full slabs with 0 free objects&n; *   partial slabs&n; *   empty slabs with no allocated objects&n; *&n; * If partial slabs exist, then new allocations come from these slabs,&n; * otherwise from empty slabs or new slabs are allocated.&n; *&n; * kmem_cache_destroy() CAN CRASH if you try to allocate from the cache&n; * during kmem_cache_destroy(). The caller must prevent concurrent allocs.&n; *&n; * Each cache has a short per-cpu head array, most allocs&n; * and frees go into that array, and if that array overflows, then 1/2&n; * of the entries in the array are given back into the global cache.&n; * The head array is strictly LIFO and should improve the cache hit rates.&n; * On SMP, it additionally reduces the spinlock operations.&n; *&n; * The c_cpuarray may not be read with enabled local interrupts - &n; * it&squot;s changed with a smp_call_function().&n; *&n; * SMP synchronization:&n; *  constructors and destructors are called without any locking.&n; *  Several members in kmem_cache_t and struct slab never change, they&n; *&t;are accessed without any locking.&n; *  The per-cpu arrays are never accessed from the wrong cpu, no locking,&n; *  &t;and local interrupts are disabled so slab code is preempt-safe.&n; *  The non-constant members are protected with a per-cache irq spinlock.&n; *&n; * Many thanks to Mark Hemment, who wrote another per-cpu slab patch&n; * in 2000 - many ideas in the current implementation are derived from&n; * his patch.&n; *&n; * Further notes from the original documentation:&n; *&n; * 11 April &squot;97.  Started multi-threading - markhe&n; *&t;The global cache-chain is protected by the semaphore &squot;cache_chain_sem&squot;.&n; *&t;The sem is only needed when accessing/extending the cache-chain, which&n; *&t;can never happen inside an interrupt (kmem_cache_create(),&n; *&t;kmem_cache_shrink() and kmem_cache_reap()).&n; *&n; *&t;At present, each engine can be growing a cache.  This should be blocked.&n; *&n; */
macro_line|#include&t;&lt;linux/config.h&gt;
macro_line|#include&t;&lt;linux/slab.h&gt;
macro_line|#include&t;&lt;linux/mm.h&gt;
macro_line|#include&t;&lt;linux/cache.h&gt;
macro_line|#include&t;&lt;linux/interrupt.h&gt;
macro_line|#include&t;&lt;linux/init.h&gt;
macro_line|#include&t;&lt;linux/compiler.h&gt;
macro_line|#include&t;&lt;linux/seq_file.h&gt;
macro_line|#include&t;&lt;linux/notifier.h&gt;
macro_line|#include&t;&lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * DEBUG&t;- 1 for kmem_cache_create() to honour; SLAB_DEBUG_INITIAL,&n; *&t;&t;  SLAB_RED_ZONE &amp; SLAB_POISON.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * STATS&t;- 1 to collect stats for /proc/slabinfo.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * FORCED_DEBUG&t;- 1 enables SLAB_RED_ZONE and SLAB_POISON (if possible)&n; */
macro_line|#ifdef CONFIG_DEBUG_SLAB
DECL|macro|DEBUG
mdefine_line|#define&t;DEBUG&t;&t;1
DECL|macro|STATS
mdefine_line|#define&t;STATS&t;&t;1
DECL|macro|FORCED_DEBUG
mdefine_line|#define&t;FORCED_DEBUG&t;1
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define&t;DEBUG&t;&t;0
DECL|macro|STATS
mdefine_line|#define&t;STATS&t;&t;0
DECL|macro|FORCED_DEBUG
mdefine_line|#define&t;FORCED_DEBUG&t;0
macro_line|#endif
multiline_comment|/* Shouldn&squot;t this be in a header file somewhere? */
DECL|macro|BYTES_PER_WORD
mdefine_line|#define&t;BYTES_PER_WORD&t;&t;sizeof(void *)
multiline_comment|/* Legal flag mask for kmem_cache_create(). */
macro_line|#if DEBUG
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_DEBUG_INITIAL | SLAB_RED_ZONE | &bslash;&n;&t;&t;&t; SLAB_POISON | SLAB_HWCACHE_ALIGN | &bslash;&n;&t;&t;&t; SLAB_NO_REAP | SLAB_CACHE_DMA | &bslash;&n;&t;&t;&t; SLAB_MUST_HWCACHE_ALIGN)
macro_line|#else
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_HWCACHE_ALIGN | SLAB_NO_REAP | &bslash;&n;&t;&t;&t; SLAB_CACHE_DMA | SLAB_MUST_HWCACHE_ALIGN)
macro_line|#endif
multiline_comment|/*&n; * kmem_bufctl_t:&n; *&n; * Bufctl&squot;s are used for linking objs within a slab&n; * linked offsets.&n; *&n; * This implementation relies on &quot;struct page&quot; for locating the cache &amp;&n; * slab an object belongs to.&n; * This allows the bufctl structure to be small (one int), but limits&n; * the number of objects a slab (not a cache) can contain when off-slab&n; * bufctls are used. The limit is the size of the largest general cache&n; * that does not use off-slab slabs.&n; * For 32bit archs with 4 kB pages, is this 56.&n; * This is not serious, as it is only for large objects, when it is unwise&n; * to have too many per slab.&n; * Note: This limit can be raised by introducing a general cache whose size&n; * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.&n; */
DECL|macro|BUFCTL_END
mdefine_line|#define BUFCTL_END 0xffffFFFF
DECL|macro|SLAB_LIMIT
mdefine_line|#define&t;SLAB_LIMIT 0xffffFFFE
DECL|typedef|kmem_bufctl_t
r_typedef
r_int
r_int
id|kmem_bufctl_t
suffix:semicolon
multiline_comment|/* Max number of objs-per-slab for caches which use off-slab slabs.&n; * Needed to avoid a possible looping condition in cache_grow().&n; */
DECL|variable|offslab_limit
r_static
r_int
r_int
id|offslab_limit
suffix:semicolon
multiline_comment|/*&n; * struct slab&n; *&n; * Manages the objs in a slab. Placed either at the beginning of mem allocated&n; * for a slab, or allocated from an general cache.&n; * Slabs are chained into three list: fully used, partial, fully free slabs.&n; */
DECL|struct|slab
r_struct
id|slab
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|colouroff
r_int
r_int
id|colouroff
suffix:semicolon
DECL|member|s_mem
r_void
op_star
id|s_mem
suffix:semicolon
multiline_comment|/* including colour offset */
DECL|member|inuse
r_int
r_int
id|inuse
suffix:semicolon
multiline_comment|/* num of objs active in slab */
DECL|member|free
id|kmem_bufctl_t
id|free
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * struct array_cache&n; *&n; * Per cpu structures&n; * Purpose:&n; * - LIFO ordering, to hand out cache-warm objects from _alloc&n; * - reduce the number of linked list operations&n; * - reduce spinlock operations&n; *&n; * The limit is stored in the per-cpu structure to reduce the data cache&n; * footprint.&n; *&n; */
DECL|struct|array_cache
r_struct
id|array_cache
(brace
DECL|member|avail
r_int
r_int
id|avail
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|batchcount
r_int
r_int
id|batchcount
suffix:semicolon
DECL|member|touched
r_int
r_int
id|touched
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* bootstrap: The caches do not work without cpuarrays anymore,&n; * but the cpuarrays are allocated from the generic caches...&n; */
DECL|macro|BOOT_CPUCACHE_ENTRIES
mdefine_line|#define BOOT_CPUCACHE_ENTRIES&t;1
DECL|struct|arraycache_init
r_struct
id|arraycache_init
(brace
DECL|member|cache
r_struct
id|array_cache
id|cache
suffix:semicolon
DECL|member|entries
r_void
op_star
id|entries
(braket
id|BOOT_CPUCACHE_ENTRIES
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The slab lists of all objects.&n; * Hopefully reduce the internal fragmentation&n; * NUMA: The spinlock could be moved from the kmem_cache_t&n; * into this structure, too. Figure out what causes&n; * fewer cross-node spinlock operations.&n; */
DECL|struct|kmem_list3
r_struct
id|kmem_list3
(brace
DECL|member|slabs_partial
r_struct
id|list_head
id|slabs_partial
suffix:semicolon
multiline_comment|/* partial list first, better asm code */
DECL|member|slabs_full
r_struct
id|list_head
id|slabs_full
suffix:semicolon
DECL|member|slabs_free
r_struct
id|list_head
id|slabs_free
suffix:semicolon
DECL|member|free_objects
r_int
r_int
id|free_objects
suffix:semicolon
DECL|member|free_touched
r_int
id|free_touched
suffix:semicolon
DECL|member|next_reap
r_int
r_int
id|next_reap
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|LIST3_INIT
mdefine_line|#define LIST3_INIT(parent) &bslash;&n;&t;{ &bslash;&n;&t;&t;.slabs_full&t;= LIST_HEAD_INIT(parent.slabs_full), &bslash;&n;&t;&t;.slabs_partial&t;= LIST_HEAD_INIT(parent.slabs_partial), &bslash;&n;&t;&t;.slabs_free&t;= LIST_HEAD_INIT(parent.slabs_free) &bslash;&n;&t;}
DECL|macro|list3_data
mdefine_line|#define list3_data(cachep) &bslash;&n;&t;(&amp;(cachep)-&gt;lists)
multiline_comment|/* NUMA: per-node */
DECL|macro|list3_data_ptr
mdefine_line|#define list3_data_ptr(cachep, ptr) &bslash;&n;&t;&t;list3_data(cachep)
multiline_comment|/*&n; * kmem_cache_t&n; *&n; * manages a cache.&n; */
DECL|struct|kmem_cache_s
r_struct
id|kmem_cache_s
(brace
multiline_comment|/* 1) per-cpu data, touched during every alloc/free */
DECL|member|array
r_struct
id|array_cache
op_star
id|array
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|member|batchcount
r_int
r_int
id|batchcount
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
multiline_comment|/* 2) touched by every alloc &amp; free from the backend */
DECL|member|lists
r_struct
id|kmem_list3
id|lists
suffix:semicolon
multiline_comment|/* NUMA: kmem_3list_t&t;*nodelists[NR_NODES] */
DECL|member|objsize
r_int
r_int
id|objsize
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* constant flags */
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
multiline_comment|/* # of objs per slab */
DECL|member|free_limit
r_int
r_int
id|free_limit
suffix:semicolon
multiline_comment|/* upper limit of objects in the lists */
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
multiline_comment|/* 3) cache_grow/shrink */
multiline_comment|/* order of pgs per slab (2^n) */
DECL|member|gfporder
r_int
r_int
id|gfporder
suffix:semicolon
multiline_comment|/* force GFP flags, e.g. GFP_DMA */
DECL|member|gfpflags
r_int
r_int
id|gfpflags
suffix:semicolon
DECL|member|colour
r_int
id|colour
suffix:semicolon
multiline_comment|/* cache colouring range */
DECL|member|colour_off
r_int
r_int
id|colour_off
suffix:semicolon
multiline_comment|/* colour offset */
DECL|member|colour_next
r_int
r_int
id|colour_next
suffix:semicolon
multiline_comment|/* cache colouring */
DECL|member|slabp_cache
id|kmem_cache_t
op_star
id|slabp_cache
suffix:semicolon
DECL|member|dflags
r_int
r_int
id|dflags
suffix:semicolon
multiline_comment|/* dynamic flags */
multiline_comment|/* constructor func */
DECL|member|ctor
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* de-constructor func */
DECL|member|dtor
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* 4) cache creation/removal */
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
multiline_comment|/* 5) statistics */
macro_line|#if STATS
DECL|member|num_active
r_int
r_int
id|num_active
suffix:semicolon
DECL|member|num_allocations
r_int
r_int
id|num_allocations
suffix:semicolon
DECL|member|high_mark
r_int
r_int
id|high_mark
suffix:semicolon
DECL|member|grown
r_int
r_int
id|grown
suffix:semicolon
DECL|member|reaped
r_int
r_int
id|reaped
suffix:semicolon
DECL|member|errors
r_int
r_int
id|errors
suffix:semicolon
DECL|member|max_freeable
r_int
r_int
id|max_freeable
suffix:semicolon
DECL|member|allochit
id|atomic_t
id|allochit
suffix:semicolon
DECL|member|allocmiss
id|atomic_t
id|allocmiss
suffix:semicolon
DECL|member|freehit
id|atomic_t
id|freehit
suffix:semicolon
DECL|member|freemiss
id|atomic_t
id|freemiss
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* internal c_flags */
DECL|macro|CFLGS_OFF_SLAB
mdefine_line|#define&t;CFLGS_OFF_SLAB&t;0x010000UL&t;/* slab management in own cache */
DECL|macro|OFF_SLAB
mdefine_line|#define&t;OFF_SLAB(x)&t;((x)-&gt;flags &amp; CFLGS_OFF_SLAB)
DECL|macro|BATCHREFILL_LIMIT
mdefine_line|#define BATCHREFILL_LIMIT&t;16
multiline_comment|/* Optimization question: fewer reaps means less &n; * probability for unnessary cpucache drain/refill cycles.&n; *&n; * OTHO the cpuarrays can contain lots of objects,&n; * which could lock up otherwise freeable slabs.&n; */
DECL|macro|REAPTIMEOUT_CPUC
mdefine_line|#define REAPTIMEOUT_CPUC&t;(2*HZ)
DECL|macro|REAPTIMEOUT_LIST3
mdefine_line|#define REAPTIMEOUT_LIST3&t;(4*HZ)
macro_line|#if STATS
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;((x)-&gt;num_active++)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;((x)-&gt;num_active--)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;((x)-&gt;num_allocations++)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;((x)-&gt;grown++)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;((x)-&gt;reaped++)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { if ((x)-&gt;num_active &gt; (x)-&gt;high_mark) &bslash;&n;&t;&t;&t;&t;&t;(x)-&gt;high_mark = (x)-&gt;num_active; &bslash;&n;&t;&t;&t;&t;} while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;((x)-&gt;errors++)
DECL|macro|STATS_SET_FREEABLE
mdefine_line|#define&t;STATS_SET_FREEABLE(x, i) &bslash;&n;&t;&t;&t;&t;do { if ((x)-&gt;max_freeable &lt; i) &bslash;&n;&t;&t;&t;&t;&t;(x)-&gt;max_freeable = i; &bslash;&n;&t;&t;&t;&t;} while (0)
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;atomic_inc(&amp;(x)-&gt;allochit)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;atomic_inc(&amp;(x)-&gt;allocmiss)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;atomic_inc(&amp;(x)-&gt;freehit)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;atomic_inc(&amp;(x)-&gt;freemiss)
macro_line|#else
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;do { } while (0)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;do { } while (0)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;do { } while (0)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { } while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;do { } while (0)
DECL|macro|STATS_SET_FREEABLE
mdefine_line|#define&t;STATS_SET_FREEABLE(x, i) &bslash;&n;&t;&t;&t;&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;do { } while (0)
macro_line|#endif
macro_line|#if DEBUG
multiline_comment|/* Magic nums for obj red zoning.&n; * Placed in the first word before and the first word after an obj.&n; */
DECL|macro|RED_MAGIC1
mdefine_line|#define&t;RED_MAGIC1&t;0x5A2CF071UL&t;/* when obj is active */
DECL|macro|RED_MAGIC2
mdefine_line|#define&t;RED_MAGIC2&t;0x170FC2A5UL&t;/* when obj is inactive */
multiline_comment|/* ...and for poisoning */
DECL|macro|POISON_BYTE
mdefine_line|#define&t;POISON_BYTE&t;0x5a&t;&t;/* byte value for poisoning */
DECL|macro|POISON_END
mdefine_line|#define&t;POISON_END&t;0xa5&t;&t;/* end-byte of poisoning */
macro_line|#endif
multiline_comment|/* maximum size of an obj (in 2^order pages) */
DECL|macro|MAX_OBJ_ORDER
mdefine_line|#define&t;MAX_OBJ_ORDER&t;5&t;/* 32 pages */
multiline_comment|/*&n; * Do not go above this order unless 0 objects fit into the slab.&n; */
DECL|macro|BREAK_GFP_ORDER_HI
mdefine_line|#define&t;BREAK_GFP_ORDER_HI&t;2
DECL|macro|BREAK_GFP_ORDER_LO
mdefine_line|#define&t;BREAK_GFP_ORDER_LO&t;1
DECL|variable|slab_break_gfp_order
r_static
r_int
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_LO
suffix:semicolon
multiline_comment|/*&n; * Absolute limit for the gfp order&n; */
DECL|macro|MAX_GFP_ORDER
mdefine_line|#define&t;MAX_GFP_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* Macros for storing/retrieving the cachep and or slab from the&n; * global &squot;mem_map&squot;. These are used to find the slab an obj belongs to.&n; * With kfree(), these are used to find the cache which an obj belongs to.&n; */
DECL|macro|SET_PAGE_CACHE
mdefine_line|#define&t;SET_PAGE_CACHE(pg,x)  ((pg)-&gt;list.next = (struct list_head *)(x))
DECL|macro|GET_PAGE_CACHE
mdefine_line|#define&t;GET_PAGE_CACHE(pg)    ((kmem_cache_t *)(pg)-&gt;list.next)
DECL|macro|SET_PAGE_SLAB
mdefine_line|#define&t;SET_PAGE_SLAB(pg,x)   ((pg)-&gt;list.prev = (struct list_head *)(x))
DECL|macro|GET_PAGE_SLAB
mdefine_line|#define&t;GET_PAGE_SLAB(pg)     ((struct slab *)(pg)-&gt;list.prev)
multiline_comment|/* Size description struct for general caches. */
DECL|struct|cache_sizes
r_struct
id|cache_sizes
(brace
DECL|member|cs_size
r_int
id|cs_size
suffix:semicolon
DECL|member|cs_cachep
id|kmem_cache_t
op_star
id|cs_cachep
suffix:semicolon
DECL|member|cs_dmacachep
id|kmem_cache_t
op_star
id|cs_dmacachep
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* These are the default caches for kmalloc. Custom caches can have other sizes. */
DECL|variable|malloc_sizes
r_static
r_struct
id|cache_sizes
id|malloc_sizes
(braket
)braket
op_assign
(brace
macro_line|#if PAGE_SIZE == 4096
(brace
l_int|32
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|64
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#if L1_CACHE_BYTES &lt; 64
(brace
l_int|96
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|128
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#if L1_CACHE_BYTES &lt; 128
(brace
l_int|192
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|256
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|512
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|1024
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|2048
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|4096
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|8192
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|16384
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|32768
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|65536
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|131072
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Must match cache_sizes above. Out of line to keep cache footprint low. */
DECL|macro|CN
mdefine_line|#define CN(x) { x, x &quot;(DMA)&quot; }
r_static
r_struct
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|name_dma
r_char
op_star
id|name_dma
suffix:semicolon
DECL|variable|cache_names
)brace
id|cache_names
(braket
)braket
op_assign
(brace
macro_line|#if PAGE_SIZE == 4096
id|CN
c_func
(paren
l_string|&quot;size-32&quot;
)paren
comma
macro_line|#endif
id|CN
c_func
(paren
l_string|&quot;size-64&quot;
)paren
comma
macro_line|#if L1_CACHE_BYTES &lt; 64
id|CN
c_func
(paren
l_string|&quot;size-96&quot;
)paren
comma
macro_line|#endif
id|CN
c_func
(paren
l_string|&quot;size-128&quot;
)paren
comma
macro_line|#if L1_CACHE_BYTES &lt; 128
id|CN
c_func
(paren
l_string|&quot;size-192&quot;
)paren
comma
macro_line|#endif
id|CN
c_func
(paren
l_string|&quot;size-256&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-512&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-1024&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-2048&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-4096&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-8192&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-16384&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-32768&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-65536&quot;
)paren
comma
id|CN
c_func
(paren
l_string|&quot;size-131072&quot;
)paren
)brace
suffix:semicolon
DECL|macro|CN
macro_line|#undef CN
DECL|variable|__initdata
r_struct
id|arraycache_init
id|initarray_cache
id|__initdata
op_assign
(brace
(brace
l_int|0
comma
id|BOOT_CPUCACHE_ENTRIES
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|__initdata
r_struct
id|arraycache_init
id|initarray_generic
id|__initdata
op_assign
(brace
(brace
l_int|0
comma
id|BOOT_CPUCACHE_ENTRIES
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* internal cache of cache description objs */
DECL|variable|cache_cache
r_static
id|kmem_cache_t
id|cache_cache
op_assign
(brace
dot
id|lists
op_assign
id|LIST3_INIT
c_func
(paren
id|cache_cache.lists
)paren
comma
multiline_comment|/* Allow for boot cpu != 0 */
dot
id|array
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_CPUS
op_minus
l_int|1
)braket
op_assign
op_amp
id|initarray_cache.cache
)brace
comma
dot
id|batchcount
op_assign
l_int|1
comma
dot
id|limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
comma
dot
id|objsize
op_assign
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
dot
id|flags
op_assign
id|SLAB_NO_REAP
comma
dot
id|spinlock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|colour_off
op_assign
id|L1_CACHE_BYTES
comma
dot
id|name
op_assign
l_string|&quot;kmem_cache&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* Guard access to the cache-chain. */
DECL|variable|cache_chain_sem
r_static
r_struct
id|semaphore
id|cache_chain_sem
suffix:semicolon
DECL|variable|cache_chain
r_struct
id|list_head
id|cache_chain
suffix:semicolon
multiline_comment|/*&n; * chicken and egg problem: delay the per-cpu array allocation&n; * until the general caches are up.&n; */
r_enum
(brace
DECL|enumerator|NONE
id|NONE
comma
DECL|enumerator|PARTIAL
id|PARTIAL
comma
DECL|enumerator|FULL
id|FULL
DECL|variable|g_cpucache_up
)brace
id|g_cpucache_up
suffix:semicolon
DECL|variable|reap_timers
r_static
r_struct
id|timer_list
id|reap_timers
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_static
r_void
id|reap_timer_fnc
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
suffix:semicolon
multiline_comment|/* Cal the num objs, wastage, and bytes left over for a given slab size. */
DECL|function|cache_estimate
r_static
r_void
id|cache_estimate
(paren
r_int
r_int
id|gfporder
comma
r_int
id|size
comma
r_int
id|flags
comma
r_int
op_star
id|left_over
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wastage
op_assign
id|PAGE_SIZE
op_lshift
id|gfporder
suffix:semicolon
r_int
id|extra
op_assign
l_int|0
suffix:semicolon
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
)paren
(brace
id|base
op_assign
r_sizeof
(paren
r_struct
id|slab
)paren
suffix:semicolon
id|extra
op_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_star
id|size
op_plus
id|L1_CACHE_ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
)paren
op_le
id|wastage
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|SLAB_LIMIT
)paren
id|i
op_assign
id|SLAB_LIMIT
suffix:semicolon
op_star
id|num
op_assign
id|i
suffix:semicolon
id|wastage
op_sub_assign
id|i
op_star
id|size
suffix:semicolon
id|wastage
op_sub_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
)paren
suffix:semicolon
op_star
id|left_over
op_assign
id|wastage
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the reap timer running on the target CPU.  We run at around 1 to 2Hz.&n; * Add the CPU number into the expiry time to minimize the possibility of the&n; * CPUs getting into lockstep and contending for the global cache chain lock.&n; */
DECL|function|start_cpu_timer
r_static
r_void
id|start_cpu_timer
c_func
(paren
r_int
id|cpu
)paren
(brace
r_struct
id|timer_list
op_star
id|rt
op_assign
op_amp
id|reap_timers
(braket
id|cpu
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;function
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;slab: reap timer started for cpu %d&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|init_timer
c_func
(paren
id|rt
)paren
suffix:semicolon
id|rt-&gt;expires
op_assign
id|jiffies
op_plus
id|HZ
op_plus
l_int|3
op_star
id|cpu
suffix:semicolon
id|rt-&gt;function
op_assign
id|reap_timer_fnc
suffix:semicolon
id|add_timer_on
c_func
(paren
id|rt
comma
id|cpu
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Note: if someone calls kmem_cache_alloc() on the new&n; * cpu before the cpuup callback had a chance to allocate&n; * the head arrays, it will oops.&n; * Is CPU_ONLINE early enough?&n; */
DECL|function|cpuup_callback
r_static
r_int
id|__devinit
id|cpuup_callback
c_func
(paren
r_struct
id|notifier_block
op_star
id|nfb
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
)paren
id|hcpu
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|CPU_UP_PREPARE
suffix:colon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
r_int
id|memsize
suffix:semicolon
r_struct
id|array_cache
op_star
id|nc
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
id|memsize
op_assign
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|cachep-&gt;limit
op_plus
r_sizeof
(paren
r_struct
id|array_cache
)paren
suffix:semicolon
id|nc
op_assign
id|kmalloc
c_func
(paren
id|memsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nc
)paren
r_goto
id|bad
suffix:semicolon
id|nc-&gt;avail
op_assign
l_int|0
suffix:semicolon
id|nc-&gt;limit
op_assign
id|cachep-&gt;limit
suffix:semicolon
id|nc-&gt;batchcount
op_assign
id|cachep-&gt;batchcount
suffix:semicolon
id|nc-&gt;touched
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;array
(braket
id|cpu
)braket
op_assign
id|nc
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_ONLINE
suffix:colon
r_if
c_cond
(paren
id|g_cpucache_up
op_eq
id|FULL
)paren
id|start_cpu_timer
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_UP_CANCELED
suffix:colon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
r_struct
id|array_cache
op_star
id|nc
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
id|nc
op_assign
id|cachep-&gt;array
(braket
id|cpu
)braket
suffix:semicolon
id|cachep-&gt;array
(braket
id|cpu
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|nc
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
id|bad
suffix:colon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
id|NOTIFY_BAD
suffix:semicolon
)brace
DECL|variable|cpucache_notifier
r_static
r_struct
id|notifier_block
id|cpucache_notifier
op_assign
(brace
op_amp
id|cpuup_callback
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|function|ac_entry
r_static
r_inline
r_void
op_star
op_star
id|ac_entry
c_func
(paren
r_struct
id|array_cache
op_star
id|ac
)paren
(brace
r_return
(paren
r_void
op_star
op_star
)paren
(paren
id|ac
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ac_data
r_static
r_inline
r_struct
id|array_cache
op_star
id|ac_data
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_return
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup the `cache&squot; cache. */
DECL|function|kmem_cache_init
r_void
id|__init
id|kmem_cache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|left_over
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cache_chain
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cache_cache.next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|cache_estimate
c_func
(paren
l_int|0
comma
id|cache_cache.objsize
comma
l_int|0
comma
op_amp
id|left_over
comma
op_amp
id|cache_cache.num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_cache.num
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cache_cache.colour
op_assign
id|left_over
op_div
id|cache_cache.colour_off
suffix:semicolon
id|cache_cache.colour_next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Register a cpu startup notifier callback&n;&t; * that initializes ac_data for all new cpus&n;&t; */
id|register_cpu_notifier
c_func
(paren
op_amp
id|cpucache_notifier
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup remaining internal and general caches.&n; * Called after the gfp() functions have been enabled, and before smp_init().&n; */
DECL|function|kmem_cache_sizes_init
r_void
id|__init
id|kmem_cache_sizes_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|cache_sizes
op_star
id|sizes
op_assign
id|malloc_sizes
suffix:semicolon
multiline_comment|/*&n;&t; * Fragmentation resistance on low memory - only use bigger&n;&t; * page orders on machines with more than 32MB of memory.&n;&t; */
r_if
c_cond
(paren
id|num_physpages
OG
(paren
l_int|32
op_lshift
l_int|20
)paren
op_rshift
id|PAGE_SHIFT
)paren
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_HI
suffix:semicolon
r_do
(brace
multiline_comment|/* For performance, all the general caches are L1 aligned.&n;&t;&t; * This should be particularly beneficial on SMP boxes, as it&n;&t;&t; * eliminates &quot;false sharing&quot;.&n;&t;&t; * Note for systems short on memory removing the alignment will&n;&t;&t; * allow tighter packing of the smaller caches. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sizes-&gt;cs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|cache_names
(braket
id|sizes
op_minus
id|malloc_sizes
)braket
dot
id|name
comma
id|sizes-&gt;cs_size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Inc off-slab bufctl limit until the ceiling is hit. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|OFF_SLAB
c_func
(paren
id|sizes-&gt;cs_cachep
)paren
)paren
)paren
(brace
id|offslab_limit
op_assign
id|sizes-&gt;cs_size
op_minus
r_sizeof
(paren
r_struct
id|slab
)paren
suffix:semicolon
id|offslab_limit
op_div_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
id|sizes-&gt;cs_dmacachep
op_assign
id|kmem_cache_create
c_func
(paren
id|cache_names
(braket
id|sizes
op_minus
id|malloc_sizes
)braket
dot
id|name_dma
comma
id|sizes-&gt;cs_size
comma
l_int|0
comma
id|SLAB_CACHE_DMA
op_or
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sizes-&gt;cs_dmacachep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|sizes
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sizes-&gt;cs_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The generic caches are running - time to kick out the&n;&t; * bootstrap cpucaches.&n;&t; */
(brace
r_void
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac_data
c_func
(paren
op_amp
id|cache_cache
)paren
op_ne
op_amp
id|initarray_cache.cache
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|ac_data
c_func
(paren
op_amp
id|cache_cache
)paren
comma
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
)paren
suffix:semicolon
id|cache_cache.array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|ptr
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac_data
c_func
(paren
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep
)paren
op_ne
op_amp
id|initarray_generic.cache
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|ac_data
c_func
(paren
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep
)paren
comma
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
)paren
suffix:semicolon
id|malloc_sizes
(braket
l_int|0
)braket
dot
id|cs_cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|ptr
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpucache_init
r_int
id|__init
id|cpucache_init
c_func
(paren
r_void
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|g_cpucache_up
op_assign
id|FULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cachep
comma
op_amp
id|cache_chain
comma
id|next
)paren
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Register the timers that return unneeded&n;&t; * pages to gfp.&n;&t; */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
id|start_cpu_timer
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cpucache_init
id|__initcall
c_func
(paren
id|cpucache_init
)paren
suffix:semicolon
multiline_comment|/* Interface to system&squot;s page allocator. No need to hold the cache-lock.&n; */
DECL|function|kmem_getpages
r_static
r_inline
r_void
op_star
id|kmem_getpages
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * If we requested dmaable memory, we will get it. Even if we&n;&t; * did not request dmaable memory, we might get it, but that&n;&t; * would be relatively rare and ignorable.&n;&t; */
id|flags
op_or_assign
id|cachep-&gt;gfpflags
suffix:semicolon
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
multiline_comment|/* Assume that now we have the pages no one else can legally&n;&t; * messes with the &squot;struct page&squot;s.&n;&t; * However vm_scan() might try to test the structure to see if&n;&t; * it is a named-page or buffer-page.  The members it tests are&n;&t; * of no interest here.....&n;&t; */
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Interface to system&squot;s page release. */
DECL|function|kmem_freepages
r_static
r_inline
r_void
id|kmem_freepages
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|i
op_assign
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* free_pages() does not clear the type bit - we do that.&n;&t; * The pages have been unlinked from their cache-slab,&n;&t; * but their &squot;struct page&squot;s might be accessed in&n;&t; * vm_scan(). Shouldn&squot;t be a worry.&n;&t; */
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|ClearPageSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|dec_page_state
c_func
(paren
id|nr_slab
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
DECL|function|poison_obj
r_static
r_void
id|poison_obj
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|size
op_assign
id|cachep-&gt;objsize
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|addr
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_sub_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
)brace
id|memset
c_func
(paren
id|addr
comma
id|POISON_BYTE
comma
id|size
)paren
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
op_assign
id|POISON_END
suffix:semicolon
)brace
DECL|function|check_poison_obj
r_static
r_int
id|check_poison_obj
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|size
op_assign
id|cachep-&gt;objsize
suffix:semicolon
r_void
op_star
id|end
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|addr
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_sub_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
)brace
id|end
op_assign
id|memchr
c_func
(paren
id|addr
comma
id|POISON_END
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Destroy all the objs in a slab, and release the mem back to the system.&n; * Before calling the slab must have been unlinked from the cache.&n; * The cache-lock is not held/needed.&n; */
DECL|function|slab_destroy
r_static
r_void
id|slab_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
macro_line|#if DEBUG
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;dtor
op_logical_and
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
)paren
(paren
id|cachep-&gt;dtor
)paren
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|cachep-&gt;dtor
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
(paren
id|cachep-&gt;dtor
)paren
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_mem
op_minus
id|slabp-&gt;colouroff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|slabp
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_create - Create a cache.&n; * @name: A string which is used in /proc/slabinfo to identify this cache.&n; * @size: The size of objects to be created in this cache.&n; * @offset: The offset to use within the page.&n; * @flags: SLAB flags&n; * @ctor: A constructor for the objects.&n; * @dtor: A destructor for the objects.&n; *&n; * Returns a ptr to the cache on success, NULL on failure.&n; * Cannot be called within a int, but can be interrupted.&n; * The @ctor is run when new pages are allocated by the cache&n; * and the @dtor is run before the pages are handed back.&n; *&n; * @name must be valid until the cache is destroyed. This implies that&n; * the module calling this has to destroy the cache before getting &n; * unloaded.&n; * &n; * The flags are&n; *&n; * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)&n; * to catch references to uninitialised memory.&n; *&n; * %SLAB_RED_ZONE - Insert `Red&squot; zones around the allocated memory to check&n; * for buffer overruns.&n; *&n; * %SLAB_NO_REAP - Don&squot;t automatically reap this cache when we&squot;re under&n; * memory pressure.&n; *&n; * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware&n; * cacheline.  This can be beneficial if you&squot;re counting cycles as closely&n; * as davem.&n; */
id|kmem_cache_t
op_star
DECL|function|kmem_cache_create
id|kmem_cache_create
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|size
comma
r_int
id|offset
comma
r_int
r_int
id|flags
comma
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
comma
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
)paren
(brace
r_const
r_char
op_star
id|func_nm
op_assign
id|KERN_ERR
l_string|&quot;kmem_create: &quot;
suffix:semicolon
r_int
id|left_over
comma
id|align
comma
id|slab_size
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity checks... these are all serious usage bugs.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|name
)paren
op_logical_or
id|in_interrupt
c_func
(paren
)paren
op_logical_or
(paren
id|size
OL
id|BYTES_PER_WORD
)paren
op_logical_or
(paren
id|size
OG
(paren
l_int|1
op_lshift
id|MAX_OBJ_ORDER
)paren
op_star
id|PAGE_SIZE
)paren
op_logical_or
(paren
id|dtor
op_logical_and
op_logical_neg
id|ctor
)paren
op_logical_or
(paren
id|offset
template_param
id|size
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* No constructor, but inital state check requested */
id|printk
c_func
(paren
l_string|&quot;%sNo con, but init state check requested - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_DEBUG_INITIAL
suffix:semicolon
)brace
macro_line|#if FORCED_DEBUG
r_if
c_cond
(paren
(paren
id|size
OL
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|SLAB_MUST_HWCACHE_ALIGN
)paren
)paren
multiline_comment|/*&n;&t;&t; * do not red zone large object, causes severe&n;&t;&t; * fragmentation.&n;&t;&t; */
id|flags
op_or_assign
id|SLAB_RED_ZONE
suffix:semicolon
id|flags
op_or_assign
id|SLAB_POISON
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t; * Always checks flags, a caller might be expecting debug&n;&t; * support which isn&squot;t available.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|CREATE_MASK
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get cache&squot;s description obj. */
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|opps
suffix:semicolon
id|memset
c_func
(paren
id|cachep
comma
l_int|0
comma
r_sizeof
(paren
id|kmem_cache_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Check that size is in terms of words.  This is needed to avoid&n;&t; * unaligned accesses for some archs when redzoning is used, and makes&n;&t; * sure any on-slab bufctl&squot;s are also correctly aligned.&n;&t; */
r_if
c_cond
(paren
id|size
op_amp
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
)paren
(brace
id|size
op_add_assign
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sForcing size word alignment - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no point trying to honour cache alignment&n;&t;&t; * when redzoning.&n;&t;&t; */
id|flags
op_and_assign
op_complement
id|SLAB_HWCACHE_ALIGN
suffix:semicolon
id|size
op_add_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
multiline_comment|/* words for redzone */
)brace
macro_line|#endif
id|align
op_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
id|align
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
multiline_comment|/* Determine if the slab management is &squot;on&squot; or &squot;off&squot; slab. */
r_if
c_cond
(paren
id|size
op_ge
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
multiline_comment|/*&n;&t;&t; * Size is large, assume best to place the slab management obj&n;&t;&t; * off-slab (should allow better packing of objs).&n;&t;&t; */
id|flags
op_or_assign
id|CFLGS_OFF_SLAB
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
multiline_comment|/* Need to adjust size so that objs are cache aligned. */
multiline_comment|/* Small obj size, can get at least two per cache line. */
r_while
c_loop
(paren
id|size
OL
id|align
op_div
l_int|2
)paren
id|align
op_div_assign
l_int|2
suffix:semicolon
id|size
op_assign
(paren
id|size
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
(paren
op_complement
(paren
id|align
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Cal size (in pages) of slabs, and the num of objs per slab.&n;&t; * This could be made much more intelligent.  For now, try to avoid&n;&t; * using high page-orders for slabs.  When the gfp() funcs are more&n;&t; * friendly towards high-order requests, this should be changed.&n;&t; */
r_do
(brace
r_int
r_int
id|break_flag
op_assign
l_int|0
suffix:semicolon
id|cal_wastage
suffix:colon
id|cache_estimate
c_func
(paren
id|cachep-&gt;gfporder
comma
id|size
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|cachep-&gt;num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_flag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|MAX_GFP_ORDER
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|cachep-&gt;num
OG
id|offslab_limit
)paren
(brace
multiline_comment|/* Oops, this num of objs will cause problems. */
id|cachep-&gt;gfporder
op_decrement
suffix:semicolon
id|break_flag
op_increment
suffix:semicolon
r_goto
id|cal_wastage
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Large num of objs is good, but v. large slabs are currently&n;&t;&t; * bad for the gfp()s.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|slab_break_gfp_order
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left_over
op_star
l_int|8
)paren
op_le
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Acceptable internal fragmentation. */
id|next
suffix:colon
id|cachep-&gt;gfporder
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_create: couldn&squot;t create cache %s.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
id|cachep
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
id|slab_size
op_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|slab
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the slab has been placed off-slab, and we have enough space then&n;&t; * move it on-slab. This is at the expense of any extra colouring.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|left_over
op_ge
id|slab_size
)paren
(brace
id|flags
op_and_assign
op_complement
id|CFLGS_OFF_SLAB
suffix:semicolon
id|left_over
op_sub_assign
id|slab_size
suffix:semicolon
)brace
multiline_comment|/* Offset must be a multiple of the alignment. */
id|offset
op_add_assign
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|offset
op_and_assign
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|offset
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
id|cachep-&gt;colour_off
op_assign
id|offset
suffix:semicolon
id|cachep-&gt;colour
op_assign
id|left_over
op_div
id|offset
suffix:semicolon
id|cachep-&gt;flags
op_assign
id|flags
suffix:semicolon
id|cachep-&gt;gfpflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_CACHE_DMA
)paren
id|cachep-&gt;gfpflags
op_or_assign
id|GFP_DMA
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;objsize
op_assign
id|size
suffix:semicolon
multiline_comment|/* NUMA */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_full
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
id|cachep-&gt;slabp_cache
op_assign
id|kmem_find_general_cachep
c_func
(paren
id|slab_size
comma
l_int|0
)paren
suffix:semicolon
id|cachep-&gt;ctor
op_assign
id|ctor
suffix:semicolon
id|cachep-&gt;dtor
op_assign
id|dtor
suffix:semicolon
id|cachep-&gt;name
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
id|g_cpucache_up
op_eq
id|FULL
)paren
(brace
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|g_cpucache_up
op_eq
id|NONE
)paren
(brace
multiline_comment|/* Note: the first kmem_cache_create must create&n;&t;&t;&t; * the cache that&squot;s used by kmalloc(24), otherwise&n;&t;&t;&t; * the creation of further caches will BUG().&n;&t;&t;&t; */
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
op_amp
id|initarray_generic.cache
suffix:semicolon
id|g_cpucache_up
op_assign
id|PARTIAL
suffix:semicolon
)brace
r_else
(brace
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arraycache_init
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ac_data
c_func
(paren
id|cachep
)paren
)paren
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|avail
op_assign
l_int|0
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|batchcount
op_assign
l_int|1
suffix:semicolon
id|ac_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|touched
op_assign
l_int|0
suffix:semicolon
id|cachep-&gt;batchcount
op_assign
l_int|1
suffix:semicolon
id|cachep-&gt;limit
op_assign
id|BOOT_CPUCACHE_ENTRIES
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
)brace
id|cachep-&gt;lists.next_reap
op_assign
id|jiffies
op_plus
id|REAPTIMEOUT_LIST3
op_plus
(paren
(paren
r_int
r_int
)paren
id|cachep
)paren
op_mod
id|REAPTIMEOUT_LIST3
suffix:semicolon
multiline_comment|/* Need the semaphore to access the chain. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|pc
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_char
id|tmp
suffix:semicolon
multiline_comment|/* This happens when the module gets unloaded and doesn&squot;t&n;&t;&t;&t;   destroy its slab cache and noone else reuses the vmalloc&n;&t;&t;&t;   area of the module. Print a warning. */
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|tmp
comma
id|pc-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SLAB: cache with size %d has lost its name&bslash;n&quot;
comma
id|pc-&gt;objsize
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|pc-&gt;name
comma
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_create: duplicate cache %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
)brace
multiline_comment|/* cache setup completed, link it into the list */
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|opps
suffix:colon
r_return
id|cachep
suffix:semicolon
)brace
DECL|function|check_irq_off
r_static
r_inline
r_void
id|check_irq_off
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|check_irq_on
r_static
r_inline
r_void
id|check_irq_on
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG
id|BUG_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|check_spinlock_acquired
r_static
r_inline
r_void
id|check_spinlock_acquired
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|spin_trylock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Waits for all CPUs to execute func().&n; */
DECL|function|smp_call_function_all_cpus
r_static
r_void
id|smp_call_function_all_cpus
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|arg
)paren
comma
r_void
op_star
id|arg
)paren
(brace
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|func
c_func
(paren
id|arg
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|func
comma
id|arg
comma
l_int|1
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|free_block
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
suffix:semicolon
DECL|function|do_drain
r_static
r_void
id|do_drain
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
id|ac-&gt;avail
)paren
suffix:semicolon
id|ac-&gt;avail
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|drain_cpu_caches
r_static
r_void
id|drain_cpu_caches
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|smp_call_function_all_cpus
c_func
(paren
id|do_drain
comma
id|cachep
)paren
suffix:semicolon
)brace
multiline_comment|/* NUMA shrink all list3s */
DECL|function|__cache_shrink
r_static
r_int
id|__cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|drain_cpu_caches
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|p
op_assign
id|cachep-&gt;lists.slabs_free.prev
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cachep-&gt;lists.slabs_free
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|cachep-&gt;lists.slabs_free.prev
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|cachep-&gt;lists.free_objects
op_sub_assign
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_full
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_shrink - Shrink a cache.&n; * @cachep: The cache to shrink.&n; *&n; * Releases as many slabs as possible for a cache.&n; * To help debugging, a zero exit status indicates all slabs were released.&n; */
DECL|function|kmem_cache_shrink
r_int
id|kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|__cache_shrink
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_destroy - delete a cache&n; * @cachep: the cache to destroy&n; *&n; * Remove a kmem_cache_t object from the slab cache.&n; * Returns 0 on success.&n; *&n; * It is expected this function will be called by a module when it is&n; * unloaded.  This will remove the cache completely, and avoid a duplicate&n; * cache being allocated each time a module is loaded and unloaded, if the&n; * module doesn&squot;t have persistent in-kernel storage across loads and unloads.&n; *&n; * The caller must guarantee that noone will allocate memory from the cache&n; * during the kmem_cache_destroy().&n; */
DECL|function|kmem_cache_destroy
r_int
id|kmem_cache_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the chain is never empty, cache_cache is never destroyed&n;&t; */
id|list_del
c_func
(paren
op_amp
id|cachep-&gt;next
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__cache_shrink
c_func
(paren
id|cachep
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_cache_destroy: Can&squot;t free all objects %p&bslash;n&quot;
comma
id|cachep
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|cachep-&gt;array
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* NUMA: free the list3 structures */
)brace
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the memory for a slab management obj. */
DECL|function|alloc_slabmgmt
r_static
r_inline
r_struct
id|slab
op_star
id|alloc_slabmgmt
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
id|colour_off
comma
r_int
id|local_flags
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
(brace
multiline_comment|/* Slab management obj is off-slab. */
id|slabp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|local_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|slabp
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
id|colour_off
op_add_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|slab
)paren
)paren
suffix:semicolon
)brace
id|slabp-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|slabp-&gt;colouroff
op_assign
id|colour_off
suffix:semicolon
id|slabp-&gt;s_mem
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
r_return
id|slabp
suffix:semicolon
)brace
DECL|function|slab_bufctl
r_static
r_inline
id|kmem_bufctl_t
op_star
id|slab_bufctl
c_func
(paren
r_struct
id|slab
op_star
id|slabp
)paren
(brace
r_return
(paren
id|kmem_bufctl_t
op_star
)paren
(paren
id|slabp
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|cache_init_objs
r_static
r_void
id|cache_init_objs
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
comma
r_int
r_int
id|ctor_flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
macro_line|#if DEBUG
multiline_comment|/* need to poison the objs? */
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_assign
id|RED_MAGIC1
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_assign
id|RED_MAGIC1
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Constructors are not allowed to allocate memory from&n;&t;&t; * the same cache which they are a constructor for.&n;&t;&t; * Otherwise, deadlock. They must also be threaded.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;ctor
op_logical_and
op_logical_neg
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
)paren
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|cachep-&gt;ctor
)paren
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
macro_line|#endif
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|BUFCTL_END
suffix:semicolon
id|slabp-&gt;free
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|kmem_flagcheck
r_static
r_void
id|kmem_flagcheck
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|__GFP_WAIT
)paren
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Grow (by 1) the number of slabs within a cache.  This is called by&n; * kmem_cache_alloc() when there are no active objs left in a cache.&n; */
DECL|function|cache_grow
r_static
r_int
id|cache_grow
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
r_int
id|i
comma
id|local_flags
suffix:semicolon
r_int
r_int
id|ctor_flags
suffix:semicolon
multiline_comment|/* Be lazy and only check for valid flags here,&n; &t; * keeping it out of the critical path in kmem_cache_alloc().&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_NO_GROW
)paren
r_return
l_int|0
suffix:semicolon
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
id|local_flags
op_assign
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
)paren
multiline_comment|/*&n;&t;&t; * Not allowed to sleep.  Need to tell a constructor about&n;&t;&t; * this - it might need to know...&n;&t;&t; */
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
multiline_comment|/* About to mess with non-constant members - lock. */
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* Get colour for the slab, and cal the next value. */
id|offset
op_assign
id|cachep-&gt;colour_next
suffix:semicolon
id|cachep-&gt;colour_next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;colour_next
op_ge
id|cachep-&gt;colour
)paren
id|cachep-&gt;colour_next
op_assign
l_int|0
suffix:semicolon
id|offset
op_mul_assign
id|cachep-&gt;colour_off
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The test for missing atomic flag is performed here, rather than&n;&t; * the more obvious place, simply to reduce the critical path length&n;&t; * in kmem_cache_alloc(). If a caller is seriously mis-behaving they&n;&t; * will eventually be caught here (where it matters).&n;&t; */
id|kmem_flagcheck
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get mem for the objs. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|objp
op_assign
id|kmem_getpages
c_func
(paren
id|cachep
comma
id|flags
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* Get slab management. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|alloc_slabmgmt
c_func
(paren
id|cachep
comma
id|objp
comma
id|offset
comma
id|local_flags
)paren
)paren
)paren
r_goto
id|opps1
suffix:semicolon
multiline_comment|/* Nasty!!!!!! I hope this is OK. */
id|i
op_assign
l_int|1
op_lshift
id|cachep-&gt;gfporder
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_do
(brace
id|SET_PAGE_CACHE
c_func
(paren
id|page
comma
id|cachep
)paren
suffix:semicolon
id|SET_PAGE_SLAB
c_func
(paren
id|page
comma
id|slabp
)paren
suffix:semicolon
id|SetPageSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|nr_slab
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
id|cache_init_objs
c_func
(paren
id|cachep
comma
id|slabp
comma
id|ctor_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_amp
id|__GFP_WAIT
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* Make slab active. */
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
(paren
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
suffix:semicolon
id|STATS_INC_GROWN
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|free_objects
op_add_assign
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|opps1
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|failed
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform extra freeing checks:&n; * - detect bad pointers.&n; * - POISON/RED_ZONE checking&n; * - destructor calls, for caches with POISON+dtor&n; */
DECL|function|kfree_debugcheck
r_static
r_inline
r_void
id|kfree_debugcheck
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
macro_line|#if DEBUG
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|virt_addr_valid
c_func
(paren
id|objp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree_debugcheck: out of range ptr %lxh.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|objp
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageSlab
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree_debugcheck: bad ptr %lxh.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|objp
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif 
)brace
DECL|function|cache_free_debugcheck
r_static
r_inline
r_void
op_star
id|cache_free_debugcheck
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
macro_line|#if DEBUG
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|objnr
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|kfree_debugcheck
c_func
(paren
id|objp
)paren
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|GET_PAGE_CACHE
c_func
(paren
id|page
)paren
op_ne
id|cachep
)paren
suffix:semicolon
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|RED_MAGIC1
)paren
op_ne
id|RED_MAGIC2
)paren
multiline_comment|/* Either write before start, or a double free. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
comma
id|RED_MAGIC1
)paren
op_ne
id|RED_MAGIC2
)paren
multiline_comment|/* Either write past end, or a double free. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
id|BUG_ON
c_func
(paren
id|objnr
op_ge
id|cachep-&gt;num
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|objp
op_ne
id|slabp-&gt;s_mem
op_plus
id|objnr
op_star
id|cachep-&gt;objsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
(brace
multiline_comment|/* Need to call the slab&squot;s constructor so the&n;&t;&t; * caller can perform a verify of its state (debugging).&n;&t;&t; * Called without the cache-lock held.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
op_plus
id|BYTES_PER_WORD
comma
id|cachep
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
)brace
r_else
(brace
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
op_logical_and
id|cachep-&gt;dtor
)paren
(brace
multiline_comment|/* we want to cache poison the object,&n;&t;&t; * call the destruction callback&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
id|cachep
op_member_access_from_pointer
id|dtor
c_func
(paren
id|objp
op_plus
id|BYTES_PER_WORD
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
r_else
id|cachep
op_member_access_from_pointer
id|dtor
c_func
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
id|poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|objp
suffix:semicolon
)brace
DECL|function|check_slabp
r_static
r_inline
r_void
id|check_slabp
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
macro_line|#if DEBUG
r_int
id|i
suffix:semicolon
r_int
id|entries
op_assign
l_int|0
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* Check slab&squot;s freelist to see if this obj is there. */
r_for
c_loop
(paren
id|i
op_assign
id|slabp-&gt;free
suffix:semicolon
id|i
op_ne
id|BUFCTL_END
suffix:semicolon
id|i
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
)paren
(brace
id|entries
op_increment
suffix:semicolon
id|BUG_ON
c_func
(paren
id|entries
OG
id|cachep-&gt;num
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|entries
op_ne
id|cachep-&gt;num
op_minus
id|slabp-&gt;inuse
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|cache_alloc_one_tail
r_static
r_inline
r_void
op_star
id|cache_alloc_one_tail
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
r_void
op_star
id|objp
suffix:semicolon
id|check_spinlock_acquired
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ALLOCED
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_SET_HIGH
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* get obj pointer */
id|slabp-&gt;inuse
op_increment
suffix:semicolon
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|slabp-&gt;free
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|slabp-&gt;free
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
suffix:semicolon
r_return
id|objp
suffix:semicolon
)brace
DECL|function|cache_alloc_listfixup
r_static
r_inline
r_void
id|cache_alloc_listfixup
c_func
(paren
r_struct
id|kmem_list3
op_star
id|l3
comma
r_struct
id|slab
op_star
id|slabp
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;free
op_eq
id|BUFCTL_END
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|l3-&gt;slabs_full
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|l3-&gt;slabs_partial
)paren
suffix:semicolon
)brace
)brace
DECL|function|cache_alloc_refill
r_static
r_void
op_star
id|cache_alloc_refill
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
id|batchcount
suffix:semicolon
r_struct
id|kmem_list3
op_star
id|l3
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|retry
suffix:colon
id|batchcount
op_assign
id|ac-&gt;batchcount
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ac-&gt;touched
op_logical_and
id|batchcount
OG
id|BATCHREFILL_LIMIT
)paren
(brace
multiline_comment|/* if there was little recent activity on this&n;&t;&t; * cache, then perform only a partial refill.&n;&t;&t; * Otherwise we could generate refill bouncing.&n;&t;&t; */
id|batchcount
op_assign
id|BATCHREFILL_LIMIT
suffix:semicolon
)brace
id|l3
op_assign
id|list3_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ac-&gt;avail
OG
l_int|0
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|batchcount
OG
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
multiline_comment|/* Get slab alloc is to come from. */
id|entry
op_assign
id|l3-&gt;slabs_partial.next
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|l3-&gt;slabs_partial
)paren
(brace
id|l3-&gt;free_touched
op_assign
l_int|1
suffix:semicolon
id|entry
op_assign
id|l3-&gt;slabs_free.next
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|l3-&gt;slabs_free
)paren
r_goto
id|must_grow
suffix:semicolon
)brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slabp-&gt;inuse
OL
id|cachep-&gt;num
op_logical_and
id|batchcount
op_decrement
)paren
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|cache_alloc_one_tail
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|check_slabp
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|cache_alloc_listfixup
c_func
(paren
id|l3
comma
id|slabp
)paren
suffix:semicolon
)brace
id|must_grow
suffix:colon
id|l3-&gt;free_objects
op_sub_assign
id|ac-&gt;avail
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ac-&gt;avail
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|x
op_assign
id|cache_grow
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// cache_grow can reenable interrupts, then ac could change.
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
op_logical_and
id|ac-&gt;avail
op_eq
l_int|0
)paren
singleline_comment|// no objects in sight? abort
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ac-&gt;avail
)paren
singleline_comment|// objects refilled by interrupt?
r_goto
id|retry
suffix:semicolon
)brace
id|ac-&gt;touched
op_assign
l_int|1
suffix:semicolon
r_return
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
op_decrement
id|ac-&gt;avail
)braket
suffix:semicolon
)brace
DECL|function|cache_alloc_debugcheck_before
r_static
r_inline
r_void
id|cache_alloc_debugcheck_before
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
macro_line|#if DEBUG
id|kmem_flagcheck
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|cache_alloc_debugcheck_after
r_static
r_inline
r_void
op_star
id|cache_alloc_debugcheck_after
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
comma
r_void
op_star
id|objp
)paren
(brace
macro_line|#if DEBUG
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_return
id|objp
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
r_if
c_cond
(paren
id|check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/* Set alloc red-zone, and check old one. */
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|RED_MAGIC2
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
comma
id|RED_MAGIC2
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;ctor
op_logical_and
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
(brace
r_int
r_int
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flags
op_amp
id|__GFP_WAIT
)paren
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|objp
suffix:semicolon
)brace
DECL|function|__cache_alloc
r_static
r_inline
r_void
op_star
id|__cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|save_flags
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
id|cache_alloc_debugcheck_before
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ac-&gt;avail
)paren
)paren
(brace
id|STATS_INC_ALLOCHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|ac-&gt;touched
op_assign
l_int|1
suffix:semicolon
id|objp
op_assign
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
op_decrement
id|ac-&gt;avail
)braket
suffix:semicolon
)brace
r_else
(brace
id|STATS_INC_ALLOCMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|objp
op_assign
id|cache_alloc_refill
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|objp
op_assign
id|cache_alloc_debugcheck_after
c_func
(paren
id|cachep
comma
id|flags
comma
id|objp
)paren
suffix:semicolon
r_return
id|objp
suffix:semicolon
)brace
multiline_comment|/* &n; * NUMA: different approach needed if the spinlock is moved into&n; * the l3 structure&n; */
r_static
r_inline
r_void
DECL|function|__free_block
id|__free_block
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|nr_objects
)paren
(brace
r_int
id|i
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* NUMA: move add into loop */
id|cachep-&gt;lists.free_objects
op_add_assign
id|nr_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|objpp
(braket
id|i
)braket
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|objnr
suffix:semicolon
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|objnr
)braket
op_assign
id|slabp-&gt;free
suffix:semicolon
id|slabp-&gt;free
op_assign
id|objnr
suffix:semicolon
id|STATS_DEC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;inuse
op_decrement
suffix:semicolon
multiline_comment|/* fixup slab chains */
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;lists.free_objects
OG
id|cachep-&gt;free_limit
)paren
(brace
id|cachep-&gt;lists.free_objects
op_sub_assign
id|cachep-&gt;num
suffix:semicolon
id|slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|list3_data_ptr
c_func
(paren
id|cachep
comma
id|objp
)paren
op_member_access_from_pointer
id|slabs_free
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Unconditionally move a slab to the end of the&n;&t;&t;&t; * partial list on free - maximum time for the&n;&t;&t;&t; * other objects to be freed, too.&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|list3_data_ptr
c_func
(paren
id|cachep
comma
id|objp
)paren
op_member_access_from_pointer
id|slabs_partial
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
DECL|function|free_block
r_static
r_void
id|free_block
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
(brace
id|__free_block
c_func
(paren
id|cachep
comma
id|objpp
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|cache_flusharray
r_static
r_void
id|cache_flusharray
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_struct
id|array_cache
op_star
id|ac
)paren
(brace
r_int
id|batchcount
suffix:semicolon
id|batchcount
op_assign
id|ac-&gt;batchcount
suffix:semicolon
macro_line|#if DEBUG
id|BUG_ON
c_func
(paren
op_logical_neg
id|batchcount
op_logical_or
id|batchcount
OG
id|ac-&gt;avail
)paren
suffix:semicolon
macro_line|#endif
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|__free_block
c_func
(paren
id|cachep
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
id|batchcount
)paren
suffix:semicolon
macro_line|#if STATS
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|p
op_assign
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free.next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
(paren
id|list3_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
(brace
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|slabp-&gt;inuse
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|STATS_SET_FREEABLE
c_func
(paren
id|cachep
comma
id|i
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ac-&gt;avail
op_sub_assign
id|batchcount
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|batchcount
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|ac-&gt;avail
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * __cache_free&n; * Release an obj back to its cache. If the obj has a constructed&n; * state, it must be in this state _before_ it is released.&n; *&n; * Called with disabled ints.&n; */
DECL|function|__cache_free
r_static
r_inline
r_void
id|__cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_struct
id|array_cache
op_star
id|ac
op_assign
id|ac_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|objp
op_assign
id|cache_free_debugcheck
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ac-&gt;avail
OL
id|ac-&gt;limit
)paren
)paren
(brace
id|STATS_INC_FREEHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|STATS_INC_FREEMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cache_flusharray
c_func
(paren
id|cachep
comma
id|ac
)paren
suffix:semicolon
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|ac-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * kmem_cache_alloc - Allocate an object&n; * @cachep: The cache to allocate from.&n; * @flags: See kmalloc().&n; *&n; * Allocate an object from this cache.  The flags are only relevant&n; * if the cache has no available objects.&n; */
DECL|function|kmem_cache_alloc
r_void
op_star
id|kmem_cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_return
id|__cache_alloc
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmalloc - allocate memory&n; * @size: how many bytes of memory are required.&n; * @flags: the type of memory to allocate.&n; *&n; * kmalloc is the normal method of allocating memory&n; * in the kernel.&n; *&n; * The @flags argument may be one of:&n; *&n; * %GFP_USER - Allocate memory on behalf of user.  May sleep.&n; *&n; * %GFP_KERNEL - Allocate normal kernel ram.  May sleep.&n; *&n; * %GFP_ATOMIC - Allocation will not sleep.  Use inside interrupt handlers.&n; *&n; * Additionally, the %GFP_DMA flag may be set to indicate the memory&n; * must be suitable for DMA.  This can mean different things on different&n; * platforms.  For example, on i386, it means that the memory must come&n; * from the first 16MB.&n; */
DECL|function|kmalloc
r_void
op_star
id|kmalloc
(paren
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|cache_sizes
op_star
id|csizep
op_assign
id|malloc_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
macro_line|#if DEBUG
multiline_comment|/* This happens if someone tries to call&n;&t;&t; * kmem_cache_create(), or kmalloc(), before&n;&t;&t; * the generic caches are initialized.&n;&t;&t; */
id|BUG_ON
c_func
(paren
id|csizep-&gt;cs_cachep
op_eq
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
id|__cache_alloc
c_func
(paren
id|flags
op_amp
id|GFP_DMA
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_free - Deallocate an object&n; * @cachep: The cache the allocation was from.&n; * @objp: The previously allocated object.&n; *&n; * Free an object which was previously allocated from this&n; * cache.&n; */
DECL|function|kmem_cache_free
r_void
id|kmem_cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kfree - free previously allocated memory&n; * @objp: pointer returned by kmalloc.&n; *&n; * Don&squot;t free memory not originally allocated by kmalloc()&n; * or you will run into trouble.&n; */
DECL|function|kfree
r_void
id|kfree
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_cache_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_debugcheck
c_func
(paren
id|objp
)paren
suffix:semicolon
id|c
op_assign
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|__cache_free
c_func
(paren
id|c
comma
(paren
r_void
op_star
)paren
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|kmem_cache_size
r_int
r_int
id|kmem_cache_size
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
r_return
(paren
id|cachep-&gt;objsize
op_minus
l_int|2
op_star
id|BYTES_PER_WORD
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cachep-&gt;objsize
suffix:semicolon
)brace
DECL|function|kmem_find_general_cachep
id|kmem_cache_t
op_star
id|kmem_find_general_cachep
(paren
r_int
id|size
comma
r_int
id|gfpflags
)paren
(brace
r_struct
id|cache_sizes
op_star
id|csizep
op_assign
id|malloc_sizes
suffix:semicolon
multiline_comment|/* This function could be moved to the header file, and&n;&t; * made inline so consumers can quickly determine what&n;&t; * cache pointer they require.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|gfpflags
op_amp
id|GFP_DMA
)paren
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
suffix:semicolon
)brace
DECL|struct|ccupdate_struct
r_struct
id|ccupdate_struct
(brace
DECL|member|cachep
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
DECL|member|new
r_struct
id|array_cache
op_star
r_new
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|do_ccupdate_local
r_static
r_void
id|do_ccupdate_local
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|ccupdate_struct
op_star
r_new
op_assign
(paren
r_struct
id|ccupdate_struct
op_star
)paren
id|info
suffix:semicolon
r_struct
id|array_cache
op_star
id|old
suffix:semicolon
id|check_irq_off
c_func
(paren
)paren
suffix:semicolon
id|old
op_assign
id|ac_data
c_func
(paren
r_new
op_member_access_from_pointer
id|cachep
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cachep-&gt;array
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|old
suffix:semicolon
)brace
DECL|function|do_tune_cpucache
r_static
r_int
id|do_tune_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|limit
comma
r_int
id|batchcount
)paren
(brace
r_struct
id|ccupdate_struct
r_new
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
dot
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
dot
r_new
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|array_cache
op_star
id|ccnew
suffix:semicolon
id|ccnew
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|limit
op_plus
r_sizeof
(paren
r_struct
id|array_cache
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccnew
)paren
(brace
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|kfree
c_func
(paren
r_new
dot
r_new
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ccnew-&gt;avail
op_assign
l_int|0
suffix:semicolon
id|ccnew-&gt;limit
op_assign
id|limit
suffix:semicolon
id|ccnew-&gt;batchcount
op_assign
id|batchcount
suffix:semicolon
id|ccnew-&gt;touched
op_assign
l_int|0
suffix:semicolon
r_new
dot
r_new
(braket
id|i
)braket
op_assign
id|ccnew
suffix:semicolon
)brace
r_new
dot
id|cachep
op_assign
id|cachep
suffix:semicolon
id|smp_call_function_all_cpus
c_func
(paren
id|do_ccupdate_local
comma
(paren
r_void
op_star
)paren
op_amp
r_new
)paren
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;batchcount
op_assign
id|batchcount
suffix:semicolon
id|cachep-&gt;limit
op_assign
id|limit
suffix:semicolon
id|cachep-&gt;free_limit
op_assign
(paren
l_int|1
op_plus
id|num_online_cpus
c_func
(paren
)paren
)paren
op_star
id|cachep-&gt;batchcount
op_plus
id|cachep-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|array_cache
op_star
id|ccold
op_assign
r_new
dot
r_new
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccold
)paren
r_continue
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
id|ac_entry
c_func
(paren
id|ccold
)paren
comma
id|ccold-&gt;avail
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ccold
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|enable_cpucache
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
id|PAGE_SIZE
)paren
id|limit
op_assign
l_int|8
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|1024
)paren
id|limit
op_assign
l_int|54
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|256
)paren
id|limit
op_assign
l_int|120
suffix:semicolon
r_else
id|limit
op_assign
l_int|248
suffix:semicolon
id|err
op_assign
id|do_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
id|limit
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;enable_cpucache failed for %s, error %d.&bslash;n&quot;
comma
id|cachep-&gt;name
comma
op_minus
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * cache_reap - Reclaim memory from caches.&n; *&n; * Called from a timer, every few seconds&n; * Purpose:&n; * - clear the per-cpu caches for this CPU.&n; * - return freeable pages to the main free memory pool.&n; *&n; * If we cannot acquire the cache chain semaphore then just give up - we&squot;ll&n; * try again next timer interrupt.&n; */
DECL|function|cache_reap
r_static
r_inline
r_void
id|cache_reap
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|walk
suffix:semicolon
macro_line|#if DEBUG
id|BUG_ON
c_func
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_irq
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|cache_chain_sem
)paren
)paren
r_return
suffix:semicolon
id|list_for_each
c_func
(paren
id|walk
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|tofree
suffix:semicolon
r_struct
id|array_cache
op_star
id|ac
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
id|searchp
op_assign
id|list_entry
c_func
(paren
id|walk
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;flags
op_amp
id|SLAB_NO_REAP
)paren
r_goto
id|next
suffix:semicolon
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|ac
op_assign
id|ac_data
c_func
(paren
id|searchp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ac-&gt;touched
)paren
(brace
id|ac-&gt;touched
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ac-&gt;avail
)paren
(brace
id|tofree
op_assign
(paren
id|ac-&gt;limit
op_plus
l_int|4
)paren
op_div
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|tofree
OG
id|ac-&gt;avail
)paren
(brace
id|tofree
op_assign
(paren
id|ac-&gt;avail
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
)brace
id|free_block
c_func
(paren
id|searchp
comma
id|ac_entry
c_func
(paren
id|ac
)paren
comma
id|tofree
)paren
suffix:semicolon
id|ac-&gt;avail
op_sub_assign
id|tofree
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
l_int|0
)braket
comma
op_amp
id|ac_entry
c_func
(paren
id|ac
)paren
(braket
id|tofree
)braket
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|ac-&gt;avail
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|searchp-&gt;lists.next_reap
comma
id|jiffies
)paren
)paren
(brace
r_goto
id|next_irqon
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|searchp-&gt;lists.next_reap
comma
id|jiffies
)paren
)paren
(brace
r_goto
id|next_unlock
suffix:semicolon
)brace
id|searchp-&gt;lists.next_reap
op_assign
id|jiffies
op_plus
id|REAPTIMEOUT_LIST3
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;lists.free_touched
)paren
(brace
id|searchp-&gt;lists.free_touched
op_assign
l_int|0
suffix:semicolon
r_goto
id|next_unlock
suffix:semicolon
)brace
id|tofree
op_assign
(paren
id|searchp-&gt;free_limit
op_plus
l_int|5
op_star
id|searchp-&gt;num
op_minus
l_int|1
)paren
op_div
(paren
l_int|5
op_star
id|searchp-&gt;num
)paren
suffix:semicolon
r_do
(brace
id|p
op_assign
id|list3_data
c_func
(paren
id|searchp
)paren
op_member_access_from_pointer
id|slabs_free.next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
(paren
id|list3_data
c_func
(paren
id|searchp
)paren
op_member_access_from_pointer
id|slabs_free
)paren
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|slabp-&gt;inuse
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|STATS_INC_REAPED
c_func
(paren
id|searchp
)paren
suffix:semicolon
multiline_comment|/* Safe to drop the lock. The slab is no longer&n;&t;&t;&t; * linked to the cache.&n;&t;&t;&t; * searchp cannot disappear, we hold&n;&t;&t;&t; * cache_chain_lock&n;&t;&t;&t; */
id|searchp-&gt;lists.free_objects
op_sub_assign
id|searchp-&gt;num
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|slab_destroy
c_func
(paren
id|searchp
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|tofree
OG
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|next_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|next_irqon
suffix:colon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|next
suffix:colon
suffix:semicolon
)brace
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a timer handler.  There is on per CPU.  It is called periodially&n; * to shrink this CPU&squot;s caches.  Otherwise there could be memory tied up&n; * for long periods (or for ever) due to load changes.&n; */
DECL|function|reap_timer_fnc
r_static
r_void
id|reap_timer_fnc
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|timer_list
op_star
id|rt
op_assign
op_amp
id|reap_timers
(braket
id|cpu
)braket
suffix:semicolon
id|cache_reap
c_func
(paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
id|rt
comma
id|jiffies
op_plus
id|REAPTIMEOUT_CPUC
op_plus
id|cpu
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|s_start
r_static
r_void
op_star
id|s_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|loff_t
id|n
op_assign
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
id|p
op_assign
id|cache_chain.next
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|n
)paren
(brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cache_chain
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
)brace
DECL|function|s_next
r_static
r_void
op_star
id|s_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|p
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
(paren
r_void
op_star
)paren
l_int|1
)paren
r_return
id|list_entry
c_func
(paren
id|cache_chain.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_return
id|cachep-&gt;next.next
op_eq
op_amp
id|cache_chain
ques
c_cond
l_int|NULL
suffix:colon
id|list_entry
c_func
(paren
id|cachep-&gt;next.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
)brace
DECL|function|s_stop
r_static
r_void
id|s_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
DECL|function|s_show
r_static
r_int
id|s_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|q
suffix:semicolon
r_struct
id|slab
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|active_objs
suffix:semicolon
r_int
r_int
id|num_objs
suffix:semicolon
r_int
r_int
id|active_slabs
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|num_slabs
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
(paren
r_void
op_star
)paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Output format version, so at least we can change it&n;&t;&t; * without _too_ many complaints.&n;&t;&t; */
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;slabinfo - version: 1.2&quot;
macro_line|#if STATS
l_string|&quot; (statistics)&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|check_irq_on
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|active_objs
op_assign
l_int|0
suffix:semicolon
id|num_slabs
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_full
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_ne
id|cachep-&gt;num
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|active_objs
op_add_assign
id|cachep-&gt;num
suffix:semicolon
id|active_slabs
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_partial
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|slabp-&gt;inuse
op_eq
id|cachep-&gt;num
op_logical_or
op_logical_neg
id|slabp-&gt;inuse
)paren
suffix:semicolon
id|active_objs
op_add_assign
id|slabp-&gt;inuse
suffix:semicolon
id|active_slabs
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;lists.slabs_free
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
r_struct
id|slab
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|num_slabs
op_increment
suffix:semicolon
)brace
id|num_slabs
op_add_assign
id|active_slabs
suffix:semicolon
id|num_objs
op_assign
id|num_slabs
op_star
id|cachep-&gt;num
suffix:semicolon
id|BUG_ON
c_func
(paren
id|num_objs
op_minus
id|active_objs
op_ne
id|cachep-&gt;lists.free_objects
)paren
suffix:semicolon
id|name
op_assign
id|cachep-&gt;name
suffix:semicolon
(brace
r_char
id|tmp
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|tmp
comma
id|name
)paren
)paren
id|name
op_assign
l_string|&quot;broken&quot;
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%-17s %6lu %6lu %6u %4lu %4lu %4u&quot;
comma
id|name
comma
id|active_objs
comma
id|num_objs
comma
id|cachep-&gt;objsize
comma
id|active_slabs
comma
id|num_slabs
comma
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : %4u %4u&quot;
comma
id|cachep-&gt;limit
comma
id|cachep-&gt;batchcount
)paren
suffix:semicolon
macro_line|#if STATS
(brace
singleline_comment|// list3 stats
r_int
r_int
id|high
op_assign
id|cachep-&gt;high_mark
suffix:semicolon
r_int
r_int
id|allocs
op_assign
id|cachep-&gt;num_allocations
suffix:semicolon
r_int
r_int
id|grown
op_assign
id|cachep-&gt;grown
suffix:semicolon
r_int
r_int
id|reaped
op_assign
id|cachep-&gt;reaped
suffix:semicolon
r_int
r_int
id|errors
op_assign
id|cachep-&gt;errors
suffix:semicolon
r_int
r_int
id|max_freeable
op_assign
id|cachep-&gt;max_freeable
suffix:semicolon
r_int
r_int
id|free_limit
op_assign
id|cachep-&gt;free_limit
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : %6lu %7lu %5lu %4lu %4lu %4lu %4lu&quot;
comma
id|high
comma
id|allocs
comma
id|grown
comma
id|reaped
comma
id|errors
comma
id|max_freeable
comma
id|free_limit
)paren
suffix:semicolon
)brace
(brace
singleline_comment|// cpucache stats
r_int
r_int
id|allochit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allochit
)paren
suffix:semicolon
r_int
r_int
id|allocmiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allocmiss
)paren
suffix:semicolon
r_int
r_int
id|freehit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freehit
)paren
suffix:semicolon
r_int
r_int
id|freemiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freemiss
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; : %6lu %6lu %6lu %6lu&quot;
comma
id|allochit
comma
id|allocmiss
comma
id|freehit
comma
id|freemiss
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|m
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * slabinfo_op - iterator that generates /proc/slabinfo&n; *&n; * Output layout:&n; * cache-name&n; * num-active-objs&n; * total-objs&n; * object size&n; * num-active-slabs&n; * total-slabs&n; * num-pages-per-slab&n; * + further values on SMP and with statistics enabled&n; */
DECL|variable|slabinfo_op
r_struct
id|seq_operations
id|slabinfo_op
op_assign
(brace
dot
id|start
op_assign
id|s_start
comma
dot
id|next
op_assign
id|s_next
comma
dot
id|stop
op_assign
id|s_stop
comma
dot
id|show
op_assign
id|s_show
comma
)brace
suffix:semicolon
DECL|macro|MAX_SLABINFO_WRITE
mdefine_line|#define MAX_SLABINFO_WRITE 128
multiline_comment|/**&n; * slabinfo_write - SMP tuning for the slab allocator&n; * @file: unused&n; * @buffer: user buffer&n; * @count: data len&n; * @data: unused&n; */
DECL|function|slabinfo_write
id|ssize_t
id|slabinfo_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_char
id|kbuf
(braket
id|MAX_SLABINFO_WRITE
op_plus
l_int|1
)braket
comma
op_star
id|tmp
suffix:semicolon
r_int
id|limit
comma
id|batchcount
comma
id|res
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|MAX_SLABINFO_WRITE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kbuf
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|kbuf
(braket
id|MAX_SLABINFO_WRITE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_assign
id|strchr
c_func
(paren
id|kbuf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|tmp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_increment
suffix:semicolon
id|limit
op_assign
id|simple_strtol
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
op_eq
l_char|&squot; &squot;
)paren
id|tmp
op_increment
suffix:semicolon
id|batchcount
op_assign
id|simple_strtol
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cachep-&gt;name
comma
id|kbuf
)paren
)paren
(brace
r_if
c_cond
(paren
id|limit
OL
l_int|1
op_logical_or
id|batchcount
template_param
id|limit
)paren
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|do_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
id|batchcount
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ge
l_int|0
)paren
id|res
op_assign
id|count
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ksize
r_int
r_int
id|ksize
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_cache_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|objp
)paren
)paren
(brace
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|size
op_assign
id|kmem_cache_size
c_func
(paren
id|c
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
eof
