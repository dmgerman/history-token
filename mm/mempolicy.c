multiline_comment|/*&n; * Simple NUMA memory policy for the Linux kernel.&n; *&n; * Copyright 2003,2004 Andi Kleen, SuSE Labs.&n; * Subject to the GNU Public License, version 2.&n; *&n; * NUMA policy allows the user to give hints in which node(s) memory should&n; * be allocated.&n; *&n; * Support four policies per VMA and per process:&n; *&n; * The VMA policy has priority over the process policy for a page fault.&n; *&n; * interleave     Allocate memory interleaved over a set of nodes,&n; *                with normal fallback if it fails.&n; *                For VMA based allocations this interleaves based on the&n; *                offset into the backing object or offset into the mapping&n; *                for anonymous memory. For process policy an process counter&n; *                is used.&n; * bind           Only allocate memory on a specific set of nodes,&n; *                no fallback.&n; * preferred       Try a specific node first before normal fallback.&n; *                As a special case node -1 here means do the allocation&n; *                on the local CPU. This is normally identical to default,&n; *                but useful to set in a VMA when you have a non default&n; *                process policy.&n; * default        Allocate on the local node first, or when on a VMA&n; *                use the process policy. This is what Linux always did&n; *&t;&t;  in a NUMA aware kernel and still does by, ahem, default.&n; *&n; * The process policy is applied for most non interrupt memory allocations&n; * in that process&squot; context. Interrupts ignore the policies and always&n; * try to allocate on the local CPU. The VMA policy is only applied for memory&n; * allocations for a VMA in the VM.&n; *&n; * Currently there are a few corner cases in swapping where the policy&n; * is not applied, but the majority should be handled. When process policy&n; * is used it is not remembered over swap outs/swap ins.&n; *&n; * Only the highest zone in the zone hierarchy gets policied. Allocations&n; * requesting a lower zone just use default policy. This implies that&n; * on systems with highmem kernel lowmem allocation don&squot;t get policied.&n; * Same with GFP_DMA allocations.&n; *&n; * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between&n; * all users and remembered even when nobody has memory mapped.&n; */
multiline_comment|/* Notebook:&n;   fix mmap readahead to honour policy and enable policy for any page cache&n;   object&n;   statistics for bigpages&n;   global policy for page cache? currently it uses process policy. Requires&n;   first item above.&n;   handle mremap for shared memory (currently ignored for the policy)&n;   grows down?&n;   make bind policy root only? It can trigger oom much faster and the&n;   kernel is not always grateful with that.&n;   could replace all the switch()es with a mempolicy_ops structure.&n;*/
macro_line|#include &lt;linux/mempolicy.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/hugetlb.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/nodemask.h&gt;
macro_line|#include &lt;linux/gfp.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compat.h&gt;
macro_line|#include &lt;linux/mempolicy.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|policy_cache
r_static
id|kmem_cache_t
op_star
id|policy_cache
suffix:semicolon
DECL|variable|sn_cache
r_static
id|kmem_cache_t
op_star
id|sn_cache
suffix:semicolon
DECL|macro|PDprintk
mdefine_line|#define PDprintk(fmt...)
multiline_comment|/* Highest zone. An specific allocation for a zone below that is not&n;   policied. */
DECL|variable|policy_zone
r_static
r_int
id|policy_zone
suffix:semicolon
DECL|variable|default_policy
r_static
r_struct
id|mempolicy
id|default_policy
op_assign
(brace
dot
id|refcnt
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
comma
multiline_comment|/* never free it */
dot
id|policy
op_assign
id|MPOL_DEFAULT
comma
)brace
suffix:semicolon
multiline_comment|/* Check if all specified nodes are online */
DECL|function|nodes_online
r_static
r_int
id|nodes_online
c_func
(paren
r_int
r_int
op_star
id|nodes
)paren
(brace
id|DECLARE_BITMAP
c_func
(paren
id|online2
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|bitmap_copy
c_func
(paren
id|online2
comma
id|nodes_addr
c_func
(paren
id|node_online_map
)paren
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_empty
c_func
(paren
id|online2
comma
id|MAX_NUMNODES
)paren
)paren
id|set_bit
c_func
(paren
l_int|0
comma
id|online2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmap_subset
c_func
(paren
id|nodes
comma
id|online2
comma
id|MAX_NUMNODES
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Do sanity checking on a policy */
DECL|function|mpol_check_policy
r_static
r_int
id|mpol_check_policy
c_func
(paren
r_int
id|mode
comma
r_int
r_int
op_star
id|nodes
)paren
(brace
r_int
id|empty
op_assign
id|bitmap_empty
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|MPOL_DEFAULT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|empty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
r_case
id|MPOL_INTERLEAVE
suffix:colon
multiline_comment|/* Preferred will only use the first bit, but allow&n;&t;&t;   more for now. */
r_if
c_cond
(paren
id|empty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|nodes_online
c_func
(paren
id|nodes
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy a node mask from user space. */
DECL|function|get_nodes
r_static
r_int
id|get_nodes
c_func
(paren
r_int
r_int
op_star
id|nodes
comma
r_int
r_int
id|__user
op_star
id|nmask
comma
r_int
r_int
id|maxnode
comma
r_int
id|mode
)paren
(brace
r_int
r_int
id|k
suffix:semicolon
r_int
r_int
id|nlongs
suffix:semicolon
r_int
r_int
id|endmask
suffix:semicolon
op_decrement
id|maxnode
suffix:semicolon
id|bitmap_zero
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxnode
op_eq
l_int|0
op_logical_or
op_logical_neg
id|nmask
)paren
r_return
l_int|0
suffix:semicolon
id|nlongs
op_assign
id|BITS_TO_LONGS
c_func
(paren
id|maxnode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|maxnode
op_mod
id|BITS_PER_LONG
)paren
op_eq
l_int|0
)paren
id|endmask
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_else
id|endmask
op_assign
(paren
l_int|1UL
op_lshift
(paren
id|maxnode
op_mod
id|BITS_PER_LONG
)paren
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* When the user specified more nodes than supported just check&n;&t;   if the non supported part is all zero. */
r_if
c_cond
(paren
id|nlongs
OG
id|BITS_TO_LONGS
c_func
(paren
id|MAX_NUMNODES
)paren
)paren
(brace
r_if
c_cond
(paren
id|nlongs
OG
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|BITS_TO_LONGS
c_func
(paren
id|MAX_NUMNODES
)paren
suffix:semicolon
id|k
OL
id|nlongs
suffix:semicolon
id|k
op_increment
)paren
(brace
r_int
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|t
comma
id|nmask
op_plus
id|k
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|k
op_eq
id|nlongs
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|t
op_amp
id|endmask
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|nlongs
op_assign
id|BITS_TO_LONGS
c_func
(paren
id|MAX_NUMNODES
)paren
suffix:semicolon
id|endmask
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|nodes
comma
id|nmask
comma
id|nlongs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nodes
(braket
id|nlongs
op_minus
l_int|1
)braket
op_and_assign
id|endmask
suffix:semicolon
r_return
id|mpol_check_policy
c_func
(paren
id|mode
comma
id|nodes
)paren
suffix:semicolon
)brace
multiline_comment|/* Generate a custom zonelist for the BIND policy. */
DECL|function|bind_zonelist
r_static
r_struct
id|zonelist
op_star
id|bind_zonelist
c_func
(paren
r_int
r_int
op_star
id|nodes
)paren
(brace
r_struct
id|zonelist
op_star
id|zl
suffix:semicolon
r_int
id|num
comma
id|max
comma
id|nd
suffix:semicolon
id|max
op_assign
l_int|1
op_plus
id|MAX_NR_ZONES
op_star
id|bitmap_weight
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|zl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|max
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zl
)paren
r_return
l_int|NULL
suffix:semicolon
id|num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nd
op_assign
id|find_first_bit
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|nd
OL
id|MAX_NUMNODES
suffix:semicolon
id|nd
op_assign
id|find_next_bit
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
comma
l_int|1
op_plus
id|nd
)paren
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|MAX_NR_ZONES
op_minus
l_int|1
suffix:semicolon
id|k
op_ge
l_int|0
suffix:semicolon
id|k
op_decrement
)paren
(brace
r_struct
id|zone
op_star
id|z
op_assign
op_amp
id|NODE_DATA
c_func
(paren
id|nd
)paren
op_member_access_from_pointer
id|node_zones
(braket
id|k
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|z-&gt;present_pages
)paren
r_continue
suffix:semicolon
id|zl-&gt;zones
(braket
id|num
op_increment
)braket
op_assign
id|z
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|policy_zone
)paren
id|policy_zone
op_assign
id|k
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|num
op_ge
id|max
)paren
suffix:semicolon
id|zl-&gt;zones
(braket
id|num
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|zl
suffix:semicolon
)brace
multiline_comment|/* Create a new policy */
DECL|function|mpol_new
r_static
r_struct
id|mempolicy
op_star
id|mpol_new
c_func
(paren
r_int
id|mode
comma
r_int
r_int
op_star
id|nodes
)paren
(brace
r_struct
id|mempolicy
op_star
id|policy
suffix:semicolon
id|PDprintk
c_func
(paren
l_string|&quot;setting mode %d nodes[0] %lx&bslash;n&quot;
comma
id|mode
comma
id|nodes
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|MPOL_DEFAULT
)paren
r_return
l_int|NULL
suffix:semicolon
id|policy
op_assign
id|kmem_cache_alloc
c_func
(paren
id|policy_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|policy
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|policy-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|MPOL_INTERLEAVE
suffix:colon
id|bitmap_copy
c_func
(paren
id|policy-&gt;v.nodes
comma
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_PREFERRED
suffix:colon
id|policy-&gt;v.preferred_node
op_assign
id|find_first_bit
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy-&gt;v.preferred_node
op_ge
id|MAX_NUMNODES
)paren
id|policy-&gt;v.preferred_node
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
id|policy-&gt;v.zonelist
op_assign
id|bind_zonelist
c_func
(paren
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy-&gt;v.zonelist
op_eq
l_int|NULL
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|policy_cache
comma
id|policy
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|policy-&gt;policy
op_assign
id|mode
suffix:semicolon
r_return
id|policy
suffix:semicolon
)brace
multiline_comment|/* Ensure all existing pages follow the policy. */
r_static
r_int
DECL|function|verify_pages
id|verify_pages
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
op_star
id|nodes
)paren
(brace
r_while
c_loop
(paren
id|addr
OL
id|end
)paren
(brace
r_struct
id|page
op_star
id|p
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pgd_t
op_star
id|pgd
op_assign
id|pgd_offset_k
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|addr
op_assign
(paren
id|addr
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|addr
op_assign
(paren
id|addr
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|p
op_assign
l_int|NULL
suffix:semicolon
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
id|p
op_assign
id|pte_page
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_int
id|nid
op_assign
id|page_to_nid
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|nid
comma
id|nodes
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Step 1: check the range */
r_static
r_struct
id|vm_area_struct
op_star
DECL|function|check_range
id|check_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
op_star
id|nodes
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|first
comma
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
id|first
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|first
suffix:semicolon
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|end
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_next
op_logical_and
id|vma-&gt;vm_end
OL
id|end
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_logical_and
id|prev-&gt;vm_end
OL
id|vma-&gt;vm_start
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MPOL_MF_STRICT
)paren
op_logical_and
op_logical_neg
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
(brace
id|err
op_assign
id|verify_pages
c_func
(paren
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
comma
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|first
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|prev
op_assign
id|vma
suffix:semicolon
)brace
r_return
id|first
suffix:semicolon
)brace
multiline_comment|/* Apply policy to a single VMA */
DECL|function|policy_vma
r_static
r_int
id|policy_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|mempolicy
op_star
r_new
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|mempolicy
op_star
id|old
op_assign
id|vma-&gt;vm_policy
suffix:semicolon
id|PDprintk
c_func
(paren
l_string|&quot;vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p&bslash;n&quot;
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
comma
id|vma-&gt;vm_pgoff
comma
id|vma-&gt;vm_ops
comma
id|vma-&gt;vm_file
comma
id|vma-&gt;vm_ops
ques
c_cond
id|vma-&gt;vm_ops-&gt;set_policy
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;set_policy
)paren
id|err
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|set_policy
c_func
(paren
id|vma
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|mpol_get
c_func
(paren
r_new
)paren
suffix:semicolon
id|vma-&gt;vm_policy
op_assign
r_new
suffix:semicolon
id|mpol_free
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Step 2: apply policy to a range and do splits. */
DECL|function|mbind_range
r_static
r_int
id|mbind_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_struct
id|mempolicy
op_star
r_new
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|end
suffix:semicolon
id|vma
op_assign
id|next
)paren
(brace
id|next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
OL
id|start
)paren
id|err
op_assign
id|split_vma
c_func
(paren
id|vma-&gt;vm_mm
comma
id|vma
comma
id|start
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|vma-&gt;vm_end
OG
id|end
)paren
id|err
op_assign
id|split_vma
c_func
(paren
id|vma-&gt;vm_mm
comma
id|vma
comma
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|policy_vma
c_func
(paren
id|vma
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Change policy for a memory range */
DECL|function|sys_mbind
id|asmlinkage
r_int
id|sys_mbind
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|len
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|__user
op_star
id|nmask
comma
r_int
r_int
id|maxnode
comma
r_int
id|flags
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|mempolicy
op_star
r_new
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
op_complement
(paren
r_int
r_int
)paren
(paren
id|MPOL_MF_STRICT
)paren
)paren
op_logical_or
id|mode
OG
id|MPOL_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|MPOL_DEFAULT
)paren
id|flags
op_and_assign
op_complement
id|MPOL_MF_STRICT
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|start
)paren
r_return
l_int|0
suffix:semicolon
id|err
op_assign
id|get_nodes
c_func
(paren
id|nodes
comma
id|nmask
comma
id|maxnode
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_new
op_assign
id|mpol_new
c_func
(paren
id|mode
comma
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
r_new
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
r_new
)paren
suffix:semicolon
id|PDprintk
c_func
(paren
l_string|&quot;mbind %lx-%lx mode:%ld nodes:%lx&bslash;n&quot;
comma
id|start
comma
id|start
op_plus
id|len
comma
id|mode
comma
id|nodes
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|vma
op_assign
id|check_range
c_func
(paren
id|mm
comma
id|start
comma
id|end
comma
id|nodes
comma
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|vma
)paren
)paren
id|err
op_assign
id|mbind_range
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
r_new
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|mpol_free
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Set the process memory policy */
DECL|function|sys_set_mempolicy
id|asmlinkage
r_int
id|sys_set_mempolicy
c_func
(paren
r_int
id|mode
comma
r_int
r_int
id|__user
op_star
id|nmask
comma
r_int
r_int
id|maxnode
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|mempolicy
op_star
r_new
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
OG
id|MPOL_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|get_nodes
c_func
(paren
id|nodes
comma
id|nmask
comma
id|maxnode
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_new
op_assign
id|mpol_new
c_func
(paren
id|mode
comma
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
r_new
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
r_new
)paren
suffix:semicolon
id|mpol_free
c_func
(paren
id|current-&gt;mempolicy
)paren
suffix:semicolon
id|current-&gt;mempolicy
op_assign
r_new
suffix:semicolon
r_if
c_cond
(paren
r_new
op_logical_and
r_new
op_member_access_from_pointer
id|policy
op_eq
id|MPOL_INTERLEAVE
)paren
id|current-&gt;il_next
op_assign
id|find_first_bit
c_func
(paren
r_new
op_member_access_from_pointer
id|v.nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fill a zone bitmap for a policy */
DECL|function|get_zonemask
r_static
r_void
id|get_zonemask
c_func
(paren
r_struct
id|mempolicy
op_star
id|p
comma
r_int
r_int
op_star
id|nodes
)paren
(brace
r_int
id|i
suffix:semicolon
id|bitmap_zero
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;policy
)paren
(brace
r_case
id|MPOL_BIND
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|p-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|__set_bit
c_func
(paren
id|p-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
op_member_access_from_pointer
id|zone_pgdat-&gt;node_id
comma
id|nodes
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_DEFAULT
suffix:colon
r_break
suffix:semicolon
r_case
id|MPOL_INTERLEAVE
suffix:colon
id|bitmap_copy
c_func
(paren
id|nodes
comma
id|p-&gt;v.nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_PREFERRED
suffix:colon
multiline_comment|/* or use current node instead of online map? */
r_if
c_cond
(paren
id|p-&gt;v.preferred_node
OL
l_int|0
)paren
id|bitmap_copy
c_func
(paren
id|nodes
comma
id|nodes_addr
c_func
(paren
id|node_online_map
)paren
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_else
id|__set_bit
c_func
(paren
id|p-&gt;v.preferred_node
comma
id|nodes
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|lookup_node
r_static
r_int
id|lookup_node
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|page
op_star
id|p
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
id|mm
comma
id|addr
op_amp
id|PAGE_MASK
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
op_amp
id|p
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|page_to_nid
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_page
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Copy a kernel node mask to user space */
DECL|function|copy_nodes_to_user
r_static
r_int
id|copy_nodes_to_user
c_func
(paren
r_int
r_int
id|__user
op_star
id|mask
comma
r_int
r_int
id|maxnode
comma
r_void
op_star
id|nodes
comma
r_int
id|nbytes
)paren
(brace
r_int
r_int
id|copy
op_assign
id|ALIGN
c_func
(paren
id|maxnode
op_minus
l_int|1
comma
l_int|64
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|nbytes
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|PAGE_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|clear_user
c_func
(paren
(paren
r_char
id|__user
op_star
)paren
id|mask
op_plus
id|nbytes
comma
id|copy
op_minus
id|nbytes
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy
op_assign
id|nbytes
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
id|mask
comma
id|nodes
comma
id|copy
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Retrieve NUMA policy */
DECL|function|sys_get_mempolicy
id|asmlinkage
r_int
id|sys_get_mempolicy
c_func
(paren
r_int
id|__user
op_star
id|policy
comma
r_int
r_int
id|__user
op_star
id|nmask
comma
r_int
r_int
id|maxnode
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|err
comma
id|pval
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|current-&gt;mempolicy
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
r_int
r_int
)paren
(paren
id|MPOL_F_NODE
op_or
id|MPOL_F_ADDR
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nmask
op_ne
l_int|NULL
op_logical_and
id|maxnode
OL
id|numnodes
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MPOL_F_ADDR
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma_intersection
c_func
(paren
id|mm
comma
id|addr
comma
id|addr
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;get_policy
)paren
id|pol
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|get_policy
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_else
id|pol
op_assign
id|vma-&gt;vm_policy
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pol
)paren
id|pol
op_assign
op_amp
id|default_policy
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MPOL_F_NODE
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|MPOL_F_ADDR
)paren
(brace
id|err
op_assign
id|lookup_node
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|pval
op_assign
id|err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pol
op_eq
id|current-&gt;mempolicy
op_logical_and
id|pol-&gt;policy
op_eq
id|MPOL_INTERLEAVE
)paren
(brace
id|pval
op_assign
id|current-&gt;il_next
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
id|pval
op_assign
id|pol-&gt;policy
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|policy
op_logical_and
id|put_user
c_func
(paren
id|pval
comma
id|policy
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nmask
)paren
(brace
id|DECLARE_BITMAP
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|get_zonemask
c_func
(paren
id|pol
comma
id|nodes
)paren
suffix:semicolon
id|err
op_assign
id|copy_nodes_to_user
c_func
(paren
id|nmask
comma
id|maxnode
comma
id|nodes
comma
r_sizeof
(paren
id|nodes
)paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|vma
)paren
id|up_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_COMPAT
DECL|function|compat_sys_get_mempolicy
id|asmlinkage
r_int
id|compat_sys_get_mempolicy
c_func
(paren
r_int
id|__user
op_star
id|policy
comma
id|compat_ulong_t
id|__user
op_star
id|nmask
comma
id|compat_ulong_t
id|maxnode
comma
id|compat_ulong_t
id|addr
comma
id|compat_ulong_t
id|flags
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
r_int
id|__user
op_star
id|nm
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|nr_bits
comma
id|alloc_size
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|bm
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|nr_bits
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|maxnode
op_minus
l_int|1
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|alloc_size
op_assign
id|ALIGN
c_func
(paren
id|nr_bits
comma
id|BITS_PER_LONG
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|nmask
)paren
id|nm
op_assign
id|compat_alloc_user_space
c_func
(paren
id|alloc_size
)paren
suffix:semicolon
id|err
op_assign
id|sys_get_mempolicy
c_func
(paren
id|policy
comma
id|nm
comma
id|nr_bits
op_plus
l_int|1
comma
id|addr
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|nmask
)paren
(brace
id|err
op_assign
id|copy_from_user
c_func
(paren
id|bm
comma
id|nm
comma
id|alloc_size
)paren
suffix:semicolon
multiline_comment|/* ensure entire bitmap is zeroed */
id|err
op_or_assign
id|clear_user
c_func
(paren
id|nmask
comma
id|ALIGN
c_func
(paren
id|maxnode
op_minus
l_int|1
comma
l_int|8
)paren
op_div
l_int|8
)paren
suffix:semicolon
id|err
op_or_assign
id|compat_put_bitmap
c_func
(paren
id|nmask
comma
id|bm
comma
id|nr_bits
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|compat_sys_set_mempolicy
id|asmlinkage
r_int
id|compat_sys_set_mempolicy
c_func
(paren
r_int
id|mode
comma
id|compat_ulong_t
id|__user
op_star
id|nmask
comma
id|compat_ulong_t
id|maxnode
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|__user
op_star
id|nm
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|nr_bits
comma
id|alloc_size
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|bm
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|nr_bits
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|maxnode
op_minus
l_int|1
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|alloc_size
op_assign
id|ALIGN
c_func
(paren
id|nr_bits
comma
id|BITS_PER_LONG
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|nmask
)paren
(brace
id|err
op_assign
id|compat_get_bitmap
c_func
(paren
id|bm
comma
id|nmask
comma
id|nr_bits
)paren
suffix:semicolon
id|nm
op_assign
id|compat_alloc_user_space
c_func
(paren
id|alloc_size
)paren
suffix:semicolon
id|err
op_or_assign
id|copy_to_user
c_func
(paren
id|nm
comma
id|bm
comma
id|alloc_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|sys_set_mempolicy
c_func
(paren
id|mode
comma
id|nm
comma
id|nr_bits
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|compat_sys_mbind
id|asmlinkage
r_int
id|compat_sys_mbind
c_func
(paren
id|compat_ulong_t
id|start
comma
id|compat_ulong_t
id|len
comma
id|compat_ulong_t
id|mode
comma
id|compat_ulong_t
id|__user
op_star
id|nmask
comma
id|compat_ulong_t
id|maxnode
comma
id|compat_ulong_t
id|flags
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|__user
op_star
id|nm
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|nr_bits
comma
id|alloc_size
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|bm
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|nr_bits
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|maxnode
op_minus
l_int|1
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|alloc_size
op_assign
id|ALIGN
c_func
(paren
id|nr_bits
comma
id|BITS_PER_LONG
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|nmask
)paren
(brace
id|err
op_assign
id|compat_get_bitmap
c_func
(paren
id|bm
comma
id|nmask
comma
id|nr_bits
)paren
suffix:semicolon
id|nm
op_assign
id|compat_alloc_user_space
c_func
(paren
id|alloc_size
)paren
suffix:semicolon
id|err
op_or_assign
id|copy_to_user
c_func
(paren
id|nm
comma
id|bm
comma
id|alloc_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|sys_mbind
c_func
(paren
id|start
comma
id|len
comma
id|mode
comma
id|nm
comma
id|nr_bits
op_plus
l_int|1
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Return effective policy for a VMA */
r_static
r_struct
id|mempolicy
op_star
DECL|function|get_vma_policy
id|get_vma_policy
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|current-&gt;mempolicy
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;get_policy
)paren
id|pol
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|get_policy
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_policy
op_logical_and
id|vma-&gt;vm_policy-&gt;policy
op_ne
id|MPOL_DEFAULT
)paren
id|pol
op_assign
id|vma-&gt;vm_policy
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pol
)paren
id|pol
op_assign
op_amp
id|default_policy
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
multiline_comment|/* Return a zonelist representing a mempolicy */
DECL|function|zonelist_policy
r_static
r_struct
id|zonelist
op_star
id|zonelist_policy
c_func
(paren
r_int
id|gfp
comma
r_struct
id|mempolicy
op_star
id|policy
)paren
(brace
r_int
id|nd
suffix:semicolon
r_switch
c_cond
(paren
id|policy-&gt;policy
)paren
(brace
r_case
id|MPOL_PREFERRED
suffix:colon
id|nd
op_assign
id|policy-&gt;v.preferred_node
suffix:semicolon
r_if
c_cond
(paren
id|nd
OL
l_int|0
)paren
id|nd
op_assign
id|numa_node_id
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
multiline_comment|/* Lower zones don&squot;t get a policy applied */
r_if
c_cond
(paren
id|gfp
op_ge
id|policy_zone
)paren
r_return
id|policy-&gt;v.zonelist
suffix:semicolon
multiline_comment|/*FALL THROUGH*/
r_case
id|MPOL_INTERLEAVE
suffix:colon
multiline_comment|/* should not happen */
r_case
id|MPOL_DEFAULT
suffix:colon
id|nd
op_assign
id|numa_node_id
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nd
op_assign
l_int|0
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|NODE_DATA
c_func
(paren
id|nd
)paren
op_member_access_from_pointer
id|node_zonelists
op_plus
(paren
id|gfp
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
)brace
multiline_comment|/* Do dynamic interleaving for a process */
DECL|function|interleave_nodes
r_static
r_int
id|interleave_nodes
c_func
(paren
r_struct
id|mempolicy
op_star
id|policy
)paren
(brace
r_int
id|nid
comma
id|next
suffix:semicolon
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
id|nid
op_assign
id|me-&gt;il_next
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nid
op_ge
id|MAX_NUMNODES
)paren
suffix:semicolon
id|next
op_assign
id|find_next_bit
c_func
(paren
id|policy-&gt;v.nodes
comma
id|MAX_NUMNODES
comma
l_int|1
op_plus
id|nid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ge
id|MAX_NUMNODES
)paren
id|next
op_assign
id|find_first_bit
c_func
(paren
id|policy-&gt;v.nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|me-&gt;il_next
op_assign
id|next
suffix:semicolon
r_return
id|nid
suffix:semicolon
)brace
multiline_comment|/* Do static interleaving for a VMA with known offset. */
DECL|function|offset_il_node
r_static
r_int
id|offset_il_node
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|off
)paren
(brace
r_int
id|nnodes
op_assign
id|bitmap_weight
c_func
(paren
id|pol-&gt;v.nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_int
id|target
op_assign
(paren
r_int
)paren
id|off
op_mod
id|nnodes
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|nid
op_assign
op_minus
l_int|1
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|nid
op_assign
id|find_next_bit
c_func
(paren
id|pol-&gt;v.nodes
comma
id|MAX_NUMNODES
comma
id|nid
op_plus
l_int|1
)paren
suffix:semicolon
id|c
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_le
id|target
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nid
op_ge
id|MAX_NUMNODES
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|nid
comma
id|pol-&gt;v.nodes
)paren
)paren
suffix:semicolon
r_return
id|nid
suffix:semicolon
)brace
multiline_comment|/* Allocate a page in interleaved policy.&n;   Own path because it needs to do special accounting. */
DECL|function|alloc_page_interleave
r_static
r_struct
id|page
op_star
id|alloc_page_interleave
c_func
(paren
r_int
id|gfp
comma
r_int
id|order
comma
r_int
id|nid
)paren
(brace
r_struct
id|zonelist
op_star
id|zl
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|node_online
c_func
(paren
id|nid
)paren
)paren
suffix:semicolon
id|zl
op_assign
id|NODE_DATA
c_func
(paren
id|nid
)paren
op_member_access_from_pointer
id|node_zonelists
op_plus
(paren
id|gfp
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
id|page
op_assign
id|__alloc_pages
c_func
(paren
id|gfp
comma
id|order
comma
id|zl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|page_zone
c_func
(paren
id|page
)paren
op_eq
id|zl-&gt;zones
(braket
l_int|0
)braket
)paren
(brace
id|zl-&gt;zones
(braket
l_int|0
)braket
op_member_access_from_pointer
id|pageset
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|interleave_hit
op_increment
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;alloc_page_vma&t;- Allocate a page for a VMA.&n; *&n; * &t;@gfp:&n; *      %GFP_USER    user allocation.&n; *      %GFP_KERNEL  kernel allocations,&n; *      %GFP_HIGHMEM highmem/user allocations,&n; *      %GFP_FS      allocation should not call back into a file system.&n; *      %GFP_ATOMIC  don&squot;t sleep.&n; *&n; * &t;@vma:  Pointer to VMA or NULL if not available.&n; *&t;@addr: Virtual Address of the allocation. Must be inside the VMA.&n; *&n; * &t;This function allocates a page from the kernel page pool and applies&n; *&t;a NUMA policy associated with the VMA or the current process.&n; *&t;When VMA is not NULL caller must hold down_read on the mmap_sem of the&n; *&t;mm_struct of the VMA to prevent it from going away. Should be used for&n; *&t;all allocations for pages that will be mapped into&n; * &t;user space. Returns NULL when no page can be allocated.&n; *&n; *&t;Should be called with the mm_sem of the vma hold.&n; */
r_struct
id|page
op_star
DECL|function|alloc_page_vma
id|alloc_page_vma
c_func
(paren
r_int
id|gfp
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|get_vma_policy
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pol-&gt;policy
op_eq
id|MPOL_INTERLEAVE
)paren
)paren
(brace
r_int
id|nid
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
id|BUG_ON
c_func
(paren
id|addr
op_ge
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|addr
OL
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|off
op_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|off
op_add_assign
(paren
id|addr
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|nid
op_assign
id|offset_il_node
c_func
(paren
id|pol
comma
id|vma
comma
id|off
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* fall back to process interleaving */
id|nid
op_assign
id|interleave_nodes
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
r_return
id|alloc_page_interleave
c_func
(paren
id|gfp
comma
l_int|0
comma
id|nid
)paren
suffix:semicolon
)brace
r_return
id|__alloc_pages
c_func
(paren
id|gfp
comma
l_int|0
comma
id|zonelist_policy
c_func
(paren
id|gfp
comma
id|pol
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;alloc_pages_current - Allocate pages.&n; *&n; *&t;@gfp:&n; *&t;&t;%GFP_USER   user allocation,&n; *      &t;%GFP_KERNEL kernel allocation,&n; *      &t;%GFP_HIGHMEM highmem allocation,&n; *      &t;%GFP_FS     don&squot;t call back into a file system.&n; *      &t;%GFP_ATOMIC don&squot;t sleep.&n; *&t;@order: Power of two of allocation size in pages. 0 is a single page.&n; *&n; *&t;Allocate a page from the kernel page pool.  When not in&n; *&t;interrupt context and apply the current process NUMA policy.&n; *&t;Returns NULL when no page can be allocated.&n; */
DECL|function|alloc_pages_current
r_struct
id|page
op_star
id|alloc_pages_current
c_func
(paren
r_int
id|gfp
comma
r_int
id|order
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|current-&gt;mempolicy
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pol
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|pol
op_assign
op_amp
id|default_policy
suffix:semicolon
r_if
c_cond
(paren
id|pol-&gt;policy
op_eq
id|MPOL_INTERLEAVE
)paren
r_return
id|alloc_page_interleave
c_func
(paren
id|gfp
comma
id|order
comma
id|interleave_nodes
c_func
(paren
id|pol
)paren
)paren
suffix:semicolon
r_return
id|__alloc_pages
c_func
(paren
id|gfp
comma
id|order
comma
id|zonelist_policy
c_func
(paren
id|gfp
comma
id|pol
)paren
)paren
suffix:semicolon
)brace
DECL|variable|alloc_pages_current
id|EXPORT_SYMBOL
c_func
(paren
id|alloc_pages_current
)paren
suffix:semicolon
multiline_comment|/* Slow path of a mempolicy copy */
DECL|function|__mpol_copy
r_struct
id|mempolicy
op_star
id|__mpol_copy
c_func
(paren
r_struct
id|mempolicy
op_star
id|old
)paren
(brace
r_struct
id|mempolicy
op_star
r_new
op_assign
id|kmem_cache_alloc
c_func
(paren
id|policy_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
op_star
r_new
op_assign
op_star
id|old
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|refcnt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|policy
op_eq
id|MPOL_BIND
)paren
(brace
r_int
id|sz
op_assign
id|ksize
c_func
(paren
id|old-&gt;v.zonelist
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|v.zonelist
op_assign
id|kmalloc
c_func
(paren
id|sz
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|v.zonelist
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|policy_cache
comma
r_new
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|v.zonelist
comma
id|old-&gt;v.zonelist
comma
id|sz
)paren
suffix:semicolon
)brace
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/* Slow path of a mempolicy comparison */
DECL|function|__mpol_equal
r_int
id|__mpol_equal
c_func
(paren
r_struct
id|mempolicy
op_star
id|a
comma
r_struct
id|mempolicy
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a
op_logical_or
op_logical_neg
id|b
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;policy
op_ne
id|b-&gt;policy
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|a-&gt;policy
)paren
(brace
r_case
id|MPOL_DEFAULT
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
id|MPOL_INTERLEAVE
suffix:colon
r_return
id|bitmap_equal
c_func
(paren
id|a-&gt;v.nodes
comma
id|b-&gt;v.nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
r_case
id|MPOL_PREFERRED
suffix:colon
r_return
id|a-&gt;v.preferred_node
op_eq
id|b-&gt;v.preferred_node
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|a-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|a-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
op_ne
id|b-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|b-&gt;v.zonelist-&gt;zones
(braket
id|i
)braket
op_eq
l_int|NULL
suffix:semicolon
)brace
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Slow path of a mpol destructor. */
DECL|function|__mpol_free
r_void
id|__mpol_free
c_func
(paren
r_struct
id|mempolicy
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|p-&gt;refcnt
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;policy
op_eq
id|MPOL_BIND
)paren
id|kfree
c_func
(paren
id|p-&gt;v.zonelist
)paren
suffix:semicolon
id|p-&gt;policy
op_assign
id|MPOL_DEFAULT
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|policy_cache
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Hugetlb policy. Same as above, just works with node numbers instead of&n; * zonelists.&n; */
multiline_comment|/* Find first node suitable for an allocation */
DECL|function|mpol_first_node
r_int
id|mpol_first_node
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|get_vma_policy
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pol-&gt;policy
)paren
(brace
r_case
id|MPOL_DEFAULT
suffix:colon
r_return
id|numa_node_id
c_func
(paren
)paren
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
r_return
id|pol-&gt;v.zonelist-&gt;zones
(braket
l_int|0
)braket
op_member_access_from_pointer
id|zone_pgdat-&gt;node_id
suffix:semicolon
r_case
id|MPOL_INTERLEAVE
suffix:colon
r_return
id|interleave_nodes
c_func
(paren
id|pol
)paren
suffix:semicolon
r_case
id|MPOL_PREFERRED
suffix:colon
r_return
id|pol-&gt;v.preferred_node
op_ge
l_int|0
ques
c_cond
id|pol-&gt;v.preferred_node
suffix:colon
id|numa_node_id
c_func
(paren
)paren
suffix:semicolon
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find secondary valid nodes for an allocation */
DECL|function|mpol_node_valid
r_int
id|mpol_node_valid
c_func
(paren
r_int
id|nid
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
id|get_vma_policy
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pol-&gt;policy
)paren
(brace
r_case
id|MPOL_PREFERRED
suffix:colon
r_case
id|MPOL_DEFAULT
suffix:colon
r_case
id|MPOL_INTERLEAVE
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
id|MPOL_BIND
suffix:colon
(brace
r_struct
id|zone
op_star
op_star
id|z
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
id|pol-&gt;v.zonelist-&gt;zones
suffix:semicolon
op_star
id|z
suffix:semicolon
id|z
op_increment
)paren
r_if
c_cond
(paren
(paren
op_star
id|z
)paren
op_member_access_from_pointer
id|zone_pgdat-&gt;node_id
op_eq
id|nid
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Shared memory backing store policy support.&n; *&n; * Remember policies even when nobody has shared memory mapped.&n; * The policies are kept in Red-Black tree linked from the inode.&n; * They are protected by the sp-&gt;lock spinlock, which should be held&n; * for any accesses to the tree.&n; */
multiline_comment|/* lookup first element intersecting start-end */
multiline_comment|/* Caller holds sp-&gt;lock */
r_static
r_struct
id|sp_node
op_star
DECL|function|sp_lookup
id|sp_lookup
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|sp-&gt;root.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|sp_node
op_star
id|p
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|p-&gt;end
)paren
(brace
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
OL
id|p-&gt;start
)paren
(brace
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sp_node
op_star
id|w
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
id|prev
op_assign
id|rb_prev
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
r_break
suffix:semicolon
id|w
op_assign
id|rb_entry
c_func
(paren
id|prev
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;end
op_le
id|start
)paren
r_break
suffix:semicolon
id|n
op_assign
id|prev
suffix:semicolon
)brace
r_return
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert a new shared policy into the list. */
multiline_comment|/* Caller holds sp-&gt;lock */
DECL|function|sp_insert
r_static
r_void
id|sp_insert
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_struct
id|sp_node
op_star
r_new
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|sp-&gt;root.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sp_node
op_star
id|nd
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|nd
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|start
OL
id|nd-&gt;start
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|end
OG
id|nd-&gt;end
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|nd
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|nd
comma
op_amp
id|sp-&gt;root
)paren
suffix:semicolon
id|PDprintk
c_func
(paren
l_string|&quot;inserting %lx-%lx: %d&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|start
comma
r_new
op_member_access_from_pointer
id|end
comma
r_new
op_member_access_from_pointer
id|policy
ques
c_cond
r_new
op_member_access_from_pointer
id|policy-&gt;policy
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Find shared policy intersecting idx */
r_struct
id|mempolicy
op_star
DECL|function|mpol_shared_policy_lookup
id|mpol_shared_policy_lookup
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_int
r_int
id|idx
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sp_node
op_star
id|sn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp-&gt;root.rb_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
id|sn
op_assign
id|sp_lookup
c_func
(paren
id|sp
comma
id|idx
comma
id|idx
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn
)paren
(brace
id|mpol_get
c_func
(paren
id|sn-&gt;policy
)paren
suffix:semicolon
id|pol
op_assign
id|sn-&gt;policy
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
DECL|function|sp_delete
r_static
r_void
id|sp_delete
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_struct
id|sp_node
op_star
id|n
)paren
(brace
id|PDprintk
c_func
(paren
l_string|&quot;deleting %lx-l%x&bslash;n&quot;
comma
id|n-&gt;start
comma
id|n-&gt;end
)paren
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|n-&gt;nd
comma
op_amp
id|sp-&gt;root
)paren
suffix:semicolon
id|mpol_free
c_func
(paren
id|n-&gt;policy
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|sn_cache
comma
id|n
)paren
suffix:semicolon
)brace
r_struct
id|sp_node
op_star
DECL|function|sp_alloc
id|sp_alloc
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_struct
id|mempolicy
op_star
id|pol
)paren
(brace
r_struct
id|sp_node
op_star
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|sn_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
id|n-&gt;start
op_assign
id|start
suffix:semicolon
id|n-&gt;end
op_assign
id|end
suffix:semicolon
id|mpol_get
c_func
(paren
id|pol
)paren
suffix:semicolon
id|n-&gt;policy
op_assign
id|pol
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* Replace a policy range. */
DECL|function|shared_policy_replace
r_static
r_int
id|shared_policy_replace
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_struct
id|sp_node
op_star
r_new
)paren
(brace
r_struct
id|sp_node
op_star
id|n
comma
op_star
id|new2
op_assign
l_int|NULL
suffix:semicolon
id|restart
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
id|n
op_assign
id|sp_lookup
c_func
(paren
id|sp
comma
id|start
comma
id|end
)paren
suffix:semicolon
multiline_comment|/* Take care of old policies in the same range. */
r_while
c_loop
(paren
id|n
op_logical_and
id|n-&gt;start
OL
id|end
)paren
(brace
r_struct
id|rb_node
op_star
id|next
op_assign
id|rb_next
c_func
(paren
op_amp
id|n-&gt;nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;start
op_ge
id|start
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;end
op_le
id|end
)paren
id|sp_delete
c_func
(paren
id|sp
comma
id|n
)paren
suffix:semicolon
r_else
id|n-&gt;start
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Old policy spanning whole new range. */
r_if
c_cond
(paren
id|n-&gt;end
OG
id|end
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|new2
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
id|new2
op_assign
id|sp_alloc
c_func
(paren
id|end
comma
id|n-&gt;end
comma
id|n-&gt;policy
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new2
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|n-&gt;end
op_assign
id|end
suffix:semicolon
id|sp_insert
c_func
(paren
id|sp
comma
id|new2
)paren
suffix:semicolon
id|new2
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Old crossing beginning, but not end (easy) */
r_if
c_cond
(paren
id|n-&gt;start
template_param
id|start
)paren
id|n-&gt;end
op_assign
id|start
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
r_break
suffix:semicolon
id|n
op_assign
id|rb_entry
c_func
(paren
id|next
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
id|sp_insert
c_func
(paren
id|sp
comma
r_new
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new2
)paren
(brace
id|mpol_free
c_func
(paren
id|new2-&gt;policy
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|sn_cache
comma
id|new2
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mpol_set_shared_policy
r_int
id|mpol_set_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|info
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|mempolicy
op_star
id|npol
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|sp_node
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|sz
op_assign
id|vma_pages
c_func
(paren
id|vma
)paren
suffix:semicolon
id|PDprintk
c_func
(paren
l_string|&quot;set_shared_policy %lx sz %lu %d %lx&bslash;n&quot;
comma
id|vma-&gt;vm_pgoff
comma
id|sz
comma
id|npol
ques
c_cond
id|npol-&gt;policy
suffix:colon
op_minus
l_int|1
comma
id|npol
ques
c_cond
id|npol-&gt;v.nodes
(braket
l_int|0
)braket
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npol
)paren
(brace
r_new
op_assign
id|sp_alloc
c_func
(paren
id|vma-&gt;vm_pgoff
comma
id|vma-&gt;vm_pgoff
op_plus
id|sz
comma
id|npol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|err
op_assign
id|shared_policy_replace
c_func
(paren
id|info
comma
id|vma-&gt;vm_pgoff
comma
id|vma-&gt;vm_pgoff
op_plus
id|sz
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
r_new
)paren
id|kmem_cache_free
c_func
(paren
id|sn_cache
comma
r_new
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Free a backing policy store on inode delete. */
DECL|function|mpol_free_shared_policy
r_void
id|mpol_free_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|p
)paren
(brace
r_struct
id|sp_node
op_star
id|n
suffix:semicolon
r_struct
id|rb_node
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;root.rb_node
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;lock
)paren
suffix:semicolon
id|next
op_assign
id|rb_first
c_func
(paren
op_amp
id|p-&gt;root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next
)paren
(brace
id|n
op_assign
id|rb_entry
c_func
(paren
id|next
comma
r_struct
id|sp_node
comma
id|nd
)paren
suffix:semicolon
id|next
op_assign
id|rb_next
c_func
(paren
op_amp
id|n-&gt;nd
)paren
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|n-&gt;nd
comma
op_amp
id|p-&gt;root
)paren
suffix:semicolon
id|mpol_free
c_func
(paren
id|n-&gt;policy
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|sn_cache
comma
id|n
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* assumes fs == KERNEL_DS */
DECL|function|numa_policy_init
r_void
id|__init
id|numa_policy_init
c_func
(paren
r_void
)paren
(brace
id|policy_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;numa_policy&quot;
comma
r_sizeof
(paren
r_struct
id|mempolicy
)paren
comma
l_int|0
comma
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|sn_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;shared_policy_node&quot;
comma
r_sizeof
(paren
r_struct
id|sp_node
)paren
comma
l_int|0
comma
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Set interleaving policy for system init. This way not all&n;&t;   the data structures allocated at system boot end up in node zero. */
r_if
c_cond
(paren
id|sys_set_mempolicy
c_func
(paren
id|MPOL_INTERLEAVE
comma
id|nodes_addr
c_func
(paren
id|node_online_map
)paren
comma
id|MAX_NUMNODES
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;numa_policy_init: interleaving failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset policy of current process to default.&n; * Assumes fs == KERNEL_DS */
DECL|function|numa_default_policy
r_void
id|numa_default_policy
c_func
(paren
r_void
)paren
(brace
id|sys_set_mempolicy
c_func
(paren
id|MPOL_DEFAULT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
