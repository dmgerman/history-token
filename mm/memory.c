multiline_comment|/*&n; *  linux/mm/memory.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; */
multiline_comment|/*&n; * demand-loading started 01.12.91 - seems it is high on the list of&n; * things wanted, and it should be easy to implement. - Linus&n; */
multiline_comment|/*&n; * Ok, demand-loading was easy, shared pages a little bit tricker. Shared&n; * pages started 02.12.91, seems to work. - Linus.&n; *&n; * Tested sharing by executing about 30 /bin/sh: under the old kernel it&n; * would have taken more than the 6M I have free, but it worked well as&n; * far as I could see.&n; *&n; * Also corrected some &quot;invalidate()&quot;s - I wasn&squot;t doing enough of them.&n; */
multiline_comment|/*&n; * Real VM (paging to/from disk) started 18.12.91. Much more work and&n; * thought has to go into this. Oh, well..&n; * 19.12.91  -  works, somewhat. Sometimes I get faults, don&squot;t know why.&n; *&t;&t;Found it. Everything seems to work now.&n; * 20.12.91  -  Ok, making the swap-device changeable like the root.&n; */
multiline_comment|/*&n; * 05.04.94  -  Multi-page memory management added for v1.1.&n; * &t;&t;Idea by Alex Bligh (alex@cconcepts.co.uk)&n; *&n; * 16.07.99  -  Support of BIGMEM added by Gerhard Wichert, Siemens AG&n; *&t;&t;(Gerhard.Wichert@pdb.siemens.de)&n; *&n; * Aug/Sep 2004 Changed to four level page tables (Andi Kleen)&n; */
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/hugetlb.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#ifndef CONFIG_DISCONTIGMEM
multiline_comment|/* use the per-pgdat data instead for discontigmem - mbligh */
DECL|variable|max_mapnr
r_int
r_int
id|max_mapnr
suffix:semicolon
DECL|variable|mem_map
r_struct
id|page
op_star
id|mem_map
suffix:semicolon
DECL|variable|max_mapnr
id|EXPORT_SYMBOL
c_func
(paren
id|max_mapnr
)paren
suffix:semicolon
DECL|variable|mem_map
id|EXPORT_SYMBOL
c_func
(paren
id|mem_map
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|num_physpages
r_int
r_int
id|num_physpages
suffix:semicolon
multiline_comment|/*&n; * A number of key systems in x86 including ioremap() rely on the assumption&n; * that high_memory defines the upper bound on direct map memory, then end&n; * of ZONE_NORMAL.  Under CONFIG_DISCONTIG this means that max_low_pfn and&n; * highstart_pfn must be the same; there must be no gap between ZONE_NORMAL&n; * and ZONE_HIGHMEM.&n; */
DECL|variable|high_memory
r_void
op_star
id|high_memory
suffix:semicolon
DECL|variable|vmalloc_earlyreserve
r_int
r_int
id|vmalloc_earlyreserve
suffix:semicolon
DECL|variable|num_physpages
id|EXPORT_SYMBOL
c_func
(paren
id|num_physpages
)paren
suffix:semicolon
DECL|variable|high_memory
id|EXPORT_SYMBOL
c_func
(paren
id|high_memory
)paren
suffix:semicolon
DECL|variable|vmalloc_earlyreserve
id|EXPORT_SYMBOL
c_func
(paren
id|vmalloc_earlyreserve
)paren
suffix:semicolon
multiline_comment|/*&n; * If a p?d_bad entry is found while walking page tables, report&n; * the error, before resetting entry to p?d_none.  Usually (but&n; * very seldom) called out from the p?d_none_or_clear_bad macros.&n; */
DECL|function|pgd_clear_bad
r_void
id|pgd_clear_bad
c_func
(paren
id|pgd_t
op_star
id|pgd
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|pgd
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|pgd
)paren
suffix:semicolon
)brace
DECL|function|pud_clear_bad
r_void
id|pud_clear_bad
c_func
(paren
id|pud_t
op_star
id|pud
)paren
(brace
id|pud_ERROR
c_func
(paren
op_star
id|pud
)paren
suffix:semicolon
id|pud_clear
c_func
(paren
id|pud
)paren
suffix:semicolon
)brace
DECL|function|pmd_clear_bad
r_void
id|pmd_clear_bad
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: this doesn&squot;t free the actual pages themselves. That&n; * has been handled earlier when unmapping all the memory regions.&n; */
DECL|function|clear_pte_range
r_static
r_inline
r_void
id|clear_pte_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|addr
op_or
id|end
)paren
op_amp
op_complement
id|PMD_MASK
)paren
)paren
(brace
multiline_comment|/* Only free fully aligned ranges */
r_struct
id|page
op_star
id|page
op_assign
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
id|dec_page_state
c_func
(paren
id|nr_page_table_pages
)paren
suffix:semicolon
id|tlb-&gt;mm-&gt;nr_ptes
op_decrement
suffix:semicolon
id|pte_free_tlb
c_func
(paren
id|tlb
comma
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|clear_pmd_range
r_static
r_inline
r_void
id|clear_pmd_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pmd_t
op_star
id|empty_pmd
op_assign
l_int|NULL
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|addr
)paren
suffix:semicolon
multiline_comment|/* Only free fully aligned ranges */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|addr
op_or
id|end
)paren
op_amp
op_complement
id|PUD_MASK
)paren
)paren
id|empty_pmd
op_assign
id|pmd
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pmd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none_or_clear_bad
c_func
(paren
id|pmd
)paren
)paren
r_continue
suffix:semicolon
id|clear_pte_range
c_func
(paren
id|tlb
comma
id|pmd
comma
id|addr
comma
id|next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pmd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty_pmd
)paren
(brace
id|pud_clear
c_func
(paren
id|pud
)paren
suffix:semicolon
id|pmd_free_tlb
c_func
(paren
id|tlb
comma
id|empty_pmd
)paren
suffix:semicolon
)brace
)brace
DECL|function|clear_pud_range
r_static
r_inline
r_void
id|clear_pud_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pud_t
op_star
id|pud
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pud_t
op_star
id|empty_pud
op_assign
l_int|NULL
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
multiline_comment|/* Only free fully aligned ranges */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|addr
op_or
id|end
)paren
op_amp
op_complement
id|PGDIR_MASK
)paren
)paren
id|empty_pud
op_assign
id|pud
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pud_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pud_none_or_clear_bad
c_func
(paren
id|pud
)paren
)paren
r_continue
suffix:semicolon
id|clear_pmd_range
c_func
(paren
id|tlb
comma
id|pud
comma
id|addr
comma
id|next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pud
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty_pud
)paren
(brace
id|pgd_clear
c_func
(paren
id|pgd
)paren
suffix:semicolon
id|pud_free_tlb
c_func
(paren
id|tlb
comma
id|empty_pud
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function clears user-level page tables of a process.&n; * Unlike other pagetable walks, some memory layouts might give end 0.&n; * Must be called with pagetable lock held.&n; */
DECL|function|clear_page_range
r_void
id|clear_page_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
r_int
r_int
id|i
comma
id|next
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|tlb-&gt;mm
comma
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pgd_index
c_func
(paren
id|addr
)paren
suffix:semicolon
id|i
op_le
id|pgd_index
c_func
(paren
id|end
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|next
op_assign
id|pgd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none_or_clear_bad
c_func
(paren
id|pgd
)paren
)paren
r_continue
suffix:semicolon
id|clear_pud_range
c_func
(paren
id|tlb
comma
id|pgd
comma
id|addr
comma
id|next
)paren
suffix:semicolon
id|pgd
op_increment
suffix:semicolon
id|addr
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|end
)paren
r_break
suffix:semicolon
)brace
)brace
DECL|function|pte_alloc_map
id|pte_t
id|fastcall
op_star
id|pte_alloc_map
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_struct
id|page
op_star
r_new
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_new
op_assign
id|pte_alloc_one
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Because we dropped the lock, we should re-check the&n;&t;&t; * entry, as somebody else could have populated it..&n;&t;&t; */
r_if
c_cond
(paren
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_free
c_func
(paren
r_new
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|mm-&gt;nr_ptes
op_increment
suffix:semicolon
id|inc_page_state
c_func
(paren
id|nr_page_table_pages
)paren
suffix:semicolon
id|pmd_populate
c_func
(paren
id|mm
comma
id|pmd
comma
r_new
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
)brace
DECL|function|pte_alloc_kernel
id|pte_t
id|fastcall
op_star
id|pte_alloc_kernel
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
r_new
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_new
op_assign
id|pte_alloc_one_kernel
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Because we dropped the lock, we should re-check the&n;&t;&t; * entry, as somebody else could have populated it..&n;&t;&t; */
r_if
c_cond
(paren
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_free_kernel
c_func
(paren
r_new
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pmd_populate_kernel
c_func
(paren
id|mm
comma
id|pmd
comma
r_new
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|pte_offset_kernel
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * copy one vm_area from one task to the other. Assumes the page tables&n; * already present in the new task to be cleared in the whole range&n; * covered by this vma.&n; *&n; * dst-&gt;page_table_lock is held on entry and exit,&n; * but may be dropped within p[mg]d_alloc() and pte_alloc_map().&n; */
r_static
r_inline
r_void
DECL|function|copy_one_pte
id|copy_one_pte
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst_mm
comma
r_struct
id|mm_struct
op_star
id|src_mm
comma
id|pte_t
op_star
id|dst_pte
comma
id|pte_t
op_star
id|src_pte
comma
r_int
r_int
id|vm_flags
comma
r_int
r_int
id|addr
)paren
(brace
id|pte_t
id|pte
op_assign
op_star
id|src_pte
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|pfn
suffix:semicolon
multiline_comment|/* pte contains position in swap or file, so copy. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|pte
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pte_file
c_func
(paren
id|pte
)paren
)paren
(brace
id|swap_duplicate
c_func
(paren
id|pte_to_swp_entry
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
multiline_comment|/* make sure dst_mm is on swapoff&squot;s mmlist. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|dst_mm-&gt;mmlist
)paren
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dst_mm-&gt;mmlist
comma
op_amp
id|src_mm-&gt;mmlist
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
)brace
)brace
id|set_pte_at
c_func
(paren
id|dst_mm
comma
id|addr
comma
id|dst_pte
comma
id|pte
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pfn
op_assign
id|pte_pfn
c_func
(paren
id|pte
)paren
suffix:semicolon
multiline_comment|/* the pte points outside of valid memory, the&n;&t; * mapping is assumed to be good, meaningful&n;&t; * and not mapped via rmap - duplicate the&n;&t; * mapping as is.&n;&t; */
id|page
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|set_pte_at
c_func
(paren
id|dst_mm
comma
id|addr
comma
id|dst_pte
comma
id|pte
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it&squot;s a COW mapping, write protect it both&n;&t; * in the parent and the child&n;&t; */
r_if
c_cond
(paren
(paren
id|vm_flags
op_amp
(paren
id|VM_SHARED
op_or
id|VM_MAYWRITE
)paren
)paren
op_eq
id|VM_MAYWRITE
)paren
(brace
id|ptep_set_wrprotect
c_func
(paren
id|src_mm
comma
id|addr
comma
id|src_pte
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|src_pte
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it&squot;s a shared mapping, mark it clean in&n;&t; * the child&n;&t; */
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
id|pte
op_assign
id|pte_mkclean
c_func
(paren
id|pte
)paren
suffix:semicolon
id|pte
op_assign
id|pte_mkold
c_func
(paren
id|pte
)paren
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|dst_mm-&gt;rss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
id|dst_mm-&gt;anon_rss
op_increment
suffix:semicolon
id|set_pte_at
c_func
(paren
id|dst_mm
comma
id|addr
comma
id|dst_pte
comma
id|pte
)paren
suffix:semicolon
id|page_dup_rmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|copy_pte_range
r_static
r_int
id|copy_pte_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst_mm
comma
r_struct
id|mm_struct
op_star
id|src_mm
comma
id|pmd_t
op_star
id|dst_pmd
comma
id|pmd_t
op_star
id|src_pmd
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pte_t
op_star
id|src_pte
comma
op_star
id|dst_pte
suffix:semicolon
r_int
r_int
id|vm_flags
op_assign
id|vma-&gt;vm_flags
suffix:semicolon
r_int
id|progress
suffix:semicolon
id|again
suffix:colon
id|dst_pte
op_assign
id|pte_alloc_map
c_func
(paren
id|dst_mm
comma
id|dst_pmd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_pte
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|src_pte
op_assign
id|pte_offset_map_nested
c_func
(paren
id|src_pmd
comma
id|addr
)paren
suffix:semicolon
id|progress
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|src_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * We are holding two locks at this point - either of them&n;&t;&t; * could generate latencies in another task on another CPU.&n;&t;&t; */
r_if
c_cond
(paren
id|progress
op_ge
l_int|32
op_logical_and
(paren
id|need_resched
c_func
(paren
)paren
op_logical_or
id|need_lockbreak
c_func
(paren
op_amp
id|src_mm-&gt;page_table_lock
)paren
op_logical_or
id|need_lockbreak
c_func
(paren
op_amp
id|dst_mm-&gt;page_table_lock
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
op_star
id|src_pte
)paren
)paren
(brace
id|progress
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|copy_one_pte
c_func
(paren
id|dst_mm
comma
id|src_mm
comma
id|dst_pte
comma
id|src_pte
comma
id|vm_flags
comma
id|addr
)paren
suffix:semicolon
id|progress
op_add_assign
l_int|8
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dst_pte
op_increment
comma
id|src_pte
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|src_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|pte_unmap_nested
c_func
(paren
id|src_pte
op_minus
l_int|1
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|dst_pte
op_minus
l_int|1
)paren
suffix:semicolon
id|cond_resched_lock
c_func
(paren
op_amp
id|dst_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
id|end
)paren
r_goto
id|again
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_pmd_range
r_static
r_inline
r_int
id|copy_pmd_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst_mm
comma
r_struct
id|mm_struct
op_star
id|src_mm
comma
id|pud_t
op_star
id|dst_pud
comma
id|pud_t
op_star
id|src_pud
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pmd_t
op_star
id|src_pmd
comma
op_star
id|dst_pmd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|dst_pmd
op_assign
id|pmd_alloc
c_func
(paren
id|dst_mm
comma
id|dst_pud
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_pmd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|src_pmd
op_assign
id|pmd_offset
c_func
(paren
id|src_pud
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pmd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none_or_clear_bad
c_func
(paren
id|src_pmd
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|copy_pte_range
c_func
(paren
id|dst_mm
comma
id|src_mm
comma
id|dst_pmd
comma
id|src_pmd
comma
id|vma
comma
id|addr
comma
id|next
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dst_pmd
op_increment
comma
id|src_pmd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_pud_range
r_static
r_inline
r_int
id|copy_pud_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst_mm
comma
r_struct
id|mm_struct
op_star
id|src_mm
comma
id|pgd_t
op_star
id|dst_pgd
comma
id|pgd_t
op_star
id|src_pgd
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
id|pud_t
op_star
id|src_pud
comma
op_star
id|dst_pud
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|dst_pud
op_assign
id|pud_alloc
c_func
(paren
id|dst_mm
comma
id|dst_pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_pud
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|src_pud
op_assign
id|pud_offset
c_func
(paren
id|src_pgd
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pud_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pud_none_or_clear_bad
c_func
(paren
id|src_pud
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|copy_pmd_range
c_func
(paren
id|dst_mm
comma
id|src_mm
comma
id|dst_pud
comma
id|src_pud
comma
id|vma
comma
id|addr
comma
id|next
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dst_pud
op_increment
comma
id|src_pud
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_page_range
r_int
id|copy_page_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst_mm
comma
r_struct
id|mm_struct
op_star
id|src_mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pgd_t
op_star
id|src_pgd
comma
op_star
id|dst_pgd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
r_int
r_int
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_int
r_int
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
r_return
id|copy_hugetlb_page_range
c_func
(paren
id|dst_mm
comma
id|src_mm
comma
id|vma
)paren
suffix:semicolon
id|dst_pgd
op_assign
id|pgd_offset
c_func
(paren
id|dst_mm
comma
id|addr
)paren
suffix:semicolon
id|src_pgd
op_assign
id|pgd_offset
c_func
(paren
id|src_mm
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pgd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none_or_clear_bad
c_func
(paren
id|src_pgd
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|copy_pud_range
c_func
(paren
id|dst_mm
comma
id|src_mm
comma
id|dst_pgd
comma
id|src_pgd
comma
id|vma
comma
id|addr
comma
id|next
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dst_pgd
op_increment
comma
id|src_pgd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zap_pte_range
r_static
r_void
id|zap_pte_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|pte_t
id|ptent
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|ptent
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|ptent
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|pte_pfn
c_func
(paren
id|ptent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|details
)paren
op_logical_and
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * unmap_shared_mapping_pages() wants to&n;&t;&t;&t;&t; * invalidate cache without truncating:&n;&t;&t;&t;&t; * unmap shared but keep private pages.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|details-&gt;check_mapping
op_logical_and
id|details-&gt;check_mapping
op_ne
id|page-&gt;mapping
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Each page-&gt;index must be checked when&n;&t;&t;&t;&t; * invalidating or truncating nonlinear.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|details-&gt;nonlinear_vma
op_logical_and
(paren
id|page-&gt;index
template_param
id|details-&gt;last_index
)paren
)paren
r_continue
suffix:semicolon
)brace
id|ptent
op_assign
id|ptep_get_and_clear
c_func
(paren
id|tlb-&gt;mm
comma
id|addr
comma
id|pte
)paren
suffix:semicolon
id|tlb_remove_tlb_entry
c_func
(paren
id|tlb
comma
id|pte
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|details
)paren
op_logical_and
id|details-&gt;nonlinear_vma
op_logical_and
id|linear_page_index
c_func
(paren
id|details-&gt;nonlinear_vma
comma
id|addr
)paren
op_ne
id|page-&gt;index
)paren
id|set_pte_at
c_func
(paren
id|tlb-&gt;mm
comma
id|addr
comma
id|pte
comma
id|pgoff_to_pte
c_func
(paren
id|page-&gt;index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|ptent
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
id|tlb-&gt;mm-&gt;anon_rss
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pte_young
c_func
(paren
id|ptent
)paren
)paren
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|tlb-&gt;freed
op_increment
suffix:semicolon
id|page_remove_rmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|tlb_remove_page
c_func
(paren
id|tlb
comma
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If details-&gt;check_mapping, we leave swap entries;&n;&t;&t; * if details-&gt;nonlinear_vma, we leave file entries.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|details
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_file
c_func
(paren
id|ptent
)paren
)paren
id|free_swap_and_cache
c_func
(paren
id|pte_to_swp_entry
c_func
(paren
id|ptent
)paren
)paren
suffix:semicolon
id|pte_clear
c_func
(paren
id|tlb-&gt;mm
comma
id|addr
comma
id|pte
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pte
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|zap_pmd_range
r_static
r_inline
r_void
id|zap_pmd_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pmd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none_or_clear_bad
c_func
(paren
id|pmd
)paren
)paren
r_continue
suffix:semicolon
id|zap_pte_range
c_func
(paren
id|tlb
comma
id|pmd
comma
id|addr
comma
id|next
comma
id|details
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pmd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
)brace
DECL|function|zap_pud_range
r_static
r_inline
r_void
id|zap_pud_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
id|pud_t
op_star
id|pud
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pud_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pud_none_or_clear_bad
c_func
(paren
id|pud
)paren
)paren
r_continue
suffix:semicolon
id|zap_pmd_range
c_func
(paren
id|tlb
comma
id|pud
comma
id|addr
comma
id|next
comma
id|details
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pud
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
)brace
DECL|function|unmap_page_range
r_static
r_void
id|unmap_page_range
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
r_if
c_cond
(paren
id|details
op_logical_and
op_logical_neg
id|details-&gt;check_mapping
op_logical_and
op_logical_neg
id|details-&gt;nonlinear_vma
)paren
id|details
op_assign
l_int|NULL
suffix:semicolon
id|BUG_ON
c_func
(paren
id|addr
op_ge
id|end
)paren
suffix:semicolon
id|tlb_start_vma
c_func
(paren
id|tlb
comma
id|vma
)paren
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|addr
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pgd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none_or_clear_bad
c_func
(paren
id|pgd
)paren
)paren
r_continue
suffix:semicolon
id|zap_pud_range
c_func
(paren
id|tlb
comma
id|pgd
comma
id|addr
comma
id|next
comma
id|details
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|tlb_end_vma
c_func
(paren
id|tlb
comma
id|vma
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PREEMPT
DECL|macro|ZAP_BLOCK_SIZE
macro_line|# define ZAP_BLOCK_SIZE&t;(8 * PAGE_SIZE)
macro_line|#else
multiline_comment|/* No preempt: go for improved straight-line efficiency */
DECL|macro|ZAP_BLOCK_SIZE
macro_line|# define ZAP_BLOCK_SIZE&t;(1024 * PAGE_SIZE)
macro_line|#endif
multiline_comment|/**&n; * unmap_vmas - unmap a range of memory covered by a list of vma&squot;s&n; * @tlbp: address of the caller&squot;s struct mmu_gather&n; * @mm: the controlling mm_struct&n; * @vma: the starting vma&n; * @start_addr: virtual address at which to start unmapping&n; * @end_addr: virtual address at which to end unmapping&n; * @nr_accounted: Place number of unmapped pages in vm-accountable vma&squot;s here&n; * @details: details of nonlinear truncation or shared cache invalidation&n; *&n; * Returns the number of vma&squot;s which were covered by the unmapping.&n; *&n; * Unmap all pages in the vma list.  Called under page_table_lock.&n; *&n; * We aim to not hold page_table_lock for too long (for scheduling latency&n; * reasons).  So zap pages in ZAP_BLOCK_SIZE bytecounts.  This means we need to&n; * return the ending mmu_gather to the caller.&n; *&n; * Only addresses between `start&squot; and `end&squot; will be unmapped.&n; *&n; * The VMA list must be sorted in ascending virtual address order.&n; *&n; * unmap_vmas() assumes that the caller will flush the whole unmapped address&n; * range after unmap_vmas() returns.  So the only responsibility here is to&n; * ensure that any thus-far unmapped pages are flushed before unmap_vmas()&n; * drops the lock and schedules.&n; */
DECL|function|unmap_vmas
r_int
id|unmap_vmas
c_func
(paren
r_struct
id|mmu_gather
op_star
op_star
id|tlbp
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start_addr
comma
r_int
r_int
id|end_addr
comma
r_int
r_int
op_star
id|nr_accounted
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
r_int
r_int
id|zap_bytes
op_assign
id|ZAP_BLOCK_SIZE
suffix:semicolon
r_int
r_int
id|tlb_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For tlb_finish_mmu */
r_int
id|tlb_start_valid
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|spinlock_t
op_star
id|i_mmap_lock
op_assign
id|details
ques
c_cond
id|details-&gt;i_mmap_lock
suffix:colon
l_int|NULL
suffix:semicolon
r_int
id|fullmm
op_assign
id|tlb_is_full_mm
c_func
(paren
op_star
id|tlbp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|end_addr
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
id|start
op_assign
id|max
c_func
(paren
id|vma-&gt;vm_start
comma
id|start_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|vma-&gt;vm_end
)paren
r_continue
suffix:semicolon
id|end
op_assign
id|min
c_func
(paren
id|vma-&gt;vm_end
comma
id|end_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_le
id|vma-&gt;vm_start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_ACCOUNT
)paren
op_star
id|nr_accounted
op_add_assign
(paren
id|end
op_minus
id|start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|ret
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|start
op_ne
id|end
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tlb_start_valid
)paren
(brace
id|tlb_start
op_assign
id|start
suffix:semicolon
id|tlb_start_valid
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
(brace
id|block
op_assign
id|end
op_minus
id|start
suffix:semicolon
id|unmap_hugepage_range
c_func
(paren
id|vma
comma
id|start
comma
id|end
)paren
suffix:semicolon
)brace
r_else
(brace
id|block
op_assign
id|min
c_func
(paren
id|zap_bytes
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
id|unmap_page_range
c_func
(paren
op_star
id|tlbp
comma
id|vma
comma
id|start
comma
id|start
op_plus
id|block
comma
id|details
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|block
suffix:semicolon
id|zap_bytes
op_sub_assign
id|block
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|zap_bytes
OG
l_int|0
)paren
r_continue
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
op_star
id|tlbp
comma
id|tlb_start
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
op_logical_or
id|need_lockbreak
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
op_logical_or
(paren
id|i_mmap_lock
op_logical_and
id|need_lockbreak
c_func
(paren
id|i_mmap_lock
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i_mmap_lock
)paren
(brace
multiline_comment|/* must reset count of rss freed */
op_star
id|tlbp
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
id|fullmm
)paren
suffix:semicolon
id|details-&gt;break_addr
op_assign
id|start
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
op_star
id|tlbp
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
id|fullmm
)paren
suffix:semicolon
id|tlb_start_valid
op_assign
l_int|0
suffix:semicolon
id|zap_bytes
op_assign
id|ZAP_BLOCK_SIZE
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * zap_page_range - remove user pages in a given range&n; * @vma: vm_area_struct holding the applicable pages&n; * @address: starting address of pages to zap&n; * @size: number of bytes to zap&n; * @details: details of nonlinear truncation or shared cache invalidation&n; */
DECL|function|zap_page_range
r_void
id|zap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_struct
id|mmu_gather
op_star
id|tlb
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_int
r_int
id|nr_accounted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
(brace
id|zap_hugepage_range
c_func
(paren
id|vma
comma
id|address
comma
id|size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|tlb
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
l_int|0
)paren
suffix:semicolon
id|unmap_vmas
c_func
(paren
op_amp
id|tlb
comma
id|mm
comma
id|vma
comma
id|address
comma
id|end
comma
op_amp
id|nr_accounted
comma
id|details
)paren
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
id|tlb
comma
id|address
comma
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do a quick page-table lookup for a single page.&n; * mm-&gt;page_table_lock must be held.&n; */
r_static
r_struct
id|page
op_star
DECL|function|__follow_page
id|__follow_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
comma
r_int
id|read
comma
r_int
id|write
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_int
r_int
id|pfn
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|follow_huge_addr
c_func
(paren
id|mm
comma
id|address
comma
id|write
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_return
id|page
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pgd_bad
c_func
(paren
op_star
id|pgd
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pud_none
c_func
(paren
op_star
id|pud
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pud_bad
c_func
(paren
op_star
id|pud
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|pmd_huge
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
id|follow_huge_pmd
c_func
(paren
id|mm
comma
id|address
comma
id|pmd
comma
id|write
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptep
)paren
r_goto
id|out
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
id|pte_unmap
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
r_if
c_cond
(paren
id|write
op_logical_and
op_logical_neg
id|pte_write
c_func
(paren
id|pte
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|read
op_logical_and
op_logical_neg
id|pte_read
c_func
(paren
id|pte
)paren
)paren
r_goto
id|out
suffix:semicolon
id|pfn
op_assign
id|pte_pfn
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
op_logical_and
op_logical_neg
id|pte_dirty
c_func
(paren
id|pte
)paren
op_logical_and
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
r_struct
id|page
op_star
DECL|function|follow_page
id|follow_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
comma
r_int
id|write
)paren
(brace
r_return
id|__follow_page
c_func
(paren
id|mm
comma
id|address
comma
multiline_comment|/*read*/
l_int|0
comma
id|write
)paren
suffix:semicolon
)brace
r_int
DECL|function|check_user_page_readable
id|check_user_page_readable
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
)paren
(brace
r_return
id|__follow_page
c_func
(paren
id|mm
comma
id|address
comma
multiline_comment|/*read*/
l_int|1
comma
multiline_comment|/*write*/
l_int|0
)paren
op_ne
l_int|NULL
suffix:semicolon
)brace
DECL|variable|check_user_page_readable
id|EXPORT_SYMBOL
c_func
(paren
id|check_user_page_readable
)paren
suffix:semicolon
multiline_comment|/* &n; * Given a physical address, is there a useful struct page pointing to&n; * it?  This may become more complex in the future if we start dealing&n; * with IO-aperture pages for direct-IO.&n; */
DECL|function|get_page_map
r_static
r_inline
r_struct
id|page
op_star
id|get_page_map
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|untouched_anonymous_page
id|untouched_anonymous_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
multiline_comment|/* Check if the vma is for an anonymous mapping. */
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;nopage
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check if page directory entry exists. */
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pgd_bad
c_func
(paren
op_star
id|pgd
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pud_none
c_func
(paren
op_star
id|pud
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pud_bad
c_func
(paren
op_star
id|pud
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Check if page middle directory entry exists. */
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
op_logical_or
id|unlikely
c_func
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* There is a pte slot for &squot;address&squot; in &squot;mm&squot;. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_user_pages
r_int
id|get_user_pages
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|write
comma
r_int
id|force
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_struct
id|vm_area_struct
op_star
op_star
id|vmas
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * Require read or write permissions.&n;&t; * If &squot;force&squot; is set, we only require the &quot;MAY&quot; flags.&n;&t; */
id|flags
op_assign
id|write
ques
c_cond
(paren
id|VM_WRITE
op_or
id|VM_MAYWRITE
)paren
suffix:colon
(paren
id|VM_READ
op_or
id|VM_MAYREAD
)paren
suffix:semicolon
id|flags
op_and_assign
id|force
ques
c_cond
(paren
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
)paren
suffix:colon
(paren
id|VM_READ
op_or
id|VM_WRITE
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|vma
op_assign
id|find_extend_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
op_logical_and
id|in_gate_area
c_func
(paren
id|tsk
comma
id|start
)paren
)paren
(brace
r_int
r_int
id|pg
op_assign
id|start
op_amp
id|PAGE_MASK
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|gate_vma
op_assign
id|get_gate_vma
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
multiline_comment|/* user gate pages are read-only */
r_return
id|i
ques
c_cond
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|pg
OG
id|TASK_SIZE
)paren
id|pgd
op_assign
id|pgd_offset_k
c_func
(paren
id|pg
)paren
suffix:semicolon
r_else
id|pgd
op_assign
id|pgd_offset_gate
c_func
(paren
id|mm
comma
id|pg
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
suffix:semicolon
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|pg
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pud_none
c_func
(paren
op_star
id|pud
)paren
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|pg
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|pg
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pte_none
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
id|pte_page
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
id|get_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vmas
)paren
id|vmas
(braket
id|i
)braket
op_assign
id|gate_vma
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|len
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vma
op_logical_or
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_IO
)paren
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|vma-&gt;vm_flags
)paren
)paren
r_return
id|i
ques
c_cond
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
(brace
id|i
op_assign
id|follow_hugetlb_page
c_func
(paren
id|mm
comma
id|vma
comma
id|pages
comma
id|vmas
comma
op_amp
id|start
comma
op_amp
id|len
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|map
suffix:semicolon
r_int
id|lookup_write
op_assign
id|write
suffix:semicolon
id|cond_resched_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|map
op_assign
id|follow_page
c_func
(paren
id|mm
comma
id|start
comma
id|lookup_write
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Shortcut for anonymous pages. We don&squot;t want&n;&t;&t;&t;&t; * to force the creation of pages tables for&n;&t;&t;&t;&t; * insanly big anonymously mapped areas that&n;&t;&t;&t;&t; * nobody touched so far. This is important&n;&t;&t;&t;&t; * for doing a core dump for these mappings.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lookup_write
op_logical_and
id|untouched_anonymous_page
c_func
(paren
id|mm
comma
id|vma
comma
id|start
)paren
)paren
(brace
id|map
op_assign
id|ZERO_PAGE
c_func
(paren
id|start
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|handle_mm_fault
c_func
(paren
id|mm
comma
id|vma
comma
id|start
comma
id|write
)paren
)paren
(brace
r_case
id|VM_FAULT_MINOR
suffix:colon
id|tsk-&gt;min_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VM_FAULT_MAJOR
suffix:colon
id|tsk-&gt;maj_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VM_FAULT_SIGBUS
suffix:colon
r_return
id|i
ques
c_cond
id|i
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_case
id|VM_FAULT_OOM
suffix:colon
r_return
id|i
ques
c_cond
id|i
suffix:colon
op_minus
id|ENOMEM
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Now that we have performed a write fault&n;&t;&t;&t;&t; * and surely no longer have a shared page we&n;&t;&t;&t;&t; * shouldn&squot;t write, we shouldn&squot;t ignore an&n;&t;&t;&t;&t; * unwritable page in the page table if&n;&t;&t;&t;&t; * we are forcing write access.&n;&t;&t;&t;&t; */
id|lookup_write
op_assign
id|write
op_logical_and
op_logical_neg
id|force
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pages
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
id|get_page_map
c_func
(paren
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pages
(braket
id|i
)braket
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|page_cache_release
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
id|page_cache_get
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vmas
)paren
id|vmas
(braket
id|i
)braket
op_assign
id|vma
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
op_logical_and
id|start
OL
id|vma-&gt;vm_end
)paren
(brace
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
(brace
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|i
suffix:semicolon
)brace
DECL|variable|get_user_pages
id|EXPORT_SYMBOL
c_func
(paren
id|get_user_pages
)paren
suffix:semicolon
DECL|function|zeromap_pte_range
r_static
r_int
id|zeromap_pte_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
id|pgprot_t
id|prot
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
id|pte_alloc_map
c_func
(paren
id|mm
comma
id|pmd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|pte_t
id|zero_pte
op_assign
id|pte_wrprotect
c_func
(paren
id|mk_pte
c_func
(paren
id|ZERO_PAGE
c_func
(paren
id|addr
)paren
comma
id|prot
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pte_none
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
id|set_pte_at
c_func
(paren
id|mm
comma
id|addr
comma
id|pte
comma
id|zero_pte
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pte
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zeromap_pmd_range
r_static
r_inline
r_int
id|zeromap_pmd_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
id|pgprot_t
id|prot
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pmd
op_assign
id|pmd_alloc
c_func
(paren
id|mm
comma
id|pud
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pmd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zeromap_pte_range
c_func
(paren
id|mm
comma
id|pmd
comma
id|addr
comma
id|next
comma
id|prot
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pmd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zeromap_pud_range
r_static
r_inline
r_int
id|zeromap_pud_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
id|pgprot_t
id|prot
)paren
(brace
id|pud_t
op_star
id|pud
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pud
op_assign
id|pud_alloc
c_func
(paren
id|mm
comma
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pud
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pud_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zeromap_pmd_range
c_func
(paren
id|mm
comma
id|pud
comma
id|addr
comma
id|next
comma
id|prot
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pud
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zeromap_page_range
r_int
id|zeromap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
id|addr
op_ge
id|end
)paren
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|vma
comma
id|addr
comma
id|end
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pgd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
id|err
op_assign
id|zeromap_pud_range
c_func
(paren
id|mm
comma
id|pgd
comma
id|addr
comma
id|next
comma
id|prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * maps a range of physical memory into the requested pages. the old&n; * mappings are removed. any references to nonexistent pages results&n; * in null mappings (currently treated as &quot;copy-on-access&quot;)&n; */
DECL|function|remap_pte_range
r_static
r_int
id|remap_pte_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
id|pfn
comma
id|pgprot_t
id|prot
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
id|pte_alloc_map
c_func
(paren
id|mm
comma
id|pmd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|pte_none
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|pfn_to_page
c_func
(paren
id|pfn
)paren
)paren
)paren
id|set_pte_at
c_func
(paren
id|mm
comma
id|addr
comma
id|pte
comma
id|pfn_pte
c_func
(paren
id|pfn
comma
id|prot
)paren
)paren
suffix:semicolon
id|pfn
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pte
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remap_pmd_range
r_static
r_inline
r_int
id|remap_pmd_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
id|pfn
comma
id|pgprot_t
id|prot
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pfn
op_sub_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pmd
op_assign
id|pmd_alloc
c_func
(paren
id|mm
comma
id|pud
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pmd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_pte_range
c_func
(paren
id|mm
comma
id|pmd
comma
id|addr
comma
id|next
comma
id|pfn
op_plus
(paren
id|addr
op_rshift
id|PAGE_SHIFT
)paren
comma
id|prot
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pmd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remap_pud_range
r_static
r_inline
r_int
id|remap_pud_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
id|pfn
comma
id|pgprot_t
id|prot
)paren
(brace
id|pud_t
op_star
id|pud
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
id|pfn
op_sub_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pud
op_assign
id|pud_alloc
c_func
(paren
id|mm
comma
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pud
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pud_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_pmd_range
c_func
(paren
id|mm
comma
id|pud
comma
id|addr
comma
id|next
comma
id|pfn
op_plus
(paren
id|addr
op_rshift
id|PAGE_SHIFT
)paren
comma
id|prot
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pud
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Note: this is only safe if the mm semaphore is held when called. */
DECL|function|remap_pfn_range
r_int
id|remap_pfn_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|pfn
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
r_int
r_int
id|next
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Physically remapped pages are special. Tell the&n;&t; * rest of the world about it:&n;&t; *   VM_IO tells people not to look at these pages&n;&t; *&t;(accesses can have side effects).&n;&t; *   VM_RESERVED tells swapout not to try to touch&n;&t; *&t;this region.&n;&t; */
id|vma-&gt;vm_flags
op_or_assign
id|VM_IO
op_or
id|VM_RESERVED
suffix:semicolon
id|BUG_ON
c_func
(paren
id|addr
op_ge
id|end
)paren
suffix:semicolon
id|pfn
op_sub_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|vma
comma
id|addr
comma
id|end
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_do
(brace
id|next
op_assign
id|pgd_addr_end
c_func
(paren
id|addr
comma
id|end
)paren
suffix:semicolon
id|err
op_assign
id|remap_pud_range
c_func
(paren
id|mm
comma
id|pgd
comma
id|addr
comma
id|next
comma
id|pfn
op_plus
(paren
id|addr
op_rshift
id|PAGE_SHIFT
)paren
comma
id|prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgd
op_increment
comma
id|addr
op_assign
id|next
comma
id|addr
op_ne
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|remap_pfn_range
id|EXPORT_SYMBOL
c_func
(paren
id|remap_pfn_range
)paren
suffix:semicolon
multiline_comment|/*&n; * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when&n; * servicing faults for write access.  In the normal case, do always want&n; * pte_mkwrite.  But get_user_pages can cause write faults for mappings&n; * that do not have writing enabled, when used by access_process_vm.&n; */
DECL|function|maybe_mkwrite
r_static
r_inline
id|pte_t
id|maybe_mkwrite
c_func
(paren
id|pte_t
id|pte
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
)paren
id|pte
op_assign
id|pte_mkwrite
c_func
(paren
id|pte
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/*&n; * We hold the mm semaphore for reading and vma-&gt;vm_mm-&gt;page_table_lock&n; */
DECL|function|break_cow
r_static
r_inline
r_void
id|break_cow
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|page
op_star
id|new_page
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|page_table
)paren
(brace
id|pte_t
id|entry
suffix:semicolon
id|entry
op_assign
id|maybe_mkwrite
c_func
(paren
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|new_page
comma
id|vma-&gt;vm_page_prot
)paren
)paren
comma
id|vma
)paren
suffix:semicolon
id|ptep_establish
c_func
(paren
id|vma
comma
id|address
comma
id|page_table
comma
id|entry
)paren
suffix:semicolon
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|address
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine handles present pages, when users try to write&n; * to a shared page. It is done by copying the page to a new address&n; * and decrementing the shared-page counter for the old page.&n; *&n; * Goto-purists beware: the only reason for goto&squot;s here is that it results&n; * in better assembly code.. The &quot;default&quot; path will see no jumps at all.&n; *&n; * Note that this routine assumes that the protection checks have been&n; * done by the caller (the low-level page fault routine in most cases).&n; * Thus we can safely just mark it writable once we&squot;ve done any necessary&n; * COW.&n; *&n; * We also mark the page dirty at this point even though the page will&n; * change only once the write actually happens. This avoids a few races,&n; * and potentially makes it more efficient.&n; *&n; * We hold the mm semaphore and the page_table_lock on entry and exit&n; * with the page_table_lock released.&n; */
DECL|function|do_wp_page
r_static
r_int
id|do_wp_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|page_table
comma
id|pmd_t
op_star
id|pmd
comma
id|pte_t
id|pte
)paren
(brace
r_struct
id|page
op_star
id|old_page
comma
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|pte_pfn
c_func
(paren
id|pte
)paren
suffix:semicolon
id|pte_t
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This should really halt the system so it can be debugged or&n;&t;&t; * at least the kernel stops what it&squot;s doing before it corrupts&n;&t;&t; * data, but for the moment just pretend this is OOM.&n;&t;&t; */
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;do_wp_page: bogus page at address %08lx&bslash;n&quot;
comma
id|address
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|VM_FAULT_OOM
suffix:semicolon
)brace
id|old_page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestSetPageLocked
c_func
(paren
id|old_page
)paren
)paren
(brace
r_int
id|reuse
op_assign
id|can_share_swap_page
c_func
(paren
id|old_page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|old_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reuse
)paren
(brace
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
comma
id|pfn
)paren
suffix:semicolon
id|entry
op_assign
id|maybe_mkwrite
c_func
(paren
id|pte_mkyoung
c_func
(paren
id|pte_mkdirty
c_func
(paren
id|pte
)paren
)paren
comma
id|vma
)paren
suffix:semicolon
id|ptep_set_access_flags
c_func
(paren
id|vma
comma
id|address
comma
id|page_table
comma
id|entry
comma
l_int|1
)paren
suffix:semicolon
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|address
comma
id|entry
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|VM_FAULT_MINOR
suffix:semicolon
)brace
)brace
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we need to copy. Oh, well..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|old_page
)paren
)paren
id|page_cache_get
c_func
(paren
id|old_page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|anon_vma_prepare
c_func
(paren
id|vma
)paren
)paren
)paren
r_goto
id|no_new_page
suffix:semicolon
r_if
c_cond
(paren
id|old_page
op_eq
id|ZERO_PAGE
c_func
(paren
id|address
)paren
)paren
(brace
id|new_page
op_assign
id|alloc_zeroed_user_highpage
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|no_new_page
suffix:semicolon
)brace
r_else
(brace
id|new_page
op_assign
id|alloc_page_vma
c_func
(paren
id|GFP_HIGHUSER
comma
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|no_new_page
suffix:semicolon
id|copy_user_highpage
c_func
(paren
id|new_page
comma
id|old_page
comma
id|address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Re-check the pte - we dropped the lock&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page_table
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|pte_same
c_func
(paren
op_star
id|page_table
comma
id|pte
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|old_page
)paren
)paren
id|mm-&gt;anon_rss
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|old_page
)paren
)paren
op_increment
id|mm-&gt;rss
suffix:semicolon
r_else
id|page_remove_rmap
c_func
(paren
id|old_page
)paren
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
comma
id|pfn
)paren
suffix:semicolon
id|break_cow
c_func
(paren
id|vma
comma
id|new_page
comma
id|address
comma
id|page_table
)paren
suffix:semicolon
id|lru_cache_add_active
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_add_anon_rmap
c_func
(paren
id|new_page
comma
id|vma
comma
id|address
)paren
suffix:semicolon
multiline_comment|/* Free the old page.. */
id|new_page
op_assign
id|old_page
suffix:semicolon
)brace
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|old_page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|VM_FAULT_MINOR
suffix:semicolon
id|no_new_page
suffix:colon
id|page_cache_release
c_func
(paren
id|old_page
)paren
suffix:semicolon
r_return
id|VM_FAULT_OOM
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper functions for unmap_mapping_range().&n; *&n; * __ Notes on dropping i_mmap_lock to reduce latency while unmapping __&n; *&n; * We have to restart searching the prio_tree whenever we drop the lock,&n; * since the iterator is only valid while the lock is held, and anyway&n; * a later vma might be split and reinserted earlier while lock dropped.&n; *&n; * The list of nonlinear vmas could be handled more efficiently, using&n; * a placeholder, but handle it in the same way until a need is shown.&n; * It is important to search the prio_tree before nonlinear list: a vma&n; * may become nonlinear and be shifted from prio_tree to nonlinear list&n; * while the lock is dropped; but never shifted from list to prio_tree.&n; *&n; * In order to make forward progress despite restarting the search,&n; * vm_truncate_count is used to mark a vma as now dealt with, so we can&n; * quickly skip it next time around.  Since the prio_tree search only&n; * shows us those vmas affected by unmapping the range in question, we&n; * can&squot;t efficiently keep all vmas in step with mapping-&gt;truncate_count:&n; * so instead reset them all whenever it wraps back to 0 (then go to 1).&n; * mapping-&gt;truncate_count and vma-&gt;vm_truncate_count are protected by&n; * i_mmap_lock.&n; *&n; * In order to make forward progress despite repeatedly restarting some&n; * large vma, note the break_addr set by unmap_vmas when it breaks out:&n; * and restart from that address when we reach that vma again.  It might&n; * have been split or merged, shrunk or extended, but never shifted: so&n; * restart_addr remains valid so long as it remains in the vma&squot;s range.&n; * unmap_mapping_range forces truncate_count to leap over page-aligned&n; * values so we can save vma&squot;s restart_addr in its truncate_count field.&n; */
DECL|macro|is_restart_addr
mdefine_line|#define is_restart_addr(truncate_count) (!((truncate_count) &amp; ~PAGE_MASK))
DECL|function|reset_vma_truncate_counts
r_static
r_void
id|reset_vma_truncate_counts
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|prio_tree_iter
id|iter
suffix:semicolon
id|vma_prio_tree_foreach
c_func
(paren
id|vma
comma
op_amp
id|iter
comma
op_amp
id|mapping-&gt;i_mmap
comma
l_int|0
comma
id|ULONG_MAX
)paren
id|vma-&gt;vm_truncate_count
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_nonlinear
comma
id|shared.vm_set.list
)paren
id|vma-&gt;vm_truncate_count
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|unmap_mapping_range_vma
r_static
r_int
id|unmap_mapping_range_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start_addr
comma
r_int
r_int
id|end_addr
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
r_int
r_int
id|restart_addr
suffix:semicolon
r_int
id|need_break
suffix:semicolon
id|again
suffix:colon
id|restart_addr
op_assign
id|vma-&gt;vm_truncate_count
suffix:semicolon
r_if
c_cond
(paren
id|is_restart_addr
c_func
(paren
id|restart_addr
)paren
op_logical_and
id|start_addr
OL
id|restart_addr
)paren
(brace
id|start_addr
op_assign
id|restart_addr
suffix:semicolon
r_if
c_cond
(paren
id|start_addr
op_ge
id|end_addr
)paren
(brace
multiline_comment|/* Top of vma has been split off since last time */
id|vma-&gt;vm_truncate_count
op_assign
id|details-&gt;truncate_count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|details-&gt;break_addr
op_assign
id|end_addr
suffix:semicolon
id|zap_page_range
c_func
(paren
id|vma
comma
id|start_addr
comma
id|end_addr
op_minus
id|start_addr
comma
id|details
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot rely on the break test in unmap_vmas:&n;&t; * on the one hand, we don&squot;t want to restart our loop&n;&t; * just because that broke out for the page_table_lock;&n;&t; * on the other hand, it does no test when vma is small.&n;&t; */
id|need_break
op_assign
id|need_resched
c_func
(paren
)paren
op_logical_or
id|need_lockbreak
c_func
(paren
id|details-&gt;i_mmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|details-&gt;break_addr
op_ge
id|end_addr
)paren
(brace
multiline_comment|/* We have now completed this vma: mark it so */
id|vma-&gt;vm_truncate_count
op_assign
id|details-&gt;truncate_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_break
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Note restart_addr in vma&squot;s truncate_count field */
id|vma-&gt;vm_truncate_count
op_assign
id|details-&gt;break_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_break
)paren
r_goto
id|again
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|details-&gt;i_mmap_lock
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|details-&gt;i_mmap_lock
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
DECL|function|unmap_mapping_range_tree
r_static
r_inline
r_void
id|unmap_mapping_range_tree
c_func
(paren
r_struct
id|prio_tree_root
op_star
id|root
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|prio_tree_iter
id|iter
suffix:semicolon
id|pgoff_t
id|vba
comma
id|vea
comma
id|zba
comma
id|zea
suffix:semicolon
id|restart
suffix:colon
id|vma_prio_tree_foreach
c_func
(paren
id|vma
comma
op_amp
id|iter
comma
id|root
comma
id|details-&gt;first_index
comma
id|details-&gt;last_index
)paren
(brace
multiline_comment|/* Skip quickly over those we have already dealt with */
r_if
c_cond
(paren
id|vma-&gt;vm_truncate_count
op_eq
id|details-&gt;truncate_count
)paren
r_continue
suffix:semicolon
id|vba
op_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|vea
op_assign
id|vba
op_plus
(paren
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
id|zba
op_assign
id|details-&gt;first_index
suffix:semicolon
r_if
c_cond
(paren
id|zba
OL
id|vba
)paren
id|zba
op_assign
id|vba
suffix:semicolon
id|zea
op_assign
id|details-&gt;last_index
suffix:semicolon
r_if
c_cond
(paren
id|zea
OG
id|vea
)paren
id|zea
op_assign
id|vea
suffix:semicolon
r_if
c_cond
(paren
id|unmap_mapping_range_vma
c_func
(paren
id|vma
comma
(paren
(paren
id|zba
op_minus
id|vba
)paren
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_start
comma
(paren
(paren
id|zea
op_minus
id|vba
op_plus
l_int|1
)paren
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_start
comma
id|details
)paren
OL
l_int|0
)paren
r_goto
id|restart
suffix:semicolon
)brace
)brace
DECL|function|unmap_mapping_range_list
r_static
r_inline
r_void
id|unmap_mapping_range_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|zap_details
op_star
id|details
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
multiline_comment|/*&n;&t; * In nonlinear VMAs there is no correspondence between virtual address&n;&t; * offset and file offset.  So we must perform an exhaustive search&n;&t; * across *all* the pages in each nonlinear VMA, not just the pages&n;&t; * whose virtual address lies outside the file truncation point.&n;&t; */
id|restart
suffix:colon
id|list_for_each_entry
c_func
(paren
id|vma
comma
id|head
comma
id|shared.vm_set.list
)paren
(brace
multiline_comment|/* Skip quickly over those we have already dealt with */
r_if
c_cond
(paren
id|vma-&gt;vm_truncate_count
op_eq
id|details-&gt;truncate_count
)paren
r_continue
suffix:semicolon
id|details-&gt;nonlinear_vma
op_assign
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|unmap_mapping_range_vma
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
comma
id|details
)paren
OL
l_int|0
)paren
r_goto
id|restart
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * unmap_mapping_range - unmap the portion of all mmaps&n; * in the specified address_space corresponding to the specified&n; * page range in the underlying file.&n; * @address_space: the address space containing mmaps to be unmapped.&n; * @holebegin: byte in first page to unmap, relative to the start of&n; * the underlying file.  This will be rounded down to a PAGE_SIZE&n; * boundary.  Note that this is different from vmtruncate(), which&n; * must keep the partial page.  In contrast, we must get rid of&n; * partial pages.&n; * @holelen: size of prospective hole in bytes.  This will be rounded&n; * up to a PAGE_SIZE boundary.  A holelen of zero truncates to the&n; * end of the file.&n; * @even_cows: 1 when truncating a file, unmap even private COWed pages;&n; * but 0 when invalidating pagecache, don&squot;t throw away private data.&n; */
DECL|function|unmap_mapping_range
r_void
id|unmap_mapping_range
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
r_const
id|holebegin
comma
id|loff_t
r_const
id|holelen
comma
r_int
id|even_cows
)paren
(brace
r_struct
id|zap_details
id|details
suffix:semicolon
id|pgoff_t
id|hba
op_assign
id|holebegin
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pgoff_t
id|hlen
op_assign
(paren
id|holelen
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Check for overflow. */
r_if
c_cond
(paren
r_sizeof
(paren
id|holelen
)paren
OG
r_sizeof
(paren
id|hlen
)paren
)paren
(brace
r_int
r_int
id|holeend
op_assign
(paren
id|holebegin
op_plus
id|holelen
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|holeend
op_amp
op_complement
(paren
r_int
r_int
)paren
id|ULONG_MAX
)paren
id|hlen
op_assign
id|ULONG_MAX
op_minus
id|hba
op_plus
l_int|1
suffix:semicolon
)brace
id|details.check_mapping
op_assign
id|even_cows
ques
c_cond
l_int|NULL
suffix:colon
id|mapping
suffix:semicolon
id|details.nonlinear_vma
op_assign
l_int|NULL
suffix:semicolon
id|details.first_index
op_assign
id|hba
suffix:semicolon
id|details.last_index
op_assign
id|hba
op_plus
id|hlen
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|details.last_index
OL
id|details.first_index
)paren
id|details.last_index
op_assign
id|ULONG_MAX
suffix:semicolon
id|details.i_mmap_lock
op_assign
op_amp
id|mapping-&gt;i_mmap_lock
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
multiline_comment|/* serialize i_size write against truncate_count write */
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Protect against page faults, and endless unmapping loops */
id|mapping-&gt;truncate_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * For archs where spin_lock has inclusive semantics like ia64&n;&t; * this smp_mb() will prevent to read pagetable contents&n;&t; * before the truncate_count increment is visible to&n;&t; * other cpus.&n;&t; */
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|is_restart_addr
c_func
(paren
id|mapping-&gt;truncate_count
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mapping-&gt;truncate_count
op_eq
l_int|0
)paren
id|reset_vma_truncate_counts
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|mapping-&gt;truncate_count
op_increment
suffix:semicolon
)brace
id|details.truncate_count
op_assign
id|mapping-&gt;truncate_count
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|prio_tree_empty
c_func
(paren
op_amp
id|mapping-&gt;i_mmap
)paren
)paren
)paren
id|unmap_mapping_range_tree
c_func
(paren
op_amp
id|mapping-&gt;i_mmap
comma
op_amp
id|details
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_nonlinear
)paren
)paren
)paren
id|unmap_mapping_range_list
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_nonlinear
comma
op_amp
id|details
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
)brace
DECL|variable|unmap_mapping_range
id|EXPORT_SYMBOL
c_func
(paren
id|unmap_mapping_range
)paren
suffix:semicolon
multiline_comment|/*&n; * Handle all mappings that got truncated by a &quot;truncate()&quot;&n; * system call.&n; *&n; * NOTE! We have to be ready to update the memory sharing&n; * between the file and the memory map for a potential last&n; * incomplete page.  Ugly, but necessary.&n; */
DECL|function|vmtruncate
r_int
id|vmtruncate
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
OL
id|offset
)paren
r_goto
id|do_expand
suffix:semicolon
multiline_comment|/*&n;&t; * truncation of in-use swapfiles is disallowed - it would cause&n;&t; * subsequent swapout to scribble on the now-freed blocks.&n;&t; */
r_if
c_cond
(paren
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
r_goto
id|out_busy
suffix:semicolon
id|i_size_write
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|unmap_mapping_range
c_func
(paren
id|mapping
comma
id|offset
op_plus
id|PAGE_SIZE
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|mapping
comma
id|offset
)paren
suffix:semicolon
r_goto
id|out_truncate
suffix:semicolon
id|do_expand
suffix:colon
id|limit
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
op_logical_and
id|offset
OG
id|limit
)paren
r_goto
id|out_sig
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
r_goto
id|out_big
suffix:semicolon
id|i_size_write
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|out_truncate
suffix:colon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_sig
suffix:colon
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|out_big
suffix:colon
r_return
op_minus
id|EFBIG
suffix:semicolon
id|out_busy
suffix:colon
r_return
op_minus
id|ETXTBSY
suffix:semicolon
)brace
DECL|variable|vmtruncate
id|EXPORT_SYMBOL
c_func
(paren
id|vmtruncate
)paren
suffix:semicolon
multiline_comment|/* &n; * Primitive swap readahead code. We simply read an aligned block of&n; * (1 &lt;&lt; page_cluster) entries in the swap area. This method is chosen&n; * because it doesn&squot;t cost us any seek time.  We also make sure to queue&n; * the &squot;original&squot; request together with the readahead ones...  &n; *&n; * This has been extended to use the NUMA policies from the mm triggering&n; * the readahead.&n; *&n; * Caller must hold down_read on the vma-&gt;vm_mm if vma is not NULL.&n; */
DECL|function|swapin_readahead
r_void
id|swapin_readahead
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
macro_line|#ifdef CONFIG_NUMA
r_struct
id|vm_area_struct
op_star
id|next_vma
op_assign
id|vma
ques
c_cond
id|vma-&gt;vm_next
suffix:colon
l_int|NULL
suffix:semicolon
macro_line|#endif
r_int
id|i
comma
id|num
suffix:semicolon
r_struct
id|page
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; * Get the number of handles we should do readahead io to.&n;&t; */
id|num
op_assign
id|valid_swaphandles
c_func
(paren
id|entry
comma
op_amp
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|offset
op_increment
comma
id|i
op_increment
)paren
(brace
multiline_comment|/* Ok, do the async read-ahead now */
id|new_page
op_assign
id|read_swap_cache_async
c_func
(paren
id|swp_entry
c_func
(paren
id|swp_type
c_func
(paren
id|entry
)paren
comma
id|offset
)paren
comma
id|vma
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_break
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
multiline_comment|/*&n;&t;&t; * Find the next applicable VMA for the NUMA policy.&n;&t;&t; */
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|0
)paren
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ge
id|vma-&gt;vm_end
)paren
(brace
id|vma
op_assign
id|next_vma
suffix:semicolon
id|next_vma
op_assign
id|vma
ques
c_cond
id|vma-&gt;vm_next
suffix:colon
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma
op_logical_and
id|addr
OL
id|vma-&gt;vm_start
)paren
id|vma
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|next_vma
op_logical_and
id|addr
op_ge
id|next_vma-&gt;vm_start
)paren
(brace
id|vma
op_assign
id|next_vma
suffix:semicolon
id|next_vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Push any new pages onto the LRU now */
)brace
multiline_comment|/*&n; * We hold the mm semaphore and the page_table_lock on entry and&n; * should release the pagetable lock on exit..&n; */
DECL|function|do_swap_page
r_static
r_int
id|do_swap_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|page_table
comma
id|pmd_t
op_star
id|pmd
comma
id|pte_t
id|orig_pte
comma
r_int
id|write_access
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|swp_entry_t
id|entry
op_assign
id|pte_to_swp_entry
c_func
(paren
id|orig_pte
)paren
suffix:semicolon
id|pte_t
id|pte
suffix:semicolon
r_int
id|ret
op_assign
id|VM_FAULT_MINOR
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|swapin_readahead
c_func
(paren
id|entry
comma
id|address
comma
id|vma
)paren
suffix:semicolon
id|page
op_assign
id|read_swap_cache_async
c_func
(paren
id|entry
comma
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Back out if somebody else faulted in this pte while&n;&t;&t;&t; * we released the page table lock.&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page_table
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|pte_same
c_func
(paren
op_star
id|page_table
comma
id|orig_pte
)paren
)paren
)paren
id|ret
op_assign
id|VM_FAULT_OOM
suffix:semicolon
r_else
id|ret
op_assign
id|VM_FAULT_MINOR
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Had to read the page from swap area: Major fault */
id|ret
op_assign
id|VM_FAULT_MAJOR
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgmajfault
)paren
suffix:semicolon
id|grab_swap_token
c_func
(paren
)paren
suffix:semicolon
)brace
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Back out if somebody else faulted in this pte while we&n;&t; * released the page table lock.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page_table
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pte_same
c_func
(paren
op_star
id|page_table
comma
id|orig_pte
)paren
)paren
)paren
(brace
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
id|VM_FAULT_MINOR
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* The page isn&squot;t present yet, go ahead with the fault. */
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm_swap_full
c_func
(paren
)paren
)paren
id|remove_exclusive_swap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_increment
suffix:semicolon
id|pte
op_assign
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_access
op_logical_and
id|can_share_swap_page
c_func
(paren
id|page
)paren
)paren
(brace
id|pte
op_assign
id|maybe_mkwrite
c_func
(paren
id|pte_mkdirty
c_func
(paren
id|pte
)paren
comma
id|vma
)paren
suffix:semicolon
id|write_access
op_assign
l_int|0
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_icache_page
c_func
(paren
id|vma
comma
id|page
)paren
suffix:semicolon
id|set_pte_at
c_func
(paren
id|mm
comma
id|address
comma
id|page_table
comma
id|pte
)paren
suffix:semicolon
id|page_add_anon_rmap
c_func
(paren
id|page
comma
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_access
)paren
(brace
r_if
c_cond
(paren
id|do_wp_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|page_table
comma
id|pmd
comma
id|pte
)paren
op_eq
id|VM_FAULT_OOM
)paren
id|ret
op_assign
id|VM_FAULT_OOM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* No need to invalidate - it was non-present before */
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|address
comma
id|pte
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * We are called with the MM semaphore and page_table_lock&n; * spinlock held to protect against concurrent faults in&n; * multithreaded programs. &n; */
r_static
r_int
DECL|function|do_anonymous_page
id|do_anonymous_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pte_t
op_star
id|page_table
comma
id|pmd_t
op_star
id|pmd
comma
r_int
id|write_access
comma
r_int
r_int
id|addr
)paren
(brace
id|pte_t
id|entry
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|ZERO_PAGE
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* Read-only mapping of ZERO_PAGE. */
id|entry
op_assign
id|pte_wrprotect
c_func
(paren
id|mk_pte
c_func
(paren
id|ZERO_PAGE
c_func
(paren
id|addr
)paren
comma
id|vma-&gt;vm_page_prot
)paren
)paren
suffix:semicolon
multiline_comment|/* ..except if it&squot;s a write access */
r_if
c_cond
(paren
id|write_access
)paren
(brace
multiline_comment|/* Allocate our own private page. */
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|anon_vma_prepare
c_func
(paren
id|vma
)paren
)paren
)paren
r_goto
id|no_mem
suffix:semicolon
id|page
op_assign
id|alloc_zeroed_user_highpage
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_mem
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page_table
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_none
c_func
(paren
op_star
id|page_table
)paren
)paren
(brace
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|mm-&gt;rss
op_increment
suffix:semicolon
id|entry
op_assign
id|maybe_mkwrite
c_func
(paren
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
)paren
comma
id|vma
)paren
suffix:semicolon
id|lru_cache_add_active
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_add_anon_rmap
c_func
(paren
id|page
comma
id|vma
comma
id|addr
)paren
suffix:semicolon
)brace
id|set_pte_at
c_func
(paren
id|mm
comma
id|addr
comma
id|page_table
comma
id|entry
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
multiline_comment|/* No need to invalidate - it was non-present before */
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|addr
comma
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|VM_FAULT_MINOR
suffix:semicolon
id|no_mem
suffix:colon
r_return
id|VM_FAULT_OOM
suffix:semicolon
)brace
multiline_comment|/*&n; * do_no_page() tries to create a new page mapping. It aggressively&n; * tries to share with existing pages, but makes a separate copy if&n; * the &quot;write_access&quot; parameter is true in order to avoid the next&n; * page fault.&n; *&n; * As this is called only for pages that do not currently exist, we&n; * do not need to flush old virtual caches or the TLB.&n; *&n; * This is called with the MM semaphore held and the page table&n; * spinlock held. Exit with the spinlock released.&n; */
r_static
r_int
DECL|function|do_no_page
id|do_no_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|write_access
comma
id|pte_t
op_star
id|page_table
comma
id|pmd_t
op_star
id|pmd
)paren
(brace
r_struct
id|page
op_star
id|new_page
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
l_int|NULL
suffix:semicolon
id|pte_t
id|entry
suffix:semicolon
r_int
r_int
id|sequence
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
id|VM_FAULT_MINOR
suffix:semicolon
r_int
id|anon
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_ops
op_logical_or
op_logical_neg
id|vma-&gt;vm_ops-&gt;nopage
)paren
r_return
id|do_anonymous_page
c_func
(paren
id|mm
comma
id|vma
comma
id|page_table
comma
id|pmd
comma
id|write_access
comma
id|address
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
(brace
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_mapping
suffix:semicolon
id|sequence
op_assign
id|mapping-&gt;truncate_count
suffix:semicolon
id|smp_rmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* serializes i_size against truncate_count */
)brace
id|retry
suffix:colon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|new_page
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|nopage
c_func
(paren
id|vma
comma
id|address
op_amp
id|PAGE_MASK
comma
op_amp
id|ret
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No smp_rmb is needed here as long as there&squot;s a full&n;&t; * spin_lock/unlock sequence inside the -&gt;nopage callback&n;&t; * (for the pagecache lookup) that acts as an implicit&n;&t; * smp_mb() and prevents the i_size read to happen&n;&t; * after the next truncate_count read.&n;&t; */
multiline_comment|/* no page was available -- either SIGBUS or OOM */
r_if
c_cond
(paren
id|new_page
op_eq
id|NOPAGE_SIGBUS
)paren
r_return
id|VM_FAULT_SIGBUS
suffix:semicolon
r_if
c_cond
(paren
id|new_page
op_eq
id|NOPAGE_OOM
)paren
r_return
id|VM_FAULT_OOM
suffix:semicolon
multiline_comment|/*&n;&t; * Should we do an early C-O-W break?&n;&t; */
r_if
c_cond
(paren
id|write_access
op_logical_and
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|anon_vma_prepare
c_func
(paren
id|vma
)paren
)paren
)paren
r_goto
id|oom
suffix:semicolon
id|page
op_assign
id|alloc_page_vma
c_func
(paren
id|GFP_HIGHUSER
comma
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|oom
suffix:semicolon
id|copy_user_highpage
c_func
(paren
id|page
comma
id|new_page
comma
id|address
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|new_page
op_assign
id|page
suffix:semicolon
id|anon
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a file-backed vma, someone could have truncated or otherwise&n;&t; * invalidated this page.  If unmap_mapping_range got called,&n;&t; * retry getting the page.&n;&t; */
r_if
c_cond
(paren
id|mapping
op_logical_and
id|unlikely
c_func
(paren
id|sequence
op_ne
id|mapping-&gt;truncate_count
)paren
)paren
(brace
id|sequence
op_assign
id|mapping-&gt;truncate_count
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|page_table
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This silly early PAGE_DIRTY setting removes a race&n;&t; * due to the bad i386 page protection. But it&squot;s valid&n;&t; * for other architectures too.&n;&t; *&n;&t; * Note that if write_access is true, we either now have&n;&t; * an exclusive copy of the page, or this is a shared mapping,&n;&t; * so we can make it writable and dirty to avoid having to&n;&t; * handle that later.&n;&t; */
multiline_comment|/* Only go through if we didn&squot;t race with anybody else... */
r_if
c_cond
(paren
id|pte_none
c_func
(paren
op_star
id|page_table
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|new_page
)paren
)paren
op_increment
id|mm-&gt;rss
suffix:semicolon
id|flush_icache_page
c_func
(paren
id|vma
comma
id|new_page
)paren
suffix:semicolon
id|entry
op_assign
id|mk_pte
c_func
(paren
id|new_page
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_access
)paren
id|entry
op_assign
id|maybe_mkwrite
c_func
(paren
id|pte_mkdirty
c_func
(paren
id|entry
)paren
comma
id|vma
)paren
suffix:semicolon
id|set_pte_at
c_func
(paren
id|mm
comma
id|address
comma
id|page_table
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|anon
)paren
(brace
id|lru_cache_add_active
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_add_anon_rmap
c_func
(paren
id|new_page
comma
id|vma
comma
id|address
)paren
suffix:semicolon
)brace
r_else
id|page_add_file_rmap
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* One of our sibling threads was faster, back out. */
id|pte_unmap
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* no need to invalidate: a not-present page shouldn&squot;t be cached */
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|address
comma
id|entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
id|oom
suffix:colon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|ret
op_assign
id|VM_FAULT_OOM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Fault of a previously existing named mapping. Repopulate the pte&n; * from the encoded file_pte if possible. This enables swappable&n; * nonlinear vmas.&n; */
DECL|function|do_file_page
r_static
r_int
id|do_file_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|write_access
comma
id|pte_t
op_star
id|pte
comma
id|pmd_t
op_star
id|pmd
)paren
(brace
r_int
r_int
id|pgoff
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|vma-&gt;vm_ops
op_logical_or
op_logical_neg
id|vma-&gt;vm_ops-&gt;nopage
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fall back to the linear mapping if the fs does not support&n;&t; * -&gt;populate:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_ops
op_logical_or
op_logical_neg
id|vma-&gt;vm_ops-&gt;populate
op_logical_or
(paren
id|write_access
op_logical_and
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
)paren
)paren
(brace
id|pte_clear
c_func
(paren
id|mm
comma
id|address
comma
id|pte
)paren
suffix:semicolon
r_return
id|do_no_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|write_access
comma
id|pte
comma
id|pmd
)paren
suffix:semicolon
)brace
id|pgoff
op_assign
id|pte_to_pgoff
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|err
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|populate
c_func
(paren
id|vma
comma
id|address
op_amp
id|PAGE_MASK
comma
id|PAGE_SIZE
comma
id|vma-&gt;vm_page_prot
comma
id|pgoff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
r_return
id|VM_FAULT_OOM
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|VM_FAULT_SIGBUS
suffix:semicolon
r_return
id|VM_FAULT_MAJOR
suffix:semicolon
)brace
multiline_comment|/*&n; * These routines also need to handle stuff like marking pages dirty&n; * and/or accessed for architectures that don&squot;t do it in hardware (most&n; * RISC architectures).  The early dirtying is also good on the i386.&n; *&n; * There is also a hook called &quot;update_mmu_cache()&quot; that architectures&n; * with external mmu caches can use to update those (ie the Sparc or&n; * PowerPC hashed page tables that act as extended TLBs).&n; *&n; * Note the &quot;page_table_lock&quot;. It is to protect against kswapd removing&n; * pages from under us. Note that kswapd only ever _removes_ pages, never&n; * adds them. As such, once we have noticed that the page is not present,&n; * we can drop the lock early.&n; *&n; * The adding of pages is protected by the MM semaphore (which we hold),&n; * so we don&squot;t need to worry about a page being suddenly been added into&n; * our VM.&n; *&n; * We enter with the pagetable spinlock held, we are supposed to&n; * release it when done.&n; */
DECL|function|handle_pte_fault
r_static
r_inline
r_int
id|handle_pte_fault
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|write_access
comma
id|pte_t
op_star
id|pte
comma
id|pmd_t
op_star
id|pmd
)paren
(brace
id|pte_t
id|entry
suffix:semicolon
id|entry
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|entry
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If it truly wasn&squot;t present, we know that kswapd&n;&t;&t; * and the PTE updates will not touch it later. So&n;&t;&t; * drop the lock.&n;&t;&t; */
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|entry
)paren
)paren
r_return
id|do_no_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|write_access
comma
id|pte
comma
id|pmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_file
c_func
(paren
id|entry
)paren
)paren
r_return
id|do_file_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|write_access
comma
id|pte
comma
id|pmd
)paren
suffix:semicolon
r_return
id|do_swap_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|pte
comma
id|pmd
comma
id|entry
comma
id|write_access
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_access
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pte_write
c_func
(paren
id|entry
)paren
)paren
r_return
id|do_wp_page
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|pte
comma
id|pmd
comma
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|pte_mkdirty
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|pte_mkyoung
c_func
(paren
id|entry
)paren
suffix:semicolon
id|ptep_set_access_flags
c_func
(paren
id|vma
comma
id|address
comma
id|pte
comma
id|entry
comma
id|write_access
)paren
suffix:semicolon
id|update_mmu_cache
c_func
(paren
id|vma
comma
id|address
comma
id|entry
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|VM_FAULT_MINOR
suffix:semicolon
)brace
multiline_comment|/*&n; * By the time we get here, we already hold the mm semaphore&n; */
DECL|function|handle_mm_fault
r_int
id|handle_mm_fault
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|write_access
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgfault
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|vma
)paren
)paren
r_return
id|VM_FAULT_SIGBUS
suffix:semicolon
multiline_comment|/* mapping truncation does this. */
multiline_comment|/*&n;&t; * We need the page table lock to synchronize with kswapd&n;&t; * and the SMP-safe atomic PTE updates.&n;&t; */
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|pud
op_assign
id|pud_alloc
c_func
(paren
id|mm
comma
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pud
)paren
r_goto
id|oom
suffix:semicolon
id|pmd
op_assign
id|pmd_alloc
c_func
(paren
id|mm
comma
id|pud
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
r_goto
id|oom
suffix:semicolon
id|pte
op_assign
id|pte_alloc_map
c_func
(paren
id|mm
comma
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
r_goto
id|oom
suffix:semicolon
r_return
id|handle_pte_fault
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|write_access
comma
id|pte
comma
id|pmd
)paren
suffix:semicolon
id|oom
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|VM_FAULT_OOM
suffix:semicolon
)brace
macro_line|#ifndef __PAGETABLE_PUD_FOLDED
multiline_comment|/*&n; * Allocate page upper directory.&n; *&n; * We&squot;ve already handled the fast-path in-line, and we own the&n; * page table lock.&n; */
DECL|function|__pud_alloc
id|pud_t
id|fastcall
op_star
id|__pud_alloc
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
id|pud_t
op_star
r_new
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_new
op_assign
id|pud_alloc_one
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Because we dropped the lock, we should re-check the&n;&t; * entry, as somebody else could have populated it..&n;&t; */
r_if
c_cond
(paren
id|pgd_present
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pud_free
c_func
(paren
r_new
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pgd_populate
c_func
(paren
id|mm
comma
id|pgd
comma
r_new
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|pud_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
)brace
macro_line|#endif /* __PAGETABLE_PUD_FOLDED */
macro_line|#ifndef __PAGETABLE_PMD_FOLDED
multiline_comment|/*&n; * Allocate page middle directory.&n; *&n; * We&squot;ve already handled the fast-path in-line, and we own the&n; * page table lock.&n; */
DECL|function|__pmd_alloc
id|pmd_t
id|fastcall
op_star
id|__pmd_alloc
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|address
)paren
(brace
id|pmd_t
op_star
r_new
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_new
op_assign
id|pmd_alloc_one
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Because we dropped the lock, we should re-check the&n;&t; * entry, as somebody else could have populated it..&n;&t; */
macro_line|#ifndef __ARCH_HAS_4LEVEL_HACK
r_if
c_cond
(paren
id|pud_present
c_func
(paren
op_star
id|pud
)paren
)paren
(brace
id|pmd_free
c_func
(paren
r_new
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pud_populate
c_func
(paren
id|mm
comma
id|pud
comma
r_new
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|pgd_present
c_func
(paren
op_star
id|pud
)paren
)paren
(brace
id|pmd_free
c_func
(paren
r_new
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pgd_populate
c_func
(paren
id|mm
comma
id|pud
comma
r_new
)paren
suffix:semicolon
macro_line|#endif /* __ARCH_HAS_4LEVEL_HACK */
id|out
suffix:colon
r_return
id|pmd_offset
c_func
(paren
id|pud
comma
id|address
)paren
suffix:semicolon
)brace
macro_line|#endif /* __PAGETABLE_PMD_FOLDED */
DECL|function|make_pages_present
r_int
id|make_pages_present
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
(brace
r_int
id|ret
comma
id|len
comma
id|write
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|write
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|vma-&gt;vm_end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|len
op_assign
(paren
id|end
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
op_minus
id|addr
op_div
id|PAGE_SIZE
suffix:semicolon
id|ret
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
id|current-&gt;mm
comma
id|addr
comma
id|len
comma
id|write
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_return
id|ret
op_eq
id|len
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Map a vmalloc()-space virtual address to the physical page.&n; */
DECL|function|vmalloc_to_page
r_struct
id|page
op_star
id|vmalloc_to_page
c_func
(paren
r_void
op_star
id|vmalloc_addr
)paren
(brace
r_int
r_int
id|addr
op_assign
(paren
r_int
r_int
)paren
id|vmalloc_addr
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
id|pgd_t
op_star
id|pgd
op_assign
id|pgd_offset_k
c_func
(paren
id|addr
)paren
suffix:semicolon
id|pud_t
op_star
id|pud
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pud_none
c_func
(paren
op_star
id|pud
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
id|page
op_assign
id|pte_page
c_func
(paren
id|pte
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|ptep
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|page
suffix:semicolon
)brace
DECL|variable|vmalloc_to_page
id|EXPORT_SYMBOL
c_func
(paren
id|vmalloc_to_page
)paren
suffix:semicolon
multiline_comment|/*&n; * Map a vmalloc()-space virtual address to the physical page frame number.&n; */
DECL|function|vmalloc_to_pfn
r_int
r_int
id|vmalloc_to_pfn
c_func
(paren
r_void
op_star
id|vmalloc_addr
)paren
(brace
r_return
id|page_to_pfn
c_func
(paren
id|vmalloc_to_page
c_func
(paren
id|vmalloc_addr
)paren
)paren
suffix:semicolon
)brace
DECL|variable|vmalloc_to_pfn
id|EXPORT_SYMBOL
c_func
(paren
id|vmalloc_to_pfn
)paren
suffix:semicolon
multiline_comment|/*&n; * update_mem_hiwater&n; *&t;- update per process rss and vm high water data&n; */
DECL|function|update_mem_hiwater
r_void
id|update_mem_hiwater
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;hiwater_rss
OL
id|tsk-&gt;mm-&gt;rss
)paren
id|tsk-&gt;mm-&gt;hiwater_rss
op_assign
id|tsk-&gt;mm-&gt;rss
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;hiwater_vm
OL
id|tsk-&gt;mm-&gt;total_vm
)paren
id|tsk-&gt;mm-&gt;hiwater_vm
op_assign
id|tsk-&gt;mm-&gt;total_vm
suffix:semicolon
)brace
)brace
macro_line|#if !defined(__HAVE_ARCH_GATE_AREA)
macro_line|#if defined(AT_SYSINFO_EHDR)
DECL|variable|gate_vma
r_struct
id|vm_area_struct
id|gate_vma
suffix:semicolon
DECL|function|gate_vma_init
r_static
r_int
id|__init
id|gate_vma_init
c_func
(paren
r_void
)paren
(brace
id|gate_vma.vm_mm
op_assign
l_int|NULL
suffix:semicolon
id|gate_vma.vm_start
op_assign
id|FIXADDR_USER_START
suffix:semicolon
id|gate_vma.vm_end
op_assign
id|FIXADDR_USER_END
suffix:semicolon
id|gate_vma.vm_page_prot
op_assign
id|PAGE_READONLY
suffix:semicolon
id|gate_vma.vm_flags
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|gate_vma_init
id|__initcall
c_func
(paren
id|gate_vma_init
)paren
suffix:semicolon
macro_line|#endif
DECL|function|get_gate_vma
r_struct
id|vm_area_struct
op_star
id|get_gate_vma
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
macro_line|#ifdef AT_SYSINFO_EHDR
r_return
op_amp
id|gate_vma
suffix:semicolon
macro_line|#else
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
)brace
DECL|function|in_gate_area_no_task
r_int
id|in_gate_area_no_task
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
macro_line|#ifdef AT_SYSINFO_EHDR
r_if
c_cond
(paren
(paren
id|addr
op_ge
id|FIXADDR_USER_START
)paren
op_logical_and
(paren
id|addr
OL
id|FIXADDR_USER_END
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* __HAVE_ARCH_GATE_AREA */
eof
